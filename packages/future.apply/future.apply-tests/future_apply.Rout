
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:59:14.788] plan(): Setting new future strategy stack:
[17:59:14.789] List of future strategies:
[17:59:14.789] 1. sequential:
[17:59:14.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:14.789]    - tweaked: FALSE
[17:59:14.789]    - call: future::plan("sequential")
[17:59:14.818] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:59:14.935] plan(): Setting new future strategy stack:
[17:59:14.935] List of future strategies:
[17:59:14.935] 1. sequential:
[17:59:14.935]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:14.935]    - tweaked: FALSE
[17:59:14.935]    - call: plan(strategy)
[17:59:14.960] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[17:59:14.962] getGlobalsAndPackagesXApply() ...
[17:59:14.963]  - future.globals: TRUE
[17:59:14.964] getGlobalsAndPackages() ...
[17:59:14.964] Searching for globals...
[17:59:15.046] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:59:15.047] Searching for globals ... DONE
[17:59:15.047] Resolving globals: FALSE
[17:59:15.052] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:59:15.053] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:59:15.053] - globals: [1] ‘FUN’
[17:59:15.053] 
[17:59:15.053] getGlobalsAndPackages() ... DONE
[17:59:15.053]  - globals found/used: [n=1] ‘FUN’
[17:59:15.054]  - needed namespaces: [n=0] 
[17:59:15.056] Finding globals ... DONE
[17:59:15.057]  - use_args: TRUE
[17:59:15.057]  - Getting '...' globals ...
[17:59:15.058] resolve() on list ...
[17:59:15.059]  recursive: 0
[17:59:15.059]  length: 1
[17:59:15.059]  elements: ‘...’
[17:59:15.060]  length: 0 (resolved future 1)
[17:59:15.060] resolve() on list ... DONE
[17:59:15.060]    - '...' content: [n=0] 
[17:59:15.060] List of 1
[17:59:15.060]  $ ...: list()
[17:59:15.060]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.060]  - attr(*, "where")=List of 1
[17:59:15.060]   ..$ ...:<environment: 0x56085abd9fd8> 
[17:59:15.060]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.060]  - attr(*, "resolved")= logi TRUE
[17:59:15.060]  - attr(*, "total_size")= num NA
[17:59:15.070]  - Getting '...' globals ... DONE
[17:59:15.070] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:15.071] List of 2
[17:59:15.071]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:15.071]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:15.071]  $ ...          : list()
[17:59:15.071]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.071]  - attr(*, "where")=List of 2
[17:59:15.071]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:15.071]   ..$ ...          :<environment: 0x56085abd9fd8> 
[17:59:15.071]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.071]  - attr(*, "resolved")= logi FALSE
[17:59:15.071]  - attr(*, "total_size")= num 354224
[17:59:15.076] Packages to be attached in all futures: [n=0] 
[17:59:15.076] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.077] future_lapply() ...
[17:59:15.148] Number of chunks: 1
[17:59:15.148] getGlobalsAndPackagesXApply() ...
[17:59:15.148]  - future.globals: <name-value list> with names ‘list()’
[17:59:15.149]  - use_args: TRUE
[17:59:15.149] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:15.149] List of 2
[17:59:15.149]  $ ...          : list()
[17:59:15.149]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.149]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:15.149]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:15.149]  - attr(*, "where")=List of 2
[17:59:15.149]   ..$ ...          :<environment: 0x56085abd9fd8> 
[17:59:15.149]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:15.149]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.149]  - attr(*, "resolved")= logi FALSE
[17:59:15.149]  - attr(*, "total_size")= num NA
[17:59:15.156] Packages to be attached in all futures: [n=0] 
[17:59:15.156] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.157] Number of futures (= number of chunks): 1
[17:59:15.157] Launching 1 futures (chunks) ...
[17:59:15.157] Chunk #1 of 1 ...
[17:59:15.158]  - seeds: <none>
[17:59:15.158]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.158] getGlobalsAndPackages() ...
[17:59:15.158] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.159] Resolving globals: FALSE
[17:59:15.159] Tweak future expression to call with '...' arguments ...
[17:59:15.159] {
[17:59:15.159]     do.call(function(...) {
[17:59:15.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.159]             on.exit(options(oopts), add = TRUE)
[17:59:15.159]         }
[17:59:15.159]         {
[17:59:15.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.159]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.159]             })
[17:59:15.159]         }
[17:59:15.159]     }, args = future.call.arguments)
[17:59:15.159] }
[17:59:15.160] Tweak future expression to call with '...' arguments ... DONE
[17:59:15.160] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.161] 
[17:59:15.161] getGlobalsAndPackages() ... DONE
[17:59:15.162] run() for ‘Future’ ...
[17:59:15.162] - state: ‘created’
[17:59:15.163] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:15.163] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.164] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:15.164]   - Field: ‘label’
[17:59:15.164]   - Field: ‘local’
[17:59:15.164]   - Field: ‘owner’
[17:59:15.167]   - Field: ‘envir’
[17:59:15.167]   - Field: ‘packages’
[17:59:15.167]   - Field: ‘gc’
[17:59:15.167]   - Field: ‘conditions’
[17:59:15.168]   - Field: ‘expr’
[17:59:15.168]   - Field: ‘uuid’
[17:59:15.168]   - Field: ‘seed’
[17:59:15.168]   - Field: ‘version’
[17:59:15.168]   - Field: ‘result’
[17:59:15.169]   - Field: ‘asynchronous’
[17:59:15.169]   - Field: ‘calls’
[17:59:15.169]   - Field: ‘globals’
[17:59:15.169]   - Field: ‘stdout’
[17:59:15.169]   - Field: ‘earlySignal’
[17:59:15.169]   - Field: ‘lazy’
[17:59:15.170]   - Field: ‘state’
[17:59:15.170] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:15.170] - Launch lazy future ...
[17:59:15.171] Packages needed by the future expression (n = 0): <none>
[17:59:15.172] Packages needed by future strategies (n = 0): <none>
[17:59:15.173] {
[17:59:15.173]     {
[17:59:15.173]         {
[17:59:15.173]             ...future.startTime <- base::Sys.time()
[17:59:15.173]             {
[17:59:15.173]                 {
[17:59:15.173]                   {
[17:59:15.173]                     base::local({
[17:59:15.173]                       has_future <- base::requireNamespace("future", 
[17:59:15.173]                         quietly = TRUE)
[17:59:15.173]                       if (has_future) {
[17:59:15.173]                         ns <- base::getNamespace("future")
[17:59:15.173]                         version <- ns[[".package"]][["version"]]
[17:59:15.173]                         if (is.null(version)) 
[17:59:15.173]                           version <- utils::packageVersion("future")
[17:59:15.173]                       }
[17:59:15.173]                       else {
[17:59:15.173]                         version <- NULL
[17:59:15.173]                       }
[17:59:15.173]                       if (!has_future || version < "1.8.0") {
[17:59:15.173]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:15.173]                           "", base::R.version$version.string), 
[17:59:15.173]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:15.173]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:15.173]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:15.173]                             "release", "version")], collapse = " "), 
[17:59:15.173]                           hostname = base::Sys.info()[["nodename"]])
[17:59:15.173]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:15.173]                           info)
[17:59:15.173]                         info <- base::paste(info, collapse = "; ")
[17:59:15.173]                         if (!has_future) {
[17:59:15.173]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:15.173]                             info)
[17:59:15.173]                         }
[17:59:15.173]                         else {
[17:59:15.173]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:15.173]                             info, version)
[17:59:15.173]                         }
[17:59:15.173]                         base::stop(msg)
[17:59:15.173]                       }
[17:59:15.173]                     })
[17:59:15.173]                   }
[17:59:15.173]                   ...future.strategy.old <- future::plan("list")
[17:59:15.173]                   options(future.plan = NULL)
[17:59:15.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:15.173]                 }
[17:59:15.173]                 ...future.workdir <- getwd()
[17:59:15.173]             }
[17:59:15.173]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:15.173]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:15.173]         }
[17:59:15.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:15.173]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:15.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:15.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:15.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:15.173]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:15.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:15.173]             base::names(...future.oldOptions))
[17:59:15.173]     }
[17:59:15.173]     if (FALSE) {
[17:59:15.173]     }
[17:59:15.173]     else {
[17:59:15.173]         if (TRUE) {
[17:59:15.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:15.173]                 open = "w")
[17:59:15.173]         }
[17:59:15.173]         else {
[17:59:15.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:15.173]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:15.173]         }
[17:59:15.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:15.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:15.173]             base::sink(type = "output", split = FALSE)
[17:59:15.173]             base::close(...future.stdout)
[17:59:15.173]         }, add = TRUE)
[17:59:15.173]     }
[17:59:15.173]     ...future.frame <- base::sys.nframe()
[17:59:15.173]     ...future.conditions <- base::list()
[17:59:15.173]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:15.173]     if (FALSE) {
[17:59:15.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:15.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:15.173]     }
[17:59:15.173]     ...future.result <- base::tryCatch({
[17:59:15.173]         base::withCallingHandlers({
[17:59:15.173]             ...future.value <- base::withVisible(base::local({
[17:59:15.173]                 do.call(function(...) {
[17:59:15.173]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.173]                   if (!identical(...future.globals.maxSize.org, 
[17:59:15.173]                     ...future.globals.maxSize)) {
[17:59:15.173]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.173]                     on.exit(options(oopts), add = TRUE)
[17:59:15.173]                   }
[17:59:15.173]                   {
[17:59:15.173]                     lapply(seq_along(...future.elements_ii), 
[17:59:15.173]                       FUN = function(jj) {
[17:59:15.173]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.173]                         ...future.FUN(...future.X_jj, ...)
[17:59:15.173]                       })
[17:59:15.173]                   }
[17:59:15.173]                 }, args = future.call.arguments)
[17:59:15.173]             }))
[17:59:15.173]             future::FutureResult(value = ...future.value$value, 
[17:59:15.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.173]                   ...future.rng), globalenv = if (FALSE) 
[17:59:15.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:15.173]                     ...future.globalenv.names))
[17:59:15.173]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:15.173]         }, condition = base::local({
[17:59:15.173]             c <- base::c
[17:59:15.173]             inherits <- base::inherits
[17:59:15.173]             invokeRestart <- base::invokeRestart
[17:59:15.173]             length <- base::length
[17:59:15.173]             list <- base::list
[17:59:15.173]             seq.int <- base::seq.int
[17:59:15.173]             signalCondition <- base::signalCondition
[17:59:15.173]             sys.calls <- base::sys.calls
[17:59:15.173]             `[[` <- base::`[[`
[17:59:15.173]             `+` <- base::`+`
[17:59:15.173]             `<<-` <- base::`<<-`
[17:59:15.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:15.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:15.173]                   3L)]
[17:59:15.173]             }
[17:59:15.173]             function(cond) {
[17:59:15.173]                 is_error <- inherits(cond, "error")
[17:59:15.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:15.173]                   NULL)
[17:59:15.173]                 if (is_error) {
[17:59:15.173]                   sessionInformation <- function() {
[17:59:15.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:15.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:15.173]                       search = base::search(), system = base::Sys.info())
[17:59:15.173]                   }
[17:59:15.173]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:15.173]                     cond$call), session = sessionInformation(), 
[17:59:15.173]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:15.173]                   signalCondition(cond)
[17:59:15.173]                 }
[17:59:15.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:15.173]                 "immediateCondition"))) {
[17:59:15.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:15.173]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:15.173]                   if (TRUE && !signal) {
[17:59:15.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.173]                     {
[17:59:15.173]                       inherits <- base::inherits
[17:59:15.173]                       invokeRestart <- base::invokeRestart
[17:59:15.173]                       is.null <- base::is.null
[17:59:15.173]                       muffled <- FALSE
[17:59:15.173]                       if (inherits(cond, "message")) {
[17:59:15.173]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.173]                         if (muffled) 
[17:59:15.173]                           invokeRestart("muffleMessage")
[17:59:15.173]                       }
[17:59:15.173]                       else if (inherits(cond, "warning")) {
[17:59:15.173]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.173]                         if (muffled) 
[17:59:15.173]                           invokeRestart("muffleWarning")
[17:59:15.173]                       }
[17:59:15.173]                       else if (inherits(cond, "condition")) {
[17:59:15.173]                         if (!is.null(pattern)) {
[17:59:15.173]                           computeRestarts <- base::computeRestarts
[17:59:15.173]                           grepl <- base::grepl
[17:59:15.173]                           restarts <- computeRestarts(cond)
[17:59:15.173]                           for (restart in restarts) {
[17:59:15.173]                             name <- restart$name
[17:59:15.173]                             if (is.null(name)) 
[17:59:15.173]                               next
[17:59:15.173]                             if (!grepl(pattern, name)) 
[17:59:15.173]                               next
[17:59:15.173]                             invokeRestart(restart)
[17:59:15.173]                             muffled <- TRUE
[17:59:15.173]                             break
[17:59:15.173]                           }
[17:59:15.173]                         }
[17:59:15.173]                       }
[17:59:15.173]                       invisible(muffled)
[17:59:15.173]                     }
[17:59:15.173]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.173]                   }
[17:59:15.173]                 }
[17:59:15.173]                 else {
[17:59:15.173]                   if (TRUE) {
[17:59:15.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.173]                     {
[17:59:15.173]                       inherits <- base::inherits
[17:59:15.173]                       invokeRestart <- base::invokeRestart
[17:59:15.173]                       is.null <- base::is.null
[17:59:15.173]                       muffled <- FALSE
[17:59:15.173]                       if (inherits(cond, "message")) {
[17:59:15.173]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.173]                         if (muffled) 
[17:59:15.173]                           invokeRestart("muffleMessage")
[17:59:15.173]                       }
[17:59:15.173]                       else if (inherits(cond, "warning")) {
[17:59:15.173]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.173]                         if (muffled) 
[17:59:15.173]                           invokeRestart("muffleWarning")
[17:59:15.173]                       }
[17:59:15.173]                       else if (inherits(cond, "condition")) {
[17:59:15.173]                         if (!is.null(pattern)) {
[17:59:15.173]                           computeRestarts <- base::computeRestarts
[17:59:15.173]                           grepl <- base::grepl
[17:59:15.173]                           restarts <- computeRestarts(cond)
[17:59:15.173]                           for (restart in restarts) {
[17:59:15.173]                             name <- restart$name
[17:59:15.173]                             if (is.null(name)) 
[17:59:15.173]                               next
[17:59:15.173]                             if (!grepl(pattern, name)) 
[17:59:15.173]                               next
[17:59:15.173]                             invokeRestart(restart)
[17:59:15.173]                             muffled <- TRUE
[17:59:15.173]                             break
[17:59:15.173]                           }
[17:59:15.173]                         }
[17:59:15.173]                       }
[17:59:15.173]                       invisible(muffled)
[17:59:15.173]                     }
[17:59:15.173]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.173]                   }
[17:59:15.173]                 }
[17:59:15.173]             }
[17:59:15.173]         }))
[17:59:15.173]     }, error = function(ex) {
[17:59:15.173]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:15.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.173]                 ...future.rng), started = ...future.startTime, 
[17:59:15.173]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:15.173]             version = "1.8"), class = "FutureResult")
[17:59:15.173]     }, finally = {
[17:59:15.173]         if (!identical(...future.workdir, getwd())) 
[17:59:15.173]             setwd(...future.workdir)
[17:59:15.173]         {
[17:59:15.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:15.173]                 ...future.oldOptions$nwarnings <- NULL
[17:59:15.173]             }
[17:59:15.173]             base::options(...future.oldOptions)
[17:59:15.173]             if (.Platform$OS.type == "windows") {
[17:59:15.173]                 old_names <- names(...future.oldEnvVars)
[17:59:15.173]                 envs <- base::Sys.getenv()
[17:59:15.173]                 names <- names(envs)
[17:59:15.173]                 common <- intersect(names, old_names)
[17:59:15.173]                 added <- setdiff(names, old_names)
[17:59:15.173]                 removed <- setdiff(old_names, names)
[17:59:15.173]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:15.173]                   envs[common]]
[17:59:15.173]                 NAMES <- toupper(changed)
[17:59:15.173]                 args <- list()
[17:59:15.173]                 for (kk in seq_along(NAMES)) {
[17:59:15.173]                   name <- changed[[kk]]
[17:59:15.173]                   NAME <- NAMES[[kk]]
[17:59:15.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.173]                     next
[17:59:15.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.173]                 }
[17:59:15.173]                 NAMES <- toupper(added)
[17:59:15.173]                 for (kk in seq_along(NAMES)) {
[17:59:15.173]                   name <- added[[kk]]
[17:59:15.173]                   NAME <- NAMES[[kk]]
[17:59:15.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.173]                     next
[17:59:15.173]                   args[[name]] <- ""
[17:59:15.173]                 }
[17:59:15.173]                 NAMES <- toupper(removed)
[17:59:15.173]                 for (kk in seq_along(NAMES)) {
[17:59:15.173]                   name <- removed[[kk]]
[17:59:15.173]                   NAME <- NAMES[[kk]]
[17:59:15.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.173]                     next
[17:59:15.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.173]                 }
[17:59:15.173]                 if (length(args) > 0) 
[17:59:15.173]                   base::do.call(base::Sys.setenv, args = args)
[17:59:15.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:15.173]             }
[17:59:15.173]             else {
[17:59:15.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:15.173]             }
[17:59:15.173]             {
[17:59:15.173]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:15.173]                   0L) {
[17:59:15.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:15.173]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:15.173]                   base::options(opts)
[17:59:15.173]                 }
[17:59:15.173]                 {
[17:59:15.173]                   {
[17:59:15.173]                     NULL
[17:59:15.173]                     RNGkind("Mersenne-Twister")
[17:59:15.173]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:15.173]                       inherits = FALSE)
[17:59:15.173]                   }
[17:59:15.173]                   options(future.plan = NULL)
[17:59:15.173]                   if (is.na(NA_character_)) 
[17:59:15.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:15.173]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:15.173]                     .init = FALSE)
[17:59:15.173]                 }
[17:59:15.173]             }
[17:59:15.173]         }
[17:59:15.173]     })
[17:59:15.173]     if (TRUE) {
[17:59:15.173]         base::sink(type = "output", split = FALSE)
[17:59:15.173]         if (TRUE) {
[17:59:15.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:15.173]         }
[17:59:15.173]         else {
[17:59:15.173]             ...future.result["stdout"] <- base::list(NULL)
[17:59:15.173]         }
[17:59:15.173]         base::close(...future.stdout)
[17:59:15.173]         ...future.stdout <- NULL
[17:59:15.173]     }
[17:59:15.173]     ...future.result$conditions <- ...future.conditions
[17:59:15.173]     ...future.result$finished <- base::Sys.time()
[17:59:15.173]     ...future.result
[17:59:15.173] }
[17:59:15.177] assign_globals() ...
[17:59:15.177] List of 5
[17:59:15.177]  $ future.call.arguments    : list()
[17:59:15.177]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.177]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:15.177]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:15.177]  $ ...future.elements_ii    :List of 2
[17:59:15.177]   ..$ : num [1:4] 1 3 1 7
[17:59:15.177]   ..$ : num [1:4] 2 4 6 8
[17:59:15.177]  $ ...future.seeds_ii       : NULL
[17:59:15.177]  $ ...future.globals.maxSize: num Inf
[17:59:15.177]  - attr(*, "resolved")= logi FALSE
[17:59:15.177]  - attr(*, "total_size")= num NA
[17:59:15.177]  - attr(*, "where")=List of 5
[17:59:15.177]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:15.177]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:15.177]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:15.177]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:15.177]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:15.177]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.177]  - attr(*, "already-done")= logi TRUE
[17:59:15.187] - copied ‘future.call.arguments’ to environment
[17:59:15.187] - copied ‘...future.FUN’ to environment
[17:59:15.188] - copied ‘...future.elements_ii’ to environment
[17:59:15.188] - copied ‘...future.seeds_ii’ to environment
[17:59:15.188] - copied ‘...future.globals.maxSize’ to environment
[17:59:15.188] assign_globals() ... done
[17:59:15.189] plan(): Setting new future strategy stack:
[17:59:15.189] List of future strategies:
[17:59:15.189] 1. sequential:
[17:59:15.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.189]    - tweaked: FALSE
[17:59:15.189]    - call: NULL
[17:59:15.190] plan(): nbrOfWorkers() = 1
[17:59:15.192] plan(): Setting new future strategy stack:
[17:59:15.193] List of future strategies:
[17:59:15.193] 1. sequential:
[17:59:15.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.193]    - tweaked: FALSE
[17:59:15.193]    - call: plan(strategy)
[17:59:15.194] plan(): nbrOfWorkers() = 1
[17:59:15.194] SequentialFuture started (and completed)
[17:59:15.195] - Launch lazy future ... done
[17:59:15.195] run() for ‘SequentialFuture’ ... done
[17:59:15.195] Created future:
[17:59:15.195] SequentialFuture:
[17:59:15.195] Label: ‘future_apply-1’
[17:59:15.195] Expression:
[17:59:15.195] {
[17:59:15.195]     do.call(function(...) {
[17:59:15.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.195]             on.exit(options(oopts), add = TRUE)
[17:59:15.195]         }
[17:59:15.195]         {
[17:59:15.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.195]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.195]             })
[17:59:15.195]         }
[17:59:15.195]     }, args = future.call.arguments)
[17:59:15.195] }
[17:59:15.195] Lazy evaluation: FALSE
[17:59:15.195] Asynchronous evaluation: FALSE
[17:59:15.195] Local evaluation: TRUE
[17:59:15.195] Environment: R_GlobalEnv
[17:59:15.195] Capture standard output: TRUE
[17:59:15.195] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:15.195] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:15.195] Packages: <none>
[17:59:15.195] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:15.195] Resolved: TRUE
[17:59:15.195] Value: 2.21 KiB of class ‘list’
[17:59:15.195] Early signaling: FALSE
[17:59:15.195] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:15.195] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.198] Chunk #1 of 1 ... DONE
[17:59:15.198] Launching 1 futures (chunks) ... DONE
[17:59:15.199] Resolving 1 futures (chunks) ...
[17:59:15.199] resolve() on list ...
[17:59:15.199]  recursive: 0
[17:59:15.199]  length: 1
[17:59:15.200] 
[17:59:15.200] resolved() for ‘SequentialFuture’ ...
[17:59:15.200] - state: ‘finished’
[17:59:15.200] - run: TRUE
[17:59:15.201] - result: ‘FutureResult’
[17:59:15.201] resolved() for ‘SequentialFuture’ ... done
[17:59:15.201] Future #1
[17:59:15.202] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:15.202] - nx: 1
[17:59:15.202] - relay: TRUE
[17:59:15.202] - stdout: TRUE
[17:59:15.202] - signal: TRUE
[17:59:15.203] - resignal: FALSE
[17:59:15.203] - force: TRUE
[17:59:15.203] - relayed: [n=1] FALSE
[17:59:15.203] - queued futures: [n=1] FALSE
[17:59:15.203]  - until=1
[17:59:15.203]  - relaying element #1
[17:59:15.204] - relayed: [n=1] TRUE
[17:59:15.204] - queued futures: [n=1] TRUE
[17:59:15.204] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:15.205]  length: 0 (resolved future 1)
[17:59:15.205] Relaying remaining futures
[17:59:15.205] signalConditionsASAP(NULL, pos=0) ...
[17:59:15.205] - nx: 1
[17:59:15.205] - relay: TRUE
[17:59:15.206] - stdout: TRUE
[17:59:15.206] - signal: TRUE
[17:59:15.206] - resignal: FALSE
[17:59:15.206] - force: TRUE
[17:59:15.206] - relayed: [n=1] TRUE
[17:59:15.206] - queued futures: [n=1] TRUE
 - flush all
[17:59:15.207] - relayed: [n=1] TRUE
[17:59:15.207] - queued futures: [n=1] TRUE
[17:59:15.207] signalConditionsASAP(NULL, pos=0) ... done
[17:59:15.207] resolve() on list ... DONE
[17:59:15.208]  - Number of value chunks collected: 1
[17:59:15.208] Resolving 1 futures (chunks) ... DONE
[17:59:15.208] Reducing values from 1 chunks ...
[17:59:15.208]  - Number of values collected after concatenation: 2
[17:59:15.208]  - Number of values expected: 2
[17:59:15.209] Reducing values from 1 chunks ... DONE
[17:59:15.209] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:59:15.210] getGlobalsAndPackagesXApply() ...
[17:59:15.211]  - future.globals: TRUE
[17:59:15.211] getGlobalsAndPackages() ...
[17:59:15.211] Searching for globals...
[17:59:15.284] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:59:15.284] Searching for globals ... DONE
[17:59:15.284] Resolving globals: FALSE
[17:59:15.288] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:59:15.289] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:59:15.289] - globals: [1] ‘FUN’
[17:59:15.289] 
[17:59:15.289] getGlobalsAndPackages() ... DONE
[17:59:15.290]  - globals found/used: [n=1] ‘FUN’
[17:59:15.290]  - needed namespaces: [n=0] 
[17:59:15.290] Finding globals ... DONE
[17:59:15.290]  - use_args: TRUE
[17:59:15.290]  - Getting '...' globals ...
[17:59:15.291] resolve() on list ...
[17:59:15.291]  recursive: 0
[17:59:15.291]  length: 1
[17:59:15.292]  elements: ‘...’
[17:59:15.292]  length: 0 (resolved future 1)
[17:59:15.292] resolve() on list ... DONE
[17:59:15.292]    - '...' content: [n=0] 
[17:59:15.292] List of 1
[17:59:15.292]  $ ...: list()
[17:59:15.292]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.292]  - attr(*, "where")=List of 1
[17:59:15.292]   ..$ ...:<environment: 0x56085b6526c0> 
[17:59:15.292]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.292]  - attr(*, "resolved")= logi TRUE
[17:59:15.292]  - attr(*, "total_size")= num NA
[17:59:15.298]  - Getting '...' globals ... DONE
[17:59:15.298] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:15.298] List of 2
[17:59:15.298]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:15.298]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:15.298]  $ ...          : list()
[17:59:15.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.298]  - attr(*, "where")=List of 2
[17:59:15.298]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:15.298]   ..$ ...          :<environment: 0x56085b6526c0> 
[17:59:15.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.298]  - attr(*, "resolved")= logi FALSE
[17:59:15.298]  - attr(*, "total_size")= num 354224
[17:59:15.304] Packages to be attached in all futures: [n=0] 
[17:59:15.304] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.304] future_lapply() ...
[17:59:15.376] Number of chunks: 1
[17:59:15.376] getGlobalsAndPackagesXApply() ...
[17:59:15.377]  - future.globals: <name-value list> with names ‘list()’
[17:59:15.377]  - use_args: TRUE
[17:59:15.377] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:15.378] List of 2
[17:59:15.378]  $ ...          : list()
[17:59:15.378]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.378]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:15.378]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:15.378]  - attr(*, "where")=List of 2
[17:59:15.378]   ..$ ...          :<environment: 0x56085b6526c0> 
[17:59:15.378]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:15.378]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.378]  - attr(*, "resolved")= logi FALSE
[17:59:15.378]  - attr(*, "total_size")= num NA
[17:59:15.385] Packages to be attached in all futures: [n=0] 
[17:59:15.385] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.386] Number of futures (= number of chunks): 1
[17:59:15.386] Launching 1 futures (chunks) ...
[17:59:15.386] Chunk #1 of 1 ...
[17:59:15.386]  - seeds: <none>
[17:59:15.387]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.387] getGlobalsAndPackages() ...
[17:59:15.387] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.387] Resolving globals: FALSE
[17:59:15.387] Tweak future expression to call with '...' arguments ...
[17:59:15.388] {
[17:59:15.388]     do.call(function(...) {
[17:59:15.388]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.388]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.388]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.388]             on.exit(options(oopts), add = TRUE)
[17:59:15.388]         }
[17:59:15.388]         {
[17:59:15.388]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.388]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.388]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.388]             })
[17:59:15.388]         }
[17:59:15.388]     }, args = future.call.arguments)
[17:59:15.388] }
[17:59:15.388] Tweak future expression to call with '...' arguments ... DONE
[17:59:15.389] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.389] 
[17:59:15.390] getGlobalsAndPackages() ... DONE
[17:59:15.390] run() for ‘Future’ ...
[17:59:15.390] - state: ‘created’
[17:59:15.391] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:15.391] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.392] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:15.392]   - Field: ‘label’
[17:59:15.392]   - Field: ‘local’
[17:59:15.393]   - Field: ‘owner’
[17:59:15.393]   - Field: ‘envir’
[17:59:15.393]   - Field: ‘packages’
[17:59:15.393]   - Field: ‘gc’
[17:59:15.394]   - Field: ‘conditions’
[17:59:15.394]   - Field: ‘expr’
[17:59:15.394]   - Field: ‘uuid’
[17:59:15.394]   - Field: ‘seed’
[17:59:15.394]   - Field: ‘version’
[17:59:15.395]   - Field: ‘result’
[17:59:15.395]   - Field: ‘asynchronous’
[17:59:15.395]   - Field: ‘calls’
[17:59:15.395]   - Field: ‘globals’
[17:59:15.396]   - Field: ‘stdout’
[17:59:15.396]   - Field: ‘earlySignal’
[17:59:15.396]   - Field: ‘lazy’
[17:59:15.396]   - Field: ‘state’
[17:59:15.396] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:15.397] - Launch lazy future ...
[17:59:15.397] Packages needed by the future expression (n = 0): <none>
[17:59:15.397] Packages needed by future strategies (n = 0): <none>
[17:59:15.398] {
[17:59:15.398]     {
[17:59:15.398]         {
[17:59:15.398]             ...future.startTime <- base::Sys.time()
[17:59:15.398]             {
[17:59:15.398]                 {
[17:59:15.398]                   {
[17:59:15.398]                     base::local({
[17:59:15.398]                       has_future <- base::requireNamespace("future", 
[17:59:15.398]                         quietly = TRUE)
[17:59:15.398]                       if (has_future) {
[17:59:15.398]                         ns <- base::getNamespace("future")
[17:59:15.398]                         version <- ns[[".package"]][["version"]]
[17:59:15.398]                         if (is.null(version)) 
[17:59:15.398]                           version <- utils::packageVersion("future")
[17:59:15.398]                       }
[17:59:15.398]                       else {
[17:59:15.398]                         version <- NULL
[17:59:15.398]                       }
[17:59:15.398]                       if (!has_future || version < "1.8.0") {
[17:59:15.398]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:15.398]                           "", base::R.version$version.string), 
[17:59:15.398]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:15.398]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:15.398]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:15.398]                             "release", "version")], collapse = " "), 
[17:59:15.398]                           hostname = base::Sys.info()[["nodename"]])
[17:59:15.398]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:15.398]                           info)
[17:59:15.398]                         info <- base::paste(info, collapse = "; ")
[17:59:15.398]                         if (!has_future) {
[17:59:15.398]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:15.398]                             info)
[17:59:15.398]                         }
[17:59:15.398]                         else {
[17:59:15.398]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:15.398]                             info, version)
[17:59:15.398]                         }
[17:59:15.398]                         base::stop(msg)
[17:59:15.398]                       }
[17:59:15.398]                     })
[17:59:15.398]                   }
[17:59:15.398]                   ...future.strategy.old <- future::plan("list")
[17:59:15.398]                   options(future.plan = NULL)
[17:59:15.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:15.398]                 }
[17:59:15.398]                 ...future.workdir <- getwd()
[17:59:15.398]             }
[17:59:15.398]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:15.398]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:15.398]         }
[17:59:15.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:15.398]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:15.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:15.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:15.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:15.398]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:15.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:15.398]             base::names(...future.oldOptions))
[17:59:15.398]     }
[17:59:15.398]     if (FALSE) {
[17:59:15.398]     }
[17:59:15.398]     else {
[17:59:15.398]         if (TRUE) {
[17:59:15.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:15.398]                 open = "w")
[17:59:15.398]         }
[17:59:15.398]         else {
[17:59:15.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:15.398]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:15.398]         }
[17:59:15.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:15.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:15.398]             base::sink(type = "output", split = FALSE)
[17:59:15.398]             base::close(...future.stdout)
[17:59:15.398]         }, add = TRUE)
[17:59:15.398]     }
[17:59:15.398]     ...future.frame <- base::sys.nframe()
[17:59:15.398]     ...future.conditions <- base::list()
[17:59:15.398]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:15.398]     if (FALSE) {
[17:59:15.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:15.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:15.398]     }
[17:59:15.398]     ...future.result <- base::tryCatch({
[17:59:15.398]         base::withCallingHandlers({
[17:59:15.398]             ...future.value <- base::withVisible(base::local({
[17:59:15.398]                 do.call(function(...) {
[17:59:15.398]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.398]                   if (!identical(...future.globals.maxSize.org, 
[17:59:15.398]                     ...future.globals.maxSize)) {
[17:59:15.398]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.398]                     on.exit(options(oopts), add = TRUE)
[17:59:15.398]                   }
[17:59:15.398]                   {
[17:59:15.398]                     lapply(seq_along(...future.elements_ii), 
[17:59:15.398]                       FUN = function(jj) {
[17:59:15.398]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.398]                         ...future.FUN(...future.X_jj, ...)
[17:59:15.398]                       })
[17:59:15.398]                   }
[17:59:15.398]                 }, args = future.call.arguments)
[17:59:15.398]             }))
[17:59:15.398]             future::FutureResult(value = ...future.value$value, 
[17:59:15.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.398]                   ...future.rng), globalenv = if (FALSE) 
[17:59:15.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:15.398]                     ...future.globalenv.names))
[17:59:15.398]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:15.398]         }, condition = base::local({
[17:59:15.398]             c <- base::c
[17:59:15.398]             inherits <- base::inherits
[17:59:15.398]             invokeRestart <- base::invokeRestart
[17:59:15.398]             length <- base::length
[17:59:15.398]             list <- base::list
[17:59:15.398]             seq.int <- base::seq.int
[17:59:15.398]             signalCondition <- base::signalCondition
[17:59:15.398]             sys.calls <- base::sys.calls
[17:59:15.398]             `[[` <- base::`[[`
[17:59:15.398]             `+` <- base::`+`
[17:59:15.398]             `<<-` <- base::`<<-`
[17:59:15.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:15.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:15.398]                   3L)]
[17:59:15.398]             }
[17:59:15.398]             function(cond) {
[17:59:15.398]                 is_error <- inherits(cond, "error")
[17:59:15.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:15.398]                   NULL)
[17:59:15.398]                 if (is_error) {
[17:59:15.398]                   sessionInformation <- function() {
[17:59:15.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:15.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:15.398]                       search = base::search(), system = base::Sys.info())
[17:59:15.398]                   }
[17:59:15.398]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:15.398]                     cond$call), session = sessionInformation(), 
[17:59:15.398]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:15.398]                   signalCondition(cond)
[17:59:15.398]                 }
[17:59:15.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:15.398]                 "immediateCondition"))) {
[17:59:15.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:15.398]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:15.398]                   if (TRUE && !signal) {
[17:59:15.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.398]                     {
[17:59:15.398]                       inherits <- base::inherits
[17:59:15.398]                       invokeRestart <- base::invokeRestart
[17:59:15.398]                       is.null <- base::is.null
[17:59:15.398]                       muffled <- FALSE
[17:59:15.398]                       if (inherits(cond, "message")) {
[17:59:15.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.398]                         if (muffled) 
[17:59:15.398]                           invokeRestart("muffleMessage")
[17:59:15.398]                       }
[17:59:15.398]                       else if (inherits(cond, "warning")) {
[17:59:15.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.398]                         if (muffled) 
[17:59:15.398]                           invokeRestart("muffleWarning")
[17:59:15.398]                       }
[17:59:15.398]                       else if (inherits(cond, "condition")) {
[17:59:15.398]                         if (!is.null(pattern)) {
[17:59:15.398]                           computeRestarts <- base::computeRestarts
[17:59:15.398]                           grepl <- base::grepl
[17:59:15.398]                           restarts <- computeRestarts(cond)
[17:59:15.398]                           for (restart in restarts) {
[17:59:15.398]                             name <- restart$name
[17:59:15.398]                             if (is.null(name)) 
[17:59:15.398]                               next
[17:59:15.398]                             if (!grepl(pattern, name)) 
[17:59:15.398]                               next
[17:59:15.398]                             invokeRestart(restart)
[17:59:15.398]                             muffled <- TRUE
[17:59:15.398]                             break
[17:59:15.398]                           }
[17:59:15.398]                         }
[17:59:15.398]                       }
[17:59:15.398]                       invisible(muffled)
[17:59:15.398]                     }
[17:59:15.398]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.398]                   }
[17:59:15.398]                 }
[17:59:15.398]                 else {
[17:59:15.398]                   if (TRUE) {
[17:59:15.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.398]                     {
[17:59:15.398]                       inherits <- base::inherits
[17:59:15.398]                       invokeRestart <- base::invokeRestart
[17:59:15.398]                       is.null <- base::is.null
[17:59:15.398]                       muffled <- FALSE
[17:59:15.398]                       if (inherits(cond, "message")) {
[17:59:15.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.398]                         if (muffled) 
[17:59:15.398]                           invokeRestart("muffleMessage")
[17:59:15.398]                       }
[17:59:15.398]                       else if (inherits(cond, "warning")) {
[17:59:15.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.398]                         if (muffled) 
[17:59:15.398]                           invokeRestart("muffleWarning")
[17:59:15.398]                       }
[17:59:15.398]                       else if (inherits(cond, "condition")) {
[17:59:15.398]                         if (!is.null(pattern)) {
[17:59:15.398]                           computeRestarts <- base::computeRestarts
[17:59:15.398]                           grepl <- base::grepl
[17:59:15.398]                           restarts <- computeRestarts(cond)
[17:59:15.398]                           for (restart in restarts) {
[17:59:15.398]                             name <- restart$name
[17:59:15.398]                             if (is.null(name)) 
[17:59:15.398]                               next
[17:59:15.398]                             if (!grepl(pattern, name)) 
[17:59:15.398]                               next
[17:59:15.398]                             invokeRestart(restart)
[17:59:15.398]                             muffled <- TRUE
[17:59:15.398]                             break
[17:59:15.398]                           }
[17:59:15.398]                         }
[17:59:15.398]                       }
[17:59:15.398]                       invisible(muffled)
[17:59:15.398]                     }
[17:59:15.398]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.398]                   }
[17:59:15.398]                 }
[17:59:15.398]             }
[17:59:15.398]         }))
[17:59:15.398]     }, error = function(ex) {
[17:59:15.398]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:15.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.398]                 ...future.rng), started = ...future.startTime, 
[17:59:15.398]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:15.398]             version = "1.8"), class = "FutureResult")
[17:59:15.398]     }, finally = {
[17:59:15.398]         if (!identical(...future.workdir, getwd())) 
[17:59:15.398]             setwd(...future.workdir)
[17:59:15.398]         {
[17:59:15.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:15.398]                 ...future.oldOptions$nwarnings <- NULL
[17:59:15.398]             }
[17:59:15.398]             base::options(...future.oldOptions)
[17:59:15.398]             if (.Platform$OS.type == "windows") {
[17:59:15.398]                 old_names <- names(...future.oldEnvVars)
[17:59:15.398]                 envs <- base::Sys.getenv()
[17:59:15.398]                 names <- names(envs)
[17:59:15.398]                 common <- intersect(names, old_names)
[17:59:15.398]                 added <- setdiff(names, old_names)
[17:59:15.398]                 removed <- setdiff(old_names, names)
[17:59:15.398]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:15.398]                   envs[common]]
[17:59:15.398]                 NAMES <- toupper(changed)
[17:59:15.398]                 args <- list()
[17:59:15.398]                 for (kk in seq_along(NAMES)) {
[17:59:15.398]                   name <- changed[[kk]]
[17:59:15.398]                   NAME <- NAMES[[kk]]
[17:59:15.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.398]                     next
[17:59:15.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.398]                 }
[17:59:15.398]                 NAMES <- toupper(added)
[17:59:15.398]                 for (kk in seq_along(NAMES)) {
[17:59:15.398]                   name <- added[[kk]]
[17:59:15.398]                   NAME <- NAMES[[kk]]
[17:59:15.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.398]                     next
[17:59:15.398]                   args[[name]] <- ""
[17:59:15.398]                 }
[17:59:15.398]                 NAMES <- toupper(removed)
[17:59:15.398]                 for (kk in seq_along(NAMES)) {
[17:59:15.398]                   name <- removed[[kk]]
[17:59:15.398]                   NAME <- NAMES[[kk]]
[17:59:15.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.398]                     next
[17:59:15.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.398]                 }
[17:59:15.398]                 if (length(args) > 0) 
[17:59:15.398]                   base::do.call(base::Sys.setenv, args = args)
[17:59:15.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:15.398]             }
[17:59:15.398]             else {
[17:59:15.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:15.398]             }
[17:59:15.398]             {
[17:59:15.398]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:15.398]                   0L) {
[17:59:15.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:15.398]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:15.398]                   base::options(opts)
[17:59:15.398]                 }
[17:59:15.398]                 {
[17:59:15.398]                   {
[17:59:15.398]                     NULL
[17:59:15.398]                     RNGkind("Mersenne-Twister")
[17:59:15.398]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:15.398]                       inherits = FALSE)
[17:59:15.398]                   }
[17:59:15.398]                   options(future.plan = NULL)
[17:59:15.398]                   if (is.na(NA_character_)) 
[17:59:15.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:15.398]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:15.398]                     .init = FALSE)
[17:59:15.398]                 }
[17:59:15.398]             }
[17:59:15.398]         }
[17:59:15.398]     })
[17:59:15.398]     if (TRUE) {
[17:59:15.398]         base::sink(type = "output", split = FALSE)
[17:59:15.398]         if (TRUE) {
[17:59:15.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:15.398]         }
[17:59:15.398]         else {
[17:59:15.398]             ...future.result["stdout"] <- base::list(NULL)
[17:59:15.398]         }
[17:59:15.398]         base::close(...future.stdout)
[17:59:15.398]         ...future.stdout <- NULL
[17:59:15.398]     }
[17:59:15.398]     ...future.result$conditions <- ...future.conditions
[17:59:15.398]     ...future.result$finished <- base::Sys.time()
[17:59:15.398]     ...future.result
[17:59:15.398] }
[17:59:15.401] assign_globals() ...
[17:59:15.402] List of 5
[17:59:15.402]  $ future.call.arguments    : list()
[17:59:15.402]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.402]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:15.402]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:15.402]  $ ...future.elements_ii    :List of 2
[17:59:15.402]   ..$ : num [1:4] 1 3 1 7
[17:59:15.402]   ..$ : num [1:4] 2 4 6 8
[17:59:15.402]  $ ...future.seeds_ii       : NULL
[17:59:15.402]  $ ...future.globals.maxSize: num Inf
[17:59:15.402]  - attr(*, "resolved")= logi FALSE
[17:59:15.402]  - attr(*, "total_size")= num NA
[17:59:15.402]  - attr(*, "where")=List of 5
[17:59:15.402]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:15.402]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:15.402]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:15.402]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:15.402]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:15.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.402]  - attr(*, "already-done")= logi TRUE
[17:59:15.414] - copied ‘future.call.arguments’ to environment
[17:59:15.414] - copied ‘...future.FUN’ to environment
[17:59:15.415] - copied ‘...future.elements_ii’ to environment
[17:59:15.415] - copied ‘...future.seeds_ii’ to environment
[17:59:15.415] - copied ‘...future.globals.maxSize’ to environment
[17:59:15.415] assign_globals() ... done
[17:59:15.416] plan(): Setting new future strategy stack:
[17:59:15.416] List of future strategies:
[17:59:15.416] 1. sequential:
[17:59:15.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.416]    - tweaked: FALSE
[17:59:15.416]    - call: NULL
[17:59:15.417] plan(): nbrOfWorkers() = 1
[17:59:15.419] plan(): Setting new future strategy stack:
[17:59:15.419] List of future strategies:
[17:59:15.419] 1. sequential:
[17:59:15.419]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.419]    - tweaked: FALSE
[17:59:15.419]    - call: plan(strategy)
[17:59:15.420] plan(): nbrOfWorkers() = 1
[17:59:15.420] SequentialFuture started (and completed)
[17:59:15.420] - Launch lazy future ... done
[17:59:15.421] run() for ‘SequentialFuture’ ... done
[17:59:15.421] Created future:
[17:59:15.421] SequentialFuture:
[17:59:15.421] Label: ‘future_apply-1’
[17:59:15.421] Expression:
[17:59:15.421] {
[17:59:15.421]     do.call(function(...) {
[17:59:15.421]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.421]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.421]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.421]             on.exit(options(oopts), add = TRUE)
[17:59:15.421]         }
[17:59:15.421]         {
[17:59:15.421]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.421]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.421]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.421]             })
[17:59:15.421]         }
[17:59:15.421]     }, args = future.call.arguments)
[17:59:15.421] }
[17:59:15.421] Lazy evaluation: FALSE
[17:59:15.421] Asynchronous evaluation: FALSE
[17:59:15.421] Local evaluation: TRUE
[17:59:15.421] Environment: R_GlobalEnv
[17:59:15.421] Capture standard output: TRUE
[17:59:15.421] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:15.421] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:15.421] Packages: <none>
[17:59:15.421] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:15.421] Resolved: TRUE
[17:59:15.421] Value: 2.21 KiB of class ‘list’
[17:59:15.421] Early signaling: FALSE
[17:59:15.421] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:15.421] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.423] Chunk #1 of 1 ... DONE
[17:59:15.423] Launching 1 futures (chunks) ... DONE
[17:59:15.423] Resolving 1 futures (chunks) ...
[17:59:15.424] resolve() on list ...
[17:59:15.424]  recursive: 0
[17:59:15.424]  length: 1
[17:59:15.424] 
[17:59:15.424] resolved() for ‘SequentialFuture’ ...
[17:59:15.425] - state: ‘finished’
[17:59:15.425] - run: TRUE
[17:59:15.425] - result: ‘FutureResult’
[17:59:15.425] resolved() for ‘SequentialFuture’ ... done
[17:59:15.425] Future #1
[17:59:15.426] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:15.426] - nx: 1
[17:59:15.426] - relay: TRUE
[17:59:15.426] - stdout: TRUE
[17:59:15.426] - signal: TRUE
[17:59:15.427] - resignal: FALSE
[17:59:15.427] - force: TRUE
[17:59:15.427] - relayed: [n=1] FALSE
[17:59:15.427] - queued futures: [n=1] FALSE
[17:59:15.427]  - until=1
[17:59:15.428]  - relaying element #1
[17:59:15.428] - relayed: [n=1] TRUE
[17:59:15.428] - queued futures: [n=1] TRUE
[17:59:15.428] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:15.428]  length: 0 (resolved future 1)
[17:59:15.429] Relaying remaining futures
[17:59:15.429] signalConditionsASAP(NULL, pos=0) ...
[17:59:15.429] - nx: 1
[17:59:15.429] - relay: TRUE
[17:59:15.429] - stdout: TRUE
[17:59:15.430] - signal: TRUE
[17:59:15.430] - resignal: FALSE
[17:59:15.430] - force: TRUE
[17:59:15.430] - relayed: [n=1] TRUE
[17:59:15.430] - queued futures: [n=1] TRUE
 - flush all
[17:59:15.431] - relayed: [n=1] TRUE
[17:59:15.431] - queued futures: [n=1] TRUE
[17:59:15.431] signalConditionsASAP(NULL, pos=0) ... done
[17:59:15.431] resolve() on list ... DONE
[17:59:15.431]  - Number of value chunks collected: 1
[17:59:15.432] Resolving 1 futures (chunks) ... DONE
[17:59:15.432] Reducing values from 1 chunks ...
[17:59:15.432]  - Number of values collected after concatenation: 2
[17:59:15.432]  - Number of values expected: 2
[17:59:15.432] Reducing values from 1 chunks ... DONE
[17:59:15.432] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:59:15.436] getGlobalsAndPackagesXApply() ...
[17:59:15.436]  - future.globals: TRUE
[17:59:15.437] getGlobalsAndPackages() ...
[17:59:15.437] Searching for globals...
[17:59:15.439] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:15.439] Searching for globals ... DONE
[17:59:15.440] Resolving globals: FALSE
[17:59:15.440] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:15.441] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:15.441] - globals: [1] ‘FUN’
[17:59:15.441] - packages: [1] ‘stats’
[17:59:15.442] getGlobalsAndPackages() ... DONE
[17:59:15.442]  - globals found/used: [n=1] ‘FUN’
[17:59:15.442]  - needed namespaces: [n=1] ‘stats’
[17:59:15.442] Finding globals ... DONE
[17:59:15.442]  - use_args: TRUE
[17:59:15.443]  - Getting '...' globals ...
[17:59:15.443] resolve() on list ...
[17:59:15.443]  recursive: 0
[17:59:15.444]  length: 1
[17:59:15.444]  elements: ‘...’
[17:59:15.444]  length: 0 (resolved future 1)
[17:59:15.444] resolve() on list ... DONE
[17:59:15.444]    - '...' content: [n=0] 
[17:59:15.445] List of 1
[17:59:15.445]  $ ...: list()
[17:59:15.445]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.445]  - attr(*, "where")=List of 1
[17:59:15.445]   ..$ ...:<environment: 0x56085b3b1c58> 
[17:59:15.445]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.445]  - attr(*, "resolved")= logi TRUE
[17:59:15.445]  - attr(*, "total_size")= num NA
[17:59:15.449]  - Getting '...' globals ... DONE
[17:59:15.450] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:15.450] List of 2
[17:59:15.450]  $ ...future.FUN:function (x, ...)  
[17:59:15.450]  $ ...          : list()
[17:59:15.450]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.450]  - attr(*, "where")=List of 2
[17:59:15.450]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:15.450]   ..$ ...          :<environment: 0x56085b3b1c58> 
[17:59:15.450]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.450]  - attr(*, "resolved")= logi FALSE
[17:59:15.450]  - attr(*, "total_size")= num 1248
[17:59:15.455] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:15.456] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.456] future_lapply() ...
[17:59:15.459] Number of chunks: 1
[17:59:15.460] getGlobalsAndPackagesXApply() ...
[17:59:15.460]  - future.globals: <name-value list> with names ‘list()’
[17:59:15.460]  - use_args: TRUE
[17:59:15.460] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:15.461] List of 2
[17:59:15.461]  $ ...          : list()
[17:59:15.461]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.461]  $ ...future.FUN:function (x, ...)  
[17:59:15.461]  - attr(*, "where")=List of 2
[17:59:15.461]   ..$ ...          :<environment: 0x56085b3b1c58> 
[17:59:15.461]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:59:15.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.461]  - attr(*, "resolved")= logi FALSE
[17:59:15.461]  - attr(*, "total_size")= num NA
[17:59:15.466] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:15.466] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.467] Number of futures (= number of chunks): 1
[17:59:15.467] Launching 1 futures (chunks) ...
[17:59:15.467] Chunk #1 of 1 ...
[17:59:15.467]  - seeds: <none>
[17:59:15.468]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.468] getGlobalsAndPackages() ...
[17:59:15.468] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.468] Resolving globals: FALSE
[17:59:15.468] Tweak future expression to call with '...' arguments ...
[17:59:15.469] {
[17:59:15.469]     do.call(function(...) {
[17:59:15.469]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.469]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.469]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.469]             on.exit(options(oopts), add = TRUE)
[17:59:15.469]         }
[17:59:15.469]         {
[17:59:15.469]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.469]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.469]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.469]             })
[17:59:15.469]         }
[17:59:15.469]     }, args = future.call.arguments)
[17:59:15.469] }
[17:59:15.469] Tweak future expression to call with '...' arguments ... DONE
[17:59:15.470] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.470] - packages: [1] ‘stats’
[17:59:15.471] getGlobalsAndPackages() ... DONE
[17:59:15.471] run() for ‘Future’ ...
[17:59:15.471] - state: ‘created’
[17:59:15.472] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:15.472] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:15.472]   - Field: ‘label’
[17:59:15.473]   - Field: ‘local’
[17:59:15.473]   - Field: ‘owner’
[17:59:15.473]   - Field: ‘envir’
[17:59:15.473]   - Field: ‘packages’
[17:59:15.473]   - Field: ‘gc’
[17:59:15.474]   - Field: ‘conditions’
[17:59:15.474]   - Field: ‘expr’
[17:59:15.474]   - Field: ‘uuid’
[17:59:15.474]   - Field: ‘seed’
[17:59:15.474]   - Field: ‘version’
[17:59:15.475]   - Field: ‘result’
[17:59:15.475]   - Field: ‘asynchronous’
[17:59:15.475]   - Field: ‘calls’
[17:59:15.475]   - Field: ‘globals’
[17:59:15.475]   - Field: ‘stdout’
[17:59:15.476]   - Field: ‘earlySignal’
[17:59:15.476]   - Field: ‘lazy’
[17:59:15.476]   - Field: ‘state’
[17:59:15.476] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:15.476] - Launch lazy future ...
[17:59:15.477] Packages needed by the future expression (n = 1): ‘stats’
[17:59:15.477] Packages needed by future strategies (n = 0): <none>
[17:59:15.478] {
[17:59:15.478]     {
[17:59:15.478]         {
[17:59:15.478]             ...future.startTime <- base::Sys.time()
[17:59:15.478]             {
[17:59:15.478]                 {
[17:59:15.478]                   {
[17:59:15.478]                     {
[17:59:15.478]                       base::local({
[17:59:15.478]                         has_future <- base::requireNamespace("future", 
[17:59:15.478]                           quietly = TRUE)
[17:59:15.478]                         if (has_future) {
[17:59:15.478]                           ns <- base::getNamespace("future")
[17:59:15.478]                           version <- ns[[".package"]][["version"]]
[17:59:15.478]                           if (is.null(version)) 
[17:59:15.478]                             version <- utils::packageVersion("future")
[17:59:15.478]                         }
[17:59:15.478]                         else {
[17:59:15.478]                           version <- NULL
[17:59:15.478]                         }
[17:59:15.478]                         if (!has_future || version < "1.8.0") {
[17:59:15.478]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:15.478]                             "", base::R.version$version.string), 
[17:59:15.478]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:15.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:15.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:15.478]                               "release", "version")], collapse = " "), 
[17:59:15.478]                             hostname = base::Sys.info()[["nodename"]])
[17:59:15.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:15.478]                             info)
[17:59:15.478]                           info <- base::paste(info, collapse = "; ")
[17:59:15.478]                           if (!has_future) {
[17:59:15.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:15.478]                               info)
[17:59:15.478]                           }
[17:59:15.478]                           else {
[17:59:15.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:15.478]                               info, version)
[17:59:15.478]                           }
[17:59:15.478]                           base::stop(msg)
[17:59:15.478]                         }
[17:59:15.478]                       })
[17:59:15.478]                     }
[17:59:15.478]                     base::local({
[17:59:15.478]                       for (pkg in "stats") {
[17:59:15.478]                         base::loadNamespace(pkg)
[17:59:15.478]                         base::library(pkg, character.only = TRUE)
[17:59:15.478]                       }
[17:59:15.478]                     })
[17:59:15.478]                   }
[17:59:15.478]                   ...future.strategy.old <- future::plan("list")
[17:59:15.478]                   options(future.plan = NULL)
[17:59:15.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:15.478]                 }
[17:59:15.478]                 ...future.workdir <- getwd()
[17:59:15.478]             }
[17:59:15.478]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:15.478]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:15.478]         }
[17:59:15.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:15.478]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:15.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:15.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:15.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:15.478]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:15.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:15.478]             base::names(...future.oldOptions))
[17:59:15.478]     }
[17:59:15.478]     if (FALSE) {
[17:59:15.478]     }
[17:59:15.478]     else {
[17:59:15.478]         if (TRUE) {
[17:59:15.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:15.478]                 open = "w")
[17:59:15.478]         }
[17:59:15.478]         else {
[17:59:15.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:15.478]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:15.478]         }
[17:59:15.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:15.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:15.478]             base::sink(type = "output", split = FALSE)
[17:59:15.478]             base::close(...future.stdout)
[17:59:15.478]         }, add = TRUE)
[17:59:15.478]     }
[17:59:15.478]     ...future.frame <- base::sys.nframe()
[17:59:15.478]     ...future.conditions <- base::list()
[17:59:15.478]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:15.478]     if (FALSE) {
[17:59:15.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:15.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:15.478]     }
[17:59:15.478]     ...future.result <- base::tryCatch({
[17:59:15.478]         base::withCallingHandlers({
[17:59:15.478]             ...future.value <- base::withVisible(base::local({
[17:59:15.478]                 do.call(function(...) {
[17:59:15.478]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.478]                   if (!identical(...future.globals.maxSize.org, 
[17:59:15.478]                     ...future.globals.maxSize)) {
[17:59:15.478]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.478]                     on.exit(options(oopts), add = TRUE)
[17:59:15.478]                   }
[17:59:15.478]                   {
[17:59:15.478]                     lapply(seq_along(...future.elements_ii), 
[17:59:15.478]                       FUN = function(jj) {
[17:59:15.478]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.478]                         ...future.FUN(...future.X_jj, ...)
[17:59:15.478]                       })
[17:59:15.478]                   }
[17:59:15.478]                 }, args = future.call.arguments)
[17:59:15.478]             }))
[17:59:15.478]             future::FutureResult(value = ...future.value$value, 
[17:59:15.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.478]                   ...future.rng), globalenv = if (FALSE) 
[17:59:15.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:15.478]                     ...future.globalenv.names))
[17:59:15.478]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:15.478]         }, condition = base::local({
[17:59:15.478]             c <- base::c
[17:59:15.478]             inherits <- base::inherits
[17:59:15.478]             invokeRestart <- base::invokeRestart
[17:59:15.478]             length <- base::length
[17:59:15.478]             list <- base::list
[17:59:15.478]             seq.int <- base::seq.int
[17:59:15.478]             signalCondition <- base::signalCondition
[17:59:15.478]             sys.calls <- base::sys.calls
[17:59:15.478]             `[[` <- base::`[[`
[17:59:15.478]             `+` <- base::`+`
[17:59:15.478]             `<<-` <- base::`<<-`
[17:59:15.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:15.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:15.478]                   3L)]
[17:59:15.478]             }
[17:59:15.478]             function(cond) {
[17:59:15.478]                 is_error <- inherits(cond, "error")
[17:59:15.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:15.478]                   NULL)
[17:59:15.478]                 if (is_error) {
[17:59:15.478]                   sessionInformation <- function() {
[17:59:15.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:15.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:15.478]                       search = base::search(), system = base::Sys.info())
[17:59:15.478]                   }
[17:59:15.478]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:15.478]                     cond$call), session = sessionInformation(), 
[17:59:15.478]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:15.478]                   signalCondition(cond)
[17:59:15.478]                 }
[17:59:15.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:15.478]                 "immediateCondition"))) {
[17:59:15.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:15.478]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:15.478]                   if (TRUE && !signal) {
[17:59:15.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.478]                     {
[17:59:15.478]                       inherits <- base::inherits
[17:59:15.478]                       invokeRestart <- base::invokeRestart
[17:59:15.478]                       is.null <- base::is.null
[17:59:15.478]                       muffled <- FALSE
[17:59:15.478]                       if (inherits(cond, "message")) {
[17:59:15.478]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.478]                         if (muffled) 
[17:59:15.478]                           invokeRestart("muffleMessage")
[17:59:15.478]                       }
[17:59:15.478]                       else if (inherits(cond, "warning")) {
[17:59:15.478]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.478]                         if (muffled) 
[17:59:15.478]                           invokeRestart("muffleWarning")
[17:59:15.478]                       }
[17:59:15.478]                       else if (inherits(cond, "condition")) {
[17:59:15.478]                         if (!is.null(pattern)) {
[17:59:15.478]                           computeRestarts <- base::computeRestarts
[17:59:15.478]                           grepl <- base::grepl
[17:59:15.478]                           restarts <- computeRestarts(cond)
[17:59:15.478]                           for (restart in restarts) {
[17:59:15.478]                             name <- restart$name
[17:59:15.478]                             if (is.null(name)) 
[17:59:15.478]                               next
[17:59:15.478]                             if (!grepl(pattern, name)) 
[17:59:15.478]                               next
[17:59:15.478]                             invokeRestart(restart)
[17:59:15.478]                             muffled <- TRUE
[17:59:15.478]                             break
[17:59:15.478]                           }
[17:59:15.478]                         }
[17:59:15.478]                       }
[17:59:15.478]                       invisible(muffled)
[17:59:15.478]                     }
[17:59:15.478]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.478]                   }
[17:59:15.478]                 }
[17:59:15.478]                 else {
[17:59:15.478]                   if (TRUE) {
[17:59:15.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.478]                     {
[17:59:15.478]                       inherits <- base::inherits
[17:59:15.478]                       invokeRestart <- base::invokeRestart
[17:59:15.478]                       is.null <- base::is.null
[17:59:15.478]                       muffled <- FALSE
[17:59:15.478]                       if (inherits(cond, "message")) {
[17:59:15.478]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.478]                         if (muffled) 
[17:59:15.478]                           invokeRestart("muffleMessage")
[17:59:15.478]                       }
[17:59:15.478]                       else if (inherits(cond, "warning")) {
[17:59:15.478]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.478]                         if (muffled) 
[17:59:15.478]                           invokeRestart("muffleWarning")
[17:59:15.478]                       }
[17:59:15.478]                       else if (inherits(cond, "condition")) {
[17:59:15.478]                         if (!is.null(pattern)) {
[17:59:15.478]                           computeRestarts <- base::computeRestarts
[17:59:15.478]                           grepl <- base::grepl
[17:59:15.478]                           restarts <- computeRestarts(cond)
[17:59:15.478]                           for (restart in restarts) {
[17:59:15.478]                             name <- restart$name
[17:59:15.478]                             if (is.null(name)) 
[17:59:15.478]                               next
[17:59:15.478]                             if (!grepl(pattern, name)) 
[17:59:15.478]                               next
[17:59:15.478]                             invokeRestart(restart)
[17:59:15.478]                             muffled <- TRUE
[17:59:15.478]                             break
[17:59:15.478]                           }
[17:59:15.478]                         }
[17:59:15.478]                       }
[17:59:15.478]                       invisible(muffled)
[17:59:15.478]                     }
[17:59:15.478]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.478]                   }
[17:59:15.478]                 }
[17:59:15.478]             }
[17:59:15.478]         }))
[17:59:15.478]     }, error = function(ex) {
[17:59:15.478]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:15.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.478]                 ...future.rng), started = ...future.startTime, 
[17:59:15.478]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:15.478]             version = "1.8"), class = "FutureResult")
[17:59:15.478]     }, finally = {
[17:59:15.478]         if (!identical(...future.workdir, getwd())) 
[17:59:15.478]             setwd(...future.workdir)
[17:59:15.478]         {
[17:59:15.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:15.478]                 ...future.oldOptions$nwarnings <- NULL
[17:59:15.478]             }
[17:59:15.478]             base::options(...future.oldOptions)
[17:59:15.478]             if (.Platform$OS.type == "windows") {
[17:59:15.478]                 old_names <- names(...future.oldEnvVars)
[17:59:15.478]                 envs <- base::Sys.getenv()
[17:59:15.478]                 names <- names(envs)
[17:59:15.478]                 common <- intersect(names, old_names)
[17:59:15.478]                 added <- setdiff(names, old_names)
[17:59:15.478]                 removed <- setdiff(old_names, names)
[17:59:15.478]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:15.478]                   envs[common]]
[17:59:15.478]                 NAMES <- toupper(changed)
[17:59:15.478]                 args <- list()
[17:59:15.478]                 for (kk in seq_along(NAMES)) {
[17:59:15.478]                   name <- changed[[kk]]
[17:59:15.478]                   NAME <- NAMES[[kk]]
[17:59:15.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.478]                     next
[17:59:15.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.478]                 }
[17:59:15.478]                 NAMES <- toupper(added)
[17:59:15.478]                 for (kk in seq_along(NAMES)) {
[17:59:15.478]                   name <- added[[kk]]
[17:59:15.478]                   NAME <- NAMES[[kk]]
[17:59:15.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.478]                     next
[17:59:15.478]                   args[[name]] <- ""
[17:59:15.478]                 }
[17:59:15.478]                 NAMES <- toupper(removed)
[17:59:15.478]                 for (kk in seq_along(NAMES)) {
[17:59:15.478]                   name <- removed[[kk]]
[17:59:15.478]                   NAME <- NAMES[[kk]]
[17:59:15.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.478]                     next
[17:59:15.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.478]                 }
[17:59:15.478]                 if (length(args) > 0) 
[17:59:15.478]                   base::do.call(base::Sys.setenv, args = args)
[17:59:15.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:15.478]             }
[17:59:15.478]             else {
[17:59:15.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:15.478]             }
[17:59:15.478]             {
[17:59:15.478]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:15.478]                   0L) {
[17:59:15.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:15.478]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:15.478]                   base::options(opts)
[17:59:15.478]                 }
[17:59:15.478]                 {
[17:59:15.478]                   {
[17:59:15.478]                     NULL
[17:59:15.478]                     RNGkind("Mersenne-Twister")
[17:59:15.478]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:15.478]                       inherits = FALSE)
[17:59:15.478]                   }
[17:59:15.478]                   options(future.plan = NULL)
[17:59:15.478]                   if (is.na(NA_character_)) 
[17:59:15.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:15.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:15.478]                     .init = FALSE)
[17:59:15.478]                 }
[17:59:15.478]             }
[17:59:15.478]         }
[17:59:15.478]     })
[17:59:15.478]     if (TRUE) {
[17:59:15.478]         base::sink(type = "output", split = FALSE)
[17:59:15.478]         if (TRUE) {
[17:59:15.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:15.478]         }
[17:59:15.478]         else {
[17:59:15.478]             ...future.result["stdout"] <- base::list(NULL)
[17:59:15.478]         }
[17:59:15.478]         base::close(...future.stdout)
[17:59:15.478]         ...future.stdout <- NULL
[17:59:15.478]     }
[17:59:15.478]     ...future.result$conditions <- ...future.conditions
[17:59:15.478]     ...future.result$finished <- base::Sys.time()
[17:59:15.478]     ...future.result
[17:59:15.478] }
[17:59:15.481] assign_globals() ...
[17:59:15.481] List of 5
[17:59:15.481]  $ future.call.arguments    : list()
[17:59:15.481]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.481]  $ ...future.FUN            :function (x, ...)  
[17:59:15.481]  $ ...future.elements_ii    :List of 2
[17:59:15.481]   ..$ : num [1:4] 1 3 1 7
[17:59:15.481]   ..$ : num [1:4] 2 4 6 8
[17:59:15.481]  $ ...future.seeds_ii       : NULL
[17:59:15.481]  $ ...future.globals.maxSize: num Inf
[17:59:15.481]  - attr(*, "resolved")= logi FALSE
[17:59:15.481]  - attr(*, "total_size")= num NA
[17:59:15.481]  - attr(*, "where")=List of 5
[17:59:15.481]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:15.481]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:15.481]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:15.481]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:15.481]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:15.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.481]  - attr(*, "already-done")= logi TRUE
[17:59:15.492] - copied ‘future.call.arguments’ to environment
[17:59:15.492] - copied ‘...future.FUN’ to environment
[17:59:15.492] - copied ‘...future.elements_ii’ to environment
[17:59:15.492] - copied ‘...future.seeds_ii’ to environment
[17:59:15.493] - copied ‘...future.globals.maxSize’ to environment
[17:59:15.493] assign_globals() ... done
[17:59:15.493] plan(): Setting new future strategy stack:
[17:59:15.494] List of future strategies:
[17:59:15.494] 1. sequential:
[17:59:15.494]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.494]    - tweaked: FALSE
[17:59:15.494]    - call: NULL
[17:59:15.495] plan(): nbrOfWorkers() = 1
[17:59:15.497] plan(): Setting new future strategy stack:
[17:59:15.497] List of future strategies:
[17:59:15.497] 1. sequential:
[17:59:15.497]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.497]    - tweaked: FALSE
[17:59:15.497]    - call: plan(strategy)
[17:59:15.498] plan(): nbrOfWorkers() = 1
[17:59:15.498] SequentialFuture started (and completed)
[17:59:15.498] - Launch lazy future ... done
[17:59:15.499] run() for ‘SequentialFuture’ ... done
[17:59:15.499] Created future:
[17:59:15.499] SequentialFuture:
[17:59:15.499] Label: ‘future_apply-1’
[17:59:15.499] Expression:
[17:59:15.499] {
[17:59:15.499]     do.call(function(...) {
[17:59:15.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.499]             on.exit(options(oopts), add = TRUE)
[17:59:15.499]         }
[17:59:15.499]         {
[17:59:15.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.499]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.499]             })
[17:59:15.499]         }
[17:59:15.499]     }, args = future.call.arguments)
[17:59:15.499] }
[17:59:15.499] Lazy evaluation: FALSE
[17:59:15.499] Asynchronous evaluation: FALSE
[17:59:15.499] Local evaluation: TRUE
[17:59:15.499] Environment: R_GlobalEnv
[17:59:15.499] Capture standard output: TRUE
[17:59:15.499] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:15.499] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:15.499] Packages: 1 packages (‘stats’)
[17:59:15.499] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:15.499] Resolved: TRUE
[17:59:15.499] Value: 1.14 KiB of class ‘list’
[17:59:15.499] Early signaling: FALSE
[17:59:15.499] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:15.499] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.501] Chunk #1 of 1 ... DONE
[17:59:15.501] Launching 1 futures (chunks) ... DONE
[17:59:15.501] Resolving 1 futures (chunks) ...
[17:59:15.502] resolve() on list ...
[17:59:15.502]  recursive: 0
[17:59:15.502]  length: 1
[17:59:15.502] 
[17:59:15.502] resolved() for ‘SequentialFuture’ ...
[17:59:15.503] - state: ‘finished’
[17:59:15.503] - run: TRUE
[17:59:15.503] - result: ‘FutureResult’
[17:59:15.503] resolved() for ‘SequentialFuture’ ... done
[17:59:15.503] Future #1
[17:59:15.504] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:15.504] - nx: 1
[17:59:15.504] - relay: TRUE
[17:59:15.504] - stdout: TRUE
[17:59:15.504] - signal: TRUE
[17:59:15.504] - resignal: FALSE
[17:59:15.505] - force: TRUE
[17:59:15.505] - relayed: [n=1] FALSE
[17:59:15.505] - queued futures: [n=1] FALSE
[17:59:15.505]  - until=1
[17:59:15.505]  - relaying element #1
[17:59:15.506] - relayed: [n=1] TRUE
[17:59:15.506] - queued futures: [n=1] TRUE
[17:59:15.506] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:15.506]  length: 0 (resolved future 1)
[17:59:15.507] Relaying remaining futures
[17:59:15.507] signalConditionsASAP(NULL, pos=0) ...
[17:59:15.507] - nx: 1
[17:59:15.507] - relay: TRUE
[17:59:15.507] - stdout: TRUE
[17:59:15.507] - signal: TRUE
[17:59:15.508] - resignal: FALSE
[17:59:15.510] - force: TRUE
[17:59:15.510] - relayed: [n=1] TRUE
[17:59:15.510] - queued futures: [n=1] TRUE
 - flush all
[17:59:15.511] - relayed: [n=1] TRUE
[17:59:15.511] - queued futures: [n=1] TRUE
[17:59:15.511] signalConditionsASAP(NULL, pos=0) ... done
[17:59:15.511] resolve() on list ... DONE
[17:59:15.512]  - Number of value chunks collected: 1
[17:59:15.512] Resolving 1 futures (chunks) ... DONE
[17:59:15.512] Reducing values from 1 chunks ...
[17:59:15.512]  - Number of values collected after concatenation: 2
[17:59:15.512]  - Number of values expected: 2
[17:59:15.513] Reducing values from 1 chunks ... DONE
[17:59:15.513] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:59:15.514] getGlobalsAndPackagesXApply() ...
[17:59:15.514]  - future.globals: TRUE
[17:59:15.514] getGlobalsAndPackages() ...
[17:59:15.515] Searching for globals...
[17:59:15.517] - globals found: [1] ‘FUN’
[17:59:15.517] Searching for globals ... DONE
[17:59:15.517] Resolving globals: FALSE
[17:59:15.518] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:15.518] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:15.518] - globals: [1] ‘FUN’
[17:59:15.519] 
[17:59:15.519] getGlobalsAndPackages() ... DONE
[17:59:15.519]  - globals found/used: [n=1] ‘FUN’
[17:59:15.519]  - needed namespaces: [n=0] 
[17:59:15.519] Finding globals ... DONE
[17:59:15.520]  - use_args: TRUE
[17:59:15.520]  - Getting '...' globals ...
[17:59:15.520] resolve() on list ...
[17:59:15.521]  recursive: 0
[17:59:15.521]  length: 1
[17:59:15.521]  elements: ‘...’
[17:59:15.521]  length: 0 (resolved future 1)
[17:59:15.521] resolve() on list ... DONE
[17:59:15.522]    - '...' content: [n=0] 
[17:59:15.522] List of 1
[17:59:15.522]  $ ...: list()
[17:59:15.522]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.522]  - attr(*, "where")=List of 1
[17:59:15.522]   ..$ ...:<environment: 0x560859cc2708> 
[17:59:15.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.522]  - attr(*, "resolved")= logi TRUE
[17:59:15.522]  - attr(*, "total_size")= num NA
[17:59:15.527]  - Getting '...' globals ... DONE
[17:59:15.527] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:15.527] List of 2
[17:59:15.527]  $ ...future.FUN:function (x)  
[17:59:15.527]  $ ...          : list()
[17:59:15.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.527]  - attr(*, "where")=List of 2
[17:59:15.527]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:15.527]   ..$ ...          :<environment: 0x560859cc2708> 
[17:59:15.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.527]  - attr(*, "resolved")= logi FALSE
[17:59:15.527]  - attr(*, "total_size")= num 848
[17:59:15.533] Packages to be attached in all futures: [n=0] 
[17:59:15.533] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.533] future_lapply() ...
[17:59:15.534] Number of chunks: 1
[17:59:15.534] getGlobalsAndPackagesXApply() ...
[17:59:15.535]  - future.globals: <name-value list> with names ‘list()’
[17:59:15.535]  - use_args: TRUE
[17:59:15.535] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:15.535] List of 2
[17:59:15.535]  $ ...          : list()
[17:59:15.535]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.535]  $ ...future.FUN:function (x)  
[17:59:15.535]  - attr(*, "where")=List of 2
[17:59:15.535]   ..$ ...          :<environment: 0x560859cc2708> 
[17:59:15.535]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:15.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.535]  - attr(*, "resolved")= logi FALSE
[17:59:15.535]  - attr(*, "total_size")= num NA
[17:59:15.542] Packages to be attached in all futures: [n=0] 
[17:59:15.542] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.542] Number of futures (= number of chunks): 1
[17:59:15.543] Launching 1 futures (chunks) ...
[17:59:15.543] Chunk #1 of 1 ...
[17:59:15.543]  - seeds: <none>
[17:59:15.543]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.544] getGlobalsAndPackages() ...
[17:59:15.544] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.544] Resolving globals: FALSE
[17:59:15.544] Tweak future expression to call with '...' arguments ...
[17:59:15.545] {
[17:59:15.545]     do.call(function(...) {
[17:59:15.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.545]             on.exit(options(oopts), add = TRUE)
[17:59:15.545]         }
[17:59:15.545]         {
[17:59:15.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.545]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.545]             })
[17:59:15.545]         }
[17:59:15.545]     }, args = future.call.arguments)
[17:59:15.545] }
[17:59:15.545] Tweak future expression to call with '...' arguments ... DONE
[17:59:15.546] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.546] 
[17:59:15.546] getGlobalsAndPackages() ... DONE
[17:59:15.547] run() for ‘Future’ ...
[17:59:15.547] - state: ‘created’
[17:59:15.547] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:15.548] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:15.548]   - Field: ‘label’
[17:59:15.548]   - Field: ‘local’
[17:59:15.549]   - Field: ‘owner’
[17:59:15.549]   - Field: ‘envir’
[17:59:15.549]   - Field: ‘packages’
[17:59:15.549]   - Field: ‘gc’
[17:59:15.549]   - Field: ‘conditions’
[17:59:15.550]   - Field: ‘expr’
[17:59:15.550]   - Field: ‘uuid’
[17:59:15.550]   - Field: ‘seed’
[17:59:15.550]   - Field: ‘version’
[17:59:15.550]   - Field: ‘result’
[17:59:15.551]   - Field: ‘asynchronous’
[17:59:15.551]   - Field: ‘calls’
[17:59:15.551]   - Field: ‘globals’
[17:59:15.551]   - Field: ‘stdout’
[17:59:15.551]   - Field: ‘earlySignal’
[17:59:15.551]   - Field: ‘lazy’
[17:59:15.552]   - Field: ‘state’
[17:59:15.552] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:15.552] - Launch lazy future ...
[17:59:15.552] Packages needed by the future expression (n = 0): <none>
[17:59:15.553] Packages needed by future strategies (n = 0): <none>
[17:59:15.554] {
[17:59:15.554]     {
[17:59:15.554]         {
[17:59:15.554]             ...future.startTime <- base::Sys.time()
[17:59:15.554]             {
[17:59:15.554]                 {
[17:59:15.554]                   {
[17:59:15.554]                     base::local({
[17:59:15.554]                       has_future <- base::requireNamespace("future", 
[17:59:15.554]                         quietly = TRUE)
[17:59:15.554]                       if (has_future) {
[17:59:15.554]                         ns <- base::getNamespace("future")
[17:59:15.554]                         version <- ns[[".package"]][["version"]]
[17:59:15.554]                         if (is.null(version)) 
[17:59:15.554]                           version <- utils::packageVersion("future")
[17:59:15.554]                       }
[17:59:15.554]                       else {
[17:59:15.554]                         version <- NULL
[17:59:15.554]                       }
[17:59:15.554]                       if (!has_future || version < "1.8.0") {
[17:59:15.554]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:15.554]                           "", base::R.version$version.string), 
[17:59:15.554]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:15.554]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:15.554]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:15.554]                             "release", "version")], collapse = " "), 
[17:59:15.554]                           hostname = base::Sys.info()[["nodename"]])
[17:59:15.554]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:15.554]                           info)
[17:59:15.554]                         info <- base::paste(info, collapse = "; ")
[17:59:15.554]                         if (!has_future) {
[17:59:15.554]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:15.554]                             info)
[17:59:15.554]                         }
[17:59:15.554]                         else {
[17:59:15.554]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:15.554]                             info, version)
[17:59:15.554]                         }
[17:59:15.554]                         base::stop(msg)
[17:59:15.554]                       }
[17:59:15.554]                     })
[17:59:15.554]                   }
[17:59:15.554]                   ...future.strategy.old <- future::plan("list")
[17:59:15.554]                   options(future.plan = NULL)
[17:59:15.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:15.554]                 }
[17:59:15.554]                 ...future.workdir <- getwd()
[17:59:15.554]             }
[17:59:15.554]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:15.554]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:15.554]         }
[17:59:15.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:15.554]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:15.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:15.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:15.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:15.554]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:15.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:15.554]             base::names(...future.oldOptions))
[17:59:15.554]     }
[17:59:15.554]     if (FALSE) {
[17:59:15.554]     }
[17:59:15.554]     else {
[17:59:15.554]         if (TRUE) {
[17:59:15.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:15.554]                 open = "w")
[17:59:15.554]         }
[17:59:15.554]         else {
[17:59:15.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:15.554]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:15.554]         }
[17:59:15.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:15.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:15.554]             base::sink(type = "output", split = FALSE)
[17:59:15.554]             base::close(...future.stdout)
[17:59:15.554]         }, add = TRUE)
[17:59:15.554]     }
[17:59:15.554]     ...future.frame <- base::sys.nframe()
[17:59:15.554]     ...future.conditions <- base::list()
[17:59:15.554]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:15.554]     if (FALSE) {
[17:59:15.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:15.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:15.554]     }
[17:59:15.554]     ...future.result <- base::tryCatch({
[17:59:15.554]         base::withCallingHandlers({
[17:59:15.554]             ...future.value <- base::withVisible(base::local({
[17:59:15.554]                 do.call(function(...) {
[17:59:15.554]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.554]                   if (!identical(...future.globals.maxSize.org, 
[17:59:15.554]                     ...future.globals.maxSize)) {
[17:59:15.554]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.554]                     on.exit(options(oopts), add = TRUE)
[17:59:15.554]                   }
[17:59:15.554]                   {
[17:59:15.554]                     lapply(seq_along(...future.elements_ii), 
[17:59:15.554]                       FUN = function(jj) {
[17:59:15.554]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.554]                         ...future.FUN(...future.X_jj, ...)
[17:59:15.554]                       })
[17:59:15.554]                   }
[17:59:15.554]                 }, args = future.call.arguments)
[17:59:15.554]             }))
[17:59:15.554]             future::FutureResult(value = ...future.value$value, 
[17:59:15.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.554]                   ...future.rng), globalenv = if (FALSE) 
[17:59:15.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:15.554]                     ...future.globalenv.names))
[17:59:15.554]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:15.554]         }, condition = base::local({
[17:59:15.554]             c <- base::c
[17:59:15.554]             inherits <- base::inherits
[17:59:15.554]             invokeRestart <- base::invokeRestart
[17:59:15.554]             length <- base::length
[17:59:15.554]             list <- base::list
[17:59:15.554]             seq.int <- base::seq.int
[17:59:15.554]             signalCondition <- base::signalCondition
[17:59:15.554]             sys.calls <- base::sys.calls
[17:59:15.554]             `[[` <- base::`[[`
[17:59:15.554]             `+` <- base::`+`
[17:59:15.554]             `<<-` <- base::`<<-`
[17:59:15.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:15.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:15.554]                   3L)]
[17:59:15.554]             }
[17:59:15.554]             function(cond) {
[17:59:15.554]                 is_error <- inherits(cond, "error")
[17:59:15.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:15.554]                   NULL)
[17:59:15.554]                 if (is_error) {
[17:59:15.554]                   sessionInformation <- function() {
[17:59:15.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:15.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:15.554]                       search = base::search(), system = base::Sys.info())
[17:59:15.554]                   }
[17:59:15.554]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:15.554]                     cond$call), session = sessionInformation(), 
[17:59:15.554]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:15.554]                   signalCondition(cond)
[17:59:15.554]                 }
[17:59:15.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:15.554]                 "immediateCondition"))) {
[17:59:15.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:15.554]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:15.554]                   if (TRUE && !signal) {
[17:59:15.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.554]                     {
[17:59:15.554]                       inherits <- base::inherits
[17:59:15.554]                       invokeRestart <- base::invokeRestart
[17:59:15.554]                       is.null <- base::is.null
[17:59:15.554]                       muffled <- FALSE
[17:59:15.554]                       if (inherits(cond, "message")) {
[17:59:15.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.554]                         if (muffled) 
[17:59:15.554]                           invokeRestart("muffleMessage")
[17:59:15.554]                       }
[17:59:15.554]                       else if (inherits(cond, "warning")) {
[17:59:15.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.554]                         if (muffled) 
[17:59:15.554]                           invokeRestart("muffleWarning")
[17:59:15.554]                       }
[17:59:15.554]                       else if (inherits(cond, "condition")) {
[17:59:15.554]                         if (!is.null(pattern)) {
[17:59:15.554]                           computeRestarts <- base::computeRestarts
[17:59:15.554]                           grepl <- base::grepl
[17:59:15.554]                           restarts <- computeRestarts(cond)
[17:59:15.554]                           for (restart in restarts) {
[17:59:15.554]                             name <- restart$name
[17:59:15.554]                             if (is.null(name)) 
[17:59:15.554]                               next
[17:59:15.554]                             if (!grepl(pattern, name)) 
[17:59:15.554]                               next
[17:59:15.554]                             invokeRestart(restart)
[17:59:15.554]                             muffled <- TRUE
[17:59:15.554]                             break
[17:59:15.554]                           }
[17:59:15.554]                         }
[17:59:15.554]                       }
[17:59:15.554]                       invisible(muffled)
[17:59:15.554]                     }
[17:59:15.554]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.554]                   }
[17:59:15.554]                 }
[17:59:15.554]                 else {
[17:59:15.554]                   if (TRUE) {
[17:59:15.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.554]                     {
[17:59:15.554]                       inherits <- base::inherits
[17:59:15.554]                       invokeRestart <- base::invokeRestart
[17:59:15.554]                       is.null <- base::is.null
[17:59:15.554]                       muffled <- FALSE
[17:59:15.554]                       if (inherits(cond, "message")) {
[17:59:15.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.554]                         if (muffled) 
[17:59:15.554]                           invokeRestart("muffleMessage")
[17:59:15.554]                       }
[17:59:15.554]                       else if (inherits(cond, "warning")) {
[17:59:15.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.554]                         if (muffled) 
[17:59:15.554]                           invokeRestart("muffleWarning")
[17:59:15.554]                       }
[17:59:15.554]                       else if (inherits(cond, "condition")) {
[17:59:15.554]                         if (!is.null(pattern)) {
[17:59:15.554]                           computeRestarts <- base::computeRestarts
[17:59:15.554]                           grepl <- base::grepl
[17:59:15.554]                           restarts <- computeRestarts(cond)
[17:59:15.554]                           for (restart in restarts) {
[17:59:15.554]                             name <- restart$name
[17:59:15.554]                             if (is.null(name)) 
[17:59:15.554]                               next
[17:59:15.554]                             if (!grepl(pattern, name)) 
[17:59:15.554]                               next
[17:59:15.554]                             invokeRestart(restart)
[17:59:15.554]                             muffled <- TRUE
[17:59:15.554]                             break
[17:59:15.554]                           }
[17:59:15.554]                         }
[17:59:15.554]                       }
[17:59:15.554]                       invisible(muffled)
[17:59:15.554]                     }
[17:59:15.554]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.554]                   }
[17:59:15.554]                 }
[17:59:15.554]             }
[17:59:15.554]         }))
[17:59:15.554]     }, error = function(ex) {
[17:59:15.554]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:15.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.554]                 ...future.rng), started = ...future.startTime, 
[17:59:15.554]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:15.554]             version = "1.8"), class = "FutureResult")
[17:59:15.554]     }, finally = {
[17:59:15.554]         if (!identical(...future.workdir, getwd())) 
[17:59:15.554]             setwd(...future.workdir)
[17:59:15.554]         {
[17:59:15.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:15.554]                 ...future.oldOptions$nwarnings <- NULL
[17:59:15.554]             }
[17:59:15.554]             base::options(...future.oldOptions)
[17:59:15.554]             if (.Platform$OS.type == "windows") {
[17:59:15.554]                 old_names <- names(...future.oldEnvVars)
[17:59:15.554]                 envs <- base::Sys.getenv()
[17:59:15.554]                 names <- names(envs)
[17:59:15.554]                 common <- intersect(names, old_names)
[17:59:15.554]                 added <- setdiff(names, old_names)
[17:59:15.554]                 removed <- setdiff(old_names, names)
[17:59:15.554]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:15.554]                   envs[common]]
[17:59:15.554]                 NAMES <- toupper(changed)
[17:59:15.554]                 args <- list()
[17:59:15.554]                 for (kk in seq_along(NAMES)) {
[17:59:15.554]                   name <- changed[[kk]]
[17:59:15.554]                   NAME <- NAMES[[kk]]
[17:59:15.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.554]                     next
[17:59:15.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.554]                 }
[17:59:15.554]                 NAMES <- toupper(added)
[17:59:15.554]                 for (kk in seq_along(NAMES)) {
[17:59:15.554]                   name <- added[[kk]]
[17:59:15.554]                   NAME <- NAMES[[kk]]
[17:59:15.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.554]                     next
[17:59:15.554]                   args[[name]] <- ""
[17:59:15.554]                 }
[17:59:15.554]                 NAMES <- toupper(removed)
[17:59:15.554]                 for (kk in seq_along(NAMES)) {
[17:59:15.554]                   name <- removed[[kk]]
[17:59:15.554]                   NAME <- NAMES[[kk]]
[17:59:15.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.554]                     next
[17:59:15.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.554]                 }
[17:59:15.554]                 if (length(args) > 0) 
[17:59:15.554]                   base::do.call(base::Sys.setenv, args = args)
[17:59:15.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:15.554]             }
[17:59:15.554]             else {
[17:59:15.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:15.554]             }
[17:59:15.554]             {
[17:59:15.554]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:15.554]                   0L) {
[17:59:15.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:15.554]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:15.554]                   base::options(opts)
[17:59:15.554]                 }
[17:59:15.554]                 {
[17:59:15.554]                   {
[17:59:15.554]                     NULL
[17:59:15.554]                     RNGkind("Mersenne-Twister")
[17:59:15.554]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:15.554]                       inherits = FALSE)
[17:59:15.554]                   }
[17:59:15.554]                   options(future.plan = NULL)
[17:59:15.554]                   if (is.na(NA_character_)) 
[17:59:15.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:15.554]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:15.554]                     .init = FALSE)
[17:59:15.554]                 }
[17:59:15.554]             }
[17:59:15.554]         }
[17:59:15.554]     })
[17:59:15.554]     if (TRUE) {
[17:59:15.554]         base::sink(type = "output", split = FALSE)
[17:59:15.554]         if (TRUE) {
[17:59:15.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:15.554]         }
[17:59:15.554]         else {
[17:59:15.554]             ...future.result["stdout"] <- base::list(NULL)
[17:59:15.554]         }
[17:59:15.554]         base::close(...future.stdout)
[17:59:15.554]         ...future.stdout <- NULL
[17:59:15.554]     }
[17:59:15.554]     ...future.result$conditions <- ...future.conditions
[17:59:15.554]     ...future.result$finished <- base::Sys.time()
[17:59:15.554]     ...future.result
[17:59:15.554] }
[17:59:15.557] assign_globals() ...
[17:59:15.557] List of 5
[17:59:15.557]  $ future.call.arguments    : list()
[17:59:15.557]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.557]  $ ...future.FUN            :function (x)  
[17:59:15.557]  $ ...future.elements_ii    :List of 2
[17:59:15.557]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:59:15.557]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:59:15.557]  $ ...future.seeds_ii       : NULL
[17:59:15.557]  $ ...future.globals.maxSize: num Inf
[17:59:15.557]  - attr(*, "resolved")= logi FALSE
[17:59:15.557]  - attr(*, "total_size")= num NA
[17:59:15.557]  - attr(*, "where")=List of 5
[17:59:15.557]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:15.557]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:15.557]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:15.557]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:15.557]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:15.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.557]  - attr(*, "already-done")= logi TRUE
[17:59:15.569] - copied ‘future.call.arguments’ to environment
[17:59:15.570] - copied ‘...future.FUN’ to environment
[17:59:15.570] - copied ‘...future.elements_ii’ to environment
[17:59:15.570] - copied ‘...future.seeds_ii’ to environment
[17:59:15.570] - copied ‘...future.globals.maxSize’ to environment
[17:59:15.571] assign_globals() ... done
[17:59:15.571] plan(): Setting new future strategy stack:
[17:59:15.571] List of future strategies:
[17:59:15.571] 1. sequential:
[17:59:15.571]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.571]    - tweaked: FALSE
[17:59:15.571]    - call: NULL
[17:59:15.572] plan(): nbrOfWorkers() = 1
[17:59:15.574] plan(): Setting new future strategy stack:
[17:59:15.574] List of future strategies:
[17:59:15.574] 1. sequential:
[17:59:15.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.574]    - tweaked: FALSE
[17:59:15.574]    - call: plan(strategy)
[17:59:15.575] plan(): nbrOfWorkers() = 1
[17:59:15.575] SequentialFuture started (and completed)
[17:59:15.575] - Launch lazy future ... done
[17:59:15.575] run() for ‘SequentialFuture’ ... done
[17:59:15.576] Created future:
[17:59:15.576] SequentialFuture:
[17:59:15.576] Label: ‘future_apply-1’
[17:59:15.576] Expression:
[17:59:15.576] {
[17:59:15.576]     do.call(function(...) {
[17:59:15.576]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.576]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.576]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.576]             on.exit(options(oopts), add = TRUE)
[17:59:15.576]         }
[17:59:15.576]         {
[17:59:15.576]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.576]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.576]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.576]             })
[17:59:15.576]         }
[17:59:15.576]     }, args = future.call.arguments)
[17:59:15.576] }
[17:59:15.576] Lazy evaluation: FALSE
[17:59:15.576] Asynchronous evaluation: FALSE
[17:59:15.576] Local evaluation: TRUE
[17:59:15.576] Environment: R_GlobalEnv
[17:59:15.576] Capture standard output: TRUE
[17:59:15.576] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:15.576] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:15.576] Packages: <none>
[17:59:15.576] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:15.576] Resolved: TRUE
[17:59:15.576] Value: 224 bytes of class ‘list’
[17:59:15.576] Early signaling: FALSE
[17:59:15.576] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:15.576] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.578] Chunk #1 of 1 ... DONE
[17:59:15.578] Launching 1 futures (chunks) ... DONE
[17:59:15.578] Resolving 1 futures (chunks) ...
[17:59:15.579] resolve() on list ...
[17:59:15.579]  recursive: 0
[17:59:15.579]  length: 1
[17:59:15.579] 
[17:59:15.579] resolved() for ‘SequentialFuture’ ...
[17:59:15.580] - state: ‘finished’
[17:59:15.580] - run: TRUE
[17:59:15.580] - result: ‘FutureResult’
[17:59:15.580] resolved() for ‘SequentialFuture’ ... done
[17:59:15.581] Future #1
[17:59:15.581] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:15.581] - nx: 1
[17:59:15.581] - relay: TRUE
[17:59:15.581] - stdout: TRUE
[17:59:15.582] - signal: TRUE
[17:59:15.582] - resignal: FALSE
[17:59:15.582] - force: TRUE
[17:59:15.582] - relayed: [n=1] FALSE
[17:59:15.582] - queued futures: [n=1] FALSE
[17:59:15.583]  - until=1
[17:59:15.583]  - relaying element #1
[17:59:15.583] - relayed: [n=1] TRUE
[17:59:15.583] - queued futures: [n=1] TRUE
[17:59:15.584] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:15.584]  length: 0 (resolved future 1)
[17:59:15.584] Relaying remaining futures
[17:59:15.584] signalConditionsASAP(NULL, pos=0) ...
[17:59:15.584] - nx: 1
[17:59:15.584] - relay: TRUE
[17:59:15.585] - stdout: TRUE
[17:59:15.585] - signal: TRUE
[17:59:15.585] - resignal: FALSE
[17:59:15.585] - force: TRUE
[17:59:15.585] - relayed: [n=1] TRUE
[17:59:15.586] - queued futures: [n=1] TRUE
 - flush all
[17:59:15.586] - relayed: [n=1] TRUE
[17:59:15.586] - queued futures: [n=1] TRUE
[17:59:15.586] signalConditionsASAP(NULL, pos=0) ... done
[17:59:15.586] resolve() on list ... DONE
[17:59:15.587]  - Number of value chunks collected: 1
[17:59:15.587] Resolving 1 futures (chunks) ... DONE
[17:59:15.587] Reducing values from 1 chunks ...
[17:59:15.587]  - Number of values collected after concatenation: 2
[17:59:15.588]  - Number of values expected: 2
[17:59:15.588] Reducing values from 1 chunks ... DONE
[17:59:15.588] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:59:15.589] getGlobalsAndPackagesXApply() ...
[17:59:15.589]  - future.globals: TRUE
[17:59:15.589] getGlobalsAndPackages() ...
[17:59:15.589] Searching for globals...
[17:59:15.591] - globals found: [1] ‘FUN’
[17:59:15.592] Searching for globals ... DONE
[17:59:15.592] Resolving globals: FALSE
[17:59:15.592] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:15.593] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:15.594] - globals: [1] ‘FUN’
[17:59:15.594] 
[17:59:15.594] getGlobalsAndPackages() ... DONE
[17:59:15.594]  - globals found/used: [n=1] ‘FUN’
[17:59:15.595]  - needed namespaces: [n=0] 
[17:59:15.595] Finding globals ... DONE
[17:59:15.595]  - use_args: TRUE
[17:59:15.595]  - Getting '...' globals ...
[17:59:15.596] resolve() on list ...
[17:59:15.596]  recursive: 0
[17:59:15.596]  length: 1
[17:59:15.596]  elements: ‘...’
[17:59:15.597]  length: 0 (resolved future 1)
[17:59:15.597] resolve() on list ... DONE
[17:59:15.597]    - '...' content: [n=0] 
[17:59:15.597] List of 1
[17:59:15.597]  $ ...: list()
[17:59:15.597]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.597]  - attr(*, "where")=List of 1
[17:59:15.597]   ..$ ...:<environment: 0x56085b45fb20> 
[17:59:15.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.597]  - attr(*, "resolved")= logi TRUE
[17:59:15.597]  - attr(*, "total_size")= num NA
[17:59:15.603]  - Getting '...' globals ... DONE
[17:59:15.603] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:15.604] List of 2
[17:59:15.604]  $ ...future.FUN:function (x)  
[17:59:15.604]  $ ...          : list()
[17:59:15.604]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.604]  - attr(*, "where")=List of 2
[17:59:15.604]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:15.604]   ..$ ...          :<environment: 0x56085b45fb20> 
[17:59:15.604]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.604]  - attr(*, "resolved")= logi FALSE
[17:59:15.604]  - attr(*, "total_size")= num 848
[17:59:15.612] Packages to be attached in all futures: [n=0] 
[17:59:15.612] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.613] future_lapply() ...
[17:59:15.614] Number of chunks: 1
[17:59:15.614] getGlobalsAndPackagesXApply() ...
[17:59:15.614]  - future.globals: <name-value list> with names ‘list()’
[17:59:15.615]  - use_args: TRUE
[17:59:15.615] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:15.615] List of 2
[17:59:15.615]  $ ...          : list()
[17:59:15.615]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.615]  $ ...future.FUN:function (x)  
[17:59:15.615]  - attr(*, "where")=List of 2
[17:59:15.615]   ..$ ...          :<environment: 0x56085b45fb20> 
[17:59:15.615]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:15.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.615]  - attr(*, "resolved")= logi FALSE
[17:59:15.615]  - attr(*, "total_size")= num NA
[17:59:15.623] Packages to be attached in all futures: [n=0] 
[17:59:15.623] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.623] Number of futures (= number of chunks): 1
[17:59:15.624] Launching 1 futures (chunks) ...
[17:59:15.624] Chunk #1 of 1 ...
[17:59:15.624]  - seeds: <none>
[17:59:15.624]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.625] getGlobalsAndPackages() ...
[17:59:15.625] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.625] Resolving globals: FALSE
[17:59:15.625] Tweak future expression to call with '...' arguments ...
[17:59:15.626] {
[17:59:15.626]     do.call(function(...) {
[17:59:15.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.626]             on.exit(options(oopts), add = TRUE)
[17:59:15.626]         }
[17:59:15.626]         {
[17:59:15.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.626]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.626]             })
[17:59:15.626]         }
[17:59:15.626]     }, args = future.call.arguments)
[17:59:15.626] }
[17:59:15.626] Tweak future expression to call with '...' arguments ... DONE
[17:59:15.627] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.627] 
[17:59:15.627] getGlobalsAndPackages() ... DONE
[17:59:15.628] run() for ‘Future’ ...
[17:59:15.628] - state: ‘created’
[17:59:15.629] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:15.629] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:15.630]   - Field: ‘label’
[17:59:15.630]   - Field: ‘local’
[17:59:15.630]   - Field: ‘owner’
[17:59:15.630]   - Field: ‘envir’
[17:59:15.631]   - Field: ‘packages’
[17:59:15.631]   - Field: ‘gc’
[17:59:15.631]   - Field: ‘conditions’
[17:59:15.631]   - Field: ‘expr’
[17:59:15.631]   - Field: ‘uuid’
[17:59:15.632]   - Field: ‘seed’
[17:59:15.632]   - Field: ‘version’
[17:59:15.632]   - Field: ‘result’
[17:59:15.632]   - Field: ‘asynchronous’
[17:59:15.632]   - Field: ‘calls’
[17:59:15.633]   - Field: ‘globals’
[17:59:15.633]   - Field: ‘stdout’
[17:59:15.633]   - Field: ‘earlySignal’
[17:59:15.633]   - Field: ‘lazy’
[17:59:15.633]   - Field: ‘state’
[17:59:15.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:15.634] - Launch lazy future ...
[17:59:15.634] Packages needed by the future expression (n = 0): <none>
[17:59:15.634] Packages needed by future strategies (n = 0): <none>
[17:59:15.635] {
[17:59:15.635]     {
[17:59:15.635]         {
[17:59:15.635]             ...future.startTime <- base::Sys.time()
[17:59:15.635]             {
[17:59:15.635]                 {
[17:59:15.635]                   {
[17:59:15.635]                     base::local({
[17:59:15.635]                       has_future <- base::requireNamespace("future", 
[17:59:15.635]                         quietly = TRUE)
[17:59:15.635]                       if (has_future) {
[17:59:15.635]                         ns <- base::getNamespace("future")
[17:59:15.635]                         version <- ns[[".package"]][["version"]]
[17:59:15.635]                         if (is.null(version)) 
[17:59:15.635]                           version <- utils::packageVersion("future")
[17:59:15.635]                       }
[17:59:15.635]                       else {
[17:59:15.635]                         version <- NULL
[17:59:15.635]                       }
[17:59:15.635]                       if (!has_future || version < "1.8.0") {
[17:59:15.635]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:15.635]                           "", base::R.version$version.string), 
[17:59:15.635]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:15.635]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:15.635]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:15.635]                             "release", "version")], collapse = " "), 
[17:59:15.635]                           hostname = base::Sys.info()[["nodename"]])
[17:59:15.635]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:15.635]                           info)
[17:59:15.635]                         info <- base::paste(info, collapse = "; ")
[17:59:15.635]                         if (!has_future) {
[17:59:15.635]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:15.635]                             info)
[17:59:15.635]                         }
[17:59:15.635]                         else {
[17:59:15.635]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:15.635]                             info, version)
[17:59:15.635]                         }
[17:59:15.635]                         base::stop(msg)
[17:59:15.635]                       }
[17:59:15.635]                     })
[17:59:15.635]                   }
[17:59:15.635]                   ...future.strategy.old <- future::plan("list")
[17:59:15.635]                   options(future.plan = NULL)
[17:59:15.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:15.635]                 }
[17:59:15.635]                 ...future.workdir <- getwd()
[17:59:15.635]             }
[17:59:15.635]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:15.635]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:15.635]         }
[17:59:15.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:15.635]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:15.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:15.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:15.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:15.635]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:15.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:15.635]             base::names(...future.oldOptions))
[17:59:15.635]     }
[17:59:15.635]     if (FALSE) {
[17:59:15.635]     }
[17:59:15.635]     else {
[17:59:15.635]         if (TRUE) {
[17:59:15.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:15.635]                 open = "w")
[17:59:15.635]         }
[17:59:15.635]         else {
[17:59:15.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:15.635]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:15.635]         }
[17:59:15.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:15.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:15.635]             base::sink(type = "output", split = FALSE)
[17:59:15.635]             base::close(...future.stdout)
[17:59:15.635]         }, add = TRUE)
[17:59:15.635]     }
[17:59:15.635]     ...future.frame <- base::sys.nframe()
[17:59:15.635]     ...future.conditions <- base::list()
[17:59:15.635]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:15.635]     if (FALSE) {
[17:59:15.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:15.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:15.635]     }
[17:59:15.635]     ...future.result <- base::tryCatch({
[17:59:15.635]         base::withCallingHandlers({
[17:59:15.635]             ...future.value <- base::withVisible(base::local({
[17:59:15.635]                 do.call(function(...) {
[17:59:15.635]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.635]                   if (!identical(...future.globals.maxSize.org, 
[17:59:15.635]                     ...future.globals.maxSize)) {
[17:59:15.635]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.635]                     on.exit(options(oopts), add = TRUE)
[17:59:15.635]                   }
[17:59:15.635]                   {
[17:59:15.635]                     lapply(seq_along(...future.elements_ii), 
[17:59:15.635]                       FUN = function(jj) {
[17:59:15.635]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.635]                         ...future.FUN(...future.X_jj, ...)
[17:59:15.635]                       })
[17:59:15.635]                   }
[17:59:15.635]                 }, args = future.call.arguments)
[17:59:15.635]             }))
[17:59:15.635]             future::FutureResult(value = ...future.value$value, 
[17:59:15.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.635]                   ...future.rng), globalenv = if (FALSE) 
[17:59:15.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:15.635]                     ...future.globalenv.names))
[17:59:15.635]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:15.635]         }, condition = base::local({
[17:59:15.635]             c <- base::c
[17:59:15.635]             inherits <- base::inherits
[17:59:15.635]             invokeRestart <- base::invokeRestart
[17:59:15.635]             length <- base::length
[17:59:15.635]             list <- base::list
[17:59:15.635]             seq.int <- base::seq.int
[17:59:15.635]             signalCondition <- base::signalCondition
[17:59:15.635]             sys.calls <- base::sys.calls
[17:59:15.635]             `[[` <- base::`[[`
[17:59:15.635]             `+` <- base::`+`
[17:59:15.635]             `<<-` <- base::`<<-`
[17:59:15.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:15.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:15.635]                   3L)]
[17:59:15.635]             }
[17:59:15.635]             function(cond) {
[17:59:15.635]                 is_error <- inherits(cond, "error")
[17:59:15.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:15.635]                   NULL)
[17:59:15.635]                 if (is_error) {
[17:59:15.635]                   sessionInformation <- function() {
[17:59:15.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:15.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:15.635]                       search = base::search(), system = base::Sys.info())
[17:59:15.635]                   }
[17:59:15.635]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:15.635]                     cond$call), session = sessionInformation(), 
[17:59:15.635]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:15.635]                   signalCondition(cond)
[17:59:15.635]                 }
[17:59:15.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:15.635]                 "immediateCondition"))) {
[17:59:15.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:15.635]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:15.635]                   if (TRUE && !signal) {
[17:59:15.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.635]                     {
[17:59:15.635]                       inherits <- base::inherits
[17:59:15.635]                       invokeRestart <- base::invokeRestart
[17:59:15.635]                       is.null <- base::is.null
[17:59:15.635]                       muffled <- FALSE
[17:59:15.635]                       if (inherits(cond, "message")) {
[17:59:15.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.635]                         if (muffled) 
[17:59:15.635]                           invokeRestart("muffleMessage")
[17:59:15.635]                       }
[17:59:15.635]                       else if (inherits(cond, "warning")) {
[17:59:15.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.635]                         if (muffled) 
[17:59:15.635]                           invokeRestart("muffleWarning")
[17:59:15.635]                       }
[17:59:15.635]                       else if (inherits(cond, "condition")) {
[17:59:15.635]                         if (!is.null(pattern)) {
[17:59:15.635]                           computeRestarts <- base::computeRestarts
[17:59:15.635]                           grepl <- base::grepl
[17:59:15.635]                           restarts <- computeRestarts(cond)
[17:59:15.635]                           for (restart in restarts) {
[17:59:15.635]                             name <- restart$name
[17:59:15.635]                             if (is.null(name)) 
[17:59:15.635]                               next
[17:59:15.635]                             if (!grepl(pattern, name)) 
[17:59:15.635]                               next
[17:59:15.635]                             invokeRestart(restart)
[17:59:15.635]                             muffled <- TRUE
[17:59:15.635]                             break
[17:59:15.635]                           }
[17:59:15.635]                         }
[17:59:15.635]                       }
[17:59:15.635]                       invisible(muffled)
[17:59:15.635]                     }
[17:59:15.635]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.635]                   }
[17:59:15.635]                 }
[17:59:15.635]                 else {
[17:59:15.635]                   if (TRUE) {
[17:59:15.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.635]                     {
[17:59:15.635]                       inherits <- base::inherits
[17:59:15.635]                       invokeRestart <- base::invokeRestart
[17:59:15.635]                       is.null <- base::is.null
[17:59:15.635]                       muffled <- FALSE
[17:59:15.635]                       if (inherits(cond, "message")) {
[17:59:15.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.635]                         if (muffled) 
[17:59:15.635]                           invokeRestart("muffleMessage")
[17:59:15.635]                       }
[17:59:15.635]                       else if (inherits(cond, "warning")) {
[17:59:15.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.635]                         if (muffled) 
[17:59:15.635]                           invokeRestart("muffleWarning")
[17:59:15.635]                       }
[17:59:15.635]                       else if (inherits(cond, "condition")) {
[17:59:15.635]                         if (!is.null(pattern)) {
[17:59:15.635]                           computeRestarts <- base::computeRestarts
[17:59:15.635]                           grepl <- base::grepl
[17:59:15.635]                           restarts <- computeRestarts(cond)
[17:59:15.635]                           for (restart in restarts) {
[17:59:15.635]                             name <- restart$name
[17:59:15.635]                             if (is.null(name)) 
[17:59:15.635]                               next
[17:59:15.635]                             if (!grepl(pattern, name)) 
[17:59:15.635]                               next
[17:59:15.635]                             invokeRestart(restart)
[17:59:15.635]                             muffled <- TRUE
[17:59:15.635]                             break
[17:59:15.635]                           }
[17:59:15.635]                         }
[17:59:15.635]                       }
[17:59:15.635]                       invisible(muffled)
[17:59:15.635]                     }
[17:59:15.635]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.635]                   }
[17:59:15.635]                 }
[17:59:15.635]             }
[17:59:15.635]         }))
[17:59:15.635]     }, error = function(ex) {
[17:59:15.635]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:15.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.635]                 ...future.rng), started = ...future.startTime, 
[17:59:15.635]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:15.635]             version = "1.8"), class = "FutureResult")
[17:59:15.635]     }, finally = {
[17:59:15.635]         if (!identical(...future.workdir, getwd())) 
[17:59:15.635]             setwd(...future.workdir)
[17:59:15.635]         {
[17:59:15.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:15.635]                 ...future.oldOptions$nwarnings <- NULL
[17:59:15.635]             }
[17:59:15.635]             base::options(...future.oldOptions)
[17:59:15.635]             if (.Platform$OS.type == "windows") {
[17:59:15.635]                 old_names <- names(...future.oldEnvVars)
[17:59:15.635]                 envs <- base::Sys.getenv()
[17:59:15.635]                 names <- names(envs)
[17:59:15.635]                 common <- intersect(names, old_names)
[17:59:15.635]                 added <- setdiff(names, old_names)
[17:59:15.635]                 removed <- setdiff(old_names, names)
[17:59:15.635]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:15.635]                   envs[common]]
[17:59:15.635]                 NAMES <- toupper(changed)
[17:59:15.635]                 args <- list()
[17:59:15.635]                 for (kk in seq_along(NAMES)) {
[17:59:15.635]                   name <- changed[[kk]]
[17:59:15.635]                   NAME <- NAMES[[kk]]
[17:59:15.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.635]                     next
[17:59:15.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.635]                 }
[17:59:15.635]                 NAMES <- toupper(added)
[17:59:15.635]                 for (kk in seq_along(NAMES)) {
[17:59:15.635]                   name <- added[[kk]]
[17:59:15.635]                   NAME <- NAMES[[kk]]
[17:59:15.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.635]                     next
[17:59:15.635]                   args[[name]] <- ""
[17:59:15.635]                 }
[17:59:15.635]                 NAMES <- toupper(removed)
[17:59:15.635]                 for (kk in seq_along(NAMES)) {
[17:59:15.635]                   name <- removed[[kk]]
[17:59:15.635]                   NAME <- NAMES[[kk]]
[17:59:15.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.635]                     next
[17:59:15.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.635]                 }
[17:59:15.635]                 if (length(args) > 0) 
[17:59:15.635]                   base::do.call(base::Sys.setenv, args = args)
[17:59:15.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:15.635]             }
[17:59:15.635]             else {
[17:59:15.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:15.635]             }
[17:59:15.635]             {
[17:59:15.635]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:15.635]                   0L) {
[17:59:15.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:15.635]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:15.635]                   base::options(opts)
[17:59:15.635]                 }
[17:59:15.635]                 {
[17:59:15.635]                   {
[17:59:15.635]                     NULL
[17:59:15.635]                     RNGkind("Mersenne-Twister")
[17:59:15.635]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:15.635]                       inherits = FALSE)
[17:59:15.635]                   }
[17:59:15.635]                   options(future.plan = NULL)
[17:59:15.635]                   if (is.na(NA_character_)) 
[17:59:15.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:15.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:15.635]                     .init = FALSE)
[17:59:15.635]                 }
[17:59:15.635]             }
[17:59:15.635]         }
[17:59:15.635]     })
[17:59:15.635]     if (TRUE) {
[17:59:15.635]         base::sink(type = "output", split = FALSE)
[17:59:15.635]         if (TRUE) {
[17:59:15.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:15.635]         }
[17:59:15.635]         else {
[17:59:15.635]             ...future.result["stdout"] <- base::list(NULL)
[17:59:15.635]         }
[17:59:15.635]         base::close(...future.stdout)
[17:59:15.635]         ...future.stdout <- NULL
[17:59:15.635]     }
[17:59:15.635]     ...future.result$conditions <- ...future.conditions
[17:59:15.635]     ...future.result$finished <- base::Sys.time()
[17:59:15.635]     ...future.result
[17:59:15.635] }
[17:59:15.639] assign_globals() ...
[17:59:15.639] List of 5
[17:59:15.639]  $ future.call.arguments    : list()
[17:59:15.639]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.639]  $ ...future.FUN            :function (x)  
[17:59:15.639]  $ ...future.elements_ii    :List of 6
[17:59:15.639]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:59:15.639]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:59:15.639]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:59:15.639]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:59:15.639]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:59:15.639]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:59:15.639]  $ ...future.seeds_ii       : NULL
[17:59:15.639]  $ ...future.globals.maxSize: num Inf
[17:59:15.639]  - attr(*, "resolved")= logi FALSE
[17:59:15.639]  - attr(*, "total_size")= num NA
[17:59:15.639]  - attr(*, "where")=List of 5
[17:59:15.639]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:15.639]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:15.639]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:15.639]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:15.639]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:15.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.639]  - attr(*, "already-done")= logi TRUE
[17:59:15.653] - copied ‘future.call.arguments’ to environment
[17:59:15.654] - copied ‘...future.FUN’ to environment
[17:59:15.654] - copied ‘...future.elements_ii’ to environment
[17:59:15.654] - copied ‘...future.seeds_ii’ to environment
[17:59:15.654] - copied ‘...future.globals.maxSize’ to environment
[17:59:15.654] assign_globals() ... done
[17:59:15.655] plan(): Setting new future strategy stack:
[17:59:15.655] List of future strategies:
[17:59:15.655] 1. sequential:
[17:59:15.655]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.655]    - tweaked: FALSE
[17:59:15.655]    - call: NULL
[17:59:15.656] plan(): nbrOfWorkers() = 1
[17:59:15.657] plan(): Setting new future strategy stack:
[17:59:15.658] List of future strategies:
[17:59:15.658] 1. sequential:
[17:59:15.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.658]    - tweaked: FALSE
[17:59:15.658]    - call: plan(strategy)
[17:59:15.659] plan(): nbrOfWorkers() = 1
[17:59:15.659] SequentialFuture started (and completed)
[17:59:15.659] - Launch lazy future ... done
[17:59:15.659] run() for ‘SequentialFuture’ ... done
[17:59:15.660] Created future:
[17:59:15.660] SequentialFuture:
[17:59:15.660] Label: ‘future_apply-1’
[17:59:15.660] Expression:
[17:59:15.660] {
[17:59:15.660]     do.call(function(...) {
[17:59:15.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.660]             on.exit(options(oopts), add = TRUE)
[17:59:15.660]         }
[17:59:15.660]         {
[17:59:15.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.660]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.660]             })
[17:59:15.660]         }
[17:59:15.660]     }, args = future.call.arguments)
[17:59:15.660] }
[17:59:15.660] Lazy evaluation: FALSE
[17:59:15.660] Asynchronous evaluation: FALSE
[17:59:15.660] Local evaluation: TRUE
[17:59:15.660] Environment: R_GlobalEnv
[17:59:15.660] Capture standard output: TRUE
[17:59:15.660] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:15.660] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:15.660] Packages: <none>
[17:59:15.660] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:15.660] Resolved: TRUE
[17:59:15.660] Value: 672 bytes of class ‘list’
[17:59:15.660] Early signaling: FALSE
[17:59:15.660] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:15.660] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.662] Chunk #1 of 1 ... DONE
[17:59:15.662] Launching 1 futures (chunks) ... DONE
[17:59:15.662] Resolving 1 futures (chunks) ...
[17:59:15.662] resolve() on list ...
[17:59:15.663]  recursive: 0
[17:59:15.663]  length: 1
[17:59:15.663] 
[17:59:15.665] resolved() for ‘SequentialFuture’ ...
[17:59:15.666] - state: ‘finished’
[17:59:15.666] - run: TRUE
[17:59:15.666] - result: ‘FutureResult’
[17:59:15.666] resolved() for ‘SequentialFuture’ ... done
[17:59:15.667] Future #1
[17:59:15.667] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:15.667] - nx: 1
[17:59:15.667] - relay: TRUE
[17:59:15.667] - stdout: TRUE
[17:59:15.668] - signal: TRUE
[17:59:15.668] - resignal: FALSE
[17:59:15.668] - force: TRUE
[17:59:15.668] - relayed: [n=1] FALSE
[17:59:15.668] - queued futures: [n=1] FALSE
[17:59:15.669]  - until=1
[17:59:15.669]  - relaying element #1
[17:59:15.669] - relayed: [n=1] TRUE
[17:59:15.669] - queued futures: [n=1] TRUE
[17:59:15.669] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:15.670]  length: 0 (resolved future 1)
[17:59:15.670] Relaying remaining futures
[17:59:15.670] signalConditionsASAP(NULL, pos=0) ...
[17:59:15.670] - nx: 1
[17:59:15.670] - relay: TRUE
[17:59:15.671] - stdout: TRUE
[17:59:15.671] - signal: TRUE
[17:59:15.671] - resignal: FALSE
[17:59:15.671] - force: TRUE
[17:59:15.671] - relayed: [n=1] TRUE
[17:59:15.671] - queued futures: [n=1] TRUE
 - flush all
[17:59:15.672] - relayed: [n=1] TRUE
[17:59:15.672] - queued futures: [n=1] TRUE
[17:59:15.672] signalConditionsASAP(NULL, pos=0) ... done
[17:59:15.672] resolve() on list ... DONE
[17:59:15.673]  - Number of value chunks collected: 1
[17:59:15.673] Resolving 1 futures (chunks) ... DONE
[17:59:15.673] Reducing values from 1 chunks ...
[17:59:15.673]  - Number of values collected after concatenation: 6
[17:59:15.673]  - Number of values expected: 6
[17:59:15.674] Reducing values from 1 chunks ... DONE
[17:59:15.674] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:59:15.675] getGlobalsAndPackagesXApply() ...
[17:59:15.675]  - future.globals: TRUE
[17:59:15.675] getGlobalsAndPackages() ...
[17:59:15.675] Searching for globals...
[17:59:15.679] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:59:15.680] Searching for globals ... DONE
[17:59:15.680] Resolving globals: FALSE
[17:59:15.681] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:59:15.682] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:59:15.682] - globals: [1] ‘FUN’
[17:59:15.682] 
[17:59:15.682] getGlobalsAndPackages() ... DONE
[17:59:15.683]  - globals found/used: [n=1] ‘FUN’
[17:59:15.684]  - needed namespaces: [n=0] 
[17:59:15.684] Finding globals ... DONE
[17:59:15.684]  - use_args: TRUE
[17:59:15.684]  - Getting '...' globals ...
[17:59:15.685] resolve() on list ...
[17:59:15.686]  recursive: 0
[17:59:15.686]  length: 1
[17:59:15.686]  elements: ‘...’
[17:59:15.686]  length: 0 (resolved future 1)
[17:59:15.686] resolve() on list ... DONE
[17:59:15.687]    - '...' content: [n=0] 
[17:59:15.687] List of 1
[17:59:15.687]  $ ...: list()
[17:59:15.687]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.687]  - attr(*, "where")=List of 1
[17:59:15.687]   ..$ ...:<environment: 0x56085912d3b0> 
[17:59:15.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.687]  - attr(*, "resolved")= logi TRUE
[17:59:15.687]  - attr(*, "total_size")= num NA
[17:59:15.692]  - Getting '...' globals ... DONE
[17:59:15.693] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:15.693] List of 2
[17:59:15.693]  $ ...future.FUN:function (x)  
[17:59:15.693]  $ ...          : list()
[17:59:15.693]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.693]  - attr(*, "where")=List of 2
[17:59:15.693]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:15.693]   ..$ ...          :<environment: 0x56085912d3b0> 
[17:59:15.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.693]  - attr(*, "resolved")= logi FALSE
[17:59:15.693]  - attr(*, "total_size")= num 1768
[17:59:15.699] Packages to be attached in all futures: [n=0] 
[17:59:15.699] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.700] future_lapply() ...
[17:59:15.701] Number of chunks: 1
[17:59:15.701] getGlobalsAndPackagesXApply() ...
[17:59:15.701]  - future.globals: <name-value list> with names ‘list()’
[17:59:15.702]  - use_args: TRUE
[17:59:15.702] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:15.702] List of 2
[17:59:15.702]  $ ...          : list()
[17:59:15.702]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.702]  $ ...future.FUN:function (x)  
[17:59:15.702]  - attr(*, "where")=List of 2
[17:59:15.702]   ..$ ...          :<environment: 0x56085912d3b0> 
[17:59:15.702]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:59:15.702]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.702]  - attr(*, "resolved")= logi FALSE
[17:59:15.702]  - attr(*, "total_size")= num NA
[17:59:15.708] Packages to be attached in all futures: [n=0] 
[17:59:15.708] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.709] Number of futures (= number of chunks): 1
[17:59:15.709] Launching 1 futures (chunks) ...
[17:59:15.709] Chunk #1 of 1 ...
[17:59:15.709]  - seeds: <none>
[17:59:15.710]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.710] getGlobalsAndPackages() ...
[17:59:15.710] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.710] Resolving globals: FALSE
[17:59:15.711] Tweak future expression to call with '...' arguments ...
[17:59:15.711] {
[17:59:15.711]     do.call(function(...) {
[17:59:15.711]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.711]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.711]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.711]             on.exit(options(oopts), add = TRUE)
[17:59:15.711]         }
[17:59:15.711]         {
[17:59:15.711]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.711]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.711]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.711]             })
[17:59:15.711]         }
[17:59:15.711]     }, args = future.call.arguments)
[17:59:15.711] }
[17:59:15.711] Tweak future expression to call with '...' arguments ... DONE
[17:59:15.713] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.713] 
[17:59:15.713] getGlobalsAndPackages() ... DONE
[17:59:15.714] run() for ‘Future’ ...
[17:59:15.714] - state: ‘created’
[17:59:15.714] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:15.715] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:15.716]   - Field: ‘label’
[17:59:15.716]   - Field: ‘local’
[17:59:15.716]   - Field: ‘owner’
[17:59:15.716]   - Field: ‘envir’
[17:59:15.717]   - Field: ‘packages’
[17:59:15.719]   - Field: ‘gc’
[17:59:15.720]   - Field: ‘conditions’
[17:59:15.720]   - Field: ‘expr’
[17:59:15.720]   - Field: ‘uuid’
[17:59:15.720]   - Field: ‘seed’
[17:59:15.720]   - Field: ‘version’
[17:59:15.721]   - Field: ‘result’
[17:59:15.721]   - Field: ‘asynchronous’
[17:59:15.721]   - Field: ‘calls’
[17:59:15.721]   - Field: ‘globals’
[17:59:15.721]   - Field: ‘stdout’
[17:59:15.722]   - Field: ‘earlySignal’
[17:59:15.722]   - Field: ‘lazy’
[17:59:15.722]   - Field: ‘state’
[17:59:15.722] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:15.723] - Launch lazy future ...
[17:59:15.723] Packages needed by the future expression (n = 0): <none>
[17:59:15.723] Packages needed by future strategies (n = 0): <none>
[17:59:15.724] {
[17:59:15.724]     {
[17:59:15.724]         {
[17:59:15.724]             ...future.startTime <- base::Sys.time()
[17:59:15.724]             {
[17:59:15.724]                 {
[17:59:15.724]                   {
[17:59:15.724]                     base::local({
[17:59:15.724]                       has_future <- base::requireNamespace("future", 
[17:59:15.724]                         quietly = TRUE)
[17:59:15.724]                       if (has_future) {
[17:59:15.724]                         ns <- base::getNamespace("future")
[17:59:15.724]                         version <- ns[[".package"]][["version"]]
[17:59:15.724]                         if (is.null(version)) 
[17:59:15.724]                           version <- utils::packageVersion("future")
[17:59:15.724]                       }
[17:59:15.724]                       else {
[17:59:15.724]                         version <- NULL
[17:59:15.724]                       }
[17:59:15.724]                       if (!has_future || version < "1.8.0") {
[17:59:15.724]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:15.724]                           "", base::R.version$version.string), 
[17:59:15.724]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:15.724]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:15.724]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:15.724]                             "release", "version")], collapse = " "), 
[17:59:15.724]                           hostname = base::Sys.info()[["nodename"]])
[17:59:15.724]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:15.724]                           info)
[17:59:15.724]                         info <- base::paste(info, collapse = "; ")
[17:59:15.724]                         if (!has_future) {
[17:59:15.724]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:15.724]                             info)
[17:59:15.724]                         }
[17:59:15.724]                         else {
[17:59:15.724]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:15.724]                             info, version)
[17:59:15.724]                         }
[17:59:15.724]                         base::stop(msg)
[17:59:15.724]                       }
[17:59:15.724]                     })
[17:59:15.724]                   }
[17:59:15.724]                   ...future.strategy.old <- future::plan("list")
[17:59:15.724]                   options(future.plan = NULL)
[17:59:15.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:15.724]                 }
[17:59:15.724]                 ...future.workdir <- getwd()
[17:59:15.724]             }
[17:59:15.724]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:15.724]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:15.724]         }
[17:59:15.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:15.724]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:15.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:15.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:15.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:15.724]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:15.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:15.724]             base::names(...future.oldOptions))
[17:59:15.724]     }
[17:59:15.724]     if (FALSE) {
[17:59:15.724]     }
[17:59:15.724]     else {
[17:59:15.724]         if (TRUE) {
[17:59:15.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:15.724]                 open = "w")
[17:59:15.724]         }
[17:59:15.724]         else {
[17:59:15.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:15.724]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:15.724]         }
[17:59:15.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:15.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:15.724]             base::sink(type = "output", split = FALSE)
[17:59:15.724]             base::close(...future.stdout)
[17:59:15.724]         }, add = TRUE)
[17:59:15.724]     }
[17:59:15.724]     ...future.frame <- base::sys.nframe()
[17:59:15.724]     ...future.conditions <- base::list()
[17:59:15.724]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:15.724]     if (FALSE) {
[17:59:15.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:15.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:15.724]     }
[17:59:15.724]     ...future.result <- base::tryCatch({
[17:59:15.724]         base::withCallingHandlers({
[17:59:15.724]             ...future.value <- base::withVisible(base::local({
[17:59:15.724]                 do.call(function(...) {
[17:59:15.724]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.724]                   if (!identical(...future.globals.maxSize.org, 
[17:59:15.724]                     ...future.globals.maxSize)) {
[17:59:15.724]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.724]                     on.exit(options(oopts), add = TRUE)
[17:59:15.724]                   }
[17:59:15.724]                   {
[17:59:15.724]                     lapply(seq_along(...future.elements_ii), 
[17:59:15.724]                       FUN = function(jj) {
[17:59:15.724]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.724]                         ...future.FUN(...future.X_jj, ...)
[17:59:15.724]                       })
[17:59:15.724]                   }
[17:59:15.724]                 }, args = future.call.arguments)
[17:59:15.724]             }))
[17:59:15.724]             future::FutureResult(value = ...future.value$value, 
[17:59:15.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.724]                   ...future.rng), globalenv = if (FALSE) 
[17:59:15.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:15.724]                     ...future.globalenv.names))
[17:59:15.724]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:15.724]         }, condition = base::local({
[17:59:15.724]             c <- base::c
[17:59:15.724]             inherits <- base::inherits
[17:59:15.724]             invokeRestart <- base::invokeRestart
[17:59:15.724]             length <- base::length
[17:59:15.724]             list <- base::list
[17:59:15.724]             seq.int <- base::seq.int
[17:59:15.724]             signalCondition <- base::signalCondition
[17:59:15.724]             sys.calls <- base::sys.calls
[17:59:15.724]             `[[` <- base::`[[`
[17:59:15.724]             `+` <- base::`+`
[17:59:15.724]             `<<-` <- base::`<<-`
[17:59:15.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:15.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:15.724]                   3L)]
[17:59:15.724]             }
[17:59:15.724]             function(cond) {
[17:59:15.724]                 is_error <- inherits(cond, "error")
[17:59:15.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:15.724]                   NULL)
[17:59:15.724]                 if (is_error) {
[17:59:15.724]                   sessionInformation <- function() {
[17:59:15.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:15.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:15.724]                       search = base::search(), system = base::Sys.info())
[17:59:15.724]                   }
[17:59:15.724]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:15.724]                     cond$call), session = sessionInformation(), 
[17:59:15.724]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:15.724]                   signalCondition(cond)
[17:59:15.724]                 }
[17:59:15.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:15.724]                 "immediateCondition"))) {
[17:59:15.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:15.724]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:15.724]                   if (TRUE && !signal) {
[17:59:15.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.724]                     {
[17:59:15.724]                       inherits <- base::inherits
[17:59:15.724]                       invokeRestart <- base::invokeRestart
[17:59:15.724]                       is.null <- base::is.null
[17:59:15.724]                       muffled <- FALSE
[17:59:15.724]                       if (inherits(cond, "message")) {
[17:59:15.724]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.724]                         if (muffled) 
[17:59:15.724]                           invokeRestart("muffleMessage")
[17:59:15.724]                       }
[17:59:15.724]                       else if (inherits(cond, "warning")) {
[17:59:15.724]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.724]                         if (muffled) 
[17:59:15.724]                           invokeRestart("muffleWarning")
[17:59:15.724]                       }
[17:59:15.724]                       else if (inherits(cond, "condition")) {
[17:59:15.724]                         if (!is.null(pattern)) {
[17:59:15.724]                           computeRestarts <- base::computeRestarts
[17:59:15.724]                           grepl <- base::grepl
[17:59:15.724]                           restarts <- computeRestarts(cond)
[17:59:15.724]                           for (restart in restarts) {
[17:59:15.724]                             name <- restart$name
[17:59:15.724]                             if (is.null(name)) 
[17:59:15.724]                               next
[17:59:15.724]                             if (!grepl(pattern, name)) 
[17:59:15.724]                               next
[17:59:15.724]                             invokeRestart(restart)
[17:59:15.724]                             muffled <- TRUE
[17:59:15.724]                             break
[17:59:15.724]                           }
[17:59:15.724]                         }
[17:59:15.724]                       }
[17:59:15.724]                       invisible(muffled)
[17:59:15.724]                     }
[17:59:15.724]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.724]                   }
[17:59:15.724]                 }
[17:59:15.724]                 else {
[17:59:15.724]                   if (TRUE) {
[17:59:15.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.724]                     {
[17:59:15.724]                       inherits <- base::inherits
[17:59:15.724]                       invokeRestart <- base::invokeRestart
[17:59:15.724]                       is.null <- base::is.null
[17:59:15.724]                       muffled <- FALSE
[17:59:15.724]                       if (inherits(cond, "message")) {
[17:59:15.724]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.724]                         if (muffled) 
[17:59:15.724]                           invokeRestart("muffleMessage")
[17:59:15.724]                       }
[17:59:15.724]                       else if (inherits(cond, "warning")) {
[17:59:15.724]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.724]                         if (muffled) 
[17:59:15.724]                           invokeRestart("muffleWarning")
[17:59:15.724]                       }
[17:59:15.724]                       else if (inherits(cond, "condition")) {
[17:59:15.724]                         if (!is.null(pattern)) {
[17:59:15.724]                           computeRestarts <- base::computeRestarts
[17:59:15.724]                           grepl <- base::grepl
[17:59:15.724]                           restarts <- computeRestarts(cond)
[17:59:15.724]                           for (restart in restarts) {
[17:59:15.724]                             name <- restart$name
[17:59:15.724]                             if (is.null(name)) 
[17:59:15.724]                               next
[17:59:15.724]                             if (!grepl(pattern, name)) 
[17:59:15.724]                               next
[17:59:15.724]                             invokeRestart(restart)
[17:59:15.724]                             muffled <- TRUE
[17:59:15.724]                             break
[17:59:15.724]                           }
[17:59:15.724]                         }
[17:59:15.724]                       }
[17:59:15.724]                       invisible(muffled)
[17:59:15.724]                     }
[17:59:15.724]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.724]                   }
[17:59:15.724]                 }
[17:59:15.724]             }
[17:59:15.724]         }))
[17:59:15.724]     }, error = function(ex) {
[17:59:15.724]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:15.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.724]                 ...future.rng), started = ...future.startTime, 
[17:59:15.724]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:15.724]             version = "1.8"), class = "FutureResult")
[17:59:15.724]     }, finally = {
[17:59:15.724]         if (!identical(...future.workdir, getwd())) 
[17:59:15.724]             setwd(...future.workdir)
[17:59:15.724]         {
[17:59:15.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:15.724]                 ...future.oldOptions$nwarnings <- NULL
[17:59:15.724]             }
[17:59:15.724]             base::options(...future.oldOptions)
[17:59:15.724]             if (.Platform$OS.type == "windows") {
[17:59:15.724]                 old_names <- names(...future.oldEnvVars)
[17:59:15.724]                 envs <- base::Sys.getenv()
[17:59:15.724]                 names <- names(envs)
[17:59:15.724]                 common <- intersect(names, old_names)
[17:59:15.724]                 added <- setdiff(names, old_names)
[17:59:15.724]                 removed <- setdiff(old_names, names)
[17:59:15.724]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:15.724]                   envs[common]]
[17:59:15.724]                 NAMES <- toupper(changed)
[17:59:15.724]                 args <- list()
[17:59:15.724]                 for (kk in seq_along(NAMES)) {
[17:59:15.724]                   name <- changed[[kk]]
[17:59:15.724]                   NAME <- NAMES[[kk]]
[17:59:15.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.724]                     next
[17:59:15.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.724]                 }
[17:59:15.724]                 NAMES <- toupper(added)
[17:59:15.724]                 for (kk in seq_along(NAMES)) {
[17:59:15.724]                   name <- added[[kk]]
[17:59:15.724]                   NAME <- NAMES[[kk]]
[17:59:15.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.724]                     next
[17:59:15.724]                   args[[name]] <- ""
[17:59:15.724]                 }
[17:59:15.724]                 NAMES <- toupper(removed)
[17:59:15.724]                 for (kk in seq_along(NAMES)) {
[17:59:15.724]                   name <- removed[[kk]]
[17:59:15.724]                   NAME <- NAMES[[kk]]
[17:59:15.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.724]                     next
[17:59:15.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.724]                 }
[17:59:15.724]                 if (length(args) > 0) 
[17:59:15.724]                   base::do.call(base::Sys.setenv, args = args)
[17:59:15.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:15.724]             }
[17:59:15.724]             else {
[17:59:15.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:15.724]             }
[17:59:15.724]             {
[17:59:15.724]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:15.724]                   0L) {
[17:59:15.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:15.724]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:15.724]                   base::options(opts)
[17:59:15.724]                 }
[17:59:15.724]                 {
[17:59:15.724]                   {
[17:59:15.724]                     NULL
[17:59:15.724]                     RNGkind("Mersenne-Twister")
[17:59:15.724]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:15.724]                       inherits = FALSE)
[17:59:15.724]                   }
[17:59:15.724]                   options(future.plan = NULL)
[17:59:15.724]                   if (is.na(NA_character_)) 
[17:59:15.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:15.724]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:15.724]                     .init = FALSE)
[17:59:15.724]                 }
[17:59:15.724]             }
[17:59:15.724]         }
[17:59:15.724]     })
[17:59:15.724]     if (TRUE) {
[17:59:15.724]         base::sink(type = "output", split = FALSE)
[17:59:15.724]         if (TRUE) {
[17:59:15.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:15.724]         }
[17:59:15.724]         else {
[17:59:15.724]             ...future.result["stdout"] <- base::list(NULL)
[17:59:15.724]         }
[17:59:15.724]         base::close(...future.stdout)
[17:59:15.724]         ...future.stdout <- NULL
[17:59:15.724]     }
[17:59:15.724]     ...future.result$conditions <- ...future.conditions
[17:59:15.724]     ...future.result$finished <- base::Sys.time()
[17:59:15.724]     ...future.result
[17:59:15.724] }
[17:59:15.728] assign_globals() ...
[17:59:15.728] List of 5
[17:59:15.728]  $ future.call.arguments    : list()
[17:59:15.728]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.728]  $ ...future.FUN            :function (x)  
[17:59:15.728]  $ ...future.elements_ii    :List of 6
[17:59:15.728]   ..$ : int [1:4] 1 7 13 19
[17:59:15.728]   ..$ : int [1:4] 2 8 14 20
[17:59:15.728]   ..$ : int [1:4] 3 9 15 21
[17:59:15.728]   ..$ : int [1:4] 4 10 16 22
[17:59:15.728]   ..$ : int [1:4] 5 11 17 23
[17:59:15.728]   ..$ : int [1:4] 6 12 18 24
[17:59:15.728]  $ ...future.seeds_ii       : NULL
[17:59:15.728]  $ ...future.globals.maxSize: num Inf
[17:59:15.728]  - attr(*, "resolved")= logi FALSE
[17:59:15.728]  - attr(*, "total_size")= num NA
[17:59:15.728]  - attr(*, "where")=List of 5
[17:59:15.728]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:15.728]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:15.728]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:15.728]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:15.728]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:15.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.728]  - attr(*, "already-done")= logi TRUE
[17:59:15.742] - copied ‘future.call.arguments’ to environment
[17:59:15.742] - reassign environment for ‘...future.FUN’
[17:59:15.742] - copied ‘...future.FUN’ to environment
[17:59:15.742] - copied ‘...future.elements_ii’ to environment
[17:59:15.743] - copied ‘...future.seeds_ii’ to environment
[17:59:15.743] - copied ‘...future.globals.maxSize’ to environment
[17:59:15.743] assign_globals() ... done
[17:59:15.744] plan(): Setting new future strategy stack:
[17:59:15.744] List of future strategies:
[17:59:15.744] 1. sequential:
[17:59:15.744]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.744]    - tweaked: FALSE
[17:59:15.744]    - call: NULL
[17:59:15.745] plan(): nbrOfWorkers() = 1
[17:59:15.746] plan(): Setting new future strategy stack:
[17:59:15.747] List of future strategies:
[17:59:15.747] 1. sequential:
[17:59:15.747]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.747]    - tweaked: FALSE
[17:59:15.747]    - call: plan(strategy)
[17:59:15.747] plan(): nbrOfWorkers() = 1
[17:59:15.748] SequentialFuture started (and completed)
[17:59:15.748] - Launch lazy future ... done
[17:59:15.748] run() for ‘SequentialFuture’ ... done
[17:59:15.748] Created future:
[17:59:15.749] SequentialFuture:
[17:59:15.749] Label: ‘future_apply-1’
[17:59:15.749] Expression:
[17:59:15.749] {
[17:59:15.749]     do.call(function(...) {
[17:59:15.749]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.749]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.749]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.749]             on.exit(options(oopts), add = TRUE)
[17:59:15.749]         }
[17:59:15.749]         {
[17:59:15.749]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.749]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.749]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.749]             })
[17:59:15.749]         }
[17:59:15.749]     }, args = future.call.arguments)
[17:59:15.749] }
[17:59:15.749] Lazy evaluation: FALSE
[17:59:15.749] Asynchronous evaluation: FALSE
[17:59:15.749] Local evaluation: TRUE
[17:59:15.749] Environment: R_GlobalEnv
[17:59:15.749] Capture standard output: TRUE
[17:59:15.749] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:15.749] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:15.749] Packages: <none>
[17:59:15.749] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:15.749] Resolved: TRUE
[17:59:15.749] Value: 1.03 KiB of class ‘list’
[17:59:15.749] Early signaling: FALSE
[17:59:15.749] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:15.749] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.751] Chunk #1 of 1 ... DONE
[17:59:15.751] Launching 1 futures (chunks) ... DONE
[17:59:15.751] Resolving 1 futures (chunks) ...
[17:59:15.751] resolve() on list ...
[17:59:15.752]  recursive: 0
[17:59:15.752]  length: 1
[17:59:15.752] 
[17:59:15.752] resolved() for ‘SequentialFuture’ ...
[17:59:15.752] - state: ‘finished’
[17:59:15.752] - run: TRUE
[17:59:15.753] - result: ‘FutureResult’
[17:59:15.753] resolved() for ‘SequentialFuture’ ... done
[17:59:15.753] Future #1
[17:59:15.753] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:15.754] - nx: 1
[17:59:15.754] - relay: TRUE
[17:59:15.754] - stdout: TRUE
[17:59:15.754] - signal: TRUE
[17:59:15.754] - resignal: FALSE
[17:59:15.754] - force: TRUE
[17:59:15.755] - relayed: [n=1] FALSE
[17:59:15.755] - queued futures: [n=1] FALSE
[17:59:15.755]  - until=1
[17:59:15.755]  - relaying element #1
[17:59:15.756] - relayed: [n=1] TRUE
[17:59:15.756] - queued futures: [n=1] TRUE
[17:59:15.756] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:15.756]  length: 0 (resolved future 1)
[17:59:15.757] Relaying remaining futures
[17:59:15.757] signalConditionsASAP(NULL, pos=0) ...
[17:59:15.757] - nx: 1
[17:59:15.758] - relay: TRUE
[17:59:15.758] - stdout: TRUE
[17:59:15.758] - signal: TRUE
[17:59:15.759] - resignal: FALSE
[17:59:15.759] - force: TRUE
[17:59:15.759] - relayed: [n=1] TRUE
[17:59:15.759] - queued futures: [n=1] TRUE
 - flush all
[17:59:15.759] - relayed: [n=1] TRUE
[17:59:15.760] - queued futures: [n=1] TRUE
[17:59:15.760] signalConditionsASAP(NULL, pos=0) ... done
[17:59:15.760] resolve() on list ... DONE
[17:59:15.760]  - Number of value chunks collected: 1
[17:59:15.761] Resolving 1 futures (chunks) ... DONE
[17:59:15.761] Reducing values from 1 chunks ...
[17:59:15.761]  - Number of values collected after concatenation: 6
[17:59:15.761]  - Number of values expected: 6
[17:59:15.761] Reducing values from 1 chunks ... DONE
[17:59:15.762] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:59:15.762] getGlobalsAndPackagesXApply() ...
[17:59:15.762]  - future.globals: TRUE
[17:59:15.763] getGlobalsAndPackages() ...
[17:59:15.763] Searching for globals...
[17:59:15.765] - globals found: [1] ‘FUN’
[17:59:15.765] Searching for globals ... DONE
[17:59:15.765] Resolving globals: FALSE
[17:59:15.766] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:15.766] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:15.767] - globals: [1] ‘FUN’
[17:59:15.767] 
[17:59:15.767] getGlobalsAndPackages() ... DONE
[17:59:15.767]  - globals found/used: [n=1] ‘FUN’
[17:59:15.768]  - needed namespaces: [n=0] 
[17:59:15.768] Finding globals ... DONE
[17:59:15.768]  - use_args: TRUE
[17:59:15.768]  - Getting '...' globals ...
[17:59:15.769] resolve() on list ...
[17:59:15.769]  recursive: 0
[17:59:15.769]  length: 1
[17:59:15.769]  elements: ‘...’
[17:59:15.770]  length: 0 (resolved future 1)
[17:59:15.772] resolve() on list ... DONE
[17:59:15.772]    - '...' content: [n=0] 
[17:59:15.773] List of 1
[17:59:15.773]  $ ...: list()
[17:59:15.773]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.773]  - attr(*, "where")=List of 1
[17:59:15.773]   ..$ ...:<environment: 0x56085b7aba58> 
[17:59:15.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.773]  - attr(*, "resolved")= logi TRUE
[17:59:15.773]  - attr(*, "total_size")= num NA
[17:59:15.778]  - Getting '...' globals ... DONE
[17:59:15.778] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:15.778] List of 2
[17:59:15.778]  $ ...future.FUN:function (x)  
[17:59:15.778]  $ ...          : list()
[17:59:15.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.778]  - attr(*, "where")=List of 2
[17:59:15.778]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:15.778]   ..$ ...          :<environment: 0x56085b7aba58> 
[17:59:15.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.778]  - attr(*, "resolved")= logi FALSE
[17:59:15.778]  - attr(*, "total_size")= num 848
[17:59:15.783] Packages to be attached in all futures: [n=0] 
[17:59:15.784] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.784] future_lapply() ...
[17:59:15.785] Number of chunks: 1
[17:59:15.785] getGlobalsAndPackagesXApply() ...
[17:59:15.785]  - future.globals: <name-value list> with names ‘list()’
[17:59:15.786]  - use_args: TRUE
[17:59:15.786] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:15.786] List of 2
[17:59:15.786]  $ ...          : list()
[17:59:15.786]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.786]  $ ...future.FUN:function (x)  
[17:59:15.786]  - attr(*, "where")=List of 2
[17:59:15.786]   ..$ ...          :<environment: 0x56085b7aba58> 
[17:59:15.786]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:15.786]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.786]  - attr(*, "resolved")= logi FALSE
[17:59:15.786]  - attr(*, "total_size")= num NA
[17:59:15.793] Packages to be attached in all futures: [n=0] 
[17:59:15.793] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.793] Number of futures (= number of chunks): 1
[17:59:15.794] Launching 1 futures (chunks) ...
[17:59:15.794] Chunk #1 of 1 ...
[17:59:15.794]  - seeds: <none>
[17:59:15.794]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.794] getGlobalsAndPackages() ...
[17:59:15.795] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.795] Resolving globals: FALSE
[17:59:15.795] Tweak future expression to call with '...' arguments ...
[17:59:15.795] {
[17:59:15.795]     do.call(function(...) {
[17:59:15.795]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.795]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.795]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.795]             on.exit(options(oopts), add = TRUE)
[17:59:15.795]         }
[17:59:15.795]         {
[17:59:15.795]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.795]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.795]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.795]             })
[17:59:15.795]         }
[17:59:15.795]     }, args = future.call.arguments)
[17:59:15.795] }
[17:59:15.796] Tweak future expression to call with '...' arguments ... DONE
[17:59:15.797] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.797] 
[17:59:15.797] getGlobalsAndPackages() ... DONE
[17:59:15.798] run() for ‘Future’ ...
[17:59:15.798] - state: ‘created’
[17:59:15.798] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:15.799] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.799] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:15.799]   - Field: ‘label’
[17:59:15.799]   - Field: ‘local’
[17:59:15.799]   - Field: ‘owner’
[17:59:15.800]   - Field: ‘envir’
[17:59:15.800]   - Field: ‘packages’
[17:59:15.800]   - Field: ‘gc’
[17:59:15.800]   - Field: ‘conditions’
[17:59:15.800]   - Field: ‘expr’
[17:59:15.801]   - Field: ‘uuid’
[17:59:15.801]   - Field: ‘seed’
[17:59:15.801]   - Field: ‘version’
[17:59:15.801]   - Field: ‘result’
[17:59:15.801]   - Field: ‘asynchronous’
[17:59:15.802]   - Field: ‘calls’
[17:59:15.802]   - Field: ‘globals’
[17:59:15.802]   - Field: ‘stdout’
[17:59:15.802]   - Field: ‘earlySignal’
[17:59:15.802]   - Field: ‘lazy’
[17:59:15.803]   - Field: ‘state’
[17:59:15.803] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:15.803] - Launch lazy future ...
[17:59:15.803] Packages needed by the future expression (n = 0): <none>
[17:59:15.804] Packages needed by future strategies (n = 0): <none>
[17:59:15.804] {
[17:59:15.804]     {
[17:59:15.804]         {
[17:59:15.804]             ...future.startTime <- base::Sys.time()
[17:59:15.804]             {
[17:59:15.804]                 {
[17:59:15.804]                   {
[17:59:15.804]                     base::local({
[17:59:15.804]                       has_future <- base::requireNamespace("future", 
[17:59:15.804]                         quietly = TRUE)
[17:59:15.804]                       if (has_future) {
[17:59:15.804]                         ns <- base::getNamespace("future")
[17:59:15.804]                         version <- ns[[".package"]][["version"]]
[17:59:15.804]                         if (is.null(version)) 
[17:59:15.804]                           version <- utils::packageVersion("future")
[17:59:15.804]                       }
[17:59:15.804]                       else {
[17:59:15.804]                         version <- NULL
[17:59:15.804]                       }
[17:59:15.804]                       if (!has_future || version < "1.8.0") {
[17:59:15.804]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:15.804]                           "", base::R.version$version.string), 
[17:59:15.804]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:15.804]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:15.804]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:15.804]                             "release", "version")], collapse = " "), 
[17:59:15.804]                           hostname = base::Sys.info()[["nodename"]])
[17:59:15.804]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:15.804]                           info)
[17:59:15.804]                         info <- base::paste(info, collapse = "; ")
[17:59:15.804]                         if (!has_future) {
[17:59:15.804]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:15.804]                             info)
[17:59:15.804]                         }
[17:59:15.804]                         else {
[17:59:15.804]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:15.804]                             info, version)
[17:59:15.804]                         }
[17:59:15.804]                         base::stop(msg)
[17:59:15.804]                       }
[17:59:15.804]                     })
[17:59:15.804]                   }
[17:59:15.804]                   ...future.strategy.old <- future::plan("list")
[17:59:15.804]                   options(future.plan = NULL)
[17:59:15.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:15.804]                 }
[17:59:15.804]                 ...future.workdir <- getwd()
[17:59:15.804]             }
[17:59:15.804]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:15.804]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:15.804]         }
[17:59:15.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:15.804]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:15.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:15.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:15.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:15.804]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:15.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:15.804]             base::names(...future.oldOptions))
[17:59:15.804]     }
[17:59:15.804]     if (FALSE) {
[17:59:15.804]     }
[17:59:15.804]     else {
[17:59:15.804]         if (TRUE) {
[17:59:15.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:15.804]                 open = "w")
[17:59:15.804]         }
[17:59:15.804]         else {
[17:59:15.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:15.804]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:15.804]         }
[17:59:15.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:15.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:15.804]             base::sink(type = "output", split = FALSE)
[17:59:15.804]             base::close(...future.stdout)
[17:59:15.804]         }, add = TRUE)
[17:59:15.804]     }
[17:59:15.804]     ...future.frame <- base::sys.nframe()
[17:59:15.804]     ...future.conditions <- base::list()
[17:59:15.804]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:15.804]     if (FALSE) {
[17:59:15.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:15.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:15.804]     }
[17:59:15.804]     ...future.result <- base::tryCatch({
[17:59:15.804]         base::withCallingHandlers({
[17:59:15.804]             ...future.value <- base::withVisible(base::local({
[17:59:15.804]                 do.call(function(...) {
[17:59:15.804]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.804]                   if (!identical(...future.globals.maxSize.org, 
[17:59:15.804]                     ...future.globals.maxSize)) {
[17:59:15.804]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.804]                     on.exit(options(oopts), add = TRUE)
[17:59:15.804]                   }
[17:59:15.804]                   {
[17:59:15.804]                     lapply(seq_along(...future.elements_ii), 
[17:59:15.804]                       FUN = function(jj) {
[17:59:15.804]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.804]                         ...future.FUN(...future.X_jj, ...)
[17:59:15.804]                       })
[17:59:15.804]                   }
[17:59:15.804]                 }, args = future.call.arguments)
[17:59:15.804]             }))
[17:59:15.804]             future::FutureResult(value = ...future.value$value, 
[17:59:15.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.804]                   ...future.rng), globalenv = if (FALSE) 
[17:59:15.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:15.804]                     ...future.globalenv.names))
[17:59:15.804]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:15.804]         }, condition = base::local({
[17:59:15.804]             c <- base::c
[17:59:15.804]             inherits <- base::inherits
[17:59:15.804]             invokeRestart <- base::invokeRestart
[17:59:15.804]             length <- base::length
[17:59:15.804]             list <- base::list
[17:59:15.804]             seq.int <- base::seq.int
[17:59:15.804]             signalCondition <- base::signalCondition
[17:59:15.804]             sys.calls <- base::sys.calls
[17:59:15.804]             `[[` <- base::`[[`
[17:59:15.804]             `+` <- base::`+`
[17:59:15.804]             `<<-` <- base::`<<-`
[17:59:15.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:15.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:15.804]                   3L)]
[17:59:15.804]             }
[17:59:15.804]             function(cond) {
[17:59:15.804]                 is_error <- inherits(cond, "error")
[17:59:15.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:15.804]                   NULL)
[17:59:15.804]                 if (is_error) {
[17:59:15.804]                   sessionInformation <- function() {
[17:59:15.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:15.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:15.804]                       search = base::search(), system = base::Sys.info())
[17:59:15.804]                   }
[17:59:15.804]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:15.804]                     cond$call), session = sessionInformation(), 
[17:59:15.804]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:15.804]                   signalCondition(cond)
[17:59:15.804]                 }
[17:59:15.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:15.804]                 "immediateCondition"))) {
[17:59:15.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:15.804]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:15.804]                   if (TRUE && !signal) {
[17:59:15.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.804]                     {
[17:59:15.804]                       inherits <- base::inherits
[17:59:15.804]                       invokeRestart <- base::invokeRestart
[17:59:15.804]                       is.null <- base::is.null
[17:59:15.804]                       muffled <- FALSE
[17:59:15.804]                       if (inherits(cond, "message")) {
[17:59:15.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.804]                         if (muffled) 
[17:59:15.804]                           invokeRestart("muffleMessage")
[17:59:15.804]                       }
[17:59:15.804]                       else if (inherits(cond, "warning")) {
[17:59:15.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.804]                         if (muffled) 
[17:59:15.804]                           invokeRestart("muffleWarning")
[17:59:15.804]                       }
[17:59:15.804]                       else if (inherits(cond, "condition")) {
[17:59:15.804]                         if (!is.null(pattern)) {
[17:59:15.804]                           computeRestarts <- base::computeRestarts
[17:59:15.804]                           grepl <- base::grepl
[17:59:15.804]                           restarts <- computeRestarts(cond)
[17:59:15.804]                           for (restart in restarts) {
[17:59:15.804]                             name <- restart$name
[17:59:15.804]                             if (is.null(name)) 
[17:59:15.804]                               next
[17:59:15.804]                             if (!grepl(pattern, name)) 
[17:59:15.804]                               next
[17:59:15.804]                             invokeRestart(restart)
[17:59:15.804]                             muffled <- TRUE
[17:59:15.804]                             break
[17:59:15.804]                           }
[17:59:15.804]                         }
[17:59:15.804]                       }
[17:59:15.804]                       invisible(muffled)
[17:59:15.804]                     }
[17:59:15.804]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.804]                   }
[17:59:15.804]                 }
[17:59:15.804]                 else {
[17:59:15.804]                   if (TRUE) {
[17:59:15.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.804]                     {
[17:59:15.804]                       inherits <- base::inherits
[17:59:15.804]                       invokeRestart <- base::invokeRestart
[17:59:15.804]                       is.null <- base::is.null
[17:59:15.804]                       muffled <- FALSE
[17:59:15.804]                       if (inherits(cond, "message")) {
[17:59:15.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.804]                         if (muffled) 
[17:59:15.804]                           invokeRestart("muffleMessage")
[17:59:15.804]                       }
[17:59:15.804]                       else if (inherits(cond, "warning")) {
[17:59:15.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.804]                         if (muffled) 
[17:59:15.804]                           invokeRestart("muffleWarning")
[17:59:15.804]                       }
[17:59:15.804]                       else if (inherits(cond, "condition")) {
[17:59:15.804]                         if (!is.null(pattern)) {
[17:59:15.804]                           computeRestarts <- base::computeRestarts
[17:59:15.804]                           grepl <- base::grepl
[17:59:15.804]                           restarts <- computeRestarts(cond)
[17:59:15.804]                           for (restart in restarts) {
[17:59:15.804]                             name <- restart$name
[17:59:15.804]                             if (is.null(name)) 
[17:59:15.804]                               next
[17:59:15.804]                             if (!grepl(pattern, name)) 
[17:59:15.804]                               next
[17:59:15.804]                             invokeRestart(restart)
[17:59:15.804]                             muffled <- TRUE
[17:59:15.804]                             break
[17:59:15.804]                           }
[17:59:15.804]                         }
[17:59:15.804]                       }
[17:59:15.804]                       invisible(muffled)
[17:59:15.804]                     }
[17:59:15.804]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.804]                   }
[17:59:15.804]                 }
[17:59:15.804]             }
[17:59:15.804]         }))
[17:59:15.804]     }, error = function(ex) {
[17:59:15.804]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:15.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.804]                 ...future.rng), started = ...future.startTime, 
[17:59:15.804]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:15.804]             version = "1.8"), class = "FutureResult")
[17:59:15.804]     }, finally = {
[17:59:15.804]         if (!identical(...future.workdir, getwd())) 
[17:59:15.804]             setwd(...future.workdir)
[17:59:15.804]         {
[17:59:15.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:15.804]                 ...future.oldOptions$nwarnings <- NULL
[17:59:15.804]             }
[17:59:15.804]             base::options(...future.oldOptions)
[17:59:15.804]             if (.Platform$OS.type == "windows") {
[17:59:15.804]                 old_names <- names(...future.oldEnvVars)
[17:59:15.804]                 envs <- base::Sys.getenv()
[17:59:15.804]                 names <- names(envs)
[17:59:15.804]                 common <- intersect(names, old_names)
[17:59:15.804]                 added <- setdiff(names, old_names)
[17:59:15.804]                 removed <- setdiff(old_names, names)
[17:59:15.804]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:15.804]                   envs[common]]
[17:59:15.804]                 NAMES <- toupper(changed)
[17:59:15.804]                 args <- list()
[17:59:15.804]                 for (kk in seq_along(NAMES)) {
[17:59:15.804]                   name <- changed[[kk]]
[17:59:15.804]                   NAME <- NAMES[[kk]]
[17:59:15.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.804]                     next
[17:59:15.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.804]                 }
[17:59:15.804]                 NAMES <- toupper(added)
[17:59:15.804]                 for (kk in seq_along(NAMES)) {
[17:59:15.804]                   name <- added[[kk]]
[17:59:15.804]                   NAME <- NAMES[[kk]]
[17:59:15.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.804]                     next
[17:59:15.804]                   args[[name]] <- ""
[17:59:15.804]                 }
[17:59:15.804]                 NAMES <- toupper(removed)
[17:59:15.804]                 for (kk in seq_along(NAMES)) {
[17:59:15.804]                   name <- removed[[kk]]
[17:59:15.804]                   NAME <- NAMES[[kk]]
[17:59:15.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.804]                     next
[17:59:15.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.804]                 }
[17:59:15.804]                 if (length(args) > 0) 
[17:59:15.804]                   base::do.call(base::Sys.setenv, args = args)
[17:59:15.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:15.804]             }
[17:59:15.804]             else {
[17:59:15.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:15.804]             }
[17:59:15.804]             {
[17:59:15.804]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:15.804]                   0L) {
[17:59:15.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:15.804]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:15.804]                   base::options(opts)
[17:59:15.804]                 }
[17:59:15.804]                 {
[17:59:15.804]                   {
[17:59:15.804]                     NULL
[17:59:15.804]                     RNGkind("Mersenne-Twister")
[17:59:15.804]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:15.804]                       inherits = FALSE)
[17:59:15.804]                   }
[17:59:15.804]                   options(future.plan = NULL)
[17:59:15.804]                   if (is.na(NA_character_)) 
[17:59:15.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:15.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:15.804]                     .init = FALSE)
[17:59:15.804]                 }
[17:59:15.804]             }
[17:59:15.804]         }
[17:59:15.804]     })
[17:59:15.804]     if (TRUE) {
[17:59:15.804]         base::sink(type = "output", split = FALSE)
[17:59:15.804]         if (TRUE) {
[17:59:15.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:15.804]         }
[17:59:15.804]         else {
[17:59:15.804]             ...future.result["stdout"] <- base::list(NULL)
[17:59:15.804]         }
[17:59:15.804]         base::close(...future.stdout)
[17:59:15.804]         ...future.stdout <- NULL
[17:59:15.804]     }
[17:59:15.804]     ...future.result$conditions <- ...future.conditions
[17:59:15.804]     ...future.result$finished <- base::Sys.time()
[17:59:15.804]     ...future.result
[17:59:15.804] }
[17:59:15.808] assign_globals() ...
[17:59:15.808] List of 5
[17:59:15.808]  $ future.call.arguments    : list()
[17:59:15.808]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.808]  $ ...future.FUN            :function (x)  
[17:59:15.808]  $ ...future.elements_ii    :List of 2
[17:59:15.808]   ..$ : int 1
[17:59:15.808]   ..$ : int 2
[17:59:15.808]  $ ...future.seeds_ii       : NULL
[17:59:15.808]  $ ...future.globals.maxSize: num Inf
[17:59:15.808]  - attr(*, "resolved")= logi FALSE
[17:59:15.808]  - attr(*, "total_size")= num NA
[17:59:15.808]  - attr(*, "where")=List of 5
[17:59:15.808]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:15.808]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:15.808]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:15.808]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:15.808]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:15.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.808]  - attr(*, "already-done")= logi TRUE
[17:59:15.849] - copied ‘future.call.arguments’ to environment
[17:59:15.849] - copied ‘...future.FUN’ to environment
[17:59:15.849] - copied ‘...future.elements_ii’ to environment
[17:59:15.850] - copied ‘...future.seeds_ii’ to environment
[17:59:15.850] - copied ‘...future.globals.maxSize’ to environment
[17:59:15.850] assign_globals() ... done
[17:59:15.851] plan(): Setting new future strategy stack:
[17:59:15.851] List of future strategies:
[17:59:15.851] 1. sequential:
[17:59:15.851]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.851]    - tweaked: FALSE
[17:59:15.851]    - call: NULL
[17:59:15.852] plan(): nbrOfWorkers() = 1
[17:59:15.853] plan(): Setting new future strategy stack:
[17:59:15.853] List of future strategies:
[17:59:15.853] 1. sequential:
[17:59:15.853]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.853]    - tweaked: FALSE
[17:59:15.853]    - call: plan(strategy)
[17:59:15.854] plan(): nbrOfWorkers() = 1
[17:59:15.855] SequentialFuture started (and completed)
[17:59:15.855] - Launch lazy future ... done
[17:59:15.855] run() for ‘SequentialFuture’ ... done
[17:59:15.855] Created future:
[17:59:15.856] SequentialFuture:
[17:59:15.856] Label: ‘future_apply-1’
[17:59:15.856] Expression:
[17:59:15.856] {
[17:59:15.856]     do.call(function(...) {
[17:59:15.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.856]             on.exit(options(oopts), add = TRUE)
[17:59:15.856]         }
[17:59:15.856]         {
[17:59:15.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.856]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.856]             })
[17:59:15.856]         }
[17:59:15.856]     }, args = future.call.arguments)
[17:59:15.856] }
[17:59:15.856] Lazy evaluation: FALSE
[17:59:15.856] Asynchronous evaluation: FALSE
[17:59:15.856] Local evaluation: TRUE
[17:59:15.856] Environment: R_GlobalEnv
[17:59:15.856] Capture standard output: TRUE
[17:59:15.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:15.856] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:15.856] Packages: <none>
[17:59:15.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:15.856] Resolved: TRUE
[17:59:15.856] Value: 112 bytes of class ‘list’
[17:59:15.856] Early signaling: FALSE
[17:59:15.856] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:15.856] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.858] Chunk #1 of 1 ... DONE
[17:59:15.858] Launching 1 futures (chunks) ... DONE
[17:59:15.858] Resolving 1 futures (chunks) ...
[17:59:15.858] resolve() on list ...
[17:59:15.858]  recursive: 0
[17:59:15.858]  length: 1
[17:59:15.859] 
[17:59:15.859] resolved() for ‘SequentialFuture’ ...
[17:59:15.859] - state: ‘finished’
[17:59:15.860] - run: TRUE
[17:59:15.860] - result: ‘FutureResult’
[17:59:15.860] resolved() for ‘SequentialFuture’ ... done
[17:59:15.860] Future #1
[17:59:15.861] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:15.861] - nx: 1
[17:59:15.861] - relay: TRUE
[17:59:15.861] - stdout: TRUE
[17:59:15.861] - signal: TRUE
[17:59:15.861] - resignal: FALSE
[17:59:15.862] - force: TRUE
[17:59:15.862] - relayed: [n=1] FALSE
[17:59:15.862] - queued futures: [n=1] FALSE
[17:59:15.862]  - until=1
[17:59:15.862]  - relaying element #1
[17:59:15.863] - relayed: [n=1] TRUE
[17:59:15.863] - queued futures: [n=1] TRUE
[17:59:15.863] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:15.863]  length: 0 (resolved future 1)
[17:59:15.863] Relaying remaining futures
[17:59:15.864] signalConditionsASAP(NULL, pos=0) ...
[17:59:15.864] - nx: 1
[17:59:15.864] - relay: TRUE
[17:59:15.864] - stdout: TRUE
[17:59:15.864] - signal: TRUE
[17:59:15.865] - resignal: FALSE
[17:59:15.865] - force: TRUE
[17:59:15.865] - relayed: [n=1] TRUE
[17:59:15.865] - queued futures: [n=1] TRUE
 - flush all
[17:59:15.865] - relayed: [n=1] TRUE
[17:59:15.866] - queued futures: [n=1] TRUE
[17:59:15.866] signalConditionsASAP(NULL, pos=0) ... done
[17:59:15.866] resolve() on list ... DONE
[17:59:15.866]  - Number of value chunks collected: 1
[17:59:15.866] Resolving 1 futures (chunks) ... DONE
[17:59:15.867] Reducing values from 1 chunks ...
[17:59:15.867]  - Number of values collected after concatenation: 2
[17:59:15.867]  - Number of values expected: 2
[17:59:15.867] Reducing values from 1 chunks ... DONE
[17:59:15.867] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:59:15.868] getGlobalsAndPackagesXApply() ...
[17:59:15.868]  - future.globals: TRUE
[17:59:15.868] getGlobalsAndPackages() ...
[17:59:15.868] Searching for globals...
[17:59:15.870] - globals found: [1] ‘FUN’
[17:59:15.871] Searching for globals ... DONE
[17:59:15.871] Resolving globals: FALSE
[17:59:15.871] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:15.872] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:15.872] - globals: [1] ‘FUN’
[17:59:15.872] 
[17:59:15.873] getGlobalsAndPackages() ... DONE
[17:59:15.873]  - globals found/used: [n=1] ‘FUN’
[17:59:15.873]  - needed namespaces: [n=0] 
[17:59:15.873] Finding globals ... DONE
[17:59:15.873]  - use_args: TRUE
[17:59:15.874]  - Getting '...' globals ...
[17:59:15.874] resolve() on list ...
[17:59:15.874]  recursive: 0
[17:59:15.875]  length: 1
[17:59:15.875]  elements: ‘...’
[17:59:15.875]  length: 0 (resolved future 1)
[17:59:15.875] resolve() on list ... DONE
[17:59:15.875]    - '...' content: [n=0] 
[17:59:15.876] List of 1
[17:59:15.876]  $ ...: list()
[17:59:15.876]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.876]  - attr(*, "where")=List of 1
[17:59:15.876]   ..$ ...:<environment: 0x56085a1448c0> 
[17:59:15.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.876]  - attr(*, "resolved")= logi TRUE
[17:59:15.876]  - attr(*, "total_size")= num NA
[17:59:15.880]  - Getting '...' globals ... DONE
[17:59:15.881] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:15.881] List of 2
[17:59:15.881]  $ ...future.FUN:function (x)  
[17:59:15.881]  $ ...          : list()
[17:59:15.881]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.881]  - attr(*, "where")=List of 2
[17:59:15.881]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:15.881]   ..$ ...          :<environment: 0x56085a1448c0> 
[17:59:15.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.881]  - attr(*, "resolved")= logi FALSE
[17:59:15.881]  - attr(*, "total_size")= num 848
[17:59:15.886] Packages to be attached in all futures: [n=0] 
[17:59:15.887] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.887] future_lapply() ...
[17:59:15.888] Number of chunks: 1
[17:59:15.888] getGlobalsAndPackagesXApply() ...
[17:59:15.888]  - future.globals: <name-value list> with names ‘list()’
[17:59:15.889]  - use_args: TRUE
[17:59:15.889] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:15.889] List of 2
[17:59:15.889]  $ ...          : list()
[17:59:15.889]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.889]  $ ...future.FUN:function (x)  
[17:59:15.889]  - attr(*, "where")=List of 2
[17:59:15.889]   ..$ ...          :<environment: 0x56085a1448c0> 
[17:59:15.889]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:15.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.889]  - attr(*, "resolved")= logi FALSE
[17:59:15.889]  - attr(*, "total_size")= num NA
[17:59:15.896] Packages to be attached in all futures: [n=0] 
[17:59:15.896] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.896] Number of futures (= number of chunks): 1
[17:59:15.896] Launching 1 futures (chunks) ...
[17:59:15.897] Chunk #1 of 1 ...
[17:59:15.897]  - seeds: <none>
[17:59:15.897]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.897] getGlobalsAndPackages() ...
[17:59:15.897] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.898] Resolving globals: FALSE
[17:59:15.898] Tweak future expression to call with '...' arguments ...
[17:59:15.898] {
[17:59:15.898]     do.call(function(...) {
[17:59:15.898]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.898]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.898]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.898]             on.exit(options(oopts), add = TRUE)
[17:59:15.898]         }
[17:59:15.898]         {
[17:59:15.898]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.898]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.898]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.898]             })
[17:59:15.898]         }
[17:59:15.898]     }, args = future.call.arguments)
[17:59:15.898] }
[17:59:15.899] Tweak future expression to call with '...' arguments ... DONE
[17:59:15.902] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.902] 
[17:59:15.902] getGlobalsAndPackages() ... DONE
[17:59:15.903] run() for ‘Future’ ...
[17:59:15.903] - state: ‘created’
[17:59:15.903] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:15.904] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.904] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:15.905]   - Field: ‘label’
[17:59:15.905]   - Field: ‘local’
[17:59:15.905]   - Field: ‘owner’
[17:59:15.905]   - Field: ‘envir’
[17:59:15.905]   - Field: ‘packages’
[17:59:15.906]   - Field: ‘gc’
[17:59:15.906]   - Field: ‘conditions’
[17:59:15.906]   - Field: ‘expr’
[17:59:15.906]   - Field: ‘uuid’
[17:59:15.906]   - Field: ‘seed’
[17:59:15.907]   - Field: ‘version’
[17:59:15.907]   - Field: ‘result’
[17:59:15.907]   - Field: ‘asynchronous’
[17:59:15.907]   - Field: ‘calls’
[17:59:15.907]   - Field: ‘globals’
[17:59:15.908]   - Field: ‘stdout’
[17:59:15.908]   - Field: ‘earlySignal’
[17:59:15.908]   - Field: ‘lazy’
[17:59:15.908]   - Field: ‘state’
[17:59:15.908] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:15.909] - Launch lazy future ...
[17:59:15.909] Packages needed by the future expression (n = 0): <none>
[17:59:15.909] Packages needed by future strategies (n = 0): <none>
[17:59:15.910] {
[17:59:15.910]     {
[17:59:15.910]         {
[17:59:15.910]             ...future.startTime <- base::Sys.time()
[17:59:15.910]             {
[17:59:15.910]                 {
[17:59:15.910]                   {
[17:59:15.910]                     base::local({
[17:59:15.910]                       has_future <- base::requireNamespace("future", 
[17:59:15.910]                         quietly = TRUE)
[17:59:15.910]                       if (has_future) {
[17:59:15.910]                         ns <- base::getNamespace("future")
[17:59:15.910]                         version <- ns[[".package"]][["version"]]
[17:59:15.910]                         if (is.null(version)) 
[17:59:15.910]                           version <- utils::packageVersion("future")
[17:59:15.910]                       }
[17:59:15.910]                       else {
[17:59:15.910]                         version <- NULL
[17:59:15.910]                       }
[17:59:15.910]                       if (!has_future || version < "1.8.0") {
[17:59:15.910]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:15.910]                           "", base::R.version$version.string), 
[17:59:15.910]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:15.910]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:15.910]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:15.910]                             "release", "version")], collapse = " "), 
[17:59:15.910]                           hostname = base::Sys.info()[["nodename"]])
[17:59:15.910]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:15.910]                           info)
[17:59:15.910]                         info <- base::paste(info, collapse = "; ")
[17:59:15.910]                         if (!has_future) {
[17:59:15.910]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:15.910]                             info)
[17:59:15.910]                         }
[17:59:15.910]                         else {
[17:59:15.910]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:15.910]                             info, version)
[17:59:15.910]                         }
[17:59:15.910]                         base::stop(msg)
[17:59:15.910]                       }
[17:59:15.910]                     })
[17:59:15.910]                   }
[17:59:15.910]                   ...future.strategy.old <- future::plan("list")
[17:59:15.910]                   options(future.plan = NULL)
[17:59:15.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:15.910]                 }
[17:59:15.910]                 ...future.workdir <- getwd()
[17:59:15.910]             }
[17:59:15.910]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:15.910]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:15.910]         }
[17:59:15.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:15.910]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:15.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:15.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:15.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:15.910]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:15.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:15.910]             base::names(...future.oldOptions))
[17:59:15.910]     }
[17:59:15.910]     if (FALSE) {
[17:59:15.910]     }
[17:59:15.910]     else {
[17:59:15.910]         if (TRUE) {
[17:59:15.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:15.910]                 open = "w")
[17:59:15.910]         }
[17:59:15.910]         else {
[17:59:15.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:15.910]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:15.910]         }
[17:59:15.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:15.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:15.910]             base::sink(type = "output", split = FALSE)
[17:59:15.910]             base::close(...future.stdout)
[17:59:15.910]         }, add = TRUE)
[17:59:15.910]     }
[17:59:15.910]     ...future.frame <- base::sys.nframe()
[17:59:15.910]     ...future.conditions <- base::list()
[17:59:15.910]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:15.910]     if (FALSE) {
[17:59:15.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:15.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:15.910]     }
[17:59:15.910]     ...future.result <- base::tryCatch({
[17:59:15.910]         base::withCallingHandlers({
[17:59:15.910]             ...future.value <- base::withVisible(base::local({
[17:59:15.910]                 do.call(function(...) {
[17:59:15.910]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.910]                   if (!identical(...future.globals.maxSize.org, 
[17:59:15.910]                     ...future.globals.maxSize)) {
[17:59:15.910]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.910]                     on.exit(options(oopts), add = TRUE)
[17:59:15.910]                   }
[17:59:15.910]                   {
[17:59:15.910]                     lapply(seq_along(...future.elements_ii), 
[17:59:15.910]                       FUN = function(jj) {
[17:59:15.910]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.910]                         ...future.FUN(...future.X_jj, ...)
[17:59:15.910]                       })
[17:59:15.910]                   }
[17:59:15.910]                 }, args = future.call.arguments)
[17:59:15.910]             }))
[17:59:15.910]             future::FutureResult(value = ...future.value$value, 
[17:59:15.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.910]                   ...future.rng), globalenv = if (FALSE) 
[17:59:15.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:15.910]                     ...future.globalenv.names))
[17:59:15.910]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:15.910]         }, condition = base::local({
[17:59:15.910]             c <- base::c
[17:59:15.910]             inherits <- base::inherits
[17:59:15.910]             invokeRestart <- base::invokeRestart
[17:59:15.910]             length <- base::length
[17:59:15.910]             list <- base::list
[17:59:15.910]             seq.int <- base::seq.int
[17:59:15.910]             signalCondition <- base::signalCondition
[17:59:15.910]             sys.calls <- base::sys.calls
[17:59:15.910]             `[[` <- base::`[[`
[17:59:15.910]             `+` <- base::`+`
[17:59:15.910]             `<<-` <- base::`<<-`
[17:59:15.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:15.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:15.910]                   3L)]
[17:59:15.910]             }
[17:59:15.910]             function(cond) {
[17:59:15.910]                 is_error <- inherits(cond, "error")
[17:59:15.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:15.910]                   NULL)
[17:59:15.910]                 if (is_error) {
[17:59:15.910]                   sessionInformation <- function() {
[17:59:15.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:15.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:15.910]                       search = base::search(), system = base::Sys.info())
[17:59:15.910]                   }
[17:59:15.910]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:15.910]                     cond$call), session = sessionInformation(), 
[17:59:15.910]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:15.910]                   signalCondition(cond)
[17:59:15.910]                 }
[17:59:15.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:15.910]                 "immediateCondition"))) {
[17:59:15.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:15.910]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:15.910]                   if (TRUE && !signal) {
[17:59:15.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.910]                     {
[17:59:15.910]                       inherits <- base::inherits
[17:59:15.910]                       invokeRestart <- base::invokeRestart
[17:59:15.910]                       is.null <- base::is.null
[17:59:15.910]                       muffled <- FALSE
[17:59:15.910]                       if (inherits(cond, "message")) {
[17:59:15.910]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.910]                         if (muffled) 
[17:59:15.910]                           invokeRestart("muffleMessage")
[17:59:15.910]                       }
[17:59:15.910]                       else if (inherits(cond, "warning")) {
[17:59:15.910]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.910]                         if (muffled) 
[17:59:15.910]                           invokeRestart("muffleWarning")
[17:59:15.910]                       }
[17:59:15.910]                       else if (inherits(cond, "condition")) {
[17:59:15.910]                         if (!is.null(pattern)) {
[17:59:15.910]                           computeRestarts <- base::computeRestarts
[17:59:15.910]                           grepl <- base::grepl
[17:59:15.910]                           restarts <- computeRestarts(cond)
[17:59:15.910]                           for (restart in restarts) {
[17:59:15.910]                             name <- restart$name
[17:59:15.910]                             if (is.null(name)) 
[17:59:15.910]                               next
[17:59:15.910]                             if (!grepl(pattern, name)) 
[17:59:15.910]                               next
[17:59:15.910]                             invokeRestart(restart)
[17:59:15.910]                             muffled <- TRUE
[17:59:15.910]                             break
[17:59:15.910]                           }
[17:59:15.910]                         }
[17:59:15.910]                       }
[17:59:15.910]                       invisible(muffled)
[17:59:15.910]                     }
[17:59:15.910]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.910]                   }
[17:59:15.910]                 }
[17:59:15.910]                 else {
[17:59:15.910]                   if (TRUE) {
[17:59:15.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.910]                     {
[17:59:15.910]                       inherits <- base::inherits
[17:59:15.910]                       invokeRestart <- base::invokeRestart
[17:59:15.910]                       is.null <- base::is.null
[17:59:15.910]                       muffled <- FALSE
[17:59:15.910]                       if (inherits(cond, "message")) {
[17:59:15.910]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.910]                         if (muffled) 
[17:59:15.910]                           invokeRestart("muffleMessage")
[17:59:15.910]                       }
[17:59:15.910]                       else if (inherits(cond, "warning")) {
[17:59:15.910]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.910]                         if (muffled) 
[17:59:15.910]                           invokeRestart("muffleWarning")
[17:59:15.910]                       }
[17:59:15.910]                       else if (inherits(cond, "condition")) {
[17:59:15.910]                         if (!is.null(pattern)) {
[17:59:15.910]                           computeRestarts <- base::computeRestarts
[17:59:15.910]                           grepl <- base::grepl
[17:59:15.910]                           restarts <- computeRestarts(cond)
[17:59:15.910]                           for (restart in restarts) {
[17:59:15.910]                             name <- restart$name
[17:59:15.910]                             if (is.null(name)) 
[17:59:15.910]                               next
[17:59:15.910]                             if (!grepl(pattern, name)) 
[17:59:15.910]                               next
[17:59:15.910]                             invokeRestart(restart)
[17:59:15.910]                             muffled <- TRUE
[17:59:15.910]                             break
[17:59:15.910]                           }
[17:59:15.910]                         }
[17:59:15.910]                       }
[17:59:15.910]                       invisible(muffled)
[17:59:15.910]                     }
[17:59:15.910]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.910]                   }
[17:59:15.910]                 }
[17:59:15.910]             }
[17:59:15.910]         }))
[17:59:15.910]     }, error = function(ex) {
[17:59:15.910]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:15.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.910]                 ...future.rng), started = ...future.startTime, 
[17:59:15.910]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:15.910]             version = "1.8"), class = "FutureResult")
[17:59:15.910]     }, finally = {
[17:59:15.910]         if (!identical(...future.workdir, getwd())) 
[17:59:15.910]             setwd(...future.workdir)
[17:59:15.910]         {
[17:59:15.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:15.910]                 ...future.oldOptions$nwarnings <- NULL
[17:59:15.910]             }
[17:59:15.910]             base::options(...future.oldOptions)
[17:59:15.910]             if (.Platform$OS.type == "windows") {
[17:59:15.910]                 old_names <- names(...future.oldEnvVars)
[17:59:15.910]                 envs <- base::Sys.getenv()
[17:59:15.910]                 names <- names(envs)
[17:59:15.910]                 common <- intersect(names, old_names)
[17:59:15.910]                 added <- setdiff(names, old_names)
[17:59:15.910]                 removed <- setdiff(old_names, names)
[17:59:15.910]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:15.910]                   envs[common]]
[17:59:15.910]                 NAMES <- toupper(changed)
[17:59:15.910]                 args <- list()
[17:59:15.910]                 for (kk in seq_along(NAMES)) {
[17:59:15.910]                   name <- changed[[kk]]
[17:59:15.910]                   NAME <- NAMES[[kk]]
[17:59:15.910]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.910]                     next
[17:59:15.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.910]                 }
[17:59:15.910]                 NAMES <- toupper(added)
[17:59:15.910]                 for (kk in seq_along(NAMES)) {
[17:59:15.910]                   name <- added[[kk]]
[17:59:15.910]                   NAME <- NAMES[[kk]]
[17:59:15.910]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.910]                     next
[17:59:15.910]                   args[[name]] <- ""
[17:59:15.910]                 }
[17:59:15.910]                 NAMES <- toupper(removed)
[17:59:15.910]                 for (kk in seq_along(NAMES)) {
[17:59:15.910]                   name <- removed[[kk]]
[17:59:15.910]                   NAME <- NAMES[[kk]]
[17:59:15.910]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.910]                     next
[17:59:15.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.910]                 }
[17:59:15.910]                 if (length(args) > 0) 
[17:59:15.910]                   base::do.call(base::Sys.setenv, args = args)
[17:59:15.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:15.910]             }
[17:59:15.910]             else {
[17:59:15.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:15.910]             }
[17:59:15.910]             {
[17:59:15.910]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:15.910]                   0L) {
[17:59:15.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:15.910]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:15.910]                   base::options(opts)
[17:59:15.910]                 }
[17:59:15.910]                 {
[17:59:15.910]                   {
[17:59:15.910]                     NULL
[17:59:15.910]                     RNGkind("Mersenne-Twister")
[17:59:15.910]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:15.910]                       inherits = FALSE)
[17:59:15.910]                   }
[17:59:15.910]                   options(future.plan = NULL)
[17:59:15.910]                   if (is.na(NA_character_)) 
[17:59:15.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:15.910]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:15.910]                     .init = FALSE)
[17:59:15.910]                 }
[17:59:15.910]             }
[17:59:15.910]         }
[17:59:15.910]     })
[17:59:15.910]     if (TRUE) {
[17:59:15.910]         base::sink(type = "output", split = FALSE)
[17:59:15.910]         if (TRUE) {
[17:59:15.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:15.910]         }
[17:59:15.910]         else {
[17:59:15.910]             ...future.result["stdout"] <- base::list(NULL)
[17:59:15.910]         }
[17:59:15.910]         base::close(...future.stdout)
[17:59:15.910]         ...future.stdout <- NULL
[17:59:15.910]     }
[17:59:15.910]     ...future.result$conditions <- ...future.conditions
[17:59:15.910]     ...future.result$finished <- base::Sys.time()
[17:59:15.910]     ...future.result
[17:59:15.910] }
[17:59:15.914] assign_globals() ...
[17:59:15.914] List of 5
[17:59:15.914]  $ future.call.arguments    : list()
[17:59:15.914]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.914]  $ ...future.FUN            :function (x)  
[17:59:15.914]  $ ...future.elements_ii    :List of 2
[17:59:15.914]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[17:59:15.914]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[17:59:15.914]  $ ...future.seeds_ii       : NULL
[17:59:15.914]  $ ...future.globals.maxSize: num Inf
[17:59:15.914]  - attr(*, "resolved")= logi FALSE
[17:59:15.914]  - attr(*, "total_size")= num NA
[17:59:15.914]  - attr(*, "where")=List of 5
[17:59:15.914]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:15.914]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:15.914]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:15.914]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:15.914]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:15.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.914]  - attr(*, "already-done")= logi TRUE
[17:59:15.926] - copied ‘future.call.arguments’ to environment
[17:59:15.926] - copied ‘...future.FUN’ to environment
[17:59:15.926] - copied ‘...future.elements_ii’ to environment
[17:59:15.926] - copied ‘...future.seeds_ii’ to environment
[17:59:15.927] - copied ‘...future.globals.maxSize’ to environment
[17:59:15.927] assign_globals() ... done
[17:59:15.927] plan(): Setting new future strategy stack:
[17:59:15.927] List of future strategies:
[17:59:15.927] 1. sequential:
[17:59:15.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.927]    - tweaked: FALSE
[17:59:15.927]    - call: NULL
[17:59:15.928] plan(): nbrOfWorkers() = 1
[17:59:15.930] plan(): Setting new future strategy stack:
[17:59:15.930] List of future strategies:
[17:59:15.930] 1. sequential:
[17:59:15.930]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:15.930]    - tweaked: FALSE
[17:59:15.930]    - call: plan(strategy)
[17:59:15.931] plan(): nbrOfWorkers() = 1
[17:59:15.931] SequentialFuture started (and completed)
[17:59:15.932] - Launch lazy future ... done
[17:59:15.932] run() for ‘SequentialFuture’ ... done
[17:59:15.932] Created future:
[17:59:15.932] SequentialFuture:
[17:59:15.932] Label: ‘future_apply-1’
[17:59:15.932] Expression:
[17:59:15.932] {
[17:59:15.932]     do.call(function(...) {
[17:59:15.932]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.932]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.932]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.932]             on.exit(options(oopts), add = TRUE)
[17:59:15.932]         }
[17:59:15.932]         {
[17:59:15.932]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.932]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.932]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.932]             })
[17:59:15.932]         }
[17:59:15.932]     }, args = future.call.arguments)
[17:59:15.932] }
[17:59:15.932] Lazy evaluation: FALSE
[17:59:15.932] Asynchronous evaluation: FALSE
[17:59:15.932] Local evaluation: TRUE
[17:59:15.932] Environment: R_GlobalEnv
[17:59:15.932] Capture standard output: TRUE
[17:59:15.932] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:15.932] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:15.932] Packages: <none>
[17:59:15.932] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:15.932] Resolved: TRUE
[17:59:15.932] Value: 496 bytes of class ‘list’
[17:59:15.932] Early signaling: FALSE
[17:59:15.932] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:15.932] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.934] Chunk #1 of 1 ... DONE
[17:59:15.934] Launching 1 futures (chunks) ... DONE
[17:59:15.934] Resolving 1 futures (chunks) ...
[17:59:15.935] resolve() on list ...
[17:59:15.935]  recursive: 0
[17:59:15.935]  length: 1
[17:59:15.935] 
[17:59:15.935] resolved() for ‘SequentialFuture’ ...
[17:59:15.936] - state: ‘finished’
[17:59:15.936] - run: TRUE
[17:59:15.936] - result: ‘FutureResult’
[17:59:15.936] resolved() for ‘SequentialFuture’ ... done
[17:59:15.936] Future #1
[17:59:15.937] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:15.937] - nx: 1
[17:59:15.937] - relay: TRUE
[17:59:15.937] - stdout: TRUE
[17:59:15.938] - signal: TRUE
[17:59:15.938] - resignal: FALSE
[17:59:15.938] - force: TRUE
[17:59:15.938] - relayed: [n=1] FALSE
[17:59:15.938] - queued futures: [n=1] FALSE
[17:59:15.938]  - until=1
[17:59:15.939]  - relaying element #1
[17:59:15.939] - relayed: [n=1] TRUE
[17:59:15.939] - queued futures: [n=1] TRUE
[17:59:15.939] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:15.940]  length: 0 (resolved future 1)
[17:59:15.940] Relaying remaining futures
[17:59:15.940] signalConditionsASAP(NULL, pos=0) ...
[17:59:15.940] - nx: 1
[17:59:15.940] - relay: TRUE
[17:59:15.941] - stdout: TRUE
[17:59:15.941] - signal: TRUE
[17:59:15.941] - resignal: FALSE
[17:59:15.941] - force: TRUE
[17:59:15.941] - relayed: [n=1] TRUE
[17:59:15.941] - queued futures: [n=1] TRUE
 - flush all
[17:59:15.942] - relayed: [n=1] TRUE
[17:59:15.942] - queued futures: [n=1] TRUE
[17:59:15.942] signalConditionsASAP(NULL, pos=0) ... done
[17:59:15.942] resolve() on list ... DONE
[17:59:15.943]  - Number of value chunks collected: 1
[17:59:15.943] Resolving 1 futures (chunks) ... DONE
[17:59:15.943] Reducing values from 1 chunks ...
[17:59:15.943]  - Number of values collected after concatenation: 2
[17:59:15.943]  - Number of values expected: 2
[17:59:15.944] Reducing values from 1 chunks ... DONE
[17:59:15.944] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:59:15.944] getGlobalsAndPackagesXApply() ...
[17:59:15.945]  - future.globals: TRUE
[17:59:15.945] getGlobalsAndPackages() ...
[17:59:15.945] Searching for globals...
[17:59:15.950] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:59:15.951] Searching for globals ... DONE
[17:59:15.951] Resolving globals: FALSE
[17:59:15.952] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:59:15.953] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:59:15.953] - globals: [1] ‘FUN’
[17:59:15.953] 
[17:59:15.953] getGlobalsAndPackages() ... DONE
[17:59:15.954]  - globals found/used: [n=1] ‘FUN’
[17:59:15.954]  - needed namespaces: [n=0] 
[17:59:15.954] Finding globals ... DONE
[17:59:15.954]  - use_args: TRUE
[17:59:15.954]  - Getting '...' globals ...
[17:59:15.958] resolve() on list ...
[17:59:15.958]  recursive: 0
[17:59:15.958]  length: 1
[17:59:15.958]  elements: ‘...’
[17:59:15.959]  length: 0 (resolved future 1)
[17:59:15.959] resolve() on list ... DONE
[17:59:15.959]    - '...' content: [n=0] 
[17:59:15.959] List of 1
[17:59:15.959]  $ ...: list()
[17:59:15.959]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.959]  - attr(*, "where")=List of 1
[17:59:15.959]   ..$ ...:<environment: 0x56085b704d10> 
[17:59:15.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.959]  - attr(*, "resolved")= logi TRUE
[17:59:15.959]  - attr(*, "total_size")= num NA
[17:59:15.965]  - Getting '...' globals ... DONE
[17:59:15.965] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:15.966] List of 2
[17:59:15.966]  $ ...future.FUN:function (x)  
[17:59:15.966]  $ ...          : list()
[17:59:15.966]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.966]  - attr(*, "where")=List of 2
[17:59:15.966]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:15.966]   ..$ ...          :<environment: 0x56085b704d10> 
[17:59:15.966]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.966]  - attr(*, "resolved")= logi FALSE
[17:59:15.966]  - attr(*, "total_size")= num 9888
[17:59:15.971] Packages to be attached in all futures: [n=0] 
[17:59:15.971] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.972] future_lapply() ...
[17:59:15.975] Number of chunks: 1
[17:59:15.975] getGlobalsAndPackagesXApply() ...
[17:59:15.975]  - future.globals: <name-value list> with names ‘list()’
[17:59:15.975]  - use_args: TRUE
[17:59:15.976] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:15.976] List of 2
[17:59:15.976]  $ ...          : list()
[17:59:15.976]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.976]  $ ...future.FUN:function (x)  
[17:59:15.976]  - attr(*, "where")=List of 2
[17:59:15.976]   ..$ ...          :<environment: 0x56085b704d10> 
[17:59:15.976]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:59:15.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.976]  - attr(*, "resolved")= logi FALSE
[17:59:15.976]  - attr(*, "total_size")= num NA
[17:59:15.981] Packages to be attached in all futures: [n=0] 
[17:59:15.982] getGlobalsAndPackagesXApply() ... DONE
[17:59:15.982] Number of futures (= number of chunks): 1
[17:59:15.982] Launching 1 futures (chunks) ...
[17:59:15.982] Chunk #1 of 1 ...
[17:59:15.983]  - seeds: <none>
[17:59:15.983]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.983] getGlobalsAndPackages() ...
[17:59:15.983] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.984] Resolving globals: FALSE
[17:59:15.984] Tweak future expression to call with '...' arguments ...
[17:59:15.984] {
[17:59:15.984]     do.call(function(...) {
[17:59:15.984]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.984]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:15.984]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.984]             on.exit(options(oopts), add = TRUE)
[17:59:15.984]         }
[17:59:15.984]         {
[17:59:15.984]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:15.984]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.984]                 ...future.FUN(...future.X_jj, ...)
[17:59:15.984]             })
[17:59:15.984]         }
[17:59:15.984]     }, args = future.call.arguments)
[17:59:15.984] }
[17:59:15.985] Tweak future expression to call with '...' arguments ... DONE
[17:59:15.985] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:15.985] 
[17:59:15.986] getGlobalsAndPackages() ... DONE
[17:59:15.986] run() for ‘Future’ ...
[17:59:15.986] - state: ‘created’
[17:59:15.987] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:15.987] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:15.987] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:15.988]   - Field: ‘label’
[17:59:15.988]   - Field: ‘local’
[17:59:15.988]   - Field: ‘owner’
[17:59:15.988]   - Field: ‘envir’
[17:59:15.988]   - Field: ‘packages’
[17:59:15.989]   - Field: ‘gc’
[17:59:15.989]   - Field: ‘conditions’
[17:59:15.989]   - Field: ‘expr’
[17:59:15.989]   - Field: ‘uuid’
[17:59:15.989]   - Field: ‘seed’
[17:59:15.990]   - Field: ‘version’
[17:59:15.990]   - Field: ‘result’
[17:59:15.990]   - Field: ‘asynchronous’
[17:59:15.990]   - Field: ‘calls’
[17:59:15.990]   - Field: ‘globals’
[17:59:15.991]   - Field: ‘stdout’
[17:59:15.991]   - Field: ‘earlySignal’
[17:59:15.991]   - Field: ‘lazy’
[17:59:15.991]   - Field: ‘state’
[17:59:15.991] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:15.992] - Launch lazy future ...
[17:59:15.992] Packages needed by the future expression (n = 0): <none>
[17:59:15.992] Packages needed by future strategies (n = 0): <none>
[17:59:15.993] {
[17:59:15.993]     {
[17:59:15.993]         {
[17:59:15.993]             ...future.startTime <- base::Sys.time()
[17:59:15.993]             {
[17:59:15.993]                 {
[17:59:15.993]                   {
[17:59:15.993]                     base::local({
[17:59:15.993]                       has_future <- base::requireNamespace("future", 
[17:59:15.993]                         quietly = TRUE)
[17:59:15.993]                       if (has_future) {
[17:59:15.993]                         ns <- base::getNamespace("future")
[17:59:15.993]                         version <- ns[[".package"]][["version"]]
[17:59:15.993]                         if (is.null(version)) 
[17:59:15.993]                           version <- utils::packageVersion("future")
[17:59:15.993]                       }
[17:59:15.993]                       else {
[17:59:15.993]                         version <- NULL
[17:59:15.993]                       }
[17:59:15.993]                       if (!has_future || version < "1.8.0") {
[17:59:15.993]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:15.993]                           "", base::R.version$version.string), 
[17:59:15.993]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:15.993]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:15.993]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:15.993]                             "release", "version")], collapse = " "), 
[17:59:15.993]                           hostname = base::Sys.info()[["nodename"]])
[17:59:15.993]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:15.993]                           info)
[17:59:15.993]                         info <- base::paste(info, collapse = "; ")
[17:59:15.993]                         if (!has_future) {
[17:59:15.993]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:15.993]                             info)
[17:59:15.993]                         }
[17:59:15.993]                         else {
[17:59:15.993]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:15.993]                             info, version)
[17:59:15.993]                         }
[17:59:15.993]                         base::stop(msg)
[17:59:15.993]                       }
[17:59:15.993]                     })
[17:59:15.993]                   }
[17:59:15.993]                   ...future.strategy.old <- future::plan("list")
[17:59:15.993]                   options(future.plan = NULL)
[17:59:15.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:15.993]                 }
[17:59:15.993]                 ...future.workdir <- getwd()
[17:59:15.993]             }
[17:59:15.993]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:15.993]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:15.993]         }
[17:59:15.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:15.993]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:15.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:15.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:15.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:15.993]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:15.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:15.993]             base::names(...future.oldOptions))
[17:59:15.993]     }
[17:59:15.993]     if (FALSE) {
[17:59:15.993]     }
[17:59:15.993]     else {
[17:59:15.993]         if (TRUE) {
[17:59:15.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:15.993]                 open = "w")
[17:59:15.993]         }
[17:59:15.993]         else {
[17:59:15.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:15.993]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:15.993]         }
[17:59:15.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:15.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:15.993]             base::sink(type = "output", split = FALSE)
[17:59:15.993]             base::close(...future.stdout)
[17:59:15.993]         }, add = TRUE)
[17:59:15.993]     }
[17:59:15.993]     ...future.frame <- base::sys.nframe()
[17:59:15.993]     ...future.conditions <- base::list()
[17:59:15.993]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:15.993]     if (FALSE) {
[17:59:15.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:15.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:15.993]     }
[17:59:15.993]     ...future.result <- base::tryCatch({
[17:59:15.993]         base::withCallingHandlers({
[17:59:15.993]             ...future.value <- base::withVisible(base::local({
[17:59:15.993]                 do.call(function(...) {
[17:59:15.993]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:15.993]                   if (!identical(...future.globals.maxSize.org, 
[17:59:15.993]                     ...future.globals.maxSize)) {
[17:59:15.993]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:15.993]                     on.exit(options(oopts), add = TRUE)
[17:59:15.993]                   }
[17:59:15.993]                   {
[17:59:15.993]                     lapply(seq_along(...future.elements_ii), 
[17:59:15.993]                       FUN = function(jj) {
[17:59:15.993]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:15.993]                         ...future.FUN(...future.X_jj, ...)
[17:59:15.993]                       })
[17:59:15.993]                   }
[17:59:15.993]                 }, args = future.call.arguments)
[17:59:15.993]             }))
[17:59:15.993]             future::FutureResult(value = ...future.value$value, 
[17:59:15.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.993]                   ...future.rng), globalenv = if (FALSE) 
[17:59:15.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:15.993]                     ...future.globalenv.names))
[17:59:15.993]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:15.993]         }, condition = base::local({
[17:59:15.993]             c <- base::c
[17:59:15.993]             inherits <- base::inherits
[17:59:15.993]             invokeRestart <- base::invokeRestart
[17:59:15.993]             length <- base::length
[17:59:15.993]             list <- base::list
[17:59:15.993]             seq.int <- base::seq.int
[17:59:15.993]             signalCondition <- base::signalCondition
[17:59:15.993]             sys.calls <- base::sys.calls
[17:59:15.993]             `[[` <- base::`[[`
[17:59:15.993]             `+` <- base::`+`
[17:59:15.993]             `<<-` <- base::`<<-`
[17:59:15.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:15.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:15.993]                   3L)]
[17:59:15.993]             }
[17:59:15.993]             function(cond) {
[17:59:15.993]                 is_error <- inherits(cond, "error")
[17:59:15.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:15.993]                   NULL)
[17:59:15.993]                 if (is_error) {
[17:59:15.993]                   sessionInformation <- function() {
[17:59:15.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:15.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:15.993]                       search = base::search(), system = base::Sys.info())
[17:59:15.993]                   }
[17:59:15.993]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:15.993]                     cond$call), session = sessionInformation(), 
[17:59:15.993]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:15.993]                   signalCondition(cond)
[17:59:15.993]                 }
[17:59:15.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:15.993]                 "immediateCondition"))) {
[17:59:15.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:15.993]                   ...future.conditions[[length(...future.conditions) + 
[17:59:15.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:15.993]                   if (TRUE && !signal) {
[17:59:15.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.993]                     {
[17:59:15.993]                       inherits <- base::inherits
[17:59:15.993]                       invokeRestart <- base::invokeRestart
[17:59:15.993]                       is.null <- base::is.null
[17:59:15.993]                       muffled <- FALSE
[17:59:15.993]                       if (inherits(cond, "message")) {
[17:59:15.993]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.993]                         if (muffled) 
[17:59:15.993]                           invokeRestart("muffleMessage")
[17:59:15.993]                       }
[17:59:15.993]                       else if (inherits(cond, "warning")) {
[17:59:15.993]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.993]                         if (muffled) 
[17:59:15.993]                           invokeRestart("muffleWarning")
[17:59:15.993]                       }
[17:59:15.993]                       else if (inherits(cond, "condition")) {
[17:59:15.993]                         if (!is.null(pattern)) {
[17:59:15.993]                           computeRestarts <- base::computeRestarts
[17:59:15.993]                           grepl <- base::grepl
[17:59:15.993]                           restarts <- computeRestarts(cond)
[17:59:15.993]                           for (restart in restarts) {
[17:59:15.993]                             name <- restart$name
[17:59:15.993]                             if (is.null(name)) 
[17:59:15.993]                               next
[17:59:15.993]                             if (!grepl(pattern, name)) 
[17:59:15.993]                               next
[17:59:15.993]                             invokeRestart(restart)
[17:59:15.993]                             muffled <- TRUE
[17:59:15.993]                             break
[17:59:15.993]                           }
[17:59:15.993]                         }
[17:59:15.993]                       }
[17:59:15.993]                       invisible(muffled)
[17:59:15.993]                     }
[17:59:15.993]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.993]                   }
[17:59:15.993]                 }
[17:59:15.993]                 else {
[17:59:15.993]                   if (TRUE) {
[17:59:15.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:15.993]                     {
[17:59:15.993]                       inherits <- base::inherits
[17:59:15.993]                       invokeRestart <- base::invokeRestart
[17:59:15.993]                       is.null <- base::is.null
[17:59:15.993]                       muffled <- FALSE
[17:59:15.993]                       if (inherits(cond, "message")) {
[17:59:15.993]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:15.993]                         if (muffled) 
[17:59:15.993]                           invokeRestart("muffleMessage")
[17:59:15.993]                       }
[17:59:15.993]                       else if (inherits(cond, "warning")) {
[17:59:15.993]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:15.993]                         if (muffled) 
[17:59:15.993]                           invokeRestart("muffleWarning")
[17:59:15.993]                       }
[17:59:15.993]                       else if (inherits(cond, "condition")) {
[17:59:15.993]                         if (!is.null(pattern)) {
[17:59:15.993]                           computeRestarts <- base::computeRestarts
[17:59:15.993]                           grepl <- base::grepl
[17:59:15.993]                           restarts <- computeRestarts(cond)
[17:59:15.993]                           for (restart in restarts) {
[17:59:15.993]                             name <- restart$name
[17:59:15.993]                             if (is.null(name)) 
[17:59:15.993]                               next
[17:59:15.993]                             if (!grepl(pattern, name)) 
[17:59:15.993]                               next
[17:59:15.993]                             invokeRestart(restart)
[17:59:15.993]                             muffled <- TRUE
[17:59:15.993]                             break
[17:59:15.993]                           }
[17:59:15.993]                         }
[17:59:15.993]                       }
[17:59:15.993]                       invisible(muffled)
[17:59:15.993]                     }
[17:59:15.993]                     muffleCondition(cond, pattern = "^muffle")
[17:59:15.993]                   }
[17:59:15.993]                 }
[17:59:15.993]             }
[17:59:15.993]         }))
[17:59:15.993]     }, error = function(ex) {
[17:59:15.993]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:15.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:15.993]                 ...future.rng), started = ...future.startTime, 
[17:59:15.993]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:15.993]             version = "1.8"), class = "FutureResult")
[17:59:15.993]     }, finally = {
[17:59:15.993]         if (!identical(...future.workdir, getwd())) 
[17:59:15.993]             setwd(...future.workdir)
[17:59:15.993]         {
[17:59:15.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:15.993]                 ...future.oldOptions$nwarnings <- NULL
[17:59:15.993]             }
[17:59:15.993]             base::options(...future.oldOptions)
[17:59:15.993]             if (.Platform$OS.type == "windows") {
[17:59:15.993]                 old_names <- names(...future.oldEnvVars)
[17:59:15.993]                 envs <- base::Sys.getenv()
[17:59:15.993]                 names <- names(envs)
[17:59:15.993]                 common <- intersect(names, old_names)
[17:59:15.993]                 added <- setdiff(names, old_names)
[17:59:15.993]                 removed <- setdiff(old_names, names)
[17:59:15.993]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:15.993]                   envs[common]]
[17:59:15.993]                 NAMES <- toupper(changed)
[17:59:15.993]                 args <- list()
[17:59:15.993]                 for (kk in seq_along(NAMES)) {
[17:59:15.993]                   name <- changed[[kk]]
[17:59:15.993]                   NAME <- NAMES[[kk]]
[17:59:15.993]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.993]                     next
[17:59:15.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.993]                 }
[17:59:15.993]                 NAMES <- toupper(added)
[17:59:15.993]                 for (kk in seq_along(NAMES)) {
[17:59:15.993]                   name <- added[[kk]]
[17:59:15.993]                   NAME <- NAMES[[kk]]
[17:59:15.993]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.993]                     next
[17:59:15.993]                   args[[name]] <- ""
[17:59:15.993]                 }
[17:59:15.993]                 NAMES <- toupper(removed)
[17:59:15.993]                 for (kk in seq_along(NAMES)) {
[17:59:15.993]                   name <- removed[[kk]]
[17:59:15.993]                   NAME <- NAMES[[kk]]
[17:59:15.993]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:15.993]                     next
[17:59:15.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:15.993]                 }
[17:59:15.993]                 if (length(args) > 0) 
[17:59:15.993]                   base::do.call(base::Sys.setenv, args = args)
[17:59:15.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:15.993]             }
[17:59:15.993]             else {
[17:59:15.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:15.993]             }
[17:59:15.993]             {
[17:59:15.993]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:15.993]                   0L) {
[17:59:15.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:15.993]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:15.993]                   base::options(opts)
[17:59:15.993]                 }
[17:59:15.993]                 {
[17:59:15.993]                   {
[17:59:15.993]                     NULL
[17:59:15.993]                     RNGkind("Mersenne-Twister")
[17:59:15.993]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:15.993]                       inherits = FALSE)
[17:59:15.993]                   }
[17:59:15.993]                   options(future.plan = NULL)
[17:59:15.993]                   if (is.na(NA_character_)) 
[17:59:15.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:15.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:15.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:15.993]                     .init = FALSE)
[17:59:15.993]                 }
[17:59:15.993]             }
[17:59:15.993]         }
[17:59:15.993]     })
[17:59:15.993]     if (TRUE) {
[17:59:15.993]         base::sink(type = "output", split = FALSE)
[17:59:15.993]         if (TRUE) {
[17:59:15.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:15.993]         }
[17:59:15.993]         else {
[17:59:15.993]             ...future.result["stdout"] <- base::list(NULL)
[17:59:15.993]         }
[17:59:15.993]         base::close(...future.stdout)
[17:59:15.993]         ...future.stdout <- NULL
[17:59:15.993]     }
[17:59:15.993]     ...future.result$conditions <- ...future.conditions
[17:59:15.993]     ...future.result$finished <- base::Sys.time()
[17:59:15.993]     ...future.result
[17:59:15.993] }
[17:59:15.996] assign_globals() ...
[17:59:15.997] List of 5
[17:59:15.997]  $ future.call.arguments    : list()
[17:59:15.997]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:15.997]  $ ...future.FUN            :function (x)  
[17:59:15.997]  $ ...future.elements_ii    :List of 2
[17:59:15.997]   ..$ : int [1:2] 1 3
[17:59:15.997]   ..$ : int [1:2] 2 4
[17:59:15.997]  $ ...future.seeds_ii       : NULL
[17:59:15.997]  $ ...future.globals.maxSize: num Inf
[17:59:15.997]  - attr(*, "resolved")= logi FALSE
[17:59:15.997]  - attr(*, "total_size")= num NA
[17:59:15.997]  - attr(*, "where")=List of 5
[17:59:15.997]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:15.997]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:15.997]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:15.997]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:15.997]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:15.997]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:15.997]  - attr(*, "already-done")= logi TRUE
[17:59:16.007] - copied ‘future.call.arguments’ to environment
[17:59:16.007] - reassign environment for ‘...future.FUN’
[17:59:16.009] - copied ‘...future.FUN’ to environment
[17:59:16.009] - copied ‘...future.elements_ii’ to environment
[17:59:16.010] - copied ‘...future.seeds_ii’ to environment
[17:59:16.010] - copied ‘...future.globals.maxSize’ to environment
[17:59:16.010] assign_globals() ... done
[17:59:16.011] plan(): Setting new future strategy stack:
[17:59:16.011] List of future strategies:
[17:59:16.011] 1. sequential:
[17:59:16.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:16.011]    - tweaked: FALSE
[17:59:16.011]    - call: NULL
[17:59:16.012] plan(): nbrOfWorkers() = 1
[17:59:16.013] plan(): Setting new future strategy stack:
[17:59:16.014] List of future strategies:
[17:59:16.014] 1. sequential:
[17:59:16.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:16.014]    - tweaked: FALSE
[17:59:16.014]    - call: plan(strategy)
[17:59:16.014] plan(): nbrOfWorkers() = 1
[17:59:16.015] SequentialFuture started (and completed)
[17:59:16.015] - Launch lazy future ... done
[17:59:16.015] run() for ‘SequentialFuture’ ... done
[17:59:16.015] Created future:
[17:59:16.016] SequentialFuture:
[17:59:16.016] Label: ‘future_apply-1’
[17:59:16.016] Expression:
[17:59:16.016] {
[17:59:16.016]     do.call(function(...) {
[17:59:16.016]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.016]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.016]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.016]             on.exit(options(oopts), add = TRUE)
[17:59:16.016]         }
[17:59:16.016]         {
[17:59:16.016]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.016]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.016]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.016]             })
[17:59:16.016]         }
[17:59:16.016]     }, args = future.call.arguments)
[17:59:16.016] }
[17:59:16.016] Lazy evaluation: FALSE
[17:59:16.016] Asynchronous evaluation: FALSE
[17:59:16.016] Local evaluation: TRUE
[17:59:16.016] Environment: R_GlobalEnv
[17:59:16.016] Capture standard output: TRUE
[17:59:16.016] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:16.016] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:16.016] Packages: <none>
[17:59:16.016] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:16.016] Resolved: TRUE
[17:59:16.016] Value: 400 bytes of class ‘list’
[17:59:16.016] Early signaling: FALSE
[17:59:16.016] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:16.016] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:16.018] Chunk #1 of 1 ... DONE
[17:59:16.018] Launching 1 futures (chunks) ... DONE
[17:59:16.018] Resolving 1 futures (chunks) ...
[17:59:16.018] resolve() on list ...
[17:59:16.018]  recursive: 0
[17:59:16.019]  length: 1
[17:59:16.019] 
[17:59:16.019] resolved() for ‘SequentialFuture’ ...
[17:59:16.019] - state: ‘finished’
[17:59:16.019] - run: TRUE
[17:59:16.020] - result: ‘FutureResult’
[17:59:16.020] resolved() for ‘SequentialFuture’ ... done
[17:59:16.020] Future #1
[17:59:16.020] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:16.020] - nx: 1
[17:59:16.021] - relay: TRUE
[17:59:16.021] - stdout: TRUE
[17:59:16.021] - signal: TRUE
[17:59:16.021] - resignal: FALSE
[17:59:16.021] - force: TRUE
[17:59:16.021] - relayed: [n=1] FALSE
[17:59:16.022] - queued futures: [n=1] FALSE
[17:59:16.022]  - until=1
[17:59:16.022]  - relaying element #1
[17:59:16.022] - relayed: [n=1] TRUE
[17:59:16.023] - queued futures: [n=1] TRUE
[17:59:16.023] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:16.023]  length: 0 (resolved future 1)
[17:59:16.023] Relaying remaining futures
[17:59:16.023] signalConditionsASAP(NULL, pos=0) ...
[17:59:16.024] - nx: 1
[17:59:16.024] - relay: TRUE
[17:59:16.024] - stdout: TRUE
[17:59:16.024] - signal: TRUE
[17:59:16.024] - resignal: FALSE
[17:59:16.024] - force: TRUE
[17:59:16.025] - relayed: [n=1] TRUE
[17:59:16.025] - queued futures: [n=1] TRUE
 - flush all
[17:59:16.025] - relayed: [n=1] TRUE
[17:59:16.025] - queued futures: [n=1] TRUE
[17:59:16.025] signalConditionsASAP(NULL, pos=0) ... done
[17:59:16.026] resolve() on list ... DONE
[17:59:16.026]  - Number of value chunks collected: 1
[17:59:16.026] Resolving 1 futures (chunks) ... DONE
[17:59:16.026] Reducing values from 1 chunks ...
[17:59:16.026]  - Number of values collected after concatenation: 2
[17:59:16.027]  - Number of values expected: 2
[17:59:16.027] Reducing values from 1 chunks ... DONE
[17:59:16.027] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:59:16.028] getGlobalsAndPackagesXApply() ...
[17:59:16.028]  - future.globals: TRUE
[17:59:16.028] getGlobalsAndPackages() ...
[17:59:16.028] Searching for globals...
[17:59:16.034] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:59:16.034] Searching for globals ... DONE
[17:59:16.034] Resolving globals: FALSE
[17:59:16.036] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:59:16.036] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:59:16.037] - globals: [1] ‘FUN’
[17:59:16.037] 
[17:59:16.037] getGlobalsAndPackages() ... DONE
[17:59:16.037]  - globals found/used: [n=1] ‘FUN’
[17:59:16.037]  - needed namespaces: [n=0] 
[17:59:16.038] Finding globals ... DONE
[17:59:16.038]  - use_args: TRUE
[17:59:16.038]  - Getting '...' globals ...
[17:59:16.039] resolve() on list ...
[17:59:16.039]  recursive: 0
[17:59:16.039]  length: 1
[17:59:16.039]  elements: ‘...’
[17:59:16.039]  length: 0 (resolved future 1)
[17:59:16.040] resolve() on list ... DONE
[17:59:16.040]    - '...' content: [n=0] 
[17:59:16.040] List of 1
[17:59:16.040]  $ ...: list()
[17:59:16.040]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.040]  - attr(*, "where")=List of 1
[17:59:16.040]   ..$ ...:<environment: 0x56085973e1b0> 
[17:59:16.040]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.040]  - attr(*, "resolved")= logi TRUE
[17:59:16.040]  - attr(*, "total_size")= num NA
[17:59:16.045]  - Getting '...' globals ... DONE
[17:59:16.045] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:16.045] List of 2
[17:59:16.045]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:59:16.045]  $ ...          : list()
[17:59:16.045]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.045]  - attr(*, "where")=List of 2
[17:59:16.045]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:16.045]   ..$ ...          :<environment: 0x56085973e1b0> 
[17:59:16.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.045]  - attr(*, "resolved")= logi FALSE
[17:59:16.045]  - attr(*, "total_size")= num 36296
[17:59:16.051] Packages to be attached in all futures: [n=0] 
[17:59:16.051] getGlobalsAndPackagesXApply() ... DONE
[17:59:16.051] future_lapply() ...
[17:59:16.058] Generating random seeds ...
[17:59:16.058] Generating random seed streams for 2 elements ...
[17:59:16.059] Generating random seed streams for 2 elements ... DONE
[17:59:16.059] Generating random seeds ... DONE
[17:59:16.059] Will set RNG state on exit: 10407, 717248977, 1424295388, -714864195, 710959580, 1096610467, -1576814552
[17:59:16.059] Number of chunks: 1
[17:59:16.059] getGlobalsAndPackagesXApply() ...
[17:59:16.060]  - future.globals: <name-value list> with names ‘list()’
[17:59:16.060]  - use_args: TRUE
[17:59:16.060] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:16.061] List of 2
[17:59:16.061]  $ ...          : list()
[17:59:16.061]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.061]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:59:16.061]  - attr(*, "where")=List of 2
[17:59:16.061]   ..$ ...          :<environment: 0x56085973e1b0> 
[17:59:16.061]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:16.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.061]  - attr(*, "resolved")= logi FALSE
[17:59:16.061]  - attr(*, "total_size")= num NA
[17:59:16.067] Packages to be attached in all futures: [n=0] 
[17:59:16.067] getGlobalsAndPackagesXApply() ... DONE
[17:59:16.068] Number of futures (= number of chunks): 1
[17:59:16.068] Launching 1 futures (chunks) ...
[17:59:16.068] Chunk #1 of 1 ...
[17:59:16.068]  - seeds: [2] <seeds>
[17:59:16.069]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.069] getGlobalsAndPackages() ...
[17:59:16.069] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.069] Resolving globals: FALSE
[17:59:16.070] Tweak future expression to call with '...' arguments ...
[17:59:16.070] {
[17:59:16.070]     do.call(function(...) {
[17:59:16.070]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.070]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.070]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.070]             on.exit(options(oopts), add = TRUE)
[17:59:16.070]         }
[17:59:16.070]         {
[17:59:16.070]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.070]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.070]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:16.070]                   envir = globalenv(), inherits = FALSE)
[17:59:16.070]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.070]             })
[17:59:16.070]         }
[17:59:16.070]     }, args = future.call.arguments)
[17:59:16.070] }
[17:59:16.070] Tweak future expression to call with '...' arguments ... DONE
[17:59:16.071] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.071] 
[17:59:16.071] getGlobalsAndPackages() ... DONE
[17:59:16.072] run() for ‘Future’ ...
[17:59:16.072] - state: ‘created’
[17:59:16.072] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:16.073] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:16.073] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:16.073]   - Field: ‘label’
[17:59:16.074]   - Field: ‘local’
[17:59:16.074]   - Field: ‘owner’
[17:59:16.074]   - Field: ‘envir’
[17:59:16.074]   - Field: ‘packages’
[17:59:16.074]   - Field: ‘gc’
[17:59:16.075]   - Field: ‘conditions’
[17:59:16.075]   - Field: ‘expr’
[17:59:16.075]   - Field: ‘uuid’
[17:59:16.075]   - Field: ‘seed’
[17:59:16.075]   - Field: ‘version’
[17:59:16.076]   - Field: ‘result’
[17:59:16.076]   - Field: ‘asynchronous’
[17:59:16.076]   - Field: ‘calls’
[17:59:16.076]   - Field: ‘globals’
[17:59:16.076]   - Field: ‘stdout’
[17:59:16.077]   - Field: ‘earlySignal’
[17:59:16.077]   - Field: ‘lazy’
[17:59:16.077]   - Field: ‘state’
[17:59:16.077] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:16.077] - Launch lazy future ...
[17:59:16.078] Packages needed by the future expression (n = 0): <none>
[17:59:16.078] Packages needed by future strategies (n = 0): <none>
[17:59:16.079] {
[17:59:16.079]     {
[17:59:16.079]         {
[17:59:16.079]             ...future.startTime <- base::Sys.time()
[17:59:16.079]             {
[17:59:16.079]                 {
[17:59:16.079]                   {
[17:59:16.079]                     base::local({
[17:59:16.079]                       has_future <- base::requireNamespace("future", 
[17:59:16.079]                         quietly = TRUE)
[17:59:16.079]                       if (has_future) {
[17:59:16.079]                         ns <- base::getNamespace("future")
[17:59:16.079]                         version <- ns[[".package"]][["version"]]
[17:59:16.079]                         if (is.null(version)) 
[17:59:16.079]                           version <- utils::packageVersion("future")
[17:59:16.079]                       }
[17:59:16.079]                       else {
[17:59:16.079]                         version <- NULL
[17:59:16.079]                       }
[17:59:16.079]                       if (!has_future || version < "1.8.0") {
[17:59:16.079]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:16.079]                           "", base::R.version$version.string), 
[17:59:16.079]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:16.079]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:16.079]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:16.079]                             "release", "version")], collapse = " "), 
[17:59:16.079]                           hostname = base::Sys.info()[["nodename"]])
[17:59:16.079]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:16.079]                           info)
[17:59:16.079]                         info <- base::paste(info, collapse = "; ")
[17:59:16.079]                         if (!has_future) {
[17:59:16.079]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:16.079]                             info)
[17:59:16.079]                         }
[17:59:16.079]                         else {
[17:59:16.079]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:16.079]                             info, version)
[17:59:16.079]                         }
[17:59:16.079]                         base::stop(msg)
[17:59:16.079]                       }
[17:59:16.079]                     })
[17:59:16.079]                   }
[17:59:16.079]                   ...future.strategy.old <- future::plan("list")
[17:59:16.079]                   options(future.plan = NULL)
[17:59:16.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:16.079]                 }
[17:59:16.079]                 ...future.workdir <- getwd()
[17:59:16.079]             }
[17:59:16.079]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:16.079]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:16.079]         }
[17:59:16.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:16.079]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:16.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:16.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:16.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:16.079]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:16.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:16.079]             base::names(...future.oldOptions))
[17:59:16.079]     }
[17:59:16.079]     if (FALSE) {
[17:59:16.079]     }
[17:59:16.079]     else {
[17:59:16.079]         if (TRUE) {
[17:59:16.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:16.079]                 open = "w")
[17:59:16.079]         }
[17:59:16.079]         else {
[17:59:16.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:16.079]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:16.079]         }
[17:59:16.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:16.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:16.079]             base::sink(type = "output", split = FALSE)
[17:59:16.079]             base::close(...future.stdout)
[17:59:16.079]         }, add = TRUE)
[17:59:16.079]     }
[17:59:16.079]     ...future.frame <- base::sys.nframe()
[17:59:16.079]     ...future.conditions <- base::list()
[17:59:16.079]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:16.079]     if (FALSE) {
[17:59:16.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:16.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:16.079]     }
[17:59:16.079]     ...future.result <- base::tryCatch({
[17:59:16.079]         base::withCallingHandlers({
[17:59:16.079]             ...future.value <- base::withVisible(base::local({
[17:59:16.079]                 do.call(function(...) {
[17:59:16.079]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.079]                   if (!identical(...future.globals.maxSize.org, 
[17:59:16.079]                     ...future.globals.maxSize)) {
[17:59:16.079]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.079]                     on.exit(options(oopts), add = TRUE)
[17:59:16.079]                   }
[17:59:16.079]                   {
[17:59:16.079]                     lapply(seq_along(...future.elements_ii), 
[17:59:16.079]                       FUN = function(jj) {
[17:59:16.079]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.079]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:16.079]                           envir = globalenv(), inherits = FALSE)
[17:59:16.079]                         ...future.FUN(...future.X_jj, ...)
[17:59:16.079]                       })
[17:59:16.079]                   }
[17:59:16.079]                 }, args = future.call.arguments)
[17:59:16.079]             }))
[17:59:16.079]             future::FutureResult(value = ...future.value$value, 
[17:59:16.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.079]                   ...future.rng), globalenv = if (FALSE) 
[17:59:16.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:16.079]                     ...future.globalenv.names))
[17:59:16.079]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:16.079]         }, condition = base::local({
[17:59:16.079]             c <- base::c
[17:59:16.079]             inherits <- base::inherits
[17:59:16.079]             invokeRestart <- base::invokeRestart
[17:59:16.079]             length <- base::length
[17:59:16.079]             list <- base::list
[17:59:16.079]             seq.int <- base::seq.int
[17:59:16.079]             signalCondition <- base::signalCondition
[17:59:16.079]             sys.calls <- base::sys.calls
[17:59:16.079]             `[[` <- base::`[[`
[17:59:16.079]             `+` <- base::`+`
[17:59:16.079]             `<<-` <- base::`<<-`
[17:59:16.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:16.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:16.079]                   3L)]
[17:59:16.079]             }
[17:59:16.079]             function(cond) {
[17:59:16.079]                 is_error <- inherits(cond, "error")
[17:59:16.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:16.079]                   NULL)
[17:59:16.079]                 if (is_error) {
[17:59:16.079]                   sessionInformation <- function() {
[17:59:16.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:16.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:16.079]                       search = base::search(), system = base::Sys.info())
[17:59:16.079]                   }
[17:59:16.079]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:16.079]                     cond$call), session = sessionInformation(), 
[17:59:16.079]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:16.079]                   signalCondition(cond)
[17:59:16.079]                 }
[17:59:16.079]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[17:59:16.079]                   signal <- TRUE && inherits(cond, character(0))
[17:59:16.079]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:16.079]                   if (TRUE && !signal) {
[17:59:16.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.079]                     {
[17:59:16.079]                       inherits <- base::inherits
[17:59:16.079]                       invokeRestart <- base::invokeRestart
[17:59:16.079]                       is.null <- base::is.null
[17:59:16.079]                       muffled <- FALSE
[17:59:16.079]                       if (inherits(cond, "message")) {
[17:59:16.079]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.079]                         if (muffled) 
[17:59:16.079]                           invokeRestart("muffleMessage")
[17:59:16.079]                       }
[17:59:16.079]                       else if (inherits(cond, "warning")) {
[17:59:16.079]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.079]                         if (muffled) 
[17:59:16.079]                           invokeRestart("muffleWarning")
[17:59:16.079]                       }
[17:59:16.079]                       else if (inherits(cond, "condition")) {
[17:59:16.079]                         if (!is.null(pattern)) {
[17:59:16.079]                           computeRestarts <- base::computeRestarts
[17:59:16.079]                           grepl <- base::grepl
[17:59:16.079]                           restarts <- computeRestarts(cond)
[17:59:16.079]                           for (restart in restarts) {
[17:59:16.079]                             name <- restart$name
[17:59:16.079]                             if (is.null(name)) 
[17:59:16.079]                               next
[17:59:16.079]                             if (!grepl(pattern, name)) 
[17:59:16.079]                               next
[17:59:16.079]                             invokeRestart(restart)
[17:59:16.079]                             muffled <- TRUE
[17:59:16.079]                             break
[17:59:16.079]                           }
[17:59:16.079]                         }
[17:59:16.079]                       }
[17:59:16.079]                       invisible(muffled)
[17:59:16.079]                     }
[17:59:16.079]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.079]                   }
[17:59:16.079]                 }
[17:59:16.079]                 else {
[17:59:16.079]                   if (FALSE) {
[17:59:16.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.079]                     {
[17:59:16.079]                       inherits <- base::inherits
[17:59:16.079]                       invokeRestart <- base::invokeRestart
[17:59:16.079]                       is.null <- base::is.null
[17:59:16.079]                       muffled <- FALSE
[17:59:16.079]                       if (inherits(cond, "message")) {
[17:59:16.079]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.079]                         if (muffled) 
[17:59:16.079]                           invokeRestart("muffleMessage")
[17:59:16.079]                       }
[17:59:16.079]                       else if (inherits(cond, "warning")) {
[17:59:16.079]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.079]                         if (muffled) 
[17:59:16.079]                           invokeRestart("muffleWarning")
[17:59:16.079]                       }
[17:59:16.079]                       else if (inherits(cond, "condition")) {
[17:59:16.079]                         if (!is.null(pattern)) {
[17:59:16.079]                           computeRestarts <- base::computeRestarts
[17:59:16.079]                           grepl <- base::grepl
[17:59:16.079]                           restarts <- computeRestarts(cond)
[17:59:16.079]                           for (restart in restarts) {
[17:59:16.079]                             name <- restart$name
[17:59:16.079]                             if (is.null(name)) 
[17:59:16.079]                               next
[17:59:16.079]                             if (!grepl(pattern, name)) 
[17:59:16.079]                               next
[17:59:16.079]                             invokeRestart(restart)
[17:59:16.079]                             muffled <- TRUE
[17:59:16.079]                             break
[17:59:16.079]                           }
[17:59:16.079]                         }
[17:59:16.079]                       }
[17:59:16.079]                       invisible(muffled)
[17:59:16.079]                     }
[17:59:16.079]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.079]                   }
[17:59:16.079]                 }
[17:59:16.079]             }
[17:59:16.079]         }))
[17:59:16.079]     }, error = function(ex) {
[17:59:16.079]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:16.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.079]                 ...future.rng), started = ...future.startTime, 
[17:59:16.079]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:16.079]             version = "1.8"), class = "FutureResult")
[17:59:16.079]     }, finally = {
[17:59:16.079]         if (!identical(...future.workdir, getwd())) 
[17:59:16.079]             setwd(...future.workdir)
[17:59:16.079]         {
[17:59:16.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:16.079]                 ...future.oldOptions$nwarnings <- NULL
[17:59:16.079]             }
[17:59:16.079]             base::options(...future.oldOptions)
[17:59:16.079]             if (.Platform$OS.type == "windows") {
[17:59:16.079]                 old_names <- names(...future.oldEnvVars)
[17:59:16.079]                 envs <- base::Sys.getenv()
[17:59:16.079]                 names <- names(envs)
[17:59:16.079]                 common <- intersect(names, old_names)
[17:59:16.079]                 added <- setdiff(names, old_names)
[17:59:16.079]                 removed <- setdiff(old_names, names)
[17:59:16.079]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:16.079]                   envs[common]]
[17:59:16.079]                 NAMES <- toupper(changed)
[17:59:16.079]                 args <- list()
[17:59:16.079]                 for (kk in seq_along(NAMES)) {
[17:59:16.079]                   name <- changed[[kk]]
[17:59:16.079]                   NAME <- NAMES[[kk]]
[17:59:16.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.079]                     next
[17:59:16.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.079]                 }
[17:59:16.079]                 NAMES <- toupper(added)
[17:59:16.079]                 for (kk in seq_along(NAMES)) {
[17:59:16.079]                   name <- added[[kk]]
[17:59:16.079]                   NAME <- NAMES[[kk]]
[17:59:16.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.079]                     next
[17:59:16.079]                   args[[name]] <- ""
[17:59:16.079]                 }
[17:59:16.079]                 NAMES <- toupper(removed)
[17:59:16.079]                 for (kk in seq_along(NAMES)) {
[17:59:16.079]                   name <- removed[[kk]]
[17:59:16.079]                   NAME <- NAMES[[kk]]
[17:59:16.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.079]                     next
[17:59:16.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.079]                 }
[17:59:16.079]                 if (length(args) > 0) 
[17:59:16.079]                   base::do.call(base::Sys.setenv, args = args)
[17:59:16.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:16.079]             }
[17:59:16.079]             else {
[17:59:16.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:16.079]             }
[17:59:16.079]             {
[17:59:16.079]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:16.079]                   0L) {
[17:59:16.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:16.079]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:16.079]                   base::options(opts)
[17:59:16.079]                 }
[17:59:16.079]                 {
[17:59:16.079]                   {
[17:59:16.079]                     base::assign(".Random.seed", c(10407L, 717248977L, 
[17:59:16.079]                     1424295388L, -714864195L, 710959580L, 1096610467L, 
[17:59:16.079]                     -1576814552L), envir = base::globalenv(), 
[17:59:16.079]                       inherits = FALSE)
[17:59:16.079]                     NULL
[17:59:16.079]                   }
[17:59:16.079]                   options(future.plan = NULL)
[17:59:16.079]                   if (is.na(NA_character_)) 
[17:59:16.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:16.079]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:16.079]                     .init = FALSE)
[17:59:16.079]                 }
[17:59:16.079]             }
[17:59:16.079]         }
[17:59:16.079]     })
[17:59:16.079]     if (TRUE) {
[17:59:16.079]         base::sink(type = "output", split = FALSE)
[17:59:16.079]         if (TRUE) {
[17:59:16.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:16.079]         }
[17:59:16.079]         else {
[17:59:16.079]             ...future.result["stdout"] <- base::list(NULL)
[17:59:16.079]         }
[17:59:16.079]         base::close(...future.stdout)
[17:59:16.079]         ...future.stdout <- NULL
[17:59:16.079]     }
[17:59:16.079]     ...future.result$conditions <- ...future.conditions
[17:59:16.079]     ...future.result$finished <- base::Sys.time()
[17:59:16.079]     ...future.result
[17:59:16.079] }
[17:59:16.082] assign_globals() ...
[17:59:16.082] List of 5
[17:59:16.082]  $ future.call.arguments    : list()
[17:59:16.082]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.082]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:59:16.082]  $ ...future.elements_ii    :List of 2
[17:59:16.082]   ..$ : int [1:2] 1 3
[17:59:16.082]   ..$ : int [1:2] 2 4
[17:59:16.082]  $ ...future.seeds_ii       :List of 2
[17:59:16.082]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:59:16.082]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:59:16.082]  $ ...future.globals.maxSize: num Inf
[17:59:16.082]  - attr(*, "resolved")= logi FALSE
[17:59:16.082]  - attr(*, "total_size")= num NA
[17:59:16.082]  - attr(*, "where")=List of 5
[17:59:16.082]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:16.082]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:16.082]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:16.082]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:16.082]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:16.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.082]  - attr(*, "already-done")= logi TRUE
[17:59:16.094] - copied ‘future.call.arguments’ to environment
[17:59:16.094] - copied ‘...future.FUN’ to environment
[17:59:16.094] - copied ‘...future.elements_ii’ to environment
[17:59:16.094] - copied ‘...future.seeds_ii’ to environment
[17:59:16.094] - copied ‘...future.globals.maxSize’ to environment
[17:59:16.095] assign_globals() ... done
[17:59:16.095] plan(): Setting new future strategy stack:
[17:59:16.095] List of future strategies:
[17:59:16.095] 1. sequential:
[17:59:16.095]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:16.095]    - tweaked: FALSE
[17:59:16.095]    - call: NULL
[17:59:16.096] plan(): nbrOfWorkers() = 1
[17:59:16.098] plan(): Setting new future strategy stack:
[17:59:16.098] List of future strategies:
[17:59:16.098] 1. sequential:
[17:59:16.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:16.098]    - tweaked: FALSE
[17:59:16.098]    - call: plan(strategy)
[17:59:16.099] plan(): nbrOfWorkers() = 1
[17:59:16.099] SequentialFuture started (and completed)
[17:59:16.099] - Launch lazy future ... done
[17:59:16.100] run() for ‘SequentialFuture’ ... done
[17:59:16.100] Created future:
[17:59:16.100] SequentialFuture:
[17:59:16.100] Label: ‘future_apply-1’
[17:59:16.100] Expression:
[17:59:16.100] {
[17:59:16.100]     do.call(function(...) {
[17:59:16.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.100]             on.exit(options(oopts), add = TRUE)
[17:59:16.100]         }
[17:59:16.100]         {
[17:59:16.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.100]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:16.100]                   envir = globalenv(), inherits = FALSE)
[17:59:16.100]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.100]             })
[17:59:16.100]         }
[17:59:16.100]     }, args = future.call.arguments)
[17:59:16.100] }
[17:59:16.100] Lazy evaluation: FALSE
[17:59:16.100] Asynchronous evaluation: FALSE
[17:59:16.100] Local evaluation: TRUE
[17:59:16.100] Environment: R_GlobalEnv
[17:59:16.100] Capture standard output: TRUE
[17:59:16.100] Capture condition classes: <none>
[17:59:16.100] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:16.100] Packages: <none>
[17:59:16.100] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:59:16.100] Resolved: TRUE
[17:59:16.100] Value: 112 bytes of class ‘list’
[17:59:16.100] Early signaling: FALSE
[17:59:16.100] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:16.100] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:16.102] Chunk #1 of 1 ... DONE
[17:59:16.102] Launching 1 futures (chunks) ... DONE
[17:59:16.102] Resolving 1 futures (chunks) ...
[17:59:16.103] resolve() on list ...
[17:59:16.103]  recursive: 0
[17:59:16.103]  length: 1
[17:59:16.103] 
[17:59:16.103] resolved() for ‘SequentialFuture’ ...
[17:59:16.103] - state: ‘finished’
[17:59:16.104] - run: TRUE
[17:59:16.104] - result: ‘FutureResult’
[17:59:16.104] resolved() for ‘SequentialFuture’ ... done
[17:59:16.104] Future #1
[17:59:16.105] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:16.105] - nx: 1
[17:59:16.105] - relay: TRUE
[17:59:16.105] - stdout: TRUE
[17:59:16.105] - signal: TRUE
[17:59:16.105] - resignal: FALSE
[17:59:16.106] - force: TRUE
[17:59:16.106] - relayed: [n=1] FALSE
[17:59:16.106] - queued futures: [n=1] FALSE
[17:59:16.106]  - until=1
[17:59:16.106]  - relaying element #1
[17:59:16.107] - relayed: [n=1] TRUE
[17:59:16.107] - queued futures: [n=1] TRUE
[17:59:16.107] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:16.107]  length: 0 (resolved future 1)
[17:59:16.108] Relaying remaining futures
[17:59:16.108] signalConditionsASAP(NULL, pos=0) ...
[17:59:16.108] - nx: 1
[17:59:16.108] - relay: TRUE
[17:59:16.108] - stdout: TRUE
[17:59:16.108] - signal: TRUE
[17:59:16.109] - resignal: FALSE
[17:59:16.109] - force: TRUE
[17:59:16.111] - relayed: [n=1] TRUE
[17:59:16.111] - queued futures: [n=1] TRUE
 - flush all
[17:59:16.112] - relayed: [n=1] TRUE
[17:59:16.112] - queued futures: [n=1] TRUE
[17:59:16.112] signalConditionsASAP(NULL, pos=0) ... done
[17:59:16.112] resolve() on list ... DONE
[17:59:16.113]  - Number of value chunks collected: 1
[17:59:16.113] Resolving 1 futures (chunks) ... DONE
[17:59:16.113] Reducing values from 1 chunks ...
[17:59:16.113]  - Number of values collected after concatenation: 2
[17:59:16.113]  - Number of values expected: 2
[17:59:16.114] Reducing values from 1 chunks ... DONE
[17:59:16.114] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:59:16.114] plan(): Setting new future strategy stack:
[17:59:16.114] List of future strategies:
[17:59:16.114] 1. sequential:
[17:59:16.114]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:16.114]    - tweaked: FALSE
[17:59:16.114]    - call: plan(sequential)
[17:59:16.115] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:59:16.116] plan(): Setting new future strategy stack:
[17:59:16.116] List of future strategies:
[17:59:16.116] 1. multicore:
[17:59:16.116]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:16.116]    - tweaked: FALSE
[17:59:16.116]    - call: plan(strategy)
[17:59:16.123] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[17:59:16.124] getGlobalsAndPackagesXApply() ...
[17:59:16.124]  - future.globals: TRUE
[17:59:16.124] getGlobalsAndPackages() ...
[17:59:16.124] Searching for globals...
[17:59:16.195] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:59:16.195] Searching for globals ... DONE
[17:59:16.196] Resolving globals: FALSE
[17:59:16.202] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:59:16.203] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:59:16.203] - globals: [1] ‘FUN’
[17:59:16.203] 
[17:59:16.203] getGlobalsAndPackages() ... DONE
[17:59:16.203]  - globals found/used: [n=1] ‘FUN’
[17:59:16.204]  - needed namespaces: [n=0] 
[17:59:16.204] Finding globals ... DONE
[17:59:16.204]  - use_args: TRUE
[17:59:16.204]  - Getting '...' globals ...
[17:59:16.205] resolve() on list ...
[17:59:16.205]  recursive: 0
[17:59:16.205]  length: 1
[17:59:16.205]  elements: ‘...’
[17:59:16.206]  length: 0 (resolved future 1)
[17:59:16.206] resolve() on list ... DONE
[17:59:16.206]    - '...' content: [n=0] 
[17:59:16.206] List of 1
[17:59:16.206]  $ ...: list()
[17:59:16.206]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.206]  - attr(*, "where")=List of 1
[17:59:16.206]   ..$ ...:<environment: 0x560859630868> 
[17:59:16.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.206]  - attr(*, "resolved")= logi TRUE
[17:59:16.206]  - attr(*, "total_size")= num NA
[17:59:16.211]  - Getting '...' globals ... DONE
[17:59:16.211] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:16.212] List of 2
[17:59:16.212]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:16.212]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:16.212]  $ ...          : list()
[17:59:16.212]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.212]  - attr(*, "where")=List of 2
[17:59:16.212]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:16.212]   ..$ ...          :<environment: 0x560859630868> 
[17:59:16.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.212]  - attr(*, "resolved")= logi FALSE
[17:59:16.212]  - attr(*, "total_size")= num 354224
[17:59:16.217] Packages to be attached in all futures: [n=0] 
[17:59:16.217] getGlobalsAndPackagesXApply() ... DONE
[17:59:16.225] future_lapply() ...
[17:59:16.304] Number of chunks: 2
[17:59:16.304] getGlobalsAndPackagesXApply() ...
[17:59:16.304]  - future.globals: <name-value list> with names ‘list()’
[17:59:16.305]  - use_args: TRUE
[17:59:16.305] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:16.305] List of 2
[17:59:16.305]  $ ...          : list()
[17:59:16.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.305]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:16.305]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:16.305]  - attr(*, "where")=List of 2
[17:59:16.305]   ..$ ...          :<environment: 0x560859630868> 
[17:59:16.305]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:16.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.305]  - attr(*, "resolved")= logi FALSE
[17:59:16.305]  - attr(*, "total_size")= num NA
[17:59:16.312] Packages to be attached in all futures: [n=0] 
[17:59:16.312] getGlobalsAndPackagesXApply() ... DONE
[17:59:16.312] Number of futures (= number of chunks): 2
[17:59:16.313] Launching 2 futures (chunks) ...
[17:59:16.313] Chunk #1 of 2 ...
[17:59:16.313]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:16.313]  - seeds: <none>
[17:59:16.313]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.314] getGlobalsAndPackages() ...
[17:59:16.314] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.314] Resolving globals: FALSE
[17:59:16.314] Tweak future expression to call with '...' arguments ...
[17:59:16.315] {
[17:59:16.315]     do.call(function(...) {
[17:59:16.315]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.315]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.315]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.315]             on.exit(options(oopts), add = TRUE)
[17:59:16.315]         }
[17:59:16.315]         {
[17:59:16.315]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.315]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.315]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.315]             })
[17:59:16.315]         }
[17:59:16.315]     }, args = future.call.arguments)
[17:59:16.315] }
[17:59:16.315] Tweak future expression to call with '...' arguments ... DONE
[17:59:16.316] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.316] 
[17:59:16.316] getGlobalsAndPackages() ... DONE
[17:59:16.317] run() for ‘Future’ ...
[17:59:16.317] - state: ‘created’
[17:59:16.317] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:16.324] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:16.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:16.324]   - Field: ‘label’
[17:59:16.325]   - Field: ‘local’
[17:59:16.325]   - Field: ‘owner’
[17:59:16.325]   - Field: ‘envir’
[17:59:16.325]   - Field: ‘workers’
[17:59:16.326]   - Field: ‘packages’
[17:59:16.326]   - Field: ‘gc’
[17:59:16.326]   - Field: ‘job’
[17:59:16.326]   - Field: ‘conditions’
[17:59:16.326]   - Field: ‘expr’
[17:59:16.327]   - Field: ‘uuid’
[17:59:16.327]   - Field: ‘seed’
[17:59:16.327]   - Field: ‘version’
[17:59:16.327]   - Field: ‘result’
[17:59:16.327]   - Field: ‘asynchronous’
[17:59:16.328]   - Field: ‘calls’
[17:59:16.328]   - Field: ‘globals’
[17:59:16.328]   - Field: ‘stdout’
[17:59:16.328]   - Field: ‘earlySignal’
[17:59:16.328]   - Field: ‘lazy’
[17:59:16.328]   - Field: ‘state’
[17:59:16.329] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:16.329] - Launch lazy future ...
[17:59:16.331] Packages needed by the future expression (n = 0): <none>
[17:59:16.331] Packages needed by future strategies (n = 0): <none>
[17:59:16.332] {
[17:59:16.332]     {
[17:59:16.332]         {
[17:59:16.332]             ...future.startTime <- base::Sys.time()
[17:59:16.332]             {
[17:59:16.332]                 {
[17:59:16.332]                   {
[17:59:16.332]                     {
[17:59:16.332]                       base::local({
[17:59:16.332]                         has_future <- base::requireNamespace("future", 
[17:59:16.332]                           quietly = TRUE)
[17:59:16.332]                         if (has_future) {
[17:59:16.332]                           ns <- base::getNamespace("future")
[17:59:16.332]                           version <- ns[[".package"]][["version"]]
[17:59:16.332]                           if (is.null(version)) 
[17:59:16.332]                             version <- utils::packageVersion("future")
[17:59:16.332]                         }
[17:59:16.332]                         else {
[17:59:16.332]                           version <- NULL
[17:59:16.332]                         }
[17:59:16.332]                         if (!has_future || version < "1.8.0") {
[17:59:16.332]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:16.332]                             "", base::R.version$version.string), 
[17:59:16.332]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:16.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:16.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:16.332]                               "release", "version")], collapse = " "), 
[17:59:16.332]                             hostname = base::Sys.info()[["nodename"]])
[17:59:16.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:16.332]                             info)
[17:59:16.332]                           info <- base::paste(info, collapse = "; ")
[17:59:16.332]                           if (!has_future) {
[17:59:16.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:16.332]                               info)
[17:59:16.332]                           }
[17:59:16.332]                           else {
[17:59:16.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:16.332]                               info, version)
[17:59:16.332]                           }
[17:59:16.332]                           base::stop(msg)
[17:59:16.332]                         }
[17:59:16.332]                       })
[17:59:16.332]                     }
[17:59:16.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:16.332]                     base::options(mc.cores = 1L)
[17:59:16.332]                   }
[17:59:16.332]                   ...future.strategy.old <- future::plan("list")
[17:59:16.332]                   options(future.plan = NULL)
[17:59:16.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:16.332]                 }
[17:59:16.332]                 ...future.workdir <- getwd()
[17:59:16.332]             }
[17:59:16.332]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:16.332]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:16.332]         }
[17:59:16.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:16.332]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:16.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:16.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:16.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:16.332]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:16.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:16.332]             base::names(...future.oldOptions))
[17:59:16.332]     }
[17:59:16.332]     if (FALSE) {
[17:59:16.332]     }
[17:59:16.332]     else {
[17:59:16.332]         if (TRUE) {
[17:59:16.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:16.332]                 open = "w")
[17:59:16.332]         }
[17:59:16.332]         else {
[17:59:16.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:16.332]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:16.332]         }
[17:59:16.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:16.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:16.332]             base::sink(type = "output", split = FALSE)
[17:59:16.332]             base::close(...future.stdout)
[17:59:16.332]         }, add = TRUE)
[17:59:16.332]     }
[17:59:16.332]     ...future.frame <- base::sys.nframe()
[17:59:16.332]     ...future.conditions <- base::list()
[17:59:16.332]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:16.332]     if (FALSE) {
[17:59:16.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:16.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:16.332]     }
[17:59:16.332]     ...future.result <- base::tryCatch({
[17:59:16.332]         base::withCallingHandlers({
[17:59:16.332]             ...future.value <- base::withVisible(base::local({
[17:59:16.332]                 withCallingHandlers({
[17:59:16.332]                   {
[17:59:16.332]                     do.call(function(...) {
[17:59:16.332]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.332]                       if (!identical(...future.globals.maxSize.org, 
[17:59:16.332]                         ...future.globals.maxSize)) {
[17:59:16.332]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.332]                         on.exit(options(oopts), add = TRUE)
[17:59:16.332]                       }
[17:59:16.332]                       {
[17:59:16.332]                         lapply(seq_along(...future.elements_ii), 
[17:59:16.332]                           FUN = function(jj) {
[17:59:16.332]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.332]                             ...future.FUN(...future.X_jj, ...)
[17:59:16.332]                           })
[17:59:16.332]                       }
[17:59:16.332]                     }, args = future.call.arguments)
[17:59:16.332]                   }
[17:59:16.332]                 }, immediateCondition = function(cond) {
[17:59:16.332]                   save_rds <- function (object, pathname, ...) 
[17:59:16.332]                   {
[17:59:16.332]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:16.332]                     if (file_test("-f", pathname_tmp)) {
[17:59:16.332]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.332]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:16.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.332]                         fi_tmp[["mtime"]])
[17:59:16.332]                     }
[17:59:16.332]                     tryCatch({
[17:59:16.332]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:16.332]                     }, error = function(ex) {
[17:59:16.332]                       msg <- conditionMessage(ex)
[17:59:16.332]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.332]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:16.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.332]                         fi_tmp[["mtime"]], msg)
[17:59:16.332]                       ex$message <- msg
[17:59:16.332]                       stop(ex)
[17:59:16.332]                     })
[17:59:16.332]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:16.332]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:16.332]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:16.332]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.332]                       fi <- file.info(pathname)
[17:59:16.332]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:16.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.332]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:16.332]                         fi[["size"]], fi[["mtime"]])
[17:59:16.332]                       stop(msg)
[17:59:16.332]                     }
[17:59:16.332]                     invisible(pathname)
[17:59:16.332]                   }
[17:59:16.332]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:16.332]                     rootPath = tempdir()) 
[17:59:16.332]                   {
[17:59:16.332]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:16.332]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:16.332]                       tmpdir = path, fileext = ".rds")
[17:59:16.332]                     save_rds(obj, file)
[17:59:16.332]                   }
[17:59:16.332]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:16.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.332]                   {
[17:59:16.332]                     inherits <- base::inherits
[17:59:16.332]                     invokeRestart <- base::invokeRestart
[17:59:16.332]                     is.null <- base::is.null
[17:59:16.332]                     muffled <- FALSE
[17:59:16.332]                     if (inherits(cond, "message")) {
[17:59:16.332]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:16.332]                       if (muffled) 
[17:59:16.332]                         invokeRestart("muffleMessage")
[17:59:16.332]                     }
[17:59:16.332]                     else if (inherits(cond, "warning")) {
[17:59:16.332]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:16.332]                       if (muffled) 
[17:59:16.332]                         invokeRestart("muffleWarning")
[17:59:16.332]                     }
[17:59:16.332]                     else if (inherits(cond, "condition")) {
[17:59:16.332]                       if (!is.null(pattern)) {
[17:59:16.332]                         computeRestarts <- base::computeRestarts
[17:59:16.332]                         grepl <- base::grepl
[17:59:16.332]                         restarts <- computeRestarts(cond)
[17:59:16.332]                         for (restart in restarts) {
[17:59:16.332]                           name <- restart$name
[17:59:16.332]                           if (is.null(name)) 
[17:59:16.332]                             next
[17:59:16.332]                           if (!grepl(pattern, name)) 
[17:59:16.332]                             next
[17:59:16.332]                           invokeRestart(restart)
[17:59:16.332]                           muffled <- TRUE
[17:59:16.332]                           break
[17:59:16.332]                         }
[17:59:16.332]                       }
[17:59:16.332]                     }
[17:59:16.332]                     invisible(muffled)
[17:59:16.332]                   }
[17:59:16.332]                   muffleCondition(cond)
[17:59:16.332]                 })
[17:59:16.332]             }))
[17:59:16.332]             future::FutureResult(value = ...future.value$value, 
[17:59:16.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.332]                   ...future.rng), globalenv = if (FALSE) 
[17:59:16.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:16.332]                     ...future.globalenv.names))
[17:59:16.332]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:16.332]         }, condition = base::local({
[17:59:16.332]             c <- base::c
[17:59:16.332]             inherits <- base::inherits
[17:59:16.332]             invokeRestart <- base::invokeRestart
[17:59:16.332]             length <- base::length
[17:59:16.332]             list <- base::list
[17:59:16.332]             seq.int <- base::seq.int
[17:59:16.332]             signalCondition <- base::signalCondition
[17:59:16.332]             sys.calls <- base::sys.calls
[17:59:16.332]             `[[` <- base::`[[`
[17:59:16.332]             `+` <- base::`+`
[17:59:16.332]             `<<-` <- base::`<<-`
[17:59:16.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:16.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:16.332]                   3L)]
[17:59:16.332]             }
[17:59:16.332]             function(cond) {
[17:59:16.332]                 is_error <- inherits(cond, "error")
[17:59:16.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:16.332]                   NULL)
[17:59:16.332]                 if (is_error) {
[17:59:16.332]                   sessionInformation <- function() {
[17:59:16.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:16.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:16.332]                       search = base::search(), system = base::Sys.info())
[17:59:16.332]                   }
[17:59:16.332]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:16.332]                     cond$call), session = sessionInformation(), 
[17:59:16.332]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:16.332]                   signalCondition(cond)
[17:59:16.332]                 }
[17:59:16.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:16.332]                 "immediateCondition"))) {
[17:59:16.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:16.332]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:16.332]                   if (TRUE && !signal) {
[17:59:16.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.332]                     {
[17:59:16.332]                       inherits <- base::inherits
[17:59:16.332]                       invokeRestart <- base::invokeRestart
[17:59:16.332]                       is.null <- base::is.null
[17:59:16.332]                       muffled <- FALSE
[17:59:16.332]                       if (inherits(cond, "message")) {
[17:59:16.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.332]                         if (muffled) 
[17:59:16.332]                           invokeRestart("muffleMessage")
[17:59:16.332]                       }
[17:59:16.332]                       else if (inherits(cond, "warning")) {
[17:59:16.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.332]                         if (muffled) 
[17:59:16.332]                           invokeRestart("muffleWarning")
[17:59:16.332]                       }
[17:59:16.332]                       else if (inherits(cond, "condition")) {
[17:59:16.332]                         if (!is.null(pattern)) {
[17:59:16.332]                           computeRestarts <- base::computeRestarts
[17:59:16.332]                           grepl <- base::grepl
[17:59:16.332]                           restarts <- computeRestarts(cond)
[17:59:16.332]                           for (restart in restarts) {
[17:59:16.332]                             name <- restart$name
[17:59:16.332]                             if (is.null(name)) 
[17:59:16.332]                               next
[17:59:16.332]                             if (!grepl(pattern, name)) 
[17:59:16.332]                               next
[17:59:16.332]                             invokeRestart(restart)
[17:59:16.332]                             muffled <- TRUE
[17:59:16.332]                             break
[17:59:16.332]                           }
[17:59:16.332]                         }
[17:59:16.332]                       }
[17:59:16.332]                       invisible(muffled)
[17:59:16.332]                     }
[17:59:16.332]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.332]                   }
[17:59:16.332]                 }
[17:59:16.332]                 else {
[17:59:16.332]                   if (TRUE) {
[17:59:16.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.332]                     {
[17:59:16.332]                       inherits <- base::inherits
[17:59:16.332]                       invokeRestart <- base::invokeRestart
[17:59:16.332]                       is.null <- base::is.null
[17:59:16.332]                       muffled <- FALSE
[17:59:16.332]                       if (inherits(cond, "message")) {
[17:59:16.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.332]                         if (muffled) 
[17:59:16.332]                           invokeRestart("muffleMessage")
[17:59:16.332]                       }
[17:59:16.332]                       else if (inherits(cond, "warning")) {
[17:59:16.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.332]                         if (muffled) 
[17:59:16.332]                           invokeRestart("muffleWarning")
[17:59:16.332]                       }
[17:59:16.332]                       else if (inherits(cond, "condition")) {
[17:59:16.332]                         if (!is.null(pattern)) {
[17:59:16.332]                           computeRestarts <- base::computeRestarts
[17:59:16.332]                           grepl <- base::grepl
[17:59:16.332]                           restarts <- computeRestarts(cond)
[17:59:16.332]                           for (restart in restarts) {
[17:59:16.332]                             name <- restart$name
[17:59:16.332]                             if (is.null(name)) 
[17:59:16.332]                               next
[17:59:16.332]                             if (!grepl(pattern, name)) 
[17:59:16.332]                               next
[17:59:16.332]                             invokeRestart(restart)
[17:59:16.332]                             muffled <- TRUE
[17:59:16.332]                             break
[17:59:16.332]                           }
[17:59:16.332]                         }
[17:59:16.332]                       }
[17:59:16.332]                       invisible(muffled)
[17:59:16.332]                     }
[17:59:16.332]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.332]                   }
[17:59:16.332]                 }
[17:59:16.332]             }
[17:59:16.332]         }))
[17:59:16.332]     }, error = function(ex) {
[17:59:16.332]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:16.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.332]                 ...future.rng), started = ...future.startTime, 
[17:59:16.332]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:16.332]             version = "1.8"), class = "FutureResult")
[17:59:16.332]     }, finally = {
[17:59:16.332]         if (!identical(...future.workdir, getwd())) 
[17:59:16.332]             setwd(...future.workdir)
[17:59:16.332]         {
[17:59:16.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:16.332]                 ...future.oldOptions$nwarnings <- NULL
[17:59:16.332]             }
[17:59:16.332]             base::options(...future.oldOptions)
[17:59:16.332]             if (.Platform$OS.type == "windows") {
[17:59:16.332]                 old_names <- names(...future.oldEnvVars)
[17:59:16.332]                 envs <- base::Sys.getenv()
[17:59:16.332]                 names <- names(envs)
[17:59:16.332]                 common <- intersect(names, old_names)
[17:59:16.332]                 added <- setdiff(names, old_names)
[17:59:16.332]                 removed <- setdiff(old_names, names)
[17:59:16.332]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:16.332]                   envs[common]]
[17:59:16.332]                 NAMES <- toupper(changed)
[17:59:16.332]                 args <- list()
[17:59:16.332]                 for (kk in seq_along(NAMES)) {
[17:59:16.332]                   name <- changed[[kk]]
[17:59:16.332]                   NAME <- NAMES[[kk]]
[17:59:16.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.332]                     next
[17:59:16.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.332]                 }
[17:59:16.332]                 NAMES <- toupper(added)
[17:59:16.332]                 for (kk in seq_along(NAMES)) {
[17:59:16.332]                   name <- added[[kk]]
[17:59:16.332]                   NAME <- NAMES[[kk]]
[17:59:16.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.332]                     next
[17:59:16.332]                   args[[name]] <- ""
[17:59:16.332]                 }
[17:59:16.332]                 NAMES <- toupper(removed)
[17:59:16.332]                 for (kk in seq_along(NAMES)) {
[17:59:16.332]                   name <- removed[[kk]]
[17:59:16.332]                   NAME <- NAMES[[kk]]
[17:59:16.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.332]                     next
[17:59:16.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.332]                 }
[17:59:16.332]                 if (length(args) > 0) 
[17:59:16.332]                   base::do.call(base::Sys.setenv, args = args)
[17:59:16.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:16.332]             }
[17:59:16.332]             else {
[17:59:16.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:16.332]             }
[17:59:16.332]             {
[17:59:16.332]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:16.332]                   0L) {
[17:59:16.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:16.332]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:16.332]                   base::options(opts)
[17:59:16.332]                 }
[17:59:16.332]                 {
[17:59:16.332]                   {
[17:59:16.332]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:16.332]                     NULL
[17:59:16.332]                   }
[17:59:16.332]                   options(future.plan = NULL)
[17:59:16.332]                   if (is.na(NA_character_)) 
[17:59:16.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:16.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:16.332]                     .init = FALSE)
[17:59:16.332]                 }
[17:59:16.332]             }
[17:59:16.332]         }
[17:59:16.332]     })
[17:59:16.332]     if (TRUE) {
[17:59:16.332]         base::sink(type = "output", split = FALSE)
[17:59:16.332]         if (TRUE) {
[17:59:16.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:16.332]         }
[17:59:16.332]         else {
[17:59:16.332]             ...future.result["stdout"] <- base::list(NULL)
[17:59:16.332]         }
[17:59:16.332]         base::close(...future.stdout)
[17:59:16.332]         ...future.stdout <- NULL
[17:59:16.332]     }
[17:59:16.332]     ...future.result$conditions <- ...future.conditions
[17:59:16.332]     ...future.result$finished <- base::Sys.time()
[17:59:16.332]     ...future.result
[17:59:16.332] }
[17:59:16.336] assign_globals() ...
[17:59:16.336] List of 5
[17:59:16.336]  $ future.call.arguments    : list()
[17:59:16.336]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.336]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:16.336]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:16.336]  $ ...future.elements_ii    :List of 1
[17:59:16.336]   ..$ : num [1:4] 1 3 1 7
[17:59:16.336]  $ ...future.seeds_ii       : NULL
[17:59:16.336]  $ ...future.globals.maxSize: num Inf
[17:59:16.336]  - attr(*, "resolved")= logi FALSE
[17:59:16.336]  - attr(*, "total_size")= num NA
[17:59:16.336]  - attr(*, "where")=List of 5
[17:59:16.336]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:16.336]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:16.336]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:16.336]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:16.336]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:16.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.336]  - attr(*, "already-done")= logi TRUE
[17:59:16.347] - copied ‘future.call.arguments’ to environment
[17:59:16.347] - copied ‘...future.FUN’ to environment
[17:59:16.347] - copied ‘...future.elements_ii’ to environment
[17:59:16.347] - copied ‘...future.seeds_ii’ to environment
[17:59:16.348] - copied ‘...future.globals.maxSize’ to environment
[17:59:16.348] assign_globals() ... done
[17:59:16.348] requestCore(): workers = 2
[17:59:16.353] MulticoreFuture started
[17:59:16.353] - Launch lazy future ... done
[17:59:16.354] run() for ‘MulticoreFuture’ ... done
[17:59:16.354] plan(): Setting new future strategy stack:
[17:59:16.354] Created future:
[17:59:16.355] List of future strategies:
[17:59:16.355] 1. sequential:
[17:59:16.355]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:16.355]    - tweaked: FALSE
[17:59:16.355]    - call: NULL
[17:59:16.357] plan(): nbrOfWorkers() = 1
[17:59:16.372] plan(): Setting new future strategy stack:
[17:59:16.373] List of future strategies:
[17:59:16.373] 1. multicore:
[17:59:16.373]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:16.373]    - tweaked: FALSE
[17:59:16.373]    - call: plan(strategy)
[17:59:16.355] MulticoreFuture:
[17:59:16.355] Label: ‘future_apply-1’
[17:59:16.355] Expression:
[17:59:16.355] {
[17:59:16.355]     do.call(function(...) {
[17:59:16.355]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.355]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.355]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.355]             on.exit(options(oopts), add = TRUE)
[17:59:16.355]         }
[17:59:16.355]         {
[17:59:16.355]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.355]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.355]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.355]             })
[17:59:16.355]         }
[17:59:16.355]     }, args = future.call.arguments)
[17:59:16.355] }
[17:59:16.355] Lazy evaluation: FALSE
[17:59:16.355] Asynchronous evaluation: TRUE
[17:59:16.355] Local evaluation: TRUE
[17:59:16.355] Environment: R_GlobalEnv
[17:59:16.355] Capture standard output: TRUE
[17:59:16.355] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:16.355] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:16.355] Packages: <none>
[17:59:16.355] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:16.355] Resolved: FALSE
[17:59:16.355] Value: <not collected>
[17:59:16.355] Conditions captured: <none>
[17:59:16.355] Early signaling: FALSE
[17:59:16.355] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:16.355] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:16.382] Chunk #1 of 2 ... DONE
[17:59:16.383] Chunk #2 of 2 ...
[17:59:16.383]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:16.384] plan(): nbrOfWorkers() = 2
[17:59:16.384]  - seeds: <none>
[17:59:16.384]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.385] getGlobalsAndPackages() ...
[17:59:16.385] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.385] Resolving globals: FALSE
[17:59:16.386] Tweak future expression to call with '...' arguments ...
[17:59:16.386] {
[17:59:16.386]     do.call(function(...) {
[17:59:16.386]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.386]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.386]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.386]             on.exit(options(oopts), add = TRUE)
[17:59:16.386]         }
[17:59:16.386]         {
[17:59:16.386]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.386]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.386]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.386]             })
[17:59:16.386]         }
[17:59:16.386]     }, args = future.call.arguments)
[17:59:16.386] }
[17:59:16.387] Tweak future expression to call with '...' arguments ... DONE
[17:59:16.388] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.388] 
[17:59:16.388] getGlobalsAndPackages() ... DONE
[17:59:16.390] run() for ‘Future’ ...
[17:59:16.390] - state: ‘created’
[17:59:16.391] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:16.398] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:16.399] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:16.399]   - Field: ‘label’
[17:59:16.399]   - Field: ‘local’
[17:59:16.400]   - Field: ‘owner’
[17:59:16.400]   - Field: ‘envir’
[17:59:16.400]   - Field: ‘workers’
[17:59:16.400]   - Field: ‘packages’
[17:59:16.401]   - Field: ‘gc’
[17:59:16.401]   - Field: ‘job’
[17:59:16.401]   - Field: ‘conditions’
[17:59:16.402]   - Field: ‘expr’
[17:59:16.402]   - Field: ‘uuid’
[17:59:16.402]   - Field: ‘seed’
[17:59:16.402]   - Field: ‘version’
[17:59:16.403]   - Field: ‘result’
[17:59:16.403]   - Field: ‘asynchronous’
[17:59:16.403]   - Field: ‘calls’
[17:59:16.403]   - Field: ‘globals’
[17:59:16.404]   - Field: ‘stdout’
[17:59:16.404]   - Field: ‘earlySignal’
[17:59:16.404]   - Field: ‘lazy’
[17:59:16.405]   - Field: ‘state’
[17:59:16.405] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:16.405] - Launch lazy future ...
[17:59:16.406] Packages needed by the future expression (n = 0): <none>
[17:59:16.406] Packages needed by future strategies (n = 0): <none>
[17:59:16.409] {
[17:59:16.409]     {
[17:59:16.409]         {
[17:59:16.409]             ...future.startTime <- base::Sys.time()
[17:59:16.409]             {
[17:59:16.409]                 {
[17:59:16.409]                   {
[17:59:16.409]                     {
[17:59:16.409]                       base::local({
[17:59:16.409]                         has_future <- base::requireNamespace("future", 
[17:59:16.409]                           quietly = TRUE)
[17:59:16.409]                         if (has_future) {
[17:59:16.409]                           ns <- base::getNamespace("future")
[17:59:16.409]                           version <- ns[[".package"]][["version"]]
[17:59:16.409]                           if (is.null(version)) 
[17:59:16.409]                             version <- utils::packageVersion("future")
[17:59:16.409]                         }
[17:59:16.409]                         else {
[17:59:16.409]                           version <- NULL
[17:59:16.409]                         }
[17:59:16.409]                         if (!has_future || version < "1.8.0") {
[17:59:16.409]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:16.409]                             "", base::R.version$version.string), 
[17:59:16.409]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:16.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:16.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:16.409]                               "release", "version")], collapse = " "), 
[17:59:16.409]                             hostname = base::Sys.info()[["nodename"]])
[17:59:16.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:16.409]                             info)
[17:59:16.409]                           info <- base::paste(info, collapse = "; ")
[17:59:16.409]                           if (!has_future) {
[17:59:16.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:16.409]                               info)
[17:59:16.409]                           }
[17:59:16.409]                           else {
[17:59:16.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:16.409]                               info, version)
[17:59:16.409]                           }
[17:59:16.409]                           base::stop(msg)
[17:59:16.409]                         }
[17:59:16.409]                       })
[17:59:16.409]                     }
[17:59:16.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:16.409]                     base::options(mc.cores = 1L)
[17:59:16.409]                   }
[17:59:16.409]                   ...future.strategy.old <- future::plan("list")
[17:59:16.409]                   options(future.plan = NULL)
[17:59:16.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:16.409]                 }
[17:59:16.409]                 ...future.workdir <- getwd()
[17:59:16.409]             }
[17:59:16.409]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:16.409]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:16.409]         }
[17:59:16.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:16.409]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:16.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:16.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:16.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:16.409]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:16.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:16.409]             base::names(...future.oldOptions))
[17:59:16.409]     }
[17:59:16.409]     if (FALSE) {
[17:59:16.409]     }
[17:59:16.409]     else {
[17:59:16.409]         if (TRUE) {
[17:59:16.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:16.409]                 open = "w")
[17:59:16.409]         }
[17:59:16.409]         else {
[17:59:16.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:16.409]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:16.409]         }
[17:59:16.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:16.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:16.409]             base::sink(type = "output", split = FALSE)
[17:59:16.409]             base::close(...future.stdout)
[17:59:16.409]         }, add = TRUE)
[17:59:16.409]     }
[17:59:16.409]     ...future.frame <- base::sys.nframe()
[17:59:16.409]     ...future.conditions <- base::list()
[17:59:16.409]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:16.409]     if (FALSE) {
[17:59:16.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:16.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:16.409]     }
[17:59:16.409]     ...future.result <- base::tryCatch({
[17:59:16.409]         base::withCallingHandlers({
[17:59:16.409]             ...future.value <- base::withVisible(base::local({
[17:59:16.409]                 withCallingHandlers({
[17:59:16.409]                   {
[17:59:16.409]                     do.call(function(...) {
[17:59:16.409]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.409]                       if (!identical(...future.globals.maxSize.org, 
[17:59:16.409]                         ...future.globals.maxSize)) {
[17:59:16.409]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.409]                         on.exit(options(oopts), add = TRUE)
[17:59:16.409]                       }
[17:59:16.409]                       {
[17:59:16.409]                         lapply(seq_along(...future.elements_ii), 
[17:59:16.409]                           FUN = function(jj) {
[17:59:16.409]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.409]                             ...future.FUN(...future.X_jj, ...)
[17:59:16.409]                           })
[17:59:16.409]                       }
[17:59:16.409]                     }, args = future.call.arguments)
[17:59:16.409]                   }
[17:59:16.409]                 }, immediateCondition = function(cond) {
[17:59:16.409]                   save_rds <- function (object, pathname, ...) 
[17:59:16.409]                   {
[17:59:16.409]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:16.409]                     if (file_test("-f", pathname_tmp)) {
[17:59:16.409]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.409]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:16.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.409]                         fi_tmp[["mtime"]])
[17:59:16.409]                     }
[17:59:16.409]                     tryCatch({
[17:59:16.409]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:16.409]                     }, error = function(ex) {
[17:59:16.409]                       msg <- conditionMessage(ex)
[17:59:16.409]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.409]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:16.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.409]                         fi_tmp[["mtime"]], msg)
[17:59:16.409]                       ex$message <- msg
[17:59:16.409]                       stop(ex)
[17:59:16.409]                     })
[17:59:16.409]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:16.409]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:16.409]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:16.409]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.409]                       fi <- file.info(pathname)
[17:59:16.409]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:16.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.409]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:16.409]                         fi[["size"]], fi[["mtime"]])
[17:59:16.409]                       stop(msg)
[17:59:16.409]                     }
[17:59:16.409]                     invisible(pathname)
[17:59:16.409]                   }
[17:59:16.409]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:16.409]                     rootPath = tempdir()) 
[17:59:16.409]                   {
[17:59:16.409]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:16.409]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:16.409]                       tmpdir = path, fileext = ".rds")
[17:59:16.409]                     save_rds(obj, file)
[17:59:16.409]                   }
[17:59:16.409]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:16.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.409]                   {
[17:59:16.409]                     inherits <- base::inherits
[17:59:16.409]                     invokeRestart <- base::invokeRestart
[17:59:16.409]                     is.null <- base::is.null
[17:59:16.409]                     muffled <- FALSE
[17:59:16.409]                     if (inherits(cond, "message")) {
[17:59:16.409]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:16.409]                       if (muffled) 
[17:59:16.409]                         invokeRestart("muffleMessage")
[17:59:16.409]                     }
[17:59:16.409]                     else if (inherits(cond, "warning")) {
[17:59:16.409]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:16.409]                       if (muffled) 
[17:59:16.409]                         invokeRestart("muffleWarning")
[17:59:16.409]                     }
[17:59:16.409]                     else if (inherits(cond, "condition")) {
[17:59:16.409]                       if (!is.null(pattern)) {
[17:59:16.409]                         computeRestarts <- base::computeRestarts
[17:59:16.409]                         grepl <- base::grepl
[17:59:16.409]                         restarts <- computeRestarts(cond)
[17:59:16.409]                         for (restart in restarts) {
[17:59:16.409]                           name <- restart$name
[17:59:16.409]                           if (is.null(name)) 
[17:59:16.409]                             next
[17:59:16.409]                           if (!grepl(pattern, name)) 
[17:59:16.409]                             next
[17:59:16.409]                           invokeRestart(restart)
[17:59:16.409]                           muffled <- TRUE
[17:59:16.409]                           break
[17:59:16.409]                         }
[17:59:16.409]                       }
[17:59:16.409]                     }
[17:59:16.409]                     invisible(muffled)
[17:59:16.409]                   }
[17:59:16.409]                   muffleCondition(cond)
[17:59:16.409]                 })
[17:59:16.409]             }))
[17:59:16.409]             future::FutureResult(value = ...future.value$value, 
[17:59:16.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.409]                   ...future.rng), globalenv = if (FALSE) 
[17:59:16.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:16.409]                     ...future.globalenv.names))
[17:59:16.409]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:16.409]         }, condition = base::local({
[17:59:16.409]             c <- base::c
[17:59:16.409]             inherits <- base::inherits
[17:59:16.409]             invokeRestart <- base::invokeRestart
[17:59:16.409]             length <- base::length
[17:59:16.409]             list <- base::list
[17:59:16.409]             seq.int <- base::seq.int
[17:59:16.409]             signalCondition <- base::signalCondition
[17:59:16.409]             sys.calls <- base::sys.calls
[17:59:16.409]             `[[` <- base::`[[`
[17:59:16.409]             `+` <- base::`+`
[17:59:16.409]             `<<-` <- base::`<<-`
[17:59:16.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:16.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:16.409]                   3L)]
[17:59:16.409]             }
[17:59:16.409]             function(cond) {
[17:59:16.409]                 is_error <- inherits(cond, "error")
[17:59:16.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:16.409]                   NULL)
[17:59:16.409]                 if (is_error) {
[17:59:16.409]                   sessionInformation <- function() {
[17:59:16.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:16.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:16.409]                       search = base::search(), system = base::Sys.info())
[17:59:16.409]                   }
[17:59:16.409]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:16.409]                     cond$call), session = sessionInformation(), 
[17:59:16.409]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:16.409]                   signalCondition(cond)
[17:59:16.409]                 }
[17:59:16.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:16.409]                 "immediateCondition"))) {
[17:59:16.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:16.409]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:16.409]                   if (TRUE && !signal) {
[17:59:16.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.409]                     {
[17:59:16.409]                       inherits <- base::inherits
[17:59:16.409]                       invokeRestart <- base::invokeRestart
[17:59:16.409]                       is.null <- base::is.null
[17:59:16.409]                       muffled <- FALSE
[17:59:16.409]                       if (inherits(cond, "message")) {
[17:59:16.409]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.409]                         if (muffled) 
[17:59:16.409]                           invokeRestart("muffleMessage")
[17:59:16.409]                       }
[17:59:16.409]                       else if (inherits(cond, "warning")) {
[17:59:16.409]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.409]                         if (muffled) 
[17:59:16.409]                           invokeRestart("muffleWarning")
[17:59:16.409]                       }
[17:59:16.409]                       else if (inherits(cond, "condition")) {
[17:59:16.409]                         if (!is.null(pattern)) {
[17:59:16.409]                           computeRestarts <- base::computeRestarts
[17:59:16.409]                           grepl <- base::grepl
[17:59:16.409]                           restarts <- computeRestarts(cond)
[17:59:16.409]                           for (restart in restarts) {
[17:59:16.409]                             name <- restart$name
[17:59:16.409]                             if (is.null(name)) 
[17:59:16.409]                               next
[17:59:16.409]                             if (!grepl(pattern, name)) 
[17:59:16.409]                               next
[17:59:16.409]                             invokeRestart(restart)
[17:59:16.409]                             muffled <- TRUE
[17:59:16.409]                             break
[17:59:16.409]                           }
[17:59:16.409]                         }
[17:59:16.409]                       }
[17:59:16.409]                       invisible(muffled)
[17:59:16.409]                     }
[17:59:16.409]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.409]                   }
[17:59:16.409]                 }
[17:59:16.409]                 else {
[17:59:16.409]                   if (TRUE) {
[17:59:16.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.409]                     {
[17:59:16.409]                       inherits <- base::inherits
[17:59:16.409]                       invokeRestart <- base::invokeRestart
[17:59:16.409]                       is.null <- base::is.null
[17:59:16.409]                       muffled <- FALSE
[17:59:16.409]                       if (inherits(cond, "message")) {
[17:59:16.409]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.409]                         if (muffled) 
[17:59:16.409]                           invokeRestart("muffleMessage")
[17:59:16.409]                       }
[17:59:16.409]                       else if (inherits(cond, "warning")) {
[17:59:16.409]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.409]                         if (muffled) 
[17:59:16.409]                           invokeRestart("muffleWarning")
[17:59:16.409]                       }
[17:59:16.409]                       else if (inherits(cond, "condition")) {
[17:59:16.409]                         if (!is.null(pattern)) {
[17:59:16.409]                           computeRestarts <- base::computeRestarts
[17:59:16.409]                           grepl <- base::grepl
[17:59:16.409]                           restarts <- computeRestarts(cond)
[17:59:16.409]                           for (restart in restarts) {
[17:59:16.409]                             name <- restart$name
[17:59:16.409]                             if (is.null(name)) 
[17:59:16.409]                               next
[17:59:16.409]                             if (!grepl(pattern, name)) 
[17:59:16.409]                               next
[17:59:16.409]                             invokeRestart(restart)
[17:59:16.409]                             muffled <- TRUE
[17:59:16.409]                             break
[17:59:16.409]                           }
[17:59:16.409]                         }
[17:59:16.409]                       }
[17:59:16.409]                       invisible(muffled)
[17:59:16.409]                     }
[17:59:16.409]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.409]                   }
[17:59:16.409]                 }
[17:59:16.409]             }
[17:59:16.409]         }))
[17:59:16.409]     }, error = function(ex) {
[17:59:16.409]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:16.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.409]                 ...future.rng), started = ...future.startTime, 
[17:59:16.409]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:16.409]             version = "1.8"), class = "FutureResult")
[17:59:16.409]     }, finally = {
[17:59:16.409]         if (!identical(...future.workdir, getwd())) 
[17:59:16.409]             setwd(...future.workdir)
[17:59:16.409]         {
[17:59:16.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:16.409]                 ...future.oldOptions$nwarnings <- NULL
[17:59:16.409]             }
[17:59:16.409]             base::options(...future.oldOptions)
[17:59:16.409]             if (.Platform$OS.type == "windows") {
[17:59:16.409]                 old_names <- names(...future.oldEnvVars)
[17:59:16.409]                 envs <- base::Sys.getenv()
[17:59:16.409]                 names <- names(envs)
[17:59:16.409]                 common <- intersect(names, old_names)
[17:59:16.409]                 added <- setdiff(names, old_names)
[17:59:16.409]                 removed <- setdiff(old_names, names)
[17:59:16.409]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:16.409]                   envs[common]]
[17:59:16.409]                 NAMES <- toupper(changed)
[17:59:16.409]                 args <- list()
[17:59:16.409]                 for (kk in seq_along(NAMES)) {
[17:59:16.409]                   name <- changed[[kk]]
[17:59:16.409]                   NAME <- NAMES[[kk]]
[17:59:16.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.409]                     next
[17:59:16.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.409]                 }
[17:59:16.409]                 NAMES <- toupper(added)
[17:59:16.409]                 for (kk in seq_along(NAMES)) {
[17:59:16.409]                   name <- added[[kk]]
[17:59:16.409]                   NAME <- NAMES[[kk]]
[17:59:16.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.409]                     next
[17:59:16.409]                   args[[name]] <- ""
[17:59:16.409]                 }
[17:59:16.409]                 NAMES <- toupper(removed)
[17:59:16.409]                 for (kk in seq_along(NAMES)) {
[17:59:16.409]                   name <- removed[[kk]]
[17:59:16.409]                   NAME <- NAMES[[kk]]
[17:59:16.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.409]                     next
[17:59:16.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.409]                 }
[17:59:16.409]                 if (length(args) > 0) 
[17:59:16.409]                   base::do.call(base::Sys.setenv, args = args)
[17:59:16.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:16.409]             }
[17:59:16.409]             else {
[17:59:16.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:16.409]             }
[17:59:16.409]             {
[17:59:16.409]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:16.409]                   0L) {
[17:59:16.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:16.409]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:16.409]                   base::options(opts)
[17:59:16.409]                 }
[17:59:16.409]                 {
[17:59:16.409]                   {
[17:59:16.409]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:16.409]                     NULL
[17:59:16.409]                   }
[17:59:16.409]                   options(future.plan = NULL)
[17:59:16.409]                   if (is.na(NA_character_)) 
[17:59:16.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:16.409]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:16.409]                     .init = FALSE)
[17:59:16.409]                 }
[17:59:16.409]             }
[17:59:16.409]         }
[17:59:16.409]     })
[17:59:16.409]     if (TRUE) {
[17:59:16.409]         base::sink(type = "output", split = FALSE)
[17:59:16.409]         if (TRUE) {
[17:59:16.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:16.409]         }
[17:59:16.409]         else {
[17:59:16.409]             ...future.result["stdout"] <- base::list(NULL)
[17:59:16.409]         }
[17:59:16.409]         base::close(...future.stdout)
[17:59:16.409]         ...future.stdout <- NULL
[17:59:16.409]     }
[17:59:16.409]     ...future.result$conditions <- ...future.conditions
[17:59:16.409]     ...future.result$finished <- base::Sys.time()
[17:59:16.409]     ...future.result
[17:59:16.409] }
[17:59:16.413] assign_globals() ...
[17:59:16.414] List of 5
[17:59:16.414]  $ future.call.arguments    : list()
[17:59:16.414]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.414]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:16.414]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:16.414]  $ ...future.elements_ii    :List of 1
[17:59:16.414]   ..$ : num [1:4] 2 4 6 8
[17:59:16.414]  $ ...future.seeds_ii       : NULL
[17:59:16.414]  $ ...future.globals.maxSize: num Inf
[17:59:16.414]  - attr(*, "resolved")= logi FALSE
[17:59:16.414]  - attr(*, "total_size")= num NA
[17:59:16.414]  - attr(*, "where")=List of 5
[17:59:16.414]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:16.414]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:16.414]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:16.414]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:16.414]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:16.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.414]  - attr(*, "already-done")= logi TRUE
[17:59:16.427] - copied ‘future.call.arguments’ to environment
[17:59:16.428] - copied ‘...future.FUN’ to environment
[17:59:16.428] - copied ‘...future.elements_ii’ to environment
[17:59:16.428] - copied ‘...future.seeds_ii’ to environment
[17:59:16.428] - copied ‘...future.globals.maxSize’ to environment
[17:59:16.429] assign_globals() ... done
[17:59:16.429] requestCore(): workers = 2
[17:59:16.439] MulticoreFuture started
[17:59:16.440] - Launch lazy future ... done
[17:59:16.440] run() for ‘MulticoreFuture’ ... done
[17:59:16.441] Created future:
[17:59:16.445] plan(): Setting new future strategy stack:
[17:59:16.446] List of future strategies:
[17:59:16.446] 1. sequential:
[17:59:16.446]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:16.446]    - tweaked: FALSE
[17:59:16.446]    - call: NULL
[17:59:16.448] plan(): nbrOfWorkers() = 1
[17:59:16.453] plan(): Setting new future strategy stack:
[17:59:16.453] List of future strategies:
[17:59:16.453] 1. multicore:
[17:59:16.453]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:16.453]    - tweaked: FALSE
[17:59:16.453]    - call: plan(strategy)
[17:59:16.441] MulticoreFuture:
[17:59:16.441] Label: ‘future_apply-2’
[17:59:16.441] Expression:
[17:59:16.441] {
[17:59:16.441]     do.call(function(...) {
[17:59:16.441]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.441]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.441]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.441]             on.exit(options(oopts), add = TRUE)
[17:59:16.441]         }
[17:59:16.441]         {
[17:59:16.441]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.441]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.441]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.441]             })
[17:59:16.441]         }
[17:59:16.441]     }, args = future.call.arguments)
[17:59:16.441] }
[17:59:16.441] Lazy evaluation: FALSE
[17:59:16.441] Asynchronous evaluation: TRUE
[17:59:16.441] Local evaluation: TRUE
[17:59:16.441] Environment: R_GlobalEnv
[17:59:16.441] Capture standard output: TRUE
[17:59:16.441] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:16.441] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:16.441] Packages: <none>
[17:59:16.441] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:16.441] Resolved: FALSE
[17:59:16.441] Value: <not collected>
[17:59:16.441] Conditions captured: <none>
[17:59:16.441] Early signaling: FALSE
[17:59:16.441] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:16.441] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:16.460] Chunk #2 of 2 ... DONE
[17:59:16.460] Launching 2 futures (chunks) ... DONE
[17:59:16.460] Resolving 2 futures (chunks) ...
[17:59:16.461] resolve() on list ...
[17:59:16.461]  recursive: 0
[17:59:16.461]  length: 2
[17:59:16.462] plan(): nbrOfWorkers() = 2
[17:59:16.461] 
[17:59:16.464] Future #1
[17:59:16.465] result() for MulticoreFuture ...
[17:59:16.469] result() for MulticoreFuture ...
[17:59:16.471] result() for MulticoreFuture ... done
[17:59:16.472] result() for MulticoreFuture ... done
[17:59:16.472] result() for MulticoreFuture ...
[17:59:16.472] result() for MulticoreFuture ... done
[17:59:16.475] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:16.475] - nx: 2
[17:59:16.475] - relay: TRUE
[17:59:16.476] - stdout: TRUE
[17:59:16.476] - signal: TRUE
[17:59:16.476] - resignal: FALSE
[17:59:16.477] - force: TRUE
[17:59:16.477] - relayed: [n=2] FALSE, FALSE
[17:59:16.477] - queued futures: [n=2] FALSE, FALSE
[17:59:16.477]  - until=1
[17:59:16.478]  - relaying element #1
[17:59:16.478] result() for MulticoreFuture ...
[17:59:16.478] result() for MulticoreFuture ... done
[17:59:16.479] result() for MulticoreFuture ...
[17:59:16.479] result() for MulticoreFuture ... done
[17:59:16.480] result() for MulticoreFuture ...
[17:59:16.480] result() for MulticoreFuture ... done
[17:59:16.480] result() for MulticoreFuture ...
[17:59:16.481] result() for MulticoreFuture ... done
[17:59:16.481] - relayed: [n=2] TRUE, FALSE
[17:59:16.481] - queued futures: [n=2] TRUE, FALSE
[17:59:16.482] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:16.482]  length: 1 (resolved future 1)
[17:59:16.489] Future #2
[17:59:16.490] result() for MulticoreFuture ...
[17:59:16.492] result() for MulticoreFuture ...
[17:59:16.495] result() for MulticoreFuture ... done
[17:59:16.496] result() for MulticoreFuture ... done
[17:59:16.496] result() for MulticoreFuture ...
[17:59:16.496] result() for MulticoreFuture ... done
[17:59:16.498] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:16.498] - nx: 2
[17:59:16.499] - relay: TRUE
[17:59:16.499] - stdout: TRUE
[17:59:16.499] - signal: TRUE
[17:59:16.500] - resignal: FALSE
[17:59:16.500] - force: TRUE
[17:59:16.500] - relayed: [n=2] TRUE, FALSE
[17:59:16.500] - queued futures: [n=2] TRUE, FALSE
[17:59:16.500]  - until=2
[17:59:16.501]  - relaying element #2
[17:59:16.501] result() for MulticoreFuture ...
[17:59:16.501] result() for MulticoreFuture ... done
[17:59:16.501] result() for MulticoreFuture ...
[17:59:16.502] result() for MulticoreFuture ... done
[17:59:16.502] result() for MulticoreFuture ...
[17:59:16.502] result() for MulticoreFuture ... done
[17:59:16.503] result() for MulticoreFuture ...
[17:59:16.503] result() for MulticoreFuture ... done
[17:59:16.503] - relayed: [n=2] TRUE, TRUE
[17:59:16.504] - queued futures: [n=2] TRUE, TRUE
[17:59:16.504] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:16.504]  length: 0 (resolved future 2)
[17:59:16.504] Relaying remaining futures
[17:59:16.505] signalConditionsASAP(NULL, pos=0) ...
[17:59:16.505] - nx: 2
[17:59:16.505] - relay: TRUE
[17:59:16.505] - stdout: TRUE
[17:59:16.505] - signal: TRUE
[17:59:16.506] - resignal: FALSE
[17:59:16.506] - force: TRUE
[17:59:16.506] - relayed: [n=2] TRUE, TRUE
[17:59:16.506] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:16.507] - relayed: [n=2] TRUE, TRUE
[17:59:16.507] - queued futures: [n=2] TRUE, TRUE
[17:59:16.507] signalConditionsASAP(NULL, pos=0) ... done
[17:59:16.507] resolve() on list ... DONE
[17:59:16.508] result() for MulticoreFuture ...
[17:59:16.508] result() for MulticoreFuture ... done
[17:59:16.508] result() for MulticoreFuture ...
[17:59:16.508] result() for MulticoreFuture ... done
[17:59:16.509] result() for MulticoreFuture ...
[17:59:16.509] result() for MulticoreFuture ... done
[17:59:16.509] result() for MulticoreFuture ...
[17:59:16.509] result() for MulticoreFuture ... done
[17:59:16.510]  - Number of value chunks collected: 2
[17:59:16.510] Resolving 2 futures (chunks) ... DONE
[17:59:16.510] Reducing values from 2 chunks ...
[17:59:16.510]  - Number of values collected after concatenation: 2
[17:59:16.510]  - Number of values expected: 2
[17:59:16.511] Reducing values from 2 chunks ... DONE
[17:59:16.511] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:59:16.512] getGlobalsAndPackagesXApply() ...
[17:59:16.512]  - future.globals: TRUE
[17:59:16.512] getGlobalsAndPackages() ...
[17:59:16.513] Searching for globals...
[17:59:16.592] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:59:16.592] Searching for globals ... DONE
[17:59:16.592] Resolving globals: FALSE
[17:59:16.596] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:59:16.597] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:59:16.597] - globals: [1] ‘FUN’
[17:59:16.597] 
[17:59:16.597] getGlobalsAndPackages() ... DONE
[17:59:16.598]  - globals found/used: [n=1] ‘FUN’
[17:59:16.598]  - needed namespaces: [n=0] 
[17:59:16.598] Finding globals ... DONE
[17:59:16.598]  - use_args: TRUE
[17:59:16.598]  - Getting '...' globals ...
[17:59:16.599] resolve() on list ...
[17:59:16.599]  recursive: 0
[17:59:16.599]  length: 1
[17:59:16.600]  elements: ‘...’
[17:59:16.600]  length: 0 (resolved future 1)
[17:59:16.600] resolve() on list ... DONE
[17:59:16.600]    - '...' content: [n=0] 
[17:59:16.600] List of 1
[17:59:16.600]  $ ...: list()
[17:59:16.600]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.600]  - attr(*, "where")=List of 1
[17:59:16.600]   ..$ ...:<environment: 0x560859b70ec8> 
[17:59:16.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.600]  - attr(*, "resolved")= logi TRUE
[17:59:16.600]  - attr(*, "total_size")= num NA
[17:59:16.606]  - Getting '...' globals ... DONE
[17:59:16.606] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:16.606] List of 2
[17:59:16.606]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:16.606]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:16.606]  $ ...          : list()
[17:59:16.606]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.606]  - attr(*, "where")=List of 2
[17:59:16.606]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:16.606]   ..$ ...          :<environment: 0x560859b70ec8> 
[17:59:16.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.606]  - attr(*, "resolved")= logi FALSE
[17:59:16.606]  - attr(*, "total_size")= num 354224
[17:59:16.612] Packages to be attached in all futures: [n=0] 
[17:59:16.612] getGlobalsAndPackagesXApply() ... DONE
[17:59:16.618] future_lapply() ...
[17:59:16.694] Number of chunks: 2
[17:59:16.695] getGlobalsAndPackagesXApply() ...
[17:59:16.695]  - future.globals: <name-value list> with names ‘list()’
[17:59:16.695]  - use_args: TRUE
[17:59:16.695] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:16.696] List of 2
[17:59:16.696]  $ ...          : list()
[17:59:16.696]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.696]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:16.696]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:16.696]  - attr(*, "where")=List of 2
[17:59:16.696]   ..$ ...          :<environment: 0x560859b70ec8> 
[17:59:16.696]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:16.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.696]  - attr(*, "resolved")= logi FALSE
[17:59:16.696]  - attr(*, "total_size")= num NA
[17:59:16.702] Packages to be attached in all futures: [n=0] 
[17:59:16.702] getGlobalsAndPackagesXApply() ... DONE
[17:59:16.703] Number of futures (= number of chunks): 2
[17:59:16.703] Launching 2 futures (chunks) ...
[17:59:16.703] Chunk #1 of 2 ...
[17:59:16.704]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:16.704]  - seeds: <none>
[17:59:16.704]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.704] getGlobalsAndPackages() ...
[17:59:16.704] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.705] Resolving globals: FALSE
[17:59:16.705] Tweak future expression to call with '...' arguments ...
[17:59:16.705] {
[17:59:16.705]     do.call(function(...) {
[17:59:16.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.705]             on.exit(options(oopts), add = TRUE)
[17:59:16.705]         }
[17:59:16.705]         {
[17:59:16.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.705]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.705]             })
[17:59:16.705]         }
[17:59:16.705]     }, args = future.call.arguments)
[17:59:16.705] }
[17:59:16.706] Tweak future expression to call with '...' arguments ... DONE
[17:59:16.706] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.707] 
[17:59:16.707] getGlobalsAndPackages() ... DONE
[17:59:16.707] run() for ‘Future’ ...
[17:59:16.708] - state: ‘created’
[17:59:16.708] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:16.714] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:16.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:16.715]   - Field: ‘label’
[17:59:16.715]   - Field: ‘local’
[17:59:16.715]   - Field: ‘owner’
[17:59:16.716]   - Field: ‘envir’
[17:59:16.716]   - Field: ‘workers’
[17:59:16.716]   - Field: ‘packages’
[17:59:16.716]   - Field: ‘gc’
[17:59:16.716]   - Field: ‘job’
[17:59:16.717]   - Field: ‘conditions’
[17:59:16.719]   - Field: ‘expr’
[17:59:16.719]   - Field: ‘uuid’
[17:59:16.720]   - Field: ‘seed’
[17:59:16.720]   - Field: ‘version’
[17:59:16.720]   - Field: ‘result’
[17:59:16.720]   - Field: ‘asynchronous’
[17:59:16.721]   - Field: ‘calls’
[17:59:16.721]   - Field: ‘globals’
[17:59:16.721]   - Field: ‘stdout’
[17:59:16.721]   - Field: ‘earlySignal’
[17:59:16.721]   - Field: ‘lazy’
[17:59:16.722]   - Field: ‘state’
[17:59:16.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:16.722] - Launch lazy future ...
[17:59:16.723] Packages needed by the future expression (n = 0): <none>
[17:59:16.723] Packages needed by future strategies (n = 0): <none>
[17:59:16.724] {
[17:59:16.724]     {
[17:59:16.724]         {
[17:59:16.724]             ...future.startTime <- base::Sys.time()
[17:59:16.724]             {
[17:59:16.724]                 {
[17:59:16.724]                   {
[17:59:16.724]                     {
[17:59:16.724]                       base::local({
[17:59:16.724]                         has_future <- base::requireNamespace("future", 
[17:59:16.724]                           quietly = TRUE)
[17:59:16.724]                         if (has_future) {
[17:59:16.724]                           ns <- base::getNamespace("future")
[17:59:16.724]                           version <- ns[[".package"]][["version"]]
[17:59:16.724]                           if (is.null(version)) 
[17:59:16.724]                             version <- utils::packageVersion("future")
[17:59:16.724]                         }
[17:59:16.724]                         else {
[17:59:16.724]                           version <- NULL
[17:59:16.724]                         }
[17:59:16.724]                         if (!has_future || version < "1.8.0") {
[17:59:16.724]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:16.724]                             "", base::R.version$version.string), 
[17:59:16.724]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:16.724]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:16.724]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:16.724]                               "release", "version")], collapse = " "), 
[17:59:16.724]                             hostname = base::Sys.info()[["nodename"]])
[17:59:16.724]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:16.724]                             info)
[17:59:16.724]                           info <- base::paste(info, collapse = "; ")
[17:59:16.724]                           if (!has_future) {
[17:59:16.724]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:16.724]                               info)
[17:59:16.724]                           }
[17:59:16.724]                           else {
[17:59:16.724]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:16.724]                               info, version)
[17:59:16.724]                           }
[17:59:16.724]                           base::stop(msg)
[17:59:16.724]                         }
[17:59:16.724]                       })
[17:59:16.724]                     }
[17:59:16.724]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:16.724]                     base::options(mc.cores = 1L)
[17:59:16.724]                   }
[17:59:16.724]                   ...future.strategy.old <- future::plan("list")
[17:59:16.724]                   options(future.plan = NULL)
[17:59:16.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:16.724]                 }
[17:59:16.724]                 ...future.workdir <- getwd()
[17:59:16.724]             }
[17:59:16.724]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:16.724]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:16.724]         }
[17:59:16.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:16.724]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:16.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:16.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:16.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:16.724]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:16.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:16.724]             base::names(...future.oldOptions))
[17:59:16.724]     }
[17:59:16.724]     if (FALSE) {
[17:59:16.724]     }
[17:59:16.724]     else {
[17:59:16.724]         if (TRUE) {
[17:59:16.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:16.724]                 open = "w")
[17:59:16.724]         }
[17:59:16.724]         else {
[17:59:16.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:16.724]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:16.724]         }
[17:59:16.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:16.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:16.724]             base::sink(type = "output", split = FALSE)
[17:59:16.724]             base::close(...future.stdout)
[17:59:16.724]         }, add = TRUE)
[17:59:16.724]     }
[17:59:16.724]     ...future.frame <- base::sys.nframe()
[17:59:16.724]     ...future.conditions <- base::list()
[17:59:16.724]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:16.724]     if (FALSE) {
[17:59:16.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:16.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:16.724]     }
[17:59:16.724]     ...future.result <- base::tryCatch({
[17:59:16.724]         base::withCallingHandlers({
[17:59:16.724]             ...future.value <- base::withVisible(base::local({
[17:59:16.724]                 withCallingHandlers({
[17:59:16.724]                   {
[17:59:16.724]                     do.call(function(...) {
[17:59:16.724]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.724]                       if (!identical(...future.globals.maxSize.org, 
[17:59:16.724]                         ...future.globals.maxSize)) {
[17:59:16.724]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.724]                         on.exit(options(oopts), add = TRUE)
[17:59:16.724]                       }
[17:59:16.724]                       {
[17:59:16.724]                         lapply(seq_along(...future.elements_ii), 
[17:59:16.724]                           FUN = function(jj) {
[17:59:16.724]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.724]                             ...future.FUN(...future.X_jj, ...)
[17:59:16.724]                           })
[17:59:16.724]                       }
[17:59:16.724]                     }, args = future.call.arguments)
[17:59:16.724]                   }
[17:59:16.724]                 }, immediateCondition = function(cond) {
[17:59:16.724]                   save_rds <- function (object, pathname, ...) 
[17:59:16.724]                   {
[17:59:16.724]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:16.724]                     if (file_test("-f", pathname_tmp)) {
[17:59:16.724]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.724]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:16.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.724]                         fi_tmp[["mtime"]])
[17:59:16.724]                     }
[17:59:16.724]                     tryCatch({
[17:59:16.724]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:16.724]                     }, error = function(ex) {
[17:59:16.724]                       msg <- conditionMessage(ex)
[17:59:16.724]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.724]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:16.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.724]                         fi_tmp[["mtime"]], msg)
[17:59:16.724]                       ex$message <- msg
[17:59:16.724]                       stop(ex)
[17:59:16.724]                     })
[17:59:16.724]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:16.724]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:16.724]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:16.724]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.724]                       fi <- file.info(pathname)
[17:59:16.724]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:16.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.724]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:16.724]                         fi[["size"]], fi[["mtime"]])
[17:59:16.724]                       stop(msg)
[17:59:16.724]                     }
[17:59:16.724]                     invisible(pathname)
[17:59:16.724]                   }
[17:59:16.724]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:16.724]                     rootPath = tempdir()) 
[17:59:16.724]                   {
[17:59:16.724]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:16.724]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:16.724]                       tmpdir = path, fileext = ".rds")
[17:59:16.724]                     save_rds(obj, file)
[17:59:16.724]                   }
[17:59:16.724]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:16.724]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.724]                   {
[17:59:16.724]                     inherits <- base::inherits
[17:59:16.724]                     invokeRestart <- base::invokeRestart
[17:59:16.724]                     is.null <- base::is.null
[17:59:16.724]                     muffled <- FALSE
[17:59:16.724]                     if (inherits(cond, "message")) {
[17:59:16.724]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:16.724]                       if (muffled) 
[17:59:16.724]                         invokeRestart("muffleMessage")
[17:59:16.724]                     }
[17:59:16.724]                     else if (inherits(cond, "warning")) {
[17:59:16.724]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:16.724]                       if (muffled) 
[17:59:16.724]                         invokeRestart("muffleWarning")
[17:59:16.724]                     }
[17:59:16.724]                     else if (inherits(cond, "condition")) {
[17:59:16.724]                       if (!is.null(pattern)) {
[17:59:16.724]                         computeRestarts <- base::computeRestarts
[17:59:16.724]                         grepl <- base::grepl
[17:59:16.724]                         restarts <- computeRestarts(cond)
[17:59:16.724]                         for (restart in restarts) {
[17:59:16.724]                           name <- restart$name
[17:59:16.724]                           if (is.null(name)) 
[17:59:16.724]                             next
[17:59:16.724]                           if (!grepl(pattern, name)) 
[17:59:16.724]                             next
[17:59:16.724]                           invokeRestart(restart)
[17:59:16.724]                           muffled <- TRUE
[17:59:16.724]                           break
[17:59:16.724]                         }
[17:59:16.724]                       }
[17:59:16.724]                     }
[17:59:16.724]                     invisible(muffled)
[17:59:16.724]                   }
[17:59:16.724]                   muffleCondition(cond)
[17:59:16.724]                 })
[17:59:16.724]             }))
[17:59:16.724]             future::FutureResult(value = ...future.value$value, 
[17:59:16.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.724]                   ...future.rng), globalenv = if (FALSE) 
[17:59:16.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:16.724]                     ...future.globalenv.names))
[17:59:16.724]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:16.724]         }, condition = base::local({
[17:59:16.724]             c <- base::c
[17:59:16.724]             inherits <- base::inherits
[17:59:16.724]             invokeRestart <- base::invokeRestart
[17:59:16.724]             length <- base::length
[17:59:16.724]             list <- base::list
[17:59:16.724]             seq.int <- base::seq.int
[17:59:16.724]             signalCondition <- base::signalCondition
[17:59:16.724]             sys.calls <- base::sys.calls
[17:59:16.724]             `[[` <- base::`[[`
[17:59:16.724]             `+` <- base::`+`
[17:59:16.724]             `<<-` <- base::`<<-`
[17:59:16.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:16.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:16.724]                   3L)]
[17:59:16.724]             }
[17:59:16.724]             function(cond) {
[17:59:16.724]                 is_error <- inherits(cond, "error")
[17:59:16.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:16.724]                   NULL)
[17:59:16.724]                 if (is_error) {
[17:59:16.724]                   sessionInformation <- function() {
[17:59:16.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:16.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:16.724]                       search = base::search(), system = base::Sys.info())
[17:59:16.724]                   }
[17:59:16.724]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:16.724]                     cond$call), session = sessionInformation(), 
[17:59:16.724]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:16.724]                   signalCondition(cond)
[17:59:16.724]                 }
[17:59:16.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:16.724]                 "immediateCondition"))) {
[17:59:16.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:16.724]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:16.724]                   if (TRUE && !signal) {
[17:59:16.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.724]                     {
[17:59:16.724]                       inherits <- base::inherits
[17:59:16.724]                       invokeRestart <- base::invokeRestart
[17:59:16.724]                       is.null <- base::is.null
[17:59:16.724]                       muffled <- FALSE
[17:59:16.724]                       if (inherits(cond, "message")) {
[17:59:16.724]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.724]                         if (muffled) 
[17:59:16.724]                           invokeRestart("muffleMessage")
[17:59:16.724]                       }
[17:59:16.724]                       else if (inherits(cond, "warning")) {
[17:59:16.724]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.724]                         if (muffled) 
[17:59:16.724]                           invokeRestart("muffleWarning")
[17:59:16.724]                       }
[17:59:16.724]                       else if (inherits(cond, "condition")) {
[17:59:16.724]                         if (!is.null(pattern)) {
[17:59:16.724]                           computeRestarts <- base::computeRestarts
[17:59:16.724]                           grepl <- base::grepl
[17:59:16.724]                           restarts <- computeRestarts(cond)
[17:59:16.724]                           for (restart in restarts) {
[17:59:16.724]                             name <- restart$name
[17:59:16.724]                             if (is.null(name)) 
[17:59:16.724]                               next
[17:59:16.724]                             if (!grepl(pattern, name)) 
[17:59:16.724]                               next
[17:59:16.724]                             invokeRestart(restart)
[17:59:16.724]                             muffled <- TRUE
[17:59:16.724]                             break
[17:59:16.724]                           }
[17:59:16.724]                         }
[17:59:16.724]                       }
[17:59:16.724]                       invisible(muffled)
[17:59:16.724]                     }
[17:59:16.724]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.724]                   }
[17:59:16.724]                 }
[17:59:16.724]                 else {
[17:59:16.724]                   if (TRUE) {
[17:59:16.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.724]                     {
[17:59:16.724]                       inherits <- base::inherits
[17:59:16.724]                       invokeRestart <- base::invokeRestart
[17:59:16.724]                       is.null <- base::is.null
[17:59:16.724]                       muffled <- FALSE
[17:59:16.724]                       if (inherits(cond, "message")) {
[17:59:16.724]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.724]                         if (muffled) 
[17:59:16.724]                           invokeRestart("muffleMessage")
[17:59:16.724]                       }
[17:59:16.724]                       else if (inherits(cond, "warning")) {
[17:59:16.724]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.724]                         if (muffled) 
[17:59:16.724]                           invokeRestart("muffleWarning")
[17:59:16.724]                       }
[17:59:16.724]                       else if (inherits(cond, "condition")) {
[17:59:16.724]                         if (!is.null(pattern)) {
[17:59:16.724]                           computeRestarts <- base::computeRestarts
[17:59:16.724]                           grepl <- base::grepl
[17:59:16.724]                           restarts <- computeRestarts(cond)
[17:59:16.724]                           for (restart in restarts) {
[17:59:16.724]                             name <- restart$name
[17:59:16.724]                             if (is.null(name)) 
[17:59:16.724]                               next
[17:59:16.724]                             if (!grepl(pattern, name)) 
[17:59:16.724]                               next
[17:59:16.724]                             invokeRestart(restart)
[17:59:16.724]                             muffled <- TRUE
[17:59:16.724]                             break
[17:59:16.724]                           }
[17:59:16.724]                         }
[17:59:16.724]                       }
[17:59:16.724]                       invisible(muffled)
[17:59:16.724]                     }
[17:59:16.724]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.724]                   }
[17:59:16.724]                 }
[17:59:16.724]             }
[17:59:16.724]         }))
[17:59:16.724]     }, error = function(ex) {
[17:59:16.724]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:16.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.724]                 ...future.rng), started = ...future.startTime, 
[17:59:16.724]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:16.724]             version = "1.8"), class = "FutureResult")
[17:59:16.724]     }, finally = {
[17:59:16.724]         if (!identical(...future.workdir, getwd())) 
[17:59:16.724]             setwd(...future.workdir)
[17:59:16.724]         {
[17:59:16.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:16.724]                 ...future.oldOptions$nwarnings <- NULL
[17:59:16.724]             }
[17:59:16.724]             base::options(...future.oldOptions)
[17:59:16.724]             if (.Platform$OS.type == "windows") {
[17:59:16.724]                 old_names <- names(...future.oldEnvVars)
[17:59:16.724]                 envs <- base::Sys.getenv()
[17:59:16.724]                 names <- names(envs)
[17:59:16.724]                 common <- intersect(names, old_names)
[17:59:16.724]                 added <- setdiff(names, old_names)
[17:59:16.724]                 removed <- setdiff(old_names, names)
[17:59:16.724]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:16.724]                   envs[common]]
[17:59:16.724]                 NAMES <- toupper(changed)
[17:59:16.724]                 args <- list()
[17:59:16.724]                 for (kk in seq_along(NAMES)) {
[17:59:16.724]                   name <- changed[[kk]]
[17:59:16.724]                   NAME <- NAMES[[kk]]
[17:59:16.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.724]                     next
[17:59:16.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.724]                 }
[17:59:16.724]                 NAMES <- toupper(added)
[17:59:16.724]                 for (kk in seq_along(NAMES)) {
[17:59:16.724]                   name <- added[[kk]]
[17:59:16.724]                   NAME <- NAMES[[kk]]
[17:59:16.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.724]                     next
[17:59:16.724]                   args[[name]] <- ""
[17:59:16.724]                 }
[17:59:16.724]                 NAMES <- toupper(removed)
[17:59:16.724]                 for (kk in seq_along(NAMES)) {
[17:59:16.724]                   name <- removed[[kk]]
[17:59:16.724]                   NAME <- NAMES[[kk]]
[17:59:16.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.724]                     next
[17:59:16.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.724]                 }
[17:59:16.724]                 if (length(args) > 0) 
[17:59:16.724]                   base::do.call(base::Sys.setenv, args = args)
[17:59:16.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:16.724]             }
[17:59:16.724]             else {
[17:59:16.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:16.724]             }
[17:59:16.724]             {
[17:59:16.724]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:16.724]                   0L) {
[17:59:16.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:16.724]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:16.724]                   base::options(opts)
[17:59:16.724]                 }
[17:59:16.724]                 {
[17:59:16.724]                   {
[17:59:16.724]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:16.724]                     NULL
[17:59:16.724]                   }
[17:59:16.724]                   options(future.plan = NULL)
[17:59:16.724]                   if (is.na(NA_character_)) 
[17:59:16.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:16.724]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:16.724]                     .init = FALSE)
[17:59:16.724]                 }
[17:59:16.724]             }
[17:59:16.724]         }
[17:59:16.724]     })
[17:59:16.724]     if (TRUE) {
[17:59:16.724]         base::sink(type = "output", split = FALSE)
[17:59:16.724]         if (TRUE) {
[17:59:16.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:16.724]         }
[17:59:16.724]         else {
[17:59:16.724]             ...future.result["stdout"] <- base::list(NULL)
[17:59:16.724]         }
[17:59:16.724]         base::close(...future.stdout)
[17:59:16.724]         ...future.stdout <- NULL
[17:59:16.724]     }
[17:59:16.724]     ...future.result$conditions <- ...future.conditions
[17:59:16.724]     ...future.result$finished <- base::Sys.time()
[17:59:16.724]     ...future.result
[17:59:16.724] }
[17:59:16.728] assign_globals() ...
[17:59:16.728] List of 5
[17:59:16.728]  $ future.call.arguments    : list()
[17:59:16.728]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.728]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:16.728]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:16.728]  $ ...future.elements_ii    :List of 1
[17:59:16.728]   ..$ : num [1:4] 1 3 1 7
[17:59:16.728]  $ ...future.seeds_ii       : NULL
[17:59:16.728]  $ ...future.globals.maxSize: num Inf
[17:59:16.728]  - attr(*, "resolved")= logi FALSE
[17:59:16.728]  - attr(*, "total_size")= num NA
[17:59:16.728]  - attr(*, "where")=List of 5
[17:59:16.728]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:16.728]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:16.728]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:16.728]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:16.728]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:16.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.728]  - attr(*, "already-done")= logi TRUE
[17:59:16.738] - copied ‘future.call.arguments’ to environment
[17:59:16.738] - copied ‘...future.FUN’ to environment
[17:59:16.738] - copied ‘...future.elements_ii’ to environment
[17:59:16.738] - copied ‘...future.seeds_ii’ to environment
[17:59:16.738] - copied ‘...future.globals.maxSize’ to environment
[17:59:16.739] assign_globals() ... done
[17:59:16.739] requestCore(): workers = 2
[17:59:16.742] MulticoreFuture started
[17:59:16.743] - Launch lazy future ... done
[17:59:16.743] run() for ‘MulticoreFuture’ ... done
[17:59:16.744] Created future:
[17:59:16.744] plan(): Setting new future strategy stack:
[17:59:16.745] List of future strategies:
[17:59:16.745] 1. sequential:
[17:59:16.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:16.745]    - tweaked: FALSE
[17:59:16.745]    - call: NULL
[17:59:16.747] plan(): nbrOfWorkers() = 1
[17:59:16.752] plan(): Setting new future strategy stack:
[17:59:16.753] List of future strategies:
[17:59:16.753] 1. multicore:
[17:59:16.753]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:16.753]    - tweaked: FALSE
[17:59:16.753]    - call: plan(strategy)
[17:59:16.744] MulticoreFuture:
[17:59:16.744] Label: ‘future_apply-1’
[17:59:16.744] Expression:
[17:59:16.744] {
[17:59:16.744]     do.call(function(...) {
[17:59:16.744]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.744]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.744]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.744]             on.exit(options(oopts), add = TRUE)
[17:59:16.744]         }
[17:59:16.744]         {
[17:59:16.744]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.744]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.744]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.744]             })
[17:59:16.744]         }
[17:59:16.744]     }, args = future.call.arguments)
[17:59:16.744] }
[17:59:16.744] Lazy evaluation: FALSE
[17:59:16.744] Asynchronous evaluation: TRUE
[17:59:16.744] Local evaluation: TRUE
[17:59:16.744] Environment: R_GlobalEnv
[17:59:16.744] Capture standard output: TRUE
[17:59:16.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:16.744] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:16.744] Packages: <none>
[17:59:16.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:16.744] Resolved: FALSE
[17:59:16.744] Value: <not collected>
[17:59:16.744] Conditions captured: <none>
[17:59:16.744] Early signaling: FALSE
[17:59:16.744] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:16.744] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:16.760] Chunk #1 of 2 ... DONE
[17:59:16.760] Chunk #2 of 2 ...
[17:59:16.761]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:16.761]  - seeds: <none>
[17:59:16.762]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.762] getGlobalsAndPackages() ...
[17:59:16.762] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.763] plan(): nbrOfWorkers() = 2
[17:59:16.763] Resolving globals: FALSE
[17:59:16.763] Tweak future expression to call with '...' arguments ...
[17:59:16.764] {
[17:59:16.764]     do.call(function(...) {
[17:59:16.764]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.764]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.764]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.764]             on.exit(options(oopts), add = TRUE)
[17:59:16.764]         }
[17:59:16.764]         {
[17:59:16.764]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.764]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.764]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.764]             })
[17:59:16.764]         }
[17:59:16.764]     }, args = future.call.arguments)
[17:59:16.764] }
[17:59:16.765] Tweak future expression to call with '...' arguments ... DONE
[17:59:16.766] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.766] 
[17:59:16.767] getGlobalsAndPackages() ... DONE
[17:59:16.767] run() for ‘Future’ ...
[17:59:16.768] - state: ‘created’
[17:59:16.768] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:16.776] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:16.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:16.777]   - Field: ‘label’
[17:59:16.778]   - Field: ‘local’
[17:59:16.778]   - Field: ‘owner’
[17:59:16.778]   - Field: ‘envir’
[17:59:16.779]   - Field: ‘workers’
[17:59:16.779]   - Field: ‘packages’
[17:59:16.779]   - Field: ‘gc’
[17:59:16.780]   - Field: ‘job’
[17:59:16.780]   - Field: ‘conditions’
[17:59:16.780]   - Field: ‘expr’
[17:59:16.781]   - Field: ‘uuid’
[17:59:16.781]   - Field: ‘seed’
[17:59:16.781]   - Field: ‘version’
[17:59:16.782]   - Field: ‘result’
[17:59:16.782]   - Field: ‘asynchronous’
[17:59:16.782]   - Field: ‘calls’
[17:59:16.783]   - Field: ‘globals’
[17:59:16.783]   - Field: ‘stdout’
[17:59:16.783]   - Field: ‘earlySignal’
[17:59:16.784]   - Field: ‘lazy’
[17:59:16.784]   - Field: ‘state’
[17:59:16.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:16.785] - Launch lazy future ...
[17:59:16.785] Packages needed by the future expression (n = 0): <none>
[17:59:16.786] Packages needed by future strategies (n = 0): <none>
[17:59:16.787] {
[17:59:16.787]     {
[17:59:16.787]         {
[17:59:16.787]             ...future.startTime <- base::Sys.time()
[17:59:16.787]             {
[17:59:16.787]                 {
[17:59:16.787]                   {
[17:59:16.787]                     {
[17:59:16.787]                       base::local({
[17:59:16.787]                         has_future <- base::requireNamespace("future", 
[17:59:16.787]                           quietly = TRUE)
[17:59:16.787]                         if (has_future) {
[17:59:16.787]                           ns <- base::getNamespace("future")
[17:59:16.787]                           version <- ns[[".package"]][["version"]]
[17:59:16.787]                           if (is.null(version)) 
[17:59:16.787]                             version <- utils::packageVersion("future")
[17:59:16.787]                         }
[17:59:16.787]                         else {
[17:59:16.787]                           version <- NULL
[17:59:16.787]                         }
[17:59:16.787]                         if (!has_future || version < "1.8.0") {
[17:59:16.787]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:16.787]                             "", base::R.version$version.string), 
[17:59:16.787]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:16.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:16.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:16.787]                               "release", "version")], collapse = " "), 
[17:59:16.787]                             hostname = base::Sys.info()[["nodename"]])
[17:59:16.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:16.787]                             info)
[17:59:16.787]                           info <- base::paste(info, collapse = "; ")
[17:59:16.787]                           if (!has_future) {
[17:59:16.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:16.787]                               info)
[17:59:16.787]                           }
[17:59:16.787]                           else {
[17:59:16.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:16.787]                               info, version)
[17:59:16.787]                           }
[17:59:16.787]                           base::stop(msg)
[17:59:16.787]                         }
[17:59:16.787]                       })
[17:59:16.787]                     }
[17:59:16.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:16.787]                     base::options(mc.cores = 1L)
[17:59:16.787]                   }
[17:59:16.787]                   ...future.strategy.old <- future::plan("list")
[17:59:16.787]                   options(future.plan = NULL)
[17:59:16.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:16.787]                 }
[17:59:16.787]                 ...future.workdir <- getwd()
[17:59:16.787]             }
[17:59:16.787]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:16.787]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:16.787]         }
[17:59:16.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:16.787]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:16.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:16.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:16.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:16.787]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:16.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:16.787]             base::names(...future.oldOptions))
[17:59:16.787]     }
[17:59:16.787]     if (FALSE) {
[17:59:16.787]     }
[17:59:16.787]     else {
[17:59:16.787]         if (TRUE) {
[17:59:16.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:16.787]                 open = "w")
[17:59:16.787]         }
[17:59:16.787]         else {
[17:59:16.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:16.787]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:16.787]         }
[17:59:16.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:16.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:16.787]             base::sink(type = "output", split = FALSE)
[17:59:16.787]             base::close(...future.stdout)
[17:59:16.787]         }, add = TRUE)
[17:59:16.787]     }
[17:59:16.787]     ...future.frame <- base::sys.nframe()
[17:59:16.787]     ...future.conditions <- base::list()
[17:59:16.787]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:16.787]     if (FALSE) {
[17:59:16.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:16.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:16.787]     }
[17:59:16.787]     ...future.result <- base::tryCatch({
[17:59:16.787]         base::withCallingHandlers({
[17:59:16.787]             ...future.value <- base::withVisible(base::local({
[17:59:16.787]                 withCallingHandlers({
[17:59:16.787]                   {
[17:59:16.787]                     do.call(function(...) {
[17:59:16.787]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.787]                       if (!identical(...future.globals.maxSize.org, 
[17:59:16.787]                         ...future.globals.maxSize)) {
[17:59:16.787]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.787]                         on.exit(options(oopts), add = TRUE)
[17:59:16.787]                       }
[17:59:16.787]                       {
[17:59:16.787]                         lapply(seq_along(...future.elements_ii), 
[17:59:16.787]                           FUN = function(jj) {
[17:59:16.787]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.787]                             ...future.FUN(...future.X_jj, ...)
[17:59:16.787]                           })
[17:59:16.787]                       }
[17:59:16.787]                     }, args = future.call.arguments)
[17:59:16.787]                   }
[17:59:16.787]                 }, immediateCondition = function(cond) {
[17:59:16.787]                   save_rds <- function (object, pathname, ...) 
[17:59:16.787]                   {
[17:59:16.787]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:16.787]                     if (file_test("-f", pathname_tmp)) {
[17:59:16.787]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.787]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:16.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.787]                         fi_tmp[["mtime"]])
[17:59:16.787]                     }
[17:59:16.787]                     tryCatch({
[17:59:16.787]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:16.787]                     }, error = function(ex) {
[17:59:16.787]                       msg <- conditionMessage(ex)
[17:59:16.787]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.787]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:16.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.787]                         fi_tmp[["mtime"]], msg)
[17:59:16.787]                       ex$message <- msg
[17:59:16.787]                       stop(ex)
[17:59:16.787]                     })
[17:59:16.787]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:16.787]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:16.787]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:16.787]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.787]                       fi <- file.info(pathname)
[17:59:16.787]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:16.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.787]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:16.787]                         fi[["size"]], fi[["mtime"]])
[17:59:16.787]                       stop(msg)
[17:59:16.787]                     }
[17:59:16.787]                     invisible(pathname)
[17:59:16.787]                   }
[17:59:16.787]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:16.787]                     rootPath = tempdir()) 
[17:59:16.787]                   {
[17:59:16.787]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:16.787]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:16.787]                       tmpdir = path, fileext = ".rds")
[17:59:16.787]                     save_rds(obj, file)
[17:59:16.787]                   }
[17:59:16.787]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:16.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.787]                   {
[17:59:16.787]                     inherits <- base::inherits
[17:59:16.787]                     invokeRestart <- base::invokeRestart
[17:59:16.787]                     is.null <- base::is.null
[17:59:16.787]                     muffled <- FALSE
[17:59:16.787]                     if (inherits(cond, "message")) {
[17:59:16.787]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:16.787]                       if (muffled) 
[17:59:16.787]                         invokeRestart("muffleMessage")
[17:59:16.787]                     }
[17:59:16.787]                     else if (inherits(cond, "warning")) {
[17:59:16.787]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:16.787]                       if (muffled) 
[17:59:16.787]                         invokeRestart("muffleWarning")
[17:59:16.787]                     }
[17:59:16.787]                     else if (inherits(cond, "condition")) {
[17:59:16.787]                       if (!is.null(pattern)) {
[17:59:16.787]                         computeRestarts <- base::computeRestarts
[17:59:16.787]                         grepl <- base::grepl
[17:59:16.787]                         restarts <- computeRestarts(cond)
[17:59:16.787]                         for (restart in restarts) {
[17:59:16.787]                           name <- restart$name
[17:59:16.787]                           if (is.null(name)) 
[17:59:16.787]                             next
[17:59:16.787]                           if (!grepl(pattern, name)) 
[17:59:16.787]                             next
[17:59:16.787]                           invokeRestart(restart)
[17:59:16.787]                           muffled <- TRUE
[17:59:16.787]                           break
[17:59:16.787]                         }
[17:59:16.787]                       }
[17:59:16.787]                     }
[17:59:16.787]                     invisible(muffled)
[17:59:16.787]                   }
[17:59:16.787]                   muffleCondition(cond)
[17:59:16.787]                 })
[17:59:16.787]             }))
[17:59:16.787]             future::FutureResult(value = ...future.value$value, 
[17:59:16.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.787]                   ...future.rng), globalenv = if (FALSE) 
[17:59:16.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:16.787]                     ...future.globalenv.names))
[17:59:16.787]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:16.787]         }, condition = base::local({
[17:59:16.787]             c <- base::c
[17:59:16.787]             inherits <- base::inherits
[17:59:16.787]             invokeRestart <- base::invokeRestart
[17:59:16.787]             length <- base::length
[17:59:16.787]             list <- base::list
[17:59:16.787]             seq.int <- base::seq.int
[17:59:16.787]             signalCondition <- base::signalCondition
[17:59:16.787]             sys.calls <- base::sys.calls
[17:59:16.787]             `[[` <- base::`[[`
[17:59:16.787]             `+` <- base::`+`
[17:59:16.787]             `<<-` <- base::`<<-`
[17:59:16.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:16.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:16.787]                   3L)]
[17:59:16.787]             }
[17:59:16.787]             function(cond) {
[17:59:16.787]                 is_error <- inherits(cond, "error")
[17:59:16.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:16.787]                   NULL)
[17:59:16.787]                 if (is_error) {
[17:59:16.787]                   sessionInformation <- function() {
[17:59:16.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:16.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:16.787]                       search = base::search(), system = base::Sys.info())
[17:59:16.787]                   }
[17:59:16.787]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:16.787]                     cond$call), session = sessionInformation(), 
[17:59:16.787]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:16.787]                   signalCondition(cond)
[17:59:16.787]                 }
[17:59:16.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:16.787]                 "immediateCondition"))) {
[17:59:16.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:16.787]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:16.787]                   if (TRUE && !signal) {
[17:59:16.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.787]                     {
[17:59:16.787]                       inherits <- base::inherits
[17:59:16.787]                       invokeRestart <- base::invokeRestart
[17:59:16.787]                       is.null <- base::is.null
[17:59:16.787]                       muffled <- FALSE
[17:59:16.787]                       if (inherits(cond, "message")) {
[17:59:16.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.787]                         if (muffled) 
[17:59:16.787]                           invokeRestart("muffleMessage")
[17:59:16.787]                       }
[17:59:16.787]                       else if (inherits(cond, "warning")) {
[17:59:16.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.787]                         if (muffled) 
[17:59:16.787]                           invokeRestart("muffleWarning")
[17:59:16.787]                       }
[17:59:16.787]                       else if (inherits(cond, "condition")) {
[17:59:16.787]                         if (!is.null(pattern)) {
[17:59:16.787]                           computeRestarts <- base::computeRestarts
[17:59:16.787]                           grepl <- base::grepl
[17:59:16.787]                           restarts <- computeRestarts(cond)
[17:59:16.787]                           for (restart in restarts) {
[17:59:16.787]                             name <- restart$name
[17:59:16.787]                             if (is.null(name)) 
[17:59:16.787]                               next
[17:59:16.787]                             if (!grepl(pattern, name)) 
[17:59:16.787]                               next
[17:59:16.787]                             invokeRestart(restart)
[17:59:16.787]                             muffled <- TRUE
[17:59:16.787]                             break
[17:59:16.787]                           }
[17:59:16.787]                         }
[17:59:16.787]                       }
[17:59:16.787]                       invisible(muffled)
[17:59:16.787]                     }
[17:59:16.787]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.787]                   }
[17:59:16.787]                 }
[17:59:16.787]                 else {
[17:59:16.787]                   if (TRUE) {
[17:59:16.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.787]                     {
[17:59:16.787]                       inherits <- base::inherits
[17:59:16.787]                       invokeRestart <- base::invokeRestart
[17:59:16.787]                       is.null <- base::is.null
[17:59:16.787]                       muffled <- FALSE
[17:59:16.787]                       if (inherits(cond, "message")) {
[17:59:16.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.787]                         if (muffled) 
[17:59:16.787]                           invokeRestart("muffleMessage")
[17:59:16.787]                       }
[17:59:16.787]                       else if (inherits(cond, "warning")) {
[17:59:16.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.787]                         if (muffled) 
[17:59:16.787]                           invokeRestart("muffleWarning")
[17:59:16.787]                       }
[17:59:16.787]                       else if (inherits(cond, "condition")) {
[17:59:16.787]                         if (!is.null(pattern)) {
[17:59:16.787]                           computeRestarts <- base::computeRestarts
[17:59:16.787]                           grepl <- base::grepl
[17:59:16.787]                           restarts <- computeRestarts(cond)
[17:59:16.787]                           for (restart in restarts) {
[17:59:16.787]                             name <- restart$name
[17:59:16.787]                             if (is.null(name)) 
[17:59:16.787]                               next
[17:59:16.787]                             if (!grepl(pattern, name)) 
[17:59:16.787]                               next
[17:59:16.787]                             invokeRestart(restart)
[17:59:16.787]                             muffled <- TRUE
[17:59:16.787]                             break
[17:59:16.787]                           }
[17:59:16.787]                         }
[17:59:16.787]                       }
[17:59:16.787]                       invisible(muffled)
[17:59:16.787]                     }
[17:59:16.787]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.787]                   }
[17:59:16.787]                 }
[17:59:16.787]             }
[17:59:16.787]         }))
[17:59:16.787]     }, error = function(ex) {
[17:59:16.787]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:16.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.787]                 ...future.rng), started = ...future.startTime, 
[17:59:16.787]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:16.787]             version = "1.8"), class = "FutureResult")
[17:59:16.787]     }, finally = {
[17:59:16.787]         if (!identical(...future.workdir, getwd())) 
[17:59:16.787]             setwd(...future.workdir)
[17:59:16.787]         {
[17:59:16.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:16.787]                 ...future.oldOptions$nwarnings <- NULL
[17:59:16.787]             }
[17:59:16.787]             base::options(...future.oldOptions)
[17:59:16.787]             if (.Platform$OS.type == "windows") {
[17:59:16.787]                 old_names <- names(...future.oldEnvVars)
[17:59:16.787]                 envs <- base::Sys.getenv()
[17:59:16.787]                 names <- names(envs)
[17:59:16.787]                 common <- intersect(names, old_names)
[17:59:16.787]                 added <- setdiff(names, old_names)
[17:59:16.787]                 removed <- setdiff(old_names, names)
[17:59:16.787]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:16.787]                   envs[common]]
[17:59:16.787]                 NAMES <- toupper(changed)
[17:59:16.787]                 args <- list()
[17:59:16.787]                 for (kk in seq_along(NAMES)) {
[17:59:16.787]                   name <- changed[[kk]]
[17:59:16.787]                   NAME <- NAMES[[kk]]
[17:59:16.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.787]                     next
[17:59:16.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.787]                 }
[17:59:16.787]                 NAMES <- toupper(added)
[17:59:16.787]                 for (kk in seq_along(NAMES)) {
[17:59:16.787]                   name <- added[[kk]]
[17:59:16.787]                   NAME <- NAMES[[kk]]
[17:59:16.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.787]                     next
[17:59:16.787]                   args[[name]] <- ""
[17:59:16.787]                 }
[17:59:16.787]                 NAMES <- toupper(removed)
[17:59:16.787]                 for (kk in seq_along(NAMES)) {
[17:59:16.787]                   name <- removed[[kk]]
[17:59:16.787]                   NAME <- NAMES[[kk]]
[17:59:16.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.787]                     next
[17:59:16.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.787]                 }
[17:59:16.787]                 if (length(args) > 0) 
[17:59:16.787]                   base::do.call(base::Sys.setenv, args = args)
[17:59:16.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:16.787]             }
[17:59:16.787]             else {
[17:59:16.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:16.787]             }
[17:59:16.787]             {
[17:59:16.787]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:16.787]                   0L) {
[17:59:16.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:16.787]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:16.787]                   base::options(opts)
[17:59:16.787]                 }
[17:59:16.787]                 {
[17:59:16.787]                   {
[17:59:16.787]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:16.787]                     NULL
[17:59:16.787]                   }
[17:59:16.787]                   options(future.plan = NULL)
[17:59:16.787]                   if (is.na(NA_character_)) 
[17:59:16.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:16.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:16.787]                     .init = FALSE)
[17:59:16.787]                 }
[17:59:16.787]             }
[17:59:16.787]         }
[17:59:16.787]     })
[17:59:16.787]     if (TRUE) {
[17:59:16.787]         base::sink(type = "output", split = FALSE)
[17:59:16.787]         if (TRUE) {
[17:59:16.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:16.787]         }
[17:59:16.787]         else {
[17:59:16.787]             ...future.result["stdout"] <- base::list(NULL)
[17:59:16.787]         }
[17:59:16.787]         base::close(...future.stdout)
[17:59:16.787]         ...future.stdout <- NULL
[17:59:16.787]     }
[17:59:16.787]     ...future.result$conditions <- ...future.conditions
[17:59:16.787]     ...future.result$finished <- base::Sys.time()
[17:59:16.787]     ...future.result
[17:59:16.787] }
[17:59:16.794] assign_globals() ...
[17:59:16.794] List of 5
[17:59:16.794]  $ future.call.arguments    : list()
[17:59:16.794]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.794]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:16.794]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:16.794]  $ ...future.elements_ii    :List of 1
[17:59:16.794]   ..$ : num [1:4] 2 4 6 8
[17:59:16.794]  $ ...future.seeds_ii       : NULL
[17:59:16.794]  $ ...future.globals.maxSize: num Inf
[17:59:16.794]  - attr(*, "resolved")= logi FALSE
[17:59:16.794]  - attr(*, "total_size")= num NA
[17:59:16.794]  - attr(*, "where")=List of 5
[17:59:16.794]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:16.794]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:16.794]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:16.794]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:16.794]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:16.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.794]  - attr(*, "already-done")= logi TRUE
[17:59:16.815] - copied ‘future.call.arguments’ to environment
[17:59:16.816] - copied ‘...future.FUN’ to environment
[17:59:16.816] - copied ‘...future.elements_ii’ to environment
[17:59:16.817] - copied ‘...future.seeds_ii’ to environment
[17:59:16.817] - copied ‘...future.globals.maxSize’ to environment
[17:59:16.818] assign_globals() ... done
[17:59:16.818] requestCore(): workers = 2
[17:59:16.822] MulticoreFuture started
[17:59:16.823] - Launch lazy future ... done
[17:59:16.823] run() for ‘MulticoreFuture’ ... done
[17:59:16.824] plan(): Setting new future strategy stack:
[17:59:16.824] Created future:
[17:59:16.825] List of future strategies:
[17:59:16.825] 1. sequential:
[17:59:16.825]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:16.825]    - tweaked: FALSE
[17:59:16.825]    - call: NULL
[17:59:16.827] plan(): nbrOfWorkers() = 1
[17:59:16.833] plan(): Setting new future strategy stack:
[17:59:16.834] List of future strategies:
[17:59:16.834] 1. multicore:
[17:59:16.834]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:16.834]    - tweaked: FALSE
[17:59:16.834]    - call: plan(strategy)
[17:59:16.825] MulticoreFuture:
[17:59:16.825] Label: ‘future_apply-2’
[17:59:16.825] Expression:
[17:59:16.825] {
[17:59:16.825]     do.call(function(...) {
[17:59:16.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.825]             on.exit(options(oopts), add = TRUE)
[17:59:16.825]         }
[17:59:16.825]         {
[17:59:16.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.825]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.825]             })
[17:59:16.825]         }
[17:59:16.825]     }, args = future.call.arguments)
[17:59:16.825] }
[17:59:16.825] Lazy evaluation: FALSE
[17:59:16.825] Asynchronous evaluation: TRUE
[17:59:16.825] Local evaluation: TRUE
[17:59:16.825] Environment: R_GlobalEnv
[17:59:16.825] Capture standard output: TRUE
[17:59:16.825] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:16.825] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:16.825] Packages: <none>
[17:59:16.825] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:16.825] Resolved: FALSE
[17:59:16.825] Value: <not collected>
[17:59:16.825] Conditions captured: <none>
[17:59:16.825] Early signaling: FALSE
[17:59:16.825] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:16.825] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:16.841] Chunk #2 of 2 ... DONE
[17:59:16.841] Launching 2 futures (chunks) ... DONE
[17:59:16.842] Resolving 2 futures (chunks) ...
[17:59:16.842] resolve() on list ...
[17:59:16.843]  recursive: 0
[17:59:16.843]  length: 2
[17:59:16.843] 
[17:59:16.843] plan(): nbrOfWorkers() = 2
[17:59:16.844] Future #1
[17:59:16.844] result() for MulticoreFuture ...
[17:59:16.846] result() for MulticoreFuture ...
[17:59:16.847] result() for MulticoreFuture ... done
[17:59:16.847] result() for MulticoreFuture ... done
[17:59:16.847] result() for MulticoreFuture ...
[17:59:16.848] result() for MulticoreFuture ... done
[17:59:16.848] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:16.848] - nx: 2
[17:59:16.849] - relay: TRUE
[17:59:16.849] - stdout: TRUE
[17:59:16.849] - signal: TRUE
[17:59:16.850] - resignal: FALSE
[17:59:16.850] - force: TRUE
[17:59:16.850] - relayed: [n=2] FALSE, FALSE
[17:59:16.851] - queued futures: [n=2] FALSE, FALSE
[17:59:16.851]  - until=1
[17:59:16.852]  - relaying element #1
[17:59:16.852] result() for MulticoreFuture ...
[17:59:16.852] result() for MulticoreFuture ... done
[17:59:16.853] result() for MulticoreFuture ...
[17:59:16.853] result() for MulticoreFuture ... done
[17:59:16.853] result() for MulticoreFuture ...
[17:59:16.854] result() for MulticoreFuture ... done
[17:59:16.854] result() for MulticoreFuture ...
[17:59:16.854] result() for MulticoreFuture ... done
[17:59:16.854] - relayed: [n=2] TRUE, FALSE
[17:59:16.855] - queued futures: [n=2] TRUE, FALSE
[17:59:16.855] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:16.855]  length: 1 (resolved future 1)
[17:59:16.856] Future #2
[17:59:16.856] result() for MulticoreFuture ...
[17:59:16.858] result() for MulticoreFuture ...
[17:59:16.859] result() for MulticoreFuture ... done
[17:59:16.863] result() for MulticoreFuture ... done
[17:59:16.863] result() for MulticoreFuture ...
[17:59:16.864] result() for MulticoreFuture ... done
[17:59:16.864] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:16.864] - nx: 2
[17:59:16.864] - relay: TRUE
[17:59:16.865] - stdout: TRUE
[17:59:16.865] - signal: TRUE
[17:59:16.865] - resignal: FALSE
[17:59:16.865] - force: TRUE
[17:59:16.866] - relayed: [n=2] TRUE, FALSE
[17:59:16.866] - queued futures: [n=2] TRUE, FALSE
[17:59:16.866]  - until=2
[17:59:16.866]  - relaying element #2
[17:59:16.867] result() for MulticoreFuture ...
[17:59:16.867] result() for MulticoreFuture ... done
[17:59:16.867] result() for MulticoreFuture ...
[17:59:16.867] result() for MulticoreFuture ... done
[17:59:16.868] result() for MulticoreFuture ...
[17:59:16.868] result() for MulticoreFuture ... done
[17:59:16.868] result() for MulticoreFuture ...
[17:59:16.868] result() for MulticoreFuture ... done
[17:59:16.869] - relayed: [n=2] TRUE, TRUE
[17:59:16.869] - queued futures: [n=2] TRUE, TRUE
[17:59:16.869] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:16.869]  length: 0 (resolved future 2)
[17:59:16.870] Relaying remaining futures
[17:59:16.870] signalConditionsASAP(NULL, pos=0) ...
[17:59:16.870] - nx: 2
[17:59:16.870] - relay: TRUE
[17:59:16.870] - stdout: TRUE
[17:59:16.871] - signal: TRUE
[17:59:16.871] - resignal: FALSE
[17:59:16.871] - force: TRUE
[17:59:16.871] - relayed: [n=2] TRUE, TRUE
[17:59:16.872] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:16.872] - relayed: [n=2] TRUE, TRUE
[17:59:16.872] - queued futures: [n=2] TRUE, TRUE
[17:59:16.872] signalConditionsASAP(NULL, pos=0) ... done
[17:59:16.873] resolve() on list ... DONE
[17:59:16.873] result() for MulticoreFuture ...
[17:59:16.873] result() for MulticoreFuture ... done
[17:59:16.874] result() for MulticoreFuture ...
[17:59:16.874] result() for MulticoreFuture ... done
[17:59:16.874] result() for MulticoreFuture ...
[17:59:16.874] result() for MulticoreFuture ... done
[17:59:16.875] result() for MulticoreFuture ...
[17:59:16.875] result() for MulticoreFuture ... done
[17:59:16.875]  - Number of value chunks collected: 2
[17:59:16.875] Resolving 2 futures (chunks) ... DONE
[17:59:16.876] Reducing values from 2 chunks ...
[17:59:16.876]  - Number of values collected after concatenation: 2
[17:59:16.876]  - Number of values expected: 2
[17:59:16.876] Reducing values from 2 chunks ... DONE
[17:59:16.876] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:59:16.878] getGlobalsAndPackagesXApply() ...
[17:59:16.879]  - future.globals: TRUE
[17:59:16.879] getGlobalsAndPackages() ...
[17:59:16.879] Searching for globals...
[17:59:16.882] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:16.882] Searching for globals ... DONE
[17:59:16.883] Resolving globals: FALSE
[17:59:16.884] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:16.884] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:16.885] - globals: [1] ‘FUN’
[17:59:16.885] - packages: [1] ‘stats’
[17:59:16.885] getGlobalsAndPackages() ... DONE
[17:59:16.886]  - globals found/used: [n=1] ‘FUN’
[17:59:16.886]  - needed namespaces: [n=1] ‘stats’
[17:59:16.886] Finding globals ... DONE
[17:59:16.886]  - use_args: TRUE
[17:59:16.886]  - Getting '...' globals ...
[17:59:16.887] resolve() on list ...
[17:59:16.887]  recursive: 0
[17:59:16.888]  length: 1
[17:59:16.888]  elements: ‘...’
[17:59:16.888]  length: 0 (resolved future 1)
[17:59:16.888] resolve() on list ... DONE
[17:59:16.889]    - '...' content: [n=0] 
[17:59:16.889] List of 1
[17:59:16.889]  $ ...: list()
[17:59:16.889]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.889]  - attr(*, "where")=List of 1
[17:59:16.889]   ..$ ...:<environment: 0x56085b3e7240> 
[17:59:16.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.889]  - attr(*, "resolved")= logi TRUE
[17:59:16.889]  - attr(*, "total_size")= num NA
[17:59:16.895]  - Getting '...' globals ... DONE
[17:59:16.895] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:16.895] List of 2
[17:59:16.895]  $ ...future.FUN:function (x, ...)  
[17:59:16.895]  $ ...          : list()
[17:59:16.895]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.895]  - attr(*, "where")=List of 2
[17:59:16.895]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:16.895]   ..$ ...          :<environment: 0x56085b3e7240> 
[17:59:16.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.895]  - attr(*, "resolved")= logi FALSE
[17:59:16.895]  - attr(*, "total_size")= num 1248
[17:59:16.905] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:16.905] getGlobalsAndPackagesXApply() ... DONE
[17:59:16.911] future_lapply() ...
[17:59:16.917] Number of chunks: 2
[17:59:16.918] getGlobalsAndPackagesXApply() ...
[17:59:16.918]  - future.globals: <name-value list> with names ‘list()’
[17:59:16.918]  - use_args: TRUE
[17:59:16.919] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:16.919] List of 2
[17:59:16.919]  $ ...          : list()
[17:59:16.919]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.919]  $ ...future.FUN:function (x, ...)  
[17:59:16.919]  - attr(*, "where")=List of 2
[17:59:16.919]   ..$ ...          :<environment: 0x56085b3e7240> 
[17:59:16.919]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:59:16.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.919]  - attr(*, "resolved")= logi FALSE
[17:59:16.919]  - attr(*, "total_size")= num NA
[17:59:16.924] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:16.925] getGlobalsAndPackagesXApply() ... DONE
[17:59:16.925] Number of futures (= number of chunks): 2
[17:59:16.925] Launching 2 futures (chunks) ...
[17:59:16.925] Chunk #1 of 2 ...
[17:59:16.926]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:16.926]  - seeds: <none>
[17:59:16.926]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.926] getGlobalsAndPackages() ...
[17:59:16.927] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.927] Resolving globals: FALSE
[17:59:16.927] Tweak future expression to call with '...' arguments ...
[17:59:16.927] {
[17:59:16.927]     do.call(function(...) {
[17:59:16.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.927]             on.exit(options(oopts), add = TRUE)
[17:59:16.927]         }
[17:59:16.927]         {
[17:59:16.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.927]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.927]             })
[17:59:16.927]         }
[17:59:16.927]     }, args = future.call.arguments)
[17:59:16.927] }
[17:59:16.928] Tweak future expression to call with '...' arguments ... DONE
[17:59:16.929] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.929] - packages: [1] ‘stats’
[17:59:16.929] getGlobalsAndPackages() ... DONE
[17:59:16.930] run() for ‘Future’ ...
[17:59:16.930] - state: ‘created’
[17:59:16.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:16.937] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:16.937] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:16.937]   - Field: ‘label’
[17:59:16.938]   - Field: ‘local’
[17:59:16.938]   - Field: ‘owner’
[17:59:16.938]   - Field: ‘envir’
[17:59:16.938]   - Field: ‘workers’
[17:59:16.938]   - Field: ‘packages’
[17:59:16.939]   - Field: ‘gc’
[17:59:16.939]   - Field: ‘job’
[17:59:16.939]   - Field: ‘conditions’
[17:59:16.939]   - Field: ‘expr’
[17:59:16.939]   - Field: ‘uuid’
[17:59:16.940]   - Field: ‘seed’
[17:59:16.940]   - Field: ‘version’
[17:59:16.940]   - Field: ‘result’
[17:59:16.940]   - Field: ‘asynchronous’
[17:59:16.940]   - Field: ‘calls’
[17:59:16.941]   - Field: ‘globals’
[17:59:16.941]   - Field: ‘stdout’
[17:59:16.941]   - Field: ‘earlySignal’
[17:59:16.941]   - Field: ‘lazy’
[17:59:16.941]   - Field: ‘state’
[17:59:16.942] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:16.942] - Launch lazy future ...
[17:59:16.942] Packages needed by the future expression (n = 1): ‘stats’
[17:59:16.943] Packages needed by future strategies (n = 0): <none>
[17:59:16.944] {
[17:59:16.944]     {
[17:59:16.944]         {
[17:59:16.944]             ...future.startTime <- base::Sys.time()
[17:59:16.944]             {
[17:59:16.944]                 {
[17:59:16.944]                   {
[17:59:16.944]                     {
[17:59:16.944]                       {
[17:59:16.944]                         base::local({
[17:59:16.944]                           has_future <- base::requireNamespace("future", 
[17:59:16.944]                             quietly = TRUE)
[17:59:16.944]                           if (has_future) {
[17:59:16.944]                             ns <- base::getNamespace("future")
[17:59:16.944]                             version <- ns[[".package"]][["version"]]
[17:59:16.944]                             if (is.null(version)) 
[17:59:16.944]                               version <- utils::packageVersion("future")
[17:59:16.944]                           }
[17:59:16.944]                           else {
[17:59:16.944]                             version <- NULL
[17:59:16.944]                           }
[17:59:16.944]                           if (!has_future || version < "1.8.0") {
[17:59:16.944]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:16.944]                               "", base::R.version$version.string), 
[17:59:16.944]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:16.944]                                 base::R.version$platform, 8 * 
[17:59:16.944]                                   base::.Machine$sizeof.pointer), 
[17:59:16.944]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:16.944]                                 "release", "version")], collapse = " "), 
[17:59:16.944]                               hostname = base::Sys.info()[["nodename"]])
[17:59:16.944]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:16.944]                               info)
[17:59:16.944]                             info <- base::paste(info, collapse = "; ")
[17:59:16.944]                             if (!has_future) {
[17:59:16.944]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:16.944]                                 info)
[17:59:16.944]                             }
[17:59:16.944]                             else {
[17:59:16.944]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:16.944]                                 info, version)
[17:59:16.944]                             }
[17:59:16.944]                             base::stop(msg)
[17:59:16.944]                           }
[17:59:16.944]                         })
[17:59:16.944]                       }
[17:59:16.944]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:16.944]                       base::options(mc.cores = 1L)
[17:59:16.944]                     }
[17:59:16.944]                     base::local({
[17:59:16.944]                       for (pkg in "stats") {
[17:59:16.944]                         base::loadNamespace(pkg)
[17:59:16.944]                         base::library(pkg, character.only = TRUE)
[17:59:16.944]                       }
[17:59:16.944]                     })
[17:59:16.944]                   }
[17:59:16.944]                   ...future.strategy.old <- future::plan("list")
[17:59:16.944]                   options(future.plan = NULL)
[17:59:16.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:16.944]                 }
[17:59:16.944]                 ...future.workdir <- getwd()
[17:59:16.944]             }
[17:59:16.944]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:16.944]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:16.944]         }
[17:59:16.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:16.944]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:16.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:16.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:16.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:16.944]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:16.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:16.944]             base::names(...future.oldOptions))
[17:59:16.944]     }
[17:59:16.944]     if (FALSE) {
[17:59:16.944]     }
[17:59:16.944]     else {
[17:59:16.944]         if (TRUE) {
[17:59:16.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:16.944]                 open = "w")
[17:59:16.944]         }
[17:59:16.944]         else {
[17:59:16.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:16.944]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:16.944]         }
[17:59:16.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:16.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:16.944]             base::sink(type = "output", split = FALSE)
[17:59:16.944]             base::close(...future.stdout)
[17:59:16.944]         }, add = TRUE)
[17:59:16.944]     }
[17:59:16.944]     ...future.frame <- base::sys.nframe()
[17:59:16.944]     ...future.conditions <- base::list()
[17:59:16.944]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:16.944]     if (FALSE) {
[17:59:16.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:16.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:16.944]     }
[17:59:16.944]     ...future.result <- base::tryCatch({
[17:59:16.944]         base::withCallingHandlers({
[17:59:16.944]             ...future.value <- base::withVisible(base::local({
[17:59:16.944]                 withCallingHandlers({
[17:59:16.944]                   {
[17:59:16.944]                     do.call(function(...) {
[17:59:16.944]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.944]                       if (!identical(...future.globals.maxSize.org, 
[17:59:16.944]                         ...future.globals.maxSize)) {
[17:59:16.944]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.944]                         on.exit(options(oopts), add = TRUE)
[17:59:16.944]                       }
[17:59:16.944]                       {
[17:59:16.944]                         lapply(seq_along(...future.elements_ii), 
[17:59:16.944]                           FUN = function(jj) {
[17:59:16.944]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.944]                             ...future.FUN(...future.X_jj, ...)
[17:59:16.944]                           })
[17:59:16.944]                       }
[17:59:16.944]                     }, args = future.call.arguments)
[17:59:16.944]                   }
[17:59:16.944]                 }, immediateCondition = function(cond) {
[17:59:16.944]                   save_rds <- function (object, pathname, ...) 
[17:59:16.944]                   {
[17:59:16.944]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:16.944]                     if (file_test("-f", pathname_tmp)) {
[17:59:16.944]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.944]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:16.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.944]                         fi_tmp[["mtime"]])
[17:59:16.944]                     }
[17:59:16.944]                     tryCatch({
[17:59:16.944]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:16.944]                     }, error = function(ex) {
[17:59:16.944]                       msg <- conditionMessage(ex)
[17:59:16.944]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.944]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:16.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.944]                         fi_tmp[["mtime"]], msg)
[17:59:16.944]                       ex$message <- msg
[17:59:16.944]                       stop(ex)
[17:59:16.944]                     })
[17:59:16.944]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:16.944]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:16.944]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:16.944]                       fi_tmp <- file.info(pathname_tmp)
[17:59:16.944]                       fi <- file.info(pathname)
[17:59:16.944]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:16.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:16.944]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:16.944]                         fi[["size"]], fi[["mtime"]])
[17:59:16.944]                       stop(msg)
[17:59:16.944]                     }
[17:59:16.944]                     invisible(pathname)
[17:59:16.944]                   }
[17:59:16.944]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:16.944]                     rootPath = tempdir()) 
[17:59:16.944]                   {
[17:59:16.944]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:16.944]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:16.944]                       tmpdir = path, fileext = ".rds")
[17:59:16.944]                     save_rds(obj, file)
[17:59:16.944]                   }
[17:59:16.944]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:16.944]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.944]                   {
[17:59:16.944]                     inherits <- base::inherits
[17:59:16.944]                     invokeRestart <- base::invokeRestart
[17:59:16.944]                     is.null <- base::is.null
[17:59:16.944]                     muffled <- FALSE
[17:59:16.944]                     if (inherits(cond, "message")) {
[17:59:16.944]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:16.944]                       if (muffled) 
[17:59:16.944]                         invokeRestart("muffleMessage")
[17:59:16.944]                     }
[17:59:16.944]                     else if (inherits(cond, "warning")) {
[17:59:16.944]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:16.944]                       if (muffled) 
[17:59:16.944]                         invokeRestart("muffleWarning")
[17:59:16.944]                     }
[17:59:16.944]                     else if (inherits(cond, "condition")) {
[17:59:16.944]                       if (!is.null(pattern)) {
[17:59:16.944]                         computeRestarts <- base::computeRestarts
[17:59:16.944]                         grepl <- base::grepl
[17:59:16.944]                         restarts <- computeRestarts(cond)
[17:59:16.944]                         for (restart in restarts) {
[17:59:16.944]                           name <- restart$name
[17:59:16.944]                           if (is.null(name)) 
[17:59:16.944]                             next
[17:59:16.944]                           if (!grepl(pattern, name)) 
[17:59:16.944]                             next
[17:59:16.944]                           invokeRestart(restart)
[17:59:16.944]                           muffled <- TRUE
[17:59:16.944]                           break
[17:59:16.944]                         }
[17:59:16.944]                       }
[17:59:16.944]                     }
[17:59:16.944]                     invisible(muffled)
[17:59:16.944]                   }
[17:59:16.944]                   muffleCondition(cond)
[17:59:16.944]                 })
[17:59:16.944]             }))
[17:59:16.944]             future::FutureResult(value = ...future.value$value, 
[17:59:16.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.944]                   ...future.rng), globalenv = if (FALSE) 
[17:59:16.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:16.944]                     ...future.globalenv.names))
[17:59:16.944]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:16.944]         }, condition = base::local({
[17:59:16.944]             c <- base::c
[17:59:16.944]             inherits <- base::inherits
[17:59:16.944]             invokeRestart <- base::invokeRestart
[17:59:16.944]             length <- base::length
[17:59:16.944]             list <- base::list
[17:59:16.944]             seq.int <- base::seq.int
[17:59:16.944]             signalCondition <- base::signalCondition
[17:59:16.944]             sys.calls <- base::sys.calls
[17:59:16.944]             `[[` <- base::`[[`
[17:59:16.944]             `+` <- base::`+`
[17:59:16.944]             `<<-` <- base::`<<-`
[17:59:16.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:16.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:16.944]                   3L)]
[17:59:16.944]             }
[17:59:16.944]             function(cond) {
[17:59:16.944]                 is_error <- inherits(cond, "error")
[17:59:16.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:16.944]                   NULL)
[17:59:16.944]                 if (is_error) {
[17:59:16.944]                   sessionInformation <- function() {
[17:59:16.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:16.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:16.944]                       search = base::search(), system = base::Sys.info())
[17:59:16.944]                   }
[17:59:16.944]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:16.944]                     cond$call), session = sessionInformation(), 
[17:59:16.944]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:16.944]                   signalCondition(cond)
[17:59:16.944]                 }
[17:59:16.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:16.944]                 "immediateCondition"))) {
[17:59:16.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:16.944]                   ...future.conditions[[length(...future.conditions) + 
[17:59:16.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:16.944]                   if (TRUE && !signal) {
[17:59:16.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.944]                     {
[17:59:16.944]                       inherits <- base::inherits
[17:59:16.944]                       invokeRestart <- base::invokeRestart
[17:59:16.944]                       is.null <- base::is.null
[17:59:16.944]                       muffled <- FALSE
[17:59:16.944]                       if (inherits(cond, "message")) {
[17:59:16.944]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.944]                         if (muffled) 
[17:59:16.944]                           invokeRestart("muffleMessage")
[17:59:16.944]                       }
[17:59:16.944]                       else if (inherits(cond, "warning")) {
[17:59:16.944]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.944]                         if (muffled) 
[17:59:16.944]                           invokeRestart("muffleWarning")
[17:59:16.944]                       }
[17:59:16.944]                       else if (inherits(cond, "condition")) {
[17:59:16.944]                         if (!is.null(pattern)) {
[17:59:16.944]                           computeRestarts <- base::computeRestarts
[17:59:16.944]                           grepl <- base::grepl
[17:59:16.944]                           restarts <- computeRestarts(cond)
[17:59:16.944]                           for (restart in restarts) {
[17:59:16.944]                             name <- restart$name
[17:59:16.944]                             if (is.null(name)) 
[17:59:16.944]                               next
[17:59:16.944]                             if (!grepl(pattern, name)) 
[17:59:16.944]                               next
[17:59:16.944]                             invokeRestart(restart)
[17:59:16.944]                             muffled <- TRUE
[17:59:16.944]                             break
[17:59:16.944]                           }
[17:59:16.944]                         }
[17:59:16.944]                       }
[17:59:16.944]                       invisible(muffled)
[17:59:16.944]                     }
[17:59:16.944]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.944]                   }
[17:59:16.944]                 }
[17:59:16.944]                 else {
[17:59:16.944]                   if (TRUE) {
[17:59:16.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:16.944]                     {
[17:59:16.944]                       inherits <- base::inherits
[17:59:16.944]                       invokeRestart <- base::invokeRestart
[17:59:16.944]                       is.null <- base::is.null
[17:59:16.944]                       muffled <- FALSE
[17:59:16.944]                       if (inherits(cond, "message")) {
[17:59:16.944]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:16.944]                         if (muffled) 
[17:59:16.944]                           invokeRestart("muffleMessage")
[17:59:16.944]                       }
[17:59:16.944]                       else if (inherits(cond, "warning")) {
[17:59:16.944]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:16.944]                         if (muffled) 
[17:59:16.944]                           invokeRestart("muffleWarning")
[17:59:16.944]                       }
[17:59:16.944]                       else if (inherits(cond, "condition")) {
[17:59:16.944]                         if (!is.null(pattern)) {
[17:59:16.944]                           computeRestarts <- base::computeRestarts
[17:59:16.944]                           grepl <- base::grepl
[17:59:16.944]                           restarts <- computeRestarts(cond)
[17:59:16.944]                           for (restart in restarts) {
[17:59:16.944]                             name <- restart$name
[17:59:16.944]                             if (is.null(name)) 
[17:59:16.944]                               next
[17:59:16.944]                             if (!grepl(pattern, name)) 
[17:59:16.944]                               next
[17:59:16.944]                             invokeRestart(restart)
[17:59:16.944]                             muffled <- TRUE
[17:59:16.944]                             break
[17:59:16.944]                           }
[17:59:16.944]                         }
[17:59:16.944]                       }
[17:59:16.944]                       invisible(muffled)
[17:59:16.944]                     }
[17:59:16.944]                     muffleCondition(cond, pattern = "^muffle")
[17:59:16.944]                   }
[17:59:16.944]                 }
[17:59:16.944]             }
[17:59:16.944]         }))
[17:59:16.944]     }, error = function(ex) {
[17:59:16.944]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:16.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:16.944]                 ...future.rng), started = ...future.startTime, 
[17:59:16.944]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:16.944]             version = "1.8"), class = "FutureResult")
[17:59:16.944]     }, finally = {
[17:59:16.944]         if (!identical(...future.workdir, getwd())) 
[17:59:16.944]             setwd(...future.workdir)
[17:59:16.944]         {
[17:59:16.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:16.944]                 ...future.oldOptions$nwarnings <- NULL
[17:59:16.944]             }
[17:59:16.944]             base::options(...future.oldOptions)
[17:59:16.944]             if (.Platform$OS.type == "windows") {
[17:59:16.944]                 old_names <- names(...future.oldEnvVars)
[17:59:16.944]                 envs <- base::Sys.getenv()
[17:59:16.944]                 names <- names(envs)
[17:59:16.944]                 common <- intersect(names, old_names)
[17:59:16.944]                 added <- setdiff(names, old_names)
[17:59:16.944]                 removed <- setdiff(old_names, names)
[17:59:16.944]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:16.944]                   envs[common]]
[17:59:16.944]                 NAMES <- toupper(changed)
[17:59:16.944]                 args <- list()
[17:59:16.944]                 for (kk in seq_along(NAMES)) {
[17:59:16.944]                   name <- changed[[kk]]
[17:59:16.944]                   NAME <- NAMES[[kk]]
[17:59:16.944]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.944]                     next
[17:59:16.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.944]                 }
[17:59:16.944]                 NAMES <- toupper(added)
[17:59:16.944]                 for (kk in seq_along(NAMES)) {
[17:59:16.944]                   name <- added[[kk]]
[17:59:16.944]                   NAME <- NAMES[[kk]]
[17:59:16.944]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.944]                     next
[17:59:16.944]                   args[[name]] <- ""
[17:59:16.944]                 }
[17:59:16.944]                 NAMES <- toupper(removed)
[17:59:16.944]                 for (kk in seq_along(NAMES)) {
[17:59:16.944]                   name <- removed[[kk]]
[17:59:16.944]                   NAME <- NAMES[[kk]]
[17:59:16.944]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:16.944]                     next
[17:59:16.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:16.944]                 }
[17:59:16.944]                 if (length(args) > 0) 
[17:59:16.944]                   base::do.call(base::Sys.setenv, args = args)
[17:59:16.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:16.944]             }
[17:59:16.944]             else {
[17:59:16.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:16.944]             }
[17:59:16.944]             {
[17:59:16.944]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:16.944]                   0L) {
[17:59:16.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:16.944]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:16.944]                   base::options(opts)
[17:59:16.944]                 }
[17:59:16.944]                 {
[17:59:16.944]                   {
[17:59:16.944]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:16.944]                     NULL
[17:59:16.944]                   }
[17:59:16.944]                   options(future.plan = NULL)
[17:59:16.944]                   if (is.na(NA_character_)) 
[17:59:16.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:16.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:16.944]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:16.944]                     .init = FALSE)
[17:59:16.944]                 }
[17:59:16.944]             }
[17:59:16.944]         }
[17:59:16.944]     })
[17:59:16.944]     if (TRUE) {
[17:59:16.944]         base::sink(type = "output", split = FALSE)
[17:59:16.944]         if (TRUE) {
[17:59:16.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:16.944]         }
[17:59:16.944]         else {
[17:59:16.944]             ...future.result["stdout"] <- base::list(NULL)
[17:59:16.944]         }
[17:59:16.944]         base::close(...future.stdout)
[17:59:16.944]         ...future.stdout <- NULL
[17:59:16.944]     }
[17:59:16.944]     ...future.result$conditions <- ...future.conditions
[17:59:16.944]     ...future.result$finished <- base::Sys.time()
[17:59:16.944]     ...future.result
[17:59:16.944] }
[17:59:16.948] assign_globals() ...
[17:59:16.949] List of 5
[17:59:16.949]  $ future.call.arguments    : list()
[17:59:16.949]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:16.949]  $ ...future.FUN            :function (x, ...)  
[17:59:16.949]  $ ...future.elements_ii    :List of 1
[17:59:16.949]   ..$ : num [1:4] 1 3 1 7
[17:59:16.949]  $ ...future.seeds_ii       : NULL
[17:59:16.949]  $ ...future.globals.maxSize: num Inf
[17:59:16.949]  - attr(*, "resolved")= logi FALSE
[17:59:16.949]  - attr(*, "total_size")= num NA
[17:59:16.949]  - attr(*, "where")=List of 5
[17:59:16.949]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:16.949]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:16.949]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:16.949]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:16.949]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:16.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:16.949]  - attr(*, "already-done")= logi TRUE
[17:59:16.964] - copied ‘future.call.arguments’ to environment
[17:59:16.964] - copied ‘...future.FUN’ to environment
[17:59:16.964] - copied ‘...future.elements_ii’ to environment
[17:59:16.964] - copied ‘...future.seeds_ii’ to environment
[17:59:16.965] - copied ‘...future.globals.maxSize’ to environment
[17:59:16.965] assign_globals() ... done
[17:59:16.965] requestCore(): workers = 2
[17:59:16.969] MulticoreFuture started
[17:59:16.970] - Launch lazy future ... done
[17:59:16.971] run() for ‘MulticoreFuture’ ... done
[17:59:16.972] Created future:
[17:59:16.973] plan(): Setting new future strategy stack:
[17:59:16.974] List of future strategies:
[17:59:16.974] 1. sequential:
[17:59:16.974]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:16.974]    - tweaked: FALSE
[17:59:16.974]    - call: NULL
[17:59:16.976] plan(): nbrOfWorkers() = 1
[17:59:16.981] plan(): Setting new future strategy stack:
[17:59:16.982] List of future strategies:
[17:59:16.982] 1. multicore:
[17:59:16.982]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:16.982]    - tweaked: FALSE
[17:59:16.982]    - call: plan(strategy)
[17:59:16.973] MulticoreFuture:
[17:59:16.973] Label: ‘future_apply-1’
[17:59:16.973] Expression:
[17:59:16.973] {
[17:59:16.973]     do.call(function(...) {
[17:59:16.973]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.973]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.973]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.973]             on.exit(options(oopts), add = TRUE)
[17:59:16.973]         }
[17:59:16.973]         {
[17:59:16.973]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.973]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.973]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.973]             })
[17:59:16.973]         }
[17:59:16.973]     }, args = future.call.arguments)
[17:59:16.973] }
[17:59:16.973] Lazy evaluation: FALSE
[17:59:16.973] Asynchronous evaluation: TRUE
[17:59:16.973] Local evaluation: TRUE
[17:59:16.973] Environment: R_GlobalEnv
[17:59:16.973] Capture standard output: TRUE
[17:59:16.973] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:16.973] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:16.973] Packages: 1 packages (‘stats’)
[17:59:16.973] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:16.973] Resolved: FALSE
[17:59:16.973] Value: <not collected>
[17:59:16.973] Conditions captured: <none>
[17:59:16.973] Early signaling: FALSE
[17:59:16.973] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:16.973] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:16.989] Chunk #1 of 2 ... DONE
[17:59:16.989] Chunk #2 of 2 ...
[17:59:16.990]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:16.990]  - seeds: <none>
[17:59:16.990]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.991] getGlobalsAndPackages() ...
[17:59:16.991] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.992] Resolving globals: FALSE
[17:59:16.992] plan(): nbrOfWorkers() = 2
[17:59:16.992] Tweak future expression to call with '...' arguments ...
[17:59:16.992] {
[17:59:16.992]     do.call(function(...) {
[17:59:16.992]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:16.992]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:16.992]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:16.992]             on.exit(options(oopts), add = TRUE)
[17:59:16.992]         }
[17:59:16.992]         {
[17:59:16.992]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:16.992]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:16.992]                 ...future.FUN(...future.X_jj, ...)
[17:59:16.992]             })
[17:59:16.992]         }
[17:59:16.992]     }, args = future.call.arguments)
[17:59:16.992] }
[17:59:16.993] Tweak future expression to call with '...' arguments ... DONE
[17:59:16.995] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:16.995] - packages: [1] ‘stats’
[17:59:16.995] getGlobalsAndPackages() ... DONE
[17:59:16.996] run() for ‘Future’ ...
[17:59:16.997] - state: ‘created’
[17:59:16.997] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:17.005] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:17.006]   - Field: ‘label’
[17:59:17.006]   - Field: ‘local’
[17:59:17.007]   - Field: ‘owner’
[17:59:17.007]   - Field: ‘envir’
[17:59:17.007]   - Field: ‘workers’
[17:59:17.007]   - Field: ‘packages’
[17:59:17.008]   - Field: ‘gc’
[17:59:17.008]   - Field: ‘job’
[17:59:17.008]   - Field: ‘conditions’
[17:59:17.009]   - Field: ‘expr’
[17:59:17.009]   - Field: ‘uuid’
[17:59:17.009]   - Field: ‘seed’
[17:59:17.009]   - Field: ‘version’
[17:59:17.010]   - Field: ‘result’
[17:59:17.010]   - Field: ‘asynchronous’
[17:59:17.010]   - Field: ‘calls’
[17:59:17.011]   - Field: ‘globals’
[17:59:17.011]   - Field: ‘stdout’
[17:59:17.011]   - Field: ‘earlySignal’
[17:59:17.011]   - Field: ‘lazy’
[17:59:17.012]   - Field: ‘state’
[17:59:17.012] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:17.012] - Launch lazy future ...
[17:59:17.013] Packages needed by the future expression (n = 1): ‘stats’
[17:59:17.014] Packages needed by future strategies (n = 0): <none>
[17:59:17.015] {
[17:59:17.015]     {
[17:59:17.015]         {
[17:59:17.015]             ...future.startTime <- base::Sys.time()
[17:59:17.015]             {
[17:59:17.015]                 {
[17:59:17.015]                   {
[17:59:17.015]                     {
[17:59:17.015]                       {
[17:59:17.015]                         base::local({
[17:59:17.015]                           has_future <- base::requireNamespace("future", 
[17:59:17.015]                             quietly = TRUE)
[17:59:17.015]                           if (has_future) {
[17:59:17.015]                             ns <- base::getNamespace("future")
[17:59:17.015]                             version <- ns[[".package"]][["version"]]
[17:59:17.015]                             if (is.null(version)) 
[17:59:17.015]                               version <- utils::packageVersion("future")
[17:59:17.015]                           }
[17:59:17.015]                           else {
[17:59:17.015]                             version <- NULL
[17:59:17.015]                           }
[17:59:17.015]                           if (!has_future || version < "1.8.0") {
[17:59:17.015]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:17.015]                               "", base::R.version$version.string), 
[17:59:17.015]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:17.015]                                 base::R.version$platform, 8 * 
[17:59:17.015]                                   base::.Machine$sizeof.pointer), 
[17:59:17.015]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:17.015]                                 "release", "version")], collapse = " "), 
[17:59:17.015]                               hostname = base::Sys.info()[["nodename"]])
[17:59:17.015]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:17.015]                               info)
[17:59:17.015]                             info <- base::paste(info, collapse = "; ")
[17:59:17.015]                             if (!has_future) {
[17:59:17.015]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:17.015]                                 info)
[17:59:17.015]                             }
[17:59:17.015]                             else {
[17:59:17.015]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:17.015]                                 info, version)
[17:59:17.015]                             }
[17:59:17.015]                             base::stop(msg)
[17:59:17.015]                           }
[17:59:17.015]                         })
[17:59:17.015]                       }
[17:59:17.015]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:17.015]                       base::options(mc.cores = 1L)
[17:59:17.015]                     }
[17:59:17.015]                     base::local({
[17:59:17.015]                       for (pkg in "stats") {
[17:59:17.015]                         base::loadNamespace(pkg)
[17:59:17.015]                         base::library(pkg, character.only = TRUE)
[17:59:17.015]                       }
[17:59:17.015]                     })
[17:59:17.015]                   }
[17:59:17.015]                   ...future.strategy.old <- future::plan("list")
[17:59:17.015]                   options(future.plan = NULL)
[17:59:17.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:17.015]                 }
[17:59:17.015]                 ...future.workdir <- getwd()
[17:59:17.015]             }
[17:59:17.015]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:17.015]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:17.015]         }
[17:59:17.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:17.015]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:17.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:17.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:17.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:17.015]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:17.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:17.015]             base::names(...future.oldOptions))
[17:59:17.015]     }
[17:59:17.015]     if (FALSE) {
[17:59:17.015]     }
[17:59:17.015]     else {
[17:59:17.015]         if (TRUE) {
[17:59:17.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:17.015]                 open = "w")
[17:59:17.015]         }
[17:59:17.015]         else {
[17:59:17.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:17.015]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:17.015]         }
[17:59:17.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:17.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:17.015]             base::sink(type = "output", split = FALSE)
[17:59:17.015]             base::close(...future.stdout)
[17:59:17.015]         }, add = TRUE)
[17:59:17.015]     }
[17:59:17.015]     ...future.frame <- base::sys.nframe()
[17:59:17.015]     ...future.conditions <- base::list()
[17:59:17.015]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:17.015]     if (FALSE) {
[17:59:17.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:17.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:17.015]     }
[17:59:17.015]     ...future.result <- base::tryCatch({
[17:59:17.015]         base::withCallingHandlers({
[17:59:17.015]             ...future.value <- base::withVisible(base::local({
[17:59:17.015]                 withCallingHandlers({
[17:59:17.015]                   {
[17:59:17.015]                     do.call(function(...) {
[17:59:17.015]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.015]                       if (!identical(...future.globals.maxSize.org, 
[17:59:17.015]                         ...future.globals.maxSize)) {
[17:59:17.015]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.015]                         on.exit(options(oopts), add = TRUE)
[17:59:17.015]                       }
[17:59:17.015]                       {
[17:59:17.015]                         lapply(seq_along(...future.elements_ii), 
[17:59:17.015]                           FUN = function(jj) {
[17:59:17.015]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.015]                             ...future.FUN(...future.X_jj, ...)
[17:59:17.015]                           })
[17:59:17.015]                       }
[17:59:17.015]                     }, args = future.call.arguments)
[17:59:17.015]                   }
[17:59:17.015]                 }, immediateCondition = function(cond) {
[17:59:17.015]                   save_rds <- function (object, pathname, ...) 
[17:59:17.015]                   {
[17:59:17.015]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:17.015]                     if (file_test("-f", pathname_tmp)) {
[17:59:17.015]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.015]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:17.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.015]                         fi_tmp[["mtime"]])
[17:59:17.015]                     }
[17:59:17.015]                     tryCatch({
[17:59:17.015]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:17.015]                     }, error = function(ex) {
[17:59:17.015]                       msg <- conditionMessage(ex)
[17:59:17.015]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.015]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:17.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.015]                         fi_tmp[["mtime"]], msg)
[17:59:17.015]                       ex$message <- msg
[17:59:17.015]                       stop(ex)
[17:59:17.015]                     })
[17:59:17.015]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:17.015]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:17.015]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:17.015]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.015]                       fi <- file.info(pathname)
[17:59:17.015]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:17.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.015]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:17.015]                         fi[["size"]], fi[["mtime"]])
[17:59:17.015]                       stop(msg)
[17:59:17.015]                     }
[17:59:17.015]                     invisible(pathname)
[17:59:17.015]                   }
[17:59:17.015]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:17.015]                     rootPath = tempdir()) 
[17:59:17.015]                   {
[17:59:17.015]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:17.015]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:17.015]                       tmpdir = path, fileext = ".rds")
[17:59:17.015]                     save_rds(obj, file)
[17:59:17.015]                   }
[17:59:17.015]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:17.015]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.015]                   {
[17:59:17.015]                     inherits <- base::inherits
[17:59:17.015]                     invokeRestart <- base::invokeRestart
[17:59:17.015]                     is.null <- base::is.null
[17:59:17.015]                     muffled <- FALSE
[17:59:17.015]                     if (inherits(cond, "message")) {
[17:59:17.015]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:17.015]                       if (muffled) 
[17:59:17.015]                         invokeRestart("muffleMessage")
[17:59:17.015]                     }
[17:59:17.015]                     else if (inherits(cond, "warning")) {
[17:59:17.015]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:17.015]                       if (muffled) 
[17:59:17.015]                         invokeRestart("muffleWarning")
[17:59:17.015]                     }
[17:59:17.015]                     else if (inherits(cond, "condition")) {
[17:59:17.015]                       if (!is.null(pattern)) {
[17:59:17.015]                         computeRestarts <- base::computeRestarts
[17:59:17.015]                         grepl <- base::grepl
[17:59:17.015]                         restarts <- computeRestarts(cond)
[17:59:17.015]                         for (restart in restarts) {
[17:59:17.015]                           name <- restart$name
[17:59:17.015]                           if (is.null(name)) 
[17:59:17.015]                             next
[17:59:17.015]                           if (!grepl(pattern, name)) 
[17:59:17.015]                             next
[17:59:17.015]                           invokeRestart(restart)
[17:59:17.015]                           muffled <- TRUE
[17:59:17.015]                           break
[17:59:17.015]                         }
[17:59:17.015]                       }
[17:59:17.015]                     }
[17:59:17.015]                     invisible(muffled)
[17:59:17.015]                   }
[17:59:17.015]                   muffleCondition(cond)
[17:59:17.015]                 })
[17:59:17.015]             }))
[17:59:17.015]             future::FutureResult(value = ...future.value$value, 
[17:59:17.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.015]                   ...future.rng), globalenv = if (FALSE) 
[17:59:17.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:17.015]                     ...future.globalenv.names))
[17:59:17.015]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:17.015]         }, condition = base::local({
[17:59:17.015]             c <- base::c
[17:59:17.015]             inherits <- base::inherits
[17:59:17.015]             invokeRestart <- base::invokeRestart
[17:59:17.015]             length <- base::length
[17:59:17.015]             list <- base::list
[17:59:17.015]             seq.int <- base::seq.int
[17:59:17.015]             signalCondition <- base::signalCondition
[17:59:17.015]             sys.calls <- base::sys.calls
[17:59:17.015]             `[[` <- base::`[[`
[17:59:17.015]             `+` <- base::`+`
[17:59:17.015]             `<<-` <- base::`<<-`
[17:59:17.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:17.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:17.015]                   3L)]
[17:59:17.015]             }
[17:59:17.015]             function(cond) {
[17:59:17.015]                 is_error <- inherits(cond, "error")
[17:59:17.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:17.015]                   NULL)
[17:59:17.015]                 if (is_error) {
[17:59:17.015]                   sessionInformation <- function() {
[17:59:17.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:17.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:17.015]                       search = base::search(), system = base::Sys.info())
[17:59:17.015]                   }
[17:59:17.015]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:17.015]                     cond$call), session = sessionInformation(), 
[17:59:17.015]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:17.015]                   signalCondition(cond)
[17:59:17.015]                 }
[17:59:17.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:17.015]                 "immediateCondition"))) {
[17:59:17.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:17.015]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:17.015]                   if (TRUE && !signal) {
[17:59:17.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.015]                     {
[17:59:17.015]                       inherits <- base::inherits
[17:59:17.015]                       invokeRestart <- base::invokeRestart
[17:59:17.015]                       is.null <- base::is.null
[17:59:17.015]                       muffled <- FALSE
[17:59:17.015]                       if (inherits(cond, "message")) {
[17:59:17.015]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.015]                         if (muffled) 
[17:59:17.015]                           invokeRestart("muffleMessage")
[17:59:17.015]                       }
[17:59:17.015]                       else if (inherits(cond, "warning")) {
[17:59:17.015]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.015]                         if (muffled) 
[17:59:17.015]                           invokeRestart("muffleWarning")
[17:59:17.015]                       }
[17:59:17.015]                       else if (inherits(cond, "condition")) {
[17:59:17.015]                         if (!is.null(pattern)) {
[17:59:17.015]                           computeRestarts <- base::computeRestarts
[17:59:17.015]                           grepl <- base::grepl
[17:59:17.015]                           restarts <- computeRestarts(cond)
[17:59:17.015]                           for (restart in restarts) {
[17:59:17.015]                             name <- restart$name
[17:59:17.015]                             if (is.null(name)) 
[17:59:17.015]                               next
[17:59:17.015]                             if (!grepl(pattern, name)) 
[17:59:17.015]                               next
[17:59:17.015]                             invokeRestart(restart)
[17:59:17.015]                             muffled <- TRUE
[17:59:17.015]                             break
[17:59:17.015]                           }
[17:59:17.015]                         }
[17:59:17.015]                       }
[17:59:17.015]                       invisible(muffled)
[17:59:17.015]                     }
[17:59:17.015]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.015]                   }
[17:59:17.015]                 }
[17:59:17.015]                 else {
[17:59:17.015]                   if (TRUE) {
[17:59:17.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.015]                     {
[17:59:17.015]                       inherits <- base::inherits
[17:59:17.015]                       invokeRestart <- base::invokeRestart
[17:59:17.015]                       is.null <- base::is.null
[17:59:17.015]                       muffled <- FALSE
[17:59:17.015]                       if (inherits(cond, "message")) {
[17:59:17.015]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.015]                         if (muffled) 
[17:59:17.015]                           invokeRestart("muffleMessage")
[17:59:17.015]                       }
[17:59:17.015]                       else if (inherits(cond, "warning")) {
[17:59:17.015]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.015]                         if (muffled) 
[17:59:17.015]                           invokeRestart("muffleWarning")
[17:59:17.015]                       }
[17:59:17.015]                       else if (inherits(cond, "condition")) {
[17:59:17.015]                         if (!is.null(pattern)) {
[17:59:17.015]                           computeRestarts <- base::computeRestarts
[17:59:17.015]                           grepl <- base::grepl
[17:59:17.015]                           restarts <- computeRestarts(cond)
[17:59:17.015]                           for (restart in restarts) {
[17:59:17.015]                             name <- restart$name
[17:59:17.015]                             if (is.null(name)) 
[17:59:17.015]                               next
[17:59:17.015]                             if (!grepl(pattern, name)) 
[17:59:17.015]                               next
[17:59:17.015]                             invokeRestart(restart)
[17:59:17.015]                             muffled <- TRUE
[17:59:17.015]                             break
[17:59:17.015]                           }
[17:59:17.015]                         }
[17:59:17.015]                       }
[17:59:17.015]                       invisible(muffled)
[17:59:17.015]                     }
[17:59:17.015]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.015]                   }
[17:59:17.015]                 }
[17:59:17.015]             }
[17:59:17.015]         }))
[17:59:17.015]     }, error = function(ex) {
[17:59:17.015]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:17.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.015]                 ...future.rng), started = ...future.startTime, 
[17:59:17.015]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:17.015]             version = "1.8"), class = "FutureResult")
[17:59:17.015]     }, finally = {
[17:59:17.015]         if (!identical(...future.workdir, getwd())) 
[17:59:17.015]             setwd(...future.workdir)
[17:59:17.015]         {
[17:59:17.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:17.015]                 ...future.oldOptions$nwarnings <- NULL
[17:59:17.015]             }
[17:59:17.015]             base::options(...future.oldOptions)
[17:59:17.015]             if (.Platform$OS.type == "windows") {
[17:59:17.015]                 old_names <- names(...future.oldEnvVars)
[17:59:17.015]                 envs <- base::Sys.getenv()
[17:59:17.015]                 names <- names(envs)
[17:59:17.015]                 common <- intersect(names, old_names)
[17:59:17.015]                 added <- setdiff(names, old_names)
[17:59:17.015]                 removed <- setdiff(old_names, names)
[17:59:17.015]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:17.015]                   envs[common]]
[17:59:17.015]                 NAMES <- toupper(changed)
[17:59:17.015]                 args <- list()
[17:59:17.015]                 for (kk in seq_along(NAMES)) {
[17:59:17.015]                   name <- changed[[kk]]
[17:59:17.015]                   NAME <- NAMES[[kk]]
[17:59:17.015]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.015]                     next
[17:59:17.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.015]                 }
[17:59:17.015]                 NAMES <- toupper(added)
[17:59:17.015]                 for (kk in seq_along(NAMES)) {
[17:59:17.015]                   name <- added[[kk]]
[17:59:17.015]                   NAME <- NAMES[[kk]]
[17:59:17.015]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.015]                     next
[17:59:17.015]                   args[[name]] <- ""
[17:59:17.015]                 }
[17:59:17.015]                 NAMES <- toupper(removed)
[17:59:17.015]                 for (kk in seq_along(NAMES)) {
[17:59:17.015]                   name <- removed[[kk]]
[17:59:17.015]                   NAME <- NAMES[[kk]]
[17:59:17.015]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.015]                     next
[17:59:17.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.015]                 }
[17:59:17.015]                 if (length(args) > 0) 
[17:59:17.015]                   base::do.call(base::Sys.setenv, args = args)
[17:59:17.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:17.015]             }
[17:59:17.015]             else {
[17:59:17.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:17.015]             }
[17:59:17.015]             {
[17:59:17.015]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:17.015]                   0L) {
[17:59:17.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:17.015]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:17.015]                   base::options(opts)
[17:59:17.015]                 }
[17:59:17.015]                 {
[17:59:17.015]                   {
[17:59:17.015]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:17.015]                     NULL
[17:59:17.015]                   }
[17:59:17.015]                   options(future.plan = NULL)
[17:59:17.015]                   if (is.na(NA_character_)) 
[17:59:17.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:17.015]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:17.015]                     .init = FALSE)
[17:59:17.015]                 }
[17:59:17.015]             }
[17:59:17.015]         }
[17:59:17.015]     })
[17:59:17.015]     if (TRUE) {
[17:59:17.015]         base::sink(type = "output", split = FALSE)
[17:59:17.015]         if (TRUE) {
[17:59:17.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:17.015]         }
[17:59:17.015]         else {
[17:59:17.015]             ...future.result["stdout"] <- base::list(NULL)
[17:59:17.015]         }
[17:59:17.015]         base::close(...future.stdout)
[17:59:17.015]         ...future.stdout <- NULL
[17:59:17.015]     }
[17:59:17.015]     ...future.result$conditions <- ...future.conditions
[17:59:17.015]     ...future.result$finished <- base::Sys.time()
[17:59:17.015]     ...future.result
[17:59:17.015] }
[17:59:17.022] assign_globals() ...
[17:59:17.022] List of 5
[17:59:17.022]  $ future.call.arguments    : list()
[17:59:17.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.022]  $ ...future.FUN            :function (x, ...)  
[17:59:17.022]  $ ...future.elements_ii    :List of 1
[17:59:17.022]   ..$ : num [1:4] 2 4 6 8
[17:59:17.022]  $ ...future.seeds_ii       : NULL
[17:59:17.022]  $ ...future.globals.maxSize: num Inf
[17:59:17.022]  - attr(*, "resolved")= logi FALSE
[17:59:17.022]  - attr(*, "total_size")= num NA
[17:59:17.022]  - attr(*, "where")=List of 5
[17:59:17.022]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:17.022]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:17.022]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:17.022]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:17.022]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:17.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.022]  - attr(*, "already-done")= logi TRUE
[17:59:17.037] - copied ‘future.call.arguments’ to environment
[17:59:17.037] - copied ‘...future.FUN’ to environment
[17:59:17.037] - copied ‘...future.elements_ii’ to environment
[17:59:17.038] - copied ‘...future.seeds_ii’ to environment
[17:59:17.038] - copied ‘...future.globals.maxSize’ to environment
[17:59:17.038] assign_globals() ... done
[17:59:17.038] requestCore(): workers = 2
[17:59:17.042] MulticoreFuture started
[17:59:17.043] - Launch lazy future ... done
[17:59:17.043] run() for ‘MulticoreFuture’ ... done
[17:59:17.044] Created future:
[17:59:17.045] plan(): Setting new future strategy stack:
[17:59:17.045] List of future strategies:
[17:59:17.045] 1. sequential:
[17:59:17.045]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:17.045]    - tweaked: FALSE
[17:59:17.045]    - call: NULL
[17:59:17.047] plan(): nbrOfWorkers() = 1
[17:59:17.052] plan(): Setting new future strategy stack:
[17:59:17.053] List of future strategies:
[17:59:17.053] 1. multicore:
[17:59:17.053]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:17.053]    - tweaked: FALSE
[17:59:17.053]    - call: plan(strategy)
[17:59:17.044] MulticoreFuture:
[17:59:17.044] Label: ‘future_apply-2’
[17:59:17.044] Expression:
[17:59:17.044] {
[17:59:17.044]     do.call(function(...) {
[17:59:17.044]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.044]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.044]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.044]             on.exit(options(oopts), add = TRUE)
[17:59:17.044]         }
[17:59:17.044]         {
[17:59:17.044]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.044]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.044]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.044]             })
[17:59:17.044]         }
[17:59:17.044]     }, args = future.call.arguments)
[17:59:17.044] }
[17:59:17.044] Lazy evaluation: FALSE
[17:59:17.044] Asynchronous evaluation: TRUE
[17:59:17.044] Local evaluation: TRUE
[17:59:17.044] Environment: R_GlobalEnv
[17:59:17.044] Capture standard output: TRUE
[17:59:17.044] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:17.044] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:17.044] Packages: 1 packages (‘stats’)
[17:59:17.044] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:17.044] Resolved: FALSE
[17:59:17.044] Value: <not collected>
[17:59:17.044] Conditions captured: <none>
[17:59:17.044] Early signaling: FALSE
[17:59:17.044] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:17.044] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.060] Chunk #2 of 2 ... DONE
[17:59:17.062] plan(): nbrOfWorkers() = 2
[17:59:17.061] Launching 2 futures (chunks) ... DONE
[17:59:17.063] Resolving 2 futures (chunks) ...
[17:59:17.063] resolve() on list ...
[17:59:17.064]  recursive: 0
[17:59:17.064]  length: 2
[17:59:17.064] 
[17:59:17.066] Future #1
[17:59:17.066] result() for MulticoreFuture ...
[17:59:17.070] result() for MulticoreFuture ...
[17:59:17.070] result() for MulticoreFuture ... done
[17:59:17.071] result() for MulticoreFuture ... done
[17:59:17.072] result() for MulticoreFuture ...
[17:59:17.072] result() for MulticoreFuture ... done
[17:59:17.073] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:17.075] - nx: 2
[17:59:17.075] - relay: TRUE
[17:59:17.076] - stdout: TRUE
[17:59:17.076] - signal: TRUE
[17:59:17.076] - resignal: FALSE
[17:59:17.076] - force: TRUE
[17:59:17.077] - relayed: [n=2] FALSE, FALSE
[17:59:17.077] - queued futures: [n=2] FALSE, FALSE
[17:59:17.077]  - until=1
[17:59:17.078]  - relaying element #1
[17:59:17.078] result() for MulticoreFuture ...
[17:59:17.078] result() for MulticoreFuture ... done
[17:59:17.079] result() for MulticoreFuture ...
[17:59:17.079] result() for MulticoreFuture ... done
[17:59:17.080] result() for MulticoreFuture ...
[17:59:17.080] result() for MulticoreFuture ... done
[17:59:17.080] result() for MulticoreFuture ...
[17:59:17.081] result() for MulticoreFuture ... done
[17:59:17.081] - relayed: [n=2] TRUE, FALSE
[17:59:17.081] - queued futures: [n=2] TRUE, FALSE
[17:59:17.082] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:17.082]  length: 1 (resolved future 1)
[17:59:17.087] Future #2
[17:59:17.088] result() for MulticoreFuture ...
[17:59:17.094] result() for MulticoreFuture ...
[17:59:17.094] result() for MulticoreFuture ... done
[17:59:17.096] result() for MulticoreFuture ... done
[17:59:17.096] result() for MulticoreFuture ...
[17:59:17.097] result() for MulticoreFuture ... done
[17:59:17.097] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:17.098] - nx: 2
[17:59:17.098] - relay: TRUE
[17:59:17.098] - stdout: TRUE
[17:59:17.099] - signal: TRUE
[17:59:17.099] - resignal: FALSE
[17:59:17.099] - force: TRUE
[17:59:17.099] - relayed: [n=2] TRUE, FALSE
[17:59:17.099] - queued futures: [n=2] TRUE, FALSE
[17:59:17.100]  - until=2
[17:59:17.100]  - relaying element #2
[17:59:17.100] result() for MulticoreFuture ...
[17:59:17.101] result() for MulticoreFuture ... done
[17:59:17.101] result() for MulticoreFuture ...
[17:59:17.101] result() for MulticoreFuture ... done
[17:59:17.101] result() for MulticoreFuture ...
[17:59:17.102] result() for MulticoreFuture ... done
[17:59:17.102] result() for MulticoreFuture ...
[17:59:17.102] result() for MulticoreFuture ... done
[17:59:17.103] - relayed: [n=2] TRUE, TRUE
[17:59:17.103] - queued futures: [n=2] TRUE, TRUE
[17:59:17.103] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:17.103]  length: 0 (resolved future 2)
[17:59:17.104] Relaying remaining futures
[17:59:17.104] signalConditionsASAP(NULL, pos=0) ...
[17:59:17.104] - nx: 2
[17:59:17.104] - relay: TRUE
[17:59:17.104] - stdout: TRUE
[17:59:17.105] - signal: TRUE
[17:59:17.105] - resignal: FALSE
[17:59:17.105] - force: TRUE
[17:59:17.105] - relayed: [n=2] TRUE, TRUE
[17:59:17.106] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:17.106] - relayed: [n=2] TRUE, TRUE
[17:59:17.106] - queued futures: [n=2] TRUE, TRUE
[17:59:17.106] signalConditionsASAP(NULL, pos=0) ... done
[17:59:17.107] resolve() on list ... DONE
[17:59:17.107] result() for MulticoreFuture ...
[17:59:17.107] result() for MulticoreFuture ... done
[17:59:17.107] result() for MulticoreFuture ...
[17:59:17.108] result() for MulticoreFuture ... done
[17:59:17.108] result() for MulticoreFuture ...
[17:59:17.108] result() for MulticoreFuture ... done
[17:59:17.108] result() for MulticoreFuture ...
[17:59:17.108] result() for MulticoreFuture ... done
[17:59:17.109]  - Number of value chunks collected: 2
[17:59:17.109] Resolving 2 futures (chunks) ... DONE
[17:59:17.109] Reducing values from 2 chunks ...
[17:59:17.109]  - Number of values collected after concatenation: 2
[17:59:17.110]  - Number of values expected: 2
[17:59:17.110] Reducing values from 2 chunks ... DONE
[17:59:17.110] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:59:17.111] getGlobalsAndPackagesXApply() ...
[17:59:17.112]  - future.globals: TRUE
[17:59:17.112] getGlobalsAndPackages() ...
[17:59:17.112] Searching for globals...
[17:59:17.115] - globals found: [1] ‘FUN’
[17:59:17.115] Searching for globals ... DONE
[17:59:17.115] Resolving globals: FALSE
[17:59:17.116] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:17.117] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:17.117] - globals: [1] ‘FUN’
[17:59:17.118] 
[17:59:17.118] getGlobalsAndPackages() ... DONE
[17:59:17.118]  - globals found/used: [n=1] ‘FUN’
[17:59:17.118]  - needed namespaces: [n=0] 
[17:59:17.119] Finding globals ... DONE
[17:59:17.119]  - use_args: TRUE
[17:59:17.119]  - Getting '...' globals ...
[17:59:17.120] resolve() on list ...
[17:59:17.120]  recursive: 0
[17:59:17.120]  length: 1
[17:59:17.121]  elements: ‘...’
[17:59:17.121]  length: 0 (resolved future 1)
[17:59:17.121] resolve() on list ... DONE
[17:59:17.121]    - '...' content: [n=0] 
[17:59:17.122] List of 1
[17:59:17.122]  $ ...: list()
[17:59:17.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.122]  - attr(*, "where")=List of 1
[17:59:17.122]   ..$ ...:<environment: 0x560859d64c40> 
[17:59:17.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.122]  - attr(*, "resolved")= logi TRUE
[17:59:17.122]  - attr(*, "total_size")= num NA
[17:59:17.128]  - Getting '...' globals ... DONE
[17:59:17.129] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:17.129] List of 2
[17:59:17.129]  $ ...future.FUN:function (x)  
[17:59:17.129]  $ ...          : list()
[17:59:17.129]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.129]  - attr(*, "where")=List of 2
[17:59:17.129]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:17.129]   ..$ ...          :<environment: 0x560859d64c40> 
[17:59:17.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.129]  - attr(*, "resolved")= logi FALSE
[17:59:17.129]  - attr(*, "total_size")= num 848
[17:59:17.136] Packages to be attached in all futures: [n=0] 
[17:59:17.136] getGlobalsAndPackagesXApply() ... DONE
[17:59:17.142] future_lapply() ...
[17:59:17.150] Number of chunks: 2
[17:59:17.150] getGlobalsAndPackagesXApply() ...
[17:59:17.150]  - future.globals: <name-value list> with names ‘list()’
[17:59:17.151]  - use_args: TRUE
[17:59:17.151] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:17.151] List of 2
[17:59:17.151]  $ ...          : list()
[17:59:17.151]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.151]  $ ...future.FUN:function (x)  
[17:59:17.151]  - attr(*, "where")=List of 2
[17:59:17.151]   ..$ ...          :<environment: 0x560859d64c40> 
[17:59:17.151]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:17.151]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.151]  - attr(*, "resolved")= logi FALSE
[17:59:17.151]  - attr(*, "total_size")= num NA
[17:59:17.165] Packages to be attached in all futures: [n=0] 
[17:59:17.165] getGlobalsAndPackagesXApply() ... DONE
[17:59:17.166] Number of futures (= number of chunks): 2
[17:59:17.166] Launching 2 futures (chunks) ...
[17:59:17.166] Chunk #1 of 2 ...
[17:59:17.167]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:17.167]  - seeds: <none>
[17:59:17.167]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.167] getGlobalsAndPackages() ...
[17:59:17.167] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.168] Resolving globals: FALSE
[17:59:17.168] Tweak future expression to call with '...' arguments ...
[17:59:17.168] {
[17:59:17.168]     do.call(function(...) {
[17:59:17.168]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.168]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.168]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.168]             on.exit(options(oopts), add = TRUE)
[17:59:17.168]         }
[17:59:17.168]         {
[17:59:17.168]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.168]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.168]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.168]             })
[17:59:17.168]         }
[17:59:17.168]     }, args = future.call.arguments)
[17:59:17.168] }
[17:59:17.169] Tweak future expression to call with '...' arguments ... DONE
[17:59:17.170] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.170] 
[17:59:17.170] getGlobalsAndPackages() ... DONE
[17:59:17.171] run() for ‘Future’ ...
[17:59:17.171] - state: ‘created’
[17:59:17.171] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:17.177] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.177] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:17.178]   - Field: ‘label’
[17:59:17.178]   - Field: ‘local’
[17:59:17.178]   - Field: ‘owner’
[17:59:17.178]   - Field: ‘envir’
[17:59:17.178]   - Field: ‘workers’
[17:59:17.179]   - Field: ‘packages’
[17:59:17.179]   - Field: ‘gc’
[17:59:17.179]   - Field: ‘job’
[17:59:17.179]   - Field: ‘conditions’
[17:59:17.179]   - Field: ‘expr’
[17:59:17.180]   - Field: ‘uuid’
[17:59:17.180]   - Field: ‘seed’
[17:59:17.180]   - Field: ‘version’
[17:59:17.180]   - Field: ‘result’
[17:59:17.180]   - Field: ‘asynchronous’
[17:59:17.181]   - Field: ‘calls’
[17:59:17.181]   - Field: ‘globals’
[17:59:17.181]   - Field: ‘stdout’
[17:59:17.181]   - Field: ‘earlySignal’
[17:59:17.181]   - Field: ‘lazy’
[17:59:17.182]   - Field: ‘state’
[17:59:17.182] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:17.182] - Launch lazy future ...
[17:59:17.183] Packages needed by the future expression (n = 0): <none>
[17:59:17.183] Packages needed by future strategies (n = 0): <none>
[17:59:17.184] {
[17:59:17.184]     {
[17:59:17.184]         {
[17:59:17.184]             ...future.startTime <- base::Sys.time()
[17:59:17.184]             {
[17:59:17.184]                 {
[17:59:17.184]                   {
[17:59:17.184]                     {
[17:59:17.184]                       base::local({
[17:59:17.184]                         has_future <- base::requireNamespace("future", 
[17:59:17.184]                           quietly = TRUE)
[17:59:17.184]                         if (has_future) {
[17:59:17.184]                           ns <- base::getNamespace("future")
[17:59:17.184]                           version <- ns[[".package"]][["version"]]
[17:59:17.184]                           if (is.null(version)) 
[17:59:17.184]                             version <- utils::packageVersion("future")
[17:59:17.184]                         }
[17:59:17.184]                         else {
[17:59:17.184]                           version <- NULL
[17:59:17.184]                         }
[17:59:17.184]                         if (!has_future || version < "1.8.0") {
[17:59:17.184]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:17.184]                             "", base::R.version$version.string), 
[17:59:17.184]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:17.184]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:17.184]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:17.184]                               "release", "version")], collapse = " "), 
[17:59:17.184]                             hostname = base::Sys.info()[["nodename"]])
[17:59:17.184]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:17.184]                             info)
[17:59:17.184]                           info <- base::paste(info, collapse = "; ")
[17:59:17.184]                           if (!has_future) {
[17:59:17.184]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:17.184]                               info)
[17:59:17.184]                           }
[17:59:17.184]                           else {
[17:59:17.184]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:17.184]                               info, version)
[17:59:17.184]                           }
[17:59:17.184]                           base::stop(msg)
[17:59:17.184]                         }
[17:59:17.184]                       })
[17:59:17.184]                     }
[17:59:17.184]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:17.184]                     base::options(mc.cores = 1L)
[17:59:17.184]                   }
[17:59:17.184]                   ...future.strategy.old <- future::plan("list")
[17:59:17.184]                   options(future.plan = NULL)
[17:59:17.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:17.184]                 }
[17:59:17.184]                 ...future.workdir <- getwd()
[17:59:17.184]             }
[17:59:17.184]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:17.184]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:17.184]         }
[17:59:17.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:17.184]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:17.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:17.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:17.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:17.184]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:17.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:17.184]             base::names(...future.oldOptions))
[17:59:17.184]     }
[17:59:17.184]     if (FALSE) {
[17:59:17.184]     }
[17:59:17.184]     else {
[17:59:17.184]         if (TRUE) {
[17:59:17.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:17.184]                 open = "w")
[17:59:17.184]         }
[17:59:17.184]         else {
[17:59:17.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:17.184]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:17.184]         }
[17:59:17.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:17.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:17.184]             base::sink(type = "output", split = FALSE)
[17:59:17.184]             base::close(...future.stdout)
[17:59:17.184]         }, add = TRUE)
[17:59:17.184]     }
[17:59:17.184]     ...future.frame <- base::sys.nframe()
[17:59:17.184]     ...future.conditions <- base::list()
[17:59:17.184]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:17.184]     if (FALSE) {
[17:59:17.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:17.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:17.184]     }
[17:59:17.184]     ...future.result <- base::tryCatch({
[17:59:17.184]         base::withCallingHandlers({
[17:59:17.184]             ...future.value <- base::withVisible(base::local({
[17:59:17.184]                 withCallingHandlers({
[17:59:17.184]                   {
[17:59:17.184]                     do.call(function(...) {
[17:59:17.184]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.184]                       if (!identical(...future.globals.maxSize.org, 
[17:59:17.184]                         ...future.globals.maxSize)) {
[17:59:17.184]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.184]                         on.exit(options(oopts), add = TRUE)
[17:59:17.184]                       }
[17:59:17.184]                       {
[17:59:17.184]                         lapply(seq_along(...future.elements_ii), 
[17:59:17.184]                           FUN = function(jj) {
[17:59:17.184]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.184]                             ...future.FUN(...future.X_jj, ...)
[17:59:17.184]                           })
[17:59:17.184]                       }
[17:59:17.184]                     }, args = future.call.arguments)
[17:59:17.184]                   }
[17:59:17.184]                 }, immediateCondition = function(cond) {
[17:59:17.184]                   save_rds <- function (object, pathname, ...) 
[17:59:17.184]                   {
[17:59:17.184]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:17.184]                     if (file_test("-f", pathname_tmp)) {
[17:59:17.184]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.184]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:17.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.184]                         fi_tmp[["mtime"]])
[17:59:17.184]                     }
[17:59:17.184]                     tryCatch({
[17:59:17.184]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:17.184]                     }, error = function(ex) {
[17:59:17.184]                       msg <- conditionMessage(ex)
[17:59:17.184]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.184]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:17.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.184]                         fi_tmp[["mtime"]], msg)
[17:59:17.184]                       ex$message <- msg
[17:59:17.184]                       stop(ex)
[17:59:17.184]                     })
[17:59:17.184]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:17.184]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:17.184]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:17.184]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.184]                       fi <- file.info(pathname)
[17:59:17.184]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:17.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.184]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:17.184]                         fi[["size"]], fi[["mtime"]])
[17:59:17.184]                       stop(msg)
[17:59:17.184]                     }
[17:59:17.184]                     invisible(pathname)
[17:59:17.184]                   }
[17:59:17.184]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:17.184]                     rootPath = tempdir()) 
[17:59:17.184]                   {
[17:59:17.184]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:17.184]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:17.184]                       tmpdir = path, fileext = ".rds")
[17:59:17.184]                     save_rds(obj, file)
[17:59:17.184]                   }
[17:59:17.184]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:17.184]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.184]                   {
[17:59:17.184]                     inherits <- base::inherits
[17:59:17.184]                     invokeRestart <- base::invokeRestart
[17:59:17.184]                     is.null <- base::is.null
[17:59:17.184]                     muffled <- FALSE
[17:59:17.184]                     if (inherits(cond, "message")) {
[17:59:17.184]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:17.184]                       if (muffled) 
[17:59:17.184]                         invokeRestart("muffleMessage")
[17:59:17.184]                     }
[17:59:17.184]                     else if (inherits(cond, "warning")) {
[17:59:17.184]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:17.184]                       if (muffled) 
[17:59:17.184]                         invokeRestart("muffleWarning")
[17:59:17.184]                     }
[17:59:17.184]                     else if (inherits(cond, "condition")) {
[17:59:17.184]                       if (!is.null(pattern)) {
[17:59:17.184]                         computeRestarts <- base::computeRestarts
[17:59:17.184]                         grepl <- base::grepl
[17:59:17.184]                         restarts <- computeRestarts(cond)
[17:59:17.184]                         for (restart in restarts) {
[17:59:17.184]                           name <- restart$name
[17:59:17.184]                           if (is.null(name)) 
[17:59:17.184]                             next
[17:59:17.184]                           if (!grepl(pattern, name)) 
[17:59:17.184]                             next
[17:59:17.184]                           invokeRestart(restart)
[17:59:17.184]                           muffled <- TRUE
[17:59:17.184]                           break
[17:59:17.184]                         }
[17:59:17.184]                       }
[17:59:17.184]                     }
[17:59:17.184]                     invisible(muffled)
[17:59:17.184]                   }
[17:59:17.184]                   muffleCondition(cond)
[17:59:17.184]                 })
[17:59:17.184]             }))
[17:59:17.184]             future::FutureResult(value = ...future.value$value, 
[17:59:17.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.184]                   ...future.rng), globalenv = if (FALSE) 
[17:59:17.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:17.184]                     ...future.globalenv.names))
[17:59:17.184]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:17.184]         }, condition = base::local({
[17:59:17.184]             c <- base::c
[17:59:17.184]             inherits <- base::inherits
[17:59:17.184]             invokeRestart <- base::invokeRestart
[17:59:17.184]             length <- base::length
[17:59:17.184]             list <- base::list
[17:59:17.184]             seq.int <- base::seq.int
[17:59:17.184]             signalCondition <- base::signalCondition
[17:59:17.184]             sys.calls <- base::sys.calls
[17:59:17.184]             `[[` <- base::`[[`
[17:59:17.184]             `+` <- base::`+`
[17:59:17.184]             `<<-` <- base::`<<-`
[17:59:17.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:17.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:17.184]                   3L)]
[17:59:17.184]             }
[17:59:17.184]             function(cond) {
[17:59:17.184]                 is_error <- inherits(cond, "error")
[17:59:17.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:17.184]                   NULL)
[17:59:17.184]                 if (is_error) {
[17:59:17.184]                   sessionInformation <- function() {
[17:59:17.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:17.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:17.184]                       search = base::search(), system = base::Sys.info())
[17:59:17.184]                   }
[17:59:17.184]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:17.184]                     cond$call), session = sessionInformation(), 
[17:59:17.184]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:17.184]                   signalCondition(cond)
[17:59:17.184]                 }
[17:59:17.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:17.184]                 "immediateCondition"))) {
[17:59:17.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:17.184]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:17.184]                   if (TRUE && !signal) {
[17:59:17.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.184]                     {
[17:59:17.184]                       inherits <- base::inherits
[17:59:17.184]                       invokeRestart <- base::invokeRestart
[17:59:17.184]                       is.null <- base::is.null
[17:59:17.184]                       muffled <- FALSE
[17:59:17.184]                       if (inherits(cond, "message")) {
[17:59:17.184]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.184]                         if (muffled) 
[17:59:17.184]                           invokeRestart("muffleMessage")
[17:59:17.184]                       }
[17:59:17.184]                       else if (inherits(cond, "warning")) {
[17:59:17.184]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.184]                         if (muffled) 
[17:59:17.184]                           invokeRestart("muffleWarning")
[17:59:17.184]                       }
[17:59:17.184]                       else if (inherits(cond, "condition")) {
[17:59:17.184]                         if (!is.null(pattern)) {
[17:59:17.184]                           computeRestarts <- base::computeRestarts
[17:59:17.184]                           grepl <- base::grepl
[17:59:17.184]                           restarts <- computeRestarts(cond)
[17:59:17.184]                           for (restart in restarts) {
[17:59:17.184]                             name <- restart$name
[17:59:17.184]                             if (is.null(name)) 
[17:59:17.184]                               next
[17:59:17.184]                             if (!grepl(pattern, name)) 
[17:59:17.184]                               next
[17:59:17.184]                             invokeRestart(restart)
[17:59:17.184]                             muffled <- TRUE
[17:59:17.184]                             break
[17:59:17.184]                           }
[17:59:17.184]                         }
[17:59:17.184]                       }
[17:59:17.184]                       invisible(muffled)
[17:59:17.184]                     }
[17:59:17.184]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.184]                   }
[17:59:17.184]                 }
[17:59:17.184]                 else {
[17:59:17.184]                   if (TRUE) {
[17:59:17.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.184]                     {
[17:59:17.184]                       inherits <- base::inherits
[17:59:17.184]                       invokeRestart <- base::invokeRestart
[17:59:17.184]                       is.null <- base::is.null
[17:59:17.184]                       muffled <- FALSE
[17:59:17.184]                       if (inherits(cond, "message")) {
[17:59:17.184]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.184]                         if (muffled) 
[17:59:17.184]                           invokeRestart("muffleMessage")
[17:59:17.184]                       }
[17:59:17.184]                       else if (inherits(cond, "warning")) {
[17:59:17.184]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.184]                         if (muffled) 
[17:59:17.184]                           invokeRestart("muffleWarning")
[17:59:17.184]                       }
[17:59:17.184]                       else if (inherits(cond, "condition")) {
[17:59:17.184]                         if (!is.null(pattern)) {
[17:59:17.184]                           computeRestarts <- base::computeRestarts
[17:59:17.184]                           grepl <- base::grepl
[17:59:17.184]                           restarts <- computeRestarts(cond)
[17:59:17.184]                           for (restart in restarts) {
[17:59:17.184]                             name <- restart$name
[17:59:17.184]                             if (is.null(name)) 
[17:59:17.184]                               next
[17:59:17.184]                             if (!grepl(pattern, name)) 
[17:59:17.184]                               next
[17:59:17.184]                             invokeRestart(restart)
[17:59:17.184]                             muffled <- TRUE
[17:59:17.184]                             break
[17:59:17.184]                           }
[17:59:17.184]                         }
[17:59:17.184]                       }
[17:59:17.184]                       invisible(muffled)
[17:59:17.184]                     }
[17:59:17.184]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.184]                   }
[17:59:17.184]                 }
[17:59:17.184]             }
[17:59:17.184]         }))
[17:59:17.184]     }, error = function(ex) {
[17:59:17.184]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:17.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.184]                 ...future.rng), started = ...future.startTime, 
[17:59:17.184]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:17.184]             version = "1.8"), class = "FutureResult")
[17:59:17.184]     }, finally = {
[17:59:17.184]         if (!identical(...future.workdir, getwd())) 
[17:59:17.184]             setwd(...future.workdir)
[17:59:17.184]         {
[17:59:17.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:17.184]                 ...future.oldOptions$nwarnings <- NULL
[17:59:17.184]             }
[17:59:17.184]             base::options(...future.oldOptions)
[17:59:17.184]             if (.Platform$OS.type == "windows") {
[17:59:17.184]                 old_names <- names(...future.oldEnvVars)
[17:59:17.184]                 envs <- base::Sys.getenv()
[17:59:17.184]                 names <- names(envs)
[17:59:17.184]                 common <- intersect(names, old_names)
[17:59:17.184]                 added <- setdiff(names, old_names)
[17:59:17.184]                 removed <- setdiff(old_names, names)
[17:59:17.184]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:17.184]                   envs[common]]
[17:59:17.184]                 NAMES <- toupper(changed)
[17:59:17.184]                 args <- list()
[17:59:17.184]                 for (kk in seq_along(NAMES)) {
[17:59:17.184]                   name <- changed[[kk]]
[17:59:17.184]                   NAME <- NAMES[[kk]]
[17:59:17.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.184]                     next
[17:59:17.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.184]                 }
[17:59:17.184]                 NAMES <- toupper(added)
[17:59:17.184]                 for (kk in seq_along(NAMES)) {
[17:59:17.184]                   name <- added[[kk]]
[17:59:17.184]                   NAME <- NAMES[[kk]]
[17:59:17.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.184]                     next
[17:59:17.184]                   args[[name]] <- ""
[17:59:17.184]                 }
[17:59:17.184]                 NAMES <- toupper(removed)
[17:59:17.184]                 for (kk in seq_along(NAMES)) {
[17:59:17.184]                   name <- removed[[kk]]
[17:59:17.184]                   NAME <- NAMES[[kk]]
[17:59:17.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.184]                     next
[17:59:17.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.184]                 }
[17:59:17.184]                 if (length(args) > 0) 
[17:59:17.184]                   base::do.call(base::Sys.setenv, args = args)
[17:59:17.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:17.184]             }
[17:59:17.184]             else {
[17:59:17.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:17.184]             }
[17:59:17.184]             {
[17:59:17.184]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:17.184]                   0L) {
[17:59:17.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:17.184]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:17.184]                   base::options(opts)
[17:59:17.184]                 }
[17:59:17.184]                 {
[17:59:17.184]                   {
[17:59:17.184]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:17.184]                     NULL
[17:59:17.184]                   }
[17:59:17.184]                   options(future.plan = NULL)
[17:59:17.184]                   if (is.na(NA_character_)) 
[17:59:17.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:17.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:17.184]                     .init = FALSE)
[17:59:17.184]                 }
[17:59:17.184]             }
[17:59:17.184]         }
[17:59:17.184]     })
[17:59:17.184]     if (TRUE) {
[17:59:17.184]         base::sink(type = "output", split = FALSE)
[17:59:17.184]         if (TRUE) {
[17:59:17.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:17.184]         }
[17:59:17.184]         else {
[17:59:17.184]             ...future.result["stdout"] <- base::list(NULL)
[17:59:17.184]         }
[17:59:17.184]         base::close(...future.stdout)
[17:59:17.184]         ...future.stdout <- NULL
[17:59:17.184]     }
[17:59:17.184]     ...future.result$conditions <- ...future.conditions
[17:59:17.184]     ...future.result$finished <- base::Sys.time()
[17:59:17.184]     ...future.result
[17:59:17.184] }
[17:59:17.188] assign_globals() ...
[17:59:17.188] List of 5
[17:59:17.188]  $ future.call.arguments    : list()
[17:59:17.188]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.188]  $ ...future.FUN            :function (x)  
[17:59:17.188]  $ ...future.elements_ii    :List of 1
[17:59:17.188]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:59:17.188]  $ ...future.seeds_ii       : NULL
[17:59:17.188]  $ ...future.globals.maxSize: num Inf
[17:59:17.188]  - attr(*, "resolved")= logi FALSE
[17:59:17.188]  - attr(*, "total_size")= num NA
[17:59:17.188]  - attr(*, "where")=List of 5
[17:59:17.188]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:17.188]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:17.188]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:17.188]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:17.188]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:17.188]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.188]  - attr(*, "already-done")= logi TRUE
[17:59:17.198] - copied ‘future.call.arguments’ to environment
[17:59:17.198] - copied ‘...future.FUN’ to environment
[17:59:17.199] - copied ‘...future.elements_ii’ to environment
[17:59:17.199] - copied ‘...future.seeds_ii’ to environment
[17:59:17.199] - copied ‘...future.globals.maxSize’ to environment
[17:59:17.199] assign_globals() ... done
[17:59:17.200] requestCore(): workers = 2
[17:59:17.203] MulticoreFuture started
[17:59:17.204] - Launch lazy future ... done
[17:59:17.204] run() for ‘MulticoreFuture’ ... done
[17:59:17.205] Created future:
[17:59:17.208] plan(): Setting new future strategy stack:
[17:59:17.208] List of future strategies:
[17:59:17.208] 1. sequential:
[17:59:17.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:17.208]    - tweaked: FALSE
[17:59:17.208]    - call: NULL
[17:59:17.211] plan(): nbrOfWorkers() = 1
[17:59:17.215] plan(): Setting new future strategy stack:
[17:59:17.215] List of future strategies:
[17:59:17.215] 1. multicore:
[17:59:17.215]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:17.215]    - tweaked: FALSE
[17:59:17.215]    - call: plan(strategy)
[17:59:17.205] MulticoreFuture:
[17:59:17.205] Label: ‘future_apply-1’
[17:59:17.205] Expression:
[17:59:17.205] {
[17:59:17.205]     do.call(function(...) {
[17:59:17.205]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.205]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.205]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.205]             on.exit(options(oopts), add = TRUE)
[17:59:17.205]         }
[17:59:17.205]         {
[17:59:17.205]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.205]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.205]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.205]             })
[17:59:17.205]         }
[17:59:17.205]     }, args = future.call.arguments)
[17:59:17.205] }
[17:59:17.205] Lazy evaluation: FALSE
[17:59:17.205] Asynchronous evaluation: TRUE
[17:59:17.205] Local evaluation: TRUE
[17:59:17.205] Environment: R_GlobalEnv
[17:59:17.205] Capture standard output: TRUE
[17:59:17.205] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:17.205] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:17.205] Packages: <none>
[17:59:17.205] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:17.205] Resolved: FALSE
[17:59:17.205] Value: <not collected>
[17:59:17.205] Conditions captured: <none>
[17:59:17.205] Early signaling: FALSE
[17:59:17.205] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:17.205] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.222] Chunk #1 of 2 ... DONE
[17:59:17.223] Chunk #2 of 2 ...
[17:59:17.225]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:17.226]  - seeds: <none>
[17:59:17.226]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.226] getGlobalsAndPackages() ...
[17:59:17.229] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.229] Resolving globals: FALSE
[17:59:17.230] Tweak future expression to call with '...' arguments ...
[17:59:17.228] plan(): nbrOfWorkers() = 2
[17:59:17.230] {
[17:59:17.230]     do.call(function(...) {
[17:59:17.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.230]             on.exit(options(oopts), add = TRUE)
[17:59:17.230]         }
[17:59:17.230]         {
[17:59:17.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.230]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.230]             })
[17:59:17.230]         }
[17:59:17.230]     }, args = future.call.arguments)
[17:59:17.230] }
[17:59:17.231] Tweak future expression to call with '...' arguments ... DONE
[17:59:17.232] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.232] 
[17:59:17.233] getGlobalsAndPackages() ... DONE
[17:59:17.234] run() for ‘Future’ ...
[17:59:17.234] - state: ‘created’
[17:59:17.234] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:17.242] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.243] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:17.243]   - Field: ‘label’
[17:59:17.243]   - Field: ‘local’
[17:59:17.244]   - Field: ‘owner’
[17:59:17.244]   - Field: ‘envir’
[17:59:17.244]   - Field: ‘workers’
[17:59:17.245]   - Field: ‘packages’
[17:59:17.245]   - Field: ‘gc’
[17:59:17.245]   - Field: ‘job’
[17:59:17.246]   - Field: ‘conditions’
[17:59:17.246]   - Field: ‘expr’
[17:59:17.246]   - Field: ‘uuid’
[17:59:17.247]   - Field: ‘seed’
[17:59:17.247]   - Field: ‘version’
[17:59:17.247]   - Field: ‘result’
[17:59:17.247]   - Field: ‘asynchronous’
[17:59:17.248]   - Field: ‘calls’
[17:59:17.248]   - Field: ‘globals’
[17:59:17.248]   - Field: ‘stdout’
[17:59:17.249]   - Field: ‘earlySignal’
[17:59:17.249]   - Field: ‘lazy’
[17:59:17.254]   - Field: ‘state’
[17:59:17.254] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:17.255] - Launch lazy future ...
[17:59:17.257] Packages needed by the future expression (n = 0): <none>
[17:59:17.258] Packages needed by future strategies (n = 0): <none>
[17:59:17.260] {
[17:59:17.260]     {
[17:59:17.260]         {
[17:59:17.260]             ...future.startTime <- base::Sys.time()
[17:59:17.260]             {
[17:59:17.260]                 {
[17:59:17.260]                   {
[17:59:17.260]                     {
[17:59:17.260]                       base::local({
[17:59:17.260]                         has_future <- base::requireNamespace("future", 
[17:59:17.260]                           quietly = TRUE)
[17:59:17.260]                         if (has_future) {
[17:59:17.260]                           ns <- base::getNamespace("future")
[17:59:17.260]                           version <- ns[[".package"]][["version"]]
[17:59:17.260]                           if (is.null(version)) 
[17:59:17.260]                             version <- utils::packageVersion("future")
[17:59:17.260]                         }
[17:59:17.260]                         else {
[17:59:17.260]                           version <- NULL
[17:59:17.260]                         }
[17:59:17.260]                         if (!has_future || version < "1.8.0") {
[17:59:17.260]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:17.260]                             "", base::R.version$version.string), 
[17:59:17.260]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:17.260]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:17.260]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:17.260]                               "release", "version")], collapse = " "), 
[17:59:17.260]                             hostname = base::Sys.info()[["nodename"]])
[17:59:17.260]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:17.260]                             info)
[17:59:17.260]                           info <- base::paste(info, collapse = "; ")
[17:59:17.260]                           if (!has_future) {
[17:59:17.260]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:17.260]                               info)
[17:59:17.260]                           }
[17:59:17.260]                           else {
[17:59:17.260]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:17.260]                               info, version)
[17:59:17.260]                           }
[17:59:17.260]                           base::stop(msg)
[17:59:17.260]                         }
[17:59:17.260]                       })
[17:59:17.260]                     }
[17:59:17.260]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:17.260]                     base::options(mc.cores = 1L)
[17:59:17.260]                   }
[17:59:17.260]                   ...future.strategy.old <- future::plan("list")
[17:59:17.260]                   options(future.plan = NULL)
[17:59:17.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:17.260]                 }
[17:59:17.260]                 ...future.workdir <- getwd()
[17:59:17.260]             }
[17:59:17.260]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:17.260]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:17.260]         }
[17:59:17.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:17.260]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:17.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:17.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:17.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:17.260]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:17.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:17.260]             base::names(...future.oldOptions))
[17:59:17.260]     }
[17:59:17.260]     if (FALSE) {
[17:59:17.260]     }
[17:59:17.260]     else {
[17:59:17.260]         if (TRUE) {
[17:59:17.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:17.260]                 open = "w")
[17:59:17.260]         }
[17:59:17.260]         else {
[17:59:17.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:17.260]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:17.260]         }
[17:59:17.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:17.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:17.260]             base::sink(type = "output", split = FALSE)
[17:59:17.260]             base::close(...future.stdout)
[17:59:17.260]         }, add = TRUE)
[17:59:17.260]     }
[17:59:17.260]     ...future.frame <- base::sys.nframe()
[17:59:17.260]     ...future.conditions <- base::list()
[17:59:17.260]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:17.260]     if (FALSE) {
[17:59:17.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:17.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:17.260]     }
[17:59:17.260]     ...future.result <- base::tryCatch({
[17:59:17.260]         base::withCallingHandlers({
[17:59:17.260]             ...future.value <- base::withVisible(base::local({
[17:59:17.260]                 withCallingHandlers({
[17:59:17.260]                   {
[17:59:17.260]                     do.call(function(...) {
[17:59:17.260]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.260]                       if (!identical(...future.globals.maxSize.org, 
[17:59:17.260]                         ...future.globals.maxSize)) {
[17:59:17.260]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.260]                         on.exit(options(oopts), add = TRUE)
[17:59:17.260]                       }
[17:59:17.260]                       {
[17:59:17.260]                         lapply(seq_along(...future.elements_ii), 
[17:59:17.260]                           FUN = function(jj) {
[17:59:17.260]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.260]                             ...future.FUN(...future.X_jj, ...)
[17:59:17.260]                           })
[17:59:17.260]                       }
[17:59:17.260]                     }, args = future.call.arguments)
[17:59:17.260]                   }
[17:59:17.260]                 }, immediateCondition = function(cond) {
[17:59:17.260]                   save_rds <- function (object, pathname, ...) 
[17:59:17.260]                   {
[17:59:17.260]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:17.260]                     if (file_test("-f", pathname_tmp)) {
[17:59:17.260]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.260]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:17.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.260]                         fi_tmp[["mtime"]])
[17:59:17.260]                     }
[17:59:17.260]                     tryCatch({
[17:59:17.260]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:17.260]                     }, error = function(ex) {
[17:59:17.260]                       msg <- conditionMessage(ex)
[17:59:17.260]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.260]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:17.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.260]                         fi_tmp[["mtime"]], msg)
[17:59:17.260]                       ex$message <- msg
[17:59:17.260]                       stop(ex)
[17:59:17.260]                     })
[17:59:17.260]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:17.260]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:17.260]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:17.260]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.260]                       fi <- file.info(pathname)
[17:59:17.260]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:17.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.260]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:17.260]                         fi[["size"]], fi[["mtime"]])
[17:59:17.260]                       stop(msg)
[17:59:17.260]                     }
[17:59:17.260]                     invisible(pathname)
[17:59:17.260]                   }
[17:59:17.260]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:17.260]                     rootPath = tempdir()) 
[17:59:17.260]                   {
[17:59:17.260]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:17.260]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:17.260]                       tmpdir = path, fileext = ".rds")
[17:59:17.260]                     save_rds(obj, file)
[17:59:17.260]                   }
[17:59:17.260]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:17.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.260]                   {
[17:59:17.260]                     inherits <- base::inherits
[17:59:17.260]                     invokeRestart <- base::invokeRestart
[17:59:17.260]                     is.null <- base::is.null
[17:59:17.260]                     muffled <- FALSE
[17:59:17.260]                     if (inherits(cond, "message")) {
[17:59:17.260]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:17.260]                       if (muffled) 
[17:59:17.260]                         invokeRestart("muffleMessage")
[17:59:17.260]                     }
[17:59:17.260]                     else if (inherits(cond, "warning")) {
[17:59:17.260]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:17.260]                       if (muffled) 
[17:59:17.260]                         invokeRestart("muffleWarning")
[17:59:17.260]                     }
[17:59:17.260]                     else if (inherits(cond, "condition")) {
[17:59:17.260]                       if (!is.null(pattern)) {
[17:59:17.260]                         computeRestarts <- base::computeRestarts
[17:59:17.260]                         grepl <- base::grepl
[17:59:17.260]                         restarts <- computeRestarts(cond)
[17:59:17.260]                         for (restart in restarts) {
[17:59:17.260]                           name <- restart$name
[17:59:17.260]                           if (is.null(name)) 
[17:59:17.260]                             next
[17:59:17.260]                           if (!grepl(pattern, name)) 
[17:59:17.260]                             next
[17:59:17.260]                           invokeRestart(restart)
[17:59:17.260]                           muffled <- TRUE
[17:59:17.260]                           break
[17:59:17.260]                         }
[17:59:17.260]                       }
[17:59:17.260]                     }
[17:59:17.260]                     invisible(muffled)
[17:59:17.260]                   }
[17:59:17.260]                   muffleCondition(cond)
[17:59:17.260]                 })
[17:59:17.260]             }))
[17:59:17.260]             future::FutureResult(value = ...future.value$value, 
[17:59:17.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.260]                   ...future.rng), globalenv = if (FALSE) 
[17:59:17.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:17.260]                     ...future.globalenv.names))
[17:59:17.260]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:17.260]         }, condition = base::local({
[17:59:17.260]             c <- base::c
[17:59:17.260]             inherits <- base::inherits
[17:59:17.260]             invokeRestart <- base::invokeRestart
[17:59:17.260]             length <- base::length
[17:59:17.260]             list <- base::list
[17:59:17.260]             seq.int <- base::seq.int
[17:59:17.260]             signalCondition <- base::signalCondition
[17:59:17.260]             sys.calls <- base::sys.calls
[17:59:17.260]             `[[` <- base::`[[`
[17:59:17.260]             `+` <- base::`+`
[17:59:17.260]             `<<-` <- base::`<<-`
[17:59:17.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:17.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:17.260]                   3L)]
[17:59:17.260]             }
[17:59:17.260]             function(cond) {
[17:59:17.260]                 is_error <- inherits(cond, "error")
[17:59:17.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:17.260]                   NULL)
[17:59:17.260]                 if (is_error) {
[17:59:17.260]                   sessionInformation <- function() {
[17:59:17.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:17.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:17.260]                       search = base::search(), system = base::Sys.info())
[17:59:17.260]                   }
[17:59:17.260]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:17.260]                     cond$call), session = sessionInformation(), 
[17:59:17.260]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:17.260]                   signalCondition(cond)
[17:59:17.260]                 }
[17:59:17.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:17.260]                 "immediateCondition"))) {
[17:59:17.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:17.260]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:17.260]                   if (TRUE && !signal) {
[17:59:17.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.260]                     {
[17:59:17.260]                       inherits <- base::inherits
[17:59:17.260]                       invokeRestart <- base::invokeRestart
[17:59:17.260]                       is.null <- base::is.null
[17:59:17.260]                       muffled <- FALSE
[17:59:17.260]                       if (inherits(cond, "message")) {
[17:59:17.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.260]                         if (muffled) 
[17:59:17.260]                           invokeRestart("muffleMessage")
[17:59:17.260]                       }
[17:59:17.260]                       else if (inherits(cond, "warning")) {
[17:59:17.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.260]                         if (muffled) 
[17:59:17.260]                           invokeRestart("muffleWarning")
[17:59:17.260]                       }
[17:59:17.260]                       else if (inherits(cond, "condition")) {
[17:59:17.260]                         if (!is.null(pattern)) {
[17:59:17.260]                           computeRestarts <- base::computeRestarts
[17:59:17.260]                           grepl <- base::grepl
[17:59:17.260]                           restarts <- computeRestarts(cond)
[17:59:17.260]                           for (restart in restarts) {
[17:59:17.260]                             name <- restart$name
[17:59:17.260]                             if (is.null(name)) 
[17:59:17.260]                               next
[17:59:17.260]                             if (!grepl(pattern, name)) 
[17:59:17.260]                               next
[17:59:17.260]                             invokeRestart(restart)
[17:59:17.260]                             muffled <- TRUE
[17:59:17.260]                             break
[17:59:17.260]                           }
[17:59:17.260]                         }
[17:59:17.260]                       }
[17:59:17.260]                       invisible(muffled)
[17:59:17.260]                     }
[17:59:17.260]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.260]                   }
[17:59:17.260]                 }
[17:59:17.260]                 else {
[17:59:17.260]                   if (TRUE) {
[17:59:17.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.260]                     {
[17:59:17.260]                       inherits <- base::inherits
[17:59:17.260]                       invokeRestart <- base::invokeRestart
[17:59:17.260]                       is.null <- base::is.null
[17:59:17.260]                       muffled <- FALSE
[17:59:17.260]                       if (inherits(cond, "message")) {
[17:59:17.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.260]                         if (muffled) 
[17:59:17.260]                           invokeRestart("muffleMessage")
[17:59:17.260]                       }
[17:59:17.260]                       else if (inherits(cond, "warning")) {
[17:59:17.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.260]                         if (muffled) 
[17:59:17.260]                           invokeRestart("muffleWarning")
[17:59:17.260]                       }
[17:59:17.260]                       else if (inherits(cond, "condition")) {
[17:59:17.260]                         if (!is.null(pattern)) {
[17:59:17.260]                           computeRestarts <- base::computeRestarts
[17:59:17.260]                           grepl <- base::grepl
[17:59:17.260]                           restarts <- computeRestarts(cond)
[17:59:17.260]                           for (restart in restarts) {
[17:59:17.260]                             name <- restart$name
[17:59:17.260]                             if (is.null(name)) 
[17:59:17.260]                               next
[17:59:17.260]                             if (!grepl(pattern, name)) 
[17:59:17.260]                               next
[17:59:17.260]                             invokeRestart(restart)
[17:59:17.260]                             muffled <- TRUE
[17:59:17.260]                             break
[17:59:17.260]                           }
[17:59:17.260]                         }
[17:59:17.260]                       }
[17:59:17.260]                       invisible(muffled)
[17:59:17.260]                     }
[17:59:17.260]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.260]                   }
[17:59:17.260]                 }
[17:59:17.260]             }
[17:59:17.260]         }))
[17:59:17.260]     }, error = function(ex) {
[17:59:17.260]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:17.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.260]                 ...future.rng), started = ...future.startTime, 
[17:59:17.260]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:17.260]             version = "1.8"), class = "FutureResult")
[17:59:17.260]     }, finally = {
[17:59:17.260]         if (!identical(...future.workdir, getwd())) 
[17:59:17.260]             setwd(...future.workdir)
[17:59:17.260]         {
[17:59:17.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:17.260]                 ...future.oldOptions$nwarnings <- NULL
[17:59:17.260]             }
[17:59:17.260]             base::options(...future.oldOptions)
[17:59:17.260]             if (.Platform$OS.type == "windows") {
[17:59:17.260]                 old_names <- names(...future.oldEnvVars)
[17:59:17.260]                 envs <- base::Sys.getenv()
[17:59:17.260]                 names <- names(envs)
[17:59:17.260]                 common <- intersect(names, old_names)
[17:59:17.260]                 added <- setdiff(names, old_names)
[17:59:17.260]                 removed <- setdiff(old_names, names)
[17:59:17.260]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:17.260]                   envs[common]]
[17:59:17.260]                 NAMES <- toupper(changed)
[17:59:17.260]                 args <- list()
[17:59:17.260]                 for (kk in seq_along(NAMES)) {
[17:59:17.260]                   name <- changed[[kk]]
[17:59:17.260]                   NAME <- NAMES[[kk]]
[17:59:17.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.260]                     next
[17:59:17.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.260]                 }
[17:59:17.260]                 NAMES <- toupper(added)
[17:59:17.260]                 for (kk in seq_along(NAMES)) {
[17:59:17.260]                   name <- added[[kk]]
[17:59:17.260]                   NAME <- NAMES[[kk]]
[17:59:17.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.260]                     next
[17:59:17.260]                   args[[name]] <- ""
[17:59:17.260]                 }
[17:59:17.260]                 NAMES <- toupper(removed)
[17:59:17.260]                 for (kk in seq_along(NAMES)) {
[17:59:17.260]                   name <- removed[[kk]]
[17:59:17.260]                   NAME <- NAMES[[kk]]
[17:59:17.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.260]                     next
[17:59:17.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.260]                 }
[17:59:17.260]                 if (length(args) > 0) 
[17:59:17.260]                   base::do.call(base::Sys.setenv, args = args)
[17:59:17.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:17.260]             }
[17:59:17.260]             else {
[17:59:17.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:17.260]             }
[17:59:17.260]             {
[17:59:17.260]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:17.260]                   0L) {
[17:59:17.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:17.260]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:17.260]                   base::options(opts)
[17:59:17.260]                 }
[17:59:17.260]                 {
[17:59:17.260]                   {
[17:59:17.260]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:17.260]                     NULL
[17:59:17.260]                   }
[17:59:17.260]                   options(future.plan = NULL)
[17:59:17.260]                   if (is.na(NA_character_)) 
[17:59:17.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:17.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:17.260]                     .init = FALSE)
[17:59:17.260]                 }
[17:59:17.260]             }
[17:59:17.260]         }
[17:59:17.260]     })
[17:59:17.260]     if (TRUE) {
[17:59:17.260]         base::sink(type = "output", split = FALSE)
[17:59:17.260]         if (TRUE) {
[17:59:17.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:17.260]         }
[17:59:17.260]         else {
[17:59:17.260]             ...future.result["stdout"] <- base::list(NULL)
[17:59:17.260]         }
[17:59:17.260]         base::close(...future.stdout)
[17:59:17.260]         ...future.stdout <- NULL
[17:59:17.260]     }
[17:59:17.260]     ...future.result$conditions <- ...future.conditions
[17:59:17.260]     ...future.result$finished <- base::Sys.time()
[17:59:17.260]     ...future.result
[17:59:17.260] }
[17:59:17.266] assign_globals() ...
[17:59:17.266] List of 5
[17:59:17.266]  $ future.call.arguments    : list()
[17:59:17.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.266]  $ ...future.FUN            :function (x)  
[17:59:17.266]  $ ...future.elements_ii    :List of 1
[17:59:17.266]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:59:17.266]  $ ...future.seeds_ii       : NULL
[17:59:17.266]  $ ...future.globals.maxSize: num Inf
[17:59:17.266]  - attr(*, "resolved")= logi FALSE
[17:59:17.266]  - attr(*, "total_size")= num NA
[17:59:17.266]  - attr(*, "where")=List of 5
[17:59:17.266]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:17.266]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:17.266]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:17.266]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:17.266]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:17.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.266]  - attr(*, "already-done")= logi TRUE
[17:59:17.283] - copied ‘future.call.arguments’ to environment
[17:59:17.283] - copied ‘...future.FUN’ to environment
[17:59:17.283] - copied ‘...future.elements_ii’ to environment
[17:59:17.284] - copied ‘...future.seeds_ii’ to environment
[17:59:17.284] - copied ‘...future.globals.maxSize’ to environment
[17:59:17.284] assign_globals() ... done
[17:59:17.285] requestCore(): workers = 2
[17:59:17.288] MulticoreFuture started
[17:59:17.289] - Launch lazy future ... done
[17:59:17.290] run() for ‘MulticoreFuture’ ... done
[17:59:17.290] Created future:
[17:59:17.290] plan(): Setting new future strategy stack:
[17:59:17.291] List of future strategies:
[17:59:17.291] 1. sequential:
[17:59:17.291]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:17.291]    - tweaked: FALSE
[17:59:17.291]    - call: NULL
[17:59:17.293] plan(): nbrOfWorkers() = 1
[17:59:17.297] plan(): Setting new future strategy stack:
[17:59:17.297] List of future strategies:
[17:59:17.297] 1. multicore:
[17:59:17.297]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:17.297]    - tweaked: FALSE
[17:59:17.297]    - call: plan(strategy)
[17:59:17.290] MulticoreFuture:
[17:59:17.290] Label: ‘future_apply-2’
[17:59:17.290] Expression:
[17:59:17.290] {
[17:59:17.290]     do.call(function(...) {
[17:59:17.290]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.290]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.290]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.290]             on.exit(options(oopts), add = TRUE)
[17:59:17.290]         }
[17:59:17.290]         {
[17:59:17.290]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.290]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.290]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.290]             })
[17:59:17.290]         }
[17:59:17.290]     }, args = future.call.arguments)
[17:59:17.290] }
[17:59:17.290] Lazy evaluation: FALSE
[17:59:17.290] Asynchronous evaluation: TRUE
[17:59:17.290] Local evaluation: TRUE
[17:59:17.290] Environment: R_GlobalEnv
[17:59:17.290] Capture standard output: TRUE
[17:59:17.290] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:17.290] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:17.290] Packages: <none>
[17:59:17.290] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:17.290] Resolved: FALSE
[17:59:17.290] Value: <not collected>
[17:59:17.290] Conditions captured: <none>
[17:59:17.290] Early signaling: FALSE
[17:59:17.290] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:17.290] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.306] Chunk #2 of 2 ... DONE
[17:59:17.306] Launching 2 futures (chunks) ... DONE
[17:59:17.307] Resolving 2 futures (chunks) ...
[17:59:17.307] plan(): nbrOfWorkers() = 2
[17:59:17.307] resolve() on list ...
[17:59:17.307]  recursive: 0
[17:59:17.308]  length: 2
[17:59:17.308] 
[17:59:17.309] Future #1
[17:59:17.309] result() for MulticoreFuture ...
[17:59:17.311] result() for MulticoreFuture ...
[17:59:17.311] result() for MulticoreFuture ... done
[17:59:17.311] result() for MulticoreFuture ... done
[17:59:17.312] result() for MulticoreFuture ...
[17:59:17.312] result() for MulticoreFuture ... done
[17:59:17.312] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:17.314] - nx: 2
[17:59:17.315] - relay: TRUE
[17:59:17.315] - stdout: TRUE
[17:59:17.315] - signal: TRUE
[17:59:17.315] - resignal: FALSE
[17:59:17.316] - force: TRUE
[17:59:17.316] - relayed: [n=2] FALSE, FALSE
[17:59:17.317] - queued futures: [n=2] FALSE, FALSE
[17:59:17.317]  - until=1
[17:59:17.317]  - relaying element #1
[17:59:17.318] result() for MulticoreFuture ...
[17:59:17.318] result() for MulticoreFuture ... done
[17:59:17.318] result() for MulticoreFuture ...
[17:59:17.319] result() for MulticoreFuture ... done
[17:59:17.319] result() for MulticoreFuture ...
[17:59:17.320] result() for MulticoreFuture ... done
[17:59:17.320] result() for MulticoreFuture ...
[17:59:17.320] result() for MulticoreFuture ... done
[17:59:17.321] - relayed: [n=2] TRUE, FALSE
[17:59:17.321] - queued futures: [n=2] TRUE, FALSE
[17:59:17.321] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:17.322]  length: 1 (resolved future 1)
[17:59:17.322] Future #2
[17:59:17.323] result() for MulticoreFuture ...
[17:59:17.325] result() for MulticoreFuture ...
[17:59:17.325] result() for MulticoreFuture ... done
[17:59:17.326] result() for MulticoreFuture ... done
[17:59:17.326] result() for MulticoreFuture ...
[17:59:17.326] result() for MulticoreFuture ... done
[17:59:17.327] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:17.327] - nx: 2
[17:59:17.327] - relay: TRUE
[17:59:17.327] - stdout: TRUE
[17:59:17.328] - signal: TRUE
[17:59:17.328] - resignal: FALSE
[17:59:17.328] - force: TRUE
[17:59:17.328] - relayed: [n=2] TRUE, FALSE
[17:59:17.328] - queued futures: [n=2] TRUE, FALSE
[17:59:17.329]  - until=2
[17:59:17.329]  - relaying element #2
[17:59:17.329] result() for MulticoreFuture ...
[17:59:17.329] result() for MulticoreFuture ... done
[17:59:17.330] result() for MulticoreFuture ...
[17:59:17.330] result() for MulticoreFuture ... done
[17:59:17.330] result() for MulticoreFuture ...
[17:59:17.330] result() for MulticoreFuture ... done
[17:59:17.331] result() for MulticoreFuture ...
[17:59:17.331] result() for MulticoreFuture ... done
[17:59:17.331] - relayed: [n=2] TRUE, TRUE
[17:59:17.331] - queued futures: [n=2] TRUE, TRUE
[17:59:17.332] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:17.332]  length: 0 (resolved future 2)
[17:59:17.332] Relaying remaining futures
[17:59:17.332] signalConditionsASAP(NULL, pos=0) ...
[17:59:17.332] - nx: 2
[17:59:17.333] - relay: TRUE
[17:59:17.333] - stdout: TRUE
[17:59:17.333] - signal: TRUE
[17:59:17.333] - resignal: FALSE
[17:59:17.333] - force: TRUE
[17:59:17.334] - relayed: [n=2] TRUE, TRUE
[17:59:17.334] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:17.334] - relayed: [n=2] TRUE, TRUE
[17:59:17.334] - queued futures: [n=2] TRUE, TRUE
[17:59:17.335] signalConditionsASAP(NULL, pos=0) ... done
[17:59:17.335] resolve() on list ... DONE
[17:59:17.335] result() for MulticoreFuture ...
[17:59:17.335] result() for MulticoreFuture ... done
[17:59:17.336] result() for MulticoreFuture ...
[17:59:17.336] result() for MulticoreFuture ... done
[17:59:17.336] result() for MulticoreFuture ...
[17:59:17.336] result() for MulticoreFuture ... done
[17:59:17.336] result() for MulticoreFuture ...
[17:59:17.337] result() for MulticoreFuture ... done
[17:59:17.337]  - Number of value chunks collected: 2
[17:59:17.337] Resolving 2 futures (chunks) ... DONE
[17:59:17.337] Reducing values from 2 chunks ...
[17:59:17.338]  - Number of values collected after concatenation: 2
[17:59:17.338]  - Number of values expected: 2
[17:59:17.338] Reducing values from 2 chunks ... DONE
[17:59:17.338] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:59:17.339] getGlobalsAndPackagesXApply() ...
[17:59:17.339]  - future.globals: TRUE
[17:59:17.339] getGlobalsAndPackages() ...
[17:59:17.340] Searching for globals...
[17:59:17.344] - globals found: [1] ‘FUN’
[17:59:17.344] Searching for globals ... DONE
[17:59:17.344] Resolving globals: FALSE
[17:59:17.345] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:17.346] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:17.346] - globals: [1] ‘FUN’
[17:59:17.346] 
[17:59:17.347] getGlobalsAndPackages() ... DONE
[17:59:17.347]  - globals found/used: [n=1] ‘FUN’
[17:59:17.347]  - needed namespaces: [n=0] 
[17:59:17.347] Finding globals ... DONE
[17:59:17.348]  - use_args: TRUE
[17:59:17.348]  - Getting '...' globals ...
[17:59:17.352] resolve() on list ...
[17:59:17.352]  recursive: 0
[17:59:17.352]  length: 1
[17:59:17.353]  elements: ‘...’
[17:59:17.353]  length: 0 (resolved future 1)
[17:59:17.353] resolve() on list ... DONE
[17:59:17.354]    - '...' content: [n=0] 
[17:59:17.354] List of 1
[17:59:17.354]  $ ...: list()
[17:59:17.354]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.354]  - attr(*, "where")=List of 1
[17:59:17.354]   ..$ ...:<environment: 0x56085b704220> 
[17:59:17.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.354]  - attr(*, "resolved")= logi TRUE
[17:59:17.354]  - attr(*, "total_size")= num NA
[17:59:17.360]  - Getting '...' globals ... DONE
[17:59:17.361] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:17.361] List of 2
[17:59:17.361]  $ ...future.FUN:function (x)  
[17:59:17.361]  $ ...          : list()
[17:59:17.361]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.361]  - attr(*, "where")=List of 2
[17:59:17.361]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:17.361]   ..$ ...          :<environment: 0x56085b704220> 
[17:59:17.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.361]  - attr(*, "resolved")= logi FALSE
[17:59:17.361]  - attr(*, "total_size")= num 848
[17:59:17.367] Packages to be attached in all futures: [n=0] 
[17:59:17.368] getGlobalsAndPackagesXApply() ... DONE
[17:59:17.375] future_lapply() ...
[17:59:17.381] Number of chunks: 2
[17:59:17.382] getGlobalsAndPackagesXApply() ...
[17:59:17.382]  - future.globals: <name-value list> with names ‘list()’
[17:59:17.382]  - use_args: TRUE
[17:59:17.383] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:17.383] List of 2
[17:59:17.383]  $ ...          : list()
[17:59:17.383]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.383]  $ ...future.FUN:function (x)  
[17:59:17.383]  - attr(*, "where")=List of 2
[17:59:17.383]   ..$ ...          :<environment: 0x56085b704220> 
[17:59:17.383]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:17.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.383]  - attr(*, "resolved")= logi FALSE
[17:59:17.383]  - attr(*, "total_size")= num NA
[17:59:17.390] Packages to be attached in all futures: [n=0] 
[17:59:17.390] getGlobalsAndPackagesXApply() ... DONE
[17:59:17.390] Number of futures (= number of chunks): 2
[17:59:17.390] Launching 2 futures (chunks) ...
[17:59:17.391] Chunk #1 of 2 ...
[17:59:17.391]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:17.391]  - seeds: <none>
[17:59:17.391]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.392] getGlobalsAndPackages() ...
[17:59:17.392] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.392] Resolving globals: FALSE
[17:59:17.392] Tweak future expression to call with '...' arguments ...
[17:59:17.392] {
[17:59:17.392]     do.call(function(...) {
[17:59:17.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.392]             on.exit(options(oopts), add = TRUE)
[17:59:17.392]         }
[17:59:17.392]         {
[17:59:17.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.392]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.392]             })
[17:59:17.392]         }
[17:59:17.392]     }, args = future.call.arguments)
[17:59:17.392] }
[17:59:17.393] Tweak future expression to call with '...' arguments ... DONE
[17:59:17.394] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.394] 
[17:59:17.394] getGlobalsAndPackages() ... DONE
[17:59:17.395] run() for ‘Future’ ...
[17:59:17.395] - state: ‘created’
[17:59:17.395] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:17.401] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.402] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:17.402]   - Field: ‘label’
[17:59:17.402]   - Field: ‘local’
[17:59:17.402]   - Field: ‘owner’
[17:59:17.403]   - Field: ‘envir’
[17:59:17.403]   - Field: ‘workers’
[17:59:17.403]   - Field: ‘packages’
[17:59:17.403]   - Field: ‘gc’
[17:59:17.403]   - Field: ‘job’
[17:59:17.404]   - Field: ‘conditions’
[17:59:17.404]   - Field: ‘expr’
[17:59:17.404]   - Field: ‘uuid’
[17:59:17.404]   - Field: ‘seed’
[17:59:17.404]   - Field: ‘version’
[17:59:17.405]   - Field: ‘result’
[17:59:17.405]   - Field: ‘asynchronous’
[17:59:17.405]   - Field: ‘calls’
[17:59:17.405]   - Field: ‘globals’
[17:59:17.405]   - Field: ‘stdout’
[17:59:17.406]   - Field: ‘earlySignal’
[17:59:17.406]   - Field: ‘lazy’
[17:59:17.406]   - Field: ‘state’
[17:59:17.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:17.406] - Launch lazy future ...
[17:59:17.407] Packages needed by the future expression (n = 0): <none>
[17:59:17.407] Packages needed by future strategies (n = 0): <none>
[17:59:17.408] {
[17:59:17.408]     {
[17:59:17.408]         {
[17:59:17.408]             ...future.startTime <- base::Sys.time()
[17:59:17.408]             {
[17:59:17.408]                 {
[17:59:17.408]                   {
[17:59:17.408]                     {
[17:59:17.408]                       base::local({
[17:59:17.408]                         has_future <- base::requireNamespace("future", 
[17:59:17.408]                           quietly = TRUE)
[17:59:17.408]                         if (has_future) {
[17:59:17.408]                           ns <- base::getNamespace("future")
[17:59:17.408]                           version <- ns[[".package"]][["version"]]
[17:59:17.408]                           if (is.null(version)) 
[17:59:17.408]                             version <- utils::packageVersion("future")
[17:59:17.408]                         }
[17:59:17.408]                         else {
[17:59:17.408]                           version <- NULL
[17:59:17.408]                         }
[17:59:17.408]                         if (!has_future || version < "1.8.0") {
[17:59:17.408]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:17.408]                             "", base::R.version$version.string), 
[17:59:17.408]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:17.408]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:17.408]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:17.408]                               "release", "version")], collapse = " "), 
[17:59:17.408]                             hostname = base::Sys.info()[["nodename"]])
[17:59:17.408]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:17.408]                             info)
[17:59:17.408]                           info <- base::paste(info, collapse = "; ")
[17:59:17.408]                           if (!has_future) {
[17:59:17.408]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:17.408]                               info)
[17:59:17.408]                           }
[17:59:17.408]                           else {
[17:59:17.408]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:17.408]                               info, version)
[17:59:17.408]                           }
[17:59:17.408]                           base::stop(msg)
[17:59:17.408]                         }
[17:59:17.408]                       })
[17:59:17.408]                     }
[17:59:17.408]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:17.408]                     base::options(mc.cores = 1L)
[17:59:17.408]                   }
[17:59:17.408]                   ...future.strategy.old <- future::plan("list")
[17:59:17.408]                   options(future.plan = NULL)
[17:59:17.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:17.408]                 }
[17:59:17.408]                 ...future.workdir <- getwd()
[17:59:17.408]             }
[17:59:17.408]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:17.408]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:17.408]         }
[17:59:17.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:17.408]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:17.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:17.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:17.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:17.408]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:17.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:17.408]             base::names(...future.oldOptions))
[17:59:17.408]     }
[17:59:17.408]     if (FALSE) {
[17:59:17.408]     }
[17:59:17.408]     else {
[17:59:17.408]         if (TRUE) {
[17:59:17.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:17.408]                 open = "w")
[17:59:17.408]         }
[17:59:17.408]         else {
[17:59:17.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:17.408]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:17.408]         }
[17:59:17.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:17.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:17.408]             base::sink(type = "output", split = FALSE)
[17:59:17.408]             base::close(...future.stdout)
[17:59:17.408]         }, add = TRUE)
[17:59:17.408]     }
[17:59:17.408]     ...future.frame <- base::sys.nframe()
[17:59:17.408]     ...future.conditions <- base::list()
[17:59:17.408]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:17.408]     if (FALSE) {
[17:59:17.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:17.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:17.408]     }
[17:59:17.408]     ...future.result <- base::tryCatch({
[17:59:17.408]         base::withCallingHandlers({
[17:59:17.408]             ...future.value <- base::withVisible(base::local({
[17:59:17.408]                 withCallingHandlers({
[17:59:17.408]                   {
[17:59:17.408]                     do.call(function(...) {
[17:59:17.408]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.408]                       if (!identical(...future.globals.maxSize.org, 
[17:59:17.408]                         ...future.globals.maxSize)) {
[17:59:17.408]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.408]                         on.exit(options(oopts), add = TRUE)
[17:59:17.408]                       }
[17:59:17.408]                       {
[17:59:17.408]                         lapply(seq_along(...future.elements_ii), 
[17:59:17.408]                           FUN = function(jj) {
[17:59:17.408]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.408]                             ...future.FUN(...future.X_jj, ...)
[17:59:17.408]                           })
[17:59:17.408]                       }
[17:59:17.408]                     }, args = future.call.arguments)
[17:59:17.408]                   }
[17:59:17.408]                 }, immediateCondition = function(cond) {
[17:59:17.408]                   save_rds <- function (object, pathname, ...) 
[17:59:17.408]                   {
[17:59:17.408]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:17.408]                     if (file_test("-f", pathname_tmp)) {
[17:59:17.408]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.408]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:17.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.408]                         fi_tmp[["mtime"]])
[17:59:17.408]                     }
[17:59:17.408]                     tryCatch({
[17:59:17.408]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:17.408]                     }, error = function(ex) {
[17:59:17.408]                       msg <- conditionMessage(ex)
[17:59:17.408]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.408]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:17.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.408]                         fi_tmp[["mtime"]], msg)
[17:59:17.408]                       ex$message <- msg
[17:59:17.408]                       stop(ex)
[17:59:17.408]                     })
[17:59:17.408]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:17.408]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:17.408]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:17.408]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.408]                       fi <- file.info(pathname)
[17:59:17.408]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:17.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.408]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:17.408]                         fi[["size"]], fi[["mtime"]])
[17:59:17.408]                       stop(msg)
[17:59:17.408]                     }
[17:59:17.408]                     invisible(pathname)
[17:59:17.408]                   }
[17:59:17.408]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:17.408]                     rootPath = tempdir()) 
[17:59:17.408]                   {
[17:59:17.408]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:17.408]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:17.408]                       tmpdir = path, fileext = ".rds")
[17:59:17.408]                     save_rds(obj, file)
[17:59:17.408]                   }
[17:59:17.408]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:17.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.408]                   {
[17:59:17.408]                     inherits <- base::inherits
[17:59:17.408]                     invokeRestart <- base::invokeRestart
[17:59:17.408]                     is.null <- base::is.null
[17:59:17.408]                     muffled <- FALSE
[17:59:17.408]                     if (inherits(cond, "message")) {
[17:59:17.408]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:17.408]                       if (muffled) 
[17:59:17.408]                         invokeRestart("muffleMessage")
[17:59:17.408]                     }
[17:59:17.408]                     else if (inherits(cond, "warning")) {
[17:59:17.408]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:17.408]                       if (muffled) 
[17:59:17.408]                         invokeRestart("muffleWarning")
[17:59:17.408]                     }
[17:59:17.408]                     else if (inherits(cond, "condition")) {
[17:59:17.408]                       if (!is.null(pattern)) {
[17:59:17.408]                         computeRestarts <- base::computeRestarts
[17:59:17.408]                         grepl <- base::grepl
[17:59:17.408]                         restarts <- computeRestarts(cond)
[17:59:17.408]                         for (restart in restarts) {
[17:59:17.408]                           name <- restart$name
[17:59:17.408]                           if (is.null(name)) 
[17:59:17.408]                             next
[17:59:17.408]                           if (!grepl(pattern, name)) 
[17:59:17.408]                             next
[17:59:17.408]                           invokeRestart(restart)
[17:59:17.408]                           muffled <- TRUE
[17:59:17.408]                           break
[17:59:17.408]                         }
[17:59:17.408]                       }
[17:59:17.408]                     }
[17:59:17.408]                     invisible(muffled)
[17:59:17.408]                   }
[17:59:17.408]                   muffleCondition(cond)
[17:59:17.408]                 })
[17:59:17.408]             }))
[17:59:17.408]             future::FutureResult(value = ...future.value$value, 
[17:59:17.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.408]                   ...future.rng), globalenv = if (FALSE) 
[17:59:17.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:17.408]                     ...future.globalenv.names))
[17:59:17.408]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:17.408]         }, condition = base::local({
[17:59:17.408]             c <- base::c
[17:59:17.408]             inherits <- base::inherits
[17:59:17.408]             invokeRestart <- base::invokeRestart
[17:59:17.408]             length <- base::length
[17:59:17.408]             list <- base::list
[17:59:17.408]             seq.int <- base::seq.int
[17:59:17.408]             signalCondition <- base::signalCondition
[17:59:17.408]             sys.calls <- base::sys.calls
[17:59:17.408]             `[[` <- base::`[[`
[17:59:17.408]             `+` <- base::`+`
[17:59:17.408]             `<<-` <- base::`<<-`
[17:59:17.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:17.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:17.408]                   3L)]
[17:59:17.408]             }
[17:59:17.408]             function(cond) {
[17:59:17.408]                 is_error <- inherits(cond, "error")
[17:59:17.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:17.408]                   NULL)
[17:59:17.408]                 if (is_error) {
[17:59:17.408]                   sessionInformation <- function() {
[17:59:17.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:17.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:17.408]                       search = base::search(), system = base::Sys.info())
[17:59:17.408]                   }
[17:59:17.408]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:17.408]                     cond$call), session = sessionInformation(), 
[17:59:17.408]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:17.408]                   signalCondition(cond)
[17:59:17.408]                 }
[17:59:17.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:17.408]                 "immediateCondition"))) {
[17:59:17.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:17.408]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:17.408]                   if (TRUE && !signal) {
[17:59:17.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.408]                     {
[17:59:17.408]                       inherits <- base::inherits
[17:59:17.408]                       invokeRestart <- base::invokeRestart
[17:59:17.408]                       is.null <- base::is.null
[17:59:17.408]                       muffled <- FALSE
[17:59:17.408]                       if (inherits(cond, "message")) {
[17:59:17.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.408]                         if (muffled) 
[17:59:17.408]                           invokeRestart("muffleMessage")
[17:59:17.408]                       }
[17:59:17.408]                       else if (inherits(cond, "warning")) {
[17:59:17.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.408]                         if (muffled) 
[17:59:17.408]                           invokeRestart("muffleWarning")
[17:59:17.408]                       }
[17:59:17.408]                       else if (inherits(cond, "condition")) {
[17:59:17.408]                         if (!is.null(pattern)) {
[17:59:17.408]                           computeRestarts <- base::computeRestarts
[17:59:17.408]                           grepl <- base::grepl
[17:59:17.408]                           restarts <- computeRestarts(cond)
[17:59:17.408]                           for (restart in restarts) {
[17:59:17.408]                             name <- restart$name
[17:59:17.408]                             if (is.null(name)) 
[17:59:17.408]                               next
[17:59:17.408]                             if (!grepl(pattern, name)) 
[17:59:17.408]                               next
[17:59:17.408]                             invokeRestart(restart)
[17:59:17.408]                             muffled <- TRUE
[17:59:17.408]                             break
[17:59:17.408]                           }
[17:59:17.408]                         }
[17:59:17.408]                       }
[17:59:17.408]                       invisible(muffled)
[17:59:17.408]                     }
[17:59:17.408]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.408]                   }
[17:59:17.408]                 }
[17:59:17.408]                 else {
[17:59:17.408]                   if (TRUE) {
[17:59:17.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.408]                     {
[17:59:17.408]                       inherits <- base::inherits
[17:59:17.408]                       invokeRestart <- base::invokeRestart
[17:59:17.408]                       is.null <- base::is.null
[17:59:17.408]                       muffled <- FALSE
[17:59:17.408]                       if (inherits(cond, "message")) {
[17:59:17.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.408]                         if (muffled) 
[17:59:17.408]                           invokeRestart("muffleMessage")
[17:59:17.408]                       }
[17:59:17.408]                       else if (inherits(cond, "warning")) {
[17:59:17.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.408]                         if (muffled) 
[17:59:17.408]                           invokeRestart("muffleWarning")
[17:59:17.408]                       }
[17:59:17.408]                       else if (inherits(cond, "condition")) {
[17:59:17.408]                         if (!is.null(pattern)) {
[17:59:17.408]                           computeRestarts <- base::computeRestarts
[17:59:17.408]                           grepl <- base::grepl
[17:59:17.408]                           restarts <- computeRestarts(cond)
[17:59:17.408]                           for (restart in restarts) {
[17:59:17.408]                             name <- restart$name
[17:59:17.408]                             if (is.null(name)) 
[17:59:17.408]                               next
[17:59:17.408]                             if (!grepl(pattern, name)) 
[17:59:17.408]                               next
[17:59:17.408]                             invokeRestart(restart)
[17:59:17.408]                             muffled <- TRUE
[17:59:17.408]                             break
[17:59:17.408]                           }
[17:59:17.408]                         }
[17:59:17.408]                       }
[17:59:17.408]                       invisible(muffled)
[17:59:17.408]                     }
[17:59:17.408]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.408]                   }
[17:59:17.408]                 }
[17:59:17.408]             }
[17:59:17.408]         }))
[17:59:17.408]     }, error = function(ex) {
[17:59:17.408]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:17.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.408]                 ...future.rng), started = ...future.startTime, 
[17:59:17.408]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:17.408]             version = "1.8"), class = "FutureResult")
[17:59:17.408]     }, finally = {
[17:59:17.408]         if (!identical(...future.workdir, getwd())) 
[17:59:17.408]             setwd(...future.workdir)
[17:59:17.408]         {
[17:59:17.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:17.408]                 ...future.oldOptions$nwarnings <- NULL
[17:59:17.408]             }
[17:59:17.408]             base::options(...future.oldOptions)
[17:59:17.408]             if (.Platform$OS.type == "windows") {
[17:59:17.408]                 old_names <- names(...future.oldEnvVars)
[17:59:17.408]                 envs <- base::Sys.getenv()
[17:59:17.408]                 names <- names(envs)
[17:59:17.408]                 common <- intersect(names, old_names)
[17:59:17.408]                 added <- setdiff(names, old_names)
[17:59:17.408]                 removed <- setdiff(old_names, names)
[17:59:17.408]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:17.408]                   envs[common]]
[17:59:17.408]                 NAMES <- toupper(changed)
[17:59:17.408]                 args <- list()
[17:59:17.408]                 for (kk in seq_along(NAMES)) {
[17:59:17.408]                   name <- changed[[kk]]
[17:59:17.408]                   NAME <- NAMES[[kk]]
[17:59:17.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.408]                     next
[17:59:17.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.408]                 }
[17:59:17.408]                 NAMES <- toupper(added)
[17:59:17.408]                 for (kk in seq_along(NAMES)) {
[17:59:17.408]                   name <- added[[kk]]
[17:59:17.408]                   NAME <- NAMES[[kk]]
[17:59:17.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.408]                     next
[17:59:17.408]                   args[[name]] <- ""
[17:59:17.408]                 }
[17:59:17.408]                 NAMES <- toupper(removed)
[17:59:17.408]                 for (kk in seq_along(NAMES)) {
[17:59:17.408]                   name <- removed[[kk]]
[17:59:17.408]                   NAME <- NAMES[[kk]]
[17:59:17.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.408]                     next
[17:59:17.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.408]                 }
[17:59:17.408]                 if (length(args) > 0) 
[17:59:17.408]                   base::do.call(base::Sys.setenv, args = args)
[17:59:17.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:17.408]             }
[17:59:17.408]             else {
[17:59:17.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:17.408]             }
[17:59:17.408]             {
[17:59:17.408]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:17.408]                   0L) {
[17:59:17.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:17.408]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:17.408]                   base::options(opts)
[17:59:17.408]                 }
[17:59:17.408]                 {
[17:59:17.408]                   {
[17:59:17.408]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:17.408]                     NULL
[17:59:17.408]                   }
[17:59:17.408]                   options(future.plan = NULL)
[17:59:17.408]                   if (is.na(NA_character_)) 
[17:59:17.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:17.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:17.408]                     .init = FALSE)
[17:59:17.408]                 }
[17:59:17.408]             }
[17:59:17.408]         }
[17:59:17.408]     })
[17:59:17.408]     if (TRUE) {
[17:59:17.408]         base::sink(type = "output", split = FALSE)
[17:59:17.408]         if (TRUE) {
[17:59:17.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:17.408]         }
[17:59:17.408]         else {
[17:59:17.408]             ...future.result["stdout"] <- base::list(NULL)
[17:59:17.408]         }
[17:59:17.408]         base::close(...future.stdout)
[17:59:17.408]         ...future.stdout <- NULL
[17:59:17.408]     }
[17:59:17.408]     ...future.result$conditions <- ...future.conditions
[17:59:17.408]     ...future.result$finished <- base::Sys.time()
[17:59:17.408]     ...future.result
[17:59:17.408] }
[17:59:17.413] assign_globals() ...
[17:59:17.413] List of 5
[17:59:17.413]  $ future.call.arguments    : list()
[17:59:17.413]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.413]  $ ...future.FUN            :function (x)  
[17:59:17.413]  $ ...future.elements_ii    :List of 3
[17:59:17.413]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:59:17.413]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:59:17.413]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:59:17.413]  $ ...future.seeds_ii       : NULL
[17:59:17.413]  $ ...future.globals.maxSize: num Inf
[17:59:17.413]  - attr(*, "resolved")= logi FALSE
[17:59:17.413]  - attr(*, "total_size")= num NA
[17:59:17.413]  - attr(*, "where")=List of 5
[17:59:17.413]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:17.413]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:17.413]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:17.413]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:17.413]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:17.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.413]  - attr(*, "already-done")= logi TRUE
[17:59:17.428] - copied ‘future.call.arguments’ to environment
[17:59:17.428] - copied ‘...future.FUN’ to environment
[17:59:17.428] - copied ‘...future.elements_ii’ to environment
[17:59:17.429] - copied ‘...future.seeds_ii’ to environment
[17:59:17.429] - copied ‘...future.globals.maxSize’ to environment
[17:59:17.429] assign_globals() ... done
[17:59:17.429] requestCore(): workers = 2
[17:59:17.433] MulticoreFuture started
[17:59:17.434] - Launch lazy future ... done
[17:59:17.434] run() for ‘MulticoreFuture’ ... done
[17:59:17.435] Created future:
[17:59:17.438] plan(): Setting new future strategy stack:
[17:59:17.438] List of future strategies:
[17:59:17.438] 1. sequential:
[17:59:17.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:17.438]    - tweaked: FALSE
[17:59:17.438]    - call: NULL
[17:59:17.442] plan(): nbrOfWorkers() = 1
[17:59:17.446] plan(): Setting new future strategy stack:
[17:59:17.446] List of future strategies:
[17:59:17.446] 1. multicore:
[17:59:17.446]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:17.446]    - tweaked: FALSE
[17:59:17.446]    - call: plan(strategy)
[17:59:17.436] MulticoreFuture:
[17:59:17.436] Label: ‘future_apply-1’
[17:59:17.436] Expression:
[17:59:17.436] {
[17:59:17.436]     do.call(function(...) {
[17:59:17.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.436]             on.exit(options(oopts), add = TRUE)
[17:59:17.436]         }
[17:59:17.436]         {
[17:59:17.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.436]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.436]             })
[17:59:17.436]         }
[17:59:17.436]     }, args = future.call.arguments)
[17:59:17.436] }
[17:59:17.436] Lazy evaluation: FALSE
[17:59:17.436] Asynchronous evaluation: TRUE
[17:59:17.436] Local evaluation: TRUE
[17:59:17.436] Environment: R_GlobalEnv
[17:59:17.436] Capture standard output: TRUE
[17:59:17.436] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:17.436] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:17.436] Packages: <none>
[17:59:17.436] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:17.436] Resolved: FALSE
[17:59:17.436] Value: <not collected>
[17:59:17.436] Conditions captured: <none>
[17:59:17.436] Early signaling: FALSE
[17:59:17.436] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:17.436] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.452] Chunk #1 of 2 ... DONE
[17:59:17.452] Chunk #2 of 2 ...
[17:59:17.453]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:17.453]  - seeds: <none>
[17:59:17.454]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.456] getGlobalsAndPackages() ...
[17:59:17.456] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.459] Resolving globals: FALSE
[17:59:17.459] Tweak future expression to call with '...' arguments ...
[17:59:17.460] {
[17:59:17.460]     do.call(function(...) {
[17:59:17.460]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.460]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.460]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.460]             on.exit(options(oopts), add = TRUE)
[17:59:17.460]         }
[17:59:17.460]         {
[17:59:17.460]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.460]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.460]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.460]             })
[17:59:17.460]         }
[17:59:17.460]     }, args = future.call.arguments)
[17:59:17.460] }
[17:59:17.459] plan(): nbrOfWorkers() = 2
[17:59:17.461] Tweak future expression to call with '...' arguments ... DONE
[17:59:17.463] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.463] 
[17:59:17.464] getGlobalsAndPackages() ... DONE
[17:59:17.465] run() for ‘Future’ ...
[17:59:17.465] - state: ‘created’
[17:59:17.466] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:17.474] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.474] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:17.475]   - Field: ‘label’
[17:59:17.475]   - Field: ‘local’
[17:59:17.475]   - Field: ‘owner’
[17:59:17.476]   - Field: ‘envir’
[17:59:17.476]   - Field: ‘workers’
[17:59:17.476]   - Field: ‘packages’
[17:59:17.477]   - Field: ‘gc’
[17:59:17.477]   - Field: ‘job’
[17:59:17.477]   - Field: ‘conditions’
[17:59:17.478]   - Field: ‘expr’
[17:59:17.478]   - Field: ‘uuid’
[17:59:17.478]   - Field: ‘seed’
[17:59:17.479]   - Field: ‘version’
[17:59:17.479]   - Field: ‘result’
[17:59:17.479]   - Field: ‘asynchronous’
[17:59:17.480]   - Field: ‘calls’
[17:59:17.480]   - Field: ‘globals’
[17:59:17.480]   - Field: ‘stdout’
[17:59:17.481]   - Field: ‘earlySignal’
[17:59:17.481]   - Field: ‘lazy’
[17:59:17.481]   - Field: ‘state’
[17:59:17.482] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:17.482] - Launch lazy future ...
[17:59:17.483] Packages needed by the future expression (n = 0): <none>
[17:59:17.483] Packages needed by future strategies (n = 0): <none>
[17:59:17.485] {
[17:59:17.485]     {
[17:59:17.485]         {
[17:59:17.485]             ...future.startTime <- base::Sys.time()
[17:59:17.485]             {
[17:59:17.485]                 {
[17:59:17.485]                   {
[17:59:17.485]                     {
[17:59:17.485]                       base::local({
[17:59:17.485]                         has_future <- base::requireNamespace("future", 
[17:59:17.485]                           quietly = TRUE)
[17:59:17.485]                         if (has_future) {
[17:59:17.485]                           ns <- base::getNamespace("future")
[17:59:17.485]                           version <- ns[[".package"]][["version"]]
[17:59:17.485]                           if (is.null(version)) 
[17:59:17.485]                             version <- utils::packageVersion("future")
[17:59:17.485]                         }
[17:59:17.485]                         else {
[17:59:17.485]                           version <- NULL
[17:59:17.485]                         }
[17:59:17.485]                         if (!has_future || version < "1.8.0") {
[17:59:17.485]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:17.485]                             "", base::R.version$version.string), 
[17:59:17.485]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:17.485]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:17.485]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:17.485]                               "release", "version")], collapse = " "), 
[17:59:17.485]                             hostname = base::Sys.info()[["nodename"]])
[17:59:17.485]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:17.485]                             info)
[17:59:17.485]                           info <- base::paste(info, collapse = "; ")
[17:59:17.485]                           if (!has_future) {
[17:59:17.485]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:17.485]                               info)
[17:59:17.485]                           }
[17:59:17.485]                           else {
[17:59:17.485]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:17.485]                               info, version)
[17:59:17.485]                           }
[17:59:17.485]                           base::stop(msg)
[17:59:17.485]                         }
[17:59:17.485]                       })
[17:59:17.485]                     }
[17:59:17.485]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:17.485]                     base::options(mc.cores = 1L)
[17:59:17.485]                   }
[17:59:17.485]                   ...future.strategy.old <- future::plan("list")
[17:59:17.485]                   options(future.plan = NULL)
[17:59:17.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:17.485]                 }
[17:59:17.485]                 ...future.workdir <- getwd()
[17:59:17.485]             }
[17:59:17.485]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:17.485]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:17.485]         }
[17:59:17.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:17.485]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:17.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:17.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:17.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:17.485]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:17.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:17.485]             base::names(...future.oldOptions))
[17:59:17.485]     }
[17:59:17.485]     if (FALSE) {
[17:59:17.485]     }
[17:59:17.485]     else {
[17:59:17.485]         if (TRUE) {
[17:59:17.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:17.485]                 open = "w")
[17:59:17.485]         }
[17:59:17.485]         else {
[17:59:17.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:17.485]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:17.485]         }
[17:59:17.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:17.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:17.485]             base::sink(type = "output", split = FALSE)
[17:59:17.485]             base::close(...future.stdout)
[17:59:17.485]         }, add = TRUE)
[17:59:17.485]     }
[17:59:17.485]     ...future.frame <- base::sys.nframe()
[17:59:17.485]     ...future.conditions <- base::list()
[17:59:17.485]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:17.485]     if (FALSE) {
[17:59:17.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:17.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:17.485]     }
[17:59:17.485]     ...future.result <- base::tryCatch({
[17:59:17.485]         base::withCallingHandlers({
[17:59:17.485]             ...future.value <- base::withVisible(base::local({
[17:59:17.485]                 withCallingHandlers({
[17:59:17.485]                   {
[17:59:17.485]                     do.call(function(...) {
[17:59:17.485]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.485]                       if (!identical(...future.globals.maxSize.org, 
[17:59:17.485]                         ...future.globals.maxSize)) {
[17:59:17.485]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.485]                         on.exit(options(oopts), add = TRUE)
[17:59:17.485]                       }
[17:59:17.485]                       {
[17:59:17.485]                         lapply(seq_along(...future.elements_ii), 
[17:59:17.485]                           FUN = function(jj) {
[17:59:17.485]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.485]                             ...future.FUN(...future.X_jj, ...)
[17:59:17.485]                           })
[17:59:17.485]                       }
[17:59:17.485]                     }, args = future.call.arguments)
[17:59:17.485]                   }
[17:59:17.485]                 }, immediateCondition = function(cond) {
[17:59:17.485]                   save_rds <- function (object, pathname, ...) 
[17:59:17.485]                   {
[17:59:17.485]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:17.485]                     if (file_test("-f", pathname_tmp)) {
[17:59:17.485]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.485]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:17.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.485]                         fi_tmp[["mtime"]])
[17:59:17.485]                     }
[17:59:17.485]                     tryCatch({
[17:59:17.485]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:17.485]                     }, error = function(ex) {
[17:59:17.485]                       msg <- conditionMessage(ex)
[17:59:17.485]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.485]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:17.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.485]                         fi_tmp[["mtime"]], msg)
[17:59:17.485]                       ex$message <- msg
[17:59:17.485]                       stop(ex)
[17:59:17.485]                     })
[17:59:17.485]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:17.485]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:17.485]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:17.485]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.485]                       fi <- file.info(pathname)
[17:59:17.485]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:17.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.485]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:17.485]                         fi[["size"]], fi[["mtime"]])
[17:59:17.485]                       stop(msg)
[17:59:17.485]                     }
[17:59:17.485]                     invisible(pathname)
[17:59:17.485]                   }
[17:59:17.485]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:17.485]                     rootPath = tempdir()) 
[17:59:17.485]                   {
[17:59:17.485]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:17.485]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:17.485]                       tmpdir = path, fileext = ".rds")
[17:59:17.485]                     save_rds(obj, file)
[17:59:17.485]                   }
[17:59:17.485]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:17.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.485]                   {
[17:59:17.485]                     inherits <- base::inherits
[17:59:17.485]                     invokeRestart <- base::invokeRestart
[17:59:17.485]                     is.null <- base::is.null
[17:59:17.485]                     muffled <- FALSE
[17:59:17.485]                     if (inherits(cond, "message")) {
[17:59:17.485]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:17.485]                       if (muffled) 
[17:59:17.485]                         invokeRestart("muffleMessage")
[17:59:17.485]                     }
[17:59:17.485]                     else if (inherits(cond, "warning")) {
[17:59:17.485]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:17.485]                       if (muffled) 
[17:59:17.485]                         invokeRestart("muffleWarning")
[17:59:17.485]                     }
[17:59:17.485]                     else if (inherits(cond, "condition")) {
[17:59:17.485]                       if (!is.null(pattern)) {
[17:59:17.485]                         computeRestarts <- base::computeRestarts
[17:59:17.485]                         grepl <- base::grepl
[17:59:17.485]                         restarts <- computeRestarts(cond)
[17:59:17.485]                         for (restart in restarts) {
[17:59:17.485]                           name <- restart$name
[17:59:17.485]                           if (is.null(name)) 
[17:59:17.485]                             next
[17:59:17.485]                           if (!grepl(pattern, name)) 
[17:59:17.485]                             next
[17:59:17.485]                           invokeRestart(restart)
[17:59:17.485]                           muffled <- TRUE
[17:59:17.485]                           break
[17:59:17.485]                         }
[17:59:17.485]                       }
[17:59:17.485]                     }
[17:59:17.485]                     invisible(muffled)
[17:59:17.485]                   }
[17:59:17.485]                   muffleCondition(cond)
[17:59:17.485]                 })
[17:59:17.485]             }))
[17:59:17.485]             future::FutureResult(value = ...future.value$value, 
[17:59:17.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.485]                   ...future.rng), globalenv = if (FALSE) 
[17:59:17.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:17.485]                     ...future.globalenv.names))
[17:59:17.485]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:17.485]         }, condition = base::local({
[17:59:17.485]             c <- base::c
[17:59:17.485]             inherits <- base::inherits
[17:59:17.485]             invokeRestart <- base::invokeRestart
[17:59:17.485]             length <- base::length
[17:59:17.485]             list <- base::list
[17:59:17.485]             seq.int <- base::seq.int
[17:59:17.485]             signalCondition <- base::signalCondition
[17:59:17.485]             sys.calls <- base::sys.calls
[17:59:17.485]             `[[` <- base::`[[`
[17:59:17.485]             `+` <- base::`+`
[17:59:17.485]             `<<-` <- base::`<<-`
[17:59:17.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:17.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:17.485]                   3L)]
[17:59:17.485]             }
[17:59:17.485]             function(cond) {
[17:59:17.485]                 is_error <- inherits(cond, "error")
[17:59:17.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:17.485]                   NULL)
[17:59:17.485]                 if (is_error) {
[17:59:17.485]                   sessionInformation <- function() {
[17:59:17.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:17.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:17.485]                       search = base::search(), system = base::Sys.info())
[17:59:17.485]                   }
[17:59:17.485]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:17.485]                     cond$call), session = sessionInformation(), 
[17:59:17.485]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:17.485]                   signalCondition(cond)
[17:59:17.485]                 }
[17:59:17.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:17.485]                 "immediateCondition"))) {
[17:59:17.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:17.485]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:17.485]                   if (TRUE && !signal) {
[17:59:17.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.485]                     {
[17:59:17.485]                       inherits <- base::inherits
[17:59:17.485]                       invokeRestart <- base::invokeRestart
[17:59:17.485]                       is.null <- base::is.null
[17:59:17.485]                       muffled <- FALSE
[17:59:17.485]                       if (inherits(cond, "message")) {
[17:59:17.485]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.485]                         if (muffled) 
[17:59:17.485]                           invokeRestart("muffleMessage")
[17:59:17.485]                       }
[17:59:17.485]                       else if (inherits(cond, "warning")) {
[17:59:17.485]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.485]                         if (muffled) 
[17:59:17.485]                           invokeRestart("muffleWarning")
[17:59:17.485]                       }
[17:59:17.485]                       else if (inherits(cond, "condition")) {
[17:59:17.485]                         if (!is.null(pattern)) {
[17:59:17.485]                           computeRestarts <- base::computeRestarts
[17:59:17.485]                           grepl <- base::grepl
[17:59:17.485]                           restarts <- computeRestarts(cond)
[17:59:17.485]                           for (restart in restarts) {
[17:59:17.485]                             name <- restart$name
[17:59:17.485]                             if (is.null(name)) 
[17:59:17.485]                               next
[17:59:17.485]                             if (!grepl(pattern, name)) 
[17:59:17.485]                               next
[17:59:17.485]                             invokeRestart(restart)
[17:59:17.485]                             muffled <- TRUE
[17:59:17.485]                             break
[17:59:17.485]                           }
[17:59:17.485]                         }
[17:59:17.485]                       }
[17:59:17.485]                       invisible(muffled)
[17:59:17.485]                     }
[17:59:17.485]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.485]                   }
[17:59:17.485]                 }
[17:59:17.485]                 else {
[17:59:17.485]                   if (TRUE) {
[17:59:17.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.485]                     {
[17:59:17.485]                       inherits <- base::inherits
[17:59:17.485]                       invokeRestart <- base::invokeRestart
[17:59:17.485]                       is.null <- base::is.null
[17:59:17.485]                       muffled <- FALSE
[17:59:17.485]                       if (inherits(cond, "message")) {
[17:59:17.485]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.485]                         if (muffled) 
[17:59:17.485]                           invokeRestart("muffleMessage")
[17:59:17.485]                       }
[17:59:17.485]                       else if (inherits(cond, "warning")) {
[17:59:17.485]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.485]                         if (muffled) 
[17:59:17.485]                           invokeRestart("muffleWarning")
[17:59:17.485]                       }
[17:59:17.485]                       else if (inherits(cond, "condition")) {
[17:59:17.485]                         if (!is.null(pattern)) {
[17:59:17.485]                           computeRestarts <- base::computeRestarts
[17:59:17.485]                           grepl <- base::grepl
[17:59:17.485]                           restarts <- computeRestarts(cond)
[17:59:17.485]                           for (restart in restarts) {
[17:59:17.485]                             name <- restart$name
[17:59:17.485]                             if (is.null(name)) 
[17:59:17.485]                               next
[17:59:17.485]                             if (!grepl(pattern, name)) 
[17:59:17.485]                               next
[17:59:17.485]                             invokeRestart(restart)
[17:59:17.485]                             muffled <- TRUE
[17:59:17.485]                             break
[17:59:17.485]                           }
[17:59:17.485]                         }
[17:59:17.485]                       }
[17:59:17.485]                       invisible(muffled)
[17:59:17.485]                     }
[17:59:17.485]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.485]                   }
[17:59:17.485]                 }
[17:59:17.485]             }
[17:59:17.485]         }))
[17:59:17.485]     }, error = function(ex) {
[17:59:17.485]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:17.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.485]                 ...future.rng), started = ...future.startTime, 
[17:59:17.485]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:17.485]             version = "1.8"), class = "FutureResult")
[17:59:17.485]     }, finally = {
[17:59:17.485]         if (!identical(...future.workdir, getwd())) 
[17:59:17.485]             setwd(...future.workdir)
[17:59:17.485]         {
[17:59:17.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:17.485]                 ...future.oldOptions$nwarnings <- NULL
[17:59:17.485]             }
[17:59:17.485]             base::options(...future.oldOptions)
[17:59:17.485]             if (.Platform$OS.type == "windows") {
[17:59:17.485]                 old_names <- names(...future.oldEnvVars)
[17:59:17.485]                 envs <- base::Sys.getenv()
[17:59:17.485]                 names <- names(envs)
[17:59:17.485]                 common <- intersect(names, old_names)
[17:59:17.485]                 added <- setdiff(names, old_names)
[17:59:17.485]                 removed <- setdiff(old_names, names)
[17:59:17.485]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:17.485]                   envs[common]]
[17:59:17.485]                 NAMES <- toupper(changed)
[17:59:17.485]                 args <- list()
[17:59:17.485]                 for (kk in seq_along(NAMES)) {
[17:59:17.485]                   name <- changed[[kk]]
[17:59:17.485]                   NAME <- NAMES[[kk]]
[17:59:17.485]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.485]                     next
[17:59:17.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.485]                 }
[17:59:17.485]                 NAMES <- toupper(added)
[17:59:17.485]                 for (kk in seq_along(NAMES)) {
[17:59:17.485]                   name <- added[[kk]]
[17:59:17.485]                   NAME <- NAMES[[kk]]
[17:59:17.485]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.485]                     next
[17:59:17.485]                   args[[name]] <- ""
[17:59:17.485]                 }
[17:59:17.485]                 NAMES <- toupper(removed)
[17:59:17.485]                 for (kk in seq_along(NAMES)) {
[17:59:17.485]                   name <- removed[[kk]]
[17:59:17.485]                   NAME <- NAMES[[kk]]
[17:59:17.485]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.485]                     next
[17:59:17.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.485]                 }
[17:59:17.485]                 if (length(args) > 0) 
[17:59:17.485]                   base::do.call(base::Sys.setenv, args = args)
[17:59:17.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:17.485]             }
[17:59:17.485]             else {
[17:59:17.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:17.485]             }
[17:59:17.485]             {
[17:59:17.485]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:17.485]                   0L) {
[17:59:17.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:17.485]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:17.485]                   base::options(opts)
[17:59:17.485]                 }
[17:59:17.485]                 {
[17:59:17.485]                   {
[17:59:17.485]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:17.485]                     NULL
[17:59:17.485]                   }
[17:59:17.485]                   options(future.plan = NULL)
[17:59:17.485]                   if (is.na(NA_character_)) 
[17:59:17.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:17.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:17.485]                     .init = FALSE)
[17:59:17.485]                 }
[17:59:17.485]             }
[17:59:17.485]         }
[17:59:17.485]     })
[17:59:17.485]     if (TRUE) {
[17:59:17.485]         base::sink(type = "output", split = FALSE)
[17:59:17.485]         if (TRUE) {
[17:59:17.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:17.485]         }
[17:59:17.485]         else {
[17:59:17.485]             ...future.result["stdout"] <- base::list(NULL)
[17:59:17.485]         }
[17:59:17.485]         base::close(...future.stdout)
[17:59:17.485]         ...future.stdout <- NULL
[17:59:17.485]     }
[17:59:17.485]     ...future.result$conditions <- ...future.conditions
[17:59:17.485]     ...future.result$finished <- base::Sys.time()
[17:59:17.485]     ...future.result
[17:59:17.485] }
[17:59:17.491] assign_globals() ...
[17:59:17.492] List of 5
[17:59:17.492]  $ future.call.arguments    : list()
[17:59:17.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.492]  $ ...future.FUN            :function (x)  
[17:59:17.492]  $ ...future.elements_ii    :List of 3
[17:59:17.492]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:59:17.492]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:59:17.492]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:59:17.492]  $ ...future.seeds_ii       : NULL
[17:59:17.492]  $ ...future.globals.maxSize: num Inf
[17:59:17.492]  - attr(*, "resolved")= logi FALSE
[17:59:17.492]  - attr(*, "total_size")= num NA
[17:59:17.492]  - attr(*, "where")=List of 5
[17:59:17.492]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:17.492]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:17.492]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:17.492]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:17.492]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:17.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.492]  - attr(*, "already-done")= logi TRUE
[17:59:17.509] - copied ‘future.call.arguments’ to environment
[17:59:17.509] - copied ‘...future.FUN’ to environment
[17:59:17.509] - copied ‘...future.elements_ii’ to environment
[17:59:17.510] - copied ‘...future.seeds_ii’ to environment
[17:59:17.510] - copied ‘...future.globals.maxSize’ to environment
[17:59:17.510] assign_globals() ... done
[17:59:17.511] requestCore(): workers = 2
[17:59:17.514] MulticoreFuture started
[17:59:17.515] - Launch lazy future ... done
[17:59:17.516] run() for ‘MulticoreFuture’ ... done
[17:59:17.516] Created future:
[17:59:17.516] plan(): Setting new future strategy stack:
[17:59:17.517] List of future strategies:
[17:59:17.517] 1. sequential:
[17:59:17.517]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:17.517]    - tweaked: FALSE
[17:59:17.517]    - call: NULL
[17:59:17.519] plan(): nbrOfWorkers() = 1
[17:59:17.531] plan(): Setting new future strategy stack:
[17:59:17.532] List of future strategies:
[17:59:17.532] 1. multicore:
[17:59:17.532]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:17.532]    - tweaked: FALSE
[17:59:17.532]    - call: plan(strategy)
[17:59:17.517] MulticoreFuture:
[17:59:17.517] Label: ‘future_apply-2’
[17:59:17.517] Expression:
[17:59:17.517] {
[17:59:17.517]     do.call(function(...) {
[17:59:17.517]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.517]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.517]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.517]             on.exit(options(oopts), add = TRUE)
[17:59:17.517]         }
[17:59:17.517]         {
[17:59:17.517]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.517]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.517]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.517]             })
[17:59:17.517]         }
[17:59:17.517]     }, args = future.call.arguments)
[17:59:17.517] }
[17:59:17.517] Lazy evaluation: FALSE
[17:59:17.517] Asynchronous evaluation: TRUE
[17:59:17.517] Local evaluation: TRUE
[17:59:17.517] Environment: R_GlobalEnv
[17:59:17.517] Capture standard output: TRUE
[17:59:17.517] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:17.517] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:17.517] Packages: <none>
[17:59:17.517] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:17.517] Resolved: FALSE
[17:59:17.517] Value: <not collected>
[17:59:17.517] Conditions captured: <none>
[17:59:17.517] Early signaling: FALSE
[17:59:17.517] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:17.517] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.537] Chunk #2 of 2 ... DONE
[17:59:17.537] Launching 2 futures (chunks) ... DONE
[17:59:17.538] Resolving 2 futures (chunks) ...
[17:59:17.539] resolve() on list ...
[17:59:17.539]  recursive: 0
[17:59:17.540]  length: 2
[17:59:17.540] 
[17:59:17.541] Future #1
[17:59:17.542] result() for MulticoreFuture ...
[17:59:17.544] result() for MulticoreFuture ...
[17:59:17.545] result() for MulticoreFuture ... done
[17:59:17.545] plan(): nbrOfWorkers() = 2
[17:59:17.545] result() for MulticoreFuture ... done
[17:59:17.546] result() for MulticoreFuture ...
[17:59:17.546] result() for MulticoreFuture ... done
[17:59:17.547] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:17.548] - nx: 2
[17:59:17.548] - relay: TRUE
[17:59:17.549] - stdout: TRUE
[17:59:17.549] - signal: TRUE
[17:59:17.550] - resignal: FALSE
[17:59:17.550] - force: TRUE
[17:59:17.550] - relayed: [n=2] FALSE, FALSE
[17:59:17.551] - queued futures: [n=2] FALSE, FALSE
[17:59:17.551]  - until=1
[17:59:17.552]  - relaying element #1
[17:59:17.552] result() for MulticoreFuture ...
[17:59:17.552] result() for MulticoreFuture ... done
[17:59:17.553] result() for MulticoreFuture ...
[17:59:17.553] result() for MulticoreFuture ... done
[17:59:17.553] result() for MulticoreFuture ...
[17:59:17.553] result() for MulticoreFuture ... done
[17:59:17.554] result() for MulticoreFuture ...
[17:59:17.554] result() for MulticoreFuture ... done
[17:59:17.554] - relayed: [n=2] TRUE, FALSE
[17:59:17.555] - queued futures: [n=2] TRUE, FALSE
[17:59:17.555] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:17.556]  length: 1 (resolved future 1)
[17:59:17.556] Future #2
[17:59:17.557] result() for MulticoreFuture ...
[17:59:17.558] result() for MulticoreFuture ...
[17:59:17.558] result() for MulticoreFuture ... done
[17:59:17.559] result() for MulticoreFuture ... done
[17:59:17.559] result() for MulticoreFuture ...
[17:59:17.559] result() for MulticoreFuture ... done
[17:59:17.560] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:17.560] - nx: 2
[17:59:17.560] - relay: TRUE
[17:59:17.560] - stdout: TRUE
[17:59:17.560] - signal: TRUE
[17:59:17.561] - resignal: FALSE
[17:59:17.561] - force: TRUE
[17:59:17.561] - relayed: [n=2] TRUE, FALSE
[17:59:17.561] - queued futures: [n=2] TRUE, FALSE
[17:59:17.562]  - until=2
[17:59:17.562]  - relaying element #2
[17:59:17.562] result() for MulticoreFuture ...
[17:59:17.562] result() for MulticoreFuture ... done
[17:59:17.562] result() for MulticoreFuture ...
[17:59:17.563] result() for MulticoreFuture ... done
[17:59:17.563] result() for MulticoreFuture ...
[17:59:17.563] result() for MulticoreFuture ... done
[17:59:17.563] result() for MulticoreFuture ...
[17:59:17.564] result() for MulticoreFuture ... done
[17:59:17.564] - relayed: [n=2] TRUE, TRUE
[17:59:17.564] - queued futures: [n=2] TRUE, TRUE
[17:59:17.564] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:17.564]  length: 0 (resolved future 2)
[17:59:17.565] Relaying remaining futures
[17:59:17.565] signalConditionsASAP(NULL, pos=0) ...
[17:59:17.565] - nx: 2
[17:59:17.565] - relay: TRUE
[17:59:17.565] - stdout: TRUE
[17:59:17.566] - signal: TRUE
[17:59:17.566] - resignal: FALSE
[17:59:17.566] - force: TRUE
[17:59:17.566] - relayed: [n=2] TRUE, TRUE
[17:59:17.566] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:17.567] - relayed: [n=2] TRUE, TRUE
[17:59:17.567] - queued futures: [n=2] TRUE, TRUE
[17:59:17.567] signalConditionsASAP(NULL, pos=0) ... done
[17:59:17.567] resolve() on list ... DONE
[17:59:17.568] result() for MulticoreFuture ...
[17:59:17.568] result() for MulticoreFuture ... done
[17:59:17.568] result() for MulticoreFuture ...
[17:59:17.568] result() for MulticoreFuture ... done
[17:59:17.569] result() for MulticoreFuture ...
[17:59:17.569] result() for MulticoreFuture ... done
[17:59:17.569] result() for MulticoreFuture ...
[17:59:17.569] result() for MulticoreFuture ... done
[17:59:17.569]  - Number of value chunks collected: 2
[17:59:17.570] Resolving 2 futures (chunks) ... DONE
[17:59:17.570] Reducing values from 2 chunks ...
[17:59:17.570]  - Number of values collected after concatenation: 6
[17:59:17.570]  - Number of values expected: 6
[17:59:17.570] Reducing values from 2 chunks ... DONE
[17:59:17.571] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:59:17.571] getGlobalsAndPackagesXApply() ...
[17:59:17.572]  - future.globals: TRUE
[17:59:17.572] getGlobalsAndPackages() ...
[17:59:17.572] Searching for globals...
[17:59:17.575] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:59:17.575] Searching for globals ... DONE
[17:59:17.575] Resolving globals: FALSE
[17:59:17.576] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:59:17.577] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:59:17.577] - globals: [1] ‘FUN’
[17:59:17.578] 
[17:59:17.578] getGlobalsAndPackages() ... DONE
[17:59:17.578]  - globals found/used: [n=1] ‘FUN’
[17:59:17.578]  - needed namespaces: [n=0] 
[17:59:17.578] Finding globals ... DONE
[17:59:17.579]  - use_args: TRUE
[17:59:17.579]  - Getting '...' globals ...
[17:59:17.580] resolve() on list ...
[17:59:17.580]  recursive: 0
[17:59:17.580]  length: 1
[17:59:17.580]  elements: ‘...’
[17:59:17.580]  length: 0 (resolved future 1)
[17:59:17.581] resolve() on list ... DONE
[17:59:17.581]    - '...' content: [n=0] 
[17:59:17.581] List of 1
[17:59:17.581]  $ ...: list()
[17:59:17.581]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.581]  - attr(*, "where")=List of 1
[17:59:17.581]   ..$ ...:<environment: 0x560859cf5450> 
[17:59:17.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.581]  - attr(*, "resolved")= logi TRUE
[17:59:17.581]  - attr(*, "total_size")= num NA
[17:59:17.587]  - Getting '...' globals ... DONE
[17:59:17.587] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:17.588] List of 2
[17:59:17.588]  $ ...future.FUN:function (x)  
[17:59:17.588]  $ ...          : list()
[17:59:17.588]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.588]  - attr(*, "where")=List of 2
[17:59:17.588]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:17.588]   ..$ ...          :<environment: 0x560859cf5450> 
[17:59:17.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.588]  - attr(*, "resolved")= logi FALSE
[17:59:17.588]  - attr(*, "total_size")= num 1768
[17:59:17.593] Packages to be attached in all futures: [n=0] 
[17:59:17.593] getGlobalsAndPackagesXApply() ... DONE
[17:59:17.602] future_lapply() ...
[17:59:17.610] Number of chunks: 2
[17:59:17.610] getGlobalsAndPackagesXApply() ...
[17:59:17.610]  - future.globals: <name-value list> with names ‘list()’
[17:59:17.611]  - use_args: TRUE
[17:59:17.611] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:17.611] List of 2
[17:59:17.611]  $ ...          : list()
[17:59:17.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.611]  $ ...future.FUN:function (x)  
[17:59:17.611]  - attr(*, "where")=List of 2
[17:59:17.611]   ..$ ...          :<environment: 0x560859cf5450> 
[17:59:17.611]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:59:17.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.611]  - attr(*, "resolved")= logi FALSE
[17:59:17.611]  - attr(*, "total_size")= num NA
[17:59:17.617] Packages to be attached in all futures: [n=0] 
[17:59:17.617] getGlobalsAndPackagesXApply() ... DONE
[17:59:17.617] Number of futures (= number of chunks): 2
[17:59:17.618] Launching 2 futures (chunks) ...
[17:59:17.618] Chunk #1 of 2 ...
[17:59:17.618]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:17.618]  - seeds: <none>
[17:59:17.618]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.619] getGlobalsAndPackages() ...
[17:59:17.619] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.619] Resolving globals: FALSE
[17:59:17.619] Tweak future expression to call with '...' arguments ...
[17:59:17.620] {
[17:59:17.620]     do.call(function(...) {
[17:59:17.620]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.620]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.620]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.620]             on.exit(options(oopts), add = TRUE)
[17:59:17.620]         }
[17:59:17.620]         {
[17:59:17.620]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.620]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.620]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.620]             })
[17:59:17.620]         }
[17:59:17.620]     }, args = future.call.arguments)
[17:59:17.620] }
[17:59:17.620] Tweak future expression to call with '...' arguments ... DONE
[17:59:17.621] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.621] 
[17:59:17.621] getGlobalsAndPackages() ... DONE
[17:59:17.622] run() for ‘Future’ ...
[17:59:17.622] - state: ‘created’
[17:59:17.622] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:17.629] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.629] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:17.630]   - Field: ‘label’
[17:59:17.630]   - Field: ‘local’
[17:59:17.630]   - Field: ‘owner’
[17:59:17.630]   - Field: ‘envir’
[17:59:17.630]   - Field: ‘workers’
[17:59:17.631]   - Field: ‘packages’
[17:59:17.631]   - Field: ‘gc’
[17:59:17.631]   - Field: ‘job’
[17:59:17.631]   - Field: ‘conditions’
[17:59:17.631]   - Field: ‘expr’
[17:59:17.632]   - Field: ‘uuid’
[17:59:17.632]   - Field: ‘seed’
[17:59:17.632]   - Field: ‘version’
[17:59:17.632]   - Field: ‘result’
[17:59:17.632]   - Field: ‘asynchronous’
[17:59:17.633]   - Field: ‘calls’
[17:59:17.633]   - Field: ‘globals’
[17:59:17.633]   - Field: ‘stdout’
[17:59:17.633]   - Field: ‘earlySignal’
[17:59:17.633]   - Field: ‘lazy’
[17:59:17.634]   - Field: ‘state’
[17:59:17.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:17.634] - Launch lazy future ...
[17:59:17.635] Packages needed by the future expression (n = 0): <none>
[17:59:17.635] Packages needed by future strategies (n = 0): <none>
[17:59:17.636] {
[17:59:17.636]     {
[17:59:17.636]         {
[17:59:17.636]             ...future.startTime <- base::Sys.time()
[17:59:17.636]             {
[17:59:17.636]                 {
[17:59:17.636]                   {
[17:59:17.636]                     {
[17:59:17.636]                       base::local({
[17:59:17.636]                         has_future <- base::requireNamespace("future", 
[17:59:17.636]                           quietly = TRUE)
[17:59:17.636]                         if (has_future) {
[17:59:17.636]                           ns <- base::getNamespace("future")
[17:59:17.636]                           version <- ns[[".package"]][["version"]]
[17:59:17.636]                           if (is.null(version)) 
[17:59:17.636]                             version <- utils::packageVersion("future")
[17:59:17.636]                         }
[17:59:17.636]                         else {
[17:59:17.636]                           version <- NULL
[17:59:17.636]                         }
[17:59:17.636]                         if (!has_future || version < "1.8.0") {
[17:59:17.636]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:17.636]                             "", base::R.version$version.string), 
[17:59:17.636]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:17.636]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:17.636]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:17.636]                               "release", "version")], collapse = " "), 
[17:59:17.636]                             hostname = base::Sys.info()[["nodename"]])
[17:59:17.636]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:17.636]                             info)
[17:59:17.636]                           info <- base::paste(info, collapse = "; ")
[17:59:17.636]                           if (!has_future) {
[17:59:17.636]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:17.636]                               info)
[17:59:17.636]                           }
[17:59:17.636]                           else {
[17:59:17.636]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:17.636]                               info, version)
[17:59:17.636]                           }
[17:59:17.636]                           base::stop(msg)
[17:59:17.636]                         }
[17:59:17.636]                       })
[17:59:17.636]                     }
[17:59:17.636]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:17.636]                     base::options(mc.cores = 1L)
[17:59:17.636]                   }
[17:59:17.636]                   ...future.strategy.old <- future::plan("list")
[17:59:17.636]                   options(future.plan = NULL)
[17:59:17.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:17.636]                 }
[17:59:17.636]                 ...future.workdir <- getwd()
[17:59:17.636]             }
[17:59:17.636]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:17.636]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:17.636]         }
[17:59:17.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:17.636]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:17.636]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:17.636]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:17.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:17.636]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:17.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:17.636]             base::names(...future.oldOptions))
[17:59:17.636]     }
[17:59:17.636]     if (FALSE) {
[17:59:17.636]     }
[17:59:17.636]     else {
[17:59:17.636]         if (TRUE) {
[17:59:17.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:17.636]                 open = "w")
[17:59:17.636]         }
[17:59:17.636]         else {
[17:59:17.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:17.636]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:17.636]         }
[17:59:17.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:17.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:17.636]             base::sink(type = "output", split = FALSE)
[17:59:17.636]             base::close(...future.stdout)
[17:59:17.636]         }, add = TRUE)
[17:59:17.636]     }
[17:59:17.636]     ...future.frame <- base::sys.nframe()
[17:59:17.636]     ...future.conditions <- base::list()
[17:59:17.636]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:17.636]     if (FALSE) {
[17:59:17.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:17.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:17.636]     }
[17:59:17.636]     ...future.result <- base::tryCatch({
[17:59:17.636]         base::withCallingHandlers({
[17:59:17.636]             ...future.value <- base::withVisible(base::local({
[17:59:17.636]                 withCallingHandlers({
[17:59:17.636]                   {
[17:59:17.636]                     do.call(function(...) {
[17:59:17.636]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.636]                       if (!identical(...future.globals.maxSize.org, 
[17:59:17.636]                         ...future.globals.maxSize)) {
[17:59:17.636]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.636]                         on.exit(options(oopts), add = TRUE)
[17:59:17.636]                       }
[17:59:17.636]                       {
[17:59:17.636]                         lapply(seq_along(...future.elements_ii), 
[17:59:17.636]                           FUN = function(jj) {
[17:59:17.636]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.636]                             ...future.FUN(...future.X_jj, ...)
[17:59:17.636]                           })
[17:59:17.636]                       }
[17:59:17.636]                     }, args = future.call.arguments)
[17:59:17.636]                   }
[17:59:17.636]                 }, immediateCondition = function(cond) {
[17:59:17.636]                   save_rds <- function (object, pathname, ...) 
[17:59:17.636]                   {
[17:59:17.636]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:17.636]                     if (file_test("-f", pathname_tmp)) {
[17:59:17.636]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.636]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:17.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.636]                         fi_tmp[["mtime"]])
[17:59:17.636]                     }
[17:59:17.636]                     tryCatch({
[17:59:17.636]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:17.636]                     }, error = function(ex) {
[17:59:17.636]                       msg <- conditionMessage(ex)
[17:59:17.636]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.636]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:17.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.636]                         fi_tmp[["mtime"]], msg)
[17:59:17.636]                       ex$message <- msg
[17:59:17.636]                       stop(ex)
[17:59:17.636]                     })
[17:59:17.636]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:17.636]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:17.636]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:17.636]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.636]                       fi <- file.info(pathname)
[17:59:17.636]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:17.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.636]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:17.636]                         fi[["size"]], fi[["mtime"]])
[17:59:17.636]                       stop(msg)
[17:59:17.636]                     }
[17:59:17.636]                     invisible(pathname)
[17:59:17.636]                   }
[17:59:17.636]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:17.636]                     rootPath = tempdir()) 
[17:59:17.636]                   {
[17:59:17.636]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:17.636]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:17.636]                       tmpdir = path, fileext = ".rds")
[17:59:17.636]                     save_rds(obj, file)
[17:59:17.636]                   }
[17:59:17.636]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:17.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.636]                   {
[17:59:17.636]                     inherits <- base::inherits
[17:59:17.636]                     invokeRestart <- base::invokeRestart
[17:59:17.636]                     is.null <- base::is.null
[17:59:17.636]                     muffled <- FALSE
[17:59:17.636]                     if (inherits(cond, "message")) {
[17:59:17.636]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:17.636]                       if (muffled) 
[17:59:17.636]                         invokeRestart("muffleMessage")
[17:59:17.636]                     }
[17:59:17.636]                     else if (inherits(cond, "warning")) {
[17:59:17.636]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:17.636]                       if (muffled) 
[17:59:17.636]                         invokeRestart("muffleWarning")
[17:59:17.636]                     }
[17:59:17.636]                     else if (inherits(cond, "condition")) {
[17:59:17.636]                       if (!is.null(pattern)) {
[17:59:17.636]                         computeRestarts <- base::computeRestarts
[17:59:17.636]                         grepl <- base::grepl
[17:59:17.636]                         restarts <- computeRestarts(cond)
[17:59:17.636]                         for (restart in restarts) {
[17:59:17.636]                           name <- restart$name
[17:59:17.636]                           if (is.null(name)) 
[17:59:17.636]                             next
[17:59:17.636]                           if (!grepl(pattern, name)) 
[17:59:17.636]                             next
[17:59:17.636]                           invokeRestart(restart)
[17:59:17.636]                           muffled <- TRUE
[17:59:17.636]                           break
[17:59:17.636]                         }
[17:59:17.636]                       }
[17:59:17.636]                     }
[17:59:17.636]                     invisible(muffled)
[17:59:17.636]                   }
[17:59:17.636]                   muffleCondition(cond)
[17:59:17.636]                 })
[17:59:17.636]             }))
[17:59:17.636]             future::FutureResult(value = ...future.value$value, 
[17:59:17.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.636]                   ...future.rng), globalenv = if (FALSE) 
[17:59:17.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:17.636]                     ...future.globalenv.names))
[17:59:17.636]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:17.636]         }, condition = base::local({
[17:59:17.636]             c <- base::c
[17:59:17.636]             inherits <- base::inherits
[17:59:17.636]             invokeRestart <- base::invokeRestart
[17:59:17.636]             length <- base::length
[17:59:17.636]             list <- base::list
[17:59:17.636]             seq.int <- base::seq.int
[17:59:17.636]             signalCondition <- base::signalCondition
[17:59:17.636]             sys.calls <- base::sys.calls
[17:59:17.636]             `[[` <- base::`[[`
[17:59:17.636]             `+` <- base::`+`
[17:59:17.636]             `<<-` <- base::`<<-`
[17:59:17.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:17.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:17.636]                   3L)]
[17:59:17.636]             }
[17:59:17.636]             function(cond) {
[17:59:17.636]                 is_error <- inherits(cond, "error")
[17:59:17.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:17.636]                   NULL)
[17:59:17.636]                 if (is_error) {
[17:59:17.636]                   sessionInformation <- function() {
[17:59:17.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:17.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:17.636]                       search = base::search(), system = base::Sys.info())
[17:59:17.636]                   }
[17:59:17.636]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:17.636]                     cond$call), session = sessionInformation(), 
[17:59:17.636]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:17.636]                   signalCondition(cond)
[17:59:17.636]                 }
[17:59:17.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:17.636]                 "immediateCondition"))) {
[17:59:17.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:17.636]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:17.636]                   if (TRUE && !signal) {
[17:59:17.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.636]                     {
[17:59:17.636]                       inherits <- base::inherits
[17:59:17.636]                       invokeRestart <- base::invokeRestart
[17:59:17.636]                       is.null <- base::is.null
[17:59:17.636]                       muffled <- FALSE
[17:59:17.636]                       if (inherits(cond, "message")) {
[17:59:17.636]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.636]                         if (muffled) 
[17:59:17.636]                           invokeRestart("muffleMessage")
[17:59:17.636]                       }
[17:59:17.636]                       else if (inherits(cond, "warning")) {
[17:59:17.636]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.636]                         if (muffled) 
[17:59:17.636]                           invokeRestart("muffleWarning")
[17:59:17.636]                       }
[17:59:17.636]                       else if (inherits(cond, "condition")) {
[17:59:17.636]                         if (!is.null(pattern)) {
[17:59:17.636]                           computeRestarts <- base::computeRestarts
[17:59:17.636]                           grepl <- base::grepl
[17:59:17.636]                           restarts <- computeRestarts(cond)
[17:59:17.636]                           for (restart in restarts) {
[17:59:17.636]                             name <- restart$name
[17:59:17.636]                             if (is.null(name)) 
[17:59:17.636]                               next
[17:59:17.636]                             if (!grepl(pattern, name)) 
[17:59:17.636]                               next
[17:59:17.636]                             invokeRestart(restart)
[17:59:17.636]                             muffled <- TRUE
[17:59:17.636]                             break
[17:59:17.636]                           }
[17:59:17.636]                         }
[17:59:17.636]                       }
[17:59:17.636]                       invisible(muffled)
[17:59:17.636]                     }
[17:59:17.636]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.636]                   }
[17:59:17.636]                 }
[17:59:17.636]                 else {
[17:59:17.636]                   if (TRUE) {
[17:59:17.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.636]                     {
[17:59:17.636]                       inherits <- base::inherits
[17:59:17.636]                       invokeRestart <- base::invokeRestart
[17:59:17.636]                       is.null <- base::is.null
[17:59:17.636]                       muffled <- FALSE
[17:59:17.636]                       if (inherits(cond, "message")) {
[17:59:17.636]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.636]                         if (muffled) 
[17:59:17.636]                           invokeRestart("muffleMessage")
[17:59:17.636]                       }
[17:59:17.636]                       else if (inherits(cond, "warning")) {
[17:59:17.636]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.636]                         if (muffled) 
[17:59:17.636]                           invokeRestart("muffleWarning")
[17:59:17.636]                       }
[17:59:17.636]                       else if (inherits(cond, "condition")) {
[17:59:17.636]                         if (!is.null(pattern)) {
[17:59:17.636]                           computeRestarts <- base::computeRestarts
[17:59:17.636]                           grepl <- base::grepl
[17:59:17.636]                           restarts <- computeRestarts(cond)
[17:59:17.636]                           for (restart in restarts) {
[17:59:17.636]                             name <- restart$name
[17:59:17.636]                             if (is.null(name)) 
[17:59:17.636]                               next
[17:59:17.636]                             if (!grepl(pattern, name)) 
[17:59:17.636]                               next
[17:59:17.636]                             invokeRestart(restart)
[17:59:17.636]                             muffled <- TRUE
[17:59:17.636]                             break
[17:59:17.636]                           }
[17:59:17.636]                         }
[17:59:17.636]                       }
[17:59:17.636]                       invisible(muffled)
[17:59:17.636]                     }
[17:59:17.636]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.636]                   }
[17:59:17.636]                 }
[17:59:17.636]             }
[17:59:17.636]         }))
[17:59:17.636]     }, error = function(ex) {
[17:59:17.636]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:17.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.636]                 ...future.rng), started = ...future.startTime, 
[17:59:17.636]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:17.636]             version = "1.8"), class = "FutureResult")
[17:59:17.636]     }, finally = {
[17:59:17.636]         if (!identical(...future.workdir, getwd())) 
[17:59:17.636]             setwd(...future.workdir)
[17:59:17.636]         {
[17:59:17.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:17.636]                 ...future.oldOptions$nwarnings <- NULL
[17:59:17.636]             }
[17:59:17.636]             base::options(...future.oldOptions)
[17:59:17.636]             if (.Platform$OS.type == "windows") {
[17:59:17.636]                 old_names <- names(...future.oldEnvVars)
[17:59:17.636]                 envs <- base::Sys.getenv()
[17:59:17.636]                 names <- names(envs)
[17:59:17.636]                 common <- intersect(names, old_names)
[17:59:17.636]                 added <- setdiff(names, old_names)
[17:59:17.636]                 removed <- setdiff(old_names, names)
[17:59:17.636]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:17.636]                   envs[common]]
[17:59:17.636]                 NAMES <- toupper(changed)
[17:59:17.636]                 args <- list()
[17:59:17.636]                 for (kk in seq_along(NAMES)) {
[17:59:17.636]                   name <- changed[[kk]]
[17:59:17.636]                   NAME <- NAMES[[kk]]
[17:59:17.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.636]                     next
[17:59:17.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.636]                 }
[17:59:17.636]                 NAMES <- toupper(added)
[17:59:17.636]                 for (kk in seq_along(NAMES)) {
[17:59:17.636]                   name <- added[[kk]]
[17:59:17.636]                   NAME <- NAMES[[kk]]
[17:59:17.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.636]                     next
[17:59:17.636]                   args[[name]] <- ""
[17:59:17.636]                 }
[17:59:17.636]                 NAMES <- toupper(removed)
[17:59:17.636]                 for (kk in seq_along(NAMES)) {
[17:59:17.636]                   name <- removed[[kk]]
[17:59:17.636]                   NAME <- NAMES[[kk]]
[17:59:17.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.636]                     next
[17:59:17.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.636]                 }
[17:59:17.636]                 if (length(args) > 0) 
[17:59:17.636]                   base::do.call(base::Sys.setenv, args = args)
[17:59:17.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:17.636]             }
[17:59:17.636]             else {
[17:59:17.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:17.636]             }
[17:59:17.636]             {
[17:59:17.636]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:17.636]                   0L) {
[17:59:17.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:17.636]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:17.636]                   base::options(opts)
[17:59:17.636]                 }
[17:59:17.636]                 {
[17:59:17.636]                   {
[17:59:17.636]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:17.636]                     NULL
[17:59:17.636]                   }
[17:59:17.636]                   options(future.plan = NULL)
[17:59:17.636]                   if (is.na(NA_character_)) 
[17:59:17.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:17.636]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:17.636]                     .init = FALSE)
[17:59:17.636]                 }
[17:59:17.636]             }
[17:59:17.636]         }
[17:59:17.636]     })
[17:59:17.636]     if (TRUE) {
[17:59:17.636]         base::sink(type = "output", split = FALSE)
[17:59:17.636]         if (TRUE) {
[17:59:17.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:17.636]         }
[17:59:17.636]         else {
[17:59:17.636]             ...future.result["stdout"] <- base::list(NULL)
[17:59:17.636]         }
[17:59:17.636]         base::close(...future.stdout)
[17:59:17.636]         ...future.stdout <- NULL
[17:59:17.636]     }
[17:59:17.636]     ...future.result$conditions <- ...future.conditions
[17:59:17.636]     ...future.result$finished <- base::Sys.time()
[17:59:17.636]     ...future.result
[17:59:17.636] }
[17:59:17.640] assign_globals() ...
[17:59:17.640] List of 5
[17:59:17.640]  $ future.call.arguments    : list()
[17:59:17.640]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.640]  $ ...future.FUN            :function (x)  
[17:59:17.640]  $ ...future.elements_ii    :List of 3
[17:59:17.640]   ..$ : int [1:4] 1 7 13 19
[17:59:17.640]   ..$ : int [1:4] 2 8 14 20
[17:59:17.640]   ..$ : int [1:4] 3 9 15 21
[17:59:17.640]  $ ...future.seeds_ii       : NULL
[17:59:17.640]  $ ...future.globals.maxSize: num Inf
[17:59:17.640]  - attr(*, "resolved")= logi FALSE
[17:59:17.640]  - attr(*, "total_size")= num NA
[17:59:17.640]  - attr(*, "where")=List of 5
[17:59:17.640]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:17.640]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:17.640]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:17.640]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:17.640]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:17.640]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.640]  - attr(*, "already-done")= logi TRUE
[17:59:17.651] - copied ‘future.call.arguments’ to environment
[17:59:17.651] - reassign environment for ‘...future.FUN’
[17:59:17.651] - copied ‘...future.FUN’ to environment
[17:59:17.652] - copied ‘...future.elements_ii’ to environment
[17:59:17.652] - copied ‘...future.seeds_ii’ to environment
[17:59:17.652] - copied ‘...future.globals.maxSize’ to environment
[17:59:17.652] assign_globals() ... done
[17:59:17.653] requestCore(): workers = 2
[17:59:17.656] MulticoreFuture started
[17:59:17.657] - Launch lazy future ... done
[17:59:17.657] run() for ‘MulticoreFuture’ ... done
[17:59:17.658] Created future:
[17:59:17.658] plan(): Setting new future strategy stack:
[17:59:17.658] List of future strategies:
[17:59:17.658] 1. sequential:
[17:59:17.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:17.658]    - tweaked: FALSE
[17:59:17.658]    - call: NULL
[17:59:17.660] plan(): nbrOfWorkers() = 1
[17:59:17.664] plan(): Setting new future strategy stack:
[17:59:17.665] List of future strategies:
[17:59:17.665] 1. multicore:
[17:59:17.665]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:17.665]    - tweaked: FALSE
[17:59:17.665]    - call: plan(strategy)
[17:59:17.658] MulticoreFuture:
[17:59:17.658] Label: ‘future_apply-1’
[17:59:17.658] Expression:
[17:59:17.658] {
[17:59:17.658]     do.call(function(...) {
[17:59:17.658]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.658]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.658]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.658]             on.exit(options(oopts), add = TRUE)
[17:59:17.658]         }
[17:59:17.658]         {
[17:59:17.658]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.658]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.658]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.658]             })
[17:59:17.658]         }
[17:59:17.658]     }, args = future.call.arguments)
[17:59:17.658] }
[17:59:17.658] Lazy evaluation: FALSE
[17:59:17.658] Asynchronous evaluation: TRUE
[17:59:17.658] Local evaluation: TRUE
[17:59:17.658] Environment: R_GlobalEnv
[17:59:17.658] Capture standard output: TRUE
[17:59:17.658] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:17.658] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:17.658] Packages: <none>
[17:59:17.658] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:17.658] Resolved: FALSE
[17:59:17.658] Value: <not collected>
[17:59:17.658] Conditions captured: <none>
[17:59:17.658] Early signaling: FALSE
[17:59:17.658] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:17.658] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.675] Chunk #1 of 2 ... DONE
[17:59:17.675] Chunk #2 of 2 ...
[17:59:17.678]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:17.678]  - seeds: <none>
[17:59:17.685] plan(): nbrOfWorkers() = 2
[17:59:17.678]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.687] getGlobalsAndPackages() ...
[17:59:17.687] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.688] Resolving globals: FALSE
[17:59:17.689] Tweak future expression to call with '...' arguments ...
[17:59:17.689] {
[17:59:17.689]     do.call(function(...) {
[17:59:17.689]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.689]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.689]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.689]             on.exit(options(oopts), add = TRUE)
[17:59:17.689]         }
[17:59:17.689]         {
[17:59:17.689]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.689]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.689]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.689]             })
[17:59:17.689]         }
[17:59:17.689]     }, args = future.call.arguments)
[17:59:17.689] }
[17:59:17.691] Tweak future expression to call with '...' arguments ... DONE
[17:59:17.692] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.693] 
[17:59:17.694] getGlobalsAndPackages() ... DONE
[17:59:17.695] run() for ‘Future’ ...
[17:59:17.696] - state: ‘created’
[17:59:17.697] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:17.707] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:17.708]   - Field: ‘label’
[17:59:17.708]   - Field: ‘local’
[17:59:17.709]   - Field: ‘owner’
[17:59:17.709]   - Field: ‘envir’
[17:59:17.709]   - Field: ‘workers’
[17:59:17.709]   - Field: ‘packages’
[17:59:17.710]   - Field: ‘gc’
[17:59:17.710]   - Field: ‘job’
[17:59:17.711]   - Field: ‘conditions’
[17:59:17.711]   - Field: ‘expr’
[17:59:17.712]   - Field: ‘uuid’
[17:59:17.712]   - Field: ‘seed’
[17:59:17.713]   - Field: ‘version’
[17:59:17.713]   - Field: ‘result’
[17:59:17.713]   - Field: ‘asynchronous’
[17:59:17.714]   - Field: ‘calls’
[17:59:17.714]   - Field: ‘globals’
[17:59:17.714]   - Field: ‘stdout’
[17:59:17.714]   - Field: ‘earlySignal’
[17:59:17.715]   - Field: ‘lazy’
[17:59:17.715]   - Field: ‘state’
[17:59:17.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:17.716] - Launch lazy future ...
[17:59:17.716] Packages needed by the future expression (n = 0): <none>
[17:59:17.717] Packages needed by future strategies (n = 0): <none>
[17:59:17.718] {
[17:59:17.718]     {
[17:59:17.718]         {
[17:59:17.718]             ...future.startTime <- base::Sys.time()
[17:59:17.718]             {
[17:59:17.718]                 {
[17:59:17.718]                   {
[17:59:17.718]                     {
[17:59:17.718]                       base::local({
[17:59:17.718]                         has_future <- base::requireNamespace("future", 
[17:59:17.718]                           quietly = TRUE)
[17:59:17.718]                         if (has_future) {
[17:59:17.718]                           ns <- base::getNamespace("future")
[17:59:17.718]                           version <- ns[[".package"]][["version"]]
[17:59:17.718]                           if (is.null(version)) 
[17:59:17.718]                             version <- utils::packageVersion("future")
[17:59:17.718]                         }
[17:59:17.718]                         else {
[17:59:17.718]                           version <- NULL
[17:59:17.718]                         }
[17:59:17.718]                         if (!has_future || version < "1.8.0") {
[17:59:17.718]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:17.718]                             "", base::R.version$version.string), 
[17:59:17.718]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:17.718]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:17.718]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:17.718]                               "release", "version")], collapse = " "), 
[17:59:17.718]                             hostname = base::Sys.info()[["nodename"]])
[17:59:17.718]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:17.718]                             info)
[17:59:17.718]                           info <- base::paste(info, collapse = "; ")
[17:59:17.718]                           if (!has_future) {
[17:59:17.718]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:17.718]                               info)
[17:59:17.718]                           }
[17:59:17.718]                           else {
[17:59:17.718]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:17.718]                               info, version)
[17:59:17.718]                           }
[17:59:17.718]                           base::stop(msg)
[17:59:17.718]                         }
[17:59:17.718]                       })
[17:59:17.718]                     }
[17:59:17.718]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:17.718]                     base::options(mc.cores = 1L)
[17:59:17.718]                   }
[17:59:17.718]                   ...future.strategy.old <- future::plan("list")
[17:59:17.718]                   options(future.plan = NULL)
[17:59:17.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:17.718]                 }
[17:59:17.718]                 ...future.workdir <- getwd()
[17:59:17.718]             }
[17:59:17.718]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:17.718]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:17.718]         }
[17:59:17.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:17.718]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:17.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:17.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:17.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:17.718]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:17.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:17.718]             base::names(...future.oldOptions))
[17:59:17.718]     }
[17:59:17.718]     if (FALSE) {
[17:59:17.718]     }
[17:59:17.718]     else {
[17:59:17.718]         if (TRUE) {
[17:59:17.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:17.718]                 open = "w")
[17:59:17.718]         }
[17:59:17.718]         else {
[17:59:17.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:17.718]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:17.718]         }
[17:59:17.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:17.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:17.718]             base::sink(type = "output", split = FALSE)
[17:59:17.718]             base::close(...future.stdout)
[17:59:17.718]         }, add = TRUE)
[17:59:17.718]     }
[17:59:17.718]     ...future.frame <- base::sys.nframe()
[17:59:17.718]     ...future.conditions <- base::list()
[17:59:17.718]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:17.718]     if (FALSE) {
[17:59:17.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:17.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:17.718]     }
[17:59:17.718]     ...future.result <- base::tryCatch({
[17:59:17.718]         base::withCallingHandlers({
[17:59:17.718]             ...future.value <- base::withVisible(base::local({
[17:59:17.718]                 withCallingHandlers({
[17:59:17.718]                   {
[17:59:17.718]                     do.call(function(...) {
[17:59:17.718]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.718]                       if (!identical(...future.globals.maxSize.org, 
[17:59:17.718]                         ...future.globals.maxSize)) {
[17:59:17.718]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.718]                         on.exit(options(oopts), add = TRUE)
[17:59:17.718]                       }
[17:59:17.718]                       {
[17:59:17.718]                         lapply(seq_along(...future.elements_ii), 
[17:59:17.718]                           FUN = function(jj) {
[17:59:17.718]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.718]                             ...future.FUN(...future.X_jj, ...)
[17:59:17.718]                           })
[17:59:17.718]                       }
[17:59:17.718]                     }, args = future.call.arguments)
[17:59:17.718]                   }
[17:59:17.718]                 }, immediateCondition = function(cond) {
[17:59:17.718]                   save_rds <- function (object, pathname, ...) 
[17:59:17.718]                   {
[17:59:17.718]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:17.718]                     if (file_test("-f", pathname_tmp)) {
[17:59:17.718]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.718]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:17.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.718]                         fi_tmp[["mtime"]])
[17:59:17.718]                     }
[17:59:17.718]                     tryCatch({
[17:59:17.718]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:17.718]                     }, error = function(ex) {
[17:59:17.718]                       msg <- conditionMessage(ex)
[17:59:17.718]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.718]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:17.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.718]                         fi_tmp[["mtime"]], msg)
[17:59:17.718]                       ex$message <- msg
[17:59:17.718]                       stop(ex)
[17:59:17.718]                     })
[17:59:17.718]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:17.718]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:17.718]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:17.718]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.718]                       fi <- file.info(pathname)
[17:59:17.718]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:17.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.718]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:17.718]                         fi[["size"]], fi[["mtime"]])
[17:59:17.718]                       stop(msg)
[17:59:17.718]                     }
[17:59:17.718]                     invisible(pathname)
[17:59:17.718]                   }
[17:59:17.718]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:17.718]                     rootPath = tempdir()) 
[17:59:17.718]                   {
[17:59:17.718]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:17.718]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:17.718]                       tmpdir = path, fileext = ".rds")
[17:59:17.718]                     save_rds(obj, file)
[17:59:17.718]                   }
[17:59:17.718]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:17.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.718]                   {
[17:59:17.718]                     inherits <- base::inherits
[17:59:17.718]                     invokeRestart <- base::invokeRestart
[17:59:17.718]                     is.null <- base::is.null
[17:59:17.718]                     muffled <- FALSE
[17:59:17.718]                     if (inherits(cond, "message")) {
[17:59:17.718]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:17.718]                       if (muffled) 
[17:59:17.718]                         invokeRestart("muffleMessage")
[17:59:17.718]                     }
[17:59:17.718]                     else if (inherits(cond, "warning")) {
[17:59:17.718]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:17.718]                       if (muffled) 
[17:59:17.718]                         invokeRestart("muffleWarning")
[17:59:17.718]                     }
[17:59:17.718]                     else if (inherits(cond, "condition")) {
[17:59:17.718]                       if (!is.null(pattern)) {
[17:59:17.718]                         computeRestarts <- base::computeRestarts
[17:59:17.718]                         grepl <- base::grepl
[17:59:17.718]                         restarts <- computeRestarts(cond)
[17:59:17.718]                         for (restart in restarts) {
[17:59:17.718]                           name <- restart$name
[17:59:17.718]                           if (is.null(name)) 
[17:59:17.718]                             next
[17:59:17.718]                           if (!grepl(pattern, name)) 
[17:59:17.718]                             next
[17:59:17.718]                           invokeRestart(restart)
[17:59:17.718]                           muffled <- TRUE
[17:59:17.718]                           break
[17:59:17.718]                         }
[17:59:17.718]                       }
[17:59:17.718]                     }
[17:59:17.718]                     invisible(muffled)
[17:59:17.718]                   }
[17:59:17.718]                   muffleCondition(cond)
[17:59:17.718]                 })
[17:59:17.718]             }))
[17:59:17.718]             future::FutureResult(value = ...future.value$value, 
[17:59:17.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.718]                   ...future.rng), globalenv = if (FALSE) 
[17:59:17.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:17.718]                     ...future.globalenv.names))
[17:59:17.718]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:17.718]         }, condition = base::local({
[17:59:17.718]             c <- base::c
[17:59:17.718]             inherits <- base::inherits
[17:59:17.718]             invokeRestart <- base::invokeRestart
[17:59:17.718]             length <- base::length
[17:59:17.718]             list <- base::list
[17:59:17.718]             seq.int <- base::seq.int
[17:59:17.718]             signalCondition <- base::signalCondition
[17:59:17.718]             sys.calls <- base::sys.calls
[17:59:17.718]             `[[` <- base::`[[`
[17:59:17.718]             `+` <- base::`+`
[17:59:17.718]             `<<-` <- base::`<<-`
[17:59:17.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:17.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:17.718]                   3L)]
[17:59:17.718]             }
[17:59:17.718]             function(cond) {
[17:59:17.718]                 is_error <- inherits(cond, "error")
[17:59:17.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:17.718]                   NULL)
[17:59:17.718]                 if (is_error) {
[17:59:17.718]                   sessionInformation <- function() {
[17:59:17.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:17.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:17.718]                       search = base::search(), system = base::Sys.info())
[17:59:17.718]                   }
[17:59:17.718]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:17.718]                     cond$call), session = sessionInformation(), 
[17:59:17.718]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:17.718]                   signalCondition(cond)
[17:59:17.718]                 }
[17:59:17.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:17.718]                 "immediateCondition"))) {
[17:59:17.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:17.718]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:17.718]                   if (TRUE && !signal) {
[17:59:17.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.718]                     {
[17:59:17.718]                       inherits <- base::inherits
[17:59:17.718]                       invokeRestart <- base::invokeRestart
[17:59:17.718]                       is.null <- base::is.null
[17:59:17.718]                       muffled <- FALSE
[17:59:17.718]                       if (inherits(cond, "message")) {
[17:59:17.718]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.718]                         if (muffled) 
[17:59:17.718]                           invokeRestart("muffleMessage")
[17:59:17.718]                       }
[17:59:17.718]                       else if (inherits(cond, "warning")) {
[17:59:17.718]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.718]                         if (muffled) 
[17:59:17.718]                           invokeRestart("muffleWarning")
[17:59:17.718]                       }
[17:59:17.718]                       else if (inherits(cond, "condition")) {
[17:59:17.718]                         if (!is.null(pattern)) {
[17:59:17.718]                           computeRestarts <- base::computeRestarts
[17:59:17.718]                           grepl <- base::grepl
[17:59:17.718]                           restarts <- computeRestarts(cond)
[17:59:17.718]                           for (restart in restarts) {
[17:59:17.718]                             name <- restart$name
[17:59:17.718]                             if (is.null(name)) 
[17:59:17.718]                               next
[17:59:17.718]                             if (!grepl(pattern, name)) 
[17:59:17.718]                               next
[17:59:17.718]                             invokeRestart(restart)
[17:59:17.718]                             muffled <- TRUE
[17:59:17.718]                             break
[17:59:17.718]                           }
[17:59:17.718]                         }
[17:59:17.718]                       }
[17:59:17.718]                       invisible(muffled)
[17:59:17.718]                     }
[17:59:17.718]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.718]                   }
[17:59:17.718]                 }
[17:59:17.718]                 else {
[17:59:17.718]                   if (TRUE) {
[17:59:17.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.718]                     {
[17:59:17.718]                       inherits <- base::inherits
[17:59:17.718]                       invokeRestart <- base::invokeRestart
[17:59:17.718]                       is.null <- base::is.null
[17:59:17.718]                       muffled <- FALSE
[17:59:17.718]                       if (inherits(cond, "message")) {
[17:59:17.718]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.718]                         if (muffled) 
[17:59:17.718]                           invokeRestart("muffleMessage")
[17:59:17.718]                       }
[17:59:17.718]                       else if (inherits(cond, "warning")) {
[17:59:17.718]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.718]                         if (muffled) 
[17:59:17.718]                           invokeRestart("muffleWarning")
[17:59:17.718]                       }
[17:59:17.718]                       else if (inherits(cond, "condition")) {
[17:59:17.718]                         if (!is.null(pattern)) {
[17:59:17.718]                           computeRestarts <- base::computeRestarts
[17:59:17.718]                           grepl <- base::grepl
[17:59:17.718]                           restarts <- computeRestarts(cond)
[17:59:17.718]                           for (restart in restarts) {
[17:59:17.718]                             name <- restart$name
[17:59:17.718]                             if (is.null(name)) 
[17:59:17.718]                               next
[17:59:17.718]                             if (!grepl(pattern, name)) 
[17:59:17.718]                               next
[17:59:17.718]                             invokeRestart(restart)
[17:59:17.718]                             muffled <- TRUE
[17:59:17.718]                             break
[17:59:17.718]                           }
[17:59:17.718]                         }
[17:59:17.718]                       }
[17:59:17.718]                       invisible(muffled)
[17:59:17.718]                     }
[17:59:17.718]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.718]                   }
[17:59:17.718]                 }
[17:59:17.718]             }
[17:59:17.718]         }))
[17:59:17.718]     }, error = function(ex) {
[17:59:17.718]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:17.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.718]                 ...future.rng), started = ...future.startTime, 
[17:59:17.718]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:17.718]             version = "1.8"), class = "FutureResult")
[17:59:17.718]     }, finally = {
[17:59:17.718]         if (!identical(...future.workdir, getwd())) 
[17:59:17.718]             setwd(...future.workdir)
[17:59:17.718]         {
[17:59:17.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:17.718]                 ...future.oldOptions$nwarnings <- NULL
[17:59:17.718]             }
[17:59:17.718]             base::options(...future.oldOptions)
[17:59:17.718]             if (.Platform$OS.type == "windows") {
[17:59:17.718]                 old_names <- names(...future.oldEnvVars)
[17:59:17.718]                 envs <- base::Sys.getenv()
[17:59:17.718]                 names <- names(envs)
[17:59:17.718]                 common <- intersect(names, old_names)
[17:59:17.718]                 added <- setdiff(names, old_names)
[17:59:17.718]                 removed <- setdiff(old_names, names)
[17:59:17.718]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:17.718]                   envs[common]]
[17:59:17.718]                 NAMES <- toupper(changed)
[17:59:17.718]                 args <- list()
[17:59:17.718]                 for (kk in seq_along(NAMES)) {
[17:59:17.718]                   name <- changed[[kk]]
[17:59:17.718]                   NAME <- NAMES[[kk]]
[17:59:17.718]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.718]                     next
[17:59:17.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.718]                 }
[17:59:17.718]                 NAMES <- toupper(added)
[17:59:17.718]                 for (kk in seq_along(NAMES)) {
[17:59:17.718]                   name <- added[[kk]]
[17:59:17.718]                   NAME <- NAMES[[kk]]
[17:59:17.718]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.718]                     next
[17:59:17.718]                   args[[name]] <- ""
[17:59:17.718]                 }
[17:59:17.718]                 NAMES <- toupper(removed)
[17:59:17.718]                 for (kk in seq_along(NAMES)) {
[17:59:17.718]                   name <- removed[[kk]]
[17:59:17.718]                   NAME <- NAMES[[kk]]
[17:59:17.718]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.718]                     next
[17:59:17.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.718]                 }
[17:59:17.718]                 if (length(args) > 0) 
[17:59:17.718]                   base::do.call(base::Sys.setenv, args = args)
[17:59:17.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:17.718]             }
[17:59:17.718]             else {
[17:59:17.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:17.718]             }
[17:59:17.718]             {
[17:59:17.718]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:17.718]                   0L) {
[17:59:17.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:17.718]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:17.718]                   base::options(opts)
[17:59:17.718]                 }
[17:59:17.718]                 {
[17:59:17.718]                   {
[17:59:17.718]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:17.718]                     NULL
[17:59:17.718]                   }
[17:59:17.718]                   options(future.plan = NULL)
[17:59:17.718]                   if (is.na(NA_character_)) 
[17:59:17.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:17.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:17.718]                     .init = FALSE)
[17:59:17.718]                 }
[17:59:17.718]             }
[17:59:17.718]         }
[17:59:17.718]     })
[17:59:17.718]     if (TRUE) {
[17:59:17.718]         base::sink(type = "output", split = FALSE)
[17:59:17.718]         if (TRUE) {
[17:59:17.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:17.718]         }
[17:59:17.718]         else {
[17:59:17.718]             ...future.result["stdout"] <- base::list(NULL)
[17:59:17.718]         }
[17:59:17.718]         base::close(...future.stdout)
[17:59:17.718]         ...future.stdout <- NULL
[17:59:17.718]     }
[17:59:17.718]     ...future.result$conditions <- ...future.conditions
[17:59:17.718]     ...future.result$finished <- base::Sys.time()
[17:59:17.718]     ...future.result
[17:59:17.718] }
[17:59:17.724] assign_globals() ...
[17:59:17.724] List of 5
[17:59:17.724]  $ future.call.arguments    : list()
[17:59:17.724]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.724]  $ ...future.FUN            :function (x)  
[17:59:17.724]  $ ...future.elements_ii    :List of 3
[17:59:17.724]   ..$ : int [1:4] 4 10 16 22
[17:59:17.724]   ..$ : int [1:4] 5 11 17 23
[17:59:17.724]   ..$ : int [1:4] 6 12 18 24
[17:59:17.724]  $ ...future.seeds_ii       : NULL
[17:59:17.724]  $ ...future.globals.maxSize: num Inf
[17:59:17.724]  - attr(*, "resolved")= logi FALSE
[17:59:17.724]  - attr(*, "total_size")= num NA
[17:59:17.724]  - attr(*, "where")=List of 5
[17:59:17.724]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:17.724]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:17.724]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:17.724]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:17.724]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:17.724]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.724]  - attr(*, "already-done")= logi TRUE
[17:59:17.740] - copied ‘future.call.arguments’ to environment
[17:59:17.740] - reassign environment for ‘...future.FUN’
[17:59:17.740] - copied ‘...future.FUN’ to environment
[17:59:17.741] - copied ‘...future.elements_ii’ to environment
[17:59:17.741] - copied ‘...future.seeds_ii’ to environment
[17:59:17.741] - copied ‘...future.globals.maxSize’ to environment
[17:59:17.742] assign_globals() ... done
[17:59:17.742] requestCore(): workers = 2
[17:59:17.745] MulticoreFuture started
[17:59:17.746] - Launch lazy future ... done
[17:59:17.746] run() for ‘MulticoreFuture’ ... done
[17:59:17.747] Created future:
[17:59:17.747] plan(): Setting new future strategy stack:
[17:59:17.748] List of future strategies:
[17:59:17.748] 1. sequential:
[17:59:17.748]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:17.748]    - tweaked: FALSE
[17:59:17.748]    - call: NULL
[17:59:17.750] plan(): nbrOfWorkers() = 1
[17:59:17.754] plan(): Setting new future strategy stack:
[17:59:17.754] List of future strategies:
[17:59:17.754] 1. multicore:
[17:59:17.754]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:17.754]    - tweaked: FALSE
[17:59:17.754]    - call: plan(strategy)
[17:59:17.748] MulticoreFuture:
[17:59:17.748] Label: ‘future_apply-2’
[17:59:17.748] Expression:
[17:59:17.748] {
[17:59:17.748]     do.call(function(...) {
[17:59:17.748]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.748]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.748]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.748]             on.exit(options(oopts), add = TRUE)
[17:59:17.748]         }
[17:59:17.748]         {
[17:59:17.748]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.748]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.748]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.748]             })
[17:59:17.748]         }
[17:59:17.748]     }, args = future.call.arguments)
[17:59:17.748] }
[17:59:17.748] Lazy evaluation: FALSE
[17:59:17.748] Asynchronous evaluation: TRUE
[17:59:17.748] Local evaluation: TRUE
[17:59:17.748] Environment: R_GlobalEnv
[17:59:17.748] Capture standard output: TRUE
[17:59:17.748] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:17.748] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:17.748] Packages: <none>
[17:59:17.748] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:17.748] Resolved: FALSE
[17:59:17.748] Value: <not collected>
[17:59:17.748] Conditions captured: <none>
[17:59:17.748] Early signaling: FALSE
[17:59:17.748] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:17.748] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.763] Chunk #2 of 2 ... DONE
[17:59:17.763] plan(): nbrOfWorkers() = 2
[17:59:17.763] Launching 2 futures (chunks) ... DONE
[17:59:17.764] Resolving 2 futures (chunks) ...
[17:59:17.764] resolve() on list ...
[17:59:17.764]  recursive: 0
[17:59:17.765]  length: 2
[17:59:17.765] 
[17:59:17.766] Future #1
[17:59:17.766] result() for MulticoreFuture ...
[17:59:17.768] result() for MulticoreFuture ...
[17:59:17.768] result() for MulticoreFuture ... done
[17:59:17.769] result() for MulticoreFuture ... done
[17:59:17.769] result() for MulticoreFuture ...
[17:59:17.769] result() for MulticoreFuture ... done
[17:59:17.770] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:17.770] - nx: 2
[17:59:17.770] - relay: TRUE
[17:59:17.771] - stdout: TRUE
[17:59:17.771] - signal: TRUE
[17:59:17.771] - resignal: FALSE
[17:59:17.771] - force: TRUE
[17:59:17.772] - relayed: [n=2] FALSE, FALSE
[17:59:17.772] - queued futures: [n=2] FALSE, FALSE
[17:59:17.772]  - until=1
[17:59:17.773]  - relaying element #1
[17:59:17.773] result() for MulticoreFuture ...
[17:59:17.773] result() for MulticoreFuture ... done
[17:59:17.774] result() for MulticoreFuture ...
[17:59:17.774] result() for MulticoreFuture ... done
[17:59:17.774] result() for MulticoreFuture ...
[17:59:17.775] result() for MulticoreFuture ... done
[17:59:17.775] result() for MulticoreFuture ...
[17:59:17.775] result() for MulticoreFuture ... done
[17:59:17.776] - relayed: [n=2] TRUE, FALSE
[17:59:17.776] - queued futures: [n=2] TRUE, FALSE
[17:59:17.777] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:17.777]  length: 1 (resolved future 1)
[17:59:17.778] Future #2
[17:59:17.778] result() for MulticoreFuture ...
[17:59:17.780] result() for MulticoreFuture ...
[17:59:17.780] result() for MulticoreFuture ... done
[17:59:17.780] result() for MulticoreFuture ... done
[17:59:17.781] result() for MulticoreFuture ...
[17:59:17.781] result() for MulticoreFuture ... done
[17:59:17.781] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:17.781] - nx: 2
[17:59:17.782] - relay: TRUE
[17:59:17.782] - stdout: TRUE
[17:59:17.782] - signal: TRUE
[17:59:17.783] - resignal: FALSE
[17:59:17.783] - force: TRUE
[17:59:17.783] - relayed: [n=2] TRUE, FALSE
[17:59:17.783] - queued futures: [n=2] TRUE, FALSE
[17:59:17.784]  - until=2
[17:59:17.784]  - relaying element #2
[17:59:17.784] result() for MulticoreFuture ...
[17:59:17.785] result() for MulticoreFuture ... done
[17:59:17.785] result() for MulticoreFuture ...
[17:59:17.785] result() for MulticoreFuture ... done
[17:59:17.785] result() for MulticoreFuture ...
[17:59:17.789] result() for MulticoreFuture ... done
[17:59:17.790] result() for MulticoreFuture ...
[17:59:17.790] result() for MulticoreFuture ... done
[17:59:17.791] - relayed: [n=2] TRUE, TRUE
[17:59:17.791] - queued futures: [n=2] TRUE, TRUE
[17:59:17.791] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:17.792]  length: 0 (resolved future 2)
[17:59:17.792] Relaying remaining futures
[17:59:17.792] signalConditionsASAP(NULL, pos=0) ...
[17:59:17.793] - nx: 2
[17:59:17.793] - relay: TRUE
[17:59:17.793] - stdout: TRUE
[17:59:17.793] - signal: TRUE
[17:59:17.794] - resignal: FALSE
[17:59:17.794] - force: TRUE
[17:59:17.794] - relayed: [n=2] TRUE, TRUE
[17:59:17.795] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:17.795] - relayed: [n=2] TRUE, TRUE
[17:59:17.796] - queued futures: [n=2] TRUE, TRUE
[17:59:17.796] signalConditionsASAP(NULL, pos=0) ... done
[17:59:17.796] resolve() on list ... DONE
[17:59:17.796] result() for MulticoreFuture ...
[17:59:17.797] result() for MulticoreFuture ... done
[17:59:17.797] result() for MulticoreFuture ...
[17:59:17.797] result() for MulticoreFuture ... done
[17:59:17.798] result() for MulticoreFuture ...
[17:59:17.798] result() for MulticoreFuture ... done
[17:59:17.798] result() for MulticoreFuture ...
[17:59:17.798] result() for MulticoreFuture ... done
[17:59:17.799]  - Number of value chunks collected: 2
[17:59:17.799] Resolving 2 futures (chunks) ... DONE
[17:59:17.799] Reducing values from 2 chunks ...
[17:59:17.799]  - Number of values collected after concatenation: 6
[17:59:17.800]  - Number of values expected: 6
[17:59:17.800] Reducing values from 2 chunks ... DONE
[17:59:17.800] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:59:17.801] getGlobalsAndPackagesXApply() ...
[17:59:17.801]  - future.globals: TRUE
[17:59:17.801] getGlobalsAndPackages() ...
[17:59:17.802] Searching for globals...
[17:59:17.804] - globals found: [1] ‘FUN’
[17:59:17.805] Searching for globals ... DONE
[17:59:17.805] Resolving globals: FALSE
[17:59:17.806] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:17.806] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:17.807] - globals: [1] ‘FUN’
[17:59:17.807] 
[17:59:17.807] getGlobalsAndPackages() ... DONE
[17:59:17.807]  - globals found/used: [n=1] ‘FUN’
[17:59:17.808]  - needed namespaces: [n=0] 
[17:59:17.808] Finding globals ... DONE
[17:59:17.808]  - use_args: TRUE
[17:59:17.808]  - Getting '...' globals ...
[17:59:17.809] resolve() on list ...
[17:59:17.809]  recursive: 0
[17:59:17.810]  length: 1
[17:59:17.810]  elements: ‘...’
[17:59:17.810]  length: 0 (resolved future 1)
[17:59:17.810] resolve() on list ... DONE
[17:59:17.810]    - '...' content: [n=0] 
[17:59:17.811] List of 1
[17:59:17.811]  $ ...: list()
[17:59:17.811]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.811]  - attr(*, "where")=List of 1
[17:59:17.811]   ..$ ...:<environment: 0x56085a884fb8> 
[17:59:17.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.811]  - attr(*, "resolved")= logi TRUE
[17:59:17.811]  - attr(*, "total_size")= num NA
[17:59:17.816]  - Getting '...' globals ... DONE
[17:59:17.817] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:17.817] List of 2
[17:59:17.817]  $ ...future.FUN:function (x)  
[17:59:17.817]  $ ...          : list()
[17:59:17.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.817]  - attr(*, "where")=List of 2
[17:59:17.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:17.817]   ..$ ...          :<environment: 0x56085a884fb8> 
[17:59:17.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.817]  - attr(*, "resolved")= logi FALSE
[17:59:17.817]  - attr(*, "total_size")= num 848
[17:59:17.823] Packages to be attached in all futures: [n=0] 
[17:59:17.823] getGlobalsAndPackagesXApply() ... DONE
[17:59:17.829] future_lapply() ...
[17:59:17.836] Number of chunks: 2
[17:59:17.836] getGlobalsAndPackagesXApply() ...
[17:59:17.836]  - future.globals: <name-value list> with names ‘list()’
[17:59:17.837]  - use_args: TRUE
[17:59:17.837] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:17.837] List of 2
[17:59:17.837]  $ ...          : list()
[17:59:17.837]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.837]  $ ...future.FUN:function (x)  
[17:59:17.837]  - attr(*, "where")=List of 2
[17:59:17.837]   ..$ ...          :<environment: 0x56085a884fb8> 
[17:59:17.837]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:17.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.837]  - attr(*, "resolved")= logi FALSE
[17:59:17.837]  - attr(*, "total_size")= num NA
[17:59:17.844] Packages to be attached in all futures: [n=0] 
[17:59:17.844] getGlobalsAndPackagesXApply() ... DONE
[17:59:17.844] Number of futures (= number of chunks): 2
[17:59:17.845] Launching 2 futures (chunks) ...
[17:59:17.845] Chunk #1 of 2 ...
[17:59:17.845]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:17.845]  - seeds: <none>
[17:59:17.846]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.846] getGlobalsAndPackages() ...
[17:59:17.846] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.846] Resolving globals: FALSE
[17:59:17.847] Tweak future expression to call with '...' arguments ...
[17:59:17.847] {
[17:59:17.847]     do.call(function(...) {
[17:59:17.847]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.847]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.847]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.847]             on.exit(options(oopts), add = TRUE)
[17:59:17.847]         }
[17:59:17.847]         {
[17:59:17.847]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.847]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.847]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.847]             })
[17:59:17.847]         }
[17:59:17.847]     }, args = future.call.arguments)
[17:59:17.847] }
[17:59:17.850] Tweak future expression to call with '...' arguments ... DONE
[17:59:17.851] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.851] 
[17:59:17.851] getGlobalsAndPackages() ... DONE
[17:59:17.852] run() for ‘Future’ ...
[17:59:17.852] - state: ‘created’
[17:59:17.852] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:17.859] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.859] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:17.860]   - Field: ‘label’
[17:59:17.860]   - Field: ‘local’
[17:59:17.860]   - Field: ‘owner’
[17:59:17.860]   - Field: ‘envir’
[17:59:17.860]   - Field: ‘workers’
[17:59:17.861]   - Field: ‘packages’
[17:59:17.861]   - Field: ‘gc’
[17:59:17.861]   - Field: ‘job’
[17:59:17.861]   - Field: ‘conditions’
[17:59:17.861]   - Field: ‘expr’
[17:59:17.862]   - Field: ‘uuid’
[17:59:17.862]   - Field: ‘seed’
[17:59:17.862]   - Field: ‘version’
[17:59:17.862]   - Field: ‘result’
[17:59:17.862]   - Field: ‘asynchronous’
[17:59:17.863]   - Field: ‘calls’
[17:59:17.863]   - Field: ‘globals’
[17:59:17.863]   - Field: ‘stdout’
[17:59:17.863]   - Field: ‘earlySignal’
[17:59:17.863]   - Field: ‘lazy’
[17:59:17.864]   - Field: ‘state’
[17:59:17.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:17.864] - Launch lazy future ...
[17:59:17.864] Packages needed by the future expression (n = 0): <none>
[17:59:17.865] Packages needed by future strategies (n = 0): <none>
[17:59:17.866] {
[17:59:17.866]     {
[17:59:17.866]         {
[17:59:17.866]             ...future.startTime <- base::Sys.time()
[17:59:17.866]             {
[17:59:17.866]                 {
[17:59:17.866]                   {
[17:59:17.866]                     {
[17:59:17.866]                       base::local({
[17:59:17.866]                         has_future <- base::requireNamespace("future", 
[17:59:17.866]                           quietly = TRUE)
[17:59:17.866]                         if (has_future) {
[17:59:17.866]                           ns <- base::getNamespace("future")
[17:59:17.866]                           version <- ns[[".package"]][["version"]]
[17:59:17.866]                           if (is.null(version)) 
[17:59:17.866]                             version <- utils::packageVersion("future")
[17:59:17.866]                         }
[17:59:17.866]                         else {
[17:59:17.866]                           version <- NULL
[17:59:17.866]                         }
[17:59:17.866]                         if (!has_future || version < "1.8.0") {
[17:59:17.866]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:17.866]                             "", base::R.version$version.string), 
[17:59:17.866]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:17.866]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:17.866]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:17.866]                               "release", "version")], collapse = " "), 
[17:59:17.866]                             hostname = base::Sys.info()[["nodename"]])
[17:59:17.866]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:17.866]                             info)
[17:59:17.866]                           info <- base::paste(info, collapse = "; ")
[17:59:17.866]                           if (!has_future) {
[17:59:17.866]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:17.866]                               info)
[17:59:17.866]                           }
[17:59:17.866]                           else {
[17:59:17.866]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:17.866]                               info, version)
[17:59:17.866]                           }
[17:59:17.866]                           base::stop(msg)
[17:59:17.866]                         }
[17:59:17.866]                       })
[17:59:17.866]                     }
[17:59:17.866]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:17.866]                     base::options(mc.cores = 1L)
[17:59:17.866]                   }
[17:59:17.866]                   ...future.strategy.old <- future::plan("list")
[17:59:17.866]                   options(future.plan = NULL)
[17:59:17.866]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.866]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:17.866]                 }
[17:59:17.866]                 ...future.workdir <- getwd()
[17:59:17.866]             }
[17:59:17.866]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:17.866]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:17.866]         }
[17:59:17.866]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:17.866]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:17.866]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:17.866]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:17.866]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:17.866]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:17.866]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:17.866]             base::names(...future.oldOptions))
[17:59:17.866]     }
[17:59:17.866]     if (FALSE) {
[17:59:17.866]     }
[17:59:17.866]     else {
[17:59:17.866]         if (TRUE) {
[17:59:17.866]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:17.866]                 open = "w")
[17:59:17.866]         }
[17:59:17.866]         else {
[17:59:17.866]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:17.866]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:17.866]         }
[17:59:17.866]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:17.866]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:17.866]             base::sink(type = "output", split = FALSE)
[17:59:17.866]             base::close(...future.stdout)
[17:59:17.866]         }, add = TRUE)
[17:59:17.866]     }
[17:59:17.866]     ...future.frame <- base::sys.nframe()
[17:59:17.866]     ...future.conditions <- base::list()
[17:59:17.866]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:17.866]     if (FALSE) {
[17:59:17.866]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:17.866]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:17.866]     }
[17:59:17.866]     ...future.result <- base::tryCatch({
[17:59:17.866]         base::withCallingHandlers({
[17:59:17.866]             ...future.value <- base::withVisible(base::local({
[17:59:17.866]                 withCallingHandlers({
[17:59:17.866]                   {
[17:59:17.866]                     do.call(function(...) {
[17:59:17.866]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.866]                       if (!identical(...future.globals.maxSize.org, 
[17:59:17.866]                         ...future.globals.maxSize)) {
[17:59:17.866]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.866]                         on.exit(options(oopts), add = TRUE)
[17:59:17.866]                       }
[17:59:17.866]                       {
[17:59:17.866]                         lapply(seq_along(...future.elements_ii), 
[17:59:17.866]                           FUN = function(jj) {
[17:59:17.866]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.866]                             ...future.FUN(...future.X_jj, ...)
[17:59:17.866]                           })
[17:59:17.866]                       }
[17:59:17.866]                     }, args = future.call.arguments)
[17:59:17.866]                   }
[17:59:17.866]                 }, immediateCondition = function(cond) {
[17:59:17.866]                   save_rds <- function (object, pathname, ...) 
[17:59:17.866]                   {
[17:59:17.866]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:17.866]                     if (file_test("-f", pathname_tmp)) {
[17:59:17.866]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.866]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:17.866]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.866]                         fi_tmp[["mtime"]])
[17:59:17.866]                     }
[17:59:17.866]                     tryCatch({
[17:59:17.866]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:17.866]                     }, error = function(ex) {
[17:59:17.866]                       msg <- conditionMessage(ex)
[17:59:17.866]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.866]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:17.866]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.866]                         fi_tmp[["mtime"]], msg)
[17:59:17.866]                       ex$message <- msg
[17:59:17.866]                       stop(ex)
[17:59:17.866]                     })
[17:59:17.866]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:17.866]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:17.866]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:17.866]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.866]                       fi <- file.info(pathname)
[17:59:17.866]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:17.866]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.866]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:17.866]                         fi[["size"]], fi[["mtime"]])
[17:59:17.866]                       stop(msg)
[17:59:17.866]                     }
[17:59:17.866]                     invisible(pathname)
[17:59:17.866]                   }
[17:59:17.866]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:17.866]                     rootPath = tempdir()) 
[17:59:17.866]                   {
[17:59:17.866]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:17.866]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:17.866]                       tmpdir = path, fileext = ".rds")
[17:59:17.866]                     save_rds(obj, file)
[17:59:17.866]                   }
[17:59:17.866]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:17.866]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.866]                   {
[17:59:17.866]                     inherits <- base::inherits
[17:59:17.866]                     invokeRestart <- base::invokeRestart
[17:59:17.866]                     is.null <- base::is.null
[17:59:17.866]                     muffled <- FALSE
[17:59:17.866]                     if (inherits(cond, "message")) {
[17:59:17.866]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:17.866]                       if (muffled) 
[17:59:17.866]                         invokeRestart("muffleMessage")
[17:59:17.866]                     }
[17:59:17.866]                     else if (inherits(cond, "warning")) {
[17:59:17.866]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:17.866]                       if (muffled) 
[17:59:17.866]                         invokeRestart("muffleWarning")
[17:59:17.866]                     }
[17:59:17.866]                     else if (inherits(cond, "condition")) {
[17:59:17.866]                       if (!is.null(pattern)) {
[17:59:17.866]                         computeRestarts <- base::computeRestarts
[17:59:17.866]                         grepl <- base::grepl
[17:59:17.866]                         restarts <- computeRestarts(cond)
[17:59:17.866]                         for (restart in restarts) {
[17:59:17.866]                           name <- restart$name
[17:59:17.866]                           if (is.null(name)) 
[17:59:17.866]                             next
[17:59:17.866]                           if (!grepl(pattern, name)) 
[17:59:17.866]                             next
[17:59:17.866]                           invokeRestart(restart)
[17:59:17.866]                           muffled <- TRUE
[17:59:17.866]                           break
[17:59:17.866]                         }
[17:59:17.866]                       }
[17:59:17.866]                     }
[17:59:17.866]                     invisible(muffled)
[17:59:17.866]                   }
[17:59:17.866]                   muffleCondition(cond)
[17:59:17.866]                 })
[17:59:17.866]             }))
[17:59:17.866]             future::FutureResult(value = ...future.value$value, 
[17:59:17.866]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.866]                   ...future.rng), globalenv = if (FALSE) 
[17:59:17.866]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:17.866]                     ...future.globalenv.names))
[17:59:17.866]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:17.866]         }, condition = base::local({
[17:59:17.866]             c <- base::c
[17:59:17.866]             inherits <- base::inherits
[17:59:17.866]             invokeRestart <- base::invokeRestart
[17:59:17.866]             length <- base::length
[17:59:17.866]             list <- base::list
[17:59:17.866]             seq.int <- base::seq.int
[17:59:17.866]             signalCondition <- base::signalCondition
[17:59:17.866]             sys.calls <- base::sys.calls
[17:59:17.866]             `[[` <- base::`[[`
[17:59:17.866]             `+` <- base::`+`
[17:59:17.866]             `<<-` <- base::`<<-`
[17:59:17.866]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:17.866]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:17.866]                   3L)]
[17:59:17.866]             }
[17:59:17.866]             function(cond) {
[17:59:17.866]                 is_error <- inherits(cond, "error")
[17:59:17.866]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:17.866]                   NULL)
[17:59:17.866]                 if (is_error) {
[17:59:17.866]                   sessionInformation <- function() {
[17:59:17.866]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:17.866]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:17.866]                       search = base::search(), system = base::Sys.info())
[17:59:17.866]                   }
[17:59:17.866]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.866]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:17.866]                     cond$call), session = sessionInformation(), 
[17:59:17.866]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:17.866]                   signalCondition(cond)
[17:59:17.866]                 }
[17:59:17.866]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:17.866]                 "immediateCondition"))) {
[17:59:17.866]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:17.866]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.866]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:17.866]                   if (TRUE && !signal) {
[17:59:17.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.866]                     {
[17:59:17.866]                       inherits <- base::inherits
[17:59:17.866]                       invokeRestart <- base::invokeRestart
[17:59:17.866]                       is.null <- base::is.null
[17:59:17.866]                       muffled <- FALSE
[17:59:17.866]                       if (inherits(cond, "message")) {
[17:59:17.866]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.866]                         if (muffled) 
[17:59:17.866]                           invokeRestart("muffleMessage")
[17:59:17.866]                       }
[17:59:17.866]                       else if (inherits(cond, "warning")) {
[17:59:17.866]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.866]                         if (muffled) 
[17:59:17.866]                           invokeRestart("muffleWarning")
[17:59:17.866]                       }
[17:59:17.866]                       else if (inherits(cond, "condition")) {
[17:59:17.866]                         if (!is.null(pattern)) {
[17:59:17.866]                           computeRestarts <- base::computeRestarts
[17:59:17.866]                           grepl <- base::grepl
[17:59:17.866]                           restarts <- computeRestarts(cond)
[17:59:17.866]                           for (restart in restarts) {
[17:59:17.866]                             name <- restart$name
[17:59:17.866]                             if (is.null(name)) 
[17:59:17.866]                               next
[17:59:17.866]                             if (!grepl(pattern, name)) 
[17:59:17.866]                               next
[17:59:17.866]                             invokeRestart(restart)
[17:59:17.866]                             muffled <- TRUE
[17:59:17.866]                             break
[17:59:17.866]                           }
[17:59:17.866]                         }
[17:59:17.866]                       }
[17:59:17.866]                       invisible(muffled)
[17:59:17.866]                     }
[17:59:17.866]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.866]                   }
[17:59:17.866]                 }
[17:59:17.866]                 else {
[17:59:17.866]                   if (TRUE) {
[17:59:17.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.866]                     {
[17:59:17.866]                       inherits <- base::inherits
[17:59:17.866]                       invokeRestart <- base::invokeRestart
[17:59:17.866]                       is.null <- base::is.null
[17:59:17.866]                       muffled <- FALSE
[17:59:17.866]                       if (inherits(cond, "message")) {
[17:59:17.866]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.866]                         if (muffled) 
[17:59:17.866]                           invokeRestart("muffleMessage")
[17:59:17.866]                       }
[17:59:17.866]                       else if (inherits(cond, "warning")) {
[17:59:17.866]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.866]                         if (muffled) 
[17:59:17.866]                           invokeRestart("muffleWarning")
[17:59:17.866]                       }
[17:59:17.866]                       else if (inherits(cond, "condition")) {
[17:59:17.866]                         if (!is.null(pattern)) {
[17:59:17.866]                           computeRestarts <- base::computeRestarts
[17:59:17.866]                           grepl <- base::grepl
[17:59:17.866]                           restarts <- computeRestarts(cond)
[17:59:17.866]                           for (restart in restarts) {
[17:59:17.866]                             name <- restart$name
[17:59:17.866]                             if (is.null(name)) 
[17:59:17.866]                               next
[17:59:17.866]                             if (!grepl(pattern, name)) 
[17:59:17.866]                               next
[17:59:17.866]                             invokeRestart(restart)
[17:59:17.866]                             muffled <- TRUE
[17:59:17.866]                             break
[17:59:17.866]                           }
[17:59:17.866]                         }
[17:59:17.866]                       }
[17:59:17.866]                       invisible(muffled)
[17:59:17.866]                     }
[17:59:17.866]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.866]                   }
[17:59:17.866]                 }
[17:59:17.866]             }
[17:59:17.866]         }))
[17:59:17.866]     }, error = function(ex) {
[17:59:17.866]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:17.866]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.866]                 ...future.rng), started = ...future.startTime, 
[17:59:17.866]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:17.866]             version = "1.8"), class = "FutureResult")
[17:59:17.866]     }, finally = {
[17:59:17.866]         if (!identical(...future.workdir, getwd())) 
[17:59:17.866]             setwd(...future.workdir)
[17:59:17.866]         {
[17:59:17.866]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:17.866]                 ...future.oldOptions$nwarnings <- NULL
[17:59:17.866]             }
[17:59:17.866]             base::options(...future.oldOptions)
[17:59:17.866]             if (.Platform$OS.type == "windows") {
[17:59:17.866]                 old_names <- names(...future.oldEnvVars)
[17:59:17.866]                 envs <- base::Sys.getenv()
[17:59:17.866]                 names <- names(envs)
[17:59:17.866]                 common <- intersect(names, old_names)
[17:59:17.866]                 added <- setdiff(names, old_names)
[17:59:17.866]                 removed <- setdiff(old_names, names)
[17:59:17.866]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:17.866]                   envs[common]]
[17:59:17.866]                 NAMES <- toupper(changed)
[17:59:17.866]                 args <- list()
[17:59:17.866]                 for (kk in seq_along(NAMES)) {
[17:59:17.866]                   name <- changed[[kk]]
[17:59:17.866]                   NAME <- NAMES[[kk]]
[17:59:17.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.866]                     next
[17:59:17.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.866]                 }
[17:59:17.866]                 NAMES <- toupper(added)
[17:59:17.866]                 for (kk in seq_along(NAMES)) {
[17:59:17.866]                   name <- added[[kk]]
[17:59:17.866]                   NAME <- NAMES[[kk]]
[17:59:17.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.866]                     next
[17:59:17.866]                   args[[name]] <- ""
[17:59:17.866]                 }
[17:59:17.866]                 NAMES <- toupper(removed)
[17:59:17.866]                 for (kk in seq_along(NAMES)) {
[17:59:17.866]                   name <- removed[[kk]]
[17:59:17.866]                   NAME <- NAMES[[kk]]
[17:59:17.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.866]                     next
[17:59:17.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.866]                 }
[17:59:17.866]                 if (length(args) > 0) 
[17:59:17.866]                   base::do.call(base::Sys.setenv, args = args)
[17:59:17.866]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:17.866]             }
[17:59:17.866]             else {
[17:59:17.866]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:17.866]             }
[17:59:17.866]             {
[17:59:17.866]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:17.866]                   0L) {
[17:59:17.866]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:17.866]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:17.866]                   base::options(opts)
[17:59:17.866]                 }
[17:59:17.866]                 {
[17:59:17.866]                   {
[17:59:17.866]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:17.866]                     NULL
[17:59:17.866]                   }
[17:59:17.866]                   options(future.plan = NULL)
[17:59:17.866]                   if (is.na(NA_character_)) 
[17:59:17.866]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.866]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:17.866]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:17.866]                     .init = FALSE)
[17:59:17.866]                 }
[17:59:17.866]             }
[17:59:17.866]         }
[17:59:17.866]     })
[17:59:17.866]     if (TRUE) {
[17:59:17.866]         base::sink(type = "output", split = FALSE)
[17:59:17.866]         if (TRUE) {
[17:59:17.866]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:17.866]         }
[17:59:17.866]         else {
[17:59:17.866]             ...future.result["stdout"] <- base::list(NULL)
[17:59:17.866]         }
[17:59:17.866]         base::close(...future.stdout)
[17:59:17.866]         ...future.stdout <- NULL
[17:59:17.866]     }
[17:59:17.866]     ...future.result$conditions <- ...future.conditions
[17:59:17.866]     ...future.result$finished <- base::Sys.time()
[17:59:17.866]     ...future.result
[17:59:17.866] }
[17:59:17.870] assign_globals() ...
[17:59:17.870] List of 5
[17:59:17.870]  $ future.call.arguments    : list()
[17:59:17.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.870]  $ ...future.FUN            :function (x)  
[17:59:17.870]  $ ...future.elements_ii    :List of 1
[17:59:17.870]   ..$ : int 1
[17:59:17.870]  $ ...future.seeds_ii       : NULL
[17:59:17.870]  $ ...future.globals.maxSize: num Inf
[17:59:17.870]  - attr(*, "resolved")= logi FALSE
[17:59:17.870]  - attr(*, "total_size")= num NA
[17:59:17.870]  - attr(*, "where")=List of 5
[17:59:17.870]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:17.870]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:17.870]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:17.870]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:17.870]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:17.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.870]  - attr(*, "already-done")= logi TRUE
[17:59:17.880] - copied ‘future.call.arguments’ to environment
[17:59:17.880] - copied ‘...future.FUN’ to environment
[17:59:17.881] - copied ‘...future.elements_ii’ to environment
[17:59:17.881] - copied ‘...future.seeds_ii’ to environment
[17:59:17.881] - copied ‘...future.globals.maxSize’ to environment
[17:59:17.881] assign_globals() ... done
[17:59:17.881] requestCore(): workers = 2
[17:59:17.885] MulticoreFuture started
[17:59:17.886] - Launch lazy future ... done
[17:59:17.886] run() for ‘MulticoreFuture’ ... done
[17:59:17.887] Created future:
[17:59:17.887] plan(): Setting new future strategy stack:
[17:59:17.887] List of future strategies:
[17:59:17.887] 1. sequential:
[17:59:17.887]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:17.887]    - tweaked: FALSE
[17:59:17.887]    - call: NULL
[17:59:17.889] plan(): nbrOfWorkers() = 1
[17:59:17.894] plan(): Setting new future strategy stack:
[17:59:17.894] List of future strategies:
[17:59:17.894] 1. multicore:
[17:59:17.894]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:17.894]    - tweaked: FALSE
[17:59:17.894]    - call: plan(strategy)
[17:59:17.887] MulticoreFuture:
[17:59:17.887] Label: ‘future_apply-1’
[17:59:17.887] Expression:
[17:59:17.887] {
[17:59:17.887]     do.call(function(...) {
[17:59:17.887]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.887]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.887]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.887]             on.exit(options(oopts), add = TRUE)
[17:59:17.887]         }
[17:59:17.887]         {
[17:59:17.887]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.887]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.887]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.887]             })
[17:59:17.887]         }
[17:59:17.887]     }, args = future.call.arguments)
[17:59:17.887] }
[17:59:17.887] Lazy evaluation: FALSE
[17:59:17.887] Asynchronous evaluation: TRUE
[17:59:17.887] Local evaluation: TRUE
[17:59:17.887] Environment: R_GlobalEnv
[17:59:17.887] Capture standard output: TRUE
[17:59:17.887] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:17.887] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:17.887] Packages: <none>
[17:59:17.887] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:17.887] Resolved: FALSE
[17:59:17.887] Value: <not collected>
[17:59:17.887] Conditions captured: <none>
[17:59:17.887] Early signaling: FALSE
[17:59:17.887] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:17.887] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.902] Chunk #1 of 2 ... DONE
[17:59:17.903] Chunk #2 of 2 ...
[17:59:17.903]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:17.904]  - seeds: <none>
[17:59:17.904] plan(): nbrOfWorkers() = 2
[17:59:17.904]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.904] getGlobalsAndPackages() ...
[17:59:17.905] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.905] Resolving globals: FALSE
[17:59:17.905] Tweak future expression to call with '...' arguments ...
[17:59:17.906] {
[17:59:17.906]     do.call(function(...) {
[17:59:17.906]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.906]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.906]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.906]             on.exit(options(oopts), add = TRUE)
[17:59:17.906]         }
[17:59:17.906]         {
[17:59:17.906]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.906]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.906]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.906]             })
[17:59:17.906]         }
[17:59:17.906]     }, args = future.call.arguments)
[17:59:17.906] }
[17:59:17.906] Tweak future expression to call with '...' arguments ... DONE
[17:59:17.908] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:17.908] 
[17:59:17.908] getGlobalsAndPackages() ... DONE
[17:59:17.909] run() for ‘Future’ ...
[17:59:17.910] - state: ‘created’
[17:59:17.910] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:17.919] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:17.919]   - Field: ‘label’
[17:59:17.920]   - Field: ‘local’
[17:59:17.920]   - Field: ‘owner’
[17:59:17.920]   - Field: ‘envir’
[17:59:17.921]   - Field: ‘workers’
[17:59:17.921]   - Field: ‘packages’
[17:59:17.921]   - Field: ‘gc’
[17:59:17.922]   - Field: ‘job’
[17:59:17.922]   - Field: ‘conditions’
[17:59:17.922]   - Field: ‘expr’
[17:59:17.922]   - Field: ‘uuid’
[17:59:17.923]   - Field: ‘seed’
[17:59:17.923]   - Field: ‘version’
[17:59:17.923]   - Field: ‘result’
[17:59:17.924]   - Field: ‘asynchronous’
[17:59:17.924]   - Field: ‘calls’
[17:59:17.924]   - Field: ‘globals’
[17:59:17.925]   - Field: ‘stdout’
[17:59:17.925]   - Field: ‘earlySignal’
[17:59:17.925]   - Field: ‘lazy’
[17:59:17.926]   - Field: ‘state’
[17:59:17.926] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:17.926] - Launch lazy future ...
[17:59:17.927] Packages needed by the future expression (n = 0): <none>
[17:59:17.927] Packages needed by future strategies (n = 0): <none>
[17:59:17.929] {
[17:59:17.929]     {
[17:59:17.929]         {
[17:59:17.929]             ...future.startTime <- base::Sys.time()
[17:59:17.929]             {
[17:59:17.929]                 {
[17:59:17.929]                   {
[17:59:17.929]                     {
[17:59:17.929]                       base::local({
[17:59:17.929]                         has_future <- base::requireNamespace("future", 
[17:59:17.929]                           quietly = TRUE)
[17:59:17.929]                         if (has_future) {
[17:59:17.929]                           ns <- base::getNamespace("future")
[17:59:17.929]                           version <- ns[[".package"]][["version"]]
[17:59:17.929]                           if (is.null(version)) 
[17:59:17.929]                             version <- utils::packageVersion("future")
[17:59:17.929]                         }
[17:59:17.929]                         else {
[17:59:17.929]                           version <- NULL
[17:59:17.929]                         }
[17:59:17.929]                         if (!has_future || version < "1.8.0") {
[17:59:17.929]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:17.929]                             "", base::R.version$version.string), 
[17:59:17.929]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:17.929]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:17.929]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:17.929]                               "release", "version")], collapse = " "), 
[17:59:17.929]                             hostname = base::Sys.info()[["nodename"]])
[17:59:17.929]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:17.929]                             info)
[17:59:17.929]                           info <- base::paste(info, collapse = "; ")
[17:59:17.929]                           if (!has_future) {
[17:59:17.929]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:17.929]                               info)
[17:59:17.929]                           }
[17:59:17.929]                           else {
[17:59:17.929]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:17.929]                               info, version)
[17:59:17.929]                           }
[17:59:17.929]                           base::stop(msg)
[17:59:17.929]                         }
[17:59:17.929]                       })
[17:59:17.929]                     }
[17:59:17.929]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:17.929]                     base::options(mc.cores = 1L)
[17:59:17.929]                   }
[17:59:17.929]                   ...future.strategy.old <- future::plan("list")
[17:59:17.929]                   options(future.plan = NULL)
[17:59:17.929]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.929]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:17.929]                 }
[17:59:17.929]                 ...future.workdir <- getwd()
[17:59:17.929]             }
[17:59:17.929]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:17.929]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:17.929]         }
[17:59:17.929]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:17.929]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:17.929]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:17.929]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:17.929]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:17.929]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:17.929]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:17.929]             base::names(...future.oldOptions))
[17:59:17.929]     }
[17:59:17.929]     if (FALSE) {
[17:59:17.929]     }
[17:59:17.929]     else {
[17:59:17.929]         if (TRUE) {
[17:59:17.929]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:17.929]                 open = "w")
[17:59:17.929]         }
[17:59:17.929]         else {
[17:59:17.929]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:17.929]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:17.929]         }
[17:59:17.929]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:17.929]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:17.929]             base::sink(type = "output", split = FALSE)
[17:59:17.929]             base::close(...future.stdout)
[17:59:17.929]         }, add = TRUE)
[17:59:17.929]     }
[17:59:17.929]     ...future.frame <- base::sys.nframe()
[17:59:17.929]     ...future.conditions <- base::list()
[17:59:17.929]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:17.929]     if (FALSE) {
[17:59:17.929]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:17.929]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:17.929]     }
[17:59:17.929]     ...future.result <- base::tryCatch({
[17:59:17.929]         base::withCallingHandlers({
[17:59:17.929]             ...future.value <- base::withVisible(base::local({
[17:59:17.929]                 withCallingHandlers({
[17:59:17.929]                   {
[17:59:17.929]                     do.call(function(...) {
[17:59:17.929]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.929]                       if (!identical(...future.globals.maxSize.org, 
[17:59:17.929]                         ...future.globals.maxSize)) {
[17:59:17.929]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.929]                         on.exit(options(oopts), add = TRUE)
[17:59:17.929]                       }
[17:59:17.929]                       {
[17:59:17.929]                         lapply(seq_along(...future.elements_ii), 
[17:59:17.929]                           FUN = function(jj) {
[17:59:17.929]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.929]                             ...future.FUN(...future.X_jj, ...)
[17:59:17.929]                           })
[17:59:17.929]                       }
[17:59:17.929]                     }, args = future.call.arguments)
[17:59:17.929]                   }
[17:59:17.929]                 }, immediateCondition = function(cond) {
[17:59:17.929]                   save_rds <- function (object, pathname, ...) 
[17:59:17.929]                   {
[17:59:17.929]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:17.929]                     if (file_test("-f", pathname_tmp)) {
[17:59:17.929]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.929]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:17.929]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.929]                         fi_tmp[["mtime"]])
[17:59:17.929]                     }
[17:59:17.929]                     tryCatch({
[17:59:17.929]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:17.929]                     }, error = function(ex) {
[17:59:17.929]                       msg <- conditionMessage(ex)
[17:59:17.929]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.929]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:17.929]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.929]                         fi_tmp[["mtime"]], msg)
[17:59:17.929]                       ex$message <- msg
[17:59:17.929]                       stop(ex)
[17:59:17.929]                     })
[17:59:17.929]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:17.929]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:17.929]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:17.929]                       fi_tmp <- file.info(pathname_tmp)
[17:59:17.929]                       fi <- file.info(pathname)
[17:59:17.929]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:17.929]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:17.929]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:17.929]                         fi[["size"]], fi[["mtime"]])
[17:59:17.929]                       stop(msg)
[17:59:17.929]                     }
[17:59:17.929]                     invisible(pathname)
[17:59:17.929]                   }
[17:59:17.929]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:17.929]                     rootPath = tempdir()) 
[17:59:17.929]                   {
[17:59:17.929]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:17.929]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:17.929]                       tmpdir = path, fileext = ".rds")
[17:59:17.929]                     save_rds(obj, file)
[17:59:17.929]                   }
[17:59:17.929]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:17.929]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.929]                   {
[17:59:17.929]                     inherits <- base::inherits
[17:59:17.929]                     invokeRestart <- base::invokeRestart
[17:59:17.929]                     is.null <- base::is.null
[17:59:17.929]                     muffled <- FALSE
[17:59:17.929]                     if (inherits(cond, "message")) {
[17:59:17.929]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:17.929]                       if (muffled) 
[17:59:17.929]                         invokeRestart("muffleMessage")
[17:59:17.929]                     }
[17:59:17.929]                     else if (inherits(cond, "warning")) {
[17:59:17.929]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:17.929]                       if (muffled) 
[17:59:17.929]                         invokeRestart("muffleWarning")
[17:59:17.929]                     }
[17:59:17.929]                     else if (inherits(cond, "condition")) {
[17:59:17.929]                       if (!is.null(pattern)) {
[17:59:17.929]                         computeRestarts <- base::computeRestarts
[17:59:17.929]                         grepl <- base::grepl
[17:59:17.929]                         restarts <- computeRestarts(cond)
[17:59:17.929]                         for (restart in restarts) {
[17:59:17.929]                           name <- restart$name
[17:59:17.929]                           if (is.null(name)) 
[17:59:17.929]                             next
[17:59:17.929]                           if (!grepl(pattern, name)) 
[17:59:17.929]                             next
[17:59:17.929]                           invokeRestart(restart)
[17:59:17.929]                           muffled <- TRUE
[17:59:17.929]                           break
[17:59:17.929]                         }
[17:59:17.929]                       }
[17:59:17.929]                     }
[17:59:17.929]                     invisible(muffled)
[17:59:17.929]                   }
[17:59:17.929]                   muffleCondition(cond)
[17:59:17.929]                 })
[17:59:17.929]             }))
[17:59:17.929]             future::FutureResult(value = ...future.value$value, 
[17:59:17.929]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.929]                   ...future.rng), globalenv = if (FALSE) 
[17:59:17.929]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:17.929]                     ...future.globalenv.names))
[17:59:17.929]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:17.929]         }, condition = base::local({
[17:59:17.929]             c <- base::c
[17:59:17.929]             inherits <- base::inherits
[17:59:17.929]             invokeRestart <- base::invokeRestart
[17:59:17.929]             length <- base::length
[17:59:17.929]             list <- base::list
[17:59:17.929]             seq.int <- base::seq.int
[17:59:17.929]             signalCondition <- base::signalCondition
[17:59:17.929]             sys.calls <- base::sys.calls
[17:59:17.929]             `[[` <- base::`[[`
[17:59:17.929]             `+` <- base::`+`
[17:59:17.929]             `<<-` <- base::`<<-`
[17:59:17.929]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:17.929]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:17.929]                   3L)]
[17:59:17.929]             }
[17:59:17.929]             function(cond) {
[17:59:17.929]                 is_error <- inherits(cond, "error")
[17:59:17.929]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:17.929]                   NULL)
[17:59:17.929]                 if (is_error) {
[17:59:17.929]                   sessionInformation <- function() {
[17:59:17.929]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:17.929]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:17.929]                       search = base::search(), system = base::Sys.info())
[17:59:17.929]                   }
[17:59:17.929]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.929]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:17.929]                     cond$call), session = sessionInformation(), 
[17:59:17.929]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:17.929]                   signalCondition(cond)
[17:59:17.929]                 }
[17:59:17.929]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:17.929]                 "immediateCondition"))) {
[17:59:17.929]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:17.929]                   ...future.conditions[[length(...future.conditions) + 
[17:59:17.929]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:17.929]                   if (TRUE && !signal) {
[17:59:17.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.929]                     {
[17:59:17.929]                       inherits <- base::inherits
[17:59:17.929]                       invokeRestart <- base::invokeRestart
[17:59:17.929]                       is.null <- base::is.null
[17:59:17.929]                       muffled <- FALSE
[17:59:17.929]                       if (inherits(cond, "message")) {
[17:59:17.929]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.929]                         if (muffled) 
[17:59:17.929]                           invokeRestart("muffleMessage")
[17:59:17.929]                       }
[17:59:17.929]                       else if (inherits(cond, "warning")) {
[17:59:17.929]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.929]                         if (muffled) 
[17:59:17.929]                           invokeRestart("muffleWarning")
[17:59:17.929]                       }
[17:59:17.929]                       else if (inherits(cond, "condition")) {
[17:59:17.929]                         if (!is.null(pattern)) {
[17:59:17.929]                           computeRestarts <- base::computeRestarts
[17:59:17.929]                           grepl <- base::grepl
[17:59:17.929]                           restarts <- computeRestarts(cond)
[17:59:17.929]                           for (restart in restarts) {
[17:59:17.929]                             name <- restart$name
[17:59:17.929]                             if (is.null(name)) 
[17:59:17.929]                               next
[17:59:17.929]                             if (!grepl(pattern, name)) 
[17:59:17.929]                               next
[17:59:17.929]                             invokeRestart(restart)
[17:59:17.929]                             muffled <- TRUE
[17:59:17.929]                             break
[17:59:17.929]                           }
[17:59:17.929]                         }
[17:59:17.929]                       }
[17:59:17.929]                       invisible(muffled)
[17:59:17.929]                     }
[17:59:17.929]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.929]                   }
[17:59:17.929]                 }
[17:59:17.929]                 else {
[17:59:17.929]                   if (TRUE) {
[17:59:17.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:17.929]                     {
[17:59:17.929]                       inherits <- base::inherits
[17:59:17.929]                       invokeRestart <- base::invokeRestart
[17:59:17.929]                       is.null <- base::is.null
[17:59:17.929]                       muffled <- FALSE
[17:59:17.929]                       if (inherits(cond, "message")) {
[17:59:17.929]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:17.929]                         if (muffled) 
[17:59:17.929]                           invokeRestart("muffleMessage")
[17:59:17.929]                       }
[17:59:17.929]                       else if (inherits(cond, "warning")) {
[17:59:17.929]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:17.929]                         if (muffled) 
[17:59:17.929]                           invokeRestart("muffleWarning")
[17:59:17.929]                       }
[17:59:17.929]                       else if (inherits(cond, "condition")) {
[17:59:17.929]                         if (!is.null(pattern)) {
[17:59:17.929]                           computeRestarts <- base::computeRestarts
[17:59:17.929]                           grepl <- base::grepl
[17:59:17.929]                           restarts <- computeRestarts(cond)
[17:59:17.929]                           for (restart in restarts) {
[17:59:17.929]                             name <- restart$name
[17:59:17.929]                             if (is.null(name)) 
[17:59:17.929]                               next
[17:59:17.929]                             if (!grepl(pattern, name)) 
[17:59:17.929]                               next
[17:59:17.929]                             invokeRestart(restart)
[17:59:17.929]                             muffled <- TRUE
[17:59:17.929]                             break
[17:59:17.929]                           }
[17:59:17.929]                         }
[17:59:17.929]                       }
[17:59:17.929]                       invisible(muffled)
[17:59:17.929]                     }
[17:59:17.929]                     muffleCondition(cond, pattern = "^muffle")
[17:59:17.929]                   }
[17:59:17.929]                 }
[17:59:17.929]             }
[17:59:17.929]         }))
[17:59:17.929]     }, error = function(ex) {
[17:59:17.929]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:17.929]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:17.929]                 ...future.rng), started = ...future.startTime, 
[17:59:17.929]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:17.929]             version = "1.8"), class = "FutureResult")
[17:59:17.929]     }, finally = {
[17:59:17.929]         if (!identical(...future.workdir, getwd())) 
[17:59:17.929]             setwd(...future.workdir)
[17:59:17.929]         {
[17:59:17.929]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:17.929]                 ...future.oldOptions$nwarnings <- NULL
[17:59:17.929]             }
[17:59:17.929]             base::options(...future.oldOptions)
[17:59:17.929]             if (.Platform$OS.type == "windows") {
[17:59:17.929]                 old_names <- names(...future.oldEnvVars)
[17:59:17.929]                 envs <- base::Sys.getenv()
[17:59:17.929]                 names <- names(envs)
[17:59:17.929]                 common <- intersect(names, old_names)
[17:59:17.929]                 added <- setdiff(names, old_names)
[17:59:17.929]                 removed <- setdiff(old_names, names)
[17:59:17.929]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:17.929]                   envs[common]]
[17:59:17.929]                 NAMES <- toupper(changed)
[17:59:17.929]                 args <- list()
[17:59:17.929]                 for (kk in seq_along(NAMES)) {
[17:59:17.929]                   name <- changed[[kk]]
[17:59:17.929]                   NAME <- NAMES[[kk]]
[17:59:17.929]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.929]                     next
[17:59:17.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.929]                 }
[17:59:17.929]                 NAMES <- toupper(added)
[17:59:17.929]                 for (kk in seq_along(NAMES)) {
[17:59:17.929]                   name <- added[[kk]]
[17:59:17.929]                   NAME <- NAMES[[kk]]
[17:59:17.929]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.929]                     next
[17:59:17.929]                   args[[name]] <- ""
[17:59:17.929]                 }
[17:59:17.929]                 NAMES <- toupper(removed)
[17:59:17.929]                 for (kk in seq_along(NAMES)) {
[17:59:17.929]                   name <- removed[[kk]]
[17:59:17.929]                   NAME <- NAMES[[kk]]
[17:59:17.929]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:17.929]                     next
[17:59:17.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:17.929]                 }
[17:59:17.929]                 if (length(args) > 0) 
[17:59:17.929]                   base::do.call(base::Sys.setenv, args = args)
[17:59:17.929]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:17.929]             }
[17:59:17.929]             else {
[17:59:17.929]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:17.929]             }
[17:59:17.929]             {
[17:59:17.929]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:17.929]                   0L) {
[17:59:17.929]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:17.929]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:17.929]                   base::options(opts)
[17:59:17.929]                 }
[17:59:17.929]                 {
[17:59:17.929]                   {
[17:59:17.929]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:17.929]                     NULL
[17:59:17.929]                   }
[17:59:17.929]                   options(future.plan = NULL)
[17:59:17.929]                   if (is.na(NA_character_)) 
[17:59:17.929]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:17.929]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:17.929]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:17.929]                     .init = FALSE)
[17:59:17.929]                 }
[17:59:17.929]             }
[17:59:17.929]         }
[17:59:17.929]     })
[17:59:17.929]     if (TRUE) {
[17:59:17.929]         base::sink(type = "output", split = FALSE)
[17:59:17.929]         if (TRUE) {
[17:59:17.929]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:17.929]         }
[17:59:17.929]         else {
[17:59:17.929]             ...future.result["stdout"] <- base::list(NULL)
[17:59:17.929]         }
[17:59:17.929]         base::close(...future.stdout)
[17:59:17.929]         ...future.stdout <- NULL
[17:59:17.929]     }
[17:59:17.929]     ...future.result$conditions <- ...future.conditions
[17:59:17.929]     ...future.result$finished <- base::Sys.time()
[17:59:17.929]     ...future.result
[17:59:17.929] }
[17:59:17.935] assign_globals() ...
[17:59:17.936] List of 5
[17:59:17.936]  $ future.call.arguments    : list()
[17:59:17.936]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:17.936]  $ ...future.FUN            :function (x)  
[17:59:17.936]  $ ...future.elements_ii    :List of 1
[17:59:17.936]   ..$ : int 2
[17:59:17.936]  $ ...future.seeds_ii       : NULL
[17:59:17.936]  $ ...future.globals.maxSize: num Inf
[17:59:17.936]  - attr(*, "resolved")= logi FALSE
[17:59:17.936]  - attr(*, "total_size")= num NA
[17:59:17.936]  - attr(*, "where")=List of 5
[17:59:17.936]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:17.936]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:17.936]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:17.936]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:17.936]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:17.936]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:17.936]  - attr(*, "already-done")= logi TRUE
[17:59:17.960] - copied ‘future.call.arguments’ to environment
[17:59:17.960] - copied ‘...future.FUN’ to environment
[17:59:17.961] - copied ‘...future.elements_ii’ to environment
[17:59:17.961] - copied ‘...future.seeds_ii’ to environment
[17:59:17.961] - copied ‘...future.globals.maxSize’ to environment
[17:59:17.962] assign_globals() ... done
[17:59:17.962] requestCore(): workers = 2
[17:59:17.966] MulticoreFuture started
[17:59:17.967] - Launch lazy future ... done
[17:59:17.967] run() for ‘MulticoreFuture’ ... done
[17:59:17.968] Created future:
[17:59:17.968] plan(): Setting new future strategy stack:
[17:59:17.969] List of future strategies:
[17:59:17.969] 1. sequential:
[17:59:17.969]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:17.969]    - tweaked: FALSE
[17:59:17.969]    - call: NULL
[17:59:17.971] plan(): nbrOfWorkers() = 1
[17:59:17.975] plan(): Setting new future strategy stack:
[17:59:17.976] List of future strategies:
[17:59:17.976] 1. multicore:
[17:59:17.976]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:17.976]    - tweaked: FALSE
[17:59:17.976]    - call: plan(strategy)
[17:59:17.968] MulticoreFuture:
[17:59:17.968] Label: ‘future_apply-2’
[17:59:17.968] Expression:
[17:59:17.968] {
[17:59:17.968]     do.call(function(...) {
[17:59:17.968]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:17.968]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:17.968]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:17.968]             on.exit(options(oopts), add = TRUE)
[17:59:17.968]         }
[17:59:17.968]         {
[17:59:17.968]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:17.968]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:17.968]                 ...future.FUN(...future.X_jj, ...)
[17:59:17.968]             })
[17:59:17.968]         }
[17:59:17.968]     }, args = future.call.arguments)
[17:59:17.968] }
[17:59:17.968] Lazy evaluation: FALSE
[17:59:17.968] Asynchronous evaluation: TRUE
[17:59:17.968] Local evaluation: TRUE
[17:59:17.968] Environment: R_GlobalEnv
[17:59:17.968] Capture standard output: TRUE
[17:59:17.968] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:17.968] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:17.968] Packages: <none>
[17:59:17.968] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:17.968] Resolved: FALSE
[17:59:17.968] Value: <not collected>
[17:59:17.968] Conditions captured: <none>
[17:59:17.968] Early signaling: FALSE
[17:59:17.968] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:17.968] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:17.984] Chunk #2 of 2 ... DONE
[17:59:17.985] Launching 2 futures (chunks) ... DONE
[17:59:17.985] Resolving 2 futures (chunks) ...
[17:59:17.985] resolve() on list ...
[17:59:17.986]  recursive: 0
[17:59:17.986]  length: 2
[17:59:17.987] 
[17:59:17.987] Future #1
[17:59:17.987] plan(): nbrOfWorkers() = 2
[17:59:17.988] result() for MulticoreFuture ...
[17:59:17.990] result() for MulticoreFuture ...
[17:59:17.990] result() for MulticoreFuture ... done
[17:59:17.990] result() for MulticoreFuture ... done
[17:59:17.990] result() for MulticoreFuture ...
[17:59:17.991] result() for MulticoreFuture ... done
[17:59:17.991] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:17.992] - nx: 2
[17:59:17.992] - relay: TRUE
[17:59:17.992] - stdout: TRUE
[17:59:17.992] - signal: TRUE
[17:59:17.993] - resignal: FALSE
[17:59:17.993] - force: TRUE
[17:59:17.993] - relayed: [n=2] FALSE, FALSE
[17:59:17.994] - queued futures: [n=2] FALSE, FALSE
[17:59:17.994]  - until=1
[17:59:17.994]  - relaying element #1
[17:59:17.995] result() for MulticoreFuture ...
[17:59:17.995] result() for MulticoreFuture ... done
[17:59:17.995] result() for MulticoreFuture ...
[17:59:17.995] result() for MulticoreFuture ... done
[17:59:17.996] result() for MulticoreFuture ...
[17:59:17.996] result() for MulticoreFuture ... done
[17:59:17.997] result() for MulticoreFuture ...
[17:59:17.997] result() for MulticoreFuture ... done
[17:59:17.997] - relayed: [n=2] TRUE, FALSE
[17:59:17.997] - queued futures: [n=2] TRUE, FALSE
[17:59:17.998] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:17.998]  length: 1 (resolved future 1)
[17:59:17.999] Future #2
[17:59:18.000] result() for MulticoreFuture ...
[17:59:18.001] result() for MulticoreFuture ...
[17:59:18.002] result() for MulticoreFuture ... done
[17:59:18.002] result() for MulticoreFuture ... done
[17:59:18.002] result() for MulticoreFuture ...
[17:59:18.003] result() for MulticoreFuture ... done
[17:59:18.003] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:18.003] - nx: 2
[17:59:18.004] - relay: TRUE
[17:59:18.004] - stdout: TRUE
[17:59:18.004] - signal: TRUE
[17:59:18.004] - resignal: FALSE
[17:59:18.005] - force: TRUE
[17:59:18.005] - relayed: [n=2] TRUE, FALSE
[17:59:18.005] - queued futures: [n=2] TRUE, FALSE
[17:59:18.005]  - until=2
[17:59:18.006]  - relaying element #2
[17:59:18.006] result() for MulticoreFuture ...
[17:59:18.006] result() for MulticoreFuture ... done
[17:59:18.006] result() for MulticoreFuture ...
[17:59:18.007] result() for MulticoreFuture ... done
[17:59:18.007] result() for MulticoreFuture ...
[17:59:18.007] result() for MulticoreFuture ... done
[17:59:18.008] result() for MulticoreFuture ...
[17:59:18.008] result() for MulticoreFuture ... done
[17:59:18.008] - relayed: [n=2] TRUE, TRUE
[17:59:18.008] - queued futures: [n=2] TRUE, TRUE
[17:59:18.008] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:18.009]  length: 0 (resolved future 2)
[17:59:18.009] Relaying remaining futures
[17:59:18.009] signalConditionsASAP(NULL, pos=0) ...
[17:59:18.009] - nx: 2
[17:59:18.010] - relay: TRUE
[17:59:18.010] - stdout: TRUE
[17:59:18.010] - signal: TRUE
[17:59:18.010] - resignal: FALSE
[17:59:18.011] - force: TRUE
[17:59:18.011] - relayed: [n=2] TRUE, TRUE
[17:59:18.011] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:18.011] - relayed: [n=2] TRUE, TRUE
[17:59:18.012] - queued futures: [n=2] TRUE, TRUE
[17:59:18.012] signalConditionsASAP(NULL, pos=0) ... done
[17:59:18.012] resolve() on list ... DONE
[17:59:18.012] result() for MulticoreFuture ...
[17:59:18.013] result() for MulticoreFuture ... done
[17:59:18.013] result() for MulticoreFuture ...
[17:59:18.013] result() for MulticoreFuture ... done
[17:59:18.013] result() for MulticoreFuture ...
[17:59:18.014] result() for MulticoreFuture ... done
[17:59:18.014] result() for MulticoreFuture ...
[17:59:18.014] result() for MulticoreFuture ... done
[17:59:18.014]  - Number of value chunks collected: 2
[17:59:18.015] Resolving 2 futures (chunks) ... DONE
[17:59:18.015] Reducing values from 2 chunks ...
[17:59:18.015]  - Number of values collected after concatenation: 2
[17:59:18.015]  - Number of values expected: 2
[17:59:18.015] Reducing values from 2 chunks ... DONE
[17:59:18.016] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:59:18.016] getGlobalsAndPackagesXApply() ...
[17:59:18.017]  - future.globals: TRUE
[17:59:18.017] getGlobalsAndPackages() ...
[17:59:18.017] Searching for globals...
[17:59:18.020] - globals found: [1] ‘FUN’
[17:59:18.020] Searching for globals ... DONE
[17:59:18.020] Resolving globals: FALSE
[17:59:18.021] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:18.022] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:18.022] - globals: [1] ‘FUN’
[17:59:18.023] 
[17:59:18.023] getGlobalsAndPackages() ... DONE
[17:59:18.023]  - globals found/used: [n=1] ‘FUN’
[17:59:18.023]  - needed namespaces: [n=0] 
[17:59:18.024] Finding globals ... DONE
[17:59:18.024]  - use_args: TRUE
[17:59:18.024]  - Getting '...' globals ...
[17:59:18.025] resolve() on list ...
[17:59:18.025]  recursive: 0
[17:59:18.025]  length: 1
[17:59:18.026]  elements: ‘...’
[17:59:18.026]  length: 0 (resolved future 1)
[17:59:18.026] resolve() on list ... DONE
[17:59:18.027]    - '...' content: [n=0] 
[17:59:18.030] List of 1
[17:59:18.030]  $ ...: list()
[17:59:18.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.030]  - attr(*, "where")=List of 1
[17:59:18.030]   ..$ ...:<environment: 0x56085b5e4d30> 
[17:59:18.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.030]  - attr(*, "resolved")= logi TRUE
[17:59:18.030]  - attr(*, "total_size")= num NA
[17:59:18.038]  - Getting '...' globals ... DONE
[17:59:18.038] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:18.039] List of 2
[17:59:18.039]  $ ...future.FUN:function (x)  
[17:59:18.039]  $ ...          : list()
[17:59:18.039]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.039]  - attr(*, "where")=List of 2
[17:59:18.039]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:18.039]   ..$ ...          :<environment: 0x56085b5e4d30> 
[17:59:18.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.039]  - attr(*, "resolved")= logi FALSE
[17:59:18.039]  - attr(*, "total_size")= num 848
[17:59:18.046] Packages to be attached in all futures: [n=0] 
[17:59:18.047] getGlobalsAndPackagesXApply() ... DONE
[17:59:18.053] future_lapply() ...
[17:59:18.060] Number of chunks: 2
[17:59:18.061] getGlobalsAndPackagesXApply() ...
[17:59:18.061]  - future.globals: <name-value list> with names ‘list()’
[17:59:18.061]  - use_args: TRUE
[17:59:18.062] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:18.062] List of 2
[17:59:18.062]  $ ...          : list()
[17:59:18.062]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.062]  $ ...future.FUN:function (x)  
[17:59:18.062]  - attr(*, "where")=List of 2
[17:59:18.062]   ..$ ...          :<environment: 0x56085b5e4d30> 
[17:59:18.062]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:18.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.062]  - attr(*, "resolved")= logi FALSE
[17:59:18.062]  - attr(*, "total_size")= num NA
[17:59:18.070] Packages to be attached in all futures: [n=0] 
[17:59:18.070] getGlobalsAndPackagesXApply() ... DONE
[17:59:18.070] Number of futures (= number of chunks): 2
[17:59:18.071] Launching 2 futures (chunks) ...
[17:59:18.071] Chunk #1 of 2 ...
[17:59:18.071]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:18.072]  - seeds: <none>
[17:59:18.072]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.072] getGlobalsAndPackages() ...
[17:59:18.072] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.072] Resolving globals: FALSE
[17:59:18.073] Tweak future expression to call with '...' arguments ...
[17:59:18.073] {
[17:59:18.073]     do.call(function(...) {
[17:59:18.073]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.073]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.073]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.073]             on.exit(options(oopts), add = TRUE)
[17:59:18.073]         }
[17:59:18.073]         {
[17:59:18.073]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.073]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.073]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.073]             })
[17:59:18.073]         }
[17:59:18.073]     }, args = future.call.arguments)
[17:59:18.073] }
[17:59:18.073] Tweak future expression to call with '...' arguments ... DONE
[17:59:18.074] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.075] 
[17:59:18.075] getGlobalsAndPackages() ... DONE
[17:59:18.075] run() for ‘Future’ ...
[17:59:18.076] - state: ‘created’
[17:59:18.076] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:18.083] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.083] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:18.084]   - Field: ‘label’
[17:59:18.084]   - Field: ‘local’
[17:59:18.084]   - Field: ‘owner’
[17:59:18.084]   - Field: ‘envir’
[17:59:18.085]   - Field: ‘workers’
[17:59:18.085]   - Field: ‘packages’
[17:59:18.085]   - Field: ‘gc’
[17:59:18.085]   - Field: ‘job’
[17:59:18.086]   - Field: ‘conditions’
[17:59:18.086]   - Field: ‘expr’
[17:59:18.086]   - Field: ‘uuid’
[17:59:18.086]   - Field: ‘seed’
[17:59:18.086]   - Field: ‘version’
[17:59:18.087]   - Field: ‘result’
[17:59:18.087]   - Field: ‘asynchronous’
[17:59:18.087]   - Field: ‘calls’
[17:59:18.087]   - Field: ‘globals’
[17:59:18.087]   - Field: ‘stdout’
[17:59:18.088]   - Field: ‘earlySignal’
[17:59:18.088]   - Field: ‘lazy’
[17:59:18.088]   - Field: ‘state’
[17:59:18.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:18.089] - Launch lazy future ...
[17:59:18.089] Packages needed by the future expression (n = 0): <none>
[17:59:18.089] Packages needed by future strategies (n = 0): <none>
[17:59:18.090] {
[17:59:18.090]     {
[17:59:18.090]         {
[17:59:18.090]             ...future.startTime <- base::Sys.time()
[17:59:18.090]             {
[17:59:18.090]                 {
[17:59:18.090]                   {
[17:59:18.090]                     {
[17:59:18.090]                       base::local({
[17:59:18.090]                         has_future <- base::requireNamespace("future", 
[17:59:18.090]                           quietly = TRUE)
[17:59:18.090]                         if (has_future) {
[17:59:18.090]                           ns <- base::getNamespace("future")
[17:59:18.090]                           version <- ns[[".package"]][["version"]]
[17:59:18.090]                           if (is.null(version)) 
[17:59:18.090]                             version <- utils::packageVersion("future")
[17:59:18.090]                         }
[17:59:18.090]                         else {
[17:59:18.090]                           version <- NULL
[17:59:18.090]                         }
[17:59:18.090]                         if (!has_future || version < "1.8.0") {
[17:59:18.090]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:18.090]                             "", base::R.version$version.string), 
[17:59:18.090]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:18.090]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:18.090]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:18.090]                               "release", "version")], collapse = " "), 
[17:59:18.090]                             hostname = base::Sys.info()[["nodename"]])
[17:59:18.090]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:18.090]                             info)
[17:59:18.090]                           info <- base::paste(info, collapse = "; ")
[17:59:18.090]                           if (!has_future) {
[17:59:18.090]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:18.090]                               info)
[17:59:18.090]                           }
[17:59:18.090]                           else {
[17:59:18.090]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:18.090]                               info, version)
[17:59:18.090]                           }
[17:59:18.090]                           base::stop(msg)
[17:59:18.090]                         }
[17:59:18.090]                       })
[17:59:18.090]                     }
[17:59:18.090]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:18.090]                     base::options(mc.cores = 1L)
[17:59:18.090]                   }
[17:59:18.090]                   ...future.strategy.old <- future::plan("list")
[17:59:18.090]                   options(future.plan = NULL)
[17:59:18.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:18.090]                 }
[17:59:18.090]                 ...future.workdir <- getwd()
[17:59:18.090]             }
[17:59:18.090]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:18.090]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:18.090]         }
[17:59:18.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:18.090]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:18.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:18.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:18.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:18.090]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:18.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:18.090]             base::names(...future.oldOptions))
[17:59:18.090]     }
[17:59:18.090]     if (FALSE) {
[17:59:18.090]     }
[17:59:18.090]     else {
[17:59:18.090]         if (TRUE) {
[17:59:18.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:18.090]                 open = "w")
[17:59:18.090]         }
[17:59:18.090]         else {
[17:59:18.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:18.090]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:18.090]         }
[17:59:18.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:18.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:18.090]             base::sink(type = "output", split = FALSE)
[17:59:18.090]             base::close(...future.stdout)
[17:59:18.090]         }, add = TRUE)
[17:59:18.090]     }
[17:59:18.090]     ...future.frame <- base::sys.nframe()
[17:59:18.090]     ...future.conditions <- base::list()
[17:59:18.090]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:18.090]     if (FALSE) {
[17:59:18.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:18.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:18.090]     }
[17:59:18.090]     ...future.result <- base::tryCatch({
[17:59:18.090]         base::withCallingHandlers({
[17:59:18.090]             ...future.value <- base::withVisible(base::local({
[17:59:18.090]                 withCallingHandlers({
[17:59:18.090]                   {
[17:59:18.090]                     do.call(function(...) {
[17:59:18.090]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.090]                       if (!identical(...future.globals.maxSize.org, 
[17:59:18.090]                         ...future.globals.maxSize)) {
[17:59:18.090]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.090]                         on.exit(options(oopts), add = TRUE)
[17:59:18.090]                       }
[17:59:18.090]                       {
[17:59:18.090]                         lapply(seq_along(...future.elements_ii), 
[17:59:18.090]                           FUN = function(jj) {
[17:59:18.090]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.090]                             ...future.FUN(...future.X_jj, ...)
[17:59:18.090]                           })
[17:59:18.090]                       }
[17:59:18.090]                     }, args = future.call.arguments)
[17:59:18.090]                   }
[17:59:18.090]                 }, immediateCondition = function(cond) {
[17:59:18.090]                   save_rds <- function (object, pathname, ...) 
[17:59:18.090]                   {
[17:59:18.090]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:18.090]                     if (file_test("-f", pathname_tmp)) {
[17:59:18.090]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.090]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:18.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.090]                         fi_tmp[["mtime"]])
[17:59:18.090]                     }
[17:59:18.090]                     tryCatch({
[17:59:18.090]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:18.090]                     }, error = function(ex) {
[17:59:18.090]                       msg <- conditionMessage(ex)
[17:59:18.090]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.090]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:18.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.090]                         fi_tmp[["mtime"]], msg)
[17:59:18.090]                       ex$message <- msg
[17:59:18.090]                       stop(ex)
[17:59:18.090]                     })
[17:59:18.090]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:18.090]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:18.090]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:18.090]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.090]                       fi <- file.info(pathname)
[17:59:18.090]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:18.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.090]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:18.090]                         fi[["size"]], fi[["mtime"]])
[17:59:18.090]                       stop(msg)
[17:59:18.090]                     }
[17:59:18.090]                     invisible(pathname)
[17:59:18.090]                   }
[17:59:18.090]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:18.090]                     rootPath = tempdir()) 
[17:59:18.090]                   {
[17:59:18.090]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:18.090]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:18.090]                       tmpdir = path, fileext = ".rds")
[17:59:18.090]                     save_rds(obj, file)
[17:59:18.090]                   }
[17:59:18.090]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:18.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.090]                   {
[17:59:18.090]                     inherits <- base::inherits
[17:59:18.090]                     invokeRestart <- base::invokeRestart
[17:59:18.090]                     is.null <- base::is.null
[17:59:18.090]                     muffled <- FALSE
[17:59:18.090]                     if (inherits(cond, "message")) {
[17:59:18.090]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:18.090]                       if (muffled) 
[17:59:18.090]                         invokeRestart("muffleMessage")
[17:59:18.090]                     }
[17:59:18.090]                     else if (inherits(cond, "warning")) {
[17:59:18.090]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:18.090]                       if (muffled) 
[17:59:18.090]                         invokeRestart("muffleWarning")
[17:59:18.090]                     }
[17:59:18.090]                     else if (inherits(cond, "condition")) {
[17:59:18.090]                       if (!is.null(pattern)) {
[17:59:18.090]                         computeRestarts <- base::computeRestarts
[17:59:18.090]                         grepl <- base::grepl
[17:59:18.090]                         restarts <- computeRestarts(cond)
[17:59:18.090]                         for (restart in restarts) {
[17:59:18.090]                           name <- restart$name
[17:59:18.090]                           if (is.null(name)) 
[17:59:18.090]                             next
[17:59:18.090]                           if (!grepl(pattern, name)) 
[17:59:18.090]                             next
[17:59:18.090]                           invokeRestart(restart)
[17:59:18.090]                           muffled <- TRUE
[17:59:18.090]                           break
[17:59:18.090]                         }
[17:59:18.090]                       }
[17:59:18.090]                     }
[17:59:18.090]                     invisible(muffled)
[17:59:18.090]                   }
[17:59:18.090]                   muffleCondition(cond)
[17:59:18.090]                 })
[17:59:18.090]             }))
[17:59:18.090]             future::FutureResult(value = ...future.value$value, 
[17:59:18.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.090]                   ...future.rng), globalenv = if (FALSE) 
[17:59:18.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:18.090]                     ...future.globalenv.names))
[17:59:18.090]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:18.090]         }, condition = base::local({
[17:59:18.090]             c <- base::c
[17:59:18.090]             inherits <- base::inherits
[17:59:18.090]             invokeRestart <- base::invokeRestart
[17:59:18.090]             length <- base::length
[17:59:18.090]             list <- base::list
[17:59:18.090]             seq.int <- base::seq.int
[17:59:18.090]             signalCondition <- base::signalCondition
[17:59:18.090]             sys.calls <- base::sys.calls
[17:59:18.090]             `[[` <- base::`[[`
[17:59:18.090]             `+` <- base::`+`
[17:59:18.090]             `<<-` <- base::`<<-`
[17:59:18.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:18.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:18.090]                   3L)]
[17:59:18.090]             }
[17:59:18.090]             function(cond) {
[17:59:18.090]                 is_error <- inherits(cond, "error")
[17:59:18.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:18.090]                   NULL)
[17:59:18.090]                 if (is_error) {
[17:59:18.090]                   sessionInformation <- function() {
[17:59:18.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:18.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:18.090]                       search = base::search(), system = base::Sys.info())
[17:59:18.090]                   }
[17:59:18.090]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:18.090]                     cond$call), session = sessionInformation(), 
[17:59:18.090]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:18.090]                   signalCondition(cond)
[17:59:18.090]                 }
[17:59:18.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:18.090]                 "immediateCondition"))) {
[17:59:18.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:18.090]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:18.090]                   if (TRUE && !signal) {
[17:59:18.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.090]                     {
[17:59:18.090]                       inherits <- base::inherits
[17:59:18.090]                       invokeRestart <- base::invokeRestart
[17:59:18.090]                       is.null <- base::is.null
[17:59:18.090]                       muffled <- FALSE
[17:59:18.090]                       if (inherits(cond, "message")) {
[17:59:18.090]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.090]                         if (muffled) 
[17:59:18.090]                           invokeRestart("muffleMessage")
[17:59:18.090]                       }
[17:59:18.090]                       else if (inherits(cond, "warning")) {
[17:59:18.090]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.090]                         if (muffled) 
[17:59:18.090]                           invokeRestart("muffleWarning")
[17:59:18.090]                       }
[17:59:18.090]                       else if (inherits(cond, "condition")) {
[17:59:18.090]                         if (!is.null(pattern)) {
[17:59:18.090]                           computeRestarts <- base::computeRestarts
[17:59:18.090]                           grepl <- base::grepl
[17:59:18.090]                           restarts <- computeRestarts(cond)
[17:59:18.090]                           for (restart in restarts) {
[17:59:18.090]                             name <- restart$name
[17:59:18.090]                             if (is.null(name)) 
[17:59:18.090]                               next
[17:59:18.090]                             if (!grepl(pattern, name)) 
[17:59:18.090]                               next
[17:59:18.090]                             invokeRestart(restart)
[17:59:18.090]                             muffled <- TRUE
[17:59:18.090]                             break
[17:59:18.090]                           }
[17:59:18.090]                         }
[17:59:18.090]                       }
[17:59:18.090]                       invisible(muffled)
[17:59:18.090]                     }
[17:59:18.090]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.090]                   }
[17:59:18.090]                 }
[17:59:18.090]                 else {
[17:59:18.090]                   if (TRUE) {
[17:59:18.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.090]                     {
[17:59:18.090]                       inherits <- base::inherits
[17:59:18.090]                       invokeRestart <- base::invokeRestart
[17:59:18.090]                       is.null <- base::is.null
[17:59:18.090]                       muffled <- FALSE
[17:59:18.090]                       if (inherits(cond, "message")) {
[17:59:18.090]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.090]                         if (muffled) 
[17:59:18.090]                           invokeRestart("muffleMessage")
[17:59:18.090]                       }
[17:59:18.090]                       else if (inherits(cond, "warning")) {
[17:59:18.090]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.090]                         if (muffled) 
[17:59:18.090]                           invokeRestart("muffleWarning")
[17:59:18.090]                       }
[17:59:18.090]                       else if (inherits(cond, "condition")) {
[17:59:18.090]                         if (!is.null(pattern)) {
[17:59:18.090]                           computeRestarts <- base::computeRestarts
[17:59:18.090]                           grepl <- base::grepl
[17:59:18.090]                           restarts <- computeRestarts(cond)
[17:59:18.090]                           for (restart in restarts) {
[17:59:18.090]                             name <- restart$name
[17:59:18.090]                             if (is.null(name)) 
[17:59:18.090]                               next
[17:59:18.090]                             if (!grepl(pattern, name)) 
[17:59:18.090]                               next
[17:59:18.090]                             invokeRestart(restart)
[17:59:18.090]                             muffled <- TRUE
[17:59:18.090]                             break
[17:59:18.090]                           }
[17:59:18.090]                         }
[17:59:18.090]                       }
[17:59:18.090]                       invisible(muffled)
[17:59:18.090]                     }
[17:59:18.090]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.090]                   }
[17:59:18.090]                 }
[17:59:18.090]             }
[17:59:18.090]         }))
[17:59:18.090]     }, error = function(ex) {
[17:59:18.090]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:18.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.090]                 ...future.rng), started = ...future.startTime, 
[17:59:18.090]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:18.090]             version = "1.8"), class = "FutureResult")
[17:59:18.090]     }, finally = {
[17:59:18.090]         if (!identical(...future.workdir, getwd())) 
[17:59:18.090]             setwd(...future.workdir)
[17:59:18.090]         {
[17:59:18.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:18.090]                 ...future.oldOptions$nwarnings <- NULL
[17:59:18.090]             }
[17:59:18.090]             base::options(...future.oldOptions)
[17:59:18.090]             if (.Platform$OS.type == "windows") {
[17:59:18.090]                 old_names <- names(...future.oldEnvVars)
[17:59:18.090]                 envs <- base::Sys.getenv()
[17:59:18.090]                 names <- names(envs)
[17:59:18.090]                 common <- intersect(names, old_names)
[17:59:18.090]                 added <- setdiff(names, old_names)
[17:59:18.090]                 removed <- setdiff(old_names, names)
[17:59:18.090]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:18.090]                   envs[common]]
[17:59:18.090]                 NAMES <- toupper(changed)
[17:59:18.090]                 args <- list()
[17:59:18.090]                 for (kk in seq_along(NAMES)) {
[17:59:18.090]                   name <- changed[[kk]]
[17:59:18.090]                   NAME <- NAMES[[kk]]
[17:59:18.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.090]                     next
[17:59:18.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.090]                 }
[17:59:18.090]                 NAMES <- toupper(added)
[17:59:18.090]                 for (kk in seq_along(NAMES)) {
[17:59:18.090]                   name <- added[[kk]]
[17:59:18.090]                   NAME <- NAMES[[kk]]
[17:59:18.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.090]                     next
[17:59:18.090]                   args[[name]] <- ""
[17:59:18.090]                 }
[17:59:18.090]                 NAMES <- toupper(removed)
[17:59:18.090]                 for (kk in seq_along(NAMES)) {
[17:59:18.090]                   name <- removed[[kk]]
[17:59:18.090]                   NAME <- NAMES[[kk]]
[17:59:18.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.090]                     next
[17:59:18.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.090]                 }
[17:59:18.090]                 if (length(args) > 0) 
[17:59:18.090]                   base::do.call(base::Sys.setenv, args = args)
[17:59:18.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:18.090]             }
[17:59:18.090]             else {
[17:59:18.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:18.090]             }
[17:59:18.090]             {
[17:59:18.090]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:18.090]                   0L) {
[17:59:18.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:18.090]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:18.090]                   base::options(opts)
[17:59:18.090]                 }
[17:59:18.090]                 {
[17:59:18.090]                   {
[17:59:18.090]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:18.090]                     NULL
[17:59:18.090]                   }
[17:59:18.090]                   options(future.plan = NULL)
[17:59:18.090]                   if (is.na(NA_character_)) 
[17:59:18.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:18.090]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:18.090]                     .init = FALSE)
[17:59:18.090]                 }
[17:59:18.090]             }
[17:59:18.090]         }
[17:59:18.090]     })
[17:59:18.090]     if (TRUE) {
[17:59:18.090]         base::sink(type = "output", split = FALSE)
[17:59:18.090]         if (TRUE) {
[17:59:18.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:18.090]         }
[17:59:18.090]         else {
[17:59:18.090]             ...future.result["stdout"] <- base::list(NULL)
[17:59:18.090]         }
[17:59:18.090]         base::close(...future.stdout)
[17:59:18.090]         ...future.stdout <- NULL
[17:59:18.090]     }
[17:59:18.090]     ...future.result$conditions <- ...future.conditions
[17:59:18.090]     ...future.result$finished <- base::Sys.time()
[17:59:18.090]     ...future.result
[17:59:18.090] }
[17:59:18.096] assign_globals() ...
[17:59:18.096] List of 5
[17:59:18.096]  $ future.call.arguments    : list()
[17:59:18.096]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.096]  $ ...future.FUN            :function (x)  
[17:59:18.096]  $ ...future.elements_ii    :List of 1
[17:59:18.096]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[17:59:18.096]  $ ...future.seeds_ii       : NULL
[17:59:18.096]  $ ...future.globals.maxSize: num Inf
[17:59:18.096]  - attr(*, "resolved")= logi FALSE
[17:59:18.096]  - attr(*, "total_size")= num NA
[17:59:18.096]  - attr(*, "where")=List of 5
[17:59:18.096]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:18.096]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:18.096]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:18.096]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:18.096]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:18.096]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.096]  - attr(*, "already-done")= logi TRUE
[17:59:18.110] - copied ‘future.call.arguments’ to environment
[17:59:18.110] - copied ‘...future.FUN’ to environment
[17:59:18.110] - copied ‘...future.elements_ii’ to environment
[17:59:18.110] - copied ‘...future.seeds_ii’ to environment
[17:59:18.111] - copied ‘...future.globals.maxSize’ to environment
[17:59:18.111] assign_globals() ... done
[17:59:18.111] requestCore(): workers = 2
[17:59:18.116] MulticoreFuture started
[17:59:18.117] - Launch lazy future ... done
[17:59:18.117] run() for ‘MulticoreFuture’ ... done
[17:59:18.119] Created future:
[17:59:18.122] plan(): Setting new future strategy stack:
[17:59:18.122] List of future strategies:
[17:59:18.122] 1. sequential:
[17:59:18.122]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:18.122]    - tweaked: FALSE
[17:59:18.122]    - call: NULL
[17:59:18.125] plan(): nbrOfWorkers() = 1
[17:59:18.129] plan(): Setting new future strategy stack:
[17:59:18.130] List of future strategies:
[17:59:18.130] 1. multicore:
[17:59:18.130]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:18.130]    - tweaked: FALSE
[17:59:18.130]    - call: plan(strategy)
[17:59:18.119] MulticoreFuture:
[17:59:18.119] Label: ‘future_apply-1’
[17:59:18.119] Expression:
[17:59:18.119] {
[17:59:18.119]     do.call(function(...) {
[17:59:18.119]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.119]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.119]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.119]             on.exit(options(oopts), add = TRUE)
[17:59:18.119]         }
[17:59:18.119]         {
[17:59:18.119]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.119]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.119]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.119]             })
[17:59:18.119]         }
[17:59:18.119]     }, args = future.call.arguments)
[17:59:18.119] }
[17:59:18.119] Lazy evaluation: FALSE
[17:59:18.119] Asynchronous evaluation: TRUE
[17:59:18.119] Local evaluation: TRUE
[17:59:18.119] Environment: R_GlobalEnv
[17:59:18.119] Capture standard output: TRUE
[17:59:18.119] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:18.119] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:18.119] Packages: <none>
[17:59:18.119] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:18.119] Resolved: FALSE
[17:59:18.119] Value: <not collected>
[17:59:18.119] Conditions captured: <none>
[17:59:18.119] Early signaling: FALSE
[17:59:18.119] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:18.119] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.135] Chunk #1 of 2 ... DONE
[17:59:18.135] Chunk #2 of 2 ...
[17:59:18.136]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:18.136]  - seeds: <none>
[17:59:18.136]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.137] getGlobalsAndPackages() ...
[17:59:18.137] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.138] Resolving globals: FALSE
[17:59:18.138] Tweak future expression to call with '...' arguments ...
[17:59:18.139] {
[17:59:18.139]     do.call(function(...) {
[17:59:18.139]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.139]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.139]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.139]             on.exit(options(oopts), add = TRUE)
[17:59:18.139]         }
[17:59:18.139]         {
[17:59:18.139]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.139]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.139]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.139]             })
[17:59:18.139]         }
[17:59:18.139]     }, args = future.call.arguments)
[17:59:18.139] }
[17:59:18.140] Tweak future expression to call with '...' arguments ... DONE
[17:59:18.142] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.143] 
[17:59:18.146] getGlobalsAndPackages() ... DONE
[17:59:18.147] run() for ‘Future’ ...
[17:59:18.148] plan(): nbrOfWorkers() = 2
[17:59:18.148] - state: ‘created’
[17:59:18.150] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:18.158] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.158] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:18.158]   - Field: ‘label’
[17:59:18.159]   - Field: ‘local’
[17:59:18.159]   - Field: ‘owner’
[17:59:18.159]   - Field: ‘envir’
[17:59:18.160]   - Field: ‘workers’
[17:59:18.160]   - Field: ‘packages’
[17:59:18.160]   - Field: ‘gc’
[17:59:18.161]   - Field: ‘job’
[17:59:18.161]   - Field: ‘conditions’
[17:59:18.161]   - Field: ‘expr’
[17:59:18.162]   - Field: ‘uuid’
[17:59:18.162]   - Field: ‘seed’
[17:59:18.162]   - Field: ‘version’
[17:59:18.163]   - Field: ‘result’
[17:59:18.163]   - Field: ‘asynchronous’
[17:59:18.163]   - Field: ‘calls’
[17:59:18.164]   - Field: ‘globals’
[17:59:18.164]   - Field: ‘stdout’
[17:59:18.164]   - Field: ‘earlySignal’
[17:59:18.165]   - Field: ‘lazy’
[17:59:18.165]   - Field: ‘state’
[17:59:18.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:18.166] - Launch lazy future ...
[17:59:18.167] Packages needed by the future expression (n = 0): <none>
[17:59:18.167] Packages needed by future strategies (n = 0): <none>
[17:59:18.169] {
[17:59:18.169]     {
[17:59:18.169]         {
[17:59:18.169]             ...future.startTime <- base::Sys.time()
[17:59:18.169]             {
[17:59:18.169]                 {
[17:59:18.169]                   {
[17:59:18.169]                     {
[17:59:18.169]                       base::local({
[17:59:18.169]                         has_future <- base::requireNamespace("future", 
[17:59:18.169]                           quietly = TRUE)
[17:59:18.169]                         if (has_future) {
[17:59:18.169]                           ns <- base::getNamespace("future")
[17:59:18.169]                           version <- ns[[".package"]][["version"]]
[17:59:18.169]                           if (is.null(version)) 
[17:59:18.169]                             version <- utils::packageVersion("future")
[17:59:18.169]                         }
[17:59:18.169]                         else {
[17:59:18.169]                           version <- NULL
[17:59:18.169]                         }
[17:59:18.169]                         if (!has_future || version < "1.8.0") {
[17:59:18.169]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:18.169]                             "", base::R.version$version.string), 
[17:59:18.169]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:18.169]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:18.169]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:18.169]                               "release", "version")], collapse = " "), 
[17:59:18.169]                             hostname = base::Sys.info()[["nodename"]])
[17:59:18.169]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:18.169]                             info)
[17:59:18.169]                           info <- base::paste(info, collapse = "; ")
[17:59:18.169]                           if (!has_future) {
[17:59:18.169]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:18.169]                               info)
[17:59:18.169]                           }
[17:59:18.169]                           else {
[17:59:18.169]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:18.169]                               info, version)
[17:59:18.169]                           }
[17:59:18.169]                           base::stop(msg)
[17:59:18.169]                         }
[17:59:18.169]                       })
[17:59:18.169]                     }
[17:59:18.169]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:18.169]                     base::options(mc.cores = 1L)
[17:59:18.169]                   }
[17:59:18.169]                   ...future.strategy.old <- future::plan("list")
[17:59:18.169]                   options(future.plan = NULL)
[17:59:18.169]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.169]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:18.169]                 }
[17:59:18.169]                 ...future.workdir <- getwd()
[17:59:18.169]             }
[17:59:18.169]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:18.169]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:18.169]         }
[17:59:18.169]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:18.169]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:18.169]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:18.169]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:18.169]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:18.169]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:18.169]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:18.169]             base::names(...future.oldOptions))
[17:59:18.169]     }
[17:59:18.169]     if (FALSE) {
[17:59:18.169]     }
[17:59:18.169]     else {
[17:59:18.169]         if (TRUE) {
[17:59:18.169]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:18.169]                 open = "w")
[17:59:18.169]         }
[17:59:18.169]         else {
[17:59:18.169]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:18.169]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:18.169]         }
[17:59:18.169]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:18.169]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:18.169]             base::sink(type = "output", split = FALSE)
[17:59:18.169]             base::close(...future.stdout)
[17:59:18.169]         }, add = TRUE)
[17:59:18.169]     }
[17:59:18.169]     ...future.frame <- base::sys.nframe()
[17:59:18.169]     ...future.conditions <- base::list()
[17:59:18.169]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:18.169]     if (FALSE) {
[17:59:18.169]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:18.169]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:18.169]     }
[17:59:18.169]     ...future.result <- base::tryCatch({
[17:59:18.169]         base::withCallingHandlers({
[17:59:18.169]             ...future.value <- base::withVisible(base::local({
[17:59:18.169]                 withCallingHandlers({
[17:59:18.169]                   {
[17:59:18.169]                     do.call(function(...) {
[17:59:18.169]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.169]                       if (!identical(...future.globals.maxSize.org, 
[17:59:18.169]                         ...future.globals.maxSize)) {
[17:59:18.169]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.169]                         on.exit(options(oopts), add = TRUE)
[17:59:18.169]                       }
[17:59:18.169]                       {
[17:59:18.169]                         lapply(seq_along(...future.elements_ii), 
[17:59:18.169]                           FUN = function(jj) {
[17:59:18.169]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.169]                             ...future.FUN(...future.X_jj, ...)
[17:59:18.169]                           })
[17:59:18.169]                       }
[17:59:18.169]                     }, args = future.call.arguments)
[17:59:18.169]                   }
[17:59:18.169]                 }, immediateCondition = function(cond) {
[17:59:18.169]                   save_rds <- function (object, pathname, ...) 
[17:59:18.169]                   {
[17:59:18.169]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:18.169]                     if (file_test("-f", pathname_tmp)) {
[17:59:18.169]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.169]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:18.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.169]                         fi_tmp[["mtime"]])
[17:59:18.169]                     }
[17:59:18.169]                     tryCatch({
[17:59:18.169]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:18.169]                     }, error = function(ex) {
[17:59:18.169]                       msg <- conditionMessage(ex)
[17:59:18.169]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.169]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:18.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.169]                         fi_tmp[["mtime"]], msg)
[17:59:18.169]                       ex$message <- msg
[17:59:18.169]                       stop(ex)
[17:59:18.169]                     })
[17:59:18.169]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:18.169]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:18.169]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:18.169]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.169]                       fi <- file.info(pathname)
[17:59:18.169]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:18.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.169]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:18.169]                         fi[["size"]], fi[["mtime"]])
[17:59:18.169]                       stop(msg)
[17:59:18.169]                     }
[17:59:18.169]                     invisible(pathname)
[17:59:18.169]                   }
[17:59:18.169]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:18.169]                     rootPath = tempdir()) 
[17:59:18.169]                   {
[17:59:18.169]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:18.169]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:18.169]                       tmpdir = path, fileext = ".rds")
[17:59:18.169]                     save_rds(obj, file)
[17:59:18.169]                   }
[17:59:18.169]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:18.169]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.169]                   {
[17:59:18.169]                     inherits <- base::inherits
[17:59:18.169]                     invokeRestart <- base::invokeRestart
[17:59:18.169]                     is.null <- base::is.null
[17:59:18.169]                     muffled <- FALSE
[17:59:18.169]                     if (inherits(cond, "message")) {
[17:59:18.169]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:18.169]                       if (muffled) 
[17:59:18.169]                         invokeRestart("muffleMessage")
[17:59:18.169]                     }
[17:59:18.169]                     else if (inherits(cond, "warning")) {
[17:59:18.169]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:18.169]                       if (muffled) 
[17:59:18.169]                         invokeRestart("muffleWarning")
[17:59:18.169]                     }
[17:59:18.169]                     else if (inherits(cond, "condition")) {
[17:59:18.169]                       if (!is.null(pattern)) {
[17:59:18.169]                         computeRestarts <- base::computeRestarts
[17:59:18.169]                         grepl <- base::grepl
[17:59:18.169]                         restarts <- computeRestarts(cond)
[17:59:18.169]                         for (restart in restarts) {
[17:59:18.169]                           name <- restart$name
[17:59:18.169]                           if (is.null(name)) 
[17:59:18.169]                             next
[17:59:18.169]                           if (!grepl(pattern, name)) 
[17:59:18.169]                             next
[17:59:18.169]                           invokeRestart(restart)
[17:59:18.169]                           muffled <- TRUE
[17:59:18.169]                           break
[17:59:18.169]                         }
[17:59:18.169]                       }
[17:59:18.169]                     }
[17:59:18.169]                     invisible(muffled)
[17:59:18.169]                   }
[17:59:18.169]                   muffleCondition(cond)
[17:59:18.169]                 })
[17:59:18.169]             }))
[17:59:18.169]             future::FutureResult(value = ...future.value$value, 
[17:59:18.169]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.169]                   ...future.rng), globalenv = if (FALSE) 
[17:59:18.169]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:18.169]                     ...future.globalenv.names))
[17:59:18.169]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:18.169]         }, condition = base::local({
[17:59:18.169]             c <- base::c
[17:59:18.169]             inherits <- base::inherits
[17:59:18.169]             invokeRestart <- base::invokeRestart
[17:59:18.169]             length <- base::length
[17:59:18.169]             list <- base::list
[17:59:18.169]             seq.int <- base::seq.int
[17:59:18.169]             signalCondition <- base::signalCondition
[17:59:18.169]             sys.calls <- base::sys.calls
[17:59:18.169]             `[[` <- base::`[[`
[17:59:18.169]             `+` <- base::`+`
[17:59:18.169]             `<<-` <- base::`<<-`
[17:59:18.169]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:18.169]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:18.169]                   3L)]
[17:59:18.169]             }
[17:59:18.169]             function(cond) {
[17:59:18.169]                 is_error <- inherits(cond, "error")
[17:59:18.169]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:18.169]                   NULL)
[17:59:18.169]                 if (is_error) {
[17:59:18.169]                   sessionInformation <- function() {
[17:59:18.169]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:18.169]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:18.169]                       search = base::search(), system = base::Sys.info())
[17:59:18.169]                   }
[17:59:18.169]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.169]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:18.169]                     cond$call), session = sessionInformation(), 
[17:59:18.169]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:18.169]                   signalCondition(cond)
[17:59:18.169]                 }
[17:59:18.169]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:18.169]                 "immediateCondition"))) {
[17:59:18.169]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:18.169]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.169]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:18.169]                   if (TRUE && !signal) {
[17:59:18.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.169]                     {
[17:59:18.169]                       inherits <- base::inherits
[17:59:18.169]                       invokeRestart <- base::invokeRestart
[17:59:18.169]                       is.null <- base::is.null
[17:59:18.169]                       muffled <- FALSE
[17:59:18.169]                       if (inherits(cond, "message")) {
[17:59:18.169]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.169]                         if (muffled) 
[17:59:18.169]                           invokeRestart("muffleMessage")
[17:59:18.169]                       }
[17:59:18.169]                       else if (inherits(cond, "warning")) {
[17:59:18.169]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.169]                         if (muffled) 
[17:59:18.169]                           invokeRestart("muffleWarning")
[17:59:18.169]                       }
[17:59:18.169]                       else if (inherits(cond, "condition")) {
[17:59:18.169]                         if (!is.null(pattern)) {
[17:59:18.169]                           computeRestarts <- base::computeRestarts
[17:59:18.169]                           grepl <- base::grepl
[17:59:18.169]                           restarts <- computeRestarts(cond)
[17:59:18.169]                           for (restart in restarts) {
[17:59:18.169]                             name <- restart$name
[17:59:18.169]                             if (is.null(name)) 
[17:59:18.169]                               next
[17:59:18.169]                             if (!grepl(pattern, name)) 
[17:59:18.169]                               next
[17:59:18.169]                             invokeRestart(restart)
[17:59:18.169]                             muffled <- TRUE
[17:59:18.169]                             break
[17:59:18.169]                           }
[17:59:18.169]                         }
[17:59:18.169]                       }
[17:59:18.169]                       invisible(muffled)
[17:59:18.169]                     }
[17:59:18.169]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.169]                   }
[17:59:18.169]                 }
[17:59:18.169]                 else {
[17:59:18.169]                   if (TRUE) {
[17:59:18.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.169]                     {
[17:59:18.169]                       inherits <- base::inherits
[17:59:18.169]                       invokeRestart <- base::invokeRestart
[17:59:18.169]                       is.null <- base::is.null
[17:59:18.169]                       muffled <- FALSE
[17:59:18.169]                       if (inherits(cond, "message")) {
[17:59:18.169]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.169]                         if (muffled) 
[17:59:18.169]                           invokeRestart("muffleMessage")
[17:59:18.169]                       }
[17:59:18.169]                       else if (inherits(cond, "warning")) {
[17:59:18.169]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.169]                         if (muffled) 
[17:59:18.169]                           invokeRestart("muffleWarning")
[17:59:18.169]                       }
[17:59:18.169]                       else if (inherits(cond, "condition")) {
[17:59:18.169]                         if (!is.null(pattern)) {
[17:59:18.169]                           computeRestarts <- base::computeRestarts
[17:59:18.169]                           grepl <- base::grepl
[17:59:18.169]                           restarts <- computeRestarts(cond)
[17:59:18.169]                           for (restart in restarts) {
[17:59:18.169]                             name <- restart$name
[17:59:18.169]                             if (is.null(name)) 
[17:59:18.169]                               next
[17:59:18.169]                             if (!grepl(pattern, name)) 
[17:59:18.169]                               next
[17:59:18.169]                             invokeRestart(restart)
[17:59:18.169]                             muffled <- TRUE
[17:59:18.169]                             break
[17:59:18.169]                           }
[17:59:18.169]                         }
[17:59:18.169]                       }
[17:59:18.169]                       invisible(muffled)
[17:59:18.169]                     }
[17:59:18.169]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.169]                   }
[17:59:18.169]                 }
[17:59:18.169]             }
[17:59:18.169]         }))
[17:59:18.169]     }, error = function(ex) {
[17:59:18.169]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:18.169]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.169]                 ...future.rng), started = ...future.startTime, 
[17:59:18.169]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:18.169]             version = "1.8"), class = "FutureResult")
[17:59:18.169]     }, finally = {
[17:59:18.169]         if (!identical(...future.workdir, getwd())) 
[17:59:18.169]             setwd(...future.workdir)
[17:59:18.169]         {
[17:59:18.169]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:18.169]                 ...future.oldOptions$nwarnings <- NULL
[17:59:18.169]             }
[17:59:18.169]             base::options(...future.oldOptions)
[17:59:18.169]             if (.Platform$OS.type == "windows") {
[17:59:18.169]                 old_names <- names(...future.oldEnvVars)
[17:59:18.169]                 envs <- base::Sys.getenv()
[17:59:18.169]                 names <- names(envs)
[17:59:18.169]                 common <- intersect(names, old_names)
[17:59:18.169]                 added <- setdiff(names, old_names)
[17:59:18.169]                 removed <- setdiff(old_names, names)
[17:59:18.169]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:18.169]                   envs[common]]
[17:59:18.169]                 NAMES <- toupper(changed)
[17:59:18.169]                 args <- list()
[17:59:18.169]                 for (kk in seq_along(NAMES)) {
[17:59:18.169]                   name <- changed[[kk]]
[17:59:18.169]                   NAME <- NAMES[[kk]]
[17:59:18.169]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.169]                     next
[17:59:18.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.169]                 }
[17:59:18.169]                 NAMES <- toupper(added)
[17:59:18.169]                 for (kk in seq_along(NAMES)) {
[17:59:18.169]                   name <- added[[kk]]
[17:59:18.169]                   NAME <- NAMES[[kk]]
[17:59:18.169]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.169]                     next
[17:59:18.169]                   args[[name]] <- ""
[17:59:18.169]                 }
[17:59:18.169]                 NAMES <- toupper(removed)
[17:59:18.169]                 for (kk in seq_along(NAMES)) {
[17:59:18.169]                   name <- removed[[kk]]
[17:59:18.169]                   NAME <- NAMES[[kk]]
[17:59:18.169]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.169]                     next
[17:59:18.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.169]                 }
[17:59:18.169]                 if (length(args) > 0) 
[17:59:18.169]                   base::do.call(base::Sys.setenv, args = args)
[17:59:18.169]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:18.169]             }
[17:59:18.169]             else {
[17:59:18.169]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:18.169]             }
[17:59:18.169]             {
[17:59:18.169]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:18.169]                   0L) {
[17:59:18.169]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:18.169]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:18.169]                   base::options(opts)
[17:59:18.169]                 }
[17:59:18.169]                 {
[17:59:18.169]                   {
[17:59:18.169]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:18.169]                     NULL
[17:59:18.169]                   }
[17:59:18.169]                   options(future.plan = NULL)
[17:59:18.169]                   if (is.na(NA_character_)) 
[17:59:18.169]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.169]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:18.169]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:18.169]                     .init = FALSE)
[17:59:18.169]                 }
[17:59:18.169]             }
[17:59:18.169]         }
[17:59:18.169]     })
[17:59:18.169]     if (TRUE) {
[17:59:18.169]         base::sink(type = "output", split = FALSE)
[17:59:18.169]         if (TRUE) {
[17:59:18.169]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:18.169]         }
[17:59:18.169]         else {
[17:59:18.169]             ...future.result["stdout"] <- base::list(NULL)
[17:59:18.169]         }
[17:59:18.169]         base::close(...future.stdout)
[17:59:18.169]         ...future.stdout <- NULL
[17:59:18.169]     }
[17:59:18.169]     ...future.result$conditions <- ...future.conditions
[17:59:18.169]     ...future.result$finished <- base::Sys.time()
[17:59:18.169]     ...future.result
[17:59:18.169] }
[17:59:18.176] assign_globals() ...
[17:59:18.176] List of 5
[17:59:18.176]  $ future.call.arguments    : list()
[17:59:18.176]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.176]  $ ...future.FUN            :function (x)  
[17:59:18.176]  $ ...future.elements_ii    :List of 1
[17:59:18.176]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[17:59:18.176]  $ ...future.seeds_ii       : NULL
[17:59:18.176]  $ ...future.globals.maxSize: num Inf
[17:59:18.176]  - attr(*, "resolved")= logi FALSE
[17:59:18.176]  - attr(*, "total_size")= num NA
[17:59:18.176]  - attr(*, "where")=List of 5
[17:59:18.176]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:18.176]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:18.176]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:18.176]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:18.176]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:18.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.176]  - attr(*, "already-done")= logi TRUE
[17:59:18.191] - copied ‘future.call.arguments’ to environment
[17:59:18.192] - copied ‘...future.FUN’ to environment
[17:59:18.192] - copied ‘...future.elements_ii’ to environment
[17:59:18.192] - copied ‘...future.seeds_ii’ to environment
[17:59:18.193] - copied ‘...future.globals.maxSize’ to environment
[17:59:18.193] assign_globals() ... done
[17:59:18.193] requestCore(): workers = 2
[17:59:18.197] MulticoreFuture started
[17:59:18.198] - Launch lazy future ... done
[17:59:18.198] run() for ‘MulticoreFuture’ ... done
[17:59:18.199] Created future:
[17:59:18.199] plan(): Setting new future strategy stack:
[17:59:18.200] List of future strategies:
[17:59:18.200] 1. sequential:
[17:59:18.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:18.200]    - tweaked: FALSE
[17:59:18.200]    - call: NULL
[17:59:18.202] plan(): nbrOfWorkers() = 1
[17:59:18.213] plan(): Setting new future strategy stack:
[17:59:18.214] List of future strategies:
[17:59:18.214] 1. multicore:
[17:59:18.214]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:18.214]    - tweaked: FALSE
[17:59:18.214]    - call: plan(strategy)
[17:59:18.199] MulticoreFuture:
[17:59:18.199] Label: ‘future_apply-2’
[17:59:18.199] Expression:
[17:59:18.199] {
[17:59:18.199]     do.call(function(...) {
[17:59:18.199]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.199]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.199]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.199]             on.exit(options(oopts), add = TRUE)
[17:59:18.199]         }
[17:59:18.199]         {
[17:59:18.199]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.199]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.199]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.199]             })
[17:59:18.199]         }
[17:59:18.199]     }, args = future.call.arguments)
[17:59:18.199] }
[17:59:18.199] Lazy evaluation: FALSE
[17:59:18.199] Asynchronous evaluation: TRUE
[17:59:18.199] Local evaluation: TRUE
[17:59:18.199] Environment: R_GlobalEnv
[17:59:18.199] Capture standard output: TRUE
[17:59:18.199] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:18.199] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:18.199] Packages: <none>
[17:59:18.199] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:18.199] Resolved: FALSE
[17:59:18.199] Value: <not collected>
[17:59:18.199] Conditions captured: <none>
[17:59:18.199] Early signaling: FALSE
[17:59:18.199] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:18.199] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.222] Chunk #2 of 2 ... DONE
[17:59:18.223] Launching 2 futures (chunks) ... DONE
[17:59:18.223] Resolving 2 futures (chunks) ...
[17:59:18.224] resolve() on list ...
[17:59:18.225]  recursive: 0
[17:59:18.225]  length: 2
[17:59:18.226] 
[17:59:18.227] plan(): nbrOfWorkers() = 2
[17:59:18.227] Future #1
[17:59:18.227] result() for MulticoreFuture ...
[17:59:18.231] result() for MulticoreFuture ...
[17:59:18.231] result() for MulticoreFuture ... done
[17:59:18.232] result() for MulticoreFuture ... done
[17:59:18.232] result() for MulticoreFuture ...
[17:59:18.233] result() for MulticoreFuture ... done
[17:59:18.233] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:18.234] - nx: 2
[17:59:18.234] - relay: TRUE
[17:59:18.234] - stdout: TRUE
[17:59:18.235] - signal: TRUE
[17:59:18.235] - resignal: FALSE
[17:59:18.236] - force: TRUE
[17:59:18.236] - relayed: [n=2] FALSE, FALSE
[17:59:18.236] - queued futures: [n=2] FALSE, FALSE
[17:59:18.236]  - until=1
[17:59:18.237]  - relaying element #1
[17:59:18.237] result() for MulticoreFuture ...
[17:59:18.237] result() for MulticoreFuture ... done
[17:59:18.238] result() for MulticoreFuture ...
[17:59:18.238] result() for MulticoreFuture ... done
[17:59:18.238] result() for MulticoreFuture ...
[17:59:18.239] result() for MulticoreFuture ... done
[17:59:18.239] result() for MulticoreFuture ...
[17:59:18.239] result() for MulticoreFuture ... done
[17:59:18.240] - relayed: [n=2] TRUE, FALSE
[17:59:18.240] - queued futures: [n=2] TRUE, FALSE
[17:59:18.241] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:18.241]  length: 1 (resolved future 1)
[17:59:18.242] Future #2
[17:59:18.242] result() for MulticoreFuture ...
[17:59:18.243] result() for MulticoreFuture ...
[17:59:18.244] result() for MulticoreFuture ... done
[17:59:18.244] result() for MulticoreFuture ... done
[17:59:18.244] result() for MulticoreFuture ...
[17:59:18.244] result() for MulticoreFuture ... done
[17:59:18.245] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:18.245] - nx: 2
[17:59:18.245] - relay: TRUE
[17:59:18.245] - stdout: TRUE
[17:59:18.246] - signal: TRUE
[17:59:18.246] - resignal: FALSE
[17:59:18.246] - force: TRUE
[17:59:18.246] - relayed: [n=2] TRUE, FALSE
[17:59:18.246] - queued futures: [n=2] TRUE, FALSE
[17:59:18.247]  - until=2
[17:59:18.247]  - relaying element #2
[17:59:18.247] result() for MulticoreFuture ...
[17:59:18.247] result() for MulticoreFuture ... done
[17:59:18.248] result() for MulticoreFuture ...
[17:59:18.248] result() for MulticoreFuture ... done
[17:59:18.248] result() for MulticoreFuture ...
[17:59:18.248] result() for MulticoreFuture ... done
[17:59:18.248] result() for MulticoreFuture ...
[17:59:18.249] result() for MulticoreFuture ... done
[17:59:18.249] - relayed: [n=2] TRUE, TRUE
[17:59:18.249] - queued futures: [n=2] TRUE, TRUE
[17:59:18.249] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:18.250]  length: 0 (resolved future 2)
[17:59:18.250] Relaying remaining futures
[17:59:18.250] signalConditionsASAP(NULL, pos=0) ...
[17:59:18.250] - nx: 2
[17:59:18.250] - relay: TRUE
[17:59:18.251] - stdout: TRUE
[17:59:18.251] - signal: TRUE
[17:59:18.251] - resignal: FALSE
[17:59:18.251] - force: TRUE
[17:59:18.251] - relayed: [n=2] TRUE, TRUE
[17:59:18.252] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:18.252] - relayed: [n=2] TRUE, TRUE
[17:59:18.252] - queued futures: [n=2] TRUE, TRUE
[17:59:18.252] signalConditionsASAP(NULL, pos=0) ... done
[17:59:18.253] resolve() on list ... DONE
[17:59:18.253] result() for MulticoreFuture ...
[17:59:18.253] result() for MulticoreFuture ... done
[17:59:18.253] result() for MulticoreFuture ...
[17:59:18.253] result() for MulticoreFuture ... done
[17:59:18.254] result() for MulticoreFuture ...
[17:59:18.254] result() for MulticoreFuture ... done
[17:59:18.254] result() for MulticoreFuture ...
[17:59:18.254] result() for MulticoreFuture ... done
[17:59:18.254]  - Number of value chunks collected: 2
[17:59:18.255] Resolving 2 futures (chunks) ... DONE
[17:59:18.255] Reducing values from 2 chunks ...
[17:59:18.255]  - Number of values collected after concatenation: 2
[17:59:18.255]  - Number of values expected: 2
[17:59:18.255] Reducing values from 2 chunks ... DONE
[17:59:18.256] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:59:18.256] getGlobalsAndPackagesXApply() ...
[17:59:18.257]  - future.globals: TRUE
[17:59:18.257] getGlobalsAndPackages() ...
[17:59:18.257] Searching for globals...
[17:59:18.263] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:59:18.263] Searching for globals ... DONE
[17:59:18.263] Resolving globals: FALSE
[17:59:18.265] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:59:18.265] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:59:18.266] - globals: [1] ‘FUN’
[17:59:18.266] 
[17:59:18.266] getGlobalsAndPackages() ... DONE
[17:59:18.266]  - globals found/used: [n=1] ‘FUN’
[17:59:18.267]  - needed namespaces: [n=0] 
[17:59:18.267] Finding globals ... DONE
[17:59:18.267]  - use_args: TRUE
[17:59:18.267]  - Getting '...' globals ...
[17:59:18.268] resolve() on list ...
[17:59:18.268]  recursive: 0
[17:59:18.268]  length: 1
[17:59:18.268]  elements: ‘...’
[17:59:18.269]  length: 0 (resolved future 1)
[17:59:18.269] resolve() on list ... DONE
[17:59:18.269]    - '...' content: [n=0] 
[17:59:18.269] List of 1
[17:59:18.269]  $ ...: list()
[17:59:18.269]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.269]  - attr(*, "where")=List of 1
[17:59:18.269]   ..$ ...:<environment: 0x5608598daaf8> 
[17:59:18.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.269]  - attr(*, "resolved")= logi TRUE
[17:59:18.269]  - attr(*, "total_size")= num NA
[17:59:18.275]  - Getting '...' globals ... DONE
[17:59:18.275] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:18.275] List of 2
[17:59:18.275]  $ ...future.FUN:function (x)  
[17:59:18.275]  $ ...          : list()
[17:59:18.275]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.275]  - attr(*, "where")=List of 2
[17:59:18.275]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:18.275]   ..$ ...          :<environment: 0x5608598daaf8> 
[17:59:18.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.275]  - attr(*, "resolved")= logi FALSE
[17:59:18.275]  - attr(*, "total_size")= num 9888
[17:59:18.284] Packages to be attached in all futures: [n=0] 
[17:59:18.284] getGlobalsAndPackagesXApply() ... DONE
[17:59:18.291] future_lapply() ...
[17:59:18.300] Number of chunks: 2
[17:59:18.300] getGlobalsAndPackagesXApply() ...
[17:59:18.300]  - future.globals: <name-value list> with names ‘list()’
[17:59:18.301]  - use_args: TRUE
[17:59:18.301] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:18.301] List of 2
[17:59:18.301]  $ ...          : list()
[17:59:18.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.301]  $ ...future.FUN:function (x)  
[17:59:18.301]  - attr(*, "where")=List of 2
[17:59:18.301]   ..$ ...          :<environment: 0x5608598daaf8> 
[17:59:18.301]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:59:18.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.301]  - attr(*, "resolved")= logi FALSE
[17:59:18.301]  - attr(*, "total_size")= num NA
[17:59:18.307] Packages to be attached in all futures: [n=0] 
[17:59:18.307] getGlobalsAndPackagesXApply() ... DONE
[17:59:18.307] Number of futures (= number of chunks): 2
[17:59:18.308] Launching 2 futures (chunks) ...
[17:59:18.308] Chunk #1 of 2 ...
[17:59:18.308]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:18.308]  - seeds: <none>
[17:59:18.309]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.309] getGlobalsAndPackages() ...
[17:59:18.309] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.309] Resolving globals: FALSE
[17:59:18.309] Tweak future expression to call with '...' arguments ...
[17:59:18.310] {
[17:59:18.310]     do.call(function(...) {
[17:59:18.310]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.310]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.310]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.310]             on.exit(options(oopts), add = TRUE)
[17:59:18.310]         }
[17:59:18.310]         {
[17:59:18.310]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.310]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.310]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.310]             })
[17:59:18.310]         }
[17:59:18.310]     }, args = future.call.arguments)
[17:59:18.310] }
[17:59:18.310] Tweak future expression to call with '...' arguments ... DONE
[17:59:18.311] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.311] 
[17:59:18.311] getGlobalsAndPackages() ... DONE
[17:59:18.312] run() for ‘Future’ ...
[17:59:18.312] - state: ‘created’
[17:59:18.313] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:18.319] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.319] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:18.320]   - Field: ‘label’
[17:59:18.320]   - Field: ‘local’
[17:59:18.320]   - Field: ‘owner’
[17:59:18.320]   - Field: ‘envir’
[17:59:18.320]   - Field: ‘workers’
[17:59:18.321]   - Field: ‘packages’
[17:59:18.321]   - Field: ‘gc’
[17:59:18.321]   - Field: ‘job’
[17:59:18.321]   - Field: ‘conditions’
[17:59:18.321]   - Field: ‘expr’
[17:59:18.322]   - Field: ‘uuid’
[17:59:18.322]   - Field: ‘seed’
[17:59:18.322]   - Field: ‘version’
[17:59:18.322]   - Field: ‘result’
[17:59:18.322]   - Field: ‘asynchronous’
[17:59:18.323]   - Field: ‘calls’
[17:59:18.323]   - Field: ‘globals’
[17:59:18.323]   - Field: ‘stdout’
[17:59:18.323]   - Field: ‘earlySignal’
[17:59:18.324]   - Field: ‘lazy’
[17:59:18.324]   - Field: ‘state’
[17:59:18.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:18.324] - Launch lazy future ...
[17:59:18.325] Packages needed by the future expression (n = 0): <none>
[17:59:18.325] Packages needed by future strategies (n = 0): <none>
[17:59:18.326] {
[17:59:18.326]     {
[17:59:18.326]         {
[17:59:18.326]             ...future.startTime <- base::Sys.time()
[17:59:18.326]             {
[17:59:18.326]                 {
[17:59:18.326]                   {
[17:59:18.326]                     {
[17:59:18.326]                       base::local({
[17:59:18.326]                         has_future <- base::requireNamespace("future", 
[17:59:18.326]                           quietly = TRUE)
[17:59:18.326]                         if (has_future) {
[17:59:18.326]                           ns <- base::getNamespace("future")
[17:59:18.326]                           version <- ns[[".package"]][["version"]]
[17:59:18.326]                           if (is.null(version)) 
[17:59:18.326]                             version <- utils::packageVersion("future")
[17:59:18.326]                         }
[17:59:18.326]                         else {
[17:59:18.326]                           version <- NULL
[17:59:18.326]                         }
[17:59:18.326]                         if (!has_future || version < "1.8.0") {
[17:59:18.326]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:18.326]                             "", base::R.version$version.string), 
[17:59:18.326]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:18.326]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:18.326]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:18.326]                               "release", "version")], collapse = " "), 
[17:59:18.326]                             hostname = base::Sys.info()[["nodename"]])
[17:59:18.326]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:18.326]                             info)
[17:59:18.326]                           info <- base::paste(info, collapse = "; ")
[17:59:18.326]                           if (!has_future) {
[17:59:18.326]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:18.326]                               info)
[17:59:18.326]                           }
[17:59:18.326]                           else {
[17:59:18.326]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:18.326]                               info, version)
[17:59:18.326]                           }
[17:59:18.326]                           base::stop(msg)
[17:59:18.326]                         }
[17:59:18.326]                       })
[17:59:18.326]                     }
[17:59:18.326]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:18.326]                     base::options(mc.cores = 1L)
[17:59:18.326]                   }
[17:59:18.326]                   ...future.strategy.old <- future::plan("list")
[17:59:18.326]                   options(future.plan = NULL)
[17:59:18.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:18.326]                 }
[17:59:18.326]                 ...future.workdir <- getwd()
[17:59:18.326]             }
[17:59:18.326]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:18.326]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:18.326]         }
[17:59:18.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:18.326]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:18.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:18.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:18.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:18.326]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:18.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:18.326]             base::names(...future.oldOptions))
[17:59:18.326]     }
[17:59:18.326]     if (FALSE) {
[17:59:18.326]     }
[17:59:18.326]     else {
[17:59:18.326]         if (TRUE) {
[17:59:18.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:18.326]                 open = "w")
[17:59:18.326]         }
[17:59:18.326]         else {
[17:59:18.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:18.326]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:18.326]         }
[17:59:18.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:18.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:18.326]             base::sink(type = "output", split = FALSE)
[17:59:18.326]             base::close(...future.stdout)
[17:59:18.326]         }, add = TRUE)
[17:59:18.326]     }
[17:59:18.326]     ...future.frame <- base::sys.nframe()
[17:59:18.326]     ...future.conditions <- base::list()
[17:59:18.326]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:18.326]     if (FALSE) {
[17:59:18.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:18.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:18.326]     }
[17:59:18.326]     ...future.result <- base::tryCatch({
[17:59:18.326]         base::withCallingHandlers({
[17:59:18.326]             ...future.value <- base::withVisible(base::local({
[17:59:18.326]                 withCallingHandlers({
[17:59:18.326]                   {
[17:59:18.326]                     do.call(function(...) {
[17:59:18.326]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.326]                       if (!identical(...future.globals.maxSize.org, 
[17:59:18.326]                         ...future.globals.maxSize)) {
[17:59:18.326]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.326]                         on.exit(options(oopts), add = TRUE)
[17:59:18.326]                       }
[17:59:18.326]                       {
[17:59:18.326]                         lapply(seq_along(...future.elements_ii), 
[17:59:18.326]                           FUN = function(jj) {
[17:59:18.326]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.326]                             ...future.FUN(...future.X_jj, ...)
[17:59:18.326]                           })
[17:59:18.326]                       }
[17:59:18.326]                     }, args = future.call.arguments)
[17:59:18.326]                   }
[17:59:18.326]                 }, immediateCondition = function(cond) {
[17:59:18.326]                   save_rds <- function (object, pathname, ...) 
[17:59:18.326]                   {
[17:59:18.326]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:18.326]                     if (file_test("-f", pathname_tmp)) {
[17:59:18.326]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.326]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:18.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.326]                         fi_tmp[["mtime"]])
[17:59:18.326]                     }
[17:59:18.326]                     tryCatch({
[17:59:18.326]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:18.326]                     }, error = function(ex) {
[17:59:18.326]                       msg <- conditionMessage(ex)
[17:59:18.326]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.326]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:18.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.326]                         fi_tmp[["mtime"]], msg)
[17:59:18.326]                       ex$message <- msg
[17:59:18.326]                       stop(ex)
[17:59:18.326]                     })
[17:59:18.326]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:18.326]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:18.326]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:18.326]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.326]                       fi <- file.info(pathname)
[17:59:18.326]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:18.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.326]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:18.326]                         fi[["size"]], fi[["mtime"]])
[17:59:18.326]                       stop(msg)
[17:59:18.326]                     }
[17:59:18.326]                     invisible(pathname)
[17:59:18.326]                   }
[17:59:18.326]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:18.326]                     rootPath = tempdir()) 
[17:59:18.326]                   {
[17:59:18.326]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:18.326]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:18.326]                       tmpdir = path, fileext = ".rds")
[17:59:18.326]                     save_rds(obj, file)
[17:59:18.326]                   }
[17:59:18.326]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:18.326]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.326]                   {
[17:59:18.326]                     inherits <- base::inherits
[17:59:18.326]                     invokeRestart <- base::invokeRestart
[17:59:18.326]                     is.null <- base::is.null
[17:59:18.326]                     muffled <- FALSE
[17:59:18.326]                     if (inherits(cond, "message")) {
[17:59:18.326]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:18.326]                       if (muffled) 
[17:59:18.326]                         invokeRestart("muffleMessage")
[17:59:18.326]                     }
[17:59:18.326]                     else if (inherits(cond, "warning")) {
[17:59:18.326]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:18.326]                       if (muffled) 
[17:59:18.326]                         invokeRestart("muffleWarning")
[17:59:18.326]                     }
[17:59:18.326]                     else if (inherits(cond, "condition")) {
[17:59:18.326]                       if (!is.null(pattern)) {
[17:59:18.326]                         computeRestarts <- base::computeRestarts
[17:59:18.326]                         grepl <- base::grepl
[17:59:18.326]                         restarts <- computeRestarts(cond)
[17:59:18.326]                         for (restart in restarts) {
[17:59:18.326]                           name <- restart$name
[17:59:18.326]                           if (is.null(name)) 
[17:59:18.326]                             next
[17:59:18.326]                           if (!grepl(pattern, name)) 
[17:59:18.326]                             next
[17:59:18.326]                           invokeRestart(restart)
[17:59:18.326]                           muffled <- TRUE
[17:59:18.326]                           break
[17:59:18.326]                         }
[17:59:18.326]                       }
[17:59:18.326]                     }
[17:59:18.326]                     invisible(muffled)
[17:59:18.326]                   }
[17:59:18.326]                   muffleCondition(cond)
[17:59:18.326]                 })
[17:59:18.326]             }))
[17:59:18.326]             future::FutureResult(value = ...future.value$value, 
[17:59:18.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.326]                   ...future.rng), globalenv = if (FALSE) 
[17:59:18.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:18.326]                     ...future.globalenv.names))
[17:59:18.326]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:18.326]         }, condition = base::local({
[17:59:18.326]             c <- base::c
[17:59:18.326]             inherits <- base::inherits
[17:59:18.326]             invokeRestart <- base::invokeRestart
[17:59:18.326]             length <- base::length
[17:59:18.326]             list <- base::list
[17:59:18.326]             seq.int <- base::seq.int
[17:59:18.326]             signalCondition <- base::signalCondition
[17:59:18.326]             sys.calls <- base::sys.calls
[17:59:18.326]             `[[` <- base::`[[`
[17:59:18.326]             `+` <- base::`+`
[17:59:18.326]             `<<-` <- base::`<<-`
[17:59:18.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:18.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:18.326]                   3L)]
[17:59:18.326]             }
[17:59:18.326]             function(cond) {
[17:59:18.326]                 is_error <- inherits(cond, "error")
[17:59:18.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:18.326]                   NULL)
[17:59:18.326]                 if (is_error) {
[17:59:18.326]                   sessionInformation <- function() {
[17:59:18.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:18.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:18.326]                       search = base::search(), system = base::Sys.info())
[17:59:18.326]                   }
[17:59:18.326]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:18.326]                     cond$call), session = sessionInformation(), 
[17:59:18.326]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:18.326]                   signalCondition(cond)
[17:59:18.326]                 }
[17:59:18.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:18.326]                 "immediateCondition"))) {
[17:59:18.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:18.326]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:18.326]                   if (TRUE && !signal) {
[17:59:18.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.326]                     {
[17:59:18.326]                       inherits <- base::inherits
[17:59:18.326]                       invokeRestart <- base::invokeRestart
[17:59:18.326]                       is.null <- base::is.null
[17:59:18.326]                       muffled <- FALSE
[17:59:18.326]                       if (inherits(cond, "message")) {
[17:59:18.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.326]                         if (muffled) 
[17:59:18.326]                           invokeRestart("muffleMessage")
[17:59:18.326]                       }
[17:59:18.326]                       else if (inherits(cond, "warning")) {
[17:59:18.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.326]                         if (muffled) 
[17:59:18.326]                           invokeRestart("muffleWarning")
[17:59:18.326]                       }
[17:59:18.326]                       else if (inherits(cond, "condition")) {
[17:59:18.326]                         if (!is.null(pattern)) {
[17:59:18.326]                           computeRestarts <- base::computeRestarts
[17:59:18.326]                           grepl <- base::grepl
[17:59:18.326]                           restarts <- computeRestarts(cond)
[17:59:18.326]                           for (restart in restarts) {
[17:59:18.326]                             name <- restart$name
[17:59:18.326]                             if (is.null(name)) 
[17:59:18.326]                               next
[17:59:18.326]                             if (!grepl(pattern, name)) 
[17:59:18.326]                               next
[17:59:18.326]                             invokeRestart(restart)
[17:59:18.326]                             muffled <- TRUE
[17:59:18.326]                             break
[17:59:18.326]                           }
[17:59:18.326]                         }
[17:59:18.326]                       }
[17:59:18.326]                       invisible(muffled)
[17:59:18.326]                     }
[17:59:18.326]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.326]                   }
[17:59:18.326]                 }
[17:59:18.326]                 else {
[17:59:18.326]                   if (TRUE) {
[17:59:18.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.326]                     {
[17:59:18.326]                       inherits <- base::inherits
[17:59:18.326]                       invokeRestart <- base::invokeRestart
[17:59:18.326]                       is.null <- base::is.null
[17:59:18.326]                       muffled <- FALSE
[17:59:18.326]                       if (inherits(cond, "message")) {
[17:59:18.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.326]                         if (muffled) 
[17:59:18.326]                           invokeRestart("muffleMessage")
[17:59:18.326]                       }
[17:59:18.326]                       else if (inherits(cond, "warning")) {
[17:59:18.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.326]                         if (muffled) 
[17:59:18.326]                           invokeRestart("muffleWarning")
[17:59:18.326]                       }
[17:59:18.326]                       else if (inherits(cond, "condition")) {
[17:59:18.326]                         if (!is.null(pattern)) {
[17:59:18.326]                           computeRestarts <- base::computeRestarts
[17:59:18.326]                           grepl <- base::grepl
[17:59:18.326]                           restarts <- computeRestarts(cond)
[17:59:18.326]                           for (restart in restarts) {
[17:59:18.326]                             name <- restart$name
[17:59:18.326]                             if (is.null(name)) 
[17:59:18.326]                               next
[17:59:18.326]                             if (!grepl(pattern, name)) 
[17:59:18.326]                               next
[17:59:18.326]                             invokeRestart(restart)
[17:59:18.326]                             muffled <- TRUE
[17:59:18.326]                             break
[17:59:18.326]                           }
[17:59:18.326]                         }
[17:59:18.326]                       }
[17:59:18.326]                       invisible(muffled)
[17:59:18.326]                     }
[17:59:18.326]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.326]                   }
[17:59:18.326]                 }
[17:59:18.326]             }
[17:59:18.326]         }))
[17:59:18.326]     }, error = function(ex) {
[17:59:18.326]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:18.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.326]                 ...future.rng), started = ...future.startTime, 
[17:59:18.326]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:18.326]             version = "1.8"), class = "FutureResult")
[17:59:18.326]     }, finally = {
[17:59:18.326]         if (!identical(...future.workdir, getwd())) 
[17:59:18.326]             setwd(...future.workdir)
[17:59:18.326]         {
[17:59:18.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:18.326]                 ...future.oldOptions$nwarnings <- NULL
[17:59:18.326]             }
[17:59:18.326]             base::options(...future.oldOptions)
[17:59:18.326]             if (.Platform$OS.type == "windows") {
[17:59:18.326]                 old_names <- names(...future.oldEnvVars)
[17:59:18.326]                 envs <- base::Sys.getenv()
[17:59:18.326]                 names <- names(envs)
[17:59:18.326]                 common <- intersect(names, old_names)
[17:59:18.326]                 added <- setdiff(names, old_names)
[17:59:18.326]                 removed <- setdiff(old_names, names)
[17:59:18.326]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:18.326]                   envs[common]]
[17:59:18.326]                 NAMES <- toupper(changed)
[17:59:18.326]                 args <- list()
[17:59:18.326]                 for (kk in seq_along(NAMES)) {
[17:59:18.326]                   name <- changed[[kk]]
[17:59:18.326]                   NAME <- NAMES[[kk]]
[17:59:18.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.326]                     next
[17:59:18.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.326]                 }
[17:59:18.326]                 NAMES <- toupper(added)
[17:59:18.326]                 for (kk in seq_along(NAMES)) {
[17:59:18.326]                   name <- added[[kk]]
[17:59:18.326]                   NAME <- NAMES[[kk]]
[17:59:18.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.326]                     next
[17:59:18.326]                   args[[name]] <- ""
[17:59:18.326]                 }
[17:59:18.326]                 NAMES <- toupper(removed)
[17:59:18.326]                 for (kk in seq_along(NAMES)) {
[17:59:18.326]                   name <- removed[[kk]]
[17:59:18.326]                   NAME <- NAMES[[kk]]
[17:59:18.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.326]                     next
[17:59:18.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.326]                 }
[17:59:18.326]                 if (length(args) > 0) 
[17:59:18.326]                   base::do.call(base::Sys.setenv, args = args)
[17:59:18.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:18.326]             }
[17:59:18.326]             else {
[17:59:18.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:18.326]             }
[17:59:18.326]             {
[17:59:18.326]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:18.326]                   0L) {
[17:59:18.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:18.326]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:18.326]                   base::options(opts)
[17:59:18.326]                 }
[17:59:18.326]                 {
[17:59:18.326]                   {
[17:59:18.326]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:18.326]                     NULL
[17:59:18.326]                   }
[17:59:18.326]                   options(future.plan = NULL)
[17:59:18.326]                   if (is.na(NA_character_)) 
[17:59:18.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:18.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:18.326]                     .init = FALSE)
[17:59:18.326]                 }
[17:59:18.326]             }
[17:59:18.326]         }
[17:59:18.326]     })
[17:59:18.326]     if (TRUE) {
[17:59:18.326]         base::sink(type = "output", split = FALSE)
[17:59:18.326]         if (TRUE) {
[17:59:18.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:18.326]         }
[17:59:18.326]         else {
[17:59:18.326]             ...future.result["stdout"] <- base::list(NULL)
[17:59:18.326]         }
[17:59:18.326]         base::close(...future.stdout)
[17:59:18.326]         ...future.stdout <- NULL
[17:59:18.326]     }
[17:59:18.326]     ...future.result$conditions <- ...future.conditions
[17:59:18.326]     ...future.result$finished <- base::Sys.time()
[17:59:18.326]     ...future.result
[17:59:18.326] }
[17:59:18.330] assign_globals() ...
[17:59:18.330] List of 5
[17:59:18.330]  $ future.call.arguments    : list()
[17:59:18.330]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.330]  $ ...future.FUN            :function (x)  
[17:59:18.330]  $ ...future.elements_ii    :List of 1
[17:59:18.330]   ..$ : int [1:2] 1 3
[17:59:18.330]  $ ...future.seeds_ii       : NULL
[17:59:18.330]  $ ...future.globals.maxSize: num Inf
[17:59:18.330]  - attr(*, "resolved")= logi FALSE
[17:59:18.330]  - attr(*, "total_size")= num NA
[17:59:18.330]  - attr(*, "where")=List of 5
[17:59:18.330]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:18.330]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:18.330]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:18.330]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:18.330]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:18.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.330]  - attr(*, "already-done")= logi TRUE
[17:59:18.344] - copied ‘future.call.arguments’ to environment
[17:59:18.344] - reassign environment for ‘...future.FUN’
[17:59:18.344] - copied ‘...future.FUN’ to environment
[17:59:18.344] - copied ‘...future.elements_ii’ to environment
[17:59:18.345] - copied ‘...future.seeds_ii’ to environment
[17:59:18.345] - copied ‘...future.globals.maxSize’ to environment
[17:59:18.345] assign_globals() ... done
[17:59:18.346] requestCore(): workers = 2
[17:59:18.349] MulticoreFuture started
[17:59:18.350] - Launch lazy future ... done
[17:59:18.351] run() for ‘MulticoreFuture’ ... done
[17:59:18.351] plan(): Setting new future strategy stack:
[17:59:18.352] Created future:
[17:59:18.352] List of future strategies:
[17:59:18.352] 1. sequential:
[17:59:18.352]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:18.352]    - tweaked: FALSE
[17:59:18.352]    - call: NULL
[17:59:18.354] plan(): nbrOfWorkers() = 1
[17:59:18.359] plan(): Setting new future strategy stack:
[17:59:18.360] List of future strategies:
[17:59:18.360] 1. multicore:
[17:59:18.360]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:18.360]    - tweaked: FALSE
[17:59:18.360]    - call: plan(strategy)
[17:59:18.352] MulticoreFuture:
[17:59:18.352] Label: ‘future_apply-1’
[17:59:18.352] Expression:
[17:59:18.352] {
[17:59:18.352]     do.call(function(...) {
[17:59:18.352]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.352]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.352]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.352]             on.exit(options(oopts), add = TRUE)
[17:59:18.352]         }
[17:59:18.352]         {
[17:59:18.352]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.352]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.352]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.352]             })
[17:59:18.352]         }
[17:59:18.352]     }, args = future.call.arguments)
[17:59:18.352] }
[17:59:18.352] Lazy evaluation: FALSE
[17:59:18.352] Asynchronous evaluation: TRUE
[17:59:18.352] Local evaluation: TRUE
[17:59:18.352] Environment: R_GlobalEnv
[17:59:18.352] Capture standard output: TRUE
[17:59:18.352] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:18.352] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:18.352] Packages: <none>
[17:59:18.352] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:18.352] Resolved: FALSE
[17:59:18.352] Value: <not collected>
[17:59:18.352] Conditions captured: <none>
[17:59:18.352] Early signaling: FALSE
[17:59:18.352] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:18.352] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.369] Chunk #1 of 2 ... DONE
[17:59:18.371] Chunk #2 of 2 ...
[17:59:18.372]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:18.372]  - seeds: <none>
[17:59:18.372]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.374] getGlobalsAndPackages() ...
[17:59:18.375] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.375] plan(): nbrOfWorkers() = 2
[17:59:18.378] Resolving globals: FALSE
[17:59:18.379] Tweak future expression to call with '...' arguments ...
[17:59:18.379] {
[17:59:18.379]     do.call(function(...) {
[17:59:18.379]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.379]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.379]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.379]             on.exit(options(oopts), add = TRUE)
[17:59:18.379]         }
[17:59:18.379]         {
[17:59:18.379]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.379]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.379]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.379]             })
[17:59:18.379]         }
[17:59:18.379]     }, args = future.call.arguments)
[17:59:18.379] }
[17:59:18.380] Tweak future expression to call with '...' arguments ... DONE
[17:59:18.381] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.382] 
[17:59:18.382] getGlobalsAndPackages() ... DONE
[17:59:18.383] run() for ‘Future’ ...
[17:59:18.384] - state: ‘created’
[17:59:18.384] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:18.393] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:18.393]   - Field: ‘label’
[17:59:18.394]   - Field: ‘local’
[17:59:18.394]   - Field: ‘owner’
[17:59:18.394]   - Field: ‘envir’
[17:59:18.395]   - Field: ‘workers’
[17:59:18.395]   - Field: ‘packages’
[17:59:18.396]   - Field: ‘gc’
[17:59:18.396]   - Field: ‘job’
[17:59:18.396]   - Field: ‘conditions’
[17:59:18.397]   - Field: ‘expr’
[17:59:18.397]   - Field: ‘uuid’
[17:59:18.397]   - Field: ‘seed’
[17:59:18.397]   - Field: ‘version’
[17:59:18.398]   - Field: ‘result’
[17:59:18.398]   - Field: ‘asynchronous’
[17:59:18.398]   - Field: ‘calls’
[17:59:18.399]   - Field: ‘globals’
[17:59:18.399]   - Field: ‘stdout’
[17:59:18.399]   - Field: ‘earlySignal’
[17:59:18.400]   - Field: ‘lazy’
[17:59:18.400]   - Field: ‘state’
[17:59:18.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:18.401] - Launch lazy future ...
[17:59:18.402] Packages needed by the future expression (n = 0): <none>
[17:59:18.402] Packages needed by future strategies (n = 0): <none>
[17:59:18.404] {
[17:59:18.404]     {
[17:59:18.404]         {
[17:59:18.404]             ...future.startTime <- base::Sys.time()
[17:59:18.404]             {
[17:59:18.404]                 {
[17:59:18.404]                   {
[17:59:18.404]                     {
[17:59:18.404]                       base::local({
[17:59:18.404]                         has_future <- base::requireNamespace("future", 
[17:59:18.404]                           quietly = TRUE)
[17:59:18.404]                         if (has_future) {
[17:59:18.404]                           ns <- base::getNamespace("future")
[17:59:18.404]                           version <- ns[[".package"]][["version"]]
[17:59:18.404]                           if (is.null(version)) 
[17:59:18.404]                             version <- utils::packageVersion("future")
[17:59:18.404]                         }
[17:59:18.404]                         else {
[17:59:18.404]                           version <- NULL
[17:59:18.404]                         }
[17:59:18.404]                         if (!has_future || version < "1.8.0") {
[17:59:18.404]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:18.404]                             "", base::R.version$version.string), 
[17:59:18.404]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:18.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:18.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:18.404]                               "release", "version")], collapse = " "), 
[17:59:18.404]                             hostname = base::Sys.info()[["nodename"]])
[17:59:18.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:18.404]                             info)
[17:59:18.404]                           info <- base::paste(info, collapse = "; ")
[17:59:18.404]                           if (!has_future) {
[17:59:18.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:18.404]                               info)
[17:59:18.404]                           }
[17:59:18.404]                           else {
[17:59:18.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:18.404]                               info, version)
[17:59:18.404]                           }
[17:59:18.404]                           base::stop(msg)
[17:59:18.404]                         }
[17:59:18.404]                       })
[17:59:18.404]                     }
[17:59:18.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:18.404]                     base::options(mc.cores = 1L)
[17:59:18.404]                   }
[17:59:18.404]                   ...future.strategy.old <- future::plan("list")
[17:59:18.404]                   options(future.plan = NULL)
[17:59:18.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:18.404]                 }
[17:59:18.404]                 ...future.workdir <- getwd()
[17:59:18.404]             }
[17:59:18.404]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:18.404]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:18.404]         }
[17:59:18.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:18.404]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:18.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:18.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:18.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:18.404]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:18.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:18.404]             base::names(...future.oldOptions))
[17:59:18.404]     }
[17:59:18.404]     if (FALSE) {
[17:59:18.404]     }
[17:59:18.404]     else {
[17:59:18.404]         if (TRUE) {
[17:59:18.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:18.404]                 open = "w")
[17:59:18.404]         }
[17:59:18.404]         else {
[17:59:18.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:18.404]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:18.404]         }
[17:59:18.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:18.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:18.404]             base::sink(type = "output", split = FALSE)
[17:59:18.404]             base::close(...future.stdout)
[17:59:18.404]         }, add = TRUE)
[17:59:18.404]     }
[17:59:18.404]     ...future.frame <- base::sys.nframe()
[17:59:18.404]     ...future.conditions <- base::list()
[17:59:18.404]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:18.404]     if (FALSE) {
[17:59:18.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:18.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:18.404]     }
[17:59:18.404]     ...future.result <- base::tryCatch({
[17:59:18.404]         base::withCallingHandlers({
[17:59:18.404]             ...future.value <- base::withVisible(base::local({
[17:59:18.404]                 withCallingHandlers({
[17:59:18.404]                   {
[17:59:18.404]                     do.call(function(...) {
[17:59:18.404]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.404]                       if (!identical(...future.globals.maxSize.org, 
[17:59:18.404]                         ...future.globals.maxSize)) {
[17:59:18.404]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.404]                         on.exit(options(oopts), add = TRUE)
[17:59:18.404]                       }
[17:59:18.404]                       {
[17:59:18.404]                         lapply(seq_along(...future.elements_ii), 
[17:59:18.404]                           FUN = function(jj) {
[17:59:18.404]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.404]                             ...future.FUN(...future.X_jj, ...)
[17:59:18.404]                           })
[17:59:18.404]                       }
[17:59:18.404]                     }, args = future.call.arguments)
[17:59:18.404]                   }
[17:59:18.404]                 }, immediateCondition = function(cond) {
[17:59:18.404]                   save_rds <- function (object, pathname, ...) 
[17:59:18.404]                   {
[17:59:18.404]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:18.404]                     if (file_test("-f", pathname_tmp)) {
[17:59:18.404]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.404]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:18.404]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.404]                         fi_tmp[["mtime"]])
[17:59:18.404]                     }
[17:59:18.404]                     tryCatch({
[17:59:18.404]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:18.404]                     }, error = function(ex) {
[17:59:18.404]                       msg <- conditionMessage(ex)
[17:59:18.404]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.404]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:18.404]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.404]                         fi_tmp[["mtime"]], msg)
[17:59:18.404]                       ex$message <- msg
[17:59:18.404]                       stop(ex)
[17:59:18.404]                     })
[17:59:18.404]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:18.404]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:18.404]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:18.404]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.404]                       fi <- file.info(pathname)
[17:59:18.404]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:18.404]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.404]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:18.404]                         fi[["size"]], fi[["mtime"]])
[17:59:18.404]                       stop(msg)
[17:59:18.404]                     }
[17:59:18.404]                     invisible(pathname)
[17:59:18.404]                   }
[17:59:18.404]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:18.404]                     rootPath = tempdir()) 
[17:59:18.404]                   {
[17:59:18.404]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:18.404]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:18.404]                       tmpdir = path, fileext = ".rds")
[17:59:18.404]                     save_rds(obj, file)
[17:59:18.404]                   }
[17:59:18.404]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:18.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.404]                   {
[17:59:18.404]                     inherits <- base::inherits
[17:59:18.404]                     invokeRestart <- base::invokeRestart
[17:59:18.404]                     is.null <- base::is.null
[17:59:18.404]                     muffled <- FALSE
[17:59:18.404]                     if (inherits(cond, "message")) {
[17:59:18.404]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:18.404]                       if (muffled) 
[17:59:18.404]                         invokeRestart("muffleMessage")
[17:59:18.404]                     }
[17:59:18.404]                     else if (inherits(cond, "warning")) {
[17:59:18.404]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:18.404]                       if (muffled) 
[17:59:18.404]                         invokeRestart("muffleWarning")
[17:59:18.404]                     }
[17:59:18.404]                     else if (inherits(cond, "condition")) {
[17:59:18.404]                       if (!is.null(pattern)) {
[17:59:18.404]                         computeRestarts <- base::computeRestarts
[17:59:18.404]                         grepl <- base::grepl
[17:59:18.404]                         restarts <- computeRestarts(cond)
[17:59:18.404]                         for (restart in restarts) {
[17:59:18.404]                           name <- restart$name
[17:59:18.404]                           if (is.null(name)) 
[17:59:18.404]                             next
[17:59:18.404]                           if (!grepl(pattern, name)) 
[17:59:18.404]                             next
[17:59:18.404]                           invokeRestart(restart)
[17:59:18.404]                           muffled <- TRUE
[17:59:18.404]                           break
[17:59:18.404]                         }
[17:59:18.404]                       }
[17:59:18.404]                     }
[17:59:18.404]                     invisible(muffled)
[17:59:18.404]                   }
[17:59:18.404]                   muffleCondition(cond)
[17:59:18.404]                 })
[17:59:18.404]             }))
[17:59:18.404]             future::FutureResult(value = ...future.value$value, 
[17:59:18.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.404]                   ...future.rng), globalenv = if (FALSE) 
[17:59:18.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:18.404]                     ...future.globalenv.names))
[17:59:18.404]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:18.404]         }, condition = base::local({
[17:59:18.404]             c <- base::c
[17:59:18.404]             inherits <- base::inherits
[17:59:18.404]             invokeRestart <- base::invokeRestart
[17:59:18.404]             length <- base::length
[17:59:18.404]             list <- base::list
[17:59:18.404]             seq.int <- base::seq.int
[17:59:18.404]             signalCondition <- base::signalCondition
[17:59:18.404]             sys.calls <- base::sys.calls
[17:59:18.404]             `[[` <- base::`[[`
[17:59:18.404]             `+` <- base::`+`
[17:59:18.404]             `<<-` <- base::`<<-`
[17:59:18.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:18.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:18.404]                   3L)]
[17:59:18.404]             }
[17:59:18.404]             function(cond) {
[17:59:18.404]                 is_error <- inherits(cond, "error")
[17:59:18.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:18.404]                   NULL)
[17:59:18.404]                 if (is_error) {
[17:59:18.404]                   sessionInformation <- function() {
[17:59:18.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:18.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:18.404]                       search = base::search(), system = base::Sys.info())
[17:59:18.404]                   }
[17:59:18.404]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:18.404]                     cond$call), session = sessionInformation(), 
[17:59:18.404]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:18.404]                   signalCondition(cond)
[17:59:18.404]                 }
[17:59:18.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:18.404]                 "immediateCondition"))) {
[17:59:18.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:18.404]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:18.404]                   if (TRUE && !signal) {
[17:59:18.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.404]                     {
[17:59:18.404]                       inherits <- base::inherits
[17:59:18.404]                       invokeRestart <- base::invokeRestart
[17:59:18.404]                       is.null <- base::is.null
[17:59:18.404]                       muffled <- FALSE
[17:59:18.404]                       if (inherits(cond, "message")) {
[17:59:18.404]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.404]                         if (muffled) 
[17:59:18.404]                           invokeRestart("muffleMessage")
[17:59:18.404]                       }
[17:59:18.404]                       else if (inherits(cond, "warning")) {
[17:59:18.404]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.404]                         if (muffled) 
[17:59:18.404]                           invokeRestart("muffleWarning")
[17:59:18.404]                       }
[17:59:18.404]                       else if (inherits(cond, "condition")) {
[17:59:18.404]                         if (!is.null(pattern)) {
[17:59:18.404]                           computeRestarts <- base::computeRestarts
[17:59:18.404]                           grepl <- base::grepl
[17:59:18.404]                           restarts <- computeRestarts(cond)
[17:59:18.404]                           for (restart in restarts) {
[17:59:18.404]                             name <- restart$name
[17:59:18.404]                             if (is.null(name)) 
[17:59:18.404]                               next
[17:59:18.404]                             if (!grepl(pattern, name)) 
[17:59:18.404]                               next
[17:59:18.404]                             invokeRestart(restart)
[17:59:18.404]                             muffled <- TRUE
[17:59:18.404]                             break
[17:59:18.404]                           }
[17:59:18.404]                         }
[17:59:18.404]                       }
[17:59:18.404]                       invisible(muffled)
[17:59:18.404]                     }
[17:59:18.404]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.404]                   }
[17:59:18.404]                 }
[17:59:18.404]                 else {
[17:59:18.404]                   if (TRUE) {
[17:59:18.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.404]                     {
[17:59:18.404]                       inherits <- base::inherits
[17:59:18.404]                       invokeRestart <- base::invokeRestart
[17:59:18.404]                       is.null <- base::is.null
[17:59:18.404]                       muffled <- FALSE
[17:59:18.404]                       if (inherits(cond, "message")) {
[17:59:18.404]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.404]                         if (muffled) 
[17:59:18.404]                           invokeRestart("muffleMessage")
[17:59:18.404]                       }
[17:59:18.404]                       else if (inherits(cond, "warning")) {
[17:59:18.404]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.404]                         if (muffled) 
[17:59:18.404]                           invokeRestart("muffleWarning")
[17:59:18.404]                       }
[17:59:18.404]                       else if (inherits(cond, "condition")) {
[17:59:18.404]                         if (!is.null(pattern)) {
[17:59:18.404]                           computeRestarts <- base::computeRestarts
[17:59:18.404]                           grepl <- base::grepl
[17:59:18.404]                           restarts <- computeRestarts(cond)
[17:59:18.404]                           for (restart in restarts) {
[17:59:18.404]                             name <- restart$name
[17:59:18.404]                             if (is.null(name)) 
[17:59:18.404]                               next
[17:59:18.404]                             if (!grepl(pattern, name)) 
[17:59:18.404]                               next
[17:59:18.404]                             invokeRestart(restart)
[17:59:18.404]                             muffled <- TRUE
[17:59:18.404]                             break
[17:59:18.404]                           }
[17:59:18.404]                         }
[17:59:18.404]                       }
[17:59:18.404]                       invisible(muffled)
[17:59:18.404]                     }
[17:59:18.404]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.404]                   }
[17:59:18.404]                 }
[17:59:18.404]             }
[17:59:18.404]         }))
[17:59:18.404]     }, error = function(ex) {
[17:59:18.404]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:18.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.404]                 ...future.rng), started = ...future.startTime, 
[17:59:18.404]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:18.404]             version = "1.8"), class = "FutureResult")
[17:59:18.404]     }, finally = {
[17:59:18.404]         if (!identical(...future.workdir, getwd())) 
[17:59:18.404]             setwd(...future.workdir)
[17:59:18.404]         {
[17:59:18.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:18.404]                 ...future.oldOptions$nwarnings <- NULL
[17:59:18.404]             }
[17:59:18.404]             base::options(...future.oldOptions)
[17:59:18.404]             if (.Platform$OS.type == "windows") {
[17:59:18.404]                 old_names <- names(...future.oldEnvVars)
[17:59:18.404]                 envs <- base::Sys.getenv()
[17:59:18.404]                 names <- names(envs)
[17:59:18.404]                 common <- intersect(names, old_names)
[17:59:18.404]                 added <- setdiff(names, old_names)
[17:59:18.404]                 removed <- setdiff(old_names, names)
[17:59:18.404]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:18.404]                   envs[common]]
[17:59:18.404]                 NAMES <- toupper(changed)
[17:59:18.404]                 args <- list()
[17:59:18.404]                 for (kk in seq_along(NAMES)) {
[17:59:18.404]                   name <- changed[[kk]]
[17:59:18.404]                   NAME <- NAMES[[kk]]
[17:59:18.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.404]                     next
[17:59:18.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.404]                 }
[17:59:18.404]                 NAMES <- toupper(added)
[17:59:18.404]                 for (kk in seq_along(NAMES)) {
[17:59:18.404]                   name <- added[[kk]]
[17:59:18.404]                   NAME <- NAMES[[kk]]
[17:59:18.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.404]                     next
[17:59:18.404]                   args[[name]] <- ""
[17:59:18.404]                 }
[17:59:18.404]                 NAMES <- toupper(removed)
[17:59:18.404]                 for (kk in seq_along(NAMES)) {
[17:59:18.404]                   name <- removed[[kk]]
[17:59:18.404]                   NAME <- NAMES[[kk]]
[17:59:18.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.404]                     next
[17:59:18.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.404]                 }
[17:59:18.404]                 if (length(args) > 0) 
[17:59:18.404]                   base::do.call(base::Sys.setenv, args = args)
[17:59:18.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:18.404]             }
[17:59:18.404]             else {
[17:59:18.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:18.404]             }
[17:59:18.404]             {
[17:59:18.404]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:18.404]                   0L) {
[17:59:18.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:18.404]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:18.404]                   base::options(opts)
[17:59:18.404]                 }
[17:59:18.404]                 {
[17:59:18.404]                   {
[17:59:18.404]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:18.404]                     NULL
[17:59:18.404]                   }
[17:59:18.404]                   options(future.plan = NULL)
[17:59:18.404]                   if (is.na(NA_character_)) 
[17:59:18.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:18.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:18.404]                     .init = FALSE)
[17:59:18.404]                 }
[17:59:18.404]             }
[17:59:18.404]         }
[17:59:18.404]     })
[17:59:18.404]     if (TRUE) {
[17:59:18.404]         base::sink(type = "output", split = FALSE)
[17:59:18.404]         if (TRUE) {
[17:59:18.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:18.404]         }
[17:59:18.404]         else {
[17:59:18.404]             ...future.result["stdout"] <- base::list(NULL)
[17:59:18.404]         }
[17:59:18.404]         base::close(...future.stdout)
[17:59:18.404]         ...future.stdout <- NULL
[17:59:18.404]     }
[17:59:18.404]     ...future.result$conditions <- ...future.conditions
[17:59:18.404]     ...future.result$finished <- base::Sys.time()
[17:59:18.404]     ...future.result
[17:59:18.404] }
[17:59:18.411] assign_globals() ...
[17:59:18.411] List of 5
[17:59:18.411]  $ future.call.arguments    : list()
[17:59:18.411]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.411]  $ ...future.FUN            :function (x)  
[17:59:18.411]  $ ...future.elements_ii    :List of 1
[17:59:18.411]   ..$ : int [1:2] 2 4
[17:59:18.411]  $ ...future.seeds_ii       : NULL
[17:59:18.411]  $ ...future.globals.maxSize: num Inf
[17:59:18.411]  - attr(*, "resolved")= logi FALSE
[17:59:18.411]  - attr(*, "total_size")= num NA
[17:59:18.411]  - attr(*, "where")=List of 5
[17:59:18.411]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:18.411]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:18.411]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:18.411]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:18.411]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:18.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.411]  - attr(*, "already-done")= logi TRUE
[17:59:18.428] - copied ‘future.call.arguments’ to environment
[17:59:18.428] - reassign environment for ‘...future.FUN’
[17:59:18.428] - copied ‘...future.FUN’ to environment
[17:59:18.429] - copied ‘...future.elements_ii’ to environment
[17:59:18.429] - copied ‘...future.seeds_ii’ to environment
[17:59:18.429] - copied ‘...future.globals.maxSize’ to environment
[17:59:18.430] assign_globals() ... done
[17:59:18.430] requestCore(): workers = 2
[17:59:18.434] MulticoreFuture started
[17:59:18.434] - Launch lazy future ... done
[17:59:18.435] run() for ‘MulticoreFuture’ ... done
[17:59:18.435] Created future:
[17:59:18.435] plan(): Setting new future strategy stack:
[17:59:18.436] List of future strategies:
[17:59:18.436] 1. sequential:
[17:59:18.436]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:18.436]    - tweaked: FALSE
[17:59:18.436]    - call: NULL
[17:59:18.438] plan(): nbrOfWorkers() = 1
[17:59:18.442] plan(): Setting new future strategy stack:
[17:59:18.443] List of future strategies:
[17:59:18.443] 1. multicore:
[17:59:18.443]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:18.443]    - tweaked: FALSE
[17:59:18.443]    - call: plan(strategy)
[17:59:18.436] MulticoreFuture:
[17:59:18.436] Label: ‘future_apply-2’
[17:59:18.436] Expression:
[17:59:18.436] {
[17:59:18.436]     do.call(function(...) {
[17:59:18.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.436]             on.exit(options(oopts), add = TRUE)
[17:59:18.436]         }
[17:59:18.436]         {
[17:59:18.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.436]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.436]             })
[17:59:18.436]         }
[17:59:18.436]     }, args = future.call.arguments)
[17:59:18.436] }
[17:59:18.436] Lazy evaluation: FALSE
[17:59:18.436] Asynchronous evaluation: TRUE
[17:59:18.436] Local evaluation: TRUE
[17:59:18.436] Environment: R_GlobalEnv
[17:59:18.436] Capture standard output: TRUE
[17:59:18.436] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:18.436] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:18.436] Packages: <none>
[17:59:18.436] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:18.436] Resolved: FALSE
[17:59:18.436] Value: <not collected>
[17:59:18.436] Conditions captured: <none>
[17:59:18.436] Early signaling: FALSE
[17:59:18.436] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:18.436] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.451] Chunk #2 of 2 ... DONE
[17:59:18.452] Launching 2 futures (chunks) ... DONE
[17:59:18.452] Resolving 2 futures (chunks) ...
[17:59:18.453] resolve() on list ...
[17:59:18.453]  recursive: 0
[17:59:18.453]  length: 2
[17:59:18.454] 
[17:59:18.455] Future #1
[17:59:18.455] result() for MulticoreFuture ...
[17:59:18.461] result() for MulticoreFuture ...
[17:59:18.462] result() for MulticoreFuture ... done
[17:59:18.462] result() for MulticoreFuture ... done
[17:59:18.463] result() for MulticoreFuture ...
[17:59:18.464] result() for MulticoreFuture ... done
[17:59:18.465] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:18.466] - nx: 2
[17:59:18.466] plan(): nbrOfWorkers() = 2
[17:59:18.466] - relay: TRUE
[17:59:18.467] - stdout: TRUE
[17:59:18.467] - signal: TRUE
[17:59:18.468] - resignal: FALSE
[17:59:18.469] - force: TRUE
[17:59:18.469] - relayed: [n=2] FALSE, FALSE
[17:59:18.470] - queued futures: [n=2] FALSE, FALSE
[17:59:18.470]  - until=1
[17:59:18.471]  - relaying element #1
[17:59:18.472] result() for MulticoreFuture ...
[17:59:18.472] result() for MulticoreFuture ... done
[17:59:18.473] result() for MulticoreFuture ...
[17:59:18.473] result() for MulticoreFuture ... done
[17:59:18.474] result() for MulticoreFuture ...
[17:59:18.475] result() for MulticoreFuture ... done
[17:59:18.475] result() for MulticoreFuture ...
[17:59:18.475] result() for MulticoreFuture ... done
[17:59:18.476] - relayed: [n=2] TRUE, FALSE
[17:59:18.476] - queued futures: [n=2] TRUE, FALSE
[17:59:18.477] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:18.477]  length: 1 (resolved future 1)
[17:59:18.478] Future #2
[17:59:18.478] result() for MulticoreFuture ...
[17:59:18.479] result() for MulticoreFuture ...
[17:59:18.480] result() for MulticoreFuture ... done
[17:59:18.480] result() for MulticoreFuture ... done
[17:59:18.480] result() for MulticoreFuture ...
[17:59:18.481] result() for MulticoreFuture ... done
[17:59:18.481] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:18.482] - nx: 2
[17:59:18.482] - relay: TRUE
[17:59:18.482] - stdout: TRUE
[17:59:18.482] - signal: TRUE
[17:59:18.482] - resignal: FALSE
[17:59:18.483] - force: TRUE
[17:59:18.483] - relayed: [n=2] TRUE, FALSE
[17:59:18.483] - queued futures: [n=2] TRUE, FALSE
[17:59:18.483]  - until=2
[17:59:18.484]  - relaying element #2
[17:59:18.484] result() for MulticoreFuture ...
[17:59:18.484] result() for MulticoreFuture ... done
[17:59:18.484] result() for MulticoreFuture ...
[17:59:18.485] result() for MulticoreFuture ... done
[17:59:18.485] result() for MulticoreFuture ...
[17:59:18.485] result() for MulticoreFuture ... done
[17:59:18.486] result() for MulticoreFuture ...
[17:59:18.486] result() for MulticoreFuture ... done
[17:59:18.486] - relayed: [n=2] TRUE, TRUE
[17:59:18.486] - queued futures: [n=2] TRUE, TRUE
[17:59:18.486] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:18.487]  length: 0 (resolved future 2)
[17:59:18.487] Relaying remaining futures
[17:59:18.487] signalConditionsASAP(NULL, pos=0) ...
[17:59:18.488] - nx: 2
[17:59:18.488] - relay: TRUE
[17:59:18.488] - stdout: TRUE
[17:59:18.488] - signal: TRUE
[17:59:18.488] - resignal: FALSE
[17:59:18.489] - force: TRUE
[17:59:18.489] - relayed: [n=2] TRUE, TRUE
[17:59:18.489] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:18.489] - relayed: [n=2] TRUE, TRUE
[17:59:18.490] - queued futures: [n=2] TRUE, TRUE
[17:59:18.490] signalConditionsASAP(NULL, pos=0) ... done
[17:59:18.490] resolve() on list ... DONE
[17:59:18.490] result() for MulticoreFuture ...
[17:59:18.491] result() for MulticoreFuture ... done
[17:59:18.491] result() for MulticoreFuture ...
[17:59:18.491] result() for MulticoreFuture ... done
[17:59:18.491] result() for MulticoreFuture ...
[17:59:18.492] result() for MulticoreFuture ... done
[17:59:18.492] result() for MulticoreFuture ...
[17:59:18.492] result() for MulticoreFuture ... done
[17:59:18.492]  - Number of value chunks collected: 2
[17:59:18.492] Resolving 2 futures (chunks) ... DONE
[17:59:18.493] Reducing values from 2 chunks ...
[17:59:18.493]  - Number of values collected after concatenation: 2
[17:59:18.493]  - Number of values expected: 2
[17:59:18.493] Reducing values from 2 chunks ... DONE
[17:59:18.494] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:59:18.494] getGlobalsAndPackagesXApply() ...
[17:59:18.494]  - future.globals: TRUE
[17:59:18.495] getGlobalsAndPackages() ...
[17:59:18.495] Searching for globals...
[17:59:18.503] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:59:18.503] Searching for globals ... DONE
[17:59:18.503] Resolving globals: FALSE
[17:59:18.505] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:59:18.505] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:59:18.506] - globals: [1] ‘FUN’
[17:59:18.506] 
[17:59:18.506] getGlobalsAndPackages() ... DONE
[17:59:18.506]  - globals found/used: [n=1] ‘FUN’
[17:59:18.507]  - needed namespaces: [n=0] 
[17:59:18.507] Finding globals ... DONE
[17:59:18.507]  - use_args: TRUE
[17:59:18.507]  - Getting '...' globals ...
[17:59:18.508] resolve() on list ...
[17:59:18.508]  recursive: 0
[17:59:18.508]  length: 1
[17:59:18.509]  elements: ‘...’
[17:59:18.509]  length: 0 (resolved future 1)
[17:59:18.509] resolve() on list ... DONE
[17:59:18.509]    - '...' content: [n=0] 
[17:59:18.510] List of 1
[17:59:18.510]  $ ...: list()
[17:59:18.510]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.510]  - attr(*, "where")=List of 1
[17:59:18.510]   ..$ ...:<environment: 0x56085a6c3af8> 
[17:59:18.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.510]  - attr(*, "resolved")= logi TRUE
[17:59:18.510]  - attr(*, "total_size")= num NA
[17:59:18.515]  - Getting '...' globals ... DONE
[17:59:18.515] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:18.515] List of 2
[17:59:18.515]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:59:18.515]  $ ...          : list()
[17:59:18.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.515]  - attr(*, "where")=List of 2
[17:59:18.515]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:18.515]   ..$ ...          :<environment: 0x56085a6c3af8> 
[17:59:18.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.515]  - attr(*, "resolved")= logi FALSE
[17:59:18.515]  - attr(*, "total_size")= num 36296
[17:59:18.524] Packages to be attached in all futures: [n=0] 
[17:59:18.525] getGlobalsAndPackagesXApply() ... DONE
[17:59:18.531] future_lapply() ...
[17:59:18.535] Generating random seeds ...
[17:59:18.535] Generating random seed streams for 2 elements ...
[17:59:18.536] Generating random seed streams for 2 elements ... DONE
[17:59:18.536] Generating random seeds ... DONE
[17:59:18.536] Will set RNG state on exit: 10407, -714864195, 380493129, -1422521837, -1576814552, 132151532, 1285653380
[17:59:18.542] Number of chunks: 2
[17:59:18.542] getGlobalsAndPackagesXApply() ...
[17:59:18.543]  - future.globals: <name-value list> with names ‘list()’
[17:59:18.543]  - use_args: TRUE
[17:59:18.543] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:18.544] List of 2
[17:59:18.544]  $ ...          : list()
[17:59:18.544]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.544]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:59:18.544]  - attr(*, "where")=List of 2
[17:59:18.544]   ..$ ...          :<environment: 0x56085a6c3af8> 
[17:59:18.544]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:18.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.544]  - attr(*, "resolved")= logi FALSE
[17:59:18.544]  - attr(*, "total_size")= num NA
[17:59:18.550] Packages to be attached in all futures: [n=0] 
[17:59:18.550] getGlobalsAndPackagesXApply() ... DONE
[17:59:18.551] Number of futures (= number of chunks): 2
[17:59:18.551] Launching 2 futures (chunks) ...
[17:59:18.551] Chunk #1 of 2 ...
[17:59:18.552]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:18.552]  - seeds: [1] <seeds>
[17:59:18.552]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.552] getGlobalsAndPackages() ...
[17:59:18.552] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.553] Resolving globals: FALSE
[17:59:18.553] Tweak future expression to call with '...' arguments ...
[17:59:18.553] {
[17:59:18.553]     do.call(function(...) {
[17:59:18.553]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.553]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.553]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.553]             on.exit(options(oopts), add = TRUE)
[17:59:18.553]         }
[17:59:18.553]         {
[17:59:18.553]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.553]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.553]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:18.553]                   envir = globalenv(), inherits = FALSE)
[17:59:18.553]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.553]             })
[17:59:18.553]         }
[17:59:18.553]     }, args = future.call.arguments)
[17:59:18.553] }
[17:59:18.554] Tweak future expression to call with '...' arguments ... DONE
[17:59:18.554] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.555] 
[17:59:18.555] getGlobalsAndPackages() ... DONE
[17:59:18.555] run() for ‘Future’ ...
[17:59:18.556] - state: ‘created’
[17:59:18.556] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:18.562] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.563] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:18.563]   - Field: ‘label’
[17:59:18.563]   - Field: ‘local’
[17:59:18.563]   - Field: ‘owner’
[17:59:18.563]   - Field: ‘envir’
[17:59:18.564]   - Field: ‘workers’
[17:59:18.564]   - Field: ‘packages’
[17:59:18.564]   - Field: ‘gc’
[17:59:18.564]   - Field: ‘job’
[17:59:18.564]   - Field: ‘conditions’
[17:59:18.565]   - Field: ‘expr’
[17:59:18.565]   - Field: ‘uuid’
[17:59:18.565]   - Field: ‘seed’
[17:59:18.565]   - Field: ‘version’
[17:59:18.565]   - Field: ‘result’
[17:59:18.566]   - Field: ‘asynchronous’
[17:59:18.566]   - Field: ‘calls’
[17:59:18.566]   - Field: ‘globals’
[17:59:18.566]   - Field: ‘stdout’
[17:59:18.566]   - Field: ‘earlySignal’
[17:59:18.567]   - Field: ‘lazy’
[17:59:18.567]   - Field: ‘state’
[17:59:18.567] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:18.567] - Launch lazy future ...
[17:59:18.568] Packages needed by the future expression (n = 0): <none>
[17:59:18.568] Packages needed by future strategies (n = 0): <none>
[17:59:18.569] {
[17:59:18.569]     {
[17:59:18.569]         {
[17:59:18.569]             ...future.startTime <- base::Sys.time()
[17:59:18.569]             {
[17:59:18.569]                 {
[17:59:18.569]                   {
[17:59:18.569]                     {
[17:59:18.569]                       base::local({
[17:59:18.569]                         has_future <- base::requireNamespace("future", 
[17:59:18.569]                           quietly = TRUE)
[17:59:18.569]                         if (has_future) {
[17:59:18.569]                           ns <- base::getNamespace("future")
[17:59:18.569]                           version <- ns[[".package"]][["version"]]
[17:59:18.569]                           if (is.null(version)) 
[17:59:18.569]                             version <- utils::packageVersion("future")
[17:59:18.569]                         }
[17:59:18.569]                         else {
[17:59:18.569]                           version <- NULL
[17:59:18.569]                         }
[17:59:18.569]                         if (!has_future || version < "1.8.0") {
[17:59:18.569]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:18.569]                             "", base::R.version$version.string), 
[17:59:18.569]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:18.569]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:18.569]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:18.569]                               "release", "version")], collapse = " "), 
[17:59:18.569]                             hostname = base::Sys.info()[["nodename"]])
[17:59:18.569]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:18.569]                             info)
[17:59:18.569]                           info <- base::paste(info, collapse = "; ")
[17:59:18.569]                           if (!has_future) {
[17:59:18.569]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:18.569]                               info)
[17:59:18.569]                           }
[17:59:18.569]                           else {
[17:59:18.569]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:18.569]                               info, version)
[17:59:18.569]                           }
[17:59:18.569]                           base::stop(msg)
[17:59:18.569]                         }
[17:59:18.569]                       })
[17:59:18.569]                     }
[17:59:18.569]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:18.569]                     base::options(mc.cores = 1L)
[17:59:18.569]                   }
[17:59:18.569]                   ...future.strategy.old <- future::plan("list")
[17:59:18.569]                   options(future.plan = NULL)
[17:59:18.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:18.569]                 }
[17:59:18.569]                 ...future.workdir <- getwd()
[17:59:18.569]             }
[17:59:18.569]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:18.569]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:18.569]         }
[17:59:18.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:18.569]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:18.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:18.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:18.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:18.569]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:18.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:18.569]             base::names(...future.oldOptions))
[17:59:18.569]     }
[17:59:18.569]     if (FALSE) {
[17:59:18.569]     }
[17:59:18.569]     else {
[17:59:18.569]         if (TRUE) {
[17:59:18.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:18.569]                 open = "w")
[17:59:18.569]         }
[17:59:18.569]         else {
[17:59:18.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:18.569]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:18.569]         }
[17:59:18.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:18.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:18.569]             base::sink(type = "output", split = FALSE)
[17:59:18.569]             base::close(...future.stdout)
[17:59:18.569]         }, add = TRUE)
[17:59:18.569]     }
[17:59:18.569]     ...future.frame <- base::sys.nframe()
[17:59:18.569]     ...future.conditions <- base::list()
[17:59:18.569]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:18.569]     if (FALSE) {
[17:59:18.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:18.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:18.569]     }
[17:59:18.569]     ...future.result <- base::tryCatch({
[17:59:18.569]         base::withCallingHandlers({
[17:59:18.569]             ...future.value <- base::withVisible(base::local({
[17:59:18.569]                 withCallingHandlers({
[17:59:18.569]                   {
[17:59:18.569]                     do.call(function(...) {
[17:59:18.569]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.569]                       if (!identical(...future.globals.maxSize.org, 
[17:59:18.569]                         ...future.globals.maxSize)) {
[17:59:18.569]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.569]                         on.exit(options(oopts), add = TRUE)
[17:59:18.569]                       }
[17:59:18.569]                       {
[17:59:18.569]                         lapply(seq_along(...future.elements_ii), 
[17:59:18.569]                           FUN = function(jj) {
[17:59:18.569]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.569]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:18.569]                               envir = globalenv(), inherits = FALSE)
[17:59:18.569]                             ...future.FUN(...future.X_jj, ...)
[17:59:18.569]                           })
[17:59:18.569]                       }
[17:59:18.569]                     }, args = future.call.arguments)
[17:59:18.569]                   }
[17:59:18.569]                 }, immediateCondition = function(cond) {
[17:59:18.569]                   save_rds <- function (object, pathname, ...) 
[17:59:18.569]                   {
[17:59:18.569]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:18.569]                     if (file_test("-f", pathname_tmp)) {
[17:59:18.569]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.569]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:18.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.569]                         fi_tmp[["mtime"]])
[17:59:18.569]                     }
[17:59:18.569]                     tryCatch({
[17:59:18.569]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:18.569]                     }, error = function(ex) {
[17:59:18.569]                       msg <- conditionMessage(ex)
[17:59:18.569]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.569]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:18.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.569]                         fi_tmp[["mtime"]], msg)
[17:59:18.569]                       ex$message <- msg
[17:59:18.569]                       stop(ex)
[17:59:18.569]                     })
[17:59:18.569]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:18.569]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:18.569]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:18.569]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.569]                       fi <- file.info(pathname)
[17:59:18.569]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:18.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.569]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:18.569]                         fi[["size"]], fi[["mtime"]])
[17:59:18.569]                       stop(msg)
[17:59:18.569]                     }
[17:59:18.569]                     invisible(pathname)
[17:59:18.569]                   }
[17:59:18.569]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:18.569]                     rootPath = tempdir()) 
[17:59:18.569]                   {
[17:59:18.569]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:18.569]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:18.569]                       tmpdir = path, fileext = ".rds")
[17:59:18.569]                     save_rds(obj, file)
[17:59:18.569]                   }
[17:59:18.569]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:18.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.569]                   {
[17:59:18.569]                     inherits <- base::inherits
[17:59:18.569]                     invokeRestart <- base::invokeRestart
[17:59:18.569]                     is.null <- base::is.null
[17:59:18.569]                     muffled <- FALSE
[17:59:18.569]                     if (inherits(cond, "message")) {
[17:59:18.569]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:18.569]                       if (muffled) 
[17:59:18.569]                         invokeRestart("muffleMessage")
[17:59:18.569]                     }
[17:59:18.569]                     else if (inherits(cond, "warning")) {
[17:59:18.569]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:18.569]                       if (muffled) 
[17:59:18.569]                         invokeRestart("muffleWarning")
[17:59:18.569]                     }
[17:59:18.569]                     else if (inherits(cond, "condition")) {
[17:59:18.569]                       if (!is.null(pattern)) {
[17:59:18.569]                         computeRestarts <- base::computeRestarts
[17:59:18.569]                         grepl <- base::grepl
[17:59:18.569]                         restarts <- computeRestarts(cond)
[17:59:18.569]                         for (restart in restarts) {
[17:59:18.569]                           name <- restart$name
[17:59:18.569]                           if (is.null(name)) 
[17:59:18.569]                             next
[17:59:18.569]                           if (!grepl(pattern, name)) 
[17:59:18.569]                             next
[17:59:18.569]                           invokeRestart(restart)
[17:59:18.569]                           muffled <- TRUE
[17:59:18.569]                           break
[17:59:18.569]                         }
[17:59:18.569]                       }
[17:59:18.569]                     }
[17:59:18.569]                     invisible(muffled)
[17:59:18.569]                   }
[17:59:18.569]                   muffleCondition(cond)
[17:59:18.569]                 })
[17:59:18.569]             }))
[17:59:18.569]             future::FutureResult(value = ...future.value$value, 
[17:59:18.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.569]                   ...future.rng), globalenv = if (FALSE) 
[17:59:18.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:18.569]                     ...future.globalenv.names))
[17:59:18.569]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:18.569]         }, condition = base::local({
[17:59:18.569]             c <- base::c
[17:59:18.569]             inherits <- base::inherits
[17:59:18.569]             invokeRestart <- base::invokeRestart
[17:59:18.569]             length <- base::length
[17:59:18.569]             list <- base::list
[17:59:18.569]             seq.int <- base::seq.int
[17:59:18.569]             signalCondition <- base::signalCondition
[17:59:18.569]             sys.calls <- base::sys.calls
[17:59:18.569]             `[[` <- base::`[[`
[17:59:18.569]             `+` <- base::`+`
[17:59:18.569]             `<<-` <- base::`<<-`
[17:59:18.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:18.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:18.569]                   3L)]
[17:59:18.569]             }
[17:59:18.569]             function(cond) {
[17:59:18.569]                 is_error <- inherits(cond, "error")
[17:59:18.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:18.569]                   NULL)
[17:59:18.569]                 if (is_error) {
[17:59:18.569]                   sessionInformation <- function() {
[17:59:18.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:18.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:18.569]                       search = base::search(), system = base::Sys.info())
[17:59:18.569]                   }
[17:59:18.569]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:18.569]                     cond$call), session = sessionInformation(), 
[17:59:18.569]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:18.569]                   signalCondition(cond)
[17:59:18.569]                 }
[17:59:18.569]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:59:18.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:18.569]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:18.569]                   if (TRUE && !signal) {
[17:59:18.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.569]                     {
[17:59:18.569]                       inherits <- base::inherits
[17:59:18.569]                       invokeRestart <- base::invokeRestart
[17:59:18.569]                       is.null <- base::is.null
[17:59:18.569]                       muffled <- FALSE
[17:59:18.569]                       if (inherits(cond, "message")) {
[17:59:18.569]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.569]                         if (muffled) 
[17:59:18.569]                           invokeRestart("muffleMessage")
[17:59:18.569]                       }
[17:59:18.569]                       else if (inherits(cond, "warning")) {
[17:59:18.569]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.569]                         if (muffled) 
[17:59:18.569]                           invokeRestart("muffleWarning")
[17:59:18.569]                       }
[17:59:18.569]                       else if (inherits(cond, "condition")) {
[17:59:18.569]                         if (!is.null(pattern)) {
[17:59:18.569]                           computeRestarts <- base::computeRestarts
[17:59:18.569]                           grepl <- base::grepl
[17:59:18.569]                           restarts <- computeRestarts(cond)
[17:59:18.569]                           for (restart in restarts) {
[17:59:18.569]                             name <- restart$name
[17:59:18.569]                             if (is.null(name)) 
[17:59:18.569]                               next
[17:59:18.569]                             if (!grepl(pattern, name)) 
[17:59:18.569]                               next
[17:59:18.569]                             invokeRestart(restart)
[17:59:18.569]                             muffled <- TRUE
[17:59:18.569]                             break
[17:59:18.569]                           }
[17:59:18.569]                         }
[17:59:18.569]                       }
[17:59:18.569]                       invisible(muffled)
[17:59:18.569]                     }
[17:59:18.569]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.569]                   }
[17:59:18.569]                 }
[17:59:18.569]                 else {
[17:59:18.569]                   if (TRUE) {
[17:59:18.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.569]                     {
[17:59:18.569]                       inherits <- base::inherits
[17:59:18.569]                       invokeRestart <- base::invokeRestart
[17:59:18.569]                       is.null <- base::is.null
[17:59:18.569]                       muffled <- FALSE
[17:59:18.569]                       if (inherits(cond, "message")) {
[17:59:18.569]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.569]                         if (muffled) 
[17:59:18.569]                           invokeRestart("muffleMessage")
[17:59:18.569]                       }
[17:59:18.569]                       else if (inherits(cond, "warning")) {
[17:59:18.569]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.569]                         if (muffled) 
[17:59:18.569]                           invokeRestart("muffleWarning")
[17:59:18.569]                       }
[17:59:18.569]                       else if (inherits(cond, "condition")) {
[17:59:18.569]                         if (!is.null(pattern)) {
[17:59:18.569]                           computeRestarts <- base::computeRestarts
[17:59:18.569]                           grepl <- base::grepl
[17:59:18.569]                           restarts <- computeRestarts(cond)
[17:59:18.569]                           for (restart in restarts) {
[17:59:18.569]                             name <- restart$name
[17:59:18.569]                             if (is.null(name)) 
[17:59:18.569]                               next
[17:59:18.569]                             if (!grepl(pattern, name)) 
[17:59:18.569]                               next
[17:59:18.569]                             invokeRestart(restart)
[17:59:18.569]                             muffled <- TRUE
[17:59:18.569]                             break
[17:59:18.569]                           }
[17:59:18.569]                         }
[17:59:18.569]                       }
[17:59:18.569]                       invisible(muffled)
[17:59:18.569]                     }
[17:59:18.569]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.569]                   }
[17:59:18.569]                 }
[17:59:18.569]             }
[17:59:18.569]         }))
[17:59:18.569]     }, error = function(ex) {
[17:59:18.569]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:18.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.569]                 ...future.rng), started = ...future.startTime, 
[17:59:18.569]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:18.569]             version = "1.8"), class = "FutureResult")
[17:59:18.569]     }, finally = {
[17:59:18.569]         if (!identical(...future.workdir, getwd())) 
[17:59:18.569]             setwd(...future.workdir)
[17:59:18.569]         {
[17:59:18.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:18.569]                 ...future.oldOptions$nwarnings <- NULL
[17:59:18.569]             }
[17:59:18.569]             base::options(...future.oldOptions)
[17:59:18.569]             if (.Platform$OS.type == "windows") {
[17:59:18.569]                 old_names <- names(...future.oldEnvVars)
[17:59:18.569]                 envs <- base::Sys.getenv()
[17:59:18.569]                 names <- names(envs)
[17:59:18.569]                 common <- intersect(names, old_names)
[17:59:18.569]                 added <- setdiff(names, old_names)
[17:59:18.569]                 removed <- setdiff(old_names, names)
[17:59:18.569]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:18.569]                   envs[common]]
[17:59:18.569]                 NAMES <- toupper(changed)
[17:59:18.569]                 args <- list()
[17:59:18.569]                 for (kk in seq_along(NAMES)) {
[17:59:18.569]                   name <- changed[[kk]]
[17:59:18.569]                   NAME <- NAMES[[kk]]
[17:59:18.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.569]                     next
[17:59:18.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.569]                 }
[17:59:18.569]                 NAMES <- toupper(added)
[17:59:18.569]                 for (kk in seq_along(NAMES)) {
[17:59:18.569]                   name <- added[[kk]]
[17:59:18.569]                   NAME <- NAMES[[kk]]
[17:59:18.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.569]                     next
[17:59:18.569]                   args[[name]] <- ""
[17:59:18.569]                 }
[17:59:18.569]                 NAMES <- toupper(removed)
[17:59:18.569]                 for (kk in seq_along(NAMES)) {
[17:59:18.569]                   name <- removed[[kk]]
[17:59:18.569]                   NAME <- NAMES[[kk]]
[17:59:18.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.569]                     next
[17:59:18.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.569]                 }
[17:59:18.569]                 if (length(args) > 0) 
[17:59:18.569]                   base::do.call(base::Sys.setenv, args = args)
[17:59:18.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:18.569]             }
[17:59:18.569]             else {
[17:59:18.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:18.569]             }
[17:59:18.569]             {
[17:59:18.569]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:18.569]                   0L) {
[17:59:18.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:18.569]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:18.569]                   base::options(opts)
[17:59:18.569]                 }
[17:59:18.569]                 {
[17:59:18.569]                   {
[17:59:18.569]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:18.569]                     NULL
[17:59:18.569]                   }
[17:59:18.569]                   options(future.plan = NULL)
[17:59:18.569]                   if (is.na(NA_character_)) 
[17:59:18.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:18.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:18.569]                     .init = FALSE)
[17:59:18.569]                 }
[17:59:18.569]             }
[17:59:18.569]         }
[17:59:18.569]     })
[17:59:18.569]     if (TRUE) {
[17:59:18.569]         base::sink(type = "output", split = FALSE)
[17:59:18.569]         if (TRUE) {
[17:59:18.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:18.569]         }
[17:59:18.569]         else {
[17:59:18.569]             ...future.result["stdout"] <- base::list(NULL)
[17:59:18.569]         }
[17:59:18.569]         base::close(...future.stdout)
[17:59:18.569]         ...future.stdout <- NULL
[17:59:18.569]     }
[17:59:18.569]     ...future.result$conditions <- ...future.conditions
[17:59:18.569]     ...future.result$finished <- base::Sys.time()
[17:59:18.569]     ...future.result
[17:59:18.569] }
[17:59:18.573] assign_globals() ...
[17:59:18.574] List of 5
[17:59:18.574]  $ future.call.arguments    : list()
[17:59:18.574]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.574]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:59:18.574]  $ ...future.elements_ii    :List of 1
[17:59:18.574]   ..$ : int [1:2] 1 3
[17:59:18.574]  $ ...future.seeds_ii       :List of 1
[17:59:18.574]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:59:18.574]  $ ...future.globals.maxSize: num Inf
[17:59:18.574]  - attr(*, "resolved")= logi FALSE
[17:59:18.574]  - attr(*, "total_size")= num NA
[17:59:18.574]  - attr(*, "where")=List of 5
[17:59:18.574]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:18.574]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:18.574]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:18.574]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:18.574]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:18.574]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.574]  - attr(*, "already-done")= logi TRUE
[17:59:18.588] - copied ‘future.call.arguments’ to environment
[17:59:18.588] - copied ‘...future.FUN’ to environment
[17:59:18.588] - copied ‘...future.elements_ii’ to environment
[17:59:18.588] - copied ‘...future.seeds_ii’ to environment
[17:59:18.589] - copied ‘...future.globals.maxSize’ to environment
[17:59:18.589] assign_globals() ... done
[17:59:18.589] requestCore(): workers = 2
[17:59:18.592] MulticoreFuture started
[17:59:18.593] - Launch lazy future ... done
[17:59:18.594] run() for ‘MulticoreFuture’ ... done
[17:59:18.594] plan(): Setting new future strategy stack:
[17:59:18.595] Created future:
[17:59:18.595] List of future strategies:
[17:59:18.595] 1. sequential:
[17:59:18.595]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:18.595]    - tweaked: FALSE
[17:59:18.595]    - call: NULL
[17:59:18.597] plan(): nbrOfWorkers() = 1
[17:59:18.603] plan(): Setting new future strategy stack:
[17:59:18.603] List of future strategies:
[17:59:18.603] 1. multicore:
[17:59:18.603]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:18.603]    - tweaked: FALSE
[17:59:18.603]    - call: plan(strategy)
[17:59:18.595] MulticoreFuture:
[17:59:18.595] Label: ‘future_apply-1’
[17:59:18.595] Expression:
[17:59:18.595] {
[17:59:18.595]     do.call(function(...) {
[17:59:18.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.595]             on.exit(options(oopts), add = TRUE)
[17:59:18.595]         }
[17:59:18.595]         {
[17:59:18.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.595]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:18.595]                   envir = globalenv(), inherits = FALSE)
[17:59:18.595]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.595]             })
[17:59:18.595]         }
[17:59:18.595]     }, args = future.call.arguments)
[17:59:18.595] }
[17:59:18.595] Lazy evaluation: FALSE
[17:59:18.595] Asynchronous evaluation: TRUE
[17:59:18.595] Local evaluation: TRUE
[17:59:18.595] Environment: R_GlobalEnv
[17:59:18.595] Capture standard output: TRUE
[17:59:18.595] Capture condition classes: <none>
[17:59:18.595] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:18.595] Packages: <none>
[17:59:18.595] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:59:18.595] Resolved: FALSE
[17:59:18.595] Value: <not collected>
[17:59:18.595] Conditions captured: <none>
[17:59:18.595] Early signaling: FALSE
[17:59:18.595] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:18.595] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.611] Chunk #1 of 2 ... DONE
[17:59:18.612] Chunk #2 of 2 ...
[17:59:18.612]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:18.612]  - seeds: [1] <seeds>
[17:59:18.613]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.613] getGlobalsAndPackages() ...
[17:59:18.613] plan(): nbrOfWorkers() = 2
[17:59:18.614] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.614] Resolving globals: FALSE
[17:59:18.614] Tweak future expression to call with '...' arguments ...
[17:59:18.615] {
[17:59:18.615]     do.call(function(...) {
[17:59:18.615]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.615]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.615]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.615]             on.exit(options(oopts), add = TRUE)
[17:59:18.615]         }
[17:59:18.615]         {
[17:59:18.615]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.615]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.615]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:18.615]                   envir = globalenv(), inherits = FALSE)
[17:59:18.615]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.615]             })
[17:59:18.615]         }
[17:59:18.615]     }, args = future.call.arguments)
[17:59:18.615] }
[17:59:18.615] Tweak future expression to call with '...' arguments ... DONE
[17:59:18.617] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:18.617] 
[17:59:18.617] getGlobalsAndPackages() ... DONE
[17:59:18.618] run() for ‘Future’ ...
[17:59:18.619] - state: ‘created’
[17:59:18.619] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:18.628] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:18.629]   - Field: ‘label’
[17:59:18.629]   - Field: ‘local’
[17:59:18.630]   - Field: ‘owner’
[17:59:18.630]   - Field: ‘envir’
[17:59:18.630]   - Field: ‘workers’
[17:59:18.631]   - Field: ‘packages’
[17:59:18.631]   - Field: ‘gc’
[17:59:18.632]   - Field: ‘job’
[17:59:18.632]   - Field: ‘conditions’
[17:59:18.632]   - Field: ‘expr’
[17:59:18.633]   - Field: ‘uuid’
[17:59:18.633]   - Field: ‘seed’
[17:59:18.634]   - Field: ‘version’
[17:59:18.634]   - Field: ‘result’
[17:59:18.634]   - Field: ‘asynchronous’
[17:59:18.635]   - Field: ‘calls’
[17:59:18.635]   - Field: ‘globals’
[17:59:18.635]   - Field: ‘stdout’
[17:59:18.636]   - Field: ‘earlySignal’
[17:59:18.636]   - Field: ‘lazy’
[17:59:18.637]   - Field: ‘state’
[17:59:18.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:18.638] - Launch lazy future ...
[17:59:18.639] Packages needed by the future expression (n = 0): <none>
[17:59:18.639] Packages needed by future strategies (n = 0): <none>
[17:59:18.641] {
[17:59:18.641]     {
[17:59:18.641]         {
[17:59:18.641]             ...future.startTime <- base::Sys.time()
[17:59:18.641]             {
[17:59:18.641]                 {
[17:59:18.641]                   {
[17:59:18.641]                     {
[17:59:18.641]                       base::local({
[17:59:18.641]                         has_future <- base::requireNamespace("future", 
[17:59:18.641]                           quietly = TRUE)
[17:59:18.641]                         if (has_future) {
[17:59:18.641]                           ns <- base::getNamespace("future")
[17:59:18.641]                           version <- ns[[".package"]][["version"]]
[17:59:18.641]                           if (is.null(version)) 
[17:59:18.641]                             version <- utils::packageVersion("future")
[17:59:18.641]                         }
[17:59:18.641]                         else {
[17:59:18.641]                           version <- NULL
[17:59:18.641]                         }
[17:59:18.641]                         if (!has_future || version < "1.8.0") {
[17:59:18.641]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:18.641]                             "", base::R.version$version.string), 
[17:59:18.641]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:18.641]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:18.641]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:18.641]                               "release", "version")], collapse = " "), 
[17:59:18.641]                             hostname = base::Sys.info()[["nodename"]])
[17:59:18.641]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:18.641]                             info)
[17:59:18.641]                           info <- base::paste(info, collapse = "; ")
[17:59:18.641]                           if (!has_future) {
[17:59:18.641]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:18.641]                               info)
[17:59:18.641]                           }
[17:59:18.641]                           else {
[17:59:18.641]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:18.641]                               info, version)
[17:59:18.641]                           }
[17:59:18.641]                           base::stop(msg)
[17:59:18.641]                         }
[17:59:18.641]                       })
[17:59:18.641]                     }
[17:59:18.641]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:18.641]                     base::options(mc.cores = 1L)
[17:59:18.641]                   }
[17:59:18.641]                   ...future.strategy.old <- future::plan("list")
[17:59:18.641]                   options(future.plan = NULL)
[17:59:18.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:18.641]                 }
[17:59:18.641]                 ...future.workdir <- getwd()
[17:59:18.641]             }
[17:59:18.641]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:18.641]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:18.641]         }
[17:59:18.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:18.641]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:18.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:18.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:18.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:18.641]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:18.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:18.641]             base::names(...future.oldOptions))
[17:59:18.641]     }
[17:59:18.641]     if (FALSE) {
[17:59:18.641]     }
[17:59:18.641]     else {
[17:59:18.641]         if (TRUE) {
[17:59:18.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:18.641]                 open = "w")
[17:59:18.641]         }
[17:59:18.641]         else {
[17:59:18.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:18.641]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:18.641]         }
[17:59:18.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:18.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:18.641]             base::sink(type = "output", split = FALSE)
[17:59:18.641]             base::close(...future.stdout)
[17:59:18.641]         }, add = TRUE)
[17:59:18.641]     }
[17:59:18.641]     ...future.frame <- base::sys.nframe()
[17:59:18.641]     ...future.conditions <- base::list()
[17:59:18.641]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:18.641]     if (FALSE) {
[17:59:18.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:18.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:18.641]     }
[17:59:18.641]     ...future.result <- base::tryCatch({
[17:59:18.641]         base::withCallingHandlers({
[17:59:18.641]             ...future.value <- base::withVisible(base::local({
[17:59:18.641]                 withCallingHandlers({
[17:59:18.641]                   {
[17:59:18.641]                     do.call(function(...) {
[17:59:18.641]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.641]                       if (!identical(...future.globals.maxSize.org, 
[17:59:18.641]                         ...future.globals.maxSize)) {
[17:59:18.641]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.641]                         on.exit(options(oopts), add = TRUE)
[17:59:18.641]                       }
[17:59:18.641]                       {
[17:59:18.641]                         lapply(seq_along(...future.elements_ii), 
[17:59:18.641]                           FUN = function(jj) {
[17:59:18.641]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.641]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:18.641]                               envir = globalenv(), inherits = FALSE)
[17:59:18.641]                             ...future.FUN(...future.X_jj, ...)
[17:59:18.641]                           })
[17:59:18.641]                       }
[17:59:18.641]                     }, args = future.call.arguments)
[17:59:18.641]                   }
[17:59:18.641]                 }, immediateCondition = function(cond) {
[17:59:18.641]                   save_rds <- function (object, pathname, ...) 
[17:59:18.641]                   {
[17:59:18.641]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:18.641]                     if (file_test("-f", pathname_tmp)) {
[17:59:18.641]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.641]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:18.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.641]                         fi_tmp[["mtime"]])
[17:59:18.641]                     }
[17:59:18.641]                     tryCatch({
[17:59:18.641]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:18.641]                     }, error = function(ex) {
[17:59:18.641]                       msg <- conditionMessage(ex)
[17:59:18.641]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.641]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:18.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.641]                         fi_tmp[["mtime"]], msg)
[17:59:18.641]                       ex$message <- msg
[17:59:18.641]                       stop(ex)
[17:59:18.641]                     })
[17:59:18.641]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:18.641]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:18.641]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:18.641]                       fi_tmp <- file.info(pathname_tmp)
[17:59:18.641]                       fi <- file.info(pathname)
[17:59:18.641]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:18.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:18.641]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:18.641]                         fi[["size"]], fi[["mtime"]])
[17:59:18.641]                       stop(msg)
[17:59:18.641]                     }
[17:59:18.641]                     invisible(pathname)
[17:59:18.641]                   }
[17:59:18.641]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:18.641]                     rootPath = tempdir()) 
[17:59:18.641]                   {
[17:59:18.641]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:18.641]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:18.641]                       tmpdir = path, fileext = ".rds")
[17:59:18.641]                     save_rds(obj, file)
[17:59:18.641]                   }
[17:59:18.641]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8GbN1e/.future/immediateConditions")
[17:59:18.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.641]                   {
[17:59:18.641]                     inherits <- base::inherits
[17:59:18.641]                     invokeRestart <- base::invokeRestart
[17:59:18.641]                     is.null <- base::is.null
[17:59:18.641]                     muffled <- FALSE
[17:59:18.641]                     if (inherits(cond, "message")) {
[17:59:18.641]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:18.641]                       if (muffled) 
[17:59:18.641]                         invokeRestart("muffleMessage")
[17:59:18.641]                     }
[17:59:18.641]                     else if (inherits(cond, "warning")) {
[17:59:18.641]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:18.641]                       if (muffled) 
[17:59:18.641]                         invokeRestart("muffleWarning")
[17:59:18.641]                     }
[17:59:18.641]                     else if (inherits(cond, "condition")) {
[17:59:18.641]                       if (!is.null(pattern)) {
[17:59:18.641]                         computeRestarts <- base::computeRestarts
[17:59:18.641]                         grepl <- base::grepl
[17:59:18.641]                         restarts <- computeRestarts(cond)
[17:59:18.641]                         for (restart in restarts) {
[17:59:18.641]                           name <- restart$name
[17:59:18.641]                           if (is.null(name)) 
[17:59:18.641]                             next
[17:59:18.641]                           if (!grepl(pattern, name)) 
[17:59:18.641]                             next
[17:59:18.641]                           invokeRestart(restart)
[17:59:18.641]                           muffled <- TRUE
[17:59:18.641]                           break
[17:59:18.641]                         }
[17:59:18.641]                       }
[17:59:18.641]                     }
[17:59:18.641]                     invisible(muffled)
[17:59:18.641]                   }
[17:59:18.641]                   muffleCondition(cond)
[17:59:18.641]                 })
[17:59:18.641]             }))
[17:59:18.641]             future::FutureResult(value = ...future.value$value, 
[17:59:18.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.641]                   ...future.rng), globalenv = if (FALSE) 
[17:59:18.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:18.641]                     ...future.globalenv.names))
[17:59:18.641]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:18.641]         }, condition = base::local({
[17:59:18.641]             c <- base::c
[17:59:18.641]             inherits <- base::inherits
[17:59:18.641]             invokeRestart <- base::invokeRestart
[17:59:18.641]             length <- base::length
[17:59:18.641]             list <- base::list
[17:59:18.641]             seq.int <- base::seq.int
[17:59:18.641]             signalCondition <- base::signalCondition
[17:59:18.641]             sys.calls <- base::sys.calls
[17:59:18.641]             `[[` <- base::`[[`
[17:59:18.641]             `+` <- base::`+`
[17:59:18.641]             `<<-` <- base::`<<-`
[17:59:18.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:18.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:18.641]                   3L)]
[17:59:18.641]             }
[17:59:18.641]             function(cond) {
[17:59:18.641]                 is_error <- inherits(cond, "error")
[17:59:18.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:18.641]                   NULL)
[17:59:18.641]                 if (is_error) {
[17:59:18.641]                   sessionInformation <- function() {
[17:59:18.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:18.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:18.641]                       search = base::search(), system = base::Sys.info())
[17:59:18.641]                   }
[17:59:18.641]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:18.641]                     cond$call), session = sessionInformation(), 
[17:59:18.641]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:18.641]                   signalCondition(cond)
[17:59:18.641]                 }
[17:59:18.641]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:59:18.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:18.641]                   ...future.conditions[[length(...future.conditions) + 
[17:59:18.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:18.641]                   if (TRUE && !signal) {
[17:59:18.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.641]                     {
[17:59:18.641]                       inherits <- base::inherits
[17:59:18.641]                       invokeRestart <- base::invokeRestart
[17:59:18.641]                       is.null <- base::is.null
[17:59:18.641]                       muffled <- FALSE
[17:59:18.641]                       if (inherits(cond, "message")) {
[17:59:18.641]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.641]                         if (muffled) 
[17:59:18.641]                           invokeRestart("muffleMessage")
[17:59:18.641]                       }
[17:59:18.641]                       else if (inherits(cond, "warning")) {
[17:59:18.641]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.641]                         if (muffled) 
[17:59:18.641]                           invokeRestart("muffleWarning")
[17:59:18.641]                       }
[17:59:18.641]                       else if (inherits(cond, "condition")) {
[17:59:18.641]                         if (!is.null(pattern)) {
[17:59:18.641]                           computeRestarts <- base::computeRestarts
[17:59:18.641]                           grepl <- base::grepl
[17:59:18.641]                           restarts <- computeRestarts(cond)
[17:59:18.641]                           for (restart in restarts) {
[17:59:18.641]                             name <- restart$name
[17:59:18.641]                             if (is.null(name)) 
[17:59:18.641]                               next
[17:59:18.641]                             if (!grepl(pattern, name)) 
[17:59:18.641]                               next
[17:59:18.641]                             invokeRestart(restart)
[17:59:18.641]                             muffled <- TRUE
[17:59:18.641]                             break
[17:59:18.641]                           }
[17:59:18.641]                         }
[17:59:18.641]                       }
[17:59:18.641]                       invisible(muffled)
[17:59:18.641]                     }
[17:59:18.641]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.641]                   }
[17:59:18.641]                 }
[17:59:18.641]                 else {
[17:59:18.641]                   if (TRUE) {
[17:59:18.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:18.641]                     {
[17:59:18.641]                       inherits <- base::inherits
[17:59:18.641]                       invokeRestart <- base::invokeRestart
[17:59:18.641]                       is.null <- base::is.null
[17:59:18.641]                       muffled <- FALSE
[17:59:18.641]                       if (inherits(cond, "message")) {
[17:59:18.641]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:18.641]                         if (muffled) 
[17:59:18.641]                           invokeRestart("muffleMessage")
[17:59:18.641]                       }
[17:59:18.641]                       else if (inherits(cond, "warning")) {
[17:59:18.641]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:18.641]                         if (muffled) 
[17:59:18.641]                           invokeRestart("muffleWarning")
[17:59:18.641]                       }
[17:59:18.641]                       else if (inherits(cond, "condition")) {
[17:59:18.641]                         if (!is.null(pattern)) {
[17:59:18.641]                           computeRestarts <- base::computeRestarts
[17:59:18.641]                           grepl <- base::grepl
[17:59:18.641]                           restarts <- computeRestarts(cond)
[17:59:18.641]                           for (restart in restarts) {
[17:59:18.641]                             name <- restart$name
[17:59:18.641]                             if (is.null(name)) 
[17:59:18.641]                               next
[17:59:18.641]                             if (!grepl(pattern, name)) 
[17:59:18.641]                               next
[17:59:18.641]                             invokeRestart(restart)
[17:59:18.641]                             muffled <- TRUE
[17:59:18.641]                             break
[17:59:18.641]                           }
[17:59:18.641]                         }
[17:59:18.641]                       }
[17:59:18.641]                       invisible(muffled)
[17:59:18.641]                     }
[17:59:18.641]                     muffleCondition(cond, pattern = "^muffle")
[17:59:18.641]                   }
[17:59:18.641]                 }
[17:59:18.641]             }
[17:59:18.641]         }))
[17:59:18.641]     }, error = function(ex) {
[17:59:18.641]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:18.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:18.641]                 ...future.rng), started = ...future.startTime, 
[17:59:18.641]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:18.641]             version = "1.8"), class = "FutureResult")
[17:59:18.641]     }, finally = {
[17:59:18.641]         if (!identical(...future.workdir, getwd())) 
[17:59:18.641]             setwd(...future.workdir)
[17:59:18.641]         {
[17:59:18.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:18.641]                 ...future.oldOptions$nwarnings <- NULL
[17:59:18.641]             }
[17:59:18.641]             base::options(...future.oldOptions)
[17:59:18.641]             if (.Platform$OS.type == "windows") {
[17:59:18.641]                 old_names <- names(...future.oldEnvVars)
[17:59:18.641]                 envs <- base::Sys.getenv()
[17:59:18.641]                 names <- names(envs)
[17:59:18.641]                 common <- intersect(names, old_names)
[17:59:18.641]                 added <- setdiff(names, old_names)
[17:59:18.641]                 removed <- setdiff(old_names, names)
[17:59:18.641]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:18.641]                   envs[common]]
[17:59:18.641]                 NAMES <- toupper(changed)
[17:59:18.641]                 args <- list()
[17:59:18.641]                 for (kk in seq_along(NAMES)) {
[17:59:18.641]                   name <- changed[[kk]]
[17:59:18.641]                   NAME <- NAMES[[kk]]
[17:59:18.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.641]                     next
[17:59:18.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.641]                 }
[17:59:18.641]                 NAMES <- toupper(added)
[17:59:18.641]                 for (kk in seq_along(NAMES)) {
[17:59:18.641]                   name <- added[[kk]]
[17:59:18.641]                   NAME <- NAMES[[kk]]
[17:59:18.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.641]                     next
[17:59:18.641]                   args[[name]] <- ""
[17:59:18.641]                 }
[17:59:18.641]                 NAMES <- toupper(removed)
[17:59:18.641]                 for (kk in seq_along(NAMES)) {
[17:59:18.641]                   name <- removed[[kk]]
[17:59:18.641]                   NAME <- NAMES[[kk]]
[17:59:18.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:18.641]                     next
[17:59:18.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:18.641]                 }
[17:59:18.641]                 if (length(args) > 0) 
[17:59:18.641]                   base::do.call(base::Sys.setenv, args = args)
[17:59:18.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:18.641]             }
[17:59:18.641]             else {
[17:59:18.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:18.641]             }
[17:59:18.641]             {
[17:59:18.641]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:18.641]                   0L) {
[17:59:18.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:18.641]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:18.641]                   base::options(opts)
[17:59:18.641]                 }
[17:59:18.641]                 {
[17:59:18.641]                   {
[17:59:18.641]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:18.641]                     NULL
[17:59:18.641]                   }
[17:59:18.641]                   options(future.plan = NULL)
[17:59:18.641]                   if (is.na(NA_character_)) 
[17:59:18.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:18.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:18.641]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:18.641]                     .init = FALSE)
[17:59:18.641]                 }
[17:59:18.641]             }
[17:59:18.641]         }
[17:59:18.641]     })
[17:59:18.641]     if (TRUE) {
[17:59:18.641]         base::sink(type = "output", split = FALSE)
[17:59:18.641]         if (TRUE) {
[17:59:18.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:18.641]         }
[17:59:18.641]         else {
[17:59:18.641]             ...future.result["stdout"] <- base::list(NULL)
[17:59:18.641]         }
[17:59:18.641]         base::close(...future.stdout)
[17:59:18.641]         ...future.stdout <- NULL
[17:59:18.641]     }
[17:59:18.641]     ...future.result$conditions <- ...future.conditions
[17:59:18.641]     ...future.result$finished <- base::Sys.time()
[17:59:18.641]     ...future.result
[17:59:18.641] }
[17:59:18.649] assign_globals() ...
[17:59:18.649] List of 5
[17:59:18.649]  $ future.call.arguments    : list()
[17:59:18.649]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:18.649]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:59:18.649]  $ ...future.elements_ii    :List of 1
[17:59:18.649]   ..$ : int [1:2] 2 4
[17:59:18.649]  $ ...future.seeds_ii       :List of 1
[17:59:18.649]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:59:18.649]  $ ...future.globals.maxSize: num Inf
[17:59:18.649]  - attr(*, "resolved")= logi FALSE
[17:59:18.649]  - attr(*, "total_size")= num NA
[17:59:18.649]  - attr(*, "where")=List of 5
[17:59:18.649]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:18.649]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:18.649]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:18.649]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:18.649]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:18.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:18.649]  - attr(*, "already-done")= logi TRUE
[17:59:18.666] - copied ‘future.call.arguments’ to environment
[17:59:18.666] - copied ‘...future.FUN’ to environment
[17:59:18.666] - copied ‘...future.elements_ii’ to environment
[17:59:18.667] - copied ‘...future.seeds_ii’ to environment
[17:59:18.667] - copied ‘...future.globals.maxSize’ to environment
[17:59:18.667] assign_globals() ... done
[17:59:18.668] requestCore(): workers = 2
[17:59:18.672] MulticoreFuture started
[17:59:18.674] - Launch lazy future ... done
[17:59:18.688] plan(): Setting new future strategy stack:
[17:59:18.687] run() for ‘MulticoreFuture’ ... done
[17:59:18.691] Created future:
[17:59:18.689] List of future strategies:
[17:59:18.689] 1. sequential:
[17:59:18.689]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:18.689]    - tweaked: FALSE
[17:59:18.689]    - call: NULL
[17:59:18.697] plan(): nbrOfWorkers() = 1
[17:59:18.707] plan(): Setting new future strategy stack:
[17:59:18.708] List of future strategies:
[17:59:18.708] 1. multicore:
[17:59:18.708]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:18.708]    - tweaked: FALSE
[17:59:18.708]    - call: plan(strategy)
[17:59:18.691] MulticoreFuture:
[17:59:18.691] Label: ‘future_apply-2’
[17:59:18.691] Expression:
[17:59:18.691] {
[17:59:18.691]     do.call(function(...) {
[17:59:18.691]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:18.691]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:18.691]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:18.691]             on.exit(options(oopts), add = TRUE)
[17:59:18.691]         }
[17:59:18.691]         {
[17:59:18.691]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:18.691]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:18.691]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:18.691]                   envir = globalenv(), inherits = FALSE)
[17:59:18.691]                 ...future.FUN(...future.X_jj, ...)
[17:59:18.691]             })
[17:59:18.691]         }
[17:59:18.691]     }, args = future.call.arguments)
[17:59:18.691] }
[17:59:18.691] Lazy evaluation: FALSE
[17:59:18.691] Asynchronous evaluation: TRUE
[17:59:18.691] Local evaluation: TRUE
[17:59:18.691] Environment: R_GlobalEnv
[17:59:18.691] Capture standard output: TRUE
[17:59:18.691] Capture condition classes: <none>
[17:59:18.691] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:18.691] Packages: <none>
[17:59:18.691] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:59:18.691] Resolved: FALSE
[17:59:18.691] Value: <not collected>
[17:59:18.691] Conditions captured: <none>
[17:59:18.691] Early signaling: FALSE
[17:59:18.691] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:18.691] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:18.719] Chunk #2 of 2 ... DONE
[17:59:18.722] Launching 2 futures (chunks) ... DONE
[17:59:18.722] Resolving 2 futures (chunks) ...
[17:59:18.726] resolve() on list ...
[17:59:18.729]  recursive: 0
[17:59:18.730] plan(): nbrOfWorkers() = 2
[17:59:18.730]  length: 2
[17:59:18.734] 
[17:59:18.735] Future #1
[17:59:18.736] result() for MulticoreFuture ...
[17:59:18.738] result() for MulticoreFuture ...
[17:59:18.738] result() for MulticoreFuture ... done
[17:59:18.740] result() for MulticoreFuture ... done
[17:59:18.740] result() for MulticoreFuture ...
[17:59:18.741] result() for MulticoreFuture ... done
[17:59:18.741] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:18.742] - nx: 2
[17:59:18.745] - relay: TRUE
[17:59:18.746] - stdout: TRUE
[17:59:18.746] - signal: TRUE
[17:59:18.746] - resignal: FALSE
[17:59:18.747] - force: TRUE
[17:59:18.747] - relayed: [n=2] FALSE, FALSE
[17:59:18.747] - queued futures: [n=2] FALSE, FALSE
[17:59:18.750]  - until=1
[17:59:18.750]  - relaying element #1
[17:59:18.751] result() for MulticoreFuture ...
[17:59:18.751] result() for MulticoreFuture ... done
[17:59:18.755] result() for MulticoreFuture ...
[17:59:18.755] result() for MulticoreFuture ... done
[17:59:18.756] result() for MulticoreFuture ...
[17:59:18.756] result() for MulticoreFuture ... done
[17:59:18.757] result() for MulticoreFuture ...
[17:59:18.757] result() for MulticoreFuture ... done
[17:59:18.757] - relayed: [n=2] TRUE, FALSE
[17:59:18.758] - queued futures: [n=2] TRUE, FALSE
[17:59:18.759] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:18.759]  length: 1 (resolved future 1)
[17:59:18.760] Future #2
[17:59:18.761] result() for MulticoreFuture ...
[17:59:18.763] result() for MulticoreFuture ...
[17:59:18.764] result() for MulticoreFuture ... done
[17:59:18.768] result() for MulticoreFuture ... done
[17:59:18.771] result() for MulticoreFuture ...
[17:59:18.771] result() for MulticoreFuture ... done
[17:59:18.772] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:18.772] - nx: 2
[17:59:18.772] - relay: TRUE
[17:59:18.773] - stdout: TRUE
[17:59:18.774] - signal: TRUE
[17:59:18.774] - resignal: FALSE
[17:59:18.774] - force: TRUE
[17:59:18.775] - relayed: [n=2] TRUE, FALSE
[17:59:18.775] - queued futures: [n=2] TRUE, FALSE
[17:59:18.775]  - until=2
[17:59:18.776]  - relaying element #2
[17:59:18.778] result() for MulticoreFuture ...
[17:59:18.779] result() for MulticoreFuture ... done
[17:59:18.779] result() for MulticoreFuture ...
[17:59:18.779] result() for MulticoreFuture ... done
[17:59:18.780] result() for MulticoreFuture ...
[17:59:18.780] result() for MulticoreFuture ... done
[17:59:18.780] result() for MulticoreFuture ...
[17:59:18.780] result() for MulticoreFuture ... done
[17:59:18.781] - relayed: [n=2] TRUE, TRUE
[17:59:18.782] - queued futures: [n=2] TRUE, TRUE
[17:59:18.782] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:18.783]  length: 0 (resolved future 2)
[17:59:18.784] Relaying remaining futures
[17:59:18.784] signalConditionsASAP(NULL, pos=0) ...
[17:59:18.784] - nx: 2
[17:59:18.785] - relay: TRUE
[17:59:18.785] - stdout: TRUE
[17:59:18.785] - signal: TRUE
[17:59:18.785] - resignal: FALSE
[17:59:18.786] - force: TRUE
[17:59:18.786] - relayed: [n=2] TRUE, TRUE
[17:59:18.788] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:18.789] - relayed: [n=2] TRUE, TRUE
[17:59:18.789] - queued futures: [n=2] TRUE, TRUE
[17:59:18.789] signalConditionsASAP(NULL, pos=0) ... done
[17:59:18.789] resolve() on list ... DONE
[17:59:18.790] result() for MulticoreFuture ...
[17:59:18.790] result() for MulticoreFuture ... done
[17:59:18.790] result() for MulticoreFuture ...
[17:59:18.790] result() for MulticoreFuture ... done
[17:59:18.791] result() for MulticoreFuture ...
[17:59:18.791] result() for MulticoreFuture ... done
[17:59:18.791] result() for MulticoreFuture ...
[17:59:18.791] result() for MulticoreFuture ... done
[17:59:18.792]  - Number of value chunks collected: 2
[17:59:18.794] Resolving 2 futures (chunks) ... DONE
[17:59:18.794] Reducing values from 2 chunks ...
[17:59:18.795]  - Number of values collected after concatenation: 2
[17:59:18.795]  - Number of values expected: 2
[17:59:18.795] Reducing values from 2 chunks ... DONE
[17:59:18.795] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:59:18.798] plan(): Setting new future strategy stack:
[17:59:18.798] List of future strategies:
[17:59:18.798] 1. sequential:
[17:59:18.798]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:18.798]    - tweaked: FALSE
[17:59:18.798]    - call: plan(sequential)
[17:59:18.800] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:59:18.801] plan(): Setting new future strategy stack:
[17:59:18.802] List of future strategies:
[17:59:18.802] 1. multisession:
[17:59:18.802]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:18.802]    - tweaked: FALSE
[17:59:18.802]    - call: plan(strategy)
[17:59:18.803] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:59:18.804] multisession:
[17:59:18.804] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:18.804] - tweaked: FALSE
[17:59:18.804] - call: plan(strategy)
[17:59:18.822] getGlobalsAndPackages() ...
[17:59:18.822] Not searching for globals
[17:59:18.823] - globals: [0] <none>
[17:59:18.823] getGlobalsAndPackages() ... DONE
[17:59:18.825] [local output] makeClusterPSOCK() ...
[17:59:18.942] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:59:18.945] [local output] Base port: 11636
[17:59:18.946] [local output] Getting setup options for 2 cluster nodes ...
[17:59:18.946] [local output]  - Node 1 of 2 ...
[17:59:18.947] [local output] localMachine=TRUE => revtunnel=FALSE

[17:59:18.950] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp8GbN1e/worker.rank=1.parallelly.parent=307495.4b1276de0fed1.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp8GbN1e/worker.rank=1.parallelly.parent=307495.4b1276de0fed1.pid")'’
[17:59:19.276] - Possible to infer worker's PID: TRUE
[17:59:19.277] [local output] Rscript port: 11636

[17:59:19.278] [local output]  - Node 2 of 2 ...
[17:59:19.279] [local output] localMachine=TRUE => revtunnel=FALSE

[17:59:19.280] [local output] Rscript port: 11636

[17:59:19.281] [local output] Getting setup options for 2 cluster nodes ... done
[17:59:19.281] [local output]  - Parallel setup requested for some PSOCK nodes
[17:59:19.282] [local output] Setting up PSOCK nodes in parallel
[17:59:19.283] List of 36
[17:59:19.283]  $ worker          : chr "localhost"
[17:59:19.283]   ..- attr(*, "localhost")= logi TRUE
[17:59:19.283]  $ master          : chr "localhost"
[17:59:19.283]  $ port            : int 11636
[17:59:19.283]  $ connectTimeout  : num 120
[17:59:19.283]  $ timeout         : num 2592000
[17:59:19.283]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:59:19.283]  $ homogeneous     : logi TRUE
[17:59:19.283]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:59:19.283]  $ rscript_envs    : NULL
[17:59:19.283]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:59:19.283]  $ rscript_startup : NULL
[17:59:19.283]  $ rscript_sh      : chr "sh"
[17:59:19.283]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:59:19.283]  $ methods         : logi TRUE
[17:59:19.283]  $ socketOptions   : chr "no-delay"
[17:59:19.283]  $ useXDR          : logi FALSE
[17:59:19.283]  $ outfile         : chr "/dev/null"
[17:59:19.283]  $ renice          : int NA
[17:59:19.283]  $ rshcmd          : NULL
[17:59:19.283]  $ user            : chr(0) 
[17:59:19.283]  $ revtunnel       : logi FALSE
[17:59:19.283]  $ rshlogfile      : NULL
[17:59:19.283]  $ rshopts         : chr(0) 
[17:59:19.283]  $ rank            : int 1
[17:59:19.283]  $ manual          : logi FALSE
[17:59:19.283]  $ dryrun          : logi FALSE
[17:59:19.283]  $ quiet           : logi FALSE
[17:59:19.283]  $ setup_strategy  : chr "parallel"
[17:59:19.283]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:59:19.283]  $ pidfile         : chr "/tmp/Rtmp8GbN1e/worker.rank=1.parallelly.parent=307495.4b1276de0fed1.pid"
[17:59:19.283]  $ rshcmd_label    : NULL
[17:59:19.283]  $ rsh_call        : NULL
[17:59:19.283]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:59:19.283]  $ localMachine    : logi TRUE
[17:59:19.283]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:59:19.283]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:59:19.283]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:59:19.283]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:59:19.283]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:59:19.283]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:59:19.283]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:59:19.283]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:59:19.283]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:59:19.283]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:59:19.283]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:59:19.283]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:59:19.283]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:59:19.283]  $ arguments       :List of 28
[17:59:19.283]   ..$ worker          : chr "localhost"
[17:59:19.283]   ..$ master          : NULL
[17:59:19.283]   ..$ port            : int 11636
[17:59:19.283]   ..$ connectTimeout  : num 120
[17:59:19.283]   ..$ timeout         : num 2592000
[17:59:19.283]   ..$ rscript         : NULL
[17:59:19.283]   ..$ homogeneous     : NULL
[17:59:19.283]   ..$ rscript_args    : NULL
[17:59:19.283]   ..$ rscript_envs    : NULL
[17:59:19.283]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:59:19.283]   ..$ rscript_startup : NULL
[17:59:19.283]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:59:19.283]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:59:19.283]   ..$ methods         : logi TRUE
[17:59:19.283]   ..$ socketOptions   : chr "no-delay"
[17:59:19.283]   ..$ useXDR          : logi FALSE
[17:59:19.283]   ..$ outfile         : chr "/dev/null"
[17:59:19.283]   ..$ renice          : int NA
[17:59:19.283]   ..$ rshcmd          : NULL
[17:59:19.283]   ..$ user            : NULL
[17:59:19.283]   ..$ revtunnel       : logi NA
[17:59:19.283]   ..$ rshlogfile      : NULL
[17:59:19.283]   ..$ rshopts         : NULL
[17:59:19.283]   ..$ rank            : int 1
[17:59:19.283]   ..$ manual          : logi FALSE
[17:59:19.283]   ..$ dryrun          : logi FALSE
[17:59:19.283]   ..$ quiet           : logi FALSE
[17:59:19.283]   ..$ setup_strategy  : chr "parallel"
[17:59:19.283]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:59:19.316] [local output] System call to launch all workers:
[17:59:19.317] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp8GbN1e/worker.rank=1.parallelly.parent=307495.4b1276de0fed1.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11636 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:59:19.317] [local output] Starting PSOCK main server
[17:59:19.326] [local output] Workers launched
[17:59:19.326] [local output] Waiting for workers to connect back
[17:59:19.326]  - [local output] 0 workers out of 2 ready
[17:59:19.771]  - [local output] 0 workers out of 2 ready
[17:59:19.772]  - [local output] 1 workers out of 2 ready
[17:59:19.772]  - [local output] 2 workers out of 2 ready
[17:59:19.772] [local output] Launching of workers completed
[17:59:19.773] [local output] Collecting session information from workers
[17:59:19.774] [local output]  - Worker #1 of 2
[17:59:19.775] [local output]  - Worker #2 of 2
[17:59:19.776] [local output] makeClusterPSOCK() ... done
[17:59:19.795] Packages needed by the future expression (n = 0): <none>
[17:59:19.795] Packages needed by future strategies (n = 0): <none>
[17:59:19.796] {
[17:59:19.796]     {
[17:59:19.796]         {
[17:59:19.796]             ...future.startTime <- base::Sys.time()
[17:59:19.796]             {
[17:59:19.796]                 {
[17:59:19.796]                   {
[17:59:19.796]                     {
[17:59:19.796]                       base::local({
[17:59:19.796]                         has_future <- base::requireNamespace("future", 
[17:59:19.796]                           quietly = TRUE)
[17:59:19.796]                         if (has_future) {
[17:59:19.796]                           ns <- base::getNamespace("future")
[17:59:19.796]                           version <- ns[[".package"]][["version"]]
[17:59:19.796]                           if (is.null(version)) 
[17:59:19.796]                             version <- utils::packageVersion("future")
[17:59:19.796]                         }
[17:59:19.796]                         else {
[17:59:19.796]                           version <- NULL
[17:59:19.796]                         }
[17:59:19.796]                         if (!has_future || version < "1.8.0") {
[17:59:19.796]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:19.796]                             "", base::R.version$version.string), 
[17:59:19.796]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:19.796]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:19.796]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:19.796]                               "release", "version")], collapse = " "), 
[17:59:19.796]                             hostname = base::Sys.info()[["nodename"]])
[17:59:19.796]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:19.796]                             info)
[17:59:19.796]                           info <- base::paste(info, collapse = "; ")
[17:59:19.796]                           if (!has_future) {
[17:59:19.796]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:19.796]                               info)
[17:59:19.796]                           }
[17:59:19.796]                           else {
[17:59:19.796]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:19.796]                               info, version)
[17:59:19.796]                           }
[17:59:19.796]                           base::stop(msg)
[17:59:19.796]                         }
[17:59:19.796]                       })
[17:59:19.796]                     }
[17:59:19.796]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:19.796]                     base::options(mc.cores = 1L)
[17:59:19.796]                   }
[17:59:19.796]                   ...future.strategy.old <- future::plan("list")
[17:59:19.796]                   options(future.plan = NULL)
[17:59:19.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:19.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:19.796]                 }
[17:59:19.796]                 ...future.workdir <- getwd()
[17:59:19.796]             }
[17:59:19.796]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:19.796]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:19.796]         }
[17:59:19.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:19.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:19.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:19.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:19.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:19.796]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:19.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:19.796]             base::names(...future.oldOptions))
[17:59:19.796]     }
[17:59:19.796]     if (FALSE) {
[17:59:19.796]     }
[17:59:19.796]     else {
[17:59:19.796]         if (TRUE) {
[17:59:19.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:19.796]                 open = "w")
[17:59:19.796]         }
[17:59:19.796]         else {
[17:59:19.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:19.796]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:19.796]         }
[17:59:19.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:19.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:19.796]             base::sink(type = "output", split = FALSE)
[17:59:19.796]             base::close(...future.stdout)
[17:59:19.796]         }, add = TRUE)
[17:59:19.796]     }
[17:59:19.796]     ...future.frame <- base::sys.nframe()
[17:59:19.796]     ...future.conditions <- base::list()
[17:59:19.796]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:19.796]     if (FALSE) {
[17:59:19.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:19.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:19.796]     }
[17:59:19.796]     ...future.result <- base::tryCatch({
[17:59:19.796]         base::withCallingHandlers({
[17:59:19.796]             ...future.value <- base::withVisible(base::local({
[17:59:19.796]                 ...future.makeSendCondition <- base::local({
[17:59:19.796]                   sendCondition <- NULL
[17:59:19.796]                   function(frame = 1L) {
[17:59:19.796]                     if (is.function(sendCondition)) 
[17:59:19.796]                       return(sendCondition)
[17:59:19.796]                     ns <- getNamespace("parallel")
[17:59:19.796]                     if (exists("sendData", mode = "function", 
[17:59:19.796]                       envir = ns)) {
[17:59:19.796]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:19.796]                         envir = ns)
[17:59:19.796]                       envir <- sys.frame(frame)
[17:59:19.796]                       master <- NULL
[17:59:19.796]                       while (!identical(envir, .GlobalEnv) && 
[17:59:19.796]                         !identical(envir, emptyenv())) {
[17:59:19.796]                         if (exists("master", mode = "list", envir = envir, 
[17:59:19.796]                           inherits = FALSE)) {
[17:59:19.796]                           master <- get("master", mode = "list", 
[17:59:19.796]                             envir = envir, inherits = FALSE)
[17:59:19.796]                           if (inherits(master, c("SOCKnode", 
[17:59:19.796]                             "SOCK0node"))) {
[17:59:19.796]                             sendCondition <<- function(cond) {
[17:59:19.796]                               data <- list(type = "VALUE", value = cond, 
[17:59:19.796]                                 success = TRUE)
[17:59:19.796]                               parallel_sendData(master, data)
[17:59:19.796]                             }
[17:59:19.796]                             return(sendCondition)
[17:59:19.796]                           }
[17:59:19.796]                         }
[17:59:19.796]                         frame <- frame + 1L
[17:59:19.796]                         envir <- sys.frame(frame)
[17:59:19.796]                       }
[17:59:19.796]                     }
[17:59:19.796]                     sendCondition <<- function(cond) NULL
[17:59:19.796]                   }
[17:59:19.796]                 })
[17:59:19.796]                 withCallingHandlers({
[17:59:19.796]                   NA
[17:59:19.796]                 }, immediateCondition = function(cond) {
[17:59:19.796]                   sendCondition <- ...future.makeSendCondition()
[17:59:19.796]                   sendCondition(cond)
[17:59:19.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:19.796]                   {
[17:59:19.796]                     inherits <- base::inherits
[17:59:19.796]                     invokeRestart <- base::invokeRestart
[17:59:19.796]                     is.null <- base::is.null
[17:59:19.796]                     muffled <- FALSE
[17:59:19.796]                     if (inherits(cond, "message")) {
[17:59:19.796]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:19.796]                       if (muffled) 
[17:59:19.796]                         invokeRestart("muffleMessage")
[17:59:19.796]                     }
[17:59:19.796]                     else if (inherits(cond, "warning")) {
[17:59:19.796]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:19.796]                       if (muffled) 
[17:59:19.796]                         invokeRestart("muffleWarning")
[17:59:19.796]                     }
[17:59:19.796]                     else if (inherits(cond, "condition")) {
[17:59:19.796]                       if (!is.null(pattern)) {
[17:59:19.796]                         computeRestarts <- base::computeRestarts
[17:59:19.796]                         grepl <- base::grepl
[17:59:19.796]                         restarts <- computeRestarts(cond)
[17:59:19.796]                         for (restart in restarts) {
[17:59:19.796]                           name <- restart$name
[17:59:19.796]                           if (is.null(name)) 
[17:59:19.796]                             next
[17:59:19.796]                           if (!grepl(pattern, name)) 
[17:59:19.796]                             next
[17:59:19.796]                           invokeRestart(restart)
[17:59:19.796]                           muffled <- TRUE
[17:59:19.796]                           break
[17:59:19.796]                         }
[17:59:19.796]                       }
[17:59:19.796]                     }
[17:59:19.796]                     invisible(muffled)
[17:59:19.796]                   }
[17:59:19.796]                   muffleCondition(cond)
[17:59:19.796]                 })
[17:59:19.796]             }))
[17:59:19.796]             future::FutureResult(value = ...future.value$value, 
[17:59:19.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:19.796]                   ...future.rng), globalenv = if (FALSE) 
[17:59:19.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:19.796]                     ...future.globalenv.names))
[17:59:19.796]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:19.796]         }, condition = base::local({
[17:59:19.796]             c <- base::c
[17:59:19.796]             inherits <- base::inherits
[17:59:19.796]             invokeRestart <- base::invokeRestart
[17:59:19.796]             length <- base::length
[17:59:19.796]             list <- base::list
[17:59:19.796]             seq.int <- base::seq.int
[17:59:19.796]             signalCondition <- base::signalCondition
[17:59:19.796]             sys.calls <- base::sys.calls
[17:59:19.796]             `[[` <- base::`[[`
[17:59:19.796]             `+` <- base::`+`
[17:59:19.796]             `<<-` <- base::`<<-`
[17:59:19.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:19.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:19.796]                   3L)]
[17:59:19.796]             }
[17:59:19.796]             function(cond) {
[17:59:19.796]                 is_error <- inherits(cond, "error")
[17:59:19.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:19.796]                   NULL)
[17:59:19.796]                 if (is_error) {
[17:59:19.796]                   sessionInformation <- function() {
[17:59:19.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:19.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:19.796]                       search = base::search(), system = base::Sys.info())
[17:59:19.796]                   }
[17:59:19.796]                   ...future.conditions[[length(...future.conditions) + 
[17:59:19.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:19.796]                     cond$call), session = sessionInformation(), 
[17:59:19.796]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:19.796]                   signalCondition(cond)
[17:59:19.796]                 }
[17:59:19.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:19.796]                 "immediateCondition"))) {
[17:59:19.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:19.796]                   ...future.conditions[[length(...future.conditions) + 
[17:59:19.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:19.796]                   if (TRUE && !signal) {
[17:59:19.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:19.796]                     {
[17:59:19.796]                       inherits <- base::inherits
[17:59:19.796]                       invokeRestart <- base::invokeRestart
[17:59:19.796]                       is.null <- base::is.null
[17:59:19.796]                       muffled <- FALSE
[17:59:19.796]                       if (inherits(cond, "message")) {
[17:59:19.796]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:19.796]                         if (muffled) 
[17:59:19.796]                           invokeRestart("muffleMessage")
[17:59:19.796]                       }
[17:59:19.796]                       else if (inherits(cond, "warning")) {
[17:59:19.796]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:19.796]                         if (muffled) 
[17:59:19.796]                           invokeRestart("muffleWarning")
[17:59:19.796]                       }
[17:59:19.796]                       else if (inherits(cond, "condition")) {
[17:59:19.796]                         if (!is.null(pattern)) {
[17:59:19.796]                           computeRestarts <- base::computeRestarts
[17:59:19.796]                           grepl <- base::grepl
[17:59:19.796]                           restarts <- computeRestarts(cond)
[17:59:19.796]                           for (restart in restarts) {
[17:59:19.796]                             name <- restart$name
[17:59:19.796]                             if (is.null(name)) 
[17:59:19.796]                               next
[17:59:19.796]                             if (!grepl(pattern, name)) 
[17:59:19.796]                               next
[17:59:19.796]                             invokeRestart(restart)
[17:59:19.796]                             muffled <- TRUE
[17:59:19.796]                             break
[17:59:19.796]                           }
[17:59:19.796]                         }
[17:59:19.796]                       }
[17:59:19.796]                       invisible(muffled)
[17:59:19.796]                     }
[17:59:19.796]                     muffleCondition(cond, pattern = "^muffle")
[17:59:19.796]                   }
[17:59:19.796]                 }
[17:59:19.796]                 else {
[17:59:19.796]                   if (TRUE) {
[17:59:19.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:19.796]                     {
[17:59:19.796]                       inherits <- base::inherits
[17:59:19.796]                       invokeRestart <- base::invokeRestart
[17:59:19.796]                       is.null <- base::is.null
[17:59:19.796]                       muffled <- FALSE
[17:59:19.796]                       if (inherits(cond, "message")) {
[17:59:19.796]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:19.796]                         if (muffled) 
[17:59:19.796]                           invokeRestart("muffleMessage")
[17:59:19.796]                       }
[17:59:19.796]                       else if (inherits(cond, "warning")) {
[17:59:19.796]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:19.796]                         if (muffled) 
[17:59:19.796]                           invokeRestart("muffleWarning")
[17:59:19.796]                       }
[17:59:19.796]                       else if (inherits(cond, "condition")) {
[17:59:19.796]                         if (!is.null(pattern)) {
[17:59:19.796]                           computeRestarts <- base::computeRestarts
[17:59:19.796]                           grepl <- base::grepl
[17:59:19.796]                           restarts <- computeRestarts(cond)
[17:59:19.796]                           for (restart in restarts) {
[17:59:19.796]                             name <- restart$name
[17:59:19.796]                             if (is.null(name)) 
[17:59:19.796]                               next
[17:59:19.796]                             if (!grepl(pattern, name)) 
[17:59:19.796]                               next
[17:59:19.796]                             invokeRestart(restart)
[17:59:19.796]                             muffled <- TRUE
[17:59:19.796]                             break
[17:59:19.796]                           }
[17:59:19.796]                         }
[17:59:19.796]                       }
[17:59:19.796]                       invisible(muffled)
[17:59:19.796]                     }
[17:59:19.796]                     muffleCondition(cond, pattern = "^muffle")
[17:59:19.796]                   }
[17:59:19.796]                 }
[17:59:19.796]             }
[17:59:19.796]         }))
[17:59:19.796]     }, error = function(ex) {
[17:59:19.796]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:19.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:19.796]                 ...future.rng), started = ...future.startTime, 
[17:59:19.796]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:19.796]             version = "1.8"), class = "FutureResult")
[17:59:19.796]     }, finally = {
[17:59:19.796]         if (!identical(...future.workdir, getwd())) 
[17:59:19.796]             setwd(...future.workdir)
[17:59:19.796]         {
[17:59:19.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:19.796]                 ...future.oldOptions$nwarnings <- NULL
[17:59:19.796]             }
[17:59:19.796]             base::options(...future.oldOptions)
[17:59:19.796]             if (.Platform$OS.type == "windows") {
[17:59:19.796]                 old_names <- names(...future.oldEnvVars)
[17:59:19.796]                 envs <- base::Sys.getenv()
[17:59:19.796]                 names <- names(envs)
[17:59:19.796]                 common <- intersect(names, old_names)
[17:59:19.796]                 added <- setdiff(names, old_names)
[17:59:19.796]                 removed <- setdiff(old_names, names)
[17:59:19.796]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:19.796]                   envs[common]]
[17:59:19.796]                 NAMES <- toupper(changed)
[17:59:19.796]                 args <- list()
[17:59:19.796]                 for (kk in seq_along(NAMES)) {
[17:59:19.796]                   name <- changed[[kk]]
[17:59:19.796]                   NAME <- NAMES[[kk]]
[17:59:19.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:19.796]                     next
[17:59:19.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:19.796]                 }
[17:59:19.796]                 NAMES <- toupper(added)
[17:59:19.796]                 for (kk in seq_along(NAMES)) {
[17:59:19.796]                   name <- added[[kk]]
[17:59:19.796]                   NAME <- NAMES[[kk]]
[17:59:19.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:19.796]                     next
[17:59:19.796]                   args[[name]] <- ""
[17:59:19.796]                 }
[17:59:19.796]                 NAMES <- toupper(removed)
[17:59:19.796]                 for (kk in seq_along(NAMES)) {
[17:59:19.796]                   name <- removed[[kk]]
[17:59:19.796]                   NAME <- NAMES[[kk]]
[17:59:19.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:19.796]                     next
[17:59:19.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:19.796]                 }
[17:59:19.796]                 if (length(args) > 0) 
[17:59:19.796]                   base::do.call(base::Sys.setenv, args = args)
[17:59:19.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:19.796]             }
[17:59:19.796]             else {
[17:59:19.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:19.796]             }
[17:59:19.796]             {
[17:59:19.796]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:19.796]                   0L) {
[17:59:19.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:19.796]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:19.796]                   base::options(opts)
[17:59:19.796]                 }
[17:59:19.796]                 {
[17:59:19.796]                   {
[17:59:19.796]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:19.796]                     NULL
[17:59:19.796]                   }
[17:59:19.796]                   options(future.plan = NULL)
[17:59:19.796]                   if (is.na(NA_character_)) 
[17:59:19.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:19.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:19.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:19.796]                     .init = FALSE)
[17:59:19.796]                 }
[17:59:19.796]             }
[17:59:19.796]         }
[17:59:19.796]     })
[17:59:19.796]     if (TRUE) {
[17:59:19.796]         base::sink(type = "output", split = FALSE)
[17:59:19.796]         if (TRUE) {
[17:59:19.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:19.796]         }
[17:59:19.796]         else {
[17:59:19.796]             ...future.result["stdout"] <- base::list(NULL)
[17:59:19.796]         }
[17:59:19.796]         base::close(...future.stdout)
[17:59:19.796]         ...future.stdout <- NULL
[17:59:19.796]     }
[17:59:19.796]     ...future.result$conditions <- ...future.conditions
[17:59:19.796]     ...future.result$finished <- base::Sys.time()
[17:59:19.796]     ...future.result
[17:59:19.796] }
[17:59:19.896] MultisessionFuture started
[17:59:19.897] result() for ClusterFuture ...
[17:59:19.898] receiveMessageFromWorker() for ClusterFuture ...
[17:59:19.898] - Validating connection of MultisessionFuture
[17:59:19.963] - received message: FutureResult
[17:59:19.963] - Received FutureResult
[17:59:19.963] - Erased future from FutureRegistry
[17:59:19.964] result() for ClusterFuture ...
[17:59:19.964] - result already collected: FutureResult
[17:59:19.964] result() for ClusterFuture ... done
[17:59:19.964] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:19.964] result() for ClusterFuture ... done
[17:59:19.965] result() for ClusterFuture ...
[17:59:19.965] - result already collected: FutureResult
[17:59:19.965] result() for ClusterFuture ... done
[17:59:19.965] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:59:19.971] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[17:59:19.973] getGlobalsAndPackagesXApply() ...
[17:59:19.973]  - future.globals: TRUE
[17:59:19.973] getGlobalsAndPackages() ...
[17:59:19.973] Searching for globals...
[17:59:20.057] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:59:20.058] Searching for globals ... DONE
[17:59:20.058] Resolving globals: FALSE
[17:59:20.065] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:59:20.065] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:59:20.066] - globals: [1] ‘FUN’
[17:59:20.066] 
[17:59:20.066] getGlobalsAndPackages() ... DONE
[17:59:20.066]  - globals found/used: [n=1] ‘FUN’
[17:59:20.066]  - needed namespaces: [n=0] 
[17:59:20.067] Finding globals ... DONE
[17:59:20.067]  - use_args: TRUE
[17:59:20.067]  - Getting '...' globals ...
[17:59:20.068] resolve() on list ...
[17:59:20.068]  recursive: 0
[17:59:20.068]  length: 1
[17:59:20.068]  elements: ‘...’
[17:59:20.068]  length: 0 (resolved future 1)
[17:59:20.069] resolve() on list ... DONE
[17:59:20.069]    - '...' content: [n=0] 
[17:59:20.069] List of 1
[17:59:20.069]  $ ...: list()
[17:59:20.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:20.069]  - attr(*, "where")=List of 1
[17:59:20.069]   ..$ ...:<environment: 0x56085c914050> 
[17:59:20.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:20.069]  - attr(*, "resolved")= logi TRUE
[17:59:20.069]  - attr(*, "total_size")= num NA
[17:59:20.074]  - Getting '...' globals ... DONE
[17:59:20.075] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:20.075] List of 2
[17:59:20.075]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:20.075]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:20.075]  $ ...          : list()
[17:59:20.075]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:20.075]  - attr(*, "where")=List of 2
[17:59:20.075]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:20.075]   ..$ ...          :<environment: 0x56085c914050> 
[17:59:20.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:20.075]  - attr(*, "resolved")= logi FALSE
[17:59:20.075]  - attr(*, "total_size")= num 354224
[17:59:20.080] Packages to be attached in all futures: [n=0] 
[17:59:20.080] getGlobalsAndPackagesXApply() ... DONE
[17:59:20.086] future_lapply() ...
[17:59:20.165] Number of chunks: 2
[17:59:20.166] getGlobalsAndPackagesXApply() ...
[17:59:20.169]  - future.globals: <name-value list> with names ‘list()’
[17:59:20.169]  - use_args: TRUE
[17:59:20.169] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:20.170] List of 2
[17:59:20.170]  $ ...          : list()
[17:59:20.170]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:20.170]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:20.170]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:20.170]  - attr(*, "where")=List of 2
[17:59:20.170]   ..$ ...          :<environment: 0x56085c914050> 
[17:59:20.170]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:20.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:20.170]  - attr(*, "resolved")= logi FALSE
[17:59:20.170]  - attr(*, "total_size")= num NA
[17:59:20.181] Packages to be attached in all futures: [n=0] 
[17:59:20.182] getGlobalsAndPackagesXApply() ... DONE
[17:59:20.182] Number of futures (= number of chunks): 2
[17:59:20.183] Launching 2 futures (chunks) ...
[17:59:20.183] Chunk #1 of 2 ...
[17:59:20.183]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:20.183]  - seeds: <none>
[17:59:20.184]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.184] getGlobalsAndPackages() ...
[17:59:20.184] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.184] Resolving globals: FALSE
[17:59:20.184] Tweak future expression to call with '...' arguments ...
[17:59:20.185] {
[17:59:20.185]     do.call(function(...) {
[17:59:20.185]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:20.185]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:20.185]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:20.185]             on.exit(options(oopts), add = TRUE)
[17:59:20.185]         }
[17:59:20.185]         {
[17:59:20.185]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:20.185]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:20.185]                 ...future.FUN(...future.X_jj, ...)
[17:59:20.185]             })
[17:59:20.185]         }
[17:59:20.185]     }, args = future.call.arguments)
[17:59:20.185] }
[17:59:20.185] Tweak future expression to call with '...' arguments ... DONE
[17:59:20.186] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.186] 
[17:59:20.187] getGlobalsAndPackages() ... DONE
[17:59:20.187] run() for ‘Future’ ...
[17:59:20.187] - state: ‘created’
[17:59:20.188] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:20.229] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:20.230] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:20.230]   - Field: ‘node’
[17:59:20.230]   - Field: ‘label’
[17:59:20.230]   - Field: ‘local’
[17:59:20.231]   - Field: ‘owner’
[17:59:20.231]   - Field: ‘envir’
[17:59:20.231]   - Field: ‘workers’
[17:59:20.231]   - Field: ‘packages’
[17:59:20.232]   - Field: ‘gc’
[17:59:20.232]   - Field: ‘conditions’
[17:59:20.232]   - Field: ‘persistent’
[17:59:20.232]   - Field: ‘expr’
[17:59:20.233]   - Field: ‘uuid’
[17:59:20.233]   - Field: ‘seed’
[17:59:20.233]   - Field: ‘version’
[17:59:20.233]   - Field: ‘result’
[17:59:20.233]   - Field: ‘asynchronous’
[17:59:20.234]   - Field: ‘calls’
[17:59:20.234]   - Field: ‘globals’
[17:59:20.234]   - Field: ‘stdout’
[17:59:20.234]   - Field: ‘earlySignal’
[17:59:20.234]   - Field: ‘lazy’
[17:59:20.235]   - Field: ‘state’
[17:59:20.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:20.235] - Launch lazy future ...
[17:59:20.236] Packages needed by the future expression (n = 0): <none>
[17:59:20.236] Packages needed by future strategies (n = 0): <none>
[17:59:20.237] {
[17:59:20.237]     {
[17:59:20.237]         {
[17:59:20.237]             ...future.startTime <- base::Sys.time()
[17:59:20.237]             {
[17:59:20.237]                 {
[17:59:20.237]                   {
[17:59:20.237]                     {
[17:59:20.237]                       base::local({
[17:59:20.237]                         has_future <- base::requireNamespace("future", 
[17:59:20.237]                           quietly = TRUE)
[17:59:20.237]                         if (has_future) {
[17:59:20.237]                           ns <- base::getNamespace("future")
[17:59:20.237]                           version <- ns[[".package"]][["version"]]
[17:59:20.237]                           if (is.null(version)) 
[17:59:20.237]                             version <- utils::packageVersion("future")
[17:59:20.237]                         }
[17:59:20.237]                         else {
[17:59:20.237]                           version <- NULL
[17:59:20.237]                         }
[17:59:20.237]                         if (!has_future || version < "1.8.0") {
[17:59:20.237]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:20.237]                             "", base::R.version$version.string), 
[17:59:20.237]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:20.237]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:20.237]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:20.237]                               "release", "version")], collapse = " "), 
[17:59:20.237]                             hostname = base::Sys.info()[["nodename"]])
[17:59:20.237]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:20.237]                             info)
[17:59:20.237]                           info <- base::paste(info, collapse = "; ")
[17:59:20.237]                           if (!has_future) {
[17:59:20.237]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:20.237]                               info)
[17:59:20.237]                           }
[17:59:20.237]                           else {
[17:59:20.237]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:20.237]                               info, version)
[17:59:20.237]                           }
[17:59:20.237]                           base::stop(msg)
[17:59:20.237]                         }
[17:59:20.237]                       })
[17:59:20.237]                     }
[17:59:20.237]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:20.237]                     base::options(mc.cores = 1L)
[17:59:20.237]                   }
[17:59:20.237]                   ...future.strategy.old <- future::plan("list")
[17:59:20.237]                   options(future.plan = NULL)
[17:59:20.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:20.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:20.237]                 }
[17:59:20.237]                 ...future.workdir <- getwd()
[17:59:20.237]             }
[17:59:20.237]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:20.237]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:20.237]         }
[17:59:20.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:20.237]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:20.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:20.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:20.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:20.237]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:20.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:20.237]             base::names(...future.oldOptions))
[17:59:20.237]     }
[17:59:20.237]     if (FALSE) {
[17:59:20.237]     }
[17:59:20.237]     else {
[17:59:20.237]         if (TRUE) {
[17:59:20.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:20.237]                 open = "w")
[17:59:20.237]         }
[17:59:20.237]         else {
[17:59:20.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:20.237]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:20.237]         }
[17:59:20.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:20.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:20.237]             base::sink(type = "output", split = FALSE)
[17:59:20.237]             base::close(...future.stdout)
[17:59:20.237]         }, add = TRUE)
[17:59:20.237]     }
[17:59:20.237]     ...future.frame <- base::sys.nframe()
[17:59:20.237]     ...future.conditions <- base::list()
[17:59:20.237]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:20.237]     if (FALSE) {
[17:59:20.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:20.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:20.237]     }
[17:59:20.237]     ...future.result <- base::tryCatch({
[17:59:20.237]         base::withCallingHandlers({
[17:59:20.237]             ...future.value <- base::withVisible(base::local({
[17:59:20.237]                 ...future.makeSendCondition <- base::local({
[17:59:20.237]                   sendCondition <- NULL
[17:59:20.237]                   function(frame = 1L) {
[17:59:20.237]                     if (is.function(sendCondition)) 
[17:59:20.237]                       return(sendCondition)
[17:59:20.237]                     ns <- getNamespace("parallel")
[17:59:20.237]                     if (exists("sendData", mode = "function", 
[17:59:20.237]                       envir = ns)) {
[17:59:20.237]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:20.237]                         envir = ns)
[17:59:20.237]                       envir <- sys.frame(frame)
[17:59:20.237]                       master <- NULL
[17:59:20.237]                       while (!identical(envir, .GlobalEnv) && 
[17:59:20.237]                         !identical(envir, emptyenv())) {
[17:59:20.237]                         if (exists("master", mode = "list", envir = envir, 
[17:59:20.237]                           inherits = FALSE)) {
[17:59:20.237]                           master <- get("master", mode = "list", 
[17:59:20.237]                             envir = envir, inherits = FALSE)
[17:59:20.237]                           if (inherits(master, c("SOCKnode", 
[17:59:20.237]                             "SOCK0node"))) {
[17:59:20.237]                             sendCondition <<- function(cond) {
[17:59:20.237]                               data <- list(type = "VALUE", value = cond, 
[17:59:20.237]                                 success = TRUE)
[17:59:20.237]                               parallel_sendData(master, data)
[17:59:20.237]                             }
[17:59:20.237]                             return(sendCondition)
[17:59:20.237]                           }
[17:59:20.237]                         }
[17:59:20.237]                         frame <- frame + 1L
[17:59:20.237]                         envir <- sys.frame(frame)
[17:59:20.237]                       }
[17:59:20.237]                     }
[17:59:20.237]                     sendCondition <<- function(cond) NULL
[17:59:20.237]                   }
[17:59:20.237]                 })
[17:59:20.237]                 withCallingHandlers({
[17:59:20.237]                   {
[17:59:20.237]                     do.call(function(...) {
[17:59:20.237]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:20.237]                       if (!identical(...future.globals.maxSize.org, 
[17:59:20.237]                         ...future.globals.maxSize)) {
[17:59:20.237]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:20.237]                         on.exit(options(oopts), add = TRUE)
[17:59:20.237]                       }
[17:59:20.237]                       {
[17:59:20.237]                         lapply(seq_along(...future.elements_ii), 
[17:59:20.237]                           FUN = function(jj) {
[17:59:20.237]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:20.237]                             ...future.FUN(...future.X_jj, ...)
[17:59:20.237]                           })
[17:59:20.237]                       }
[17:59:20.237]                     }, args = future.call.arguments)
[17:59:20.237]                   }
[17:59:20.237]                 }, immediateCondition = function(cond) {
[17:59:20.237]                   sendCondition <- ...future.makeSendCondition()
[17:59:20.237]                   sendCondition(cond)
[17:59:20.237]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:20.237]                   {
[17:59:20.237]                     inherits <- base::inherits
[17:59:20.237]                     invokeRestart <- base::invokeRestart
[17:59:20.237]                     is.null <- base::is.null
[17:59:20.237]                     muffled <- FALSE
[17:59:20.237]                     if (inherits(cond, "message")) {
[17:59:20.237]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:20.237]                       if (muffled) 
[17:59:20.237]                         invokeRestart("muffleMessage")
[17:59:20.237]                     }
[17:59:20.237]                     else if (inherits(cond, "warning")) {
[17:59:20.237]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:20.237]                       if (muffled) 
[17:59:20.237]                         invokeRestart("muffleWarning")
[17:59:20.237]                     }
[17:59:20.237]                     else if (inherits(cond, "condition")) {
[17:59:20.237]                       if (!is.null(pattern)) {
[17:59:20.237]                         computeRestarts <- base::computeRestarts
[17:59:20.237]                         grepl <- base::grepl
[17:59:20.237]                         restarts <- computeRestarts(cond)
[17:59:20.237]                         for (restart in restarts) {
[17:59:20.237]                           name <- restart$name
[17:59:20.237]                           if (is.null(name)) 
[17:59:20.237]                             next
[17:59:20.237]                           if (!grepl(pattern, name)) 
[17:59:20.237]                             next
[17:59:20.237]                           invokeRestart(restart)
[17:59:20.237]                           muffled <- TRUE
[17:59:20.237]                           break
[17:59:20.237]                         }
[17:59:20.237]                       }
[17:59:20.237]                     }
[17:59:20.237]                     invisible(muffled)
[17:59:20.237]                   }
[17:59:20.237]                   muffleCondition(cond)
[17:59:20.237]                 })
[17:59:20.237]             }))
[17:59:20.237]             future::FutureResult(value = ...future.value$value, 
[17:59:20.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:20.237]                   ...future.rng), globalenv = if (FALSE) 
[17:59:20.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:20.237]                     ...future.globalenv.names))
[17:59:20.237]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:20.237]         }, condition = base::local({
[17:59:20.237]             c <- base::c
[17:59:20.237]             inherits <- base::inherits
[17:59:20.237]             invokeRestart <- base::invokeRestart
[17:59:20.237]             length <- base::length
[17:59:20.237]             list <- base::list
[17:59:20.237]             seq.int <- base::seq.int
[17:59:20.237]             signalCondition <- base::signalCondition
[17:59:20.237]             sys.calls <- base::sys.calls
[17:59:20.237]             `[[` <- base::`[[`
[17:59:20.237]             `+` <- base::`+`
[17:59:20.237]             `<<-` <- base::`<<-`
[17:59:20.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:20.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:20.237]                   3L)]
[17:59:20.237]             }
[17:59:20.237]             function(cond) {
[17:59:20.237]                 is_error <- inherits(cond, "error")
[17:59:20.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:20.237]                   NULL)
[17:59:20.237]                 if (is_error) {
[17:59:20.237]                   sessionInformation <- function() {
[17:59:20.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:20.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:20.237]                       search = base::search(), system = base::Sys.info())
[17:59:20.237]                   }
[17:59:20.237]                   ...future.conditions[[length(...future.conditions) + 
[17:59:20.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:20.237]                     cond$call), session = sessionInformation(), 
[17:59:20.237]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:20.237]                   signalCondition(cond)
[17:59:20.237]                 }
[17:59:20.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:20.237]                 "immediateCondition"))) {
[17:59:20.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:20.237]                   ...future.conditions[[length(...future.conditions) + 
[17:59:20.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:20.237]                   if (TRUE && !signal) {
[17:59:20.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:20.237]                     {
[17:59:20.237]                       inherits <- base::inherits
[17:59:20.237]                       invokeRestart <- base::invokeRestart
[17:59:20.237]                       is.null <- base::is.null
[17:59:20.237]                       muffled <- FALSE
[17:59:20.237]                       if (inherits(cond, "message")) {
[17:59:20.237]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:20.237]                         if (muffled) 
[17:59:20.237]                           invokeRestart("muffleMessage")
[17:59:20.237]                       }
[17:59:20.237]                       else if (inherits(cond, "warning")) {
[17:59:20.237]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:20.237]                         if (muffled) 
[17:59:20.237]                           invokeRestart("muffleWarning")
[17:59:20.237]                       }
[17:59:20.237]                       else if (inherits(cond, "condition")) {
[17:59:20.237]                         if (!is.null(pattern)) {
[17:59:20.237]                           computeRestarts <- base::computeRestarts
[17:59:20.237]                           grepl <- base::grepl
[17:59:20.237]                           restarts <- computeRestarts(cond)
[17:59:20.237]                           for (restart in restarts) {
[17:59:20.237]                             name <- restart$name
[17:59:20.237]                             if (is.null(name)) 
[17:59:20.237]                               next
[17:59:20.237]                             if (!grepl(pattern, name)) 
[17:59:20.237]                               next
[17:59:20.237]                             invokeRestart(restart)
[17:59:20.237]                             muffled <- TRUE
[17:59:20.237]                             break
[17:59:20.237]                           }
[17:59:20.237]                         }
[17:59:20.237]                       }
[17:59:20.237]                       invisible(muffled)
[17:59:20.237]                     }
[17:59:20.237]                     muffleCondition(cond, pattern = "^muffle")
[17:59:20.237]                   }
[17:59:20.237]                 }
[17:59:20.237]                 else {
[17:59:20.237]                   if (TRUE) {
[17:59:20.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:20.237]                     {
[17:59:20.237]                       inherits <- base::inherits
[17:59:20.237]                       invokeRestart <- base::invokeRestart
[17:59:20.237]                       is.null <- base::is.null
[17:59:20.237]                       muffled <- FALSE
[17:59:20.237]                       if (inherits(cond, "message")) {
[17:59:20.237]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:20.237]                         if (muffled) 
[17:59:20.237]                           invokeRestart("muffleMessage")
[17:59:20.237]                       }
[17:59:20.237]                       else if (inherits(cond, "warning")) {
[17:59:20.237]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:20.237]                         if (muffled) 
[17:59:20.237]                           invokeRestart("muffleWarning")
[17:59:20.237]                       }
[17:59:20.237]                       else if (inherits(cond, "condition")) {
[17:59:20.237]                         if (!is.null(pattern)) {
[17:59:20.237]                           computeRestarts <- base::computeRestarts
[17:59:20.237]                           grepl <- base::grepl
[17:59:20.237]                           restarts <- computeRestarts(cond)
[17:59:20.237]                           for (restart in restarts) {
[17:59:20.237]                             name <- restart$name
[17:59:20.237]                             if (is.null(name)) 
[17:59:20.237]                               next
[17:59:20.237]                             if (!grepl(pattern, name)) 
[17:59:20.237]                               next
[17:59:20.237]                             invokeRestart(restart)
[17:59:20.237]                             muffled <- TRUE
[17:59:20.237]                             break
[17:59:20.237]                           }
[17:59:20.237]                         }
[17:59:20.237]                       }
[17:59:20.237]                       invisible(muffled)
[17:59:20.237]                     }
[17:59:20.237]                     muffleCondition(cond, pattern = "^muffle")
[17:59:20.237]                   }
[17:59:20.237]                 }
[17:59:20.237]             }
[17:59:20.237]         }))
[17:59:20.237]     }, error = function(ex) {
[17:59:20.237]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:20.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:20.237]                 ...future.rng), started = ...future.startTime, 
[17:59:20.237]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:20.237]             version = "1.8"), class = "FutureResult")
[17:59:20.237]     }, finally = {
[17:59:20.237]         if (!identical(...future.workdir, getwd())) 
[17:59:20.237]             setwd(...future.workdir)
[17:59:20.237]         {
[17:59:20.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:20.237]                 ...future.oldOptions$nwarnings <- NULL
[17:59:20.237]             }
[17:59:20.237]             base::options(...future.oldOptions)
[17:59:20.237]             if (.Platform$OS.type == "windows") {
[17:59:20.237]                 old_names <- names(...future.oldEnvVars)
[17:59:20.237]                 envs <- base::Sys.getenv()
[17:59:20.237]                 names <- names(envs)
[17:59:20.237]                 common <- intersect(names, old_names)
[17:59:20.237]                 added <- setdiff(names, old_names)
[17:59:20.237]                 removed <- setdiff(old_names, names)
[17:59:20.237]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:20.237]                   envs[common]]
[17:59:20.237]                 NAMES <- toupper(changed)
[17:59:20.237]                 args <- list()
[17:59:20.237]                 for (kk in seq_along(NAMES)) {
[17:59:20.237]                   name <- changed[[kk]]
[17:59:20.237]                   NAME <- NAMES[[kk]]
[17:59:20.237]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:20.237]                     next
[17:59:20.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:20.237]                 }
[17:59:20.237]                 NAMES <- toupper(added)
[17:59:20.237]                 for (kk in seq_along(NAMES)) {
[17:59:20.237]                   name <- added[[kk]]
[17:59:20.237]                   NAME <- NAMES[[kk]]
[17:59:20.237]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:20.237]                     next
[17:59:20.237]                   args[[name]] <- ""
[17:59:20.237]                 }
[17:59:20.237]                 NAMES <- toupper(removed)
[17:59:20.237]                 for (kk in seq_along(NAMES)) {
[17:59:20.237]                   name <- removed[[kk]]
[17:59:20.237]                   NAME <- NAMES[[kk]]
[17:59:20.237]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:20.237]                     next
[17:59:20.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:20.237]                 }
[17:59:20.237]                 if (length(args) > 0) 
[17:59:20.237]                   base::do.call(base::Sys.setenv, args = args)
[17:59:20.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:20.237]             }
[17:59:20.237]             else {
[17:59:20.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:20.237]             }
[17:59:20.237]             {
[17:59:20.237]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:20.237]                   0L) {
[17:59:20.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:20.237]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:20.237]                   base::options(opts)
[17:59:20.237]                 }
[17:59:20.237]                 {
[17:59:20.237]                   {
[17:59:20.237]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:20.237]                     NULL
[17:59:20.237]                   }
[17:59:20.237]                   options(future.plan = NULL)
[17:59:20.237]                   if (is.na(NA_character_)) 
[17:59:20.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:20.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:20.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:20.237]                     .init = FALSE)
[17:59:20.237]                 }
[17:59:20.237]             }
[17:59:20.237]         }
[17:59:20.237]     })
[17:59:20.237]     if (TRUE) {
[17:59:20.237]         base::sink(type = "output", split = FALSE)
[17:59:20.237]         if (TRUE) {
[17:59:20.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:20.237]         }
[17:59:20.237]         else {
[17:59:20.237]             ...future.result["stdout"] <- base::list(NULL)
[17:59:20.237]         }
[17:59:20.237]         base::close(...future.stdout)
[17:59:20.237]         ...future.stdout <- NULL
[17:59:20.237]     }
[17:59:20.237]     ...future.result$conditions <- ...future.conditions
[17:59:20.237]     ...future.result$finished <- base::Sys.time()
[17:59:20.237]     ...future.result
[17:59:20.237] }
[17:59:20.243] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[17:59:20.244] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:20.245] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:20.245] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[17:59:20.287] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[17:59:20.287] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:59:20.288] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:59:20.289] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:20.289] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:20.290] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:59:20.291] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:59:20.291] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[17:59:20.293] MultisessionFuture started
[17:59:20.294] - Launch lazy future ... done
[17:59:20.294] run() for ‘MultisessionFuture’ ... done
[17:59:20.294] Created future:
[17:59:20.294] MultisessionFuture:
[17:59:20.294] Label: ‘future_apply-1’
[17:59:20.294] Expression:
[17:59:20.294] {
[17:59:20.294]     do.call(function(...) {
[17:59:20.294]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:20.294]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:20.294]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:20.294]             on.exit(options(oopts), add = TRUE)
[17:59:20.294]         }
[17:59:20.294]         {
[17:59:20.294]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:20.294]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:20.294]                 ...future.FUN(...future.X_jj, ...)
[17:59:20.294]             })
[17:59:20.294]         }
[17:59:20.294]     }, args = future.call.arguments)
[17:59:20.294] }
[17:59:20.294] Lazy evaluation: FALSE
[17:59:20.294] Asynchronous evaluation: TRUE
[17:59:20.294] Local evaluation: TRUE
[17:59:20.294] Environment: R_GlobalEnv
[17:59:20.294] Capture standard output: TRUE
[17:59:20.294] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:20.294] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:20.294] Packages: <none>
[17:59:20.294] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:20.294] Resolved: FALSE
[17:59:20.294] Value: <not collected>
[17:59:20.294] Conditions captured: <none>
[17:59:20.294] Early signaling: FALSE
[17:59:20.294] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:20.294] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:20.308] Chunk #1 of 2 ... DONE
[17:59:20.308] Chunk #2 of 2 ...
[17:59:20.309]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:20.309]  - seeds: <none>
[17:59:20.309]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.309] getGlobalsAndPackages() ...
[17:59:20.310] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.310] Resolving globals: FALSE
[17:59:20.310] Tweak future expression to call with '...' arguments ...
[17:59:20.310] {
[17:59:20.310]     do.call(function(...) {
[17:59:20.310]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:20.310]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:20.310]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:20.310]             on.exit(options(oopts), add = TRUE)
[17:59:20.310]         }
[17:59:20.310]         {
[17:59:20.310]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:20.310]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:20.310]                 ...future.FUN(...future.X_jj, ...)
[17:59:20.310]             })
[17:59:20.310]         }
[17:59:20.310]     }, args = future.call.arguments)
[17:59:20.310] }
[17:59:20.311] Tweak future expression to call with '...' arguments ... DONE
[17:59:20.312] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.313] 
[17:59:20.313] getGlobalsAndPackages() ... DONE
[17:59:20.313] run() for ‘Future’ ...
[17:59:20.314] - state: ‘created’
[17:59:20.315] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:20.351] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:20.352] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:20.353]   - Field: ‘node’
[17:59:20.353]   - Field: ‘label’
[17:59:20.353]   - Field: ‘local’
[17:59:20.354]   - Field: ‘owner’
[17:59:20.354]   - Field: ‘envir’
[17:59:20.354]   - Field: ‘workers’
[17:59:20.354]   - Field: ‘packages’
[17:59:20.355]   - Field: ‘gc’
[17:59:20.356]   - Field: ‘conditions’
[17:59:20.356]   - Field: ‘persistent’
[17:59:20.357]   - Field: ‘expr’
[17:59:20.357]   - Field: ‘uuid’
[17:59:20.357]   - Field: ‘seed’
[17:59:20.357]   - Field: ‘version’
[17:59:20.358]   - Field: ‘result’
[17:59:20.359]   - Field: ‘asynchronous’
[17:59:20.359]   - Field: ‘calls’
[17:59:20.359]   - Field: ‘globals’
[17:59:20.360]   - Field: ‘stdout’
[17:59:20.360]   - Field: ‘earlySignal’
[17:59:20.360]   - Field: ‘lazy’
[17:59:20.360]   - Field: ‘state’
[17:59:20.361] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:20.363] - Launch lazy future ...
[17:59:20.363] Packages needed by the future expression (n = 0): <none>
[17:59:20.364] Packages needed by future strategies (n = 0): <none>
[17:59:20.375] {
[17:59:20.375]     {
[17:59:20.375]         {
[17:59:20.375]             ...future.startTime <- base::Sys.time()
[17:59:20.375]             {
[17:59:20.375]                 {
[17:59:20.375]                   {
[17:59:20.375]                     {
[17:59:20.375]                       base::local({
[17:59:20.375]                         has_future <- base::requireNamespace("future", 
[17:59:20.375]                           quietly = TRUE)
[17:59:20.375]                         if (has_future) {
[17:59:20.375]                           ns <- base::getNamespace("future")
[17:59:20.375]                           version <- ns[[".package"]][["version"]]
[17:59:20.375]                           if (is.null(version)) 
[17:59:20.375]                             version <- utils::packageVersion("future")
[17:59:20.375]                         }
[17:59:20.375]                         else {
[17:59:20.375]                           version <- NULL
[17:59:20.375]                         }
[17:59:20.375]                         if (!has_future || version < "1.8.0") {
[17:59:20.375]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:20.375]                             "", base::R.version$version.string), 
[17:59:20.375]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:20.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:20.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:20.375]                               "release", "version")], collapse = " "), 
[17:59:20.375]                             hostname = base::Sys.info()[["nodename"]])
[17:59:20.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:20.375]                             info)
[17:59:20.375]                           info <- base::paste(info, collapse = "; ")
[17:59:20.375]                           if (!has_future) {
[17:59:20.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:20.375]                               info)
[17:59:20.375]                           }
[17:59:20.375]                           else {
[17:59:20.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:20.375]                               info, version)
[17:59:20.375]                           }
[17:59:20.375]                           base::stop(msg)
[17:59:20.375]                         }
[17:59:20.375]                       })
[17:59:20.375]                     }
[17:59:20.375]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:20.375]                     base::options(mc.cores = 1L)
[17:59:20.375]                   }
[17:59:20.375]                   ...future.strategy.old <- future::plan("list")
[17:59:20.375]                   options(future.plan = NULL)
[17:59:20.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:20.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:20.375]                 }
[17:59:20.375]                 ...future.workdir <- getwd()
[17:59:20.375]             }
[17:59:20.375]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:20.375]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:20.375]         }
[17:59:20.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:20.375]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:20.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:20.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:20.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:20.375]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:20.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:20.375]             base::names(...future.oldOptions))
[17:59:20.375]     }
[17:59:20.375]     if (FALSE) {
[17:59:20.375]     }
[17:59:20.375]     else {
[17:59:20.375]         if (TRUE) {
[17:59:20.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:20.375]                 open = "w")
[17:59:20.375]         }
[17:59:20.375]         else {
[17:59:20.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:20.375]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:20.375]         }
[17:59:20.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:20.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:20.375]             base::sink(type = "output", split = FALSE)
[17:59:20.375]             base::close(...future.stdout)
[17:59:20.375]         }, add = TRUE)
[17:59:20.375]     }
[17:59:20.375]     ...future.frame <- base::sys.nframe()
[17:59:20.375]     ...future.conditions <- base::list()
[17:59:20.375]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:20.375]     if (FALSE) {
[17:59:20.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:20.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:20.375]     }
[17:59:20.375]     ...future.result <- base::tryCatch({
[17:59:20.375]         base::withCallingHandlers({
[17:59:20.375]             ...future.value <- base::withVisible(base::local({
[17:59:20.375]                 ...future.makeSendCondition <- base::local({
[17:59:20.375]                   sendCondition <- NULL
[17:59:20.375]                   function(frame = 1L) {
[17:59:20.375]                     if (is.function(sendCondition)) 
[17:59:20.375]                       return(sendCondition)
[17:59:20.375]                     ns <- getNamespace("parallel")
[17:59:20.375]                     if (exists("sendData", mode = "function", 
[17:59:20.375]                       envir = ns)) {
[17:59:20.375]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:20.375]                         envir = ns)
[17:59:20.375]                       envir <- sys.frame(frame)
[17:59:20.375]                       master <- NULL
[17:59:20.375]                       while (!identical(envir, .GlobalEnv) && 
[17:59:20.375]                         !identical(envir, emptyenv())) {
[17:59:20.375]                         if (exists("master", mode = "list", envir = envir, 
[17:59:20.375]                           inherits = FALSE)) {
[17:59:20.375]                           master <- get("master", mode = "list", 
[17:59:20.375]                             envir = envir, inherits = FALSE)
[17:59:20.375]                           if (inherits(master, c("SOCKnode", 
[17:59:20.375]                             "SOCK0node"))) {
[17:59:20.375]                             sendCondition <<- function(cond) {
[17:59:20.375]                               data <- list(type = "VALUE", value = cond, 
[17:59:20.375]                                 success = TRUE)
[17:59:20.375]                               parallel_sendData(master, data)
[17:59:20.375]                             }
[17:59:20.375]                             return(sendCondition)
[17:59:20.375]                           }
[17:59:20.375]                         }
[17:59:20.375]                         frame <- frame + 1L
[17:59:20.375]                         envir <- sys.frame(frame)
[17:59:20.375]                       }
[17:59:20.375]                     }
[17:59:20.375]                     sendCondition <<- function(cond) NULL
[17:59:20.375]                   }
[17:59:20.375]                 })
[17:59:20.375]                 withCallingHandlers({
[17:59:20.375]                   {
[17:59:20.375]                     do.call(function(...) {
[17:59:20.375]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:20.375]                       if (!identical(...future.globals.maxSize.org, 
[17:59:20.375]                         ...future.globals.maxSize)) {
[17:59:20.375]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:20.375]                         on.exit(options(oopts), add = TRUE)
[17:59:20.375]                       }
[17:59:20.375]                       {
[17:59:20.375]                         lapply(seq_along(...future.elements_ii), 
[17:59:20.375]                           FUN = function(jj) {
[17:59:20.375]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:20.375]                             ...future.FUN(...future.X_jj, ...)
[17:59:20.375]                           })
[17:59:20.375]                       }
[17:59:20.375]                     }, args = future.call.arguments)
[17:59:20.375]                   }
[17:59:20.375]                 }, immediateCondition = function(cond) {
[17:59:20.375]                   sendCondition <- ...future.makeSendCondition()
[17:59:20.375]                   sendCondition(cond)
[17:59:20.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:20.375]                   {
[17:59:20.375]                     inherits <- base::inherits
[17:59:20.375]                     invokeRestart <- base::invokeRestart
[17:59:20.375]                     is.null <- base::is.null
[17:59:20.375]                     muffled <- FALSE
[17:59:20.375]                     if (inherits(cond, "message")) {
[17:59:20.375]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:20.375]                       if (muffled) 
[17:59:20.375]                         invokeRestart("muffleMessage")
[17:59:20.375]                     }
[17:59:20.375]                     else if (inherits(cond, "warning")) {
[17:59:20.375]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:20.375]                       if (muffled) 
[17:59:20.375]                         invokeRestart("muffleWarning")
[17:59:20.375]                     }
[17:59:20.375]                     else if (inherits(cond, "condition")) {
[17:59:20.375]                       if (!is.null(pattern)) {
[17:59:20.375]                         computeRestarts <- base::computeRestarts
[17:59:20.375]                         grepl <- base::grepl
[17:59:20.375]                         restarts <- computeRestarts(cond)
[17:59:20.375]                         for (restart in restarts) {
[17:59:20.375]                           name <- restart$name
[17:59:20.375]                           if (is.null(name)) 
[17:59:20.375]                             next
[17:59:20.375]                           if (!grepl(pattern, name)) 
[17:59:20.375]                             next
[17:59:20.375]                           invokeRestart(restart)
[17:59:20.375]                           muffled <- TRUE
[17:59:20.375]                           break
[17:59:20.375]                         }
[17:59:20.375]                       }
[17:59:20.375]                     }
[17:59:20.375]                     invisible(muffled)
[17:59:20.375]                   }
[17:59:20.375]                   muffleCondition(cond)
[17:59:20.375]                 })
[17:59:20.375]             }))
[17:59:20.375]             future::FutureResult(value = ...future.value$value, 
[17:59:20.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:20.375]                   ...future.rng), globalenv = if (FALSE) 
[17:59:20.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:20.375]                     ...future.globalenv.names))
[17:59:20.375]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:20.375]         }, condition = base::local({
[17:59:20.375]             c <- base::c
[17:59:20.375]             inherits <- base::inherits
[17:59:20.375]             invokeRestart <- base::invokeRestart
[17:59:20.375]             length <- base::length
[17:59:20.375]             list <- base::list
[17:59:20.375]             seq.int <- base::seq.int
[17:59:20.375]             signalCondition <- base::signalCondition
[17:59:20.375]             sys.calls <- base::sys.calls
[17:59:20.375]             `[[` <- base::`[[`
[17:59:20.375]             `+` <- base::`+`
[17:59:20.375]             `<<-` <- base::`<<-`
[17:59:20.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:20.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:20.375]                   3L)]
[17:59:20.375]             }
[17:59:20.375]             function(cond) {
[17:59:20.375]                 is_error <- inherits(cond, "error")
[17:59:20.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:20.375]                   NULL)
[17:59:20.375]                 if (is_error) {
[17:59:20.375]                   sessionInformation <- function() {
[17:59:20.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:20.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:20.375]                       search = base::search(), system = base::Sys.info())
[17:59:20.375]                   }
[17:59:20.375]                   ...future.conditions[[length(...future.conditions) + 
[17:59:20.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:20.375]                     cond$call), session = sessionInformation(), 
[17:59:20.375]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:20.375]                   signalCondition(cond)
[17:59:20.375]                 }
[17:59:20.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:20.375]                 "immediateCondition"))) {
[17:59:20.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:20.375]                   ...future.conditions[[length(...future.conditions) + 
[17:59:20.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:20.375]                   if (TRUE && !signal) {
[17:59:20.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:20.375]                     {
[17:59:20.375]                       inherits <- base::inherits
[17:59:20.375]                       invokeRestart <- base::invokeRestart
[17:59:20.375]                       is.null <- base::is.null
[17:59:20.375]                       muffled <- FALSE
[17:59:20.375]                       if (inherits(cond, "message")) {
[17:59:20.375]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:20.375]                         if (muffled) 
[17:59:20.375]                           invokeRestart("muffleMessage")
[17:59:20.375]                       }
[17:59:20.375]                       else if (inherits(cond, "warning")) {
[17:59:20.375]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:20.375]                         if (muffled) 
[17:59:20.375]                           invokeRestart("muffleWarning")
[17:59:20.375]                       }
[17:59:20.375]                       else if (inherits(cond, "condition")) {
[17:59:20.375]                         if (!is.null(pattern)) {
[17:59:20.375]                           computeRestarts <- base::computeRestarts
[17:59:20.375]                           grepl <- base::grepl
[17:59:20.375]                           restarts <- computeRestarts(cond)
[17:59:20.375]                           for (restart in restarts) {
[17:59:20.375]                             name <- restart$name
[17:59:20.375]                             if (is.null(name)) 
[17:59:20.375]                               next
[17:59:20.375]                             if (!grepl(pattern, name)) 
[17:59:20.375]                               next
[17:59:20.375]                             invokeRestart(restart)
[17:59:20.375]                             muffled <- TRUE
[17:59:20.375]                             break
[17:59:20.375]                           }
[17:59:20.375]                         }
[17:59:20.375]                       }
[17:59:20.375]                       invisible(muffled)
[17:59:20.375]                     }
[17:59:20.375]                     muffleCondition(cond, pattern = "^muffle")
[17:59:20.375]                   }
[17:59:20.375]                 }
[17:59:20.375]                 else {
[17:59:20.375]                   if (TRUE) {
[17:59:20.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:20.375]                     {
[17:59:20.375]                       inherits <- base::inherits
[17:59:20.375]                       invokeRestart <- base::invokeRestart
[17:59:20.375]                       is.null <- base::is.null
[17:59:20.375]                       muffled <- FALSE
[17:59:20.375]                       if (inherits(cond, "message")) {
[17:59:20.375]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:20.375]                         if (muffled) 
[17:59:20.375]                           invokeRestart("muffleMessage")
[17:59:20.375]                       }
[17:59:20.375]                       else if (inherits(cond, "warning")) {
[17:59:20.375]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:20.375]                         if (muffled) 
[17:59:20.375]                           invokeRestart("muffleWarning")
[17:59:20.375]                       }
[17:59:20.375]                       else if (inherits(cond, "condition")) {
[17:59:20.375]                         if (!is.null(pattern)) {
[17:59:20.375]                           computeRestarts <- base::computeRestarts
[17:59:20.375]                           grepl <- base::grepl
[17:59:20.375]                           restarts <- computeRestarts(cond)
[17:59:20.375]                           for (restart in restarts) {
[17:59:20.375]                             name <- restart$name
[17:59:20.375]                             if (is.null(name)) 
[17:59:20.375]                               next
[17:59:20.375]                             if (!grepl(pattern, name)) 
[17:59:20.375]                               next
[17:59:20.375]                             invokeRestart(restart)
[17:59:20.375]                             muffled <- TRUE
[17:59:20.375]                             break
[17:59:20.375]                           }
[17:59:20.375]                         }
[17:59:20.375]                       }
[17:59:20.375]                       invisible(muffled)
[17:59:20.375]                     }
[17:59:20.375]                     muffleCondition(cond, pattern = "^muffle")
[17:59:20.375]                   }
[17:59:20.375]                 }
[17:59:20.375]             }
[17:59:20.375]         }))
[17:59:20.375]     }, error = function(ex) {
[17:59:20.375]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:20.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:20.375]                 ...future.rng), started = ...future.startTime, 
[17:59:20.375]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:20.375]             version = "1.8"), class = "FutureResult")
[17:59:20.375]     }, finally = {
[17:59:20.375]         if (!identical(...future.workdir, getwd())) 
[17:59:20.375]             setwd(...future.workdir)
[17:59:20.375]         {
[17:59:20.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:20.375]                 ...future.oldOptions$nwarnings <- NULL
[17:59:20.375]             }
[17:59:20.375]             base::options(...future.oldOptions)
[17:59:20.375]             if (.Platform$OS.type == "windows") {
[17:59:20.375]                 old_names <- names(...future.oldEnvVars)
[17:59:20.375]                 envs <- base::Sys.getenv()
[17:59:20.375]                 names <- names(envs)
[17:59:20.375]                 common <- intersect(names, old_names)
[17:59:20.375]                 added <- setdiff(names, old_names)
[17:59:20.375]                 removed <- setdiff(old_names, names)
[17:59:20.375]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:20.375]                   envs[common]]
[17:59:20.375]                 NAMES <- toupper(changed)
[17:59:20.375]                 args <- list()
[17:59:20.375]                 for (kk in seq_along(NAMES)) {
[17:59:20.375]                   name <- changed[[kk]]
[17:59:20.375]                   NAME <- NAMES[[kk]]
[17:59:20.375]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:20.375]                     next
[17:59:20.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:20.375]                 }
[17:59:20.375]                 NAMES <- toupper(added)
[17:59:20.375]                 for (kk in seq_along(NAMES)) {
[17:59:20.375]                   name <- added[[kk]]
[17:59:20.375]                   NAME <- NAMES[[kk]]
[17:59:20.375]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:20.375]                     next
[17:59:20.375]                   args[[name]] <- ""
[17:59:20.375]                 }
[17:59:20.375]                 NAMES <- toupper(removed)
[17:59:20.375]                 for (kk in seq_along(NAMES)) {
[17:59:20.375]                   name <- removed[[kk]]
[17:59:20.375]                   NAME <- NAMES[[kk]]
[17:59:20.375]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:20.375]                     next
[17:59:20.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:20.375]                 }
[17:59:20.375]                 if (length(args) > 0) 
[17:59:20.375]                   base::do.call(base::Sys.setenv, args = args)
[17:59:20.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:20.375]             }
[17:59:20.375]             else {
[17:59:20.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:20.375]             }
[17:59:20.375]             {
[17:59:20.375]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:20.375]                   0L) {
[17:59:20.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:20.375]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:20.375]                   base::options(opts)
[17:59:20.375]                 }
[17:59:20.375]                 {
[17:59:20.375]                   {
[17:59:20.375]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:20.375]                     NULL
[17:59:20.375]                   }
[17:59:20.375]                   options(future.plan = NULL)
[17:59:20.375]                   if (is.na(NA_character_)) 
[17:59:20.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:20.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:20.375]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:20.375]                     .init = FALSE)
[17:59:20.375]                 }
[17:59:20.375]             }
[17:59:20.375]         }
[17:59:20.375]     })
[17:59:20.375]     if (TRUE) {
[17:59:20.375]         base::sink(type = "output", split = FALSE)
[17:59:20.375]         if (TRUE) {
[17:59:20.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:20.375]         }
[17:59:20.375]         else {
[17:59:20.375]             ...future.result["stdout"] <- base::list(NULL)
[17:59:20.375]         }
[17:59:20.375]         base::close(...future.stdout)
[17:59:20.375]         ...future.stdout <- NULL
[17:59:20.375]     }
[17:59:20.375]     ...future.result$conditions <- ...future.conditions
[17:59:20.375]     ...future.result$finished <- base::Sys.time()
[17:59:20.375]     ...future.result
[17:59:20.375] }
[17:59:20.522] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[17:59:20.522] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:20.523] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:20.523] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[17:59:20.566] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[17:59:20.566] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:59:20.567] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:59:20.567] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:20.568] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:20.569] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:59:20.569] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:59:20.570] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[17:59:20.572] MultisessionFuture started
[17:59:20.573] - Launch lazy future ... done
[17:59:20.573] run() for ‘MultisessionFuture’ ... done
[17:59:20.573] Created future:
[17:59:20.573] MultisessionFuture:
[17:59:20.573] Label: ‘future_apply-2’
[17:59:20.573] Expression:
[17:59:20.573] {
[17:59:20.573]     do.call(function(...) {
[17:59:20.573]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:20.573]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:20.573]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:20.573]             on.exit(options(oopts), add = TRUE)
[17:59:20.573]         }
[17:59:20.573]         {
[17:59:20.573]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:20.573]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:20.573]                 ...future.FUN(...future.X_jj, ...)
[17:59:20.573]             })
[17:59:20.573]         }
[17:59:20.573]     }, args = future.call.arguments)
[17:59:20.573] }
[17:59:20.573] Lazy evaluation: FALSE
[17:59:20.573] Asynchronous evaluation: TRUE
[17:59:20.573] Local evaluation: TRUE
[17:59:20.573] Environment: R_GlobalEnv
[17:59:20.573] Capture standard output: TRUE
[17:59:20.573] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:20.573] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:20.573] Packages: <none>
[17:59:20.573] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:20.573] Resolved: FALSE
[17:59:20.573] Value: <not collected>
[17:59:20.573] Conditions captured: <none>
[17:59:20.573] Early signaling: FALSE
[17:59:20.573] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:20.573] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:20.587] Chunk #2 of 2 ... DONE
[17:59:20.587] Launching 2 futures (chunks) ... DONE
[17:59:20.587] Resolving 2 futures (chunks) ...
[17:59:20.587] resolve() on list ...
[17:59:20.588]  recursive: 0
[17:59:20.588]  length: 2
[17:59:20.588] 
[17:59:20.589] receiveMessageFromWorker() for ClusterFuture ...
[17:59:20.589] - Validating connection of MultisessionFuture
[17:59:20.589] - received message: FutureResult
[17:59:20.590] - Received FutureResult
[17:59:20.590] - Erased future from FutureRegistry
[17:59:20.590] result() for ClusterFuture ...
[17:59:20.590] - result already collected: FutureResult
[17:59:20.590] result() for ClusterFuture ... done
[17:59:20.591] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:20.591] Future #1
[17:59:20.591] result() for ClusterFuture ...
[17:59:20.591] - result already collected: FutureResult
[17:59:20.591] result() for ClusterFuture ... done
[17:59:20.592] result() for ClusterFuture ...
[17:59:20.592] - result already collected: FutureResult
[17:59:20.592] result() for ClusterFuture ... done
[17:59:20.592] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:20.592] - nx: 2
[17:59:20.592] - relay: TRUE
[17:59:20.593] - stdout: TRUE
[17:59:20.593] - signal: TRUE
[17:59:20.593] - resignal: FALSE
[17:59:20.593] - force: TRUE
[17:59:20.593] - relayed: [n=2] FALSE, FALSE
[17:59:20.593] - queued futures: [n=2] FALSE, FALSE
[17:59:20.594]  - until=1
[17:59:20.594]  - relaying element #1
[17:59:20.594] result() for ClusterFuture ...
[17:59:20.594] - result already collected: FutureResult
[17:59:20.594] result() for ClusterFuture ... done
[17:59:20.595] result() for ClusterFuture ...
[17:59:20.595] - result already collected: FutureResult
[17:59:20.595] result() for ClusterFuture ... done
[17:59:20.595] result() for ClusterFuture ...
[17:59:20.595] - result already collected: FutureResult
[17:59:20.596] result() for ClusterFuture ... done
[17:59:20.596] result() for ClusterFuture ...
[17:59:20.596] - result already collected: FutureResult
[17:59:20.596] result() for ClusterFuture ... done
[17:59:20.596] - relayed: [n=2] TRUE, FALSE
[17:59:20.596] - queued futures: [n=2] TRUE, FALSE
[17:59:20.597] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:20.597]  length: 1 (resolved future 1)
[17:59:20.684] receiveMessageFromWorker() for ClusterFuture ...
[17:59:20.684] - Validating connection of MultisessionFuture
[17:59:20.684] - received message: FutureResult
[17:59:20.685] - Received FutureResult
[17:59:20.685] - Erased future from FutureRegistry
[17:59:20.685] result() for ClusterFuture ...
[17:59:20.685] - result already collected: FutureResult
[17:59:20.685] result() for ClusterFuture ... done
[17:59:20.686] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:20.686] Future #2
[17:59:20.686] result() for ClusterFuture ...
[17:59:20.686] - result already collected: FutureResult
[17:59:20.686] result() for ClusterFuture ... done
[17:59:20.687] result() for ClusterFuture ...
[17:59:20.687] - result already collected: FutureResult
[17:59:20.687] result() for ClusterFuture ... done
[17:59:20.687] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:20.687] - nx: 2
[17:59:20.687] - relay: TRUE
[17:59:20.688] - stdout: TRUE
[17:59:20.688] - signal: TRUE
[17:59:20.688] - resignal: FALSE
[17:59:20.688] - force: TRUE
[17:59:20.688] - relayed: [n=2] TRUE, FALSE
[17:59:20.688] - queued futures: [n=2] TRUE, FALSE
[17:59:20.689]  - until=2
[17:59:20.689]  - relaying element #2
[17:59:20.689] result() for ClusterFuture ...
[17:59:20.689] - result already collected: FutureResult
[17:59:20.689] result() for ClusterFuture ... done
[17:59:20.690] result() for ClusterFuture ...
[17:59:20.690] - result already collected: FutureResult
[17:59:20.690] result() for ClusterFuture ... done
[17:59:20.690] result() for ClusterFuture ...
[17:59:20.690] - result already collected: FutureResult
[17:59:20.691] result() for ClusterFuture ... done
[17:59:20.691] result() for ClusterFuture ...
[17:59:20.691] - result already collected: FutureResult
[17:59:20.691] result() for ClusterFuture ... done
[17:59:20.691] - relayed: [n=2] TRUE, TRUE
[17:59:20.692] - queued futures: [n=2] TRUE, TRUE
[17:59:20.692] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:20.692]  length: 0 (resolved future 2)
[17:59:20.692] Relaying remaining futures
[17:59:20.692] signalConditionsASAP(NULL, pos=0) ...
[17:59:20.693] - nx: 2
[17:59:20.693] - relay: TRUE
[17:59:20.693] - stdout: TRUE
[17:59:20.693] - signal: TRUE
[17:59:20.693] - resignal: FALSE
[17:59:20.693] - force: TRUE
[17:59:20.694] - relayed: [n=2] TRUE, TRUE
[17:59:20.694] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:20.694] - relayed: [n=2] TRUE, TRUE
[17:59:20.694] - queued futures: [n=2] TRUE, TRUE
[17:59:20.694] signalConditionsASAP(NULL, pos=0) ... done
[17:59:20.695] resolve() on list ... DONE
[17:59:20.695] result() for ClusterFuture ...
[17:59:20.695] - result already collected: FutureResult
[17:59:20.695] result() for ClusterFuture ... done
[17:59:20.695] result() for ClusterFuture ...
[17:59:20.696] - result already collected: FutureResult
[17:59:20.696] result() for ClusterFuture ... done
[17:59:20.696] result() for ClusterFuture ...
[17:59:20.696] - result already collected: FutureResult
[17:59:20.696] result() for ClusterFuture ... done
[17:59:20.697] result() for ClusterFuture ...
[17:59:20.697] - result already collected: FutureResult
[17:59:20.697] result() for ClusterFuture ... done
[17:59:20.697]  - Number of value chunks collected: 2
[17:59:20.697] Resolving 2 futures (chunks) ... DONE
[17:59:20.698] Reducing values from 2 chunks ...
[17:59:20.698]  - Number of values collected after concatenation: 2
[17:59:20.698]  - Number of values expected: 2
[17:59:20.698] Reducing values from 2 chunks ... DONE
[17:59:20.698] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:59:20.699] getGlobalsAndPackagesXApply() ...
[17:59:20.699]  - future.globals: TRUE
[17:59:20.699] getGlobalsAndPackages() ...
[17:59:20.700] Searching for globals...
[17:59:20.770] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:59:20.771] Searching for globals ... DONE
[17:59:20.771] Resolving globals: FALSE
[17:59:20.774] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:59:20.775] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:59:20.775] - globals: [1] ‘FUN’
[17:59:20.776] 
[17:59:20.776] getGlobalsAndPackages() ... DONE
[17:59:20.776]  - globals found/used: [n=1] ‘FUN’
[17:59:20.776]  - needed namespaces: [n=0] 
[17:59:20.776] Finding globals ... DONE
[17:59:20.777]  - use_args: TRUE
[17:59:20.777]  - Getting '...' globals ...
[17:59:20.777] resolve() on list ...
[17:59:20.778]  recursive: 0
[17:59:20.778]  length: 1
[17:59:20.778]  elements: ‘...’
[17:59:20.778]  length: 0 (resolved future 1)
[17:59:20.779] resolve() on list ... DONE
[17:59:20.779]    - '...' content: [n=0] 
[17:59:20.779] List of 1
[17:59:20.779]  $ ...: list()
[17:59:20.779]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:20.779]  - attr(*, "where")=List of 1
[17:59:20.779]   ..$ ...:<environment: 0x560859b3b9c0> 
[17:59:20.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:20.779]  - attr(*, "resolved")= logi TRUE
[17:59:20.779]  - attr(*, "total_size")= num NA
[17:59:20.784]  - Getting '...' globals ... DONE
[17:59:20.784] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:20.784] List of 2
[17:59:20.784]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:20.784]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:20.784]  $ ...          : list()
[17:59:20.784]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:20.784]  - attr(*, "where")=List of 2
[17:59:20.784]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:20.784]   ..$ ...          :<environment: 0x560859b3b9c0> 
[17:59:20.784]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:20.784]  - attr(*, "resolved")= logi FALSE
[17:59:20.784]  - attr(*, "total_size")= num 354224
[17:59:20.790] Packages to be attached in all futures: [n=0] 
[17:59:20.790] getGlobalsAndPackagesXApply() ... DONE
[17:59:20.796] future_lapply() ...
[17:59:20.869] Number of chunks: 2
[17:59:20.869] getGlobalsAndPackagesXApply() ...
[17:59:20.869]  - future.globals: <name-value list> with names ‘list()’
[17:59:20.869]  - use_args: TRUE
[17:59:20.870] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:20.870] List of 2
[17:59:20.870]  $ ...          : list()
[17:59:20.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:20.870]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:59:20.870]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:59:20.870]  - attr(*, "where")=List of 2
[17:59:20.870]   ..$ ...          :<environment: 0x560859b3b9c0> 
[17:59:20.870]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:20.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:20.870]  - attr(*, "resolved")= logi FALSE
[17:59:20.870]  - attr(*, "total_size")= num NA
[17:59:20.876] Packages to be attached in all futures: [n=0] 
[17:59:20.877] getGlobalsAndPackagesXApply() ... DONE
[17:59:20.877] Number of futures (= number of chunks): 2
[17:59:20.877] Launching 2 futures (chunks) ...
[17:59:20.877] Chunk #1 of 2 ...
[17:59:20.878]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:20.878]  - seeds: <none>
[17:59:20.878]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.878] getGlobalsAndPackages() ...
[17:59:20.879] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.879] Resolving globals: FALSE
[17:59:20.879] Tweak future expression to call with '...' arguments ...
[17:59:20.879] {
[17:59:20.879]     do.call(function(...) {
[17:59:20.879]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:20.879]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:20.879]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:20.879]             on.exit(options(oopts), add = TRUE)
[17:59:20.879]         }
[17:59:20.879]         {
[17:59:20.879]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:20.879]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:20.879]                 ...future.FUN(...future.X_jj, ...)
[17:59:20.879]             })
[17:59:20.879]         }
[17:59:20.879]     }, args = future.call.arguments)
[17:59:20.879] }
[17:59:20.880] Tweak future expression to call with '...' arguments ... DONE
[17:59:20.881] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.881] 
[17:59:20.881] getGlobalsAndPackages() ... DONE
[17:59:20.881] run() for ‘Future’ ...
[17:59:20.882] - state: ‘created’
[17:59:20.882] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:20.906] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:20.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:20.907]   - Field: ‘node’
[17:59:20.907]   - Field: ‘label’
[17:59:20.907]   - Field: ‘local’
[17:59:20.907]   - Field: ‘owner’
[17:59:20.908]   - Field: ‘envir’
[17:59:20.908]   - Field: ‘workers’
[17:59:20.908]   - Field: ‘packages’
[17:59:20.908]   - Field: ‘gc’
[17:59:20.908]   - Field: ‘conditions’
[17:59:20.909]   - Field: ‘persistent’
[17:59:20.909]   - Field: ‘expr’
[17:59:20.909]   - Field: ‘uuid’
[17:59:20.909]   - Field: ‘seed’
[17:59:20.909]   - Field: ‘version’
[17:59:20.910]   - Field: ‘result’
[17:59:20.910]   - Field: ‘asynchronous’
[17:59:20.910]   - Field: ‘calls’
[17:59:20.910]   - Field: ‘globals’
[17:59:20.910]   - Field: ‘stdout’
[17:59:20.911]   - Field: ‘earlySignal’
[17:59:20.911]   - Field: ‘lazy’
[17:59:20.911]   - Field: ‘state’
[17:59:20.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:20.911] - Launch lazy future ...
[17:59:20.912] Packages needed by the future expression (n = 0): <none>
[17:59:20.912] Packages needed by future strategies (n = 0): <none>
[17:59:20.913] {
[17:59:20.913]     {
[17:59:20.913]         {
[17:59:20.913]             ...future.startTime <- base::Sys.time()
[17:59:20.913]             {
[17:59:20.913]                 {
[17:59:20.913]                   {
[17:59:20.913]                     {
[17:59:20.913]                       base::local({
[17:59:20.913]                         has_future <- base::requireNamespace("future", 
[17:59:20.913]                           quietly = TRUE)
[17:59:20.913]                         if (has_future) {
[17:59:20.913]                           ns <- base::getNamespace("future")
[17:59:20.913]                           version <- ns[[".package"]][["version"]]
[17:59:20.913]                           if (is.null(version)) 
[17:59:20.913]                             version <- utils::packageVersion("future")
[17:59:20.913]                         }
[17:59:20.913]                         else {
[17:59:20.913]                           version <- NULL
[17:59:20.913]                         }
[17:59:20.913]                         if (!has_future || version < "1.8.0") {
[17:59:20.913]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:20.913]                             "", base::R.version$version.string), 
[17:59:20.913]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:20.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:20.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:20.913]                               "release", "version")], collapse = " "), 
[17:59:20.913]                             hostname = base::Sys.info()[["nodename"]])
[17:59:20.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:20.913]                             info)
[17:59:20.913]                           info <- base::paste(info, collapse = "; ")
[17:59:20.913]                           if (!has_future) {
[17:59:20.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:20.913]                               info)
[17:59:20.913]                           }
[17:59:20.913]                           else {
[17:59:20.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:20.913]                               info, version)
[17:59:20.913]                           }
[17:59:20.913]                           base::stop(msg)
[17:59:20.913]                         }
[17:59:20.913]                       })
[17:59:20.913]                     }
[17:59:20.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:20.913]                     base::options(mc.cores = 1L)
[17:59:20.913]                   }
[17:59:20.913]                   ...future.strategy.old <- future::plan("list")
[17:59:20.913]                   options(future.plan = NULL)
[17:59:20.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:20.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:20.913]                 }
[17:59:20.913]                 ...future.workdir <- getwd()
[17:59:20.913]             }
[17:59:20.913]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:20.913]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:20.913]         }
[17:59:20.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:20.913]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:20.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:20.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:20.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:20.913]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:20.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:20.913]             base::names(...future.oldOptions))
[17:59:20.913]     }
[17:59:20.913]     if (FALSE) {
[17:59:20.913]     }
[17:59:20.913]     else {
[17:59:20.913]         if (TRUE) {
[17:59:20.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:20.913]                 open = "w")
[17:59:20.913]         }
[17:59:20.913]         else {
[17:59:20.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:20.913]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:20.913]         }
[17:59:20.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:20.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:20.913]             base::sink(type = "output", split = FALSE)
[17:59:20.913]             base::close(...future.stdout)
[17:59:20.913]         }, add = TRUE)
[17:59:20.913]     }
[17:59:20.913]     ...future.frame <- base::sys.nframe()
[17:59:20.913]     ...future.conditions <- base::list()
[17:59:20.913]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:20.913]     if (FALSE) {
[17:59:20.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:20.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:20.913]     }
[17:59:20.913]     ...future.result <- base::tryCatch({
[17:59:20.913]         base::withCallingHandlers({
[17:59:20.913]             ...future.value <- base::withVisible(base::local({
[17:59:20.913]                 ...future.makeSendCondition <- base::local({
[17:59:20.913]                   sendCondition <- NULL
[17:59:20.913]                   function(frame = 1L) {
[17:59:20.913]                     if (is.function(sendCondition)) 
[17:59:20.913]                       return(sendCondition)
[17:59:20.913]                     ns <- getNamespace("parallel")
[17:59:20.913]                     if (exists("sendData", mode = "function", 
[17:59:20.913]                       envir = ns)) {
[17:59:20.913]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:20.913]                         envir = ns)
[17:59:20.913]                       envir <- sys.frame(frame)
[17:59:20.913]                       master <- NULL
[17:59:20.913]                       while (!identical(envir, .GlobalEnv) && 
[17:59:20.913]                         !identical(envir, emptyenv())) {
[17:59:20.913]                         if (exists("master", mode = "list", envir = envir, 
[17:59:20.913]                           inherits = FALSE)) {
[17:59:20.913]                           master <- get("master", mode = "list", 
[17:59:20.913]                             envir = envir, inherits = FALSE)
[17:59:20.913]                           if (inherits(master, c("SOCKnode", 
[17:59:20.913]                             "SOCK0node"))) {
[17:59:20.913]                             sendCondition <<- function(cond) {
[17:59:20.913]                               data <- list(type = "VALUE", value = cond, 
[17:59:20.913]                                 success = TRUE)
[17:59:20.913]                               parallel_sendData(master, data)
[17:59:20.913]                             }
[17:59:20.913]                             return(sendCondition)
[17:59:20.913]                           }
[17:59:20.913]                         }
[17:59:20.913]                         frame <- frame + 1L
[17:59:20.913]                         envir <- sys.frame(frame)
[17:59:20.913]                       }
[17:59:20.913]                     }
[17:59:20.913]                     sendCondition <<- function(cond) NULL
[17:59:20.913]                   }
[17:59:20.913]                 })
[17:59:20.913]                 withCallingHandlers({
[17:59:20.913]                   {
[17:59:20.913]                     do.call(function(...) {
[17:59:20.913]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:20.913]                       if (!identical(...future.globals.maxSize.org, 
[17:59:20.913]                         ...future.globals.maxSize)) {
[17:59:20.913]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:20.913]                         on.exit(options(oopts), add = TRUE)
[17:59:20.913]                       }
[17:59:20.913]                       {
[17:59:20.913]                         lapply(seq_along(...future.elements_ii), 
[17:59:20.913]                           FUN = function(jj) {
[17:59:20.913]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:20.913]                             ...future.FUN(...future.X_jj, ...)
[17:59:20.913]                           })
[17:59:20.913]                       }
[17:59:20.913]                     }, args = future.call.arguments)
[17:59:20.913]                   }
[17:59:20.913]                 }, immediateCondition = function(cond) {
[17:59:20.913]                   sendCondition <- ...future.makeSendCondition()
[17:59:20.913]                   sendCondition(cond)
[17:59:20.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:20.913]                   {
[17:59:20.913]                     inherits <- base::inherits
[17:59:20.913]                     invokeRestart <- base::invokeRestart
[17:59:20.913]                     is.null <- base::is.null
[17:59:20.913]                     muffled <- FALSE
[17:59:20.913]                     if (inherits(cond, "message")) {
[17:59:20.913]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:20.913]                       if (muffled) 
[17:59:20.913]                         invokeRestart("muffleMessage")
[17:59:20.913]                     }
[17:59:20.913]                     else if (inherits(cond, "warning")) {
[17:59:20.913]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:20.913]                       if (muffled) 
[17:59:20.913]                         invokeRestart("muffleWarning")
[17:59:20.913]                     }
[17:59:20.913]                     else if (inherits(cond, "condition")) {
[17:59:20.913]                       if (!is.null(pattern)) {
[17:59:20.913]                         computeRestarts <- base::computeRestarts
[17:59:20.913]                         grepl <- base::grepl
[17:59:20.913]                         restarts <- computeRestarts(cond)
[17:59:20.913]                         for (restart in restarts) {
[17:59:20.913]                           name <- restart$name
[17:59:20.913]                           if (is.null(name)) 
[17:59:20.913]                             next
[17:59:20.913]                           if (!grepl(pattern, name)) 
[17:59:20.913]                             next
[17:59:20.913]                           invokeRestart(restart)
[17:59:20.913]                           muffled <- TRUE
[17:59:20.913]                           break
[17:59:20.913]                         }
[17:59:20.913]                       }
[17:59:20.913]                     }
[17:59:20.913]                     invisible(muffled)
[17:59:20.913]                   }
[17:59:20.913]                   muffleCondition(cond)
[17:59:20.913]                 })
[17:59:20.913]             }))
[17:59:20.913]             future::FutureResult(value = ...future.value$value, 
[17:59:20.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:20.913]                   ...future.rng), globalenv = if (FALSE) 
[17:59:20.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:20.913]                     ...future.globalenv.names))
[17:59:20.913]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:20.913]         }, condition = base::local({
[17:59:20.913]             c <- base::c
[17:59:20.913]             inherits <- base::inherits
[17:59:20.913]             invokeRestart <- base::invokeRestart
[17:59:20.913]             length <- base::length
[17:59:20.913]             list <- base::list
[17:59:20.913]             seq.int <- base::seq.int
[17:59:20.913]             signalCondition <- base::signalCondition
[17:59:20.913]             sys.calls <- base::sys.calls
[17:59:20.913]             `[[` <- base::`[[`
[17:59:20.913]             `+` <- base::`+`
[17:59:20.913]             `<<-` <- base::`<<-`
[17:59:20.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:20.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:20.913]                   3L)]
[17:59:20.913]             }
[17:59:20.913]             function(cond) {
[17:59:20.913]                 is_error <- inherits(cond, "error")
[17:59:20.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:20.913]                   NULL)
[17:59:20.913]                 if (is_error) {
[17:59:20.913]                   sessionInformation <- function() {
[17:59:20.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:20.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:20.913]                       search = base::search(), system = base::Sys.info())
[17:59:20.913]                   }
[17:59:20.913]                   ...future.conditions[[length(...future.conditions) + 
[17:59:20.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:20.913]                     cond$call), session = sessionInformation(), 
[17:59:20.913]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:20.913]                   signalCondition(cond)
[17:59:20.913]                 }
[17:59:20.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:20.913]                 "immediateCondition"))) {
[17:59:20.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:20.913]                   ...future.conditions[[length(...future.conditions) + 
[17:59:20.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:20.913]                   if (TRUE && !signal) {
[17:59:20.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:20.913]                     {
[17:59:20.913]                       inherits <- base::inherits
[17:59:20.913]                       invokeRestart <- base::invokeRestart
[17:59:20.913]                       is.null <- base::is.null
[17:59:20.913]                       muffled <- FALSE
[17:59:20.913]                       if (inherits(cond, "message")) {
[17:59:20.913]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:20.913]                         if (muffled) 
[17:59:20.913]                           invokeRestart("muffleMessage")
[17:59:20.913]                       }
[17:59:20.913]                       else if (inherits(cond, "warning")) {
[17:59:20.913]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:20.913]                         if (muffled) 
[17:59:20.913]                           invokeRestart("muffleWarning")
[17:59:20.913]                       }
[17:59:20.913]                       else if (inherits(cond, "condition")) {
[17:59:20.913]                         if (!is.null(pattern)) {
[17:59:20.913]                           computeRestarts <- base::computeRestarts
[17:59:20.913]                           grepl <- base::grepl
[17:59:20.913]                           restarts <- computeRestarts(cond)
[17:59:20.913]                           for (restart in restarts) {
[17:59:20.913]                             name <- restart$name
[17:59:20.913]                             if (is.null(name)) 
[17:59:20.913]                               next
[17:59:20.913]                             if (!grepl(pattern, name)) 
[17:59:20.913]                               next
[17:59:20.913]                             invokeRestart(restart)
[17:59:20.913]                             muffled <- TRUE
[17:59:20.913]                             break
[17:59:20.913]                           }
[17:59:20.913]                         }
[17:59:20.913]                       }
[17:59:20.913]                       invisible(muffled)
[17:59:20.913]                     }
[17:59:20.913]                     muffleCondition(cond, pattern = "^muffle")
[17:59:20.913]                   }
[17:59:20.913]                 }
[17:59:20.913]                 else {
[17:59:20.913]                   if (TRUE) {
[17:59:20.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:20.913]                     {
[17:59:20.913]                       inherits <- base::inherits
[17:59:20.913]                       invokeRestart <- base::invokeRestart
[17:59:20.913]                       is.null <- base::is.null
[17:59:20.913]                       muffled <- FALSE
[17:59:20.913]                       if (inherits(cond, "message")) {
[17:59:20.913]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:20.913]                         if (muffled) 
[17:59:20.913]                           invokeRestart("muffleMessage")
[17:59:20.913]                       }
[17:59:20.913]                       else if (inherits(cond, "warning")) {
[17:59:20.913]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:20.913]                         if (muffled) 
[17:59:20.913]                           invokeRestart("muffleWarning")
[17:59:20.913]                       }
[17:59:20.913]                       else if (inherits(cond, "condition")) {
[17:59:20.913]                         if (!is.null(pattern)) {
[17:59:20.913]                           computeRestarts <- base::computeRestarts
[17:59:20.913]                           grepl <- base::grepl
[17:59:20.913]                           restarts <- computeRestarts(cond)
[17:59:20.913]                           for (restart in restarts) {
[17:59:20.913]                             name <- restart$name
[17:59:20.913]                             if (is.null(name)) 
[17:59:20.913]                               next
[17:59:20.913]                             if (!grepl(pattern, name)) 
[17:59:20.913]                               next
[17:59:20.913]                             invokeRestart(restart)
[17:59:20.913]                             muffled <- TRUE
[17:59:20.913]                             break
[17:59:20.913]                           }
[17:59:20.913]                         }
[17:59:20.913]                       }
[17:59:20.913]                       invisible(muffled)
[17:59:20.913]                     }
[17:59:20.913]                     muffleCondition(cond, pattern = "^muffle")
[17:59:20.913]                   }
[17:59:20.913]                 }
[17:59:20.913]             }
[17:59:20.913]         }))
[17:59:20.913]     }, error = function(ex) {
[17:59:20.913]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:20.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:20.913]                 ...future.rng), started = ...future.startTime, 
[17:59:20.913]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:20.913]             version = "1.8"), class = "FutureResult")
[17:59:20.913]     }, finally = {
[17:59:20.913]         if (!identical(...future.workdir, getwd())) 
[17:59:20.913]             setwd(...future.workdir)
[17:59:20.913]         {
[17:59:20.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:20.913]                 ...future.oldOptions$nwarnings <- NULL
[17:59:20.913]             }
[17:59:20.913]             base::options(...future.oldOptions)
[17:59:20.913]             if (.Platform$OS.type == "windows") {
[17:59:20.913]                 old_names <- names(...future.oldEnvVars)
[17:59:20.913]                 envs <- base::Sys.getenv()
[17:59:20.913]                 names <- names(envs)
[17:59:20.913]                 common <- intersect(names, old_names)
[17:59:20.913]                 added <- setdiff(names, old_names)
[17:59:20.913]                 removed <- setdiff(old_names, names)
[17:59:20.913]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:20.913]                   envs[common]]
[17:59:20.913]                 NAMES <- toupper(changed)
[17:59:20.913]                 args <- list()
[17:59:20.913]                 for (kk in seq_along(NAMES)) {
[17:59:20.913]                   name <- changed[[kk]]
[17:59:20.913]                   NAME <- NAMES[[kk]]
[17:59:20.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:20.913]                     next
[17:59:20.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:20.913]                 }
[17:59:20.913]                 NAMES <- toupper(added)
[17:59:20.913]                 for (kk in seq_along(NAMES)) {
[17:59:20.913]                   name <- added[[kk]]
[17:59:20.913]                   NAME <- NAMES[[kk]]
[17:59:20.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:20.913]                     next
[17:59:20.913]                   args[[name]] <- ""
[17:59:20.913]                 }
[17:59:20.913]                 NAMES <- toupper(removed)
[17:59:20.913]                 for (kk in seq_along(NAMES)) {
[17:59:20.913]                   name <- removed[[kk]]
[17:59:20.913]                   NAME <- NAMES[[kk]]
[17:59:20.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:20.913]                     next
[17:59:20.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:20.913]                 }
[17:59:20.913]                 if (length(args) > 0) 
[17:59:20.913]                   base::do.call(base::Sys.setenv, args = args)
[17:59:20.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:20.913]             }
[17:59:20.913]             else {
[17:59:20.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:20.913]             }
[17:59:20.913]             {
[17:59:20.913]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:20.913]                   0L) {
[17:59:20.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:20.913]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:20.913]                   base::options(opts)
[17:59:20.913]                 }
[17:59:20.913]                 {
[17:59:20.913]                   {
[17:59:20.913]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:20.913]                     NULL
[17:59:20.913]                   }
[17:59:20.913]                   options(future.plan = NULL)
[17:59:20.913]                   if (is.na(NA_character_)) 
[17:59:20.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:20.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:20.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:20.913]                     .init = FALSE)
[17:59:20.913]                 }
[17:59:20.913]             }
[17:59:20.913]         }
[17:59:20.913]     })
[17:59:20.913]     if (TRUE) {
[17:59:20.913]         base::sink(type = "output", split = FALSE)
[17:59:20.913]         if (TRUE) {
[17:59:20.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:20.913]         }
[17:59:20.913]         else {
[17:59:20.913]             ...future.result["stdout"] <- base::list(NULL)
[17:59:20.913]         }
[17:59:20.913]         base::close(...future.stdout)
[17:59:20.913]         ...future.stdout <- NULL
[17:59:20.913]     }
[17:59:20.913]     ...future.result$conditions <- ...future.conditions
[17:59:20.913]     ...future.result$finished <- base::Sys.time()
[17:59:20.913]     ...future.result
[17:59:20.913] }
[17:59:20.919] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[17:59:20.919] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:20.920] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:20.921] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[17:59:20.969] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[17:59:20.970] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:59:20.971] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:59:20.971] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:20.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:20.972] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:59:20.973] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:59:20.973] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[17:59:20.974] MultisessionFuture started
[17:59:20.975] - Launch lazy future ... done
[17:59:20.975] run() for ‘MultisessionFuture’ ... done
[17:59:20.976] Created future:
[17:59:20.976] MultisessionFuture:
[17:59:20.976] Label: ‘future_apply-1’
[17:59:20.976] Expression:
[17:59:20.976] {
[17:59:20.976]     do.call(function(...) {
[17:59:20.976]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:20.976]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:20.976]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:20.976]             on.exit(options(oopts), add = TRUE)
[17:59:20.976]         }
[17:59:20.976]         {
[17:59:20.976]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:20.976]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:20.976]                 ...future.FUN(...future.X_jj, ...)
[17:59:20.976]             })
[17:59:20.976]         }
[17:59:20.976]     }, args = future.call.arguments)
[17:59:20.976] }
[17:59:20.976] Lazy evaluation: FALSE
[17:59:20.976] Asynchronous evaluation: TRUE
[17:59:20.976] Local evaluation: TRUE
[17:59:20.976] Environment: R_GlobalEnv
[17:59:20.976] Capture standard output: TRUE
[17:59:20.976] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:20.976] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:20.976] Packages: <none>
[17:59:20.976] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:20.976] Resolved: FALSE
[17:59:20.976] Value: <not collected>
[17:59:20.976] Conditions captured: <none>
[17:59:20.976] Early signaling: FALSE
[17:59:20.976] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:20.976] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:20.989] Chunk #1 of 2 ... DONE
[17:59:20.989] Chunk #2 of 2 ...
[17:59:20.990]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:20.990]  - seeds: <none>
[17:59:20.990]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.991] getGlobalsAndPackages() ...
[17:59:20.991] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.991] Resolving globals: FALSE
[17:59:20.991] Tweak future expression to call with '...' arguments ...
[17:59:20.992] {
[17:59:20.992]     do.call(function(...) {
[17:59:20.992]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:20.992]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:20.992]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:20.992]             on.exit(options(oopts), add = TRUE)
[17:59:20.992]         }
[17:59:20.992]         {
[17:59:20.992]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:20.992]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:20.992]                 ...future.FUN(...future.X_jj, ...)
[17:59:20.992]             })
[17:59:20.992]         }
[17:59:20.992]     }, args = future.call.arguments)
[17:59:20.992] }
[17:59:20.992] Tweak future expression to call with '...' arguments ... DONE
[17:59:20.993] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:20.993] 
[17:59:20.994] getGlobalsAndPackages() ... DONE
[17:59:20.994] run() for ‘Future’ ...
[17:59:20.995] - state: ‘created’
[17:59:20.995] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:21.020] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.021] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:21.021]   - Field: ‘node’
[17:59:21.021]   - Field: ‘label’
[17:59:21.021]   - Field: ‘local’
[17:59:21.022]   - Field: ‘owner’
[17:59:21.022]   - Field: ‘envir’
[17:59:21.022]   - Field: ‘workers’
[17:59:21.022]   - Field: ‘packages’
[17:59:21.022]   - Field: ‘gc’
[17:59:21.023]   - Field: ‘conditions’
[17:59:21.023]   - Field: ‘persistent’
[17:59:21.023]   - Field: ‘expr’
[17:59:21.023]   - Field: ‘uuid’
[17:59:21.023]   - Field: ‘seed’
[17:59:21.024]   - Field: ‘version’
[17:59:21.024]   - Field: ‘result’
[17:59:21.024]   - Field: ‘asynchronous’
[17:59:21.024]   - Field: ‘calls’
[17:59:21.024]   - Field: ‘globals’
[17:59:21.025]   - Field: ‘stdout’
[17:59:21.025]   - Field: ‘earlySignal’
[17:59:21.025]   - Field: ‘lazy’
[17:59:21.025]   - Field: ‘state’
[17:59:21.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:21.026] - Launch lazy future ...
[17:59:21.026] Packages needed by the future expression (n = 0): <none>
[17:59:21.026] Packages needed by future strategies (n = 0): <none>
[17:59:21.027] {
[17:59:21.027]     {
[17:59:21.027]         {
[17:59:21.027]             ...future.startTime <- base::Sys.time()
[17:59:21.027]             {
[17:59:21.027]                 {
[17:59:21.027]                   {
[17:59:21.027]                     {
[17:59:21.027]                       base::local({
[17:59:21.027]                         has_future <- base::requireNamespace("future", 
[17:59:21.027]                           quietly = TRUE)
[17:59:21.027]                         if (has_future) {
[17:59:21.027]                           ns <- base::getNamespace("future")
[17:59:21.027]                           version <- ns[[".package"]][["version"]]
[17:59:21.027]                           if (is.null(version)) 
[17:59:21.027]                             version <- utils::packageVersion("future")
[17:59:21.027]                         }
[17:59:21.027]                         else {
[17:59:21.027]                           version <- NULL
[17:59:21.027]                         }
[17:59:21.027]                         if (!has_future || version < "1.8.0") {
[17:59:21.027]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:21.027]                             "", base::R.version$version.string), 
[17:59:21.027]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:21.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:21.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:21.027]                               "release", "version")], collapse = " "), 
[17:59:21.027]                             hostname = base::Sys.info()[["nodename"]])
[17:59:21.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:21.027]                             info)
[17:59:21.027]                           info <- base::paste(info, collapse = "; ")
[17:59:21.027]                           if (!has_future) {
[17:59:21.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:21.027]                               info)
[17:59:21.027]                           }
[17:59:21.027]                           else {
[17:59:21.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:21.027]                               info, version)
[17:59:21.027]                           }
[17:59:21.027]                           base::stop(msg)
[17:59:21.027]                         }
[17:59:21.027]                       })
[17:59:21.027]                     }
[17:59:21.027]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:21.027]                     base::options(mc.cores = 1L)
[17:59:21.027]                   }
[17:59:21.027]                   ...future.strategy.old <- future::plan("list")
[17:59:21.027]                   options(future.plan = NULL)
[17:59:21.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:21.027]                 }
[17:59:21.027]                 ...future.workdir <- getwd()
[17:59:21.027]             }
[17:59:21.027]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:21.027]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:21.027]         }
[17:59:21.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:21.027]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:21.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:21.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:21.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:21.027]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:21.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:21.027]             base::names(...future.oldOptions))
[17:59:21.027]     }
[17:59:21.027]     if (FALSE) {
[17:59:21.027]     }
[17:59:21.027]     else {
[17:59:21.027]         if (TRUE) {
[17:59:21.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:21.027]                 open = "w")
[17:59:21.027]         }
[17:59:21.027]         else {
[17:59:21.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:21.027]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:21.027]         }
[17:59:21.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:21.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:21.027]             base::sink(type = "output", split = FALSE)
[17:59:21.027]             base::close(...future.stdout)
[17:59:21.027]         }, add = TRUE)
[17:59:21.027]     }
[17:59:21.027]     ...future.frame <- base::sys.nframe()
[17:59:21.027]     ...future.conditions <- base::list()
[17:59:21.027]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:21.027]     if (FALSE) {
[17:59:21.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:21.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:21.027]     }
[17:59:21.027]     ...future.result <- base::tryCatch({
[17:59:21.027]         base::withCallingHandlers({
[17:59:21.027]             ...future.value <- base::withVisible(base::local({
[17:59:21.027]                 ...future.makeSendCondition <- base::local({
[17:59:21.027]                   sendCondition <- NULL
[17:59:21.027]                   function(frame = 1L) {
[17:59:21.027]                     if (is.function(sendCondition)) 
[17:59:21.027]                       return(sendCondition)
[17:59:21.027]                     ns <- getNamespace("parallel")
[17:59:21.027]                     if (exists("sendData", mode = "function", 
[17:59:21.027]                       envir = ns)) {
[17:59:21.027]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:21.027]                         envir = ns)
[17:59:21.027]                       envir <- sys.frame(frame)
[17:59:21.027]                       master <- NULL
[17:59:21.027]                       while (!identical(envir, .GlobalEnv) && 
[17:59:21.027]                         !identical(envir, emptyenv())) {
[17:59:21.027]                         if (exists("master", mode = "list", envir = envir, 
[17:59:21.027]                           inherits = FALSE)) {
[17:59:21.027]                           master <- get("master", mode = "list", 
[17:59:21.027]                             envir = envir, inherits = FALSE)
[17:59:21.027]                           if (inherits(master, c("SOCKnode", 
[17:59:21.027]                             "SOCK0node"))) {
[17:59:21.027]                             sendCondition <<- function(cond) {
[17:59:21.027]                               data <- list(type = "VALUE", value = cond, 
[17:59:21.027]                                 success = TRUE)
[17:59:21.027]                               parallel_sendData(master, data)
[17:59:21.027]                             }
[17:59:21.027]                             return(sendCondition)
[17:59:21.027]                           }
[17:59:21.027]                         }
[17:59:21.027]                         frame <- frame + 1L
[17:59:21.027]                         envir <- sys.frame(frame)
[17:59:21.027]                       }
[17:59:21.027]                     }
[17:59:21.027]                     sendCondition <<- function(cond) NULL
[17:59:21.027]                   }
[17:59:21.027]                 })
[17:59:21.027]                 withCallingHandlers({
[17:59:21.027]                   {
[17:59:21.027]                     do.call(function(...) {
[17:59:21.027]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.027]                       if (!identical(...future.globals.maxSize.org, 
[17:59:21.027]                         ...future.globals.maxSize)) {
[17:59:21.027]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.027]                         on.exit(options(oopts), add = TRUE)
[17:59:21.027]                       }
[17:59:21.027]                       {
[17:59:21.027]                         lapply(seq_along(...future.elements_ii), 
[17:59:21.027]                           FUN = function(jj) {
[17:59:21.027]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.027]                             ...future.FUN(...future.X_jj, ...)
[17:59:21.027]                           })
[17:59:21.027]                       }
[17:59:21.027]                     }, args = future.call.arguments)
[17:59:21.027]                   }
[17:59:21.027]                 }, immediateCondition = function(cond) {
[17:59:21.027]                   sendCondition <- ...future.makeSendCondition()
[17:59:21.027]                   sendCondition(cond)
[17:59:21.027]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.027]                   {
[17:59:21.027]                     inherits <- base::inherits
[17:59:21.027]                     invokeRestart <- base::invokeRestart
[17:59:21.027]                     is.null <- base::is.null
[17:59:21.027]                     muffled <- FALSE
[17:59:21.027]                     if (inherits(cond, "message")) {
[17:59:21.027]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:21.027]                       if (muffled) 
[17:59:21.027]                         invokeRestart("muffleMessage")
[17:59:21.027]                     }
[17:59:21.027]                     else if (inherits(cond, "warning")) {
[17:59:21.027]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:21.027]                       if (muffled) 
[17:59:21.027]                         invokeRestart("muffleWarning")
[17:59:21.027]                     }
[17:59:21.027]                     else if (inherits(cond, "condition")) {
[17:59:21.027]                       if (!is.null(pattern)) {
[17:59:21.027]                         computeRestarts <- base::computeRestarts
[17:59:21.027]                         grepl <- base::grepl
[17:59:21.027]                         restarts <- computeRestarts(cond)
[17:59:21.027]                         for (restart in restarts) {
[17:59:21.027]                           name <- restart$name
[17:59:21.027]                           if (is.null(name)) 
[17:59:21.027]                             next
[17:59:21.027]                           if (!grepl(pattern, name)) 
[17:59:21.027]                             next
[17:59:21.027]                           invokeRestart(restart)
[17:59:21.027]                           muffled <- TRUE
[17:59:21.027]                           break
[17:59:21.027]                         }
[17:59:21.027]                       }
[17:59:21.027]                     }
[17:59:21.027]                     invisible(muffled)
[17:59:21.027]                   }
[17:59:21.027]                   muffleCondition(cond)
[17:59:21.027]                 })
[17:59:21.027]             }))
[17:59:21.027]             future::FutureResult(value = ...future.value$value, 
[17:59:21.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.027]                   ...future.rng), globalenv = if (FALSE) 
[17:59:21.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:21.027]                     ...future.globalenv.names))
[17:59:21.027]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:21.027]         }, condition = base::local({
[17:59:21.027]             c <- base::c
[17:59:21.027]             inherits <- base::inherits
[17:59:21.027]             invokeRestart <- base::invokeRestart
[17:59:21.027]             length <- base::length
[17:59:21.027]             list <- base::list
[17:59:21.027]             seq.int <- base::seq.int
[17:59:21.027]             signalCondition <- base::signalCondition
[17:59:21.027]             sys.calls <- base::sys.calls
[17:59:21.027]             `[[` <- base::`[[`
[17:59:21.027]             `+` <- base::`+`
[17:59:21.027]             `<<-` <- base::`<<-`
[17:59:21.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:21.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:21.027]                   3L)]
[17:59:21.027]             }
[17:59:21.027]             function(cond) {
[17:59:21.027]                 is_error <- inherits(cond, "error")
[17:59:21.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:21.027]                   NULL)
[17:59:21.027]                 if (is_error) {
[17:59:21.027]                   sessionInformation <- function() {
[17:59:21.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:21.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:21.027]                       search = base::search(), system = base::Sys.info())
[17:59:21.027]                   }
[17:59:21.027]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:21.027]                     cond$call), session = sessionInformation(), 
[17:59:21.027]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:21.027]                   signalCondition(cond)
[17:59:21.027]                 }
[17:59:21.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:21.027]                 "immediateCondition"))) {
[17:59:21.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:21.027]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:21.027]                   if (TRUE && !signal) {
[17:59:21.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.027]                     {
[17:59:21.027]                       inherits <- base::inherits
[17:59:21.027]                       invokeRestart <- base::invokeRestart
[17:59:21.027]                       is.null <- base::is.null
[17:59:21.027]                       muffled <- FALSE
[17:59:21.027]                       if (inherits(cond, "message")) {
[17:59:21.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.027]                         if (muffled) 
[17:59:21.027]                           invokeRestart("muffleMessage")
[17:59:21.027]                       }
[17:59:21.027]                       else if (inherits(cond, "warning")) {
[17:59:21.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.027]                         if (muffled) 
[17:59:21.027]                           invokeRestart("muffleWarning")
[17:59:21.027]                       }
[17:59:21.027]                       else if (inherits(cond, "condition")) {
[17:59:21.027]                         if (!is.null(pattern)) {
[17:59:21.027]                           computeRestarts <- base::computeRestarts
[17:59:21.027]                           grepl <- base::grepl
[17:59:21.027]                           restarts <- computeRestarts(cond)
[17:59:21.027]                           for (restart in restarts) {
[17:59:21.027]                             name <- restart$name
[17:59:21.027]                             if (is.null(name)) 
[17:59:21.027]                               next
[17:59:21.027]                             if (!grepl(pattern, name)) 
[17:59:21.027]                               next
[17:59:21.027]                             invokeRestart(restart)
[17:59:21.027]                             muffled <- TRUE
[17:59:21.027]                             break
[17:59:21.027]                           }
[17:59:21.027]                         }
[17:59:21.027]                       }
[17:59:21.027]                       invisible(muffled)
[17:59:21.027]                     }
[17:59:21.027]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.027]                   }
[17:59:21.027]                 }
[17:59:21.027]                 else {
[17:59:21.027]                   if (TRUE) {
[17:59:21.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.027]                     {
[17:59:21.027]                       inherits <- base::inherits
[17:59:21.027]                       invokeRestart <- base::invokeRestart
[17:59:21.027]                       is.null <- base::is.null
[17:59:21.027]                       muffled <- FALSE
[17:59:21.027]                       if (inherits(cond, "message")) {
[17:59:21.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.027]                         if (muffled) 
[17:59:21.027]                           invokeRestart("muffleMessage")
[17:59:21.027]                       }
[17:59:21.027]                       else if (inherits(cond, "warning")) {
[17:59:21.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.027]                         if (muffled) 
[17:59:21.027]                           invokeRestart("muffleWarning")
[17:59:21.027]                       }
[17:59:21.027]                       else if (inherits(cond, "condition")) {
[17:59:21.027]                         if (!is.null(pattern)) {
[17:59:21.027]                           computeRestarts <- base::computeRestarts
[17:59:21.027]                           grepl <- base::grepl
[17:59:21.027]                           restarts <- computeRestarts(cond)
[17:59:21.027]                           for (restart in restarts) {
[17:59:21.027]                             name <- restart$name
[17:59:21.027]                             if (is.null(name)) 
[17:59:21.027]                               next
[17:59:21.027]                             if (!grepl(pattern, name)) 
[17:59:21.027]                               next
[17:59:21.027]                             invokeRestart(restart)
[17:59:21.027]                             muffled <- TRUE
[17:59:21.027]                             break
[17:59:21.027]                           }
[17:59:21.027]                         }
[17:59:21.027]                       }
[17:59:21.027]                       invisible(muffled)
[17:59:21.027]                     }
[17:59:21.027]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.027]                   }
[17:59:21.027]                 }
[17:59:21.027]             }
[17:59:21.027]         }))
[17:59:21.027]     }, error = function(ex) {
[17:59:21.027]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:21.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.027]                 ...future.rng), started = ...future.startTime, 
[17:59:21.027]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:21.027]             version = "1.8"), class = "FutureResult")
[17:59:21.027]     }, finally = {
[17:59:21.027]         if (!identical(...future.workdir, getwd())) 
[17:59:21.027]             setwd(...future.workdir)
[17:59:21.027]         {
[17:59:21.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:21.027]                 ...future.oldOptions$nwarnings <- NULL
[17:59:21.027]             }
[17:59:21.027]             base::options(...future.oldOptions)
[17:59:21.027]             if (.Platform$OS.type == "windows") {
[17:59:21.027]                 old_names <- names(...future.oldEnvVars)
[17:59:21.027]                 envs <- base::Sys.getenv()
[17:59:21.027]                 names <- names(envs)
[17:59:21.027]                 common <- intersect(names, old_names)
[17:59:21.027]                 added <- setdiff(names, old_names)
[17:59:21.027]                 removed <- setdiff(old_names, names)
[17:59:21.027]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:21.027]                   envs[common]]
[17:59:21.027]                 NAMES <- toupper(changed)
[17:59:21.027]                 args <- list()
[17:59:21.027]                 for (kk in seq_along(NAMES)) {
[17:59:21.027]                   name <- changed[[kk]]
[17:59:21.027]                   NAME <- NAMES[[kk]]
[17:59:21.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.027]                     next
[17:59:21.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.027]                 }
[17:59:21.027]                 NAMES <- toupper(added)
[17:59:21.027]                 for (kk in seq_along(NAMES)) {
[17:59:21.027]                   name <- added[[kk]]
[17:59:21.027]                   NAME <- NAMES[[kk]]
[17:59:21.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.027]                     next
[17:59:21.027]                   args[[name]] <- ""
[17:59:21.027]                 }
[17:59:21.027]                 NAMES <- toupper(removed)
[17:59:21.027]                 for (kk in seq_along(NAMES)) {
[17:59:21.027]                   name <- removed[[kk]]
[17:59:21.027]                   NAME <- NAMES[[kk]]
[17:59:21.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.027]                     next
[17:59:21.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.027]                 }
[17:59:21.027]                 if (length(args) > 0) 
[17:59:21.027]                   base::do.call(base::Sys.setenv, args = args)
[17:59:21.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:21.027]             }
[17:59:21.027]             else {
[17:59:21.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:21.027]             }
[17:59:21.027]             {
[17:59:21.027]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:21.027]                   0L) {
[17:59:21.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:21.027]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:21.027]                   base::options(opts)
[17:59:21.027]                 }
[17:59:21.027]                 {
[17:59:21.027]                   {
[17:59:21.027]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:21.027]                     NULL
[17:59:21.027]                   }
[17:59:21.027]                   options(future.plan = NULL)
[17:59:21.027]                   if (is.na(NA_character_)) 
[17:59:21.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:21.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:21.027]                     .init = FALSE)
[17:59:21.027]                 }
[17:59:21.027]             }
[17:59:21.027]         }
[17:59:21.027]     })
[17:59:21.027]     if (TRUE) {
[17:59:21.027]         base::sink(type = "output", split = FALSE)
[17:59:21.027]         if (TRUE) {
[17:59:21.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:21.027]         }
[17:59:21.027]         else {
[17:59:21.027]             ...future.result["stdout"] <- base::list(NULL)
[17:59:21.027]         }
[17:59:21.027]         base::close(...future.stdout)
[17:59:21.027]         ...future.stdout <- NULL
[17:59:21.027]     }
[17:59:21.027]     ...future.result$conditions <- ...future.conditions
[17:59:21.027]     ...future.result$finished <- base::Sys.time()
[17:59:21.027]     ...future.result
[17:59:21.027] }
[17:59:21.033] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[17:59:21.033] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:21.034] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:21.035] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[17:59:21.077] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[17:59:21.078] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:59:21.079] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:59:21.079] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:21.080] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:21.080] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:59:21.081] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:59:21.082] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[17:59:21.083] MultisessionFuture started
[17:59:21.083] - Launch lazy future ... done
[17:59:21.084] run() for ‘MultisessionFuture’ ... done
[17:59:21.084] Created future:
[17:59:21.084] MultisessionFuture:
[17:59:21.084] Label: ‘future_apply-2’
[17:59:21.084] Expression:
[17:59:21.084] {
[17:59:21.084]     do.call(function(...) {
[17:59:21.084]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.084]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.084]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.084]             on.exit(options(oopts), add = TRUE)
[17:59:21.084]         }
[17:59:21.084]         {
[17:59:21.084]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.084]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.084]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.084]             })
[17:59:21.084]         }
[17:59:21.084]     }, args = future.call.arguments)
[17:59:21.084] }
[17:59:21.084] Lazy evaluation: FALSE
[17:59:21.084] Asynchronous evaluation: TRUE
[17:59:21.084] Local evaluation: TRUE
[17:59:21.084] Environment: R_GlobalEnv
[17:59:21.084] Capture standard output: TRUE
[17:59:21.084] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:21.084] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:21.084] Packages: <none>
[17:59:21.084] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:21.084] Resolved: FALSE
[17:59:21.084] Value: <not collected>
[17:59:21.084] Conditions captured: <none>
[17:59:21.084] Early signaling: FALSE
[17:59:21.084] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:21.084] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.099] Chunk #2 of 2 ... DONE
[17:59:21.099] Launching 2 futures (chunks) ... DONE
[17:59:21.099] Resolving 2 futures (chunks) ...
[17:59:21.100] resolve() on list ...
[17:59:21.100]  recursive: 0
[17:59:21.100]  length: 2
[17:59:21.101] 
[17:59:21.102] receiveMessageFromWorker() for ClusterFuture ...
[17:59:21.103] - Validating connection of MultisessionFuture
[17:59:21.103] - received message: FutureResult
[17:59:21.104] - Received FutureResult
[17:59:21.104] - Erased future from FutureRegistry
[17:59:21.104] result() for ClusterFuture ...
[17:59:21.105] - result already collected: FutureResult
[17:59:21.105] result() for ClusterFuture ... done
[17:59:21.105] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:21.105] Future #1
[17:59:21.106] result() for ClusterFuture ...
[17:59:21.106] - result already collected: FutureResult
[17:59:21.106] result() for ClusterFuture ... done
[17:59:21.107] result() for ClusterFuture ...
[17:59:21.107] - result already collected: FutureResult
[17:59:21.107] result() for ClusterFuture ... done
[17:59:21.108] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:21.108] - nx: 2
[17:59:21.108] - relay: TRUE
[17:59:21.108] - stdout: TRUE
[17:59:21.109] - signal: TRUE
[17:59:21.109] - resignal: FALSE
[17:59:21.109] - force: TRUE
[17:59:21.110] - relayed: [n=2] FALSE, FALSE
[17:59:21.110] - queued futures: [n=2] FALSE, FALSE
[17:59:21.110]  - until=1
[17:59:21.111]  - relaying element #1
[17:59:21.111] result() for ClusterFuture ...
[17:59:21.111] - result already collected: FutureResult
[17:59:21.111] result() for ClusterFuture ... done
[17:59:21.112] result() for ClusterFuture ...
[17:59:21.112] - result already collected: FutureResult
[17:59:21.112] result() for ClusterFuture ... done
[17:59:21.113] result() for ClusterFuture ...
[17:59:21.113] - result already collected: FutureResult
[17:59:21.113] result() for ClusterFuture ... done
[17:59:21.114] result() for ClusterFuture ...
[17:59:21.114] - result already collected: FutureResult
[17:59:21.114] result() for ClusterFuture ... done
[17:59:21.114] - relayed: [n=2] TRUE, FALSE
[17:59:21.115] - queued futures: [n=2] TRUE, FALSE
[17:59:21.115] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:21.115]  length: 1 (resolved future 1)
[17:59:21.138] receiveMessageFromWorker() for ClusterFuture ...
[17:59:21.139] - Validating connection of MultisessionFuture
[17:59:21.139] - received message: FutureResult
[17:59:21.140] - Received FutureResult
[17:59:21.140] - Erased future from FutureRegistry
[17:59:21.141] result() for ClusterFuture ...
[17:59:21.141] - result already collected: FutureResult
[17:59:21.141] result() for ClusterFuture ... done
[17:59:21.141] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:21.142] Future #2
[17:59:21.142] result() for ClusterFuture ...
[17:59:21.142] - result already collected: FutureResult
[17:59:21.143] result() for ClusterFuture ... done
[17:59:21.143] result() for ClusterFuture ...
[17:59:21.143] - result already collected: FutureResult
[17:59:21.144] result() for ClusterFuture ... done
[17:59:21.144] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:21.144] - nx: 2
[17:59:21.145] - relay: TRUE
[17:59:21.145] - stdout: TRUE
[17:59:21.145] - signal: TRUE
[17:59:21.145] - resignal: FALSE
[17:59:21.146] - force: TRUE
[17:59:21.146] - relayed: [n=2] TRUE, FALSE
[17:59:21.146] - queued futures: [n=2] TRUE, FALSE
[17:59:21.147]  - until=2
[17:59:21.147]  - relaying element #2
[17:59:21.147] result() for ClusterFuture ...
[17:59:21.148] - result already collected: FutureResult
[17:59:21.148] result() for ClusterFuture ... done
[17:59:21.148] result() for ClusterFuture ...
[17:59:21.148] - result already collected: FutureResult
[17:59:21.152] result() for ClusterFuture ... done
[17:59:21.153] result() for ClusterFuture ...
[17:59:21.153] - result already collected: FutureResult
[17:59:21.153] result() for ClusterFuture ... done
[17:59:21.154] result() for ClusterFuture ...
[17:59:21.154] - result already collected: FutureResult
[17:59:21.154] result() for ClusterFuture ... done
[17:59:21.154] - relayed: [n=2] TRUE, TRUE
[17:59:21.155] - queued futures: [n=2] TRUE, TRUE
[17:59:21.155] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:21.155]  length: 0 (resolved future 2)
[17:59:21.156] Relaying remaining futures
[17:59:21.156] signalConditionsASAP(NULL, pos=0) ...
[17:59:21.156] - nx: 2
[17:59:21.157] - relay: TRUE
[17:59:21.157] - stdout: TRUE
[17:59:21.157] - signal: TRUE
[17:59:21.157] - resignal: FALSE
[17:59:21.158] - force: TRUE
[17:59:21.158] - relayed: [n=2] TRUE, TRUE
[17:59:21.158] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:21.159] - relayed: [n=2] TRUE, TRUE
[17:59:21.159] - queued futures: [n=2] TRUE, TRUE
[17:59:21.159] signalConditionsASAP(NULL, pos=0) ... done
[17:59:21.160] resolve() on list ... DONE
[17:59:21.160] result() for ClusterFuture ...
[17:59:21.160] - result already collected: FutureResult
[17:59:21.161] result() for ClusterFuture ... done
[17:59:21.161] result() for ClusterFuture ...
[17:59:21.161] - result already collected: FutureResult
[17:59:21.162] result() for ClusterFuture ... done
[17:59:21.162] result() for ClusterFuture ...
[17:59:21.162] - result already collected: FutureResult
[17:59:21.162] result() for ClusterFuture ... done
[17:59:21.163] result() for ClusterFuture ...
[17:59:21.163] - result already collected: FutureResult
[17:59:21.163] result() for ClusterFuture ... done
[17:59:21.164]  - Number of value chunks collected: 2
[17:59:21.164] Resolving 2 futures (chunks) ... DONE
[17:59:21.164] Reducing values from 2 chunks ...
[17:59:21.165]  - Number of values collected after concatenation: 2
[17:59:21.165]  - Number of values expected: 2
[17:59:21.165] Reducing values from 2 chunks ... DONE
[17:59:21.165] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:59:21.168] getGlobalsAndPackagesXApply() ...
[17:59:21.168]  - future.globals: TRUE
[17:59:21.168] getGlobalsAndPackages() ...
[17:59:21.169] Searching for globals...
[17:59:21.172] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:21.173] Searching for globals ... DONE
[17:59:21.173] Resolving globals: FALSE
[17:59:21.174] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:21.175] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:21.175] - globals: [1] ‘FUN’
[17:59:21.176] - packages: [1] ‘stats’
[17:59:21.176] getGlobalsAndPackages() ... DONE
[17:59:21.176]  - globals found/used: [n=1] ‘FUN’
[17:59:21.176]  - needed namespaces: [n=1] ‘stats’
[17:59:21.177] Finding globals ... DONE
[17:59:21.177]  - use_args: TRUE
[17:59:21.177]  - Getting '...' globals ...
[17:59:21.178] resolve() on list ...
[17:59:21.178]  recursive: 0
[17:59:21.179]  length: 1
[17:59:21.179]  elements: ‘...’
[17:59:21.179]  length: 0 (resolved future 1)
[17:59:21.179] resolve() on list ... DONE
[17:59:21.180]    - '...' content: [n=0] 
[17:59:21.180] List of 1
[17:59:21.180]  $ ...: list()
[17:59:21.180]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.180]  - attr(*, "where")=List of 1
[17:59:21.180]   ..$ ...:<environment: 0x56085b945758> 
[17:59:21.180]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.180]  - attr(*, "resolved")= logi TRUE
[17:59:21.180]  - attr(*, "total_size")= num NA
[17:59:21.187]  - Getting '...' globals ... DONE
[17:59:21.187] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:21.188] List of 2
[17:59:21.188]  $ ...future.FUN:function (x, ...)  
[17:59:21.188]  $ ...          : list()
[17:59:21.188]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.188]  - attr(*, "where")=List of 2
[17:59:21.188]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:21.188]   ..$ ...          :<environment: 0x56085b945758> 
[17:59:21.188]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.188]  - attr(*, "resolved")= logi FALSE
[17:59:21.188]  - attr(*, "total_size")= num 1248
[17:59:21.195] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:21.195] getGlobalsAndPackagesXApply() ... DONE
[17:59:21.201] future_lapply() ...
[17:59:21.208] Number of chunks: 2
[17:59:21.209] getGlobalsAndPackagesXApply() ...
[17:59:21.209]  - future.globals: <name-value list> with names ‘list()’
[17:59:21.209]  - use_args: TRUE
[17:59:21.209] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:21.210] List of 2
[17:59:21.210]  $ ...          : list()
[17:59:21.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.210]  $ ...future.FUN:function (x, ...)  
[17:59:21.210]  - attr(*, "where")=List of 2
[17:59:21.210]   ..$ ...          :<environment: 0x56085b945758> 
[17:59:21.210]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:59:21.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.210]  - attr(*, "resolved")= logi FALSE
[17:59:21.210]  - attr(*, "total_size")= num NA
[17:59:21.216] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:21.216] getGlobalsAndPackagesXApply() ... DONE
[17:59:21.217] Number of futures (= number of chunks): 2
[17:59:21.217] Launching 2 futures (chunks) ...
[17:59:21.217] Chunk #1 of 2 ...
[17:59:21.217]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:21.218]  - seeds: <none>
[17:59:21.218]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.218] getGlobalsAndPackages() ...
[17:59:21.218] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.218] Resolving globals: FALSE
[17:59:21.219] Tweak future expression to call with '...' arguments ...
[17:59:21.219] {
[17:59:21.219]     do.call(function(...) {
[17:59:21.219]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.219]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.219]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.219]             on.exit(options(oopts), add = TRUE)
[17:59:21.219]         }
[17:59:21.219]         {
[17:59:21.219]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.219]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.219]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.219]             })
[17:59:21.219]         }
[17:59:21.219]     }, args = future.call.arguments)
[17:59:21.219] }
[17:59:21.220] Tweak future expression to call with '...' arguments ... DONE
[17:59:21.220] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.221] - packages: [1] ‘stats’
[17:59:21.221] getGlobalsAndPackages() ... DONE
[17:59:21.222] run() for ‘Future’ ...
[17:59:21.222] - state: ‘created’
[17:59:21.222] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:21.247] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.248] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:21.248]   - Field: ‘node’
[17:59:21.248]   - Field: ‘label’
[17:59:21.248]   - Field: ‘local’
[17:59:21.248]   - Field: ‘owner’
[17:59:21.249]   - Field: ‘envir’
[17:59:21.249]   - Field: ‘workers’
[17:59:21.249]   - Field: ‘packages’
[17:59:21.249]   - Field: ‘gc’
[17:59:21.249]   - Field: ‘conditions’
[17:59:21.250]   - Field: ‘persistent’
[17:59:21.250]   - Field: ‘expr’
[17:59:21.250]   - Field: ‘uuid’
[17:59:21.250]   - Field: ‘seed’
[17:59:21.250]   - Field: ‘version’
[17:59:21.251]   - Field: ‘result’
[17:59:21.251]   - Field: ‘asynchronous’
[17:59:21.251]   - Field: ‘calls’
[17:59:21.251]   - Field: ‘globals’
[17:59:21.251]   - Field: ‘stdout’
[17:59:21.252]   - Field: ‘earlySignal’
[17:59:21.252]   - Field: ‘lazy’
[17:59:21.252]   - Field: ‘state’
[17:59:21.252] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:21.252] - Launch lazy future ...
[17:59:21.253] Packages needed by the future expression (n = 1): ‘stats’
[17:59:21.253] Packages needed by future strategies (n = 0): <none>
[17:59:21.254] {
[17:59:21.254]     {
[17:59:21.254]         {
[17:59:21.254]             ...future.startTime <- base::Sys.time()
[17:59:21.254]             {
[17:59:21.254]                 {
[17:59:21.254]                   {
[17:59:21.254]                     {
[17:59:21.254]                       {
[17:59:21.254]                         base::local({
[17:59:21.254]                           has_future <- base::requireNamespace("future", 
[17:59:21.254]                             quietly = TRUE)
[17:59:21.254]                           if (has_future) {
[17:59:21.254]                             ns <- base::getNamespace("future")
[17:59:21.254]                             version <- ns[[".package"]][["version"]]
[17:59:21.254]                             if (is.null(version)) 
[17:59:21.254]                               version <- utils::packageVersion("future")
[17:59:21.254]                           }
[17:59:21.254]                           else {
[17:59:21.254]                             version <- NULL
[17:59:21.254]                           }
[17:59:21.254]                           if (!has_future || version < "1.8.0") {
[17:59:21.254]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:21.254]                               "", base::R.version$version.string), 
[17:59:21.254]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:21.254]                                 base::R.version$platform, 8 * 
[17:59:21.254]                                   base::.Machine$sizeof.pointer), 
[17:59:21.254]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:21.254]                                 "release", "version")], collapse = " "), 
[17:59:21.254]                               hostname = base::Sys.info()[["nodename"]])
[17:59:21.254]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:21.254]                               info)
[17:59:21.254]                             info <- base::paste(info, collapse = "; ")
[17:59:21.254]                             if (!has_future) {
[17:59:21.254]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:21.254]                                 info)
[17:59:21.254]                             }
[17:59:21.254]                             else {
[17:59:21.254]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:21.254]                                 info, version)
[17:59:21.254]                             }
[17:59:21.254]                             base::stop(msg)
[17:59:21.254]                           }
[17:59:21.254]                         })
[17:59:21.254]                       }
[17:59:21.254]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:21.254]                       base::options(mc.cores = 1L)
[17:59:21.254]                     }
[17:59:21.254]                     base::local({
[17:59:21.254]                       for (pkg in "stats") {
[17:59:21.254]                         base::loadNamespace(pkg)
[17:59:21.254]                         base::library(pkg, character.only = TRUE)
[17:59:21.254]                       }
[17:59:21.254]                     })
[17:59:21.254]                   }
[17:59:21.254]                   ...future.strategy.old <- future::plan("list")
[17:59:21.254]                   options(future.plan = NULL)
[17:59:21.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:21.254]                 }
[17:59:21.254]                 ...future.workdir <- getwd()
[17:59:21.254]             }
[17:59:21.254]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:21.254]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:21.254]         }
[17:59:21.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:21.254]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:21.254]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:21.254]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:21.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:21.254]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:21.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:21.254]             base::names(...future.oldOptions))
[17:59:21.254]     }
[17:59:21.254]     if (FALSE) {
[17:59:21.254]     }
[17:59:21.254]     else {
[17:59:21.254]         if (TRUE) {
[17:59:21.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:21.254]                 open = "w")
[17:59:21.254]         }
[17:59:21.254]         else {
[17:59:21.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:21.254]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:21.254]         }
[17:59:21.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:21.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:21.254]             base::sink(type = "output", split = FALSE)
[17:59:21.254]             base::close(...future.stdout)
[17:59:21.254]         }, add = TRUE)
[17:59:21.254]     }
[17:59:21.254]     ...future.frame <- base::sys.nframe()
[17:59:21.254]     ...future.conditions <- base::list()
[17:59:21.254]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:21.254]     if (FALSE) {
[17:59:21.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:21.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:21.254]     }
[17:59:21.254]     ...future.result <- base::tryCatch({
[17:59:21.254]         base::withCallingHandlers({
[17:59:21.254]             ...future.value <- base::withVisible(base::local({
[17:59:21.254]                 ...future.makeSendCondition <- base::local({
[17:59:21.254]                   sendCondition <- NULL
[17:59:21.254]                   function(frame = 1L) {
[17:59:21.254]                     if (is.function(sendCondition)) 
[17:59:21.254]                       return(sendCondition)
[17:59:21.254]                     ns <- getNamespace("parallel")
[17:59:21.254]                     if (exists("sendData", mode = "function", 
[17:59:21.254]                       envir = ns)) {
[17:59:21.254]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:21.254]                         envir = ns)
[17:59:21.254]                       envir <- sys.frame(frame)
[17:59:21.254]                       master <- NULL
[17:59:21.254]                       while (!identical(envir, .GlobalEnv) && 
[17:59:21.254]                         !identical(envir, emptyenv())) {
[17:59:21.254]                         if (exists("master", mode = "list", envir = envir, 
[17:59:21.254]                           inherits = FALSE)) {
[17:59:21.254]                           master <- get("master", mode = "list", 
[17:59:21.254]                             envir = envir, inherits = FALSE)
[17:59:21.254]                           if (inherits(master, c("SOCKnode", 
[17:59:21.254]                             "SOCK0node"))) {
[17:59:21.254]                             sendCondition <<- function(cond) {
[17:59:21.254]                               data <- list(type = "VALUE", value = cond, 
[17:59:21.254]                                 success = TRUE)
[17:59:21.254]                               parallel_sendData(master, data)
[17:59:21.254]                             }
[17:59:21.254]                             return(sendCondition)
[17:59:21.254]                           }
[17:59:21.254]                         }
[17:59:21.254]                         frame <- frame + 1L
[17:59:21.254]                         envir <- sys.frame(frame)
[17:59:21.254]                       }
[17:59:21.254]                     }
[17:59:21.254]                     sendCondition <<- function(cond) NULL
[17:59:21.254]                   }
[17:59:21.254]                 })
[17:59:21.254]                 withCallingHandlers({
[17:59:21.254]                   {
[17:59:21.254]                     do.call(function(...) {
[17:59:21.254]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.254]                       if (!identical(...future.globals.maxSize.org, 
[17:59:21.254]                         ...future.globals.maxSize)) {
[17:59:21.254]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.254]                         on.exit(options(oopts), add = TRUE)
[17:59:21.254]                       }
[17:59:21.254]                       {
[17:59:21.254]                         lapply(seq_along(...future.elements_ii), 
[17:59:21.254]                           FUN = function(jj) {
[17:59:21.254]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.254]                             ...future.FUN(...future.X_jj, ...)
[17:59:21.254]                           })
[17:59:21.254]                       }
[17:59:21.254]                     }, args = future.call.arguments)
[17:59:21.254]                   }
[17:59:21.254]                 }, immediateCondition = function(cond) {
[17:59:21.254]                   sendCondition <- ...future.makeSendCondition()
[17:59:21.254]                   sendCondition(cond)
[17:59:21.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.254]                   {
[17:59:21.254]                     inherits <- base::inherits
[17:59:21.254]                     invokeRestart <- base::invokeRestart
[17:59:21.254]                     is.null <- base::is.null
[17:59:21.254]                     muffled <- FALSE
[17:59:21.254]                     if (inherits(cond, "message")) {
[17:59:21.254]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:21.254]                       if (muffled) 
[17:59:21.254]                         invokeRestart("muffleMessage")
[17:59:21.254]                     }
[17:59:21.254]                     else if (inherits(cond, "warning")) {
[17:59:21.254]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:21.254]                       if (muffled) 
[17:59:21.254]                         invokeRestart("muffleWarning")
[17:59:21.254]                     }
[17:59:21.254]                     else if (inherits(cond, "condition")) {
[17:59:21.254]                       if (!is.null(pattern)) {
[17:59:21.254]                         computeRestarts <- base::computeRestarts
[17:59:21.254]                         grepl <- base::grepl
[17:59:21.254]                         restarts <- computeRestarts(cond)
[17:59:21.254]                         for (restart in restarts) {
[17:59:21.254]                           name <- restart$name
[17:59:21.254]                           if (is.null(name)) 
[17:59:21.254]                             next
[17:59:21.254]                           if (!grepl(pattern, name)) 
[17:59:21.254]                             next
[17:59:21.254]                           invokeRestart(restart)
[17:59:21.254]                           muffled <- TRUE
[17:59:21.254]                           break
[17:59:21.254]                         }
[17:59:21.254]                       }
[17:59:21.254]                     }
[17:59:21.254]                     invisible(muffled)
[17:59:21.254]                   }
[17:59:21.254]                   muffleCondition(cond)
[17:59:21.254]                 })
[17:59:21.254]             }))
[17:59:21.254]             future::FutureResult(value = ...future.value$value, 
[17:59:21.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.254]                   ...future.rng), globalenv = if (FALSE) 
[17:59:21.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:21.254]                     ...future.globalenv.names))
[17:59:21.254]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:21.254]         }, condition = base::local({
[17:59:21.254]             c <- base::c
[17:59:21.254]             inherits <- base::inherits
[17:59:21.254]             invokeRestart <- base::invokeRestart
[17:59:21.254]             length <- base::length
[17:59:21.254]             list <- base::list
[17:59:21.254]             seq.int <- base::seq.int
[17:59:21.254]             signalCondition <- base::signalCondition
[17:59:21.254]             sys.calls <- base::sys.calls
[17:59:21.254]             `[[` <- base::`[[`
[17:59:21.254]             `+` <- base::`+`
[17:59:21.254]             `<<-` <- base::`<<-`
[17:59:21.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:21.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:21.254]                   3L)]
[17:59:21.254]             }
[17:59:21.254]             function(cond) {
[17:59:21.254]                 is_error <- inherits(cond, "error")
[17:59:21.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:21.254]                   NULL)
[17:59:21.254]                 if (is_error) {
[17:59:21.254]                   sessionInformation <- function() {
[17:59:21.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:21.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:21.254]                       search = base::search(), system = base::Sys.info())
[17:59:21.254]                   }
[17:59:21.254]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:21.254]                     cond$call), session = sessionInformation(), 
[17:59:21.254]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:21.254]                   signalCondition(cond)
[17:59:21.254]                 }
[17:59:21.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:21.254]                 "immediateCondition"))) {
[17:59:21.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:21.254]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:21.254]                   if (TRUE && !signal) {
[17:59:21.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.254]                     {
[17:59:21.254]                       inherits <- base::inherits
[17:59:21.254]                       invokeRestart <- base::invokeRestart
[17:59:21.254]                       is.null <- base::is.null
[17:59:21.254]                       muffled <- FALSE
[17:59:21.254]                       if (inherits(cond, "message")) {
[17:59:21.254]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.254]                         if (muffled) 
[17:59:21.254]                           invokeRestart("muffleMessage")
[17:59:21.254]                       }
[17:59:21.254]                       else if (inherits(cond, "warning")) {
[17:59:21.254]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.254]                         if (muffled) 
[17:59:21.254]                           invokeRestart("muffleWarning")
[17:59:21.254]                       }
[17:59:21.254]                       else if (inherits(cond, "condition")) {
[17:59:21.254]                         if (!is.null(pattern)) {
[17:59:21.254]                           computeRestarts <- base::computeRestarts
[17:59:21.254]                           grepl <- base::grepl
[17:59:21.254]                           restarts <- computeRestarts(cond)
[17:59:21.254]                           for (restart in restarts) {
[17:59:21.254]                             name <- restart$name
[17:59:21.254]                             if (is.null(name)) 
[17:59:21.254]                               next
[17:59:21.254]                             if (!grepl(pattern, name)) 
[17:59:21.254]                               next
[17:59:21.254]                             invokeRestart(restart)
[17:59:21.254]                             muffled <- TRUE
[17:59:21.254]                             break
[17:59:21.254]                           }
[17:59:21.254]                         }
[17:59:21.254]                       }
[17:59:21.254]                       invisible(muffled)
[17:59:21.254]                     }
[17:59:21.254]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.254]                   }
[17:59:21.254]                 }
[17:59:21.254]                 else {
[17:59:21.254]                   if (TRUE) {
[17:59:21.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.254]                     {
[17:59:21.254]                       inherits <- base::inherits
[17:59:21.254]                       invokeRestart <- base::invokeRestart
[17:59:21.254]                       is.null <- base::is.null
[17:59:21.254]                       muffled <- FALSE
[17:59:21.254]                       if (inherits(cond, "message")) {
[17:59:21.254]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.254]                         if (muffled) 
[17:59:21.254]                           invokeRestart("muffleMessage")
[17:59:21.254]                       }
[17:59:21.254]                       else if (inherits(cond, "warning")) {
[17:59:21.254]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.254]                         if (muffled) 
[17:59:21.254]                           invokeRestart("muffleWarning")
[17:59:21.254]                       }
[17:59:21.254]                       else if (inherits(cond, "condition")) {
[17:59:21.254]                         if (!is.null(pattern)) {
[17:59:21.254]                           computeRestarts <- base::computeRestarts
[17:59:21.254]                           grepl <- base::grepl
[17:59:21.254]                           restarts <- computeRestarts(cond)
[17:59:21.254]                           for (restart in restarts) {
[17:59:21.254]                             name <- restart$name
[17:59:21.254]                             if (is.null(name)) 
[17:59:21.254]                               next
[17:59:21.254]                             if (!grepl(pattern, name)) 
[17:59:21.254]                               next
[17:59:21.254]                             invokeRestart(restart)
[17:59:21.254]                             muffled <- TRUE
[17:59:21.254]                             break
[17:59:21.254]                           }
[17:59:21.254]                         }
[17:59:21.254]                       }
[17:59:21.254]                       invisible(muffled)
[17:59:21.254]                     }
[17:59:21.254]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.254]                   }
[17:59:21.254]                 }
[17:59:21.254]             }
[17:59:21.254]         }))
[17:59:21.254]     }, error = function(ex) {
[17:59:21.254]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:21.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.254]                 ...future.rng), started = ...future.startTime, 
[17:59:21.254]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:21.254]             version = "1.8"), class = "FutureResult")
[17:59:21.254]     }, finally = {
[17:59:21.254]         if (!identical(...future.workdir, getwd())) 
[17:59:21.254]             setwd(...future.workdir)
[17:59:21.254]         {
[17:59:21.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:21.254]                 ...future.oldOptions$nwarnings <- NULL
[17:59:21.254]             }
[17:59:21.254]             base::options(...future.oldOptions)
[17:59:21.254]             if (.Platform$OS.type == "windows") {
[17:59:21.254]                 old_names <- names(...future.oldEnvVars)
[17:59:21.254]                 envs <- base::Sys.getenv()
[17:59:21.254]                 names <- names(envs)
[17:59:21.254]                 common <- intersect(names, old_names)
[17:59:21.254]                 added <- setdiff(names, old_names)
[17:59:21.254]                 removed <- setdiff(old_names, names)
[17:59:21.254]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:21.254]                   envs[common]]
[17:59:21.254]                 NAMES <- toupper(changed)
[17:59:21.254]                 args <- list()
[17:59:21.254]                 for (kk in seq_along(NAMES)) {
[17:59:21.254]                   name <- changed[[kk]]
[17:59:21.254]                   NAME <- NAMES[[kk]]
[17:59:21.254]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.254]                     next
[17:59:21.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.254]                 }
[17:59:21.254]                 NAMES <- toupper(added)
[17:59:21.254]                 for (kk in seq_along(NAMES)) {
[17:59:21.254]                   name <- added[[kk]]
[17:59:21.254]                   NAME <- NAMES[[kk]]
[17:59:21.254]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.254]                     next
[17:59:21.254]                   args[[name]] <- ""
[17:59:21.254]                 }
[17:59:21.254]                 NAMES <- toupper(removed)
[17:59:21.254]                 for (kk in seq_along(NAMES)) {
[17:59:21.254]                   name <- removed[[kk]]
[17:59:21.254]                   NAME <- NAMES[[kk]]
[17:59:21.254]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.254]                     next
[17:59:21.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.254]                 }
[17:59:21.254]                 if (length(args) > 0) 
[17:59:21.254]                   base::do.call(base::Sys.setenv, args = args)
[17:59:21.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:21.254]             }
[17:59:21.254]             else {
[17:59:21.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:21.254]             }
[17:59:21.254]             {
[17:59:21.254]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:21.254]                   0L) {
[17:59:21.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:21.254]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:21.254]                   base::options(opts)
[17:59:21.254]                 }
[17:59:21.254]                 {
[17:59:21.254]                   {
[17:59:21.254]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:21.254]                     NULL
[17:59:21.254]                   }
[17:59:21.254]                   options(future.plan = NULL)
[17:59:21.254]                   if (is.na(NA_character_)) 
[17:59:21.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:21.254]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:21.254]                     .init = FALSE)
[17:59:21.254]                 }
[17:59:21.254]             }
[17:59:21.254]         }
[17:59:21.254]     })
[17:59:21.254]     if (TRUE) {
[17:59:21.254]         base::sink(type = "output", split = FALSE)
[17:59:21.254]         if (TRUE) {
[17:59:21.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:21.254]         }
[17:59:21.254]         else {
[17:59:21.254]             ...future.result["stdout"] <- base::list(NULL)
[17:59:21.254]         }
[17:59:21.254]         base::close(...future.stdout)
[17:59:21.254]         ...future.stdout <- NULL
[17:59:21.254]     }
[17:59:21.254]     ...future.result$conditions <- ...future.conditions
[17:59:21.254]     ...future.result$finished <- base::Sys.time()
[17:59:21.254]     ...future.result
[17:59:21.254] }
[17:59:21.260] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[17:59:21.260] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:21.261] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:21.262] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:59:21.262] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:59:21.263] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:59:21.263] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:59:21.264] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:21.264] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:21.265] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:59:21.266] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:59:21.266] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[17:59:21.267] MultisessionFuture started
[17:59:21.268] - Launch lazy future ... done
[17:59:21.268] run() for ‘MultisessionFuture’ ... done
[17:59:21.268] Created future:
[17:59:21.268] MultisessionFuture:
[17:59:21.268] Label: ‘future_apply-1’
[17:59:21.268] Expression:
[17:59:21.268] {
[17:59:21.268]     do.call(function(...) {
[17:59:21.268]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.268]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.268]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.268]             on.exit(options(oopts), add = TRUE)
[17:59:21.268]         }
[17:59:21.268]         {
[17:59:21.268]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.268]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.268]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.268]             })
[17:59:21.268]         }
[17:59:21.268]     }, args = future.call.arguments)
[17:59:21.268] }
[17:59:21.268] Lazy evaluation: FALSE
[17:59:21.268] Asynchronous evaluation: TRUE
[17:59:21.268] Local evaluation: TRUE
[17:59:21.268] Environment: R_GlobalEnv
[17:59:21.268] Capture standard output: TRUE
[17:59:21.268] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:21.268] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:21.268] Packages: 1 packages (‘stats’)
[17:59:21.268] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:21.268] Resolved: FALSE
[17:59:21.268] Value: <not collected>
[17:59:21.268] Conditions captured: <none>
[17:59:21.268] Early signaling: FALSE
[17:59:21.268] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:21.268] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.283] Chunk #1 of 2 ... DONE
[17:59:21.283] Chunk #2 of 2 ...
[17:59:21.283]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:21.283]  - seeds: <none>
[17:59:21.284]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.284] getGlobalsAndPackages() ...
[17:59:21.284] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.284] Resolving globals: FALSE
[17:59:21.285] Tweak future expression to call with '...' arguments ...
[17:59:21.285] {
[17:59:21.285]     do.call(function(...) {
[17:59:21.285]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.285]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.285]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.285]             on.exit(options(oopts), add = TRUE)
[17:59:21.285]         }
[17:59:21.285]         {
[17:59:21.285]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.285]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.285]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.285]             })
[17:59:21.285]         }
[17:59:21.285]     }, args = future.call.arguments)
[17:59:21.285] }
[17:59:21.286] Tweak future expression to call with '...' arguments ... DONE
[17:59:21.286] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.287] - packages: [1] ‘stats’
[17:59:21.287] getGlobalsAndPackages() ... DONE
[17:59:21.288] run() for ‘Future’ ...
[17:59:21.288] - state: ‘created’
[17:59:21.288] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:21.312] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:21.312]   - Field: ‘node’
[17:59:21.312]   - Field: ‘label’
[17:59:21.313]   - Field: ‘local’
[17:59:21.313]   - Field: ‘owner’
[17:59:21.313]   - Field: ‘envir’
[17:59:21.313]   - Field: ‘workers’
[17:59:21.314]   - Field: ‘packages’
[17:59:21.314]   - Field: ‘gc’
[17:59:21.314]   - Field: ‘conditions’
[17:59:21.314]   - Field: ‘persistent’
[17:59:21.314]   - Field: ‘expr’
[17:59:21.314]   - Field: ‘uuid’
[17:59:21.315]   - Field: ‘seed’
[17:59:21.315]   - Field: ‘version’
[17:59:21.315]   - Field: ‘result’
[17:59:21.315]   - Field: ‘asynchronous’
[17:59:21.315]   - Field: ‘calls’
[17:59:21.316]   - Field: ‘globals’
[17:59:21.316]   - Field: ‘stdout’
[17:59:21.316]   - Field: ‘earlySignal’
[17:59:21.316]   - Field: ‘lazy’
[17:59:21.316]   - Field: ‘state’
[17:59:21.317] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:21.317] - Launch lazy future ...
[17:59:21.317] Packages needed by the future expression (n = 1): ‘stats’
[17:59:21.318] Packages needed by future strategies (n = 0): <none>
[17:59:21.319] {
[17:59:21.319]     {
[17:59:21.319]         {
[17:59:21.319]             ...future.startTime <- base::Sys.time()
[17:59:21.319]             {
[17:59:21.319]                 {
[17:59:21.319]                   {
[17:59:21.319]                     {
[17:59:21.319]                       {
[17:59:21.319]                         base::local({
[17:59:21.319]                           has_future <- base::requireNamespace("future", 
[17:59:21.319]                             quietly = TRUE)
[17:59:21.319]                           if (has_future) {
[17:59:21.319]                             ns <- base::getNamespace("future")
[17:59:21.319]                             version <- ns[[".package"]][["version"]]
[17:59:21.319]                             if (is.null(version)) 
[17:59:21.319]                               version <- utils::packageVersion("future")
[17:59:21.319]                           }
[17:59:21.319]                           else {
[17:59:21.319]                             version <- NULL
[17:59:21.319]                           }
[17:59:21.319]                           if (!has_future || version < "1.8.0") {
[17:59:21.319]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:21.319]                               "", base::R.version$version.string), 
[17:59:21.319]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:21.319]                                 base::R.version$platform, 8 * 
[17:59:21.319]                                   base::.Machine$sizeof.pointer), 
[17:59:21.319]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:21.319]                                 "release", "version")], collapse = " "), 
[17:59:21.319]                               hostname = base::Sys.info()[["nodename"]])
[17:59:21.319]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:21.319]                               info)
[17:59:21.319]                             info <- base::paste(info, collapse = "; ")
[17:59:21.319]                             if (!has_future) {
[17:59:21.319]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:21.319]                                 info)
[17:59:21.319]                             }
[17:59:21.319]                             else {
[17:59:21.319]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:21.319]                                 info, version)
[17:59:21.319]                             }
[17:59:21.319]                             base::stop(msg)
[17:59:21.319]                           }
[17:59:21.319]                         })
[17:59:21.319]                       }
[17:59:21.319]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:21.319]                       base::options(mc.cores = 1L)
[17:59:21.319]                     }
[17:59:21.319]                     base::local({
[17:59:21.319]                       for (pkg in "stats") {
[17:59:21.319]                         base::loadNamespace(pkg)
[17:59:21.319]                         base::library(pkg, character.only = TRUE)
[17:59:21.319]                       }
[17:59:21.319]                     })
[17:59:21.319]                   }
[17:59:21.319]                   ...future.strategy.old <- future::plan("list")
[17:59:21.319]                   options(future.plan = NULL)
[17:59:21.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:21.319]                 }
[17:59:21.319]                 ...future.workdir <- getwd()
[17:59:21.319]             }
[17:59:21.319]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:21.319]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:21.319]         }
[17:59:21.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:21.319]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:21.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:21.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:21.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:21.319]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:21.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:21.319]             base::names(...future.oldOptions))
[17:59:21.319]     }
[17:59:21.319]     if (FALSE) {
[17:59:21.319]     }
[17:59:21.319]     else {
[17:59:21.319]         if (TRUE) {
[17:59:21.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:21.319]                 open = "w")
[17:59:21.319]         }
[17:59:21.319]         else {
[17:59:21.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:21.319]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:21.319]         }
[17:59:21.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:21.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:21.319]             base::sink(type = "output", split = FALSE)
[17:59:21.319]             base::close(...future.stdout)
[17:59:21.319]         }, add = TRUE)
[17:59:21.319]     }
[17:59:21.319]     ...future.frame <- base::sys.nframe()
[17:59:21.319]     ...future.conditions <- base::list()
[17:59:21.319]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:21.319]     if (FALSE) {
[17:59:21.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:21.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:21.319]     }
[17:59:21.319]     ...future.result <- base::tryCatch({
[17:59:21.319]         base::withCallingHandlers({
[17:59:21.319]             ...future.value <- base::withVisible(base::local({
[17:59:21.319]                 ...future.makeSendCondition <- base::local({
[17:59:21.319]                   sendCondition <- NULL
[17:59:21.319]                   function(frame = 1L) {
[17:59:21.319]                     if (is.function(sendCondition)) 
[17:59:21.319]                       return(sendCondition)
[17:59:21.319]                     ns <- getNamespace("parallel")
[17:59:21.319]                     if (exists("sendData", mode = "function", 
[17:59:21.319]                       envir = ns)) {
[17:59:21.319]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:21.319]                         envir = ns)
[17:59:21.319]                       envir <- sys.frame(frame)
[17:59:21.319]                       master <- NULL
[17:59:21.319]                       while (!identical(envir, .GlobalEnv) && 
[17:59:21.319]                         !identical(envir, emptyenv())) {
[17:59:21.319]                         if (exists("master", mode = "list", envir = envir, 
[17:59:21.319]                           inherits = FALSE)) {
[17:59:21.319]                           master <- get("master", mode = "list", 
[17:59:21.319]                             envir = envir, inherits = FALSE)
[17:59:21.319]                           if (inherits(master, c("SOCKnode", 
[17:59:21.319]                             "SOCK0node"))) {
[17:59:21.319]                             sendCondition <<- function(cond) {
[17:59:21.319]                               data <- list(type = "VALUE", value = cond, 
[17:59:21.319]                                 success = TRUE)
[17:59:21.319]                               parallel_sendData(master, data)
[17:59:21.319]                             }
[17:59:21.319]                             return(sendCondition)
[17:59:21.319]                           }
[17:59:21.319]                         }
[17:59:21.319]                         frame <- frame + 1L
[17:59:21.319]                         envir <- sys.frame(frame)
[17:59:21.319]                       }
[17:59:21.319]                     }
[17:59:21.319]                     sendCondition <<- function(cond) NULL
[17:59:21.319]                   }
[17:59:21.319]                 })
[17:59:21.319]                 withCallingHandlers({
[17:59:21.319]                   {
[17:59:21.319]                     do.call(function(...) {
[17:59:21.319]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.319]                       if (!identical(...future.globals.maxSize.org, 
[17:59:21.319]                         ...future.globals.maxSize)) {
[17:59:21.319]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.319]                         on.exit(options(oopts), add = TRUE)
[17:59:21.319]                       }
[17:59:21.319]                       {
[17:59:21.319]                         lapply(seq_along(...future.elements_ii), 
[17:59:21.319]                           FUN = function(jj) {
[17:59:21.319]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.319]                             ...future.FUN(...future.X_jj, ...)
[17:59:21.319]                           })
[17:59:21.319]                       }
[17:59:21.319]                     }, args = future.call.arguments)
[17:59:21.319]                   }
[17:59:21.319]                 }, immediateCondition = function(cond) {
[17:59:21.319]                   sendCondition <- ...future.makeSendCondition()
[17:59:21.319]                   sendCondition(cond)
[17:59:21.319]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.319]                   {
[17:59:21.319]                     inherits <- base::inherits
[17:59:21.319]                     invokeRestart <- base::invokeRestart
[17:59:21.319]                     is.null <- base::is.null
[17:59:21.319]                     muffled <- FALSE
[17:59:21.319]                     if (inherits(cond, "message")) {
[17:59:21.319]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:21.319]                       if (muffled) 
[17:59:21.319]                         invokeRestart("muffleMessage")
[17:59:21.319]                     }
[17:59:21.319]                     else if (inherits(cond, "warning")) {
[17:59:21.319]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:21.319]                       if (muffled) 
[17:59:21.319]                         invokeRestart("muffleWarning")
[17:59:21.319]                     }
[17:59:21.319]                     else if (inherits(cond, "condition")) {
[17:59:21.319]                       if (!is.null(pattern)) {
[17:59:21.319]                         computeRestarts <- base::computeRestarts
[17:59:21.319]                         grepl <- base::grepl
[17:59:21.319]                         restarts <- computeRestarts(cond)
[17:59:21.319]                         for (restart in restarts) {
[17:59:21.319]                           name <- restart$name
[17:59:21.319]                           if (is.null(name)) 
[17:59:21.319]                             next
[17:59:21.319]                           if (!grepl(pattern, name)) 
[17:59:21.319]                             next
[17:59:21.319]                           invokeRestart(restart)
[17:59:21.319]                           muffled <- TRUE
[17:59:21.319]                           break
[17:59:21.319]                         }
[17:59:21.319]                       }
[17:59:21.319]                     }
[17:59:21.319]                     invisible(muffled)
[17:59:21.319]                   }
[17:59:21.319]                   muffleCondition(cond)
[17:59:21.319]                 })
[17:59:21.319]             }))
[17:59:21.319]             future::FutureResult(value = ...future.value$value, 
[17:59:21.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.319]                   ...future.rng), globalenv = if (FALSE) 
[17:59:21.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:21.319]                     ...future.globalenv.names))
[17:59:21.319]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:21.319]         }, condition = base::local({
[17:59:21.319]             c <- base::c
[17:59:21.319]             inherits <- base::inherits
[17:59:21.319]             invokeRestart <- base::invokeRestart
[17:59:21.319]             length <- base::length
[17:59:21.319]             list <- base::list
[17:59:21.319]             seq.int <- base::seq.int
[17:59:21.319]             signalCondition <- base::signalCondition
[17:59:21.319]             sys.calls <- base::sys.calls
[17:59:21.319]             `[[` <- base::`[[`
[17:59:21.319]             `+` <- base::`+`
[17:59:21.319]             `<<-` <- base::`<<-`
[17:59:21.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:21.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:21.319]                   3L)]
[17:59:21.319]             }
[17:59:21.319]             function(cond) {
[17:59:21.319]                 is_error <- inherits(cond, "error")
[17:59:21.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:21.319]                   NULL)
[17:59:21.319]                 if (is_error) {
[17:59:21.319]                   sessionInformation <- function() {
[17:59:21.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:21.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:21.319]                       search = base::search(), system = base::Sys.info())
[17:59:21.319]                   }
[17:59:21.319]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:21.319]                     cond$call), session = sessionInformation(), 
[17:59:21.319]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:21.319]                   signalCondition(cond)
[17:59:21.319]                 }
[17:59:21.319]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:21.319]                 "immediateCondition"))) {
[17:59:21.319]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:21.319]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:21.319]                   if (TRUE && !signal) {
[17:59:21.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.319]                     {
[17:59:21.319]                       inherits <- base::inherits
[17:59:21.319]                       invokeRestart <- base::invokeRestart
[17:59:21.319]                       is.null <- base::is.null
[17:59:21.319]                       muffled <- FALSE
[17:59:21.319]                       if (inherits(cond, "message")) {
[17:59:21.319]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.319]                         if (muffled) 
[17:59:21.319]                           invokeRestart("muffleMessage")
[17:59:21.319]                       }
[17:59:21.319]                       else if (inherits(cond, "warning")) {
[17:59:21.319]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.319]                         if (muffled) 
[17:59:21.319]                           invokeRestart("muffleWarning")
[17:59:21.319]                       }
[17:59:21.319]                       else if (inherits(cond, "condition")) {
[17:59:21.319]                         if (!is.null(pattern)) {
[17:59:21.319]                           computeRestarts <- base::computeRestarts
[17:59:21.319]                           grepl <- base::grepl
[17:59:21.319]                           restarts <- computeRestarts(cond)
[17:59:21.319]                           for (restart in restarts) {
[17:59:21.319]                             name <- restart$name
[17:59:21.319]                             if (is.null(name)) 
[17:59:21.319]                               next
[17:59:21.319]                             if (!grepl(pattern, name)) 
[17:59:21.319]                               next
[17:59:21.319]                             invokeRestart(restart)
[17:59:21.319]                             muffled <- TRUE
[17:59:21.319]                             break
[17:59:21.319]                           }
[17:59:21.319]                         }
[17:59:21.319]                       }
[17:59:21.319]                       invisible(muffled)
[17:59:21.319]                     }
[17:59:21.319]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.319]                   }
[17:59:21.319]                 }
[17:59:21.319]                 else {
[17:59:21.319]                   if (TRUE) {
[17:59:21.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.319]                     {
[17:59:21.319]                       inherits <- base::inherits
[17:59:21.319]                       invokeRestart <- base::invokeRestart
[17:59:21.319]                       is.null <- base::is.null
[17:59:21.319]                       muffled <- FALSE
[17:59:21.319]                       if (inherits(cond, "message")) {
[17:59:21.319]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.319]                         if (muffled) 
[17:59:21.319]                           invokeRestart("muffleMessage")
[17:59:21.319]                       }
[17:59:21.319]                       else if (inherits(cond, "warning")) {
[17:59:21.319]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.319]                         if (muffled) 
[17:59:21.319]                           invokeRestart("muffleWarning")
[17:59:21.319]                       }
[17:59:21.319]                       else if (inherits(cond, "condition")) {
[17:59:21.319]                         if (!is.null(pattern)) {
[17:59:21.319]                           computeRestarts <- base::computeRestarts
[17:59:21.319]                           grepl <- base::grepl
[17:59:21.319]                           restarts <- computeRestarts(cond)
[17:59:21.319]                           for (restart in restarts) {
[17:59:21.319]                             name <- restart$name
[17:59:21.319]                             if (is.null(name)) 
[17:59:21.319]                               next
[17:59:21.319]                             if (!grepl(pattern, name)) 
[17:59:21.319]                               next
[17:59:21.319]                             invokeRestart(restart)
[17:59:21.319]                             muffled <- TRUE
[17:59:21.319]                             break
[17:59:21.319]                           }
[17:59:21.319]                         }
[17:59:21.319]                       }
[17:59:21.319]                       invisible(muffled)
[17:59:21.319]                     }
[17:59:21.319]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.319]                   }
[17:59:21.319]                 }
[17:59:21.319]             }
[17:59:21.319]         }))
[17:59:21.319]     }, error = function(ex) {
[17:59:21.319]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:21.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.319]                 ...future.rng), started = ...future.startTime, 
[17:59:21.319]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:21.319]             version = "1.8"), class = "FutureResult")
[17:59:21.319]     }, finally = {
[17:59:21.319]         if (!identical(...future.workdir, getwd())) 
[17:59:21.319]             setwd(...future.workdir)
[17:59:21.319]         {
[17:59:21.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:21.319]                 ...future.oldOptions$nwarnings <- NULL
[17:59:21.319]             }
[17:59:21.319]             base::options(...future.oldOptions)
[17:59:21.319]             if (.Platform$OS.type == "windows") {
[17:59:21.319]                 old_names <- names(...future.oldEnvVars)
[17:59:21.319]                 envs <- base::Sys.getenv()
[17:59:21.319]                 names <- names(envs)
[17:59:21.319]                 common <- intersect(names, old_names)
[17:59:21.319]                 added <- setdiff(names, old_names)
[17:59:21.319]                 removed <- setdiff(old_names, names)
[17:59:21.319]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:21.319]                   envs[common]]
[17:59:21.319]                 NAMES <- toupper(changed)
[17:59:21.319]                 args <- list()
[17:59:21.319]                 for (kk in seq_along(NAMES)) {
[17:59:21.319]                   name <- changed[[kk]]
[17:59:21.319]                   NAME <- NAMES[[kk]]
[17:59:21.319]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.319]                     next
[17:59:21.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.319]                 }
[17:59:21.319]                 NAMES <- toupper(added)
[17:59:21.319]                 for (kk in seq_along(NAMES)) {
[17:59:21.319]                   name <- added[[kk]]
[17:59:21.319]                   NAME <- NAMES[[kk]]
[17:59:21.319]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.319]                     next
[17:59:21.319]                   args[[name]] <- ""
[17:59:21.319]                 }
[17:59:21.319]                 NAMES <- toupper(removed)
[17:59:21.319]                 for (kk in seq_along(NAMES)) {
[17:59:21.319]                   name <- removed[[kk]]
[17:59:21.319]                   NAME <- NAMES[[kk]]
[17:59:21.319]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.319]                     next
[17:59:21.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.319]                 }
[17:59:21.319]                 if (length(args) > 0) 
[17:59:21.319]                   base::do.call(base::Sys.setenv, args = args)
[17:59:21.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:21.319]             }
[17:59:21.319]             else {
[17:59:21.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:21.319]             }
[17:59:21.319]             {
[17:59:21.319]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:21.319]                   0L) {
[17:59:21.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:21.319]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:21.319]                   base::options(opts)
[17:59:21.319]                 }
[17:59:21.319]                 {
[17:59:21.319]                   {
[17:59:21.319]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:21.319]                     NULL
[17:59:21.319]                   }
[17:59:21.319]                   options(future.plan = NULL)
[17:59:21.319]                   if (is.na(NA_character_)) 
[17:59:21.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:21.319]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:21.319]                     .init = FALSE)
[17:59:21.319]                 }
[17:59:21.319]             }
[17:59:21.319]         }
[17:59:21.319]     })
[17:59:21.319]     if (TRUE) {
[17:59:21.319]         base::sink(type = "output", split = FALSE)
[17:59:21.319]         if (TRUE) {
[17:59:21.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:21.319]         }
[17:59:21.319]         else {
[17:59:21.319]             ...future.result["stdout"] <- base::list(NULL)
[17:59:21.319]         }
[17:59:21.319]         base::close(...future.stdout)
[17:59:21.319]         ...future.stdout <- NULL
[17:59:21.319]     }
[17:59:21.319]     ...future.result$conditions <- ...future.conditions
[17:59:21.319]     ...future.result$finished <- base::Sys.time()
[17:59:21.319]     ...future.result
[17:59:21.319] }
[17:59:21.324] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[17:59:21.325] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:21.326] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:21.326] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:59:21.327] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:59:21.327] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:59:21.328] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:59:21.328] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:21.329] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:21.329] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:59:21.330] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:59:21.330] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[17:59:21.331] MultisessionFuture started
[17:59:21.332] - Launch lazy future ... done
[17:59:21.332] run() for ‘MultisessionFuture’ ... done
[17:59:21.332] Created future:
[17:59:21.332] MultisessionFuture:
[17:59:21.332] Label: ‘future_apply-2’
[17:59:21.332] Expression:
[17:59:21.332] {
[17:59:21.332]     do.call(function(...) {
[17:59:21.332]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.332]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.332]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.332]             on.exit(options(oopts), add = TRUE)
[17:59:21.332]         }
[17:59:21.332]         {
[17:59:21.332]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.332]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.332]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.332]             })
[17:59:21.332]         }
[17:59:21.332]     }, args = future.call.arguments)
[17:59:21.332] }
[17:59:21.332] Lazy evaluation: FALSE
[17:59:21.332] Asynchronous evaluation: TRUE
[17:59:21.332] Local evaluation: TRUE
[17:59:21.332] Environment: R_GlobalEnv
[17:59:21.332] Capture standard output: TRUE
[17:59:21.332] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:21.332] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:21.332] Packages: 1 packages (‘stats’)
[17:59:21.332] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:21.332] Resolved: FALSE
[17:59:21.332] Value: <not collected>
[17:59:21.332] Conditions captured: <none>
[17:59:21.332] Early signaling: FALSE
[17:59:21.332] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:21.332] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.345] Chunk #2 of 2 ... DONE
[17:59:21.345] Launching 2 futures (chunks) ... DONE
[17:59:21.346] Resolving 2 futures (chunks) ...
[17:59:21.346] resolve() on list ...
[17:59:21.346]  recursive: 0
[17:59:21.346]  length: 2
[17:59:21.346] 
[17:59:21.347] receiveMessageFromWorker() for ClusterFuture ...
[17:59:21.348] - Validating connection of MultisessionFuture
[17:59:21.348] - received message: FutureResult
[17:59:21.348] - Received FutureResult
[17:59:21.348] - Erased future from FutureRegistry
[17:59:21.349] result() for ClusterFuture ...
[17:59:21.349] - result already collected: FutureResult
[17:59:21.349] result() for ClusterFuture ... done
[17:59:21.349] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:21.349] Future #1
[17:59:21.350] result() for ClusterFuture ...
[17:59:21.350] - result already collected: FutureResult
[17:59:21.350] result() for ClusterFuture ... done
[17:59:21.350] result() for ClusterFuture ...
[17:59:21.350] - result already collected: FutureResult
[17:59:21.350] result() for ClusterFuture ... done
[17:59:21.351] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:21.351] - nx: 2
[17:59:21.351] - relay: TRUE
[17:59:21.351] - stdout: TRUE
[17:59:21.351] - signal: TRUE
[17:59:21.352] - resignal: FALSE
[17:59:21.352] - force: TRUE
[17:59:21.352] - relayed: [n=2] FALSE, FALSE
[17:59:21.352] - queued futures: [n=2] FALSE, FALSE
[17:59:21.352]  - until=1
[17:59:21.352]  - relaying element #1
[17:59:21.353] result() for ClusterFuture ...
[17:59:21.353] - result already collected: FutureResult
[17:59:21.353] result() for ClusterFuture ... done
[17:59:21.353] result() for ClusterFuture ...
[17:59:21.353] - result already collected: FutureResult
[17:59:21.354] result() for ClusterFuture ... done
[17:59:21.354] result() for ClusterFuture ...
[17:59:21.354] - result already collected: FutureResult
[17:59:21.354] result() for ClusterFuture ... done
[17:59:21.354] result() for ClusterFuture ...
[17:59:21.355] - result already collected: FutureResult
[17:59:21.355] result() for ClusterFuture ... done
[17:59:21.355] - relayed: [n=2] TRUE, FALSE
[17:59:21.355] - queued futures: [n=2] TRUE, FALSE
[17:59:21.355] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:21.356]  length: 1 (resolved future 1)
[17:59:21.378] receiveMessageFromWorker() for ClusterFuture ...
[17:59:21.378] - Validating connection of MultisessionFuture
[17:59:21.378] - received message: FutureResult
[17:59:21.379] - Received FutureResult
[17:59:21.379] - Erased future from FutureRegistry
[17:59:21.379] result() for ClusterFuture ...
[17:59:21.379] - result already collected: FutureResult
[17:59:21.379] result() for ClusterFuture ... done
[17:59:21.380] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:21.380] Future #2
[17:59:21.380] result() for ClusterFuture ...
[17:59:21.380] - result already collected: FutureResult
[17:59:21.380] result() for ClusterFuture ... done
[17:59:21.381] result() for ClusterFuture ...
[17:59:21.381] - result already collected: FutureResult
[17:59:21.381] result() for ClusterFuture ... done
[17:59:21.381] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:21.381] - nx: 2
[17:59:21.381] - relay: TRUE
[17:59:21.382] - stdout: TRUE
[17:59:21.382] - signal: TRUE
[17:59:21.382] - resignal: FALSE
[17:59:21.382] - force: TRUE
[17:59:21.382] - relayed: [n=2] TRUE, FALSE
[17:59:21.383] - queued futures: [n=2] TRUE, FALSE
[17:59:21.383]  - until=2
[17:59:21.383]  - relaying element #2
[17:59:21.383] result() for ClusterFuture ...
[17:59:21.383] - result already collected: FutureResult
[17:59:21.383] result() for ClusterFuture ... done
[17:59:21.384] result() for ClusterFuture ...
[17:59:21.384] - result already collected: FutureResult
[17:59:21.384] result() for ClusterFuture ... done
[17:59:21.384] result() for ClusterFuture ...
[17:59:21.384] - result already collected: FutureResult
[17:59:21.385] result() for ClusterFuture ... done
[17:59:21.385] result() for ClusterFuture ...
[17:59:21.385] - result already collected: FutureResult
[17:59:21.385] result() for ClusterFuture ... done
[17:59:21.385] - relayed: [n=2] TRUE, TRUE
[17:59:21.386] - queued futures: [n=2] TRUE, TRUE
[17:59:21.386] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:21.386]  length: 0 (resolved future 2)
[17:59:21.386] Relaying remaining futures
[17:59:21.386] signalConditionsASAP(NULL, pos=0) ...
[17:59:21.387] - nx: 2
[17:59:21.387] - relay: TRUE
[17:59:21.387] - stdout: TRUE
[17:59:21.387] - signal: TRUE
[17:59:21.387] - resignal: FALSE
[17:59:21.387] - force: TRUE
[17:59:21.388] - relayed: [n=2] TRUE, TRUE
[17:59:21.388] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:21.388] - relayed: [n=2] TRUE, TRUE
[17:59:21.388] - queued futures: [n=2] TRUE, TRUE
[17:59:21.388] signalConditionsASAP(NULL, pos=0) ... done
[17:59:21.389] resolve() on list ... DONE
[17:59:21.389] result() for ClusterFuture ...
[17:59:21.389] - result already collected: FutureResult
[17:59:21.389] result() for ClusterFuture ... done
[17:59:21.389] result() for ClusterFuture ...
[17:59:21.389] - result already collected: FutureResult
[17:59:21.390] result() for ClusterFuture ... done
[17:59:21.390] result() for ClusterFuture ...
[17:59:21.390] - result already collected: FutureResult
[17:59:21.390] result() for ClusterFuture ... done
[17:59:21.390] result() for ClusterFuture ...
[17:59:21.391] - result already collected: FutureResult
[17:59:21.391] result() for ClusterFuture ... done
[17:59:21.391]  - Number of value chunks collected: 2
[17:59:21.391] Resolving 2 futures (chunks) ... DONE
[17:59:21.391] Reducing values from 2 chunks ...
[17:59:21.392]  - Number of values collected after concatenation: 2
[17:59:21.392]  - Number of values expected: 2
[17:59:21.392] Reducing values from 2 chunks ... DONE
[17:59:21.392] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:59:21.393] getGlobalsAndPackagesXApply() ...
[17:59:21.393]  - future.globals: TRUE
[17:59:21.393] getGlobalsAndPackages() ...
[17:59:21.394] Searching for globals...
[17:59:21.396] - globals found: [1] ‘FUN’
[17:59:21.396] Searching for globals ... DONE
[17:59:21.396] Resolving globals: FALSE
[17:59:21.397] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:21.397] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:21.398] - globals: [1] ‘FUN’
[17:59:21.398] 
[17:59:21.398] getGlobalsAndPackages() ... DONE
[17:59:21.398]  - globals found/used: [n=1] ‘FUN’
[17:59:21.398]  - needed namespaces: [n=0] 
[17:59:21.399] Finding globals ... DONE
[17:59:21.399]  - use_args: TRUE
[17:59:21.399]  - Getting '...' globals ...
[17:59:21.400] resolve() on list ...
[17:59:21.400]  recursive: 0
[17:59:21.400]  length: 1
[17:59:21.401]  elements: ‘...’
[17:59:21.401]  length: 0 (resolved future 1)
[17:59:21.401] resolve() on list ... DONE
[17:59:21.401]    - '...' content: [n=0] 
[17:59:21.401] List of 1
[17:59:21.401]  $ ...: list()
[17:59:21.401]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.401]  - attr(*, "where")=List of 1
[17:59:21.401]   ..$ ...:<environment: 0x56085d0993b0> 
[17:59:21.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.401]  - attr(*, "resolved")= logi TRUE
[17:59:21.401]  - attr(*, "total_size")= num NA
[17:59:21.406]  - Getting '...' globals ... DONE
[17:59:21.407] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:21.407] List of 2
[17:59:21.407]  $ ...future.FUN:function (x)  
[17:59:21.407]  $ ...          : list()
[17:59:21.407]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.407]  - attr(*, "where")=List of 2
[17:59:21.407]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:21.407]   ..$ ...          :<environment: 0x56085d0993b0> 
[17:59:21.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.407]  - attr(*, "resolved")= logi FALSE
[17:59:21.407]  - attr(*, "total_size")= num 848
[17:59:21.412] Packages to be attached in all futures: [n=0] 
[17:59:21.412] getGlobalsAndPackagesXApply() ... DONE
[17:59:21.419] future_lapply() ...
[17:59:21.425] Number of chunks: 2
[17:59:21.425] getGlobalsAndPackagesXApply() ...
[17:59:21.425]  - future.globals: <name-value list> with names ‘list()’
[17:59:21.426]  - use_args: TRUE
[17:59:21.426] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:21.426] List of 2
[17:59:21.426]  $ ...          : list()
[17:59:21.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.426]  $ ...future.FUN:function (x)  
[17:59:21.426]  - attr(*, "where")=List of 2
[17:59:21.426]   ..$ ...          :<environment: 0x56085d0993b0> 
[17:59:21.426]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:21.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.426]  - attr(*, "resolved")= logi FALSE
[17:59:21.426]  - attr(*, "total_size")= num NA
[17:59:21.435] Packages to be attached in all futures: [n=0] 
[17:59:21.436] getGlobalsAndPackagesXApply() ... DONE
[17:59:21.436] Number of futures (= number of chunks): 2
[17:59:21.436] Launching 2 futures (chunks) ...
[17:59:21.436] Chunk #1 of 2 ...
[17:59:21.437]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:21.437]  - seeds: <none>
[17:59:21.437]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.437] getGlobalsAndPackages() ...
[17:59:21.438] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.438] Resolving globals: FALSE
[17:59:21.438] Tweak future expression to call with '...' arguments ...
[17:59:21.438] {
[17:59:21.438]     do.call(function(...) {
[17:59:21.438]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.438]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.438]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.438]             on.exit(options(oopts), add = TRUE)
[17:59:21.438]         }
[17:59:21.438]         {
[17:59:21.438]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.438]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.438]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.438]             })
[17:59:21.438]         }
[17:59:21.438]     }, args = future.call.arguments)
[17:59:21.438] }
[17:59:21.439] Tweak future expression to call with '...' arguments ... DONE
[17:59:21.440] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.440] 
[17:59:21.440] getGlobalsAndPackages() ... DONE
[17:59:21.440] run() for ‘Future’ ...
[17:59:21.441] - state: ‘created’
[17:59:21.441] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:21.463] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:21.464]   - Field: ‘node’
[17:59:21.464]   - Field: ‘label’
[17:59:21.464]   - Field: ‘local’
[17:59:21.465]   - Field: ‘owner’
[17:59:21.465]   - Field: ‘envir’
[17:59:21.465]   - Field: ‘workers’
[17:59:21.465]   - Field: ‘packages’
[17:59:21.465]   - Field: ‘gc’
[17:59:21.466]   - Field: ‘conditions’
[17:59:21.466]   - Field: ‘persistent’
[17:59:21.466]   - Field: ‘expr’
[17:59:21.466]   - Field: ‘uuid’
[17:59:21.466]   - Field: ‘seed’
[17:59:21.467]   - Field: ‘version’
[17:59:21.467]   - Field: ‘result’
[17:59:21.467]   - Field: ‘asynchronous’
[17:59:21.467]   - Field: ‘calls’
[17:59:21.467]   - Field: ‘globals’
[17:59:21.468]   - Field: ‘stdout’
[17:59:21.468]   - Field: ‘earlySignal’
[17:59:21.468]   - Field: ‘lazy’
[17:59:21.468]   - Field: ‘state’
[17:59:21.468] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:21.469] - Launch lazy future ...
[17:59:21.469] Packages needed by the future expression (n = 0): <none>
[17:59:21.469] Packages needed by future strategies (n = 0): <none>
[17:59:21.470] {
[17:59:21.470]     {
[17:59:21.470]         {
[17:59:21.470]             ...future.startTime <- base::Sys.time()
[17:59:21.470]             {
[17:59:21.470]                 {
[17:59:21.470]                   {
[17:59:21.470]                     {
[17:59:21.470]                       base::local({
[17:59:21.470]                         has_future <- base::requireNamespace("future", 
[17:59:21.470]                           quietly = TRUE)
[17:59:21.470]                         if (has_future) {
[17:59:21.470]                           ns <- base::getNamespace("future")
[17:59:21.470]                           version <- ns[[".package"]][["version"]]
[17:59:21.470]                           if (is.null(version)) 
[17:59:21.470]                             version <- utils::packageVersion("future")
[17:59:21.470]                         }
[17:59:21.470]                         else {
[17:59:21.470]                           version <- NULL
[17:59:21.470]                         }
[17:59:21.470]                         if (!has_future || version < "1.8.0") {
[17:59:21.470]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:21.470]                             "", base::R.version$version.string), 
[17:59:21.470]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:21.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:21.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:21.470]                               "release", "version")], collapse = " "), 
[17:59:21.470]                             hostname = base::Sys.info()[["nodename"]])
[17:59:21.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:21.470]                             info)
[17:59:21.470]                           info <- base::paste(info, collapse = "; ")
[17:59:21.470]                           if (!has_future) {
[17:59:21.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:21.470]                               info)
[17:59:21.470]                           }
[17:59:21.470]                           else {
[17:59:21.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:21.470]                               info, version)
[17:59:21.470]                           }
[17:59:21.470]                           base::stop(msg)
[17:59:21.470]                         }
[17:59:21.470]                       })
[17:59:21.470]                     }
[17:59:21.470]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:21.470]                     base::options(mc.cores = 1L)
[17:59:21.470]                   }
[17:59:21.470]                   ...future.strategy.old <- future::plan("list")
[17:59:21.470]                   options(future.plan = NULL)
[17:59:21.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:21.470]                 }
[17:59:21.470]                 ...future.workdir <- getwd()
[17:59:21.470]             }
[17:59:21.470]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:21.470]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:21.470]         }
[17:59:21.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:21.470]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:21.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:21.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:21.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:21.470]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:21.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:21.470]             base::names(...future.oldOptions))
[17:59:21.470]     }
[17:59:21.470]     if (FALSE) {
[17:59:21.470]     }
[17:59:21.470]     else {
[17:59:21.470]         if (TRUE) {
[17:59:21.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:21.470]                 open = "w")
[17:59:21.470]         }
[17:59:21.470]         else {
[17:59:21.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:21.470]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:21.470]         }
[17:59:21.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:21.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:21.470]             base::sink(type = "output", split = FALSE)
[17:59:21.470]             base::close(...future.stdout)
[17:59:21.470]         }, add = TRUE)
[17:59:21.470]     }
[17:59:21.470]     ...future.frame <- base::sys.nframe()
[17:59:21.470]     ...future.conditions <- base::list()
[17:59:21.470]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:21.470]     if (FALSE) {
[17:59:21.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:21.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:21.470]     }
[17:59:21.470]     ...future.result <- base::tryCatch({
[17:59:21.470]         base::withCallingHandlers({
[17:59:21.470]             ...future.value <- base::withVisible(base::local({
[17:59:21.470]                 ...future.makeSendCondition <- base::local({
[17:59:21.470]                   sendCondition <- NULL
[17:59:21.470]                   function(frame = 1L) {
[17:59:21.470]                     if (is.function(sendCondition)) 
[17:59:21.470]                       return(sendCondition)
[17:59:21.470]                     ns <- getNamespace("parallel")
[17:59:21.470]                     if (exists("sendData", mode = "function", 
[17:59:21.470]                       envir = ns)) {
[17:59:21.470]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:21.470]                         envir = ns)
[17:59:21.470]                       envir <- sys.frame(frame)
[17:59:21.470]                       master <- NULL
[17:59:21.470]                       while (!identical(envir, .GlobalEnv) && 
[17:59:21.470]                         !identical(envir, emptyenv())) {
[17:59:21.470]                         if (exists("master", mode = "list", envir = envir, 
[17:59:21.470]                           inherits = FALSE)) {
[17:59:21.470]                           master <- get("master", mode = "list", 
[17:59:21.470]                             envir = envir, inherits = FALSE)
[17:59:21.470]                           if (inherits(master, c("SOCKnode", 
[17:59:21.470]                             "SOCK0node"))) {
[17:59:21.470]                             sendCondition <<- function(cond) {
[17:59:21.470]                               data <- list(type = "VALUE", value = cond, 
[17:59:21.470]                                 success = TRUE)
[17:59:21.470]                               parallel_sendData(master, data)
[17:59:21.470]                             }
[17:59:21.470]                             return(sendCondition)
[17:59:21.470]                           }
[17:59:21.470]                         }
[17:59:21.470]                         frame <- frame + 1L
[17:59:21.470]                         envir <- sys.frame(frame)
[17:59:21.470]                       }
[17:59:21.470]                     }
[17:59:21.470]                     sendCondition <<- function(cond) NULL
[17:59:21.470]                   }
[17:59:21.470]                 })
[17:59:21.470]                 withCallingHandlers({
[17:59:21.470]                   {
[17:59:21.470]                     do.call(function(...) {
[17:59:21.470]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.470]                       if (!identical(...future.globals.maxSize.org, 
[17:59:21.470]                         ...future.globals.maxSize)) {
[17:59:21.470]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.470]                         on.exit(options(oopts), add = TRUE)
[17:59:21.470]                       }
[17:59:21.470]                       {
[17:59:21.470]                         lapply(seq_along(...future.elements_ii), 
[17:59:21.470]                           FUN = function(jj) {
[17:59:21.470]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.470]                             ...future.FUN(...future.X_jj, ...)
[17:59:21.470]                           })
[17:59:21.470]                       }
[17:59:21.470]                     }, args = future.call.arguments)
[17:59:21.470]                   }
[17:59:21.470]                 }, immediateCondition = function(cond) {
[17:59:21.470]                   sendCondition <- ...future.makeSendCondition()
[17:59:21.470]                   sendCondition(cond)
[17:59:21.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.470]                   {
[17:59:21.470]                     inherits <- base::inherits
[17:59:21.470]                     invokeRestart <- base::invokeRestart
[17:59:21.470]                     is.null <- base::is.null
[17:59:21.470]                     muffled <- FALSE
[17:59:21.470]                     if (inherits(cond, "message")) {
[17:59:21.470]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:21.470]                       if (muffled) 
[17:59:21.470]                         invokeRestart("muffleMessage")
[17:59:21.470]                     }
[17:59:21.470]                     else if (inherits(cond, "warning")) {
[17:59:21.470]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:21.470]                       if (muffled) 
[17:59:21.470]                         invokeRestart("muffleWarning")
[17:59:21.470]                     }
[17:59:21.470]                     else if (inherits(cond, "condition")) {
[17:59:21.470]                       if (!is.null(pattern)) {
[17:59:21.470]                         computeRestarts <- base::computeRestarts
[17:59:21.470]                         grepl <- base::grepl
[17:59:21.470]                         restarts <- computeRestarts(cond)
[17:59:21.470]                         for (restart in restarts) {
[17:59:21.470]                           name <- restart$name
[17:59:21.470]                           if (is.null(name)) 
[17:59:21.470]                             next
[17:59:21.470]                           if (!grepl(pattern, name)) 
[17:59:21.470]                             next
[17:59:21.470]                           invokeRestart(restart)
[17:59:21.470]                           muffled <- TRUE
[17:59:21.470]                           break
[17:59:21.470]                         }
[17:59:21.470]                       }
[17:59:21.470]                     }
[17:59:21.470]                     invisible(muffled)
[17:59:21.470]                   }
[17:59:21.470]                   muffleCondition(cond)
[17:59:21.470]                 })
[17:59:21.470]             }))
[17:59:21.470]             future::FutureResult(value = ...future.value$value, 
[17:59:21.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.470]                   ...future.rng), globalenv = if (FALSE) 
[17:59:21.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:21.470]                     ...future.globalenv.names))
[17:59:21.470]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:21.470]         }, condition = base::local({
[17:59:21.470]             c <- base::c
[17:59:21.470]             inherits <- base::inherits
[17:59:21.470]             invokeRestart <- base::invokeRestart
[17:59:21.470]             length <- base::length
[17:59:21.470]             list <- base::list
[17:59:21.470]             seq.int <- base::seq.int
[17:59:21.470]             signalCondition <- base::signalCondition
[17:59:21.470]             sys.calls <- base::sys.calls
[17:59:21.470]             `[[` <- base::`[[`
[17:59:21.470]             `+` <- base::`+`
[17:59:21.470]             `<<-` <- base::`<<-`
[17:59:21.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:21.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:21.470]                   3L)]
[17:59:21.470]             }
[17:59:21.470]             function(cond) {
[17:59:21.470]                 is_error <- inherits(cond, "error")
[17:59:21.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:21.470]                   NULL)
[17:59:21.470]                 if (is_error) {
[17:59:21.470]                   sessionInformation <- function() {
[17:59:21.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:21.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:21.470]                       search = base::search(), system = base::Sys.info())
[17:59:21.470]                   }
[17:59:21.470]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:21.470]                     cond$call), session = sessionInformation(), 
[17:59:21.470]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:21.470]                   signalCondition(cond)
[17:59:21.470]                 }
[17:59:21.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:21.470]                 "immediateCondition"))) {
[17:59:21.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:21.470]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:21.470]                   if (TRUE && !signal) {
[17:59:21.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.470]                     {
[17:59:21.470]                       inherits <- base::inherits
[17:59:21.470]                       invokeRestart <- base::invokeRestart
[17:59:21.470]                       is.null <- base::is.null
[17:59:21.470]                       muffled <- FALSE
[17:59:21.470]                       if (inherits(cond, "message")) {
[17:59:21.470]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.470]                         if (muffled) 
[17:59:21.470]                           invokeRestart("muffleMessage")
[17:59:21.470]                       }
[17:59:21.470]                       else if (inherits(cond, "warning")) {
[17:59:21.470]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.470]                         if (muffled) 
[17:59:21.470]                           invokeRestart("muffleWarning")
[17:59:21.470]                       }
[17:59:21.470]                       else if (inherits(cond, "condition")) {
[17:59:21.470]                         if (!is.null(pattern)) {
[17:59:21.470]                           computeRestarts <- base::computeRestarts
[17:59:21.470]                           grepl <- base::grepl
[17:59:21.470]                           restarts <- computeRestarts(cond)
[17:59:21.470]                           for (restart in restarts) {
[17:59:21.470]                             name <- restart$name
[17:59:21.470]                             if (is.null(name)) 
[17:59:21.470]                               next
[17:59:21.470]                             if (!grepl(pattern, name)) 
[17:59:21.470]                               next
[17:59:21.470]                             invokeRestart(restart)
[17:59:21.470]                             muffled <- TRUE
[17:59:21.470]                             break
[17:59:21.470]                           }
[17:59:21.470]                         }
[17:59:21.470]                       }
[17:59:21.470]                       invisible(muffled)
[17:59:21.470]                     }
[17:59:21.470]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.470]                   }
[17:59:21.470]                 }
[17:59:21.470]                 else {
[17:59:21.470]                   if (TRUE) {
[17:59:21.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.470]                     {
[17:59:21.470]                       inherits <- base::inherits
[17:59:21.470]                       invokeRestart <- base::invokeRestart
[17:59:21.470]                       is.null <- base::is.null
[17:59:21.470]                       muffled <- FALSE
[17:59:21.470]                       if (inherits(cond, "message")) {
[17:59:21.470]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.470]                         if (muffled) 
[17:59:21.470]                           invokeRestart("muffleMessage")
[17:59:21.470]                       }
[17:59:21.470]                       else if (inherits(cond, "warning")) {
[17:59:21.470]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.470]                         if (muffled) 
[17:59:21.470]                           invokeRestart("muffleWarning")
[17:59:21.470]                       }
[17:59:21.470]                       else if (inherits(cond, "condition")) {
[17:59:21.470]                         if (!is.null(pattern)) {
[17:59:21.470]                           computeRestarts <- base::computeRestarts
[17:59:21.470]                           grepl <- base::grepl
[17:59:21.470]                           restarts <- computeRestarts(cond)
[17:59:21.470]                           for (restart in restarts) {
[17:59:21.470]                             name <- restart$name
[17:59:21.470]                             if (is.null(name)) 
[17:59:21.470]                               next
[17:59:21.470]                             if (!grepl(pattern, name)) 
[17:59:21.470]                               next
[17:59:21.470]                             invokeRestart(restart)
[17:59:21.470]                             muffled <- TRUE
[17:59:21.470]                             break
[17:59:21.470]                           }
[17:59:21.470]                         }
[17:59:21.470]                       }
[17:59:21.470]                       invisible(muffled)
[17:59:21.470]                     }
[17:59:21.470]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.470]                   }
[17:59:21.470]                 }
[17:59:21.470]             }
[17:59:21.470]         }))
[17:59:21.470]     }, error = function(ex) {
[17:59:21.470]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:21.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.470]                 ...future.rng), started = ...future.startTime, 
[17:59:21.470]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:21.470]             version = "1.8"), class = "FutureResult")
[17:59:21.470]     }, finally = {
[17:59:21.470]         if (!identical(...future.workdir, getwd())) 
[17:59:21.470]             setwd(...future.workdir)
[17:59:21.470]         {
[17:59:21.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:21.470]                 ...future.oldOptions$nwarnings <- NULL
[17:59:21.470]             }
[17:59:21.470]             base::options(...future.oldOptions)
[17:59:21.470]             if (.Platform$OS.type == "windows") {
[17:59:21.470]                 old_names <- names(...future.oldEnvVars)
[17:59:21.470]                 envs <- base::Sys.getenv()
[17:59:21.470]                 names <- names(envs)
[17:59:21.470]                 common <- intersect(names, old_names)
[17:59:21.470]                 added <- setdiff(names, old_names)
[17:59:21.470]                 removed <- setdiff(old_names, names)
[17:59:21.470]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:21.470]                   envs[common]]
[17:59:21.470]                 NAMES <- toupper(changed)
[17:59:21.470]                 args <- list()
[17:59:21.470]                 for (kk in seq_along(NAMES)) {
[17:59:21.470]                   name <- changed[[kk]]
[17:59:21.470]                   NAME <- NAMES[[kk]]
[17:59:21.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.470]                     next
[17:59:21.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.470]                 }
[17:59:21.470]                 NAMES <- toupper(added)
[17:59:21.470]                 for (kk in seq_along(NAMES)) {
[17:59:21.470]                   name <- added[[kk]]
[17:59:21.470]                   NAME <- NAMES[[kk]]
[17:59:21.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.470]                     next
[17:59:21.470]                   args[[name]] <- ""
[17:59:21.470]                 }
[17:59:21.470]                 NAMES <- toupper(removed)
[17:59:21.470]                 for (kk in seq_along(NAMES)) {
[17:59:21.470]                   name <- removed[[kk]]
[17:59:21.470]                   NAME <- NAMES[[kk]]
[17:59:21.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.470]                     next
[17:59:21.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.470]                 }
[17:59:21.470]                 if (length(args) > 0) 
[17:59:21.470]                   base::do.call(base::Sys.setenv, args = args)
[17:59:21.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:21.470]             }
[17:59:21.470]             else {
[17:59:21.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:21.470]             }
[17:59:21.470]             {
[17:59:21.470]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:21.470]                   0L) {
[17:59:21.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:21.470]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:21.470]                   base::options(opts)
[17:59:21.470]                 }
[17:59:21.470]                 {
[17:59:21.470]                   {
[17:59:21.470]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:21.470]                     NULL
[17:59:21.470]                   }
[17:59:21.470]                   options(future.plan = NULL)
[17:59:21.470]                   if (is.na(NA_character_)) 
[17:59:21.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:21.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:21.470]                     .init = FALSE)
[17:59:21.470]                 }
[17:59:21.470]             }
[17:59:21.470]         }
[17:59:21.470]     })
[17:59:21.470]     if (TRUE) {
[17:59:21.470]         base::sink(type = "output", split = FALSE)
[17:59:21.470]         if (TRUE) {
[17:59:21.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:21.470]         }
[17:59:21.470]         else {
[17:59:21.470]             ...future.result["stdout"] <- base::list(NULL)
[17:59:21.470]         }
[17:59:21.470]         base::close(...future.stdout)
[17:59:21.470]         ...future.stdout <- NULL
[17:59:21.470]     }
[17:59:21.470]     ...future.result$conditions <- ...future.conditions
[17:59:21.470]     ...future.result$finished <- base::Sys.time()
[17:59:21.470]     ...future.result
[17:59:21.470] }
[17:59:21.476] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[17:59:21.476] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:21.477] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:21.477] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:59:21.478] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:59:21.479] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:59:21.479] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:59:21.480] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:21.480] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:21.481] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:59:21.482] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:59:21.482] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[17:59:21.483] MultisessionFuture started
[17:59:21.483] - Launch lazy future ... done
[17:59:21.483] run() for ‘MultisessionFuture’ ... done
[17:59:21.483] Created future:
[17:59:21.484] MultisessionFuture:
[17:59:21.484] Label: ‘future_apply-1’
[17:59:21.484] Expression:
[17:59:21.484] {
[17:59:21.484]     do.call(function(...) {
[17:59:21.484]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.484]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.484]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.484]             on.exit(options(oopts), add = TRUE)
[17:59:21.484]         }
[17:59:21.484]         {
[17:59:21.484]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.484]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.484]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.484]             })
[17:59:21.484]         }
[17:59:21.484]     }, args = future.call.arguments)
[17:59:21.484] }
[17:59:21.484] Lazy evaluation: FALSE
[17:59:21.484] Asynchronous evaluation: TRUE
[17:59:21.484] Local evaluation: TRUE
[17:59:21.484] Environment: R_GlobalEnv
[17:59:21.484] Capture standard output: TRUE
[17:59:21.484] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:21.484] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:21.484] Packages: <none>
[17:59:21.484] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:21.484] Resolved: FALSE
[17:59:21.484] Value: <not collected>
[17:59:21.484] Conditions captured: <none>
[17:59:21.484] Early signaling: FALSE
[17:59:21.484] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:21.484] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.497] Chunk #1 of 2 ... DONE
[17:59:21.497] Chunk #2 of 2 ...
[17:59:21.497]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:21.497]  - seeds: <none>
[17:59:21.498]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.498] getGlobalsAndPackages() ...
[17:59:21.498] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.498] Resolving globals: FALSE
[17:59:21.499] Tweak future expression to call with '...' arguments ...
[17:59:21.499] {
[17:59:21.499]     do.call(function(...) {
[17:59:21.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.499]             on.exit(options(oopts), add = TRUE)
[17:59:21.499]         }
[17:59:21.499]         {
[17:59:21.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.499]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.499]             })
[17:59:21.499]         }
[17:59:21.499]     }, args = future.call.arguments)
[17:59:21.499] }
[17:59:21.499] Tweak future expression to call with '...' arguments ... DONE
[17:59:21.500] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.501] 
[17:59:21.501] getGlobalsAndPackages() ... DONE
[17:59:21.501] run() for ‘Future’ ...
[17:59:21.502] - state: ‘created’
[17:59:21.502] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:21.527] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.527] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:21.528]   - Field: ‘node’
[17:59:21.528]   - Field: ‘label’
[17:59:21.528]   - Field: ‘local’
[17:59:21.528]   - Field: ‘owner’
[17:59:21.528]   - Field: ‘envir’
[17:59:21.529]   - Field: ‘workers’
[17:59:21.529]   - Field: ‘packages’
[17:59:21.529]   - Field: ‘gc’
[17:59:21.529]   - Field: ‘conditions’
[17:59:21.529]   - Field: ‘persistent’
[17:59:21.530]   - Field: ‘expr’
[17:59:21.530]   - Field: ‘uuid’
[17:59:21.530]   - Field: ‘seed’
[17:59:21.530]   - Field: ‘version’
[17:59:21.530]   - Field: ‘result’
[17:59:21.531]   - Field: ‘asynchronous’
[17:59:21.531]   - Field: ‘calls’
[17:59:21.531]   - Field: ‘globals’
[17:59:21.531]   - Field: ‘stdout’
[17:59:21.531]   - Field: ‘earlySignal’
[17:59:21.532]   - Field: ‘lazy’
[17:59:21.532]   - Field: ‘state’
[17:59:21.532] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:21.532] - Launch lazy future ...
[17:59:21.533] Packages needed by the future expression (n = 0): <none>
[17:59:21.533] Packages needed by future strategies (n = 0): <none>
[17:59:21.534] {
[17:59:21.534]     {
[17:59:21.534]         {
[17:59:21.534]             ...future.startTime <- base::Sys.time()
[17:59:21.534]             {
[17:59:21.534]                 {
[17:59:21.534]                   {
[17:59:21.534]                     {
[17:59:21.534]                       base::local({
[17:59:21.534]                         has_future <- base::requireNamespace("future", 
[17:59:21.534]                           quietly = TRUE)
[17:59:21.534]                         if (has_future) {
[17:59:21.534]                           ns <- base::getNamespace("future")
[17:59:21.534]                           version <- ns[[".package"]][["version"]]
[17:59:21.534]                           if (is.null(version)) 
[17:59:21.534]                             version <- utils::packageVersion("future")
[17:59:21.534]                         }
[17:59:21.534]                         else {
[17:59:21.534]                           version <- NULL
[17:59:21.534]                         }
[17:59:21.534]                         if (!has_future || version < "1.8.0") {
[17:59:21.534]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:21.534]                             "", base::R.version$version.string), 
[17:59:21.534]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:21.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:21.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:21.534]                               "release", "version")], collapse = " "), 
[17:59:21.534]                             hostname = base::Sys.info()[["nodename"]])
[17:59:21.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:21.534]                             info)
[17:59:21.534]                           info <- base::paste(info, collapse = "; ")
[17:59:21.534]                           if (!has_future) {
[17:59:21.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:21.534]                               info)
[17:59:21.534]                           }
[17:59:21.534]                           else {
[17:59:21.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:21.534]                               info, version)
[17:59:21.534]                           }
[17:59:21.534]                           base::stop(msg)
[17:59:21.534]                         }
[17:59:21.534]                       })
[17:59:21.534]                     }
[17:59:21.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:21.534]                     base::options(mc.cores = 1L)
[17:59:21.534]                   }
[17:59:21.534]                   ...future.strategy.old <- future::plan("list")
[17:59:21.534]                   options(future.plan = NULL)
[17:59:21.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:21.534]                 }
[17:59:21.534]                 ...future.workdir <- getwd()
[17:59:21.534]             }
[17:59:21.534]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:21.534]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:21.534]         }
[17:59:21.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:21.534]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:21.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:21.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:21.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:21.534]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:21.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:21.534]             base::names(...future.oldOptions))
[17:59:21.534]     }
[17:59:21.534]     if (FALSE) {
[17:59:21.534]     }
[17:59:21.534]     else {
[17:59:21.534]         if (TRUE) {
[17:59:21.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:21.534]                 open = "w")
[17:59:21.534]         }
[17:59:21.534]         else {
[17:59:21.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:21.534]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:21.534]         }
[17:59:21.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:21.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:21.534]             base::sink(type = "output", split = FALSE)
[17:59:21.534]             base::close(...future.stdout)
[17:59:21.534]         }, add = TRUE)
[17:59:21.534]     }
[17:59:21.534]     ...future.frame <- base::sys.nframe()
[17:59:21.534]     ...future.conditions <- base::list()
[17:59:21.534]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:21.534]     if (FALSE) {
[17:59:21.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:21.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:21.534]     }
[17:59:21.534]     ...future.result <- base::tryCatch({
[17:59:21.534]         base::withCallingHandlers({
[17:59:21.534]             ...future.value <- base::withVisible(base::local({
[17:59:21.534]                 ...future.makeSendCondition <- base::local({
[17:59:21.534]                   sendCondition <- NULL
[17:59:21.534]                   function(frame = 1L) {
[17:59:21.534]                     if (is.function(sendCondition)) 
[17:59:21.534]                       return(sendCondition)
[17:59:21.534]                     ns <- getNamespace("parallel")
[17:59:21.534]                     if (exists("sendData", mode = "function", 
[17:59:21.534]                       envir = ns)) {
[17:59:21.534]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:21.534]                         envir = ns)
[17:59:21.534]                       envir <- sys.frame(frame)
[17:59:21.534]                       master <- NULL
[17:59:21.534]                       while (!identical(envir, .GlobalEnv) && 
[17:59:21.534]                         !identical(envir, emptyenv())) {
[17:59:21.534]                         if (exists("master", mode = "list", envir = envir, 
[17:59:21.534]                           inherits = FALSE)) {
[17:59:21.534]                           master <- get("master", mode = "list", 
[17:59:21.534]                             envir = envir, inherits = FALSE)
[17:59:21.534]                           if (inherits(master, c("SOCKnode", 
[17:59:21.534]                             "SOCK0node"))) {
[17:59:21.534]                             sendCondition <<- function(cond) {
[17:59:21.534]                               data <- list(type = "VALUE", value = cond, 
[17:59:21.534]                                 success = TRUE)
[17:59:21.534]                               parallel_sendData(master, data)
[17:59:21.534]                             }
[17:59:21.534]                             return(sendCondition)
[17:59:21.534]                           }
[17:59:21.534]                         }
[17:59:21.534]                         frame <- frame + 1L
[17:59:21.534]                         envir <- sys.frame(frame)
[17:59:21.534]                       }
[17:59:21.534]                     }
[17:59:21.534]                     sendCondition <<- function(cond) NULL
[17:59:21.534]                   }
[17:59:21.534]                 })
[17:59:21.534]                 withCallingHandlers({
[17:59:21.534]                   {
[17:59:21.534]                     do.call(function(...) {
[17:59:21.534]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.534]                       if (!identical(...future.globals.maxSize.org, 
[17:59:21.534]                         ...future.globals.maxSize)) {
[17:59:21.534]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.534]                         on.exit(options(oopts), add = TRUE)
[17:59:21.534]                       }
[17:59:21.534]                       {
[17:59:21.534]                         lapply(seq_along(...future.elements_ii), 
[17:59:21.534]                           FUN = function(jj) {
[17:59:21.534]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.534]                             ...future.FUN(...future.X_jj, ...)
[17:59:21.534]                           })
[17:59:21.534]                       }
[17:59:21.534]                     }, args = future.call.arguments)
[17:59:21.534]                   }
[17:59:21.534]                 }, immediateCondition = function(cond) {
[17:59:21.534]                   sendCondition <- ...future.makeSendCondition()
[17:59:21.534]                   sendCondition(cond)
[17:59:21.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.534]                   {
[17:59:21.534]                     inherits <- base::inherits
[17:59:21.534]                     invokeRestart <- base::invokeRestart
[17:59:21.534]                     is.null <- base::is.null
[17:59:21.534]                     muffled <- FALSE
[17:59:21.534]                     if (inherits(cond, "message")) {
[17:59:21.534]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:21.534]                       if (muffled) 
[17:59:21.534]                         invokeRestart("muffleMessage")
[17:59:21.534]                     }
[17:59:21.534]                     else if (inherits(cond, "warning")) {
[17:59:21.534]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:21.534]                       if (muffled) 
[17:59:21.534]                         invokeRestart("muffleWarning")
[17:59:21.534]                     }
[17:59:21.534]                     else if (inherits(cond, "condition")) {
[17:59:21.534]                       if (!is.null(pattern)) {
[17:59:21.534]                         computeRestarts <- base::computeRestarts
[17:59:21.534]                         grepl <- base::grepl
[17:59:21.534]                         restarts <- computeRestarts(cond)
[17:59:21.534]                         for (restart in restarts) {
[17:59:21.534]                           name <- restart$name
[17:59:21.534]                           if (is.null(name)) 
[17:59:21.534]                             next
[17:59:21.534]                           if (!grepl(pattern, name)) 
[17:59:21.534]                             next
[17:59:21.534]                           invokeRestart(restart)
[17:59:21.534]                           muffled <- TRUE
[17:59:21.534]                           break
[17:59:21.534]                         }
[17:59:21.534]                       }
[17:59:21.534]                     }
[17:59:21.534]                     invisible(muffled)
[17:59:21.534]                   }
[17:59:21.534]                   muffleCondition(cond)
[17:59:21.534]                 })
[17:59:21.534]             }))
[17:59:21.534]             future::FutureResult(value = ...future.value$value, 
[17:59:21.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.534]                   ...future.rng), globalenv = if (FALSE) 
[17:59:21.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:21.534]                     ...future.globalenv.names))
[17:59:21.534]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:21.534]         }, condition = base::local({
[17:59:21.534]             c <- base::c
[17:59:21.534]             inherits <- base::inherits
[17:59:21.534]             invokeRestart <- base::invokeRestart
[17:59:21.534]             length <- base::length
[17:59:21.534]             list <- base::list
[17:59:21.534]             seq.int <- base::seq.int
[17:59:21.534]             signalCondition <- base::signalCondition
[17:59:21.534]             sys.calls <- base::sys.calls
[17:59:21.534]             `[[` <- base::`[[`
[17:59:21.534]             `+` <- base::`+`
[17:59:21.534]             `<<-` <- base::`<<-`
[17:59:21.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:21.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:21.534]                   3L)]
[17:59:21.534]             }
[17:59:21.534]             function(cond) {
[17:59:21.534]                 is_error <- inherits(cond, "error")
[17:59:21.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:21.534]                   NULL)
[17:59:21.534]                 if (is_error) {
[17:59:21.534]                   sessionInformation <- function() {
[17:59:21.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:21.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:21.534]                       search = base::search(), system = base::Sys.info())
[17:59:21.534]                   }
[17:59:21.534]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:21.534]                     cond$call), session = sessionInformation(), 
[17:59:21.534]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:21.534]                   signalCondition(cond)
[17:59:21.534]                 }
[17:59:21.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:21.534]                 "immediateCondition"))) {
[17:59:21.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:21.534]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:21.534]                   if (TRUE && !signal) {
[17:59:21.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.534]                     {
[17:59:21.534]                       inherits <- base::inherits
[17:59:21.534]                       invokeRestart <- base::invokeRestart
[17:59:21.534]                       is.null <- base::is.null
[17:59:21.534]                       muffled <- FALSE
[17:59:21.534]                       if (inherits(cond, "message")) {
[17:59:21.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.534]                         if (muffled) 
[17:59:21.534]                           invokeRestart("muffleMessage")
[17:59:21.534]                       }
[17:59:21.534]                       else if (inherits(cond, "warning")) {
[17:59:21.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.534]                         if (muffled) 
[17:59:21.534]                           invokeRestart("muffleWarning")
[17:59:21.534]                       }
[17:59:21.534]                       else if (inherits(cond, "condition")) {
[17:59:21.534]                         if (!is.null(pattern)) {
[17:59:21.534]                           computeRestarts <- base::computeRestarts
[17:59:21.534]                           grepl <- base::grepl
[17:59:21.534]                           restarts <- computeRestarts(cond)
[17:59:21.534]                           for (restart in restarts) {
[17:59:21.534]                             name <- restart$name
[17:59:21.534]                             if (is.null(name)) 
[17:59:21.534]                               next
[17:59:21.534]                             if (!grepl(pattern, name)) 
[17:59:21.534]                               next
[17:59:21.534]                             invokeRestart(restart)
[17:59:21.534]                             muffled <- TRUE
[17:59:21.534]                             break
[17:59:21.534]                           }
[17:59:21.534]                         }
[17:59:21.534]                       }
[17:59:21.534]                       invisible(muffled)
[17:59:21.534]                     }
[17:59:21.534]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.534]                   }
[17:59:21.534]                 }
[17:59:21.534]                 else {
[17:59:21.534]                   if (TRUE) {
[17:59:21.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.534]                     {
[17:59:21.534]                       inherits <- base::inherits
[17:59:21.534]                       invokeRestart <- base::invokeRestart
[17:59:21.534]                       is.null <- base::is.null
[17:59:21.534]                       muffled <- FALSE
[17:59:21.534]                       if (inherits(cond, "message")) {
[17:59:21.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.534]                         if (muffled) 
[17:59:21.534]                           invokeRestart("muffleMessage")
[17:59:21.534]                       }
[17:59:21.534]                       else if (inherits(cond, "warning")) {
[17:59:21.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.534]                         if (muffled) 
[17:59:21.534]                           invokeRestart("muffleWarning")
[17:59:21.534]                       }
[17:59:21.534]                       else if (inherits(cond, "condition")) {
[17:59:21.534]                         if (!is.null(pattern)) {
[17:59:21.534]                           computeRestarts <- base::computeRestarts
[17:59:21.534]                           grepl <- base::grepl
[17:59:21.534]                           restarts <- computeRestarts(cond)
[17:59:21.534]                           for (restart in restarts) {
[17:59:21.534]                             name <- restart$name
[17:59:21.534]                             if (is.null(name)) 
[17:59:21.534]                               next
[17:59:21.534]                             if (!grepl(pattern, name)) 
[17:59:21.534]                               next
[17:59:21.534]                             invokeRestart(restart)
[17:59:21.534]                             muffled <- TRUE
[17:59:21.534]                             break
[17:59:21.534]                           }
[17:59:21.534]                         }
[17:59:21.534]                       }
[17:59:21.534]                       invisible(muffled)
[17:59:21.534]                     }
[17:59:21.534]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.534]                   }
[17:59:21.534]                 }
[17:59:21.534]             }
[17:59:21.534]         }))
[17:59:21.534]     }, error = function(ex) {
[17:59:21.534]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:21.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.534]                 ...future.rng), started = ...future.startTime, 
[17:59:21.534]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:21.534]             version = "1.8"), class = "FutureResult")
[17:59:21.534]     }, finally = {
[17:59:21.534]         if (!identical(...future.workdir, getwd())) 
[17:59:21.534]             setwd(...future.workdir)
[17:59:21.534]         {
[17:59:21.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:21.534]                 ...future.oldOptions$nwarnings <- NULL
[17:59:21.534]             }
[17:59:21.534]             base::options(...future.oldOptions)
[17:59:21.534]             if (.Platform$OS.type == "windows") {
[17:59:21.534]                 old_names <- names(...future.oldEnvVars)
[17:59:21.534]                 envs <- base::Sys.getenv()
[17:59:21.534]                 names <- names(envs)
[17:59:21.534]                 common <- intersect(names, old_names)
[17:59:21.534]                 added <- setdiff(names, old_names)
[17:59:21.534]                 removed <- setdiff(old_names, names)
[17:59:21.534]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:21.534]                   envs[common]]
[17:59:21.534]                 NAMES <- toupper(changed)
[17:59:21.534]                 args <- list()
[17:59:21.534]                 for (kk in seq_along(NAMES)) {
[17:59:21.534]                   name <- changed[[kk]]
[17:59:21.534]                   NAME <- NAMES[[kk]]
[17:59:21.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.534]                     next
[17:59:21.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.534]                 }
[17:59:21.534]                 NAMES <- toupper(added)
[17:59:21.534]                 for (kk in seq_along(NAMES)) {
[17:59:21.534]                   name <- added[[kk]]
[17:59:21.534]                   NAME <- NAMES[[kk]]
[17:59:21.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.534]                     next
[17:59:21.534]                   args[[name]] <- ""
[17:59:21.534]                 }
[17:59:21.534]                 NAMES <- toupper(removed)
[17:59:21.534]                 for (kk in seq_along(NAMES)) {
[17:59:21.534]                   name <- removed[[kk]]
[17:59:21.534]                   NAME <- NAMES[[kk]]
[17:59:21.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.534]                     next
[17:59:21.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.534]                 }
[17:59:21.534]                 if (length(args) > 0) 
[17:59:21.534]                   base::do.call(base::Sys.setenv, args = args)
[17:59:21.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:21.534]             }
[17:59:21.534]             else {
[17:59:21.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:21.534]             }
[17:59:21.534]             {
[17:59:21.534]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:21.534]                   0L) {
[17:59:21.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:21.534]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:21.534]                   base::options(opts)
[17:59:21.534]                 }
[17:59:21.534]                 {
[17:59:21.534]                   {
[17:59:21.534]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:21.534]                     NULL
[17:59:21.534]                   }
[17:59:21.534]                   options(future.plan = NULL)
[17:59:21.534]                   if (is.na(NA_character_)) 
[17:59:21.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:21.534]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:21.534]                     .init = FALSE)
[17:59:21.534]                 }
[17:59:21.534]             }
[17:59:21.534]         }
[17:59:21.534]     })
[17:59:21.534]     if (TRUE) {
[17:59:21.534]         base::sink(type = "output", split = FALSE)
[17:59:21.534]         if (TRUE) {
[17:59:21.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:21.534]         }
[17:59:21.534]         else {
[17:59:21.534]             ...future.result["stdout"] <- base::list(NULL)
[17:59:21.534]         }
[17:59:21.534]         base::close(...future.stdout)
[17:59:21.534]         ...future.stdout <- NULL
[17:59:21.534]     }
[17:59:21.534]     ...future.result$conditions <- ...future.conditions
[17:59:21.534]     ...future.result$finished <- base::Sys.time()
[17:59:21.534]     ...future.result
[17:59:21.534] }
[17:59:21.539] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[17:59:21.540] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:21.541] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:21.541] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:59:21.542] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:59:21.542] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:59:21.543] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:59:21.543] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:21.544] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:21.544] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:59:21.545] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:59:21.545] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[17:59:21.546] MultisessionFuture started
[17:59:21.547] - Launch lazy future ... done
[17:59:21.547] run() for ‘MultisessionFuture’ ... done
[17:59:21.547] Created future:
[17:59:21.547] MultisessionFuture:
[17:59:21.547] Label: ‘future_apply-2’
[17:59:21.547] Expression:
[17:59:21.547] {
[17:59:21.547]     do.call(function(...) {
[17:59:21.547]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.547]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.547]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.547]             on.exit(options(oopts), add = TRUE)
[17:59:21.547]         }
[17:59:21.547]         {
[17:59:21.547]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.547]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.547]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.547]             })
[17:59:21.547]         }
[17:59:21.547]     }, args = future.call.arguments)
[17:59:21.547] }
[17:59:21.547] Lazy evaluation: FALSE
[17:59:21.547] Asynchronous evaluation: TRUE
[17:59:21.547] Local evaluation: TRUE
[17:59:21.547] Environment: R_GlobalEnv
[17:59:21.547] Capture standard output: TRUE
[17:59:21.547] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:21.547] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:21.547] Packages: <none>
[17:59:21.547] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:21.547] Resolved: FALSE
[17:59:21.547] Value: <not collected>
[17:59:21.547] Conditions captured: <none>
[17:59:21.547] Early signaling: FALSE
[17:59:21.547] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:21.547] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.560] Chunk #2 of 2 ... DONE
[17:59:21.560] Launching 2 futures (chunks) ... DONE
[17:59:21.561] Resolving 2 futures (chunks) ...
[17:59:21.561] resolve() on list ...
[17:59:21.561]  recursive: 0
[17:59:21.561]  length: 2
[17:59:21.561] 
[17:59:21.562] receiveMessageFromWorker() for ClusterFuture ...
[17:59:21.562] - Validating connection of MultisessionFuture
[17:59:21.563] - received message: FutureResult
[17:59:21.563] - Received FutureResult
[17:59:21.563] - Erased future from FutureRegistry
[17:59:21.563] result() for ClusterFuture ...
[17:59:21.564] - result already collected: FutureResult
[17:59:21.564] result() for ClusterFuture ... done
[17:59:21.564] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:21.564] Future #1
[17:59:21.564] result() for ClusterFuture ...
[17:59:21.565] - result already collected: FutureResult
[17:59:21.565] result() for ClusterFuture ... done
[17:59:21.565] result() for ClusterFuture ...
[17:59:21.565] - result already collected: FutureResult
[17:59:21.565] result() for ClusterFuture ... done
[17:59:21.565] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:21.566] - nx: 2
[17:59:21.566] - relay: TRUE
[17:59:21.566] - stdout: TRUE
[17:59:21.566] - signal: TRUE
[17:59:21.566] - resignal: FALSE
[17:59:21.567] - force: TRUE
[17:59:21.567] - relayed: [n=2] FALSE, FALSE
[17:59:21.567] - queued futures: [n=2] FALSE, FALSE
[17:59:21.567]  - until=1
[17:59:21.567]  - relaying element #1
[17:59:21.567] result() for ClusterFuture ...
[17:59:21.568] - result already collected: FutureResult
[17:59:21.568] result() for ClusterFuture ... done
[17:59:21.568] result() for ClusterFuture ...
[17:59:21.568] - result already collected: FutureResult
[17:59:21.568] result() for ClusterFuture ... done
[17:59:21.569] result() for ClusterFuture ...
[17:59:21.569] - result already collected: FutureResult
[17:59:21.569] result() for ClusterFuture ... done
[17:59:21.569] result() for ClusterFuture ...
[17:59:21.569] - result already collected: FutureResult
[17:59:21.570] result() for ClusterFuture ... done
[17:59:21.570] - relayed: [n=2] TRUE, FALSE
[17:59:21.570] - queued futures: [n=2] TRUE, FALSE
[17:59:21.570] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:21.570]  length: 1 (resolved future 1)
[17:59:21.592] receiveMessageFromWorker() for ClusterFuture ...
[17:59:21.593] - Validating connection of MultisessionFuture
[17:59:21.593] - received message: FutureResult
[17:59:21.593] - Received FutureResult
[17:59:21.594] - Erased future from FutureRegistry
[17:59:21.594] result() for ClusterFuture ...
[17:59:21.594] - result already collected: FutureResult
[17:59:21.594] result() for ClusterFuture ... done
[17:59:21.594] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:21.595] Future #2
[17:59:21.595] result() for ClusterFuture ...
[17:59:21.595] - result already collected: FutureResult
[17:59:21.595] result() for ClusterFuture ... done
[17:59:21.595] result() for ClusterFuture ...
[17:59:21.596] - result already collected: FutureResult
[17:59:21.596] result() for ClusterFuture ... done
[17:59:21.596] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:21.596] - nx: 2
[17:59:21.596] - relay: TRUE
[17:59:21.597] - stdout: TRUE
[17:59:21.597] - signal: TRUE
[17:59:21.597] - resignal: FALSE
[17:59:21.597] - force: TRUE
[17:59:21.597] - relayed: [n=2] TRUE, FALSE
[17:59:21.597] - queued futures: [n=2] TRUE, FALSE
[17:59:21.598]  - until=2
[17:59:21.598]  - relaying element #2
[17:59:21.598] result() for ClusterFuture ...
[17:59:21.598] - result already collected: FutureResult
[17:59:21.598] result() for ClusterFuture ... done
[17:59:21.599] result() for ClusterFuture ...
[17:59:21.599] - result already collected: FutureResult
[17:59:21.599] result() for ClusterFuture ... done
[17:59:21.599] result() for ClusterFuture ...
[17:59:21.599] - result already collected: FutureResult
[17:59:21.599] result() for ClusterFuture ... done
[17:59:21.600] result() for ClusterFuture ...
[17:59:21.600] - result already collected: FutureResult
[17:59:21.600] result() for ClusterFuture ... done
[17:59:21.600] - relayed: [n=2] TRUE, TRUE
[17:59:21.600] - queued futures: [n=2] TRUE, TRUE
[17:59:21.601] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:21.601]  length: 0 (resolved future 2)
[17:59:21.601] Relaying remaining futures
[17:59:21.601] signalConditionsASAP(NULL, pos=0) ...
[17:59:21.601] - nx: 2
[17:59:21.601] - relay: TRUE
[17:59:21.602] - stdout: TRUE
[17:59:21.602] - signal: TRUE
[17:59:21.602] - resignal: FALSE
[17:59:21.602] - force: TRUE
[17:59:21.602] - relayed: [n=2] TRUE, TRUE
[17:59:21.603] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:21.603] - relayed: [n=2] TRUE, TRUE
[17:59:21.603] - queued futures: [n=2] TRUE, TRUE
[17:59:21.603] signalConditionsASAP(NULL, pos=0) ... done
[17:59:21.603] resolve() on list ... DONE
[17:59:21.604] result() for ClusterFuture ...
[17:59:21.604] - result already collected: FutureResult
[17:59:21.604] result() for ClusterFuture ... done
[17:59:21.604] result() for ClusterFuture ...
[17:59:21.604] - result already collected: FutureResult
[17:59:21.604] result() for ClusterFuture ... done
[17:59:21.605] result() for ClusterFuture ...
[17:59:21.605] - result already collected: FutureResult
[17:59:21.605] result() for ClusterFuture ... done
[17:59:21.605] result() for ClusterFuture ...
[17:59:21.605] - result already collected: FutureResult
[17:59:21.606] result() for ClusterFuture ... done
[17:59:21.606]  - Number of value chunks collected: 2
[17:59:21.606] Resolving 2 futures (chunks) ... DONE
[17:59:21.606] Reducing values from 2 chunks ...
[17:59:21.606]  - Number of values collected after concatenation: 2
[17:59:21.607]  - Number of values expected: 2
[17:59:21.607] Reducing values from 2 chunks ... DONE
[17:59:21.607] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:59:21.608] getGlobalsAndPackagesXApply() ...
[17:59:21.608]  - future.globals: TRUE
[17:59:21.608] getGlobalsAndPackages() ...
[17:59:21.608] Searching for globals...
[17:59:21.610] - globals found: [1] ‘FUN’
[17:59:21.610] Searching for globals ... DONE
[17:59:21.611] Resolving globals: FALSE
[17:59:21.611] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:21.612] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:21.612] - globals: [1] ‘FUN’
[17:59:21.612] 
[17:59:21.612] getGlobalsAndPackages() ... DONE
[17:59:21.613]  - globals found/used: [n=1] ‘FUN’
[17:59:21.613]  - needed namespaces: [n=0] 
[17:59:21.613] Finding globals ... DONE
[17:59:21.613]  - use_args: TRUE
[17:59:21.613]  - Getting '...' globals ...
[17:59:21.614] resolve() on list ...
[17:59:21.614]  recursive: 0
[17:59:21.614]  length: 1
[17:59:21.615]  elements: ‘...’
[17:59:21.615]  length: 0 (resolved future 1)
[17:59:21.615] resolve() on list ... DONE
[17:59:21.615]    - '...' content: [n=0] 
[17:59:21.615] List of 1
[17:59:21.615]  $ ...: list()
[17:59:21.615]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.615]  - attr(*, "where")=List of 1
[17:59:21.615]   ..$ ...:<environment: 0x56085d8b9dc0> 
[17:59:21.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.615]  - attr(*, "resolved")= logi TRUE
[17:59:21.615]  - attr(*, "total_size")= num NA
[17:59:21.620]  - Getting '...' globals ... DONE
[17:59:21.621] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:21.621] List of 2
[17:59:21.621]  $ ...future.FUN:function (x)  
[17:59:21.621]  $ ...          : list()
[17:59:21.621]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.621]  - attr(*, "where")=List of 2
[17:59:21.621]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:21.621]   ..$ ...          :<environment: 0x56085d8b9dc0> 
[17:59:21.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.621]  - attr(*, "resolved")= logi FALSE
[17:59:21.621]  - attr(*, "total_size")= num 848
[17:59:21.626] Packages to be attached in all futures: [n=0] 
[17:59:21.626] getGlobalsAndPackagesXApply() ... DONE
[17:59:21.632] future_lapply() ...
[17:59:21.639] Number of chunks: 2
[17:59:21.639] getGlobalsAndPackagesXApply() ...
[17:59:21.640]  - future.globals: <name-value list> with names ‘list()’
[17:59:21.640]  - use_args: TRUE
[17:59:21.640] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:21.641] List of 2
[17:59:21.641]  $ ...          : list()
[17:59:21.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.641]  $ ...future.FUN:function (x)  
[17:59:21.641]  - attr(*, "where")=List of 2
[17:59:21.641]   ..$ ...          :<environment: 0x56085d8b9dc0> 
[17:59:21.641]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:21.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.641]  - attr(*, "resolved")= logi FALSE
[17:59:21.641]  - attr(*, "total_size")= num NA
[17:59:21.647] Packages to be attached in all futures: [n=0] 
[17:59:21.647] getGlobalsAndPackagesXApply() ... DONE
[17:59:21.648] Number of futures (= number of chunks): 2
[17:59:21.648] Launching 2 futures (chunks) ...
[17:59:21.648] Chunk #1 of 2 ...
[17:59:21.648]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:21.649]  - seeds: <none>
[17:59:21.649]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.649] getGlobalsAndPackages() ...
[17:59:21.649] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.649] Resolving globals: FALSE
[17:59:21.650] Tweak future expression to call with '...' arguments ...
[17:59:21.650] {
[17:59:21.650]     do.call(function(...) {
[17:59:21.650]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.650]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.650]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.650]             on.exit(options(oopts), add = TRUE)
[17:59:21.650]         }
[17:59:21.650]         {
[17:59:21.650]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.650]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.650]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.650]             })
[17:59:21.650]         }
[17:59:21.650]     }, args = future.call.arguments)
[17:59:21.650] }
[17:59:21.650] Tweak future expression to call with '...' arguments ... DONE
[17:59:21.651] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.651] 
[17:59:21.652] getGlobalsAndPackages() ... DONE
[17:59:21.652] run() for ‘Future’ ...
[17:59:21.652] - state: ‘created’
[17:59:21.653] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:21.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:21.677]   - Field: ‘node’
[17:59:21.678]   - Field: ‘label’
[17:59:21.678]   - Field: ‘local’
[17:59:21.678]   - Field: ‘owner’
[17:59:21.678]   - Field: ‘envir’
[17:59:21.678]   - Field: ‘workers’
[17:59:21.679]   - Field: ‘packages’
[17:59:21.679]   - Field: ‘gc’
[17:59:21.679]   - Field: ‘conditions’
[17:59:21.679]   - Field: ‘persistent’
[17:59:21.679]   - Field: ‘expr’
[17:59:21.680]   - Field: ‘uuid’
[17:59:21.680]   - Field: ‘seed’
[17:59:21.680]   - Field: ‘version’
[17:59:21.680]   - Field: ‘result’
[17:59:21.680]   - Field: ‘asynchronous’
[17:59:21.681]   - Field: ‘calls’
[17:59:21.681]   - Field: ‘globals’
[17:59:21.681]   - Field: ‘stdout’
[17:59:21.681]   - Field: ‘earlySignal’
[17:59:21.681]   - Field: ‘lazy’
[17:59:21.682]   - Field: ‘state’
[17:59:21.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:21.682] - Launch lazy future ...
[17:59:21.682] Packages needed by the future expression (n = 0): <none>
[17:59:21.683] Packages needed by future strategies (n = 0): <none>
[17:59:21.684] {
[17:59:21.684]     {
[17:59:21.684]         {
[17:59:21.684]             ...future.startTime <- base::Sys.time()
[17:59:21.684]             {
[17:59:21.684]                 {
[17:59:21.684]                   {
[17:59:21.684]                     {
[17:59:21.684]                       base::local({
[17:59:21.684]                         has_future <- base::requireNamespace("future", 
[17:59:21.684]                           quietly = TRUE)
[17:59:21.684]                         if (has_future) {
[17:59:21.684]                           ns <- base::getNamespace("future")
[17:59:21.684]                           version <- ns[[".package"]][["version"]]
[17:59:21.684]                           if (is.null(version)) 
[17:59:21.684]                             version <- utils::packageVersion("future")
[17:59:21.684]                         }
[17:59:21.684]                         else {
[17:59:21.684]                           version <- NULL
[17:59:21.684]                         }
[17:59:21.684]                         if (!has_future || version < "1.8.0") {
[17:59:21.684]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:21.684]                             "", base::R.version$version.string), 
[17:59:21.684]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:21.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:21.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:21.684]                               "release", "version")], collapse = " "), 
[17:59:21.684]                             hostname = base::Sys.info()[["nodename"]])
[17:59:21.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:21.684]                             info)
[17:59:21.684]                           info <- base::paste(info, collapse = "; ")
[17:59:21.684]                           if (!has_future) {
[17:59:21.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:21.684]                               info)
[17:59:21.684]                           }
[17:59:21.684]                           else {
[17:59:21.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:21.684]                               info, version)
[17:59:21.684]                           }
[17:59:21.684]                           base::stop(msg)
[17:59:21.684]                         }
[17:59:21.684]                       })
[17:59:21.684]                     }
[17:59:21.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:21.684]                     base::options(mc.cores = 1L)
[17:59:21.684]                   }
[17:59:21.684]                   ...future.strategy.old <- future::plan("list")
[17:59:21.684]                   options(future.plan = NULL)
[17:59:21.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:21.684]                 }
[17:59:21.684]                 ...future.workdir <- getwd()
[17:59:21.684]             }
[17:59:21.684]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:21.684]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:21.684]         }
[17:59:21.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:21.684]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:21.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:21.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:21.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:21.684]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:21.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:21.684]             base::names(...future.oldOptions))
[17:59:21.684]     }
[17:59:21.684]     if (FALSE) {
[17:59:21.684]     }
[17:59:21.684]     else {
[17:59:21.684]         if (TRUE) {
[17:59:21.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:21.684]                 open = "w")
[17:59:21.684]         }
[17:59:21.684]         else {
[17:59:21.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:21.684]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:21.684]         }
[17:59:21.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:21.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:21.684]             base::sink(type = "output", split = FALSE)
[17:59:21.684]             base::close(...future.stdout)
[17:59:21.684]         }, add = TRUE)
[17:59:21.684]     }
[17:59:21.684]     ...future.frame <- base::sys.nframe()
[17:59:21.684]     ...future.conditions <- base::list()
[17:59:21.684]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:21.684]     if (FALSE) {
[17:59:21.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:21.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:21.684]     }
[17:59:21.684]     ...future.result <- base::tryCatch({
[17:59:21.684]         base::withCallingHandlers({
[17:59:21.684]             ...future.value <- base::withVisible(base::local({
[17:59:21.684]                 ...future.makeSendCondition <- base::local({
[17:59:21.684]                   sendCondition <- NULL
[17:59:21.684]                   function(frame = 1L) {
[17:59:21.684]                     if (is.function(sendCondition)) 
[17:59:21.684]                       return(sendCondition)
[17:59:21.684]                     ns <- getNamespace("parallel")
[17:59:21.684]                     if (exists("sendData", mode = "function", 
[17:59:21.684]                       envir = ns)) {
[17:59:21.684]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:21.684]                         envir = ns)
[17:59:21.684]                       envir <- sys.frame(frame)
[17:59:21.684]                       master <- NULL
[17:59:21.684]                       while (!identical(envir, .GlobalEnv) && 
[17:59:21.684]                         !identical(envir, emptyenv())) {
[17:59:21.684]                         if (exists("master", mode = "list", envir = envir, 
[17:59:21.684]                           inherits = FALSE)) {
[17:59:21.684]                           master <- get("master", mode = "list", 
[17:59:21.684]                             envir = envir, inherits = FALSE)
[17:59:21.684]                           if (inherits(master, c("SOCKnode", 
[17:59:21.684]                             "SOCK0node"))) {
[17:59:21.684]                             sendCondition <<- function(cond) {
[17:59:21.684]                               data <- list(type = "VALUE", value = cond, 
[17:59:21.684]                                 success = TRUE)
[17:59:21.684]                               parallel_sendData(master, data)
[17:59:21.684]                             }
[17:59:21.684]                             return(sendCondition)
[17:59:21.684]                           }
[17:59:21.684]                         }
[17:59:21.684]                         frame <- frame + 1L
[17:59:21.684]                         envir <- sys.frame(frame)
[17:59:21.684]                       }
[17:59:21.684]                     }
[17:59:21.684]                     sendCondition <<- function(cond) NULL
[17:59:21.684]                   }
[17:59:21.684]                 })
[17:59:21.684]                 withCallingHandlers({
[17:59:21.684]                   {
[17:59:21.684]                     do.call(function(...) {
[17:59:21.684]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.684]                       if (!identical(...future.globals.maxSize.org, 
[17:59:21.684]                         ...future.globals.maxSize)) {
[17:59:21.684]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.684]                         on.exit(options(oopts), add = TRUE)
[17:59:21.684]                       }
[17:59:21.684]                       {
[17:59:21.684]                         lapply(seq_along(...future.elements_ii), 
[17:59:21.684]                           FUN = function(jj) {
[17:59:21.684]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.684]                             ...future.FUN(...future.X_jj, ...)
[17:59:21.684]                           })
[17:59:21.684]                       }
[17:59:21.684]                     }, args = future.call.arguments)
[17:59:21.684]                   }
[17:59:21.684]                 }, immediateCondition = function(cond) {
[17:59:21.684]                   sendCondition <- ...future.makeSendCondition()
[17:59:21.684]                   sendCondition(cond)
[17:59:21.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.684]                   {
[17:59:21.684]                     inherits <- base::inherits
[17:59:21.684]                     invokeRestart <- base::invokeRestart
[17:59:21.684]                     is.null <- base::is.null
[17:59:21.684]                     muffled <- FALSE
[17:59:21.684]                     if (inherits(cond, "message")) {
[17:59:21.684]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:21.684]                       if (muffled) 
[17:59:21.684]                         invokeRestart("muffleMessage")
[17:59:21.684]                     }
[17:59:21.684]                     else if (inherits(cond, "warning")) {
[17:59:21.684]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:21.684]                       if (muffled) 
[17:59:21.684]                         invokeRestart("muffleWarning")
[17:59:21.684]                     }
[17:59:21.684]                     else if (inherits(cond, "condition")) {
[17:59:21.684]                       if (!is.null(pattern)) {
[17:59:21.684]                         computeRestarts <- base::computeRestarts
[17:59:21.684]                         grepl <- base::grepl
[17:59:21.684]                         restarts <- computeRestarts(cond)
[17:59:21.684]                         for (restart in restarts) {
[17:59:21.684]                           name <- restart$name
[17:59:21.684]                           if (is.null(name)) 
[17:59:21.684]                             next
[17:59:21.684]                           if (!grepl(pattern, name)) 
[17:59:21.684]                             next
[17:59:21.684]                           invokeRestart(restart)
[17:59:21.684]                           muffled <- TRUE
[17:59:21.684]                           break
[17:59:21.684]                         }
[17:59:21.684]                       }
[17:59:21.684]                     }
[17:59:21.684]                     invisible(muffled)
[17:59:21.684]                   }
[17:59:21.684]                   muffleCondition(cond)
[17:59:21.684]                 })
[17:59:21.684]             }))
[17:59:21.684]             future::FutureResult(value = ...future.value$value, 
[17:59:21.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.684]                   ...future.rng), globalenv = if (FALSE) 
[17:59:21.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:21.684]                     ...future.globalenv.names))
[17:59:21.684]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:21.684]         }, condition = base::local({
[17:59:21.684]             c <- base::c
[17:59:21.684]             inherits <- base::inherits
[17:59:21.684]             invokeRestart <- base::invokeRestart
[17:59:21.684]             length <- base::length
[17:59:21.684]             list <- base::list
[17:59:21.684]             seq.int <- base::seq.int
[17:59:21.684]             signalCondition <- base::signalCondition
[17:59:21.684]             sys.calls <- base::sys.calls
[17:59:21.684]             `[[` <- base::`[[`
[17:59:21.684]             `+` <- base::`+`
[17:59:21.684]             `<<-` <- base::`<<-`
[17:59:21.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:21.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:21.684]                   3L)]
[17:59:21.684]             }
[17:59:21.684]             function(cond) {
[17:59:21.684]                 is_error <- inherits(cond, "error")
[17:59:21.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:21.684]                   NULL)
[17:59:21.684]                 if (is_error) {
[17:59:21.684]                   sessionInformation <- function() {
[17:59:21.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:21.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:21.684]                       search = base::search(), system = base::Sys.info())
[17:59:21.684]                   }
[17:59:21.684]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:21.684]                     cond$call), session = sessionInformation(), 
[17:59:21.684]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:21.684]                   signalCondition(cond)
[17:59:21.684]                 }
[17:59:21.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:21.684]                 "immediateCondition"))) {
[17:59:21.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:21.684]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:21.684]                   if (TRUE && !signal) {
[17:59:21.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.684]                     {
[17:59:21.684]                       inherits <- base::inherits
[17:59:21.684]                       invokeRestart <- base::invokeRestart
[17:59:21.684]                       is.null <- base::is.null
[17:59:21.684]                       muffled <- FALSE
[17:59:21.684]                       if (inherits(cond, "message")) {
[17:59:21.684]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.684]                         if (muffled) 
[17:59:21.684]                           invokeRestart("muffleMessage")
[17:59:21.684]                       }
[17:59:21.684]                       else if (inherits(cond, "warning")) {
[17:59:21.684]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.684]                         if (muffled) 
[17:59:21.684]                           invokeRestart("muffleWarning")
[17:59:21.684]                       }
[17:59:21.684]                       else if (inherits(cond, "condition")) {
[17:59:21.684]                         if (!is.null(pattern)) {
[17:59:21.684]                           computeRestarts <- base::computeRestarts
[17:59:21.684]                           grepl <- base::grepl
[17:59:21.684]                           restarts <- computeRestarts(cond)
[17:59:21.684]                           for (restart in restarts) {
[17:59:21.684]                             name <- restart$name
[17:59:21.684]                             if (is.null(name)) 
[17:59:21.684]                               next
[17:59:21.684]                             if (!grepl(pattern, name)) 
[17:59:21.684]                               next
[17:59:21.684]                             invokeRestart(restart)
[17:59:21.684]                             muffled <- TRUE
[17:59:21.684]                             break
[17:59:21.684]                           }
[17:59:21.684]                         }
[17:59:21.684]                       }
[17:59:21.684]                       invisible(muffled)
[17:59:21.684]                     }
[17:59:21.684]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.684]                   }
[17:59:21.684]                 }
[17:59:21.684]                 else {
[17:59:21.684]                   if (TRUE) {
[17:59:21.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.684]                     {
[17:59:21.684]                       inherits <- base::inherits
[17:59:21.684]                       invokeRestart <- base::invokeRestart
[17:59:21.684]                       is.null <- base::is.null
[17:59:21.684]                       muffled <- FALSE
[17:59:21.684]                       if (inherits(cond, "message")) {
[17:59:21.684]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.684]                         if (muffled) 
[17:59:21.684]                           invokeRestart("muffleMessage")
[17:59:21.684]                       }
[17:59:21.684]                       else if (inherits(cond, "warning")) {
[17:59:21.684]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.684]                         if (muffled) 
[17:59:21.684]                           invokeRestart("muffleWarning")
[17:59:21.684]                       }
[17:59:21.684]                       else if (inherits(cond, "condition")) {
[17:59:21.684]                         if (!is.null(pattern)) {
[17:59:21.684]                           computeRestarts <- base::computeRestarts
[17:59:21.684]                           grepl <- base::grepl
[17:59:21.684]                           restarts <- computeRestarts(cond)
[17:59:21.684]                           for (restart in restarts) {
[17:59:21.684]                             name <- restart$name
[17:59:21.684]                             if (is.null(name)) 
[17:59:21.684]                               next
[17:59:21.684]                             if (!grepl(pattern, name)) 
[17:59:21.684]                               next
[17:59:21.684]                             invokeRestart(restart)
[17:59:21.684]                             muffled <- TRUE
[17:59:21.684]                             break
[17:59:21.684]                           }
[17:59:21.684]                         }
[17:59:21.684]                       }
[17:59:21.684]                       invisible(muffled)
[17:59:21.684]                     }
[17:59:21.684]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.684]                   }
[17:59:21.684]                 }
[17:59:21.684]             }
[17:59:21.684]         }))
[17:59:21.684]     }, error = function(ex) {
[17:59:21.684]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:21.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.684]                 ...future.rng), started = ...future.startTime, 
[17:59:21.684]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:21.684]             version = "1.8"), class = "FutureResult")
[17:59:21.684]     }, finally = {
[17:59:21.684]         if (!identical(...future.workdir, getwd())) 
[17:59:21.684]             setwd(...future.workdir)
[17:59:21.684]         {
[17:59:21.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:21.684]                 ...future.oldOptions$nwarnings <- NULL
[17:59:21.684]             }
[17:59:21.684]             base::options(...future.oldOptions)
[17:59:21.684]             if (.Platform$OS.type == "windows") {
[17:59:21.684]                 old_names <- names(...future.oldEnvVars)
[17:59:21.684]                 envs <- base::Sys.getenv()
[17:59:21.684]                 names <- names(envs)
[17:59:21.684]                 common <- intersect(names, old_names)
[17:59:21.684]                 added <- setdiff(names, old_names)
[17:59:21.684]                 removed <- setdiff(old_names, names)
[17:59:21.684]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:21.684]                   envs[common]]
[17:59:21.684]                 NAMES <- toupper(changed)
[17:59:21.684]                 args <- list()
[17:59:21.684]                 for (kk in seq_along(NAMES)) {
[17:59:21.684]                   name <- changed[[kk]]
[17:59:21.684]                   NAME <- NAMES[[kk]]
[17:59:21.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.684]                     next
[17:59:21.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.684]                 }
[17:59:21.684]                 NAMES <- toupper(added)
[17:59:21.684]                 for (kk in seq_along(NAMES)) {
[17:59:21.684]                   name <- added[[kk]]
[17:59:21.684]                   NAME <- NAMES[[kk]]
[17:59:21.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.684]                     next
[17:59:21.684]                   args[[name]] <- ""
[17:59:21.684]                 }
[17:59:21.684]                 NAMES <- toupper(removed)
[17:59:21.684]                 for (kk in seq_along(NAMES)) {
[17:59:21.684]                   name <- removed[[kk]]
[17:59:21.684]                   NAME <- NAMES[[kk]]
[17:59:21.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.684]                     next
[17:59:21.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.684]                 }
[17:59:21.684]                 if (length(args) > 0) 
[17:59:21.684]                   base::do.call(base::Sys.setenv, args = args)
[17:59:21.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:21.684]             }
[17:59:21.684]             else {
[17:59:21.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:21.684]             }
[17:59:21.684]             {
[17:59:21.684]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:21.684]                   0L) {
[17:59:21.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:21.684]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:21.684]                   base::options(opts)
[17:59:21.684]                 }
[17:59:21.684]                 {
[17:59:21.684]                   {
[17:59:21.684]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:21.684]                     NULL
[17:59:21.684]                   }
[17:59:21.684]                   options(future.plan = NULL)
[17:59:21.684]                   if (is.na(NA_character_)) 
[17:59:21.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:21.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:21.684]                     .init = FALSE)
[17:59:21.684]                 }
[17:59:21.684]             }
[17:59:21.684]         }
[17:59:21.684]     })
[17:59:21.684]     if (TRUE) {
[17:59:21.684]         base::sink(type = "output", split = FALSE)
[17:59:21.684]         if (TRUE) {
[17:59:21.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:21.684]         }
[17:59:21.684]         else {
[17:59:21.684]             ...future.result["stdout"] <- base::list(NULL)
[17:59:21.684]         }
[17:59:21.684]         base::close(...future.stdout)
[17:59:21.684]         ...future.stdout <- NULL
[17:59:21.684]     }
[17:59:21.684]     ...future.result$conditions <- ...future.conditions
[17:59:21.684]     ...future.result$finished <- base::Sys.time()
[17:59:21.684]     ...future.result
[17:59:21.684] }
[17:59:21.689] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:59:21.690] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:21.690] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:21.691] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:59:21.692] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:59:21.692] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:59:21.693] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:59:21.693] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:21.694] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:21.694] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:59:21.695] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:59:21.695] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:59:21.696] MultisessionFuture started
[17:59:21.697] - Launch lazy future ... done
[17:59:21.697] run() for ‘MultisessionFuture’ ... done
[17:59:21.697] Created future:
[17:59:21.697] MultisessionFuture:
[17:59:21.697] Label: ‘future_apply-1’
[17:59:21.697] Expression:
[17:59:21.697] {
[17:59:21.697]     do.call(function(...) {
[17:59:21.697]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.697]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.697]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.697]             on.exit(options(oopts), add = TRUE)
[17:59:21.697]         }
[17:59:21.697]         {
[17:59:21.697]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.697]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.697]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.697]             })
[17:59:21.697]         }
[17:59:21.697]     }, args = future.call.arguments)
[17:59:21.697] }
[17:59:21.697] Lazy evaluation: FALSE
[17:59:21.697] Asynchronous evaluation: TRUE
[17:59:21.697] Local evaluation: TRUE
[17:59:21.697] Environment: R_GlobalEnv
[17:59:21.697] Capture standard output: TRUE
[17:59:21.697] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:21.697] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:21.697] Packages: <none>
[17:59:21.697] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:21.697] Resolved: FALSE
[17:59:21.697] Value: <not collected>
[17:59:21.697] Conditions captured: <none>
[17:59:21.697] Early signaling: FALSE
[17:59:21.697] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:21.697] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.710] Chunk #1 of 2 ... DONE
[17:59:21.710] Chunk #2 of 2 ...
[17:59:21.711]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:21.711]  - seeds: <none>
[17:59:21.711]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.711] getGlobalsAndPackages() ...
[17:59:21.712] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.712] Resolving globals: FALSE
[17:59:21.712] Tweak future expression to call with '...' arguments ...
[17:59:21.712] {
[17:59:21.712]     do.call(function(...) {
[17:59:21.712]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.712]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.712]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.712]             on.exit(options(oopts), add = TRUE)
[17:59:21.712]         }
[17:59:21.712]         {
[17:59:21.712]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.712]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.712]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.712]             })
[17:59:21.712]         }
[17:59:21.712]     }, args = future.call.arguments)
[17:59:21.712] }
[17:59:21.713] Tweak future expression to call with '...' arguments ... DONE
[17:59:21.714] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.714] 
[17:59:21.714] getGlobalsAndPackages() ... DONE
[17:59:21.715] run() for ‘Future’ ...
[17:59:21.715] - state: ‘created’
[17:59:21.715] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:21.740] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:21.740]   - Field: ‘node’
[17:59:21.740]   - Field: ‘label’
[17:59:21.741]   - Field: ‘local’
[17:59:21.741]   - Field: ‘owner’
[17:59:21.741]   - Field: ‘envir’
[17:59:21.741]   - Field: ‘workers’
[17:59:21.741]   - Field: ‘packages’
[17:59:21.742]   - Field: ‘gc’
[17:59:21.742]   - Field: ‘conditions’
[17:59:21.742]   - Field: ‘persistent’
[17:59:21.742]   - Field: ‘expr’
[17:59:21.742]   - Field: ‘uuid’
[17:59:21.743]   - Field: ‘seed’
[17:59:21.743]   - Field: ‘version’
[17:59:21.743]   - Field: ‘result’
[17:59:21.746]   - Field: ‘asynchronous’
[17:59:21.747]   - Field: ‘calls’
[17:59:21.747]   - Field: ‘globals’
[17:59:21.747]   - Field: ‘stdout’
[17:59:21.747]   - Field: ‘earlySignal’
[17:59:21.748]   - Field: ‘lazy’
[17:59:21.748]   - Field: ‘state’
[17:59:21.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:21.748] - Launch lazy future ...
[17:59:21.749] Packages needed by the future expression (n = 0): <none>
[17:59:21.749] Packages needed by future strategies (n = 0): <none>
[17:59:21.750] {
[17:59:21.750]     {
[17:59:21.750]         {
[17:59:21.750]             ...future.startTime <- base::Sys.time()
[17:59:21.750]             {
[17:59:21.750]                 {
[17:59:21.750]                   {
[17:59:21.750]                     {
[17:59:21.750]                       base::local({
[17:59:21.750]                         has_future <- base::requireNamespace("future", 
[17:59:21.750]                           quietly = TRUE)
[17:59:21.750]                         if (has_future) {
[17:59:21.750]                           ns <- base::getNamespace("future")
[17:59:21.750]                           version <- ns[[".package"]][["version"]]
[17:59:21.750]                           if (is.null(version)) 
[17:59:21.750]                             version <- utils::packageVersion("future")
[17:59:21.750]                         }
[17:59:21.750]                         else {
[17:59:21.750]                           version <- NULL
[17:59:21.750]                         }
[17:59:21.750]                         if (!has_future || version < "1.8.0") {
[17:59:21.750]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:21.750]                             "", base::R.version$version.string), 
[17:59:21.750]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:21.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:21.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:21.750]                               "release", "version")], collapse = " "), 
[17:59:21.750]                             hostname = base::Sys.info()[["nodename"]])
[17:59:21.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:21.750]                             info)
[17:59:21.750]                           info <- base::paste(info, collapse = "; ")
[17:59:21.750]                           if (!has_future) {
[17:59:21.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:21.750]                               info)
[17:59:21.750]                           }
[17:59:21.750]                           else {
[17:59:21.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:21.750]                               info, version)
[17:59:21.750]                           }
[17:59:21.750]                           base::stop(msg)
[17:59:21.750]                         }
[17:59:21.750]                       })
[17:59:21.750]                     }
[17:59:21.750]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:21.750]                     base::options(mc.cores = 1L)
[17:59:21.750]                   }
[17:59:21.750]                   ...future.strategy.old <- future::plan("list")
[17:59:21.750]                   options(future.plan = NULL)
[17:59:21.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:21.750]                 }
[17:59:21.750]                 ...future.workdir <- getwd()
[17:59:21.750]             }
[17:59:21.750]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:21.750]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:21.750]         }
[17:59:21.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:21.750]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:21.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:21.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:21.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:21.750]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:21.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:21.750]             base::names(...future.oldOptions))
[17:59:21.750]     }
[17:59:21.750]     if (FALSE) {
[17:59:21.750]     }
[17:59:21.750]     else {
[17:59:21.750]         if (TRUE) {
[17:59:21.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:21.750]                 open = "w")
[17:59:21.750]         }
[17:59:21.750]         else {
[17:59:21.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:21.750]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:21.750]         }
[17:59:21.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:21.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:21.750]             base::sink(type = "output", split = FALSE)
[17:59:21.750]             base::close(...future.stdout)
[17:59:21.750]         }, add = TRUE)
[17:59:21.750]     }
[17:59:21.750]     ...future.frame <- base::sys.nframe()
[17:59:21.750]     ...future.conditions <- base::list()
[17:59:21.750]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:21.750]     if (FALSE) {
[17:59:21.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:21.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:21.750]     }
[17:59:21.750]     ...future.result <- base::tryCatch({
[17:59:21.750]         base::withCallingHandlers({
[17:59:21.750]             ...future.value <- base::withVisible(base::local({
[17:59:21.750]                 ...future.makeSendCondition <- base::local({
[17:59:21.750]                   sendCondition <- NULL
[17:59:21.750]                   function(frame = 1L) {
[17:59:21.750]                     if (is.function(sendCondition)) 
[17:59:21.750]                       return(sendCondition)
[17:59:21.750]                     ns <- getNamespace("parallel")
[17:59:21.750]                     if (exists("sendData", mode = "function", 
[17:59:21.750]                       envir = ns)) {
[17:59:21.750]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:21.750]                         envir = ns)
[17:59:21.750]                       envir <- sys.frame(frame)
[17:59:21.750]                       master <- NULL
[17:59:21.750]                       while (!identical(envir, .GlobalEnv) && 
[17:59:21.750]                         !identical(envir, emptyenv())) {
[17:59:21.750]                         if (exists("master", mode = "list", envir = envir, 
[17:59:21.750]                           inherits = FALSE)) {
[17:59:21.750]                           master <- get("master", mode = "list", 
[17:59:21.750]                             envir = envir, inherits = FALSE)
[17:59:21.750]                           if (inherits(master, c("SOCKnode", 
[17:59:21.750]                             "SOCK0node"))) {
[17:59:21.750]                             sendCondition <<- function(cond) {
[17:59:21.750]                               data <- list(type = "VALUE", value = cond, 
[17:59:21.750]                                 success = TRUE)
[17:59:21.750]                               parallel_sendData(master, data)
[17:59:21.750]                             }
[17:59:21.750]                             return(sendCondition)
[17:59:21.750]                           }
[17:59:21.750]                         }
[17:59:21.750]                         frame <- frame + 1L
[17:59:21.750]                         envir <- sys.frame(frame)
[17:59:21.750]                       }
[17:59:21.750]                     }
[17:59:21.750]                     sendCondition <<- function(cond) NULL
[17:59:21.750]                   }
[17:59:21.750]                 })
[17:59:21.750]                 withCallingHandlers({
[17:59:21.750]                   {
[17:59:21.750]                     do.call(function(...) {
[17:59:21.750]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.750]                       if (!identical(...future.globals.maxSize.org, 
[17:59:21.750]                         ...future.globals.maxSize)) {
[17:59:21.750]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.750]                         on.exit(options(oopts), add = TRUE)
[17:59:21.750]                       }
[17:59:21.750]                       {
[17:59:21.750]                         lapply(seq_along(...future.elements_ii), 
[17:59:21.750]                           FUN = function(jj) {
[17:59:21.750]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.750]                             ...future.FUN(...future.X_jj, ...)
[17:59:21.750]                           })
[17:59:21.750]                       }
[17:59:21.750]                     }, args = future.call.arguments)
[17:59:21.750]                   }
[17:59:21.750]                 }, immediateCondition = function(cond) {
[17:59:21.750]                   sendCondition <- ...future.makeSendCondition()
[17:59:21.750]                   sendCondition(cond)
[17:59:21.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.750]                   {
[17:59:21.750]                     inherits <- base::inherits
[17:59:21.750]                     invokeRestart <- base::invokeRestart
[17:59:21.750]                     is.null <- base::is.null
[17:59:21.750]                     muffled <- FALSE
[17:59:21.750]                     if (inherits(cond, "message")) {
[17:59:21.750]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:21.750]                       if (muffled) 
[17:59:21.750]                         invokeRestart("muffleMessage")
[17:59:21.750]                     }
[17:59:21.750]                     else if (inherits(cond, "warning")) {
[17:59:21.750]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:21.750]                       if (muffled) 
[17:59:21.750]                         invokeRestart("muffleWarning")
[17:59:21.750]                     }
[17:59:21.750]                     else if (inherits(cond, "condition")) {
[17:59:21.750]                       if (!is.null(pattern)) {
[17:59:21.750]                         computeRestarts <- base::computeRestarts
[17:59:21.750]                         grepl <- base::grepl
[17:59:21.750]                         restarts <- computeRestarts(cond)
[17:59:21.750]                         for (restart in restarts) {
[17:59:21.750]                           name <- restart$name
[17:59:21.750]                           if (is.null(name)) 
[17:59:21.750]                             next
[17:59:21.750]                           if (!grepl(pattern, name)) 
[17:59:21.750]                             next
[17:59:21.750]                           invokeRestart(restart)
[17:59:21.750]                           muffled <- TRUE
[17:59:21.750]                           break
[17:59:21.750]                         }
[17:59:21.750]                       }
[17:59:21.750]                     }
[17:59:21.750]                     invisible(muffled)
[17:59:21.750]                   }
[17:59:21.750]                   muffleCondition(cond)
[17:59:21.750]                 })
[17:59:21.750]             }))
[17:59:21.750]             future::FutureResult(value = ...future.value$value, 
[17:59:21.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.750]                   ...future.rng), globalenv = if (FALSE) 
[17:59:21.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:21.750]                     ...future.globalenv.names))
[17:59:21.750]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:21.750]         }, condition = base::local({
[17:59:21.750]             c <- base::c
[17:59:21.750]             inherits <- base::inherits
[17:59:21.750]             invokeRestart <- base::invokeRestart
[17:59:21.750]             length <- base::length
[17:59:21.750]             list <- base::list
[17:59:21.750]             seq.int <- base::seq.int
[17:59:21.750]             signalCondition <- base::signalCondition
[17:59:21.750]             sys.calls <- base::sys.calls
[17:59:21.750]             `[[` <- base::`[[`
[17:59:21.750]             `+` <- base::`+`
[17:59:21.750]             `<<-` <- base::`<<-`
[17:59:21.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:21.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:21.750]                   3L)]
[17:59:21.750]             }
[17:59:21.750]             function(cond) {
[17:59:21.750]                 is_error <- inherits(cond, "error")
[17:59:21.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:21.750]                   NULL)
[17:59:21.750]                 if (is_error) {
[17:59:21.750]                   sessionInformation <- function() {
[17:59:21.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:21.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:21.750]                       search = base::search(), system = base::Sys.info())
[17:59:21.750]                   }
[17:59:21.750]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:21.750]                     cond$call), session = sessionInformation(), 
[17:59:21.750]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:21.750]                   signalCondition(cond)
[17:59:21.750]                 }
[17:59:21.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:21.750]                 "immediateCondition"))) {
[17:59:21.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:21.750]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:21.750]                   if (TRUE && !signal) {
[17:59:21.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.750]                     {
[17:59:21.750]                       inherits <- base::inherits
[17:59:21.750]                       invokeRestart <- base::invokeRestart
[17:59:21.750]                       is.null <- base::is.null
[17:59:21.750]                       muffled <- FALSE
[17:59:21.750]                       if (inherits(cond, "message")) {
[17:59:21.750]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.750]                         if (muffled) 
[17:59:21.750]                           invokeRestart("muffleMessage")
[17:59:21.750]                       }
[17:59:21.750]                       else if (inherits(cond, "warning")) {
[17:59:21.750]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.750]                         if (muffled) 
[17:59:21.750]                           invokeRestart("muffleWarning")
[17:59:21.750]                       }
[17:59:21.750]                       else if (inherits(cond, "condition")) {
[17:59:21.750]                         if (!is.null(pattern)) {
[17:59:21.750]                           computeRestarts <- base::computeRestarts
[17:59:21.750]                           grepl <- base::grepl
[17:59:21.750]                           restarts <- computeRestarts(cond)
[17:59:21.750]                           for (restart in restarts) {
[17:59:21.750]                             name <- restart$name
[17:59:21.750]                             if (is.null(name)) 
[17:59:21.750]                               next
[17:59:21.750]                             if (!grepl(pattern, name)) 
[17:59:21.750]                               next
[17:59:21.750]                             invokeRestart(restart)
[17:59:21.750]                             muffled <- TRUE
[17:59:21.750]                             break
[17:59:21.750]                           }
[17:59:21.750]                         }
[17:59:21.750]                       }
[17:59:21.750]                       invisible(muffled)
[17:59:21.750]                     }
[17:59:21.750]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.750]                   }
[17:59:21.750]                 }
[17:59:21.750]                 else {
[17:59:21.750]                   if (TRUE) {
[17:59:21.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.750]                     {
[17:59:21.750]                       inherits <- base::inherits
[17:59:21.750]                       invokeRestart <- base::invokeRestart
[17:59:21.750]                       is.null <- base::is.null
[17:59:21.750]                       muffled <- FALSE
[17:59:21.750]                       if (inherits(cond, "message")) {
[17:59:21.750]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.750]                         if (muffled) 
[17:59:21.750]                           invokeRestart("muffleMessage")
[17:59:21.750]                       }
[17:59:21.750]                       else if (inherits(cond, "warning")) {
[17:59:21.750]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.750]                         if (muffled) 
[17:59:21.750]                           invokeRestart("muffleWarning")
[17:59:21.750]                       }
[17:59:21.750]                       else if (inherits(cond, "condition")) {
[17:59:21.750]                         if (!is.null(pattern)) {
[17:59:21.750]                           computeRestarts <- base::computeRestarts
[17:59:21.750]                           grepl <- base::grepl
[17:59:21.750]                           restarts <- computeRestarts(cond)
[17:59:21.750]                           for (restart in restarts) {
[17:59:21.750]                             name <- restart$name
[17:59:21.750]                             if (is.null(name)) 
[17:59:21.750]                               next
[17:59:21.750]                             if (!grepl(pattern, name)) 
[17:59:21.750]                               next
[17:59:21.750]                             invokeRestart(restart)
[17:59:21.750]                             muffled <- TRUE
[17:59:21.750]                             break
[17:59:21.750]                           }
[17:59:21.750]                         }
[17:59:21.750]                       }
[17:59:21.750]                       invisible(muffled)
[17:59:21.750]                     }
[17:59:21.750]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.750]                   }
[17:59:21.750]                 }
[17:59:21.750]             }
[17:59:21.750]         }))
[17:59:21.750]     }, error = function(ex) {
[17:59:21.750]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:21.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.750]                 ...future.rng), started = ...future.startTime, 
[17:59:21.750]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:21.750]             version = "1.8"), class = "FutureResult")
[17:59:21.750]     }, finally = {
[17:59:21.750]         if (!identical(...future.workdir, getwd())) 
[17:59:21.750]             setwd(...future.workdir)
[17:59:21.750]         {
[17:59:21.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:21.750]                 ...future.oldOptions$nwarnings <- NULL
[17:59:21.750]             }
[17:59:21.750]             base::options(...future.oldOptions)
[17:59:21.750]             if (.Platform$OS.type == "windows") {
[17:59:21.750]                 old_names <- names(...future.oldEnvVars)
[17:59:21.750]                 envs <- base::Sys.getenv()
[17:59:21.750]                 names <- names(envs)
[17:59:21.750]                 common <- intersect(names, old_names)
[17:59:21.750]                 added <- setdiff(names, old_names)
[17:59:21.750]                 removed <- setdiff(old_names, names)
[17:59:21.750]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:21.750]                   envs[common]]
[17:59:21.750]                 NAMES <- toupper(changed)
[17:59:21.750]                 args <- list()
[17:59:21.750]                 for (kk in seq_along(NAMES)) {
[17:59:21.750]                   name <- changed[[kk]]
[17:59:21.750]                   NAME <- NAMES[[kk]]
[17:59:21.750]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.750]                     next
[17:59:21.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.750]                 }
[17:59:21.750]                 NAMES <- toupper(added)
[17:59:21.750]                 for (kk in seq_along(NAMES)) {
[17:59:21.750]                   name <- added[[kk]]
[17:59:21.750]                   NAME <- NAMES[[kk]]
[17:59:21.750]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.750]                     next
[17:59:21.750]                   args[[name]] <- ""
[17:59:21.750]                 }
[17:59:21.750]                 NAMES <- toupper(removed)
[17:59:21.750]                 for (kk in seq_along(NAMES)) {
[17:59:21.750]                   name <- removed[[kk]]
[17:59:21.750]                   NAME <- NAMES[[kk]]
[17:59:21.750]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.750]                     next
[17:59:21.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.750]                 }
[17:59:21.750]                 if (length(args) > 0) 
[17:59:21.750]                   base::do.call(base::Sys.setenv, args = args)
[17:59:21.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:21.750]             }
[17:59:21.750]             else {
[17:59:21.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:21.750]             }
[17:59:21.750]             {
[17:59:21.750]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:21.750]                   0L) {
[17:59:21.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:21.750]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:21.750]                   base::options(opts)
[17:59:21.750]                 }
[17:59:21.750]                 {
[17:59:21.750]                   {
[17:59:21.750]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:21.750]                     NULL
[17:59:21.750]                   }
[17:59:21.750]                   options(future.plan = NULL)
[17:59:21.750]                   if (is.na(NA_character_)) 
[17:59:21.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:21.750]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:21.750]                     .init = FALSE)
[17:59:21.750]                 }
[17:59:21.750]             }
[17:59:21.750]         }
[17:59:21.750]     })
[17:59:21.750]     if (TRUE) {
[17:59:21.750]         base::sink(type = "output", split = FALSE)
[17:59:21.750]         if (TRUE) {
[17:59:21.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:21.750]         }
[17:59:21.750]         else {
[17:59:21.750]             ...future.result["stdout"] <- base::list(NULL)
[17:59:21.750]         }
[17:59:21.750]         base::close(...future.stdout)
[17:59:21.750]         ...future.stdout <- NULL
[17:59:21.750]     }
[17:59:21.750]     ...future.result$conditions <- ...future.conditions
[17:59:21.750]     ...future.result$finished <- base::Sys.time()
[17:59:21.750]     ...future.result
[17:59:21.750] }
[17:59:21.756] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:59:21.757] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:21.757] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:21.758] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:59:21.759] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:59:21.759] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[17:59:21.760] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[17:59:21.761] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:21.762] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:21.762] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:59:21.763] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:59:21.763] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:59:21.764] MultisessionFuture started
[17:59:21.764] - Launch lazy future ... done
[17:59:21.764] run() for ‘MultisessionFuture’ ... done
[17:59:21.765] Created future:
[17:59:21.765] MultisessionFuture:
[17:59:21.765] Label: ‘future_apply-2’
[17:59:21.765] Expression:
[17:59:21.765] {
[17:59:21.765]     do.call(function(...) {
[17:59:21.765]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.765]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.765]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.765]             on.exit(options(oopts), add = TRUE)
[17:59:21.765]         }
[17:59:21.765]         {
[17:59:21.765]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.765]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.765]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.765]             })
[17:59:21.765]         }
[17:59:21.765]     }, args = future.call.arguments)
[17:59:21.765] }
[17:59:21.765] Lazy evaluation: FALSE
[17:59:21.765] Asynchronous evaluation: TRUE
[17:59:21.765] Local evaluation: TRUE
[17:59:21.765] Environment: R_GlobalEnv
[17:59:21.765] Capture standard output: TRUE
[17:59:21.765] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:21.765] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:21.765] Packages: <none>
[17:59:21.765] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:21.765] Resolved: FALSE
[17:59:21.765] Value: <not collected>
[17:59:21.765] Conditions captured: <none>
[17:59:21.765] Early signaling: FALSE
[17:59:21.765] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:21.765] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.779] Chunk #2 of 2 ... DONE
[17:59:21.779] Launching 2 futures (chunks) ... DONE
[17:59:21.779] Resolving 2 futures (chunks) ...
[17:59:21.780] resolve() on list ...
[17:59:21.780]  recursive: 0
[17:59:21.780]  length: 2
[17:59:21.780] 
[17:59:21.781] receiveMessageFromWorker() for ClusterFuture ...
[17:59:21.782] - Validating connection of MultisessionFuture
[17:59:21.782] - received message: FutureResult
[17:59:21.782] - Received FutureResult
[17:59:21.782] - Erased future from FutureRegistry
[17:59:21.783] result() for ClusterFuture ...
[17:59:21.783] - result already collected: FutureResult
[17:59:21.783] result() for ClusterFuture ... done
[17:59:21.783] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:21.783] Future #1
[17:59:21.784] result() for ClusterFuture ...
[17:59:21.784] - result already collected: FutureResult
[17:59:21.784] result() for ClusterFuture ... done
[17:59:21.784] result() for ClusterFuture ...
[17:59:21.784] - result already collected: FutureResult
[17:59:21.784] result() for ClusterFuture ... done
[17:59:21.785] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:21.785] - nx: 2
[17:59:21.785] - relay: TRUE
[17:59:21.785] - stdout: TRUE
[17:59:21.785] - signal: TRUE
[17:59:21.786] - resignal: FALSE
[17:59:21.786] - force: TRUE
[17:59:21.786] - relayed: [n=2] FALSE, FALSE
[17:59:21.786] - queued futures: [n=2] FALSE, FALSE
[17:59:21.786]  - until=1
[17:59:21.786]  - relaying element #1
[17:59:21.787] result() for ClusterFuture ...
[17:59:21.787] - result already collected: FutureResult
[17:59:21.787] result() for ClusterFuture ... done
[17:59:21.787] result() for ClusterFuture ...
[17:59:21.787] - result already collected: FutureResult
[17:59:21.788] result() for ClusterFuture ... done
[17:59:21.788] result() for ClusterFuture ...
[17:59:21.788] - result already collected: FutureResult
[17:59:21.788] result() for ClusterFuture ... done
[17:59:21.788] result() for ClusterFuture ...
[17:59:21.789] - result already collected: FutureResult
[17:59:21.789] result() for ClusterFuture ... done
[17:59:21.789] - relayed: [n=2] TRUE, FALSE
[17:59:21.789] - queued futures: [n=2] TRUE, FALSE
[17:59:21.789] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:21.789]  length: 1 (resolved future 1)
[17:59:21.812] receiveMessageFromWorker() for ClusterFuture ...
[17:59:21.812] - Validating connection of MultisessionFuture
[17:59:21.812] - received message: FutureResult
[17:59:21.813] - Received FutureResult
[17:59:21.813] - Erased future from FutureRegistry
[17:59:21.813] result() for ClusterFuture ...
[17:59:21.813] - result already collected: FutureResult
[17:59:21.814] result() for ClusterFuture ... done
[17:59:21.814] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:21.814] Future #2
[17:59:21.814] result() for ClusterFuture ...
[17:59:21.815] - result already collected: FutureResult
[17:59:21.815] result() for ClusterFuture ... done
[17:59:21.815] result() for ClusterFuture ...
[17:59:21.815] - result already collected: FutureResult
[17:59:21.815] result() for ClusterFuture ... done
[17:59:21.816] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:21.816] - nx: 2
[17:59:21.816] - relay: TRUE
[17:59:21.816] - stdout: TRUE
[17:59:21.816] - signal: TRUE
[17:59:21.816] - resignal: FALSE
[17:59:21.817] - force: TRUE
[17:59:21.817] - relayed: [n=2] TRUE, FALSE
[17:59:21.817] - queued futures: [n=2] TRUE, FALSE
[17:59:21.817]  - until=2
[17:59:21.817]  - relaying element #2
[17:59:21.817] result() for ClusterFuture ...
[17:59:21.818] - result already collected: FutureResult
[17:59:21.818] result() for ClusterFuture ... done
[17:59:21.818] result() for ClusterFuture ...
[17:59:21.818] - result already collected: FutureResult
[17:59:21.818] result() for ClusterFuture ... done
[17:59:21.819] result() for ClusterFuture ...
[17:59:21.819] - result already collected: FutureResult
[17:59:21.819] result() for ClusterFuture ... done
[17:59:21.819] result() for ClusterFuture ...
[17:59:21.819] - result already collected: FutureResult
[17:59:21.820] result() for ClusterFuture ... done
[17:59:21.820] - relayed: [n=2] TRUE, TRUE
[17:59:21.820] - queued futures: [n=2] TRUE, TRUE
[17:59:21.820] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:21.820]  length: 0 (resolved future 2)
[17:59:21.820] Relaying remaining futures
[17:59:21.821] signalConditionsASAP(NULL, pos=0) ...
[17:59:21.821] - nx: 2
[17:59:21.821] - relay: TRUE
[17:59:21.821] - stdout: TRUE
[17:59:21.821] - signal: TRUE
[17:59:21.821] - resignal: FALSE
[17:59:21.822] - force: TRUE
[17:59:21.822] - relayed: [n=2] TRUE, TRUE
[17:59:21.822] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:21.822] - relayed: [n=2] TRUE, TRUE
[17:59:21.822] - queued futures: [n=2] TRUE, TRUE
[17:59:21.823] signalConditionsASAP(NULL, pos=0) ... done
[17:59:21.823] resolve() on list ... DONE
[17:59:21.823] result() for ClusterFuture ...
[17:59:21.823] - result already collected: FutureResult
[17:59:21.823] result() for ClusterFuture ... done
[17:59:21.824] result() for ClusterFuture ...
[17:59:21.824] - result already collected: FutureResult
[17:59:21.824] result() for ClusterFuture ... done
[17:59:21.824] result() for ClusterFuture ...
[17:59:21.824] - result already collected: FutureResult
[17:59:21.824] result() for ClusterFuture ... done
[17:59:21.825] result() for ClusterFuture ...
[17:59:21.825] - result already collected: FutureResult
[17:59:21.825] result() for ClusterFuture ... done
[17:59:21.825]  - Number of value chunks collected: 2
[17:59:21.825] Resolving 2 futures (chunks) ... DONE
[17:59:21.826] Reducing values from 2 chunks ...
[17:59:21.826]  - Number of values collected after concatenation: 6
[17:59:21.826]  - Number of values expected: 6
[17:59:21.826] Reducing values from 2 chunks ... DONE
[17:59:21.827] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:59:21.828] getGlobalsAndPackagesXApply() ...
[17:59:21.828]  - future.globals: TRUE
[17:59:21.828] getGlobalsAndPackages() ...
[17:59:21.828] Searching for globals...
[17:59:21.830] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:59:21.831] Searching for globals ... DONE
[17:59:21.831] Resolving globals: FALSE
[17:59:21.832] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:59:21.832] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:59:21.833] - globals: [1] ‘FUN’
[17:59:21.833] 
[17:59:21.833] getGlobalsAndPackages() ... DONE
[17:59:21.833]  - globals found/used: [n=1] ‘FUN’
[17:59:21.833]  - needed namespaces: [n=0] 
[17:59:21.834] Finding globals ... DONE
[17:59:21.834]  - use_args: TRUE
[17:59:21.834]  - Getting '...' globals ...
[17:59:21.835] resolve() on list ...
[17:59:21.835]  recursive: 0
[17:59:21.835]  length: 1
[17:59:21.835]  elements: ‘...’
[17:59:21.835]  length: 0 (resolved future 1)
[17:59:21.836] resolve() on list ... DONE
[17:59:21.836]    - '...' content: [n=0] 
[17:59:21.836] List of 1
[17:59:21.836]  $ ...: list()
[17:59:21.836]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.836]  - attr(*, "where")=List of 1
[17:59:21.836]   ..$ ...:<environment: 0x560859e6ac68> 
[17:59:21.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.836]  - attr(*, "resolved")= logi TRUE
[17:59:21.836]  - attr(*, "total_size")= num NA
[17:59:21.841]  - Getting '...' globals ... DONE
[17:59:21.841] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:21.841] List of 2
[17:59:21.841]  $ ...future.FUN:function (x)  
[17:59:21.841]  $ ...          : list()
[17:59:21.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.841]  - attr(*, "where")=List of 2
[17:59:21.841]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:21.841]   ..$ ...          :<environment: 0x560859e6ac68> 
[17:59:21.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.841]  - attr(*, "resolved")= logi FALSE
[17:59:21.841]  - attr(*, "total_size")= num 1768
[17:59:21.847] Packages to be attached in all futures: [n=0] 
[17:59:21.847] getGlobalsAndPackagesXApply() ... DONE
[17:59:21.853] future_lapply() ...
[17:59:21.860] Number of chunks: 2
[17:59:21.860] getGlobalsAndPackagesXApply() ...
[17:59:21.860]  - future.globals: <name-value list> with names ‘list()’
[17:59:21.860]  - use_args: TRUE
[17:59:21.861] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:21.861] List of 2
[17:59:21.861]  $ ...          : list()
[17:59:21.861]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:21.861]  $ ...future.FUN:function (x)  
[17:59:21.861]  - attr(*, "where")=List of 2
[17:59:21.861]   ..$ ...          :<environment: 0x560859e6ac68> 
[17:59:21.861]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:59:21.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:21.861]  - attr(*, "resolved")= logi FALSE
[17:59:21.861]  - attr(*, "total_size")= num NA
[17:59:21.866] Packages to be attached in all futures: [n=0] 
[17:59:21.867] getGlobalsAndPackagesXApply() ... DONE
[17:59:21.867] Number of futures (= number of chunks): 2
[17:59:21.867] Launching 2 futures (chunks) ...
[17:59:21.867] Chunk #1 of 2 ...
[17:59:21.868]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:21.868]  - seeds: <none>
[17:59:21.868]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.868] getGlobalsAndPackages() ...
[17:59:21.868] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.869] Resolving globals: FALSE
[17:59:21.869] Tweak future expression to call with '...' arguments ...
[17:59:21.869] {
[17:59:21.869]     do.call(function(...) {
[17:59:21.869]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.869]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.869]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.869]             on.exit(options(oopts), add = TRUE)
[17:59:21.869]         }
[17:59:21.869]         {
[17:59:21.869]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.869]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.869]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.869]             })
[17:59:21.869]         }
[17:59:21.869]     }, args = future.call.arguments)
[17:59:21.869] }
[17:59:21.870] Tweak future expression to call with '...' arguments ... DONE
[17:59:21.870] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.871] 
[17:59:21.871] getGlobalsAndPackages() ... DONE
[17:59:21.871] run() for ‘Future’ ...
[17:59:21.872] - state: ‘created’
[17:59:21.872] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:21.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:21.896]   - Field: ‘node’
[17:59:21.896]   - Field: ‘label’
[17:59:21.897]   - Field: ‘local’
[17:59:21.897]   - Field: ‘owner’
[17:59:21.897]   - Field: ‘envir’
[17:59:21.897]   - Field: ‘workers’
[17:59:21.898]   - Field: ‘packages’
[17:59:21.898]   - Field: ‘gc’
[17:59:21.898]   - Field: ‘conditions’
[17:59:21.898]   - Field: ‘persistent’
[17:59:21.898]   - Field: ‘expr’
[17:59:21.899]   - Field: ‘uuid’
[17:59:21.899]   - Field: ‘seed’
[17:59:21.899]   - Field: ‘version’
[17:59:21.899]   - Field: ‘result’
[17:59:21.899]   - Field: ‘asynchronous’
[17:59:21.899]   - Field: ‘calls’
[17:59:21.900]   - Field: ‘globals’
[17:59:21.900]   - Field: ‘stdout’
[17:59:21.900]   - Field: ‘earlySignal’
[17:59:21.900]   - Field: ‘lazy’
[17:59:21.900]   - Field: ‘state’
[17:59:21.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:21.901] - Launch lazy future ...
[17:59:21.901] Packages needed by the future expression (n = 0): <none>
[17:59:21.902] Packages needed by future strategies (n = 0): <none>
[17:59:21.902] {
[17:59:21.902]     {
[17:59:21.902]         {
[17:59:21.902]             ...future.startTime <- base::Sys.time()
[17:59:21.902]             {
[17:59:21.902]                 {
[17:59:21.902]                   {
[17:59:21.902]                     {
[17:59:21.902]                       base::local({
[17:59:21.902]                         has_future <- base::requireNamespace("future", 
[17:59:21.902]                           quietly = TRUE)
[17:59:21.902]                         if (has_future) {
[17:59:21.902]                           ns <- base::getNamespace("future")
[17:59:21.902]                           version <- ns[[".package"]][["version"]]
[17:59:21.902]                           if (is.null(version)) 
[17:59:21.902]                             version <- utils::packageVersion("future")
[17:59:21.902]                         }
[17:59:21.902]                         else {
[17:59:21.902]                           version <- NULL
[17:59:21.902]                         }
[17:59:21.902]                         if (!has_future || version < "1.8.0") {
[17:59:21.902]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:21.902]                             "", base::R.version$version.string), 
[17:59:21.902]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:21.902]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:21.902]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:21.902]                               "release", "version")], collapse = " "), 
[17:59:21.902]                             hostname = base::Sys.info()[["nodename"]])
[17:59:21.902]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:21.902]                             info)
[17:59:21.902]                           info <- base::paste(info, collapse = "; ")
[17:59:21.902]                           if (!has_future) {
[17:59:21.902]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:21.902]                               info)
[17:59:21.902]                           }
[17:59:21.902]                           else {
[17:59:21.902]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:21.902]                               info, version)
[17:59:21.902]                           }
[17:59:21.902]                           base::stop(msg)
[17:59:21.902]                         }
[17:59:21.902]                       })
[17:59:21.902]                     }
[17:59:21.902]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:21.902]                     base::options(mc.cores = 1L)
[17:59:21.902]                   }
[17:59:21.902]                   ...future.strategy.old <- future::plan("list")
[17:59:21.902]                   options(future.plan = NULL)
[17:59:21.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:21.902]                 }
[17:59:21.902]                 ...future.workdir <- getwd()
[17:59:21.902]             }
[17:59:21.902]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:21.902]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:21.902]         }
[17:59:21.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:21.902]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:21.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:21.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:21.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:21.902]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:21.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:21.902]             base::names(...future.oldOptions))
[17:59:21.902]     }
[17:59:21.902]     if (FALSE) {
[17:59:21.902]     }
[17:59:21.902]     else {
[17:59:21.902]         if (TRUE) {
[17:59:21.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:21.902]                 open = "w")
[17:59:21.902]         }
[17:59:21.902]         else {
[17:59:21.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:21.902]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:21.902]         }
[17:59:21.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:21.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:21.902]             base::sink(type = "output", split = FALSE)
[17:59:21.902]             base::close(...future.stdout)
[17:59:21.902]         }, add = TRUE)
[17:59:21.902]     }
[17:59:21.902]     ...future.frame <- base::sys.nframe()
[17:59:21.902]     ...future.conditions <- base::list()
[17:59:21.902]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:21.902]     if (FALSE) {
[17:59:21.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:21.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:21.902]     }
[17:59:21.902]     ...future.result <- base::tryCatch({
[17:59:21.902]         base::withCallingHandlers({
[17:59:21.902]             ...future.value <- base::withVisible(base::local({
[17:59:21.902]                 ...future.makeSendCondition <- base::local({
[17:59:21.902]                   sendCondition <- NULL
[17:59:21.902]                   function(frame = 1L) {
[17:59:21.902]                     if (is.function(sendCondition)) 
[17:59:21.902]                       return(sendCondition)
[17:59:21.902]                     ns <- getNamespace("parallel")
[17:59:21.902]                     if (exists("sendData", mode = "function", 
[17:59:21.902]                       envir = ns)) {
[17:59:21.902]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:21.902]                         envir = ns)
[17:59:21.902]                       envir <- sys.frame(frame)
[17:59:21.902]                       master <- NULL
[17:59:21.902]                       while (!identical(envir, .GlobalEnv) && 
[17:59:21.902]                         !identical(envir, emptyenv())) {
[17:59:21.902]                         if (exists("master", mode = "list", envir = envir, 
[17:59:21.902]                           inherits = FALSE)) {
[17:59:21.902]                           master <- get("master", mode = "list", 
[17:59:21.902]                             envir = envir, inherits = FALSE)
[17:59:21.902]                           if (inherits(master, c("SOCKnode", 
[17:59:21.902]                             "SOCK0node"))) {
[17:59:21.902]                             sendCondition <<- function(cond) {
[17:59:21.902]                               data <- list(type = "VALUE", value = cond, 
[17:59:21.902]                                 success = TRUE)
[17:59:21.902]                               parallel_sendData(master, data)
[17:59:21.902]                             }
[17:59:21.902]                             return(sendCondition)
[17:59:21.902]                           }
[17:59:21.902]                         }
[17:59:21.902]                         frame <- frame + 1L
[17:59:21.902]                         envir <- sys.frame(frame)
[17:59:21.902]                       }
[17:59:21.902]                     }
[17:59:21.902]                     sendCondition <<- function(cond) NULL
[17:59:21.902]                   }
[17:59:21.902]                 })
[17:59:21.902]                 withCallingHandlers({
[17:59:21.902]                   {
[17:59:21.902]                     do.call(function(...) {
[17:59:21.902]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.902]                       if (!identical(...future.globals.maxSize.org, 
[17:59:21.902]                         ...future.globals.maxSize)) {
[17:59:21.902]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.902]                         on.exit(options(oopts), add = TRUE)
[17:59:21.902]                       }
[17:59:21.902]                       {
[17:59:21.902]                         lapply(seq_along(...future.elements_ii), 
[17:59:21.902]                           FUN = function(jj) {
[17:59:21.902]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.902]                             ...future.FUN(...future.X_jj, ...)
[17:59:21.902]                           })
[17:59:21.902]                       }
[17:59:21.902]                     }, args = future.call.arguments)
[17:59:21.902]                   }
[17:59:21.902]                 }, immediateCondition = function(cond) {
[17:59:21.902]                   sendCondition <- ...future.makeSendCondition()
[17:59:21.902]                   sendCondition(cond)
[17:59:21.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.902]                   {
[17:59:21.902]                     inherits <- base::inherits
[17:59:21.902]                     invokeRestart <- base::invokeRestart
[17:59:21.902]                     is.null <- base::is.null
[17:59:21.902]                     muffled <- FALSE
[17:59:21.902]                     if (inherits(cond, "message")) {
[17:59:21.902]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:21.902]                       if (muffled) 
[17:59:21.902]                         invokeRestart("muffleMessage")
[17:59:21.902]                     }
[17:59:21.902]                     else if (inherits(cond, "warning")) {
[17:59:21.902]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:21.902]                       if (muffled) 
[17:59:21.902]                         invokeRestart("muffleWarning")
[17:59:21.902]                     }
[17:59:21.902]                     else if (inherits(cond, "condition")) {
[17:59:21.902]                       if (!is.null(pattern)) {
[17:59:21.902]                         computeRestarts <- base::computeRestarts
[17:59:21.902]                         grepl <- base::grepl
[17:59:21.902]                         restarts <- computeRestarts(cond)
[17:59:21.902]                         for (restart in restarts) {
[17:59:21.902]                           name <- restart$name
[17:59:21.902]                           if (is.null(name)) 
[17:59:21.902]                             next
[17:59:21.902]                           if (!grepl(pattern, name)) 
[17:59:21.902]                             next
[17:59:21.902]                           invokeRestart(restart)
[17:59:21.902]                           muffled <- TRUE
[17:59:21.902]                           break
[17:59:21.902]                         }
[17:59:21.902]                       }
[17:59:21.902]                     }
[17:59:21.902]                     invisible(muffled)
[17:59:21.902]                   }
[17:59:21.902]                   muffleCondition(cond)
[17:59:21.902]                 })
[17:59:21.902]             }))
[17:59:21.902]             future::FutureResult(value = ...future.value$value, 
[17:59:21.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.902]                   ...future.rng), globalenv = if (FALSE) 
[17:59:21.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:21.902]                     ...future.globalenv.names))
[17:59:21.902]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:21.902]         }, condition = base::local({
[17:59:21.902]             c <- base::c
[17:59:21.902]             inherits <- base::inherits
[17:59:21.902]             invokeRestart <- base::invokeRestart
[17:59:21.902]             length <- base::length
[17:59:21.902]             list <- base::list
[17:59:21.902]             seq.int <- base::seq.int
[17:59:21.902]             signalCondition <- base::signalCondition
[17:59:21.902]             sys.calls <- base::sys.calls
[17:59:21.902]             `[[` <- base::`[[`
[17:59:21.902]             `+` <- base::`+`
[17:59:21.902]             `<<-` <- base::`<<-`
[17:59:21.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:21.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:21.902]                   3L)]
[17:59:21.902]             }
[17:59:21.902]             function(cond) {
[17:59:21.902]                 is_error <- inherits(cond, "error")
[17:59:21.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:21.902]                   NULL)
[17:59:21.902]                 if (is_error) {
[17:59:21.902]                   sessionInformation <- function() {
[17:59:21.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:21.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:21.902]                       search = base::search(), system = base::Sys.info())
[17:59:21.902]                   }
[17:59:21.902]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:21.902]                     cond$call), session = sessionInformation(), 
[17:59:21.902]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:21.902]                   signalCondition(cond)
[17:59:21.902]                 }
[17:59:21.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:21.902]                 "immediateCondition"))) {
[17:59:21.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:21.902]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:21.902]                   if (TRUE && !signal) {
[17:59:21.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.902]                     {
[17:59:21.902]                       inherits <- base::inherits
[17:59:21.902]                       invokeRestart <- base::invokeRestart
[17:59:21.902]                       is.null <- base::is.null
[17:59:21.902]                       muffled <- FALSE
[17:59:21.902]                       if (inherits(cond, "message")) {
[17:59:21.902]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.902]                         if (muffled) 
[17:59:21.902]                           invokeRestart("muffleMessage")
[17:59:21.902]                       }
[17:59:21.902]                       else if (inherits(cond, "warning")) {
[17:59:21.902]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.902]                         if (muffled) 
[17:59:21.902]                           invokeRestart("muffleWarning")
[17:59:21.902]                       }
[17:59:21.902]                       else if (inherits(cond, "condition")) {
[17:59:21.902]                         if (!is.null(pattern)) {
[17:59:21.902]                           computeRestarts <- base::computeRestarts
[17:59:21.902]                           grepl <- base::grepl
[17:59:21.902]                           restarts <- computeRestarts(cond)
[17:59:21.902]                           for (restart in restarts) {
[17:59:21.902]                             name <- restart$name
[17:59:21.902]                             if (is.null(name)) 
[17:59:21.902]                               next
[17:59:21.902]                             if (!grepl(pattern, name)) 
[17:59:21.902]                               next
[17:59:21.902]                             invokeRestart(restart)
[17:59:21.902]                             muffled <- TRUE
[17:59:21.902]                             break
[17:59:21.902]                           }
[17:59:21.902]                         }
[17:59:21.902]                       }
[17:59:21.902]                       invisible(muffled)
[17:59:21.902]                     }
[17:59:21.902]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.902]                   }
[17:59:21.902]                 }
[17:59:21.902]                 else {
[17:59:21.902]                   if (TRUE) {
[17:59:21.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.902]                     {
[17:59:21.902]                       inherits <- base::inherits
[17:59:21.902]                       invokeRestart <- base::invokeRestart
[17:59:21.902]                       is.null <- base::is.null
[17:59:21.902]                       muffled <- FALSE
[17:59:21.902]                       if (inherits(cond, "message")) {
[17:59:21.902]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.902]                         if (muffled) 
[17:59:21.902]                           invokeRestart("muffleMessage")
[17:59:21.902]                       }
[17:59:21.902]                       else if (inherits(cond, "warning")) {
[17:59:21.902]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.902]                         if (muffled) 
[17:59:21.902]                           invokeRestart("muffleWarning")
[17:59:21.902]                       }
[17:59:21.902]                       else if (inherits(cond, "condition")) {
[17:59:21.902]                         if (!is.null(pattern)) {
[17:59:21.902]                           computeRestarts <- base::computeRestarts
[17:59:21.902]                           grepl <- base::grepl
[17:59:21.902]                           restarts <- computeRestarts(cond)
[17:59:21.902]                           for (restart in restarts) {
[17:59:21.902]                             name <- restart$name
[17:59:21.902]                             if (is.null(name)) 
[17:59:21.902]                               next
[17:59:21.902]                             if (!grepl(pattern, name)) 
[17:59:21.902]                               next
[17:59:21.902]                             invokeRestart(restart)
[17:59:21.902]                             muffled <- TRUE
[17:59:21.902]                             break
[17:59:21.902]                           }
[17:59:21.902]                         }
[17:59:21.902]                       }
[17:59:21.902]                       invisible(muffled)
[17:59:21.902]                     }
[17:59:21.902]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.902]                   }
[17:59:21.902]                 }
[17:59:21.902]             }
[17:59:21.902]         }))
[17:59:21.902]     }, error = function(ex) {
[17:59:21.902]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:21.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.902]                 ...future.rng), started = ...future.startTime, 
[17:59:21.902]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:21.902]             version = "1.8"), class = "FutureResult")
[17:59:21.902]     }, finally = {
[17:59:21.902]         if (!identical(...future.workdir, getwd())) 
[17:59:21.902]             setwd(...future.workdir)
[17:59:21.902]         {
[17:59:21.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:21.902]                 ...future.oldOptions$nwarnings <- NULL
[17:59:21.902]             }
[17:59:21.902]             base::options(...future.oldOptions)
[17:59:21.902]             if (.Platform$OS.type == "windows") {
[17:59:21.902]                 old_names <- names(...future.oldEnvVars)
[17:59:21.902]                 envs <- base::Sys.getenv()
[17:59:21.902]                 names <- names(envs)
[17:59:21.902]                 common <- intersect(names, old_names)
[17:59:21.902]                 added <- setdiff(names, old_names)
[17:59:21.902]                 removed <- setdiff(old_names, names)
[17:59:21.902]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:21.902]                   envs[common]]
[17:59:21.902]                 NAMES <- toupper(changed)
[17:59:21.902]                 args <- list()
[17:59:21.902]                 for (kk in seq_along(NAMES)) {
[17:59:21.902]                   name <- changed[[kk]]
[17:59:21.902]                   NAME <- NAMES[[kk]]
[17:59:21.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.902]                     next
[17:59:21.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.902]                 }
[17:59:21.902]                 NAMES <- toupper(added)
[17:59:21.902]                 for (kk in seq_along(NAMES)) {
[17:59:21.902]                   name <- added[[kk]]
[17:59:21.902]                   NAME <- NAMES[[kk]]
[17:59:21.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.902]                     next
[17:59:21.902]                   args[[name]] <- ""
[17:59:21.902]                 }
[17:59:21.902]                 NAMES <- toupper(removed)
[17:59:21.902]                 for (kk in seq_along(NAMES)) {
[17:59:21.902]                   name <- removed[[kk]]
[17:59:21.902]                   NAME <- NAMES[[kk]]
[17:59:21.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.902]                     next
[17:59:21.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.902]                 }
[17:59:21.902]                 if (length(args) > 0) 
[17:59:21.902]                   base::do.call(base::Sys.setenv, args = args)
[17:59:21.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:21.902]             }
[17:59:21.902]             else {
[17:59:21.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:21.902]             }
[17:59:21.902]             {
[17:59:21.902]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:21.902]                   0L) {
[17:59:21.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:21.902]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:21.902]                   base::options(opts)
[17:59:21.902]                 }
[17:59:21.902]                 {
[17:59:21.902]                   {
[17:59:21.902]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:21.902]                     NULL
[17:59:21.902]                   }
[17:59:21.902]                   options(future.plan = NULL)
[17:59:21.902]                   if (is.na(NA_character_)) 
[17:59:21.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:21.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:21.902]                     .init = FALSE)
[17:59:21.902]                 }
[17:59:21.902]             }
[17:59:21.902]         }
[17:59:21.902]     })
[17:59:21.902]     if (TRUE) {
[17:59:21.902]         base::sink(type = "output", split = FALSE)
[17:59:21.902]         if (TRUE) {
[17:59:21.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:21.902]         }
[17:59:21.902]         else {
[17:59:21.902]             ...future.result["stdout"] <- base::list(NULL)
[17:59:21.902]         }
[17:59:21.902]         base::close(...future.stdout)
[17:59:21.902]         ...future.stdout <- NULL
[17:59:21.902]     }
[17:59:21.902]     ...future.result$conditions <- ...future.conditions
[17:59:21.902]     ...future.result$finished <- base::Sys.time()
[17:59:21.902]     ...future.result
[17:59:21.902] }
[17:59:21.908] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[17:59:21.909] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:21.909] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:21.910] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[17:59:21.911] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[17:59:21.911] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[17:59:21.912] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[17:59:21.912] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:21.913] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:21.913] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:59:21.914] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:59:21.914] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[17:59:21.915] MultisessionFuture started
[17:59:21.915] - Launch lazy future ... done
[17:59:21.915] run() for ‘MultisessionFuture’ ... done
[17:59:21.916] Created future:
[17:59:21.916] MultisessionFuture:
[17:59:21.916] Label: ‘future_apply-1’
[17:59:21.916] Expression:
[17:59:21.916] {
[17:59:21.916]     do.call(function(...) {
[17:59:21.916]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.916]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.916]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.916]             on.exit(options(oopts), add = TRUE)
[17:59:21.916]         }
[17:59:21.916]         {
[17:59:21.916]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.916]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.916]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.916]             })
[17:59:21.916]         }
[17:59:21.916]     }, args = future.call.arguments)
[17:59:21.916] }
[17:59:21.916] Lazy evaluation: FALSE
[17:59:21.916] Asynchronous evaluation: TRUE
[17:59:21.916] Local evaluation: TRUE
[17:59:21.916] Environment: R_GlobalEnv
[17:59:21.916] Capture standard output: TRUE
[17:59:21.916] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:21.916] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:21.916] Packages: <none>
[17:59:21.916] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:21.916] Resolved: FALSE
[17:59:21.916] Value: <not collected>
[17:59:21.916] Conditions captured: <none>
[17:59:21.916] Early signaling: FALSE
[17:59:21.916] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:21.916] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.929] Chunk #1 of 2 ... DONE
[17:59:21.929] Chunk #2 of 2 ...
[17:59:21.929]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:21.929]  - seeds: <none>
[17:59:21.930]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.930] getGlobalsAndPackages() ...
[17:59:21.930] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.930] Resolving globals: FALSE
[17:59:21.931] Tweak future expression to call with '...' arguments ...
[17:59:21.931] {
[17:59:21.931]     do.call(function(...) {
[17:59:21.931]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.931]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.931]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.931]             on.exit(options(oopts), add = TRUE)
[17:59:21.931]         }
[17:59:21.931]         {
[17:59:21.931]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.931]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.931]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.931]             })
[17:59:21.931]         }
[17:59:21.931]     }, args = future.call.arguments)
[17:59:21.931] }
[17:59:21.931] Tweak future expression to call with '...' arguments ... DONE
[17:59:21.932] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:21.932] 
[17:59:21.932] getGlobalsAndPackages() ... DONE
[17:59:21.933] run() for ‘Future’ ...
[17:59:21.933] - state: ‘created’
[17:59:21.933] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:21.958] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.958] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:21.959]   - Field: ‘node’
[17:59:21.959]   - Field: ‘label’
[17:59:21.959]   - Field: ‘local’
[17:59:21.959]   - Field: ‘owner’
[17:59:21.959]   - Field: ‘envir’
[17:59:21.960]   - Field: ‘workers’
[17:59:21.960]   - Field: ‘packages’
[17:59:21.960]   - Field: ‘gc’
[17:59:21.960]   - Field: ‘conditions’
[17:59:21.960]   - Field: ‘persistent’
[17:59:21.961]   - Field: ‘expr’
[17:59:21.961]   - Field: ‘uuid’
[17:59:21.961]   - Field: ‘seed’
[17:59:21.961]   - Field: ‘version’
[17:59:21.961]   - Field: ‘result’
[17:59:21.962]   - Field: ‘asynchronous’
[17:59:21.962]   - Field: ‘calls’
[17:59:21.962]   - Field: ‘globals’
[17:59:21.962]   - Field: ‘stdout’
[17:59:21.962]   - Field: ‘earlySignal’
[17:59:21.963]   - Field: ‘lazy’
[17:59:21.963]   - Field: ‘state’
[17:59:21.963] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:21.963] - Launch lazy future ...
[17:59:21.964] Packages needed by the future expression (n = 0): <none>
[17:59:21.964] Packages needed by future strategies (n = 0): <none>
[17:59:21.965] {
[17:59:21.965]     {
[17:59:21.965]         {
[17:59:21.965]             ...future.startTime <- base::Sys.time()
[17:59:21.965]             {
[17:59:21.965]                 {
[17:59:21.965]                   {
[17:59:21.965]                     {
[17:59:21.965]                       base::local({
[17:59:21.965]                         has_future <- base::requireNamespace("future", 
[17:59:21.965]                           quietly = TRUE)
[17:59:21.965]                         if (has_future) {
[17:59:21.965]                           ns <- base::getNamespace("future")
[17:59:21.965]                           version <- ns[[".package"]][["version"]]
[17:59:21.965]                           if (is.null(version)) 
[17:59:21.965]                             version <- utils::packageVersion("future")
[17:59:21.965]                         }
[17:59:21.965]                         else {
[17:59:21.965]                           version <- NULL
[17:59:21.965]                         }
[17:59:21.965]                         if (!has_future || version < "1.8.0") {
[17:59:21.965]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:21.965]                             "", base::R.version$version.string), 
[17:59:21.965]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:21.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:21.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:21.965]                               "release", "version")], collapse = " "), 
[17:59:21.965]                             hostname = base::Sys.info()[["nodename"]])
[17:59:21.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:21.965]                             info)
[17:59:21.965]                           info <- base::paste(info, collapse = "; ")
[17:59:21.965]                           if (!has_future) {
[17:59:21.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:21.965]                               info)
[17:59:21.965]                           }
[17:59:21.965]                           else {
[17:59:21.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:21.965]                               info, version)
[17:59:21.965]                           }
[17:59:21.965]                           base::stop(msg)
[17:59:21.965]                         }
[17:59:21.965]                       })
[17:59:21.965]                     }
[17:59:21.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:21.965]                     base::options(mc.cores = 1L)
[17:59:21.965]                   }
[17:59:21.965]                   ...future.strategy.old <- future::plan("list")
[17:59:21.965]                   options(future.plan = NULL)
[17:59:21.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:21.965]                 }
[17:59:21.965]                 ...future.workdir <- getwd()
[17:59:21.965]             }
[17:59:21.965]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:21.965]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:21.965]         }
[17:59:21.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:21.965]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:21.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:21.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:21.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:21.965]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:21.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:21.965]             base::names(...future.oldOptions))
[17:59:21.965]     }
[17:59:21.965]     if (FALSE) {
[17:59:21.965]     }
[17:59:21.965]     else {
[17:59:21.965]         if (TRUE) {
[17:59:21.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:21.965]                 open = "w")
[17:59:21.965]         }
[17:59:21.965]         else {
[17:59:21.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:21.965]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:21.965]         }
[17:59:21.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:21.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:21.965]             base::sink(type = "output", split = FALSE)
[17:59:21.965]             base::close(...future.stdout)
[17:59:21.965]         }, add = TRUE)
[17:59:21.965]     }
[17:59:21.965]     ...future.frame <- base::sys.nframe()
[17:59:21.965]     ...future.conditions <- base::list()
[17:59:21.965]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:21.965]     if (FALSE) {
[17:59:21.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:21.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:21.965]     }
[17:59:21.965]     ...future.result <- base::tryCatch({
[17:59:21.965]         base::withCallingHandlers({
[17:59:21.965]             ...future.value <- base::withVisible(base::local({
[17:59:21.965]                 ...future.makeSendCondition <- base::local({
[17:59:21.965]                   sendCondition <- NULL
[17:59:21.965]                   function(frame = 1L) {
[17:59:21.965]                     if (is.function(sendCondition)) 
[17:59:21.965]                       return(sendCondition)
[17:59:21.965]                     ns <- getNamespace("parallel")
[17:59:21.965]                     if (exists("sendData", mode = "function", 
[17:59:21.965]                       envir = ns)) {
[17:59:21.965]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:21.965]                         envir = ns)
[17:59:21.965]                       envir <- sys.frame(frame)
[17:59:21.965]                       master <- NULL
[17:59:21.965]                       while (!identical(envir, .GlobalEnv) && 
[17:59:21.965]                         !identical(envir, emptyenv())) {
[17:59:21.965]                         if (exists("master", mode = "list", envir = envir, 
[17:59:21.965]                           inherits = FALSE)) {
[17:59:21.965]                           master <- get("master", mode = "list", 
[17:59:21.965]                             envir = envir, inherits = FALSE)
[17:59:21.965]                           if (inherits(master, c("SOCKnode", 
[17:59:21.965]                             "SOCK0node"))) {
[17:59:21.965]                             sendCondition <<- function(cond) {
[17:59:21.965]                               data <- list(type = "VALUE", value = cond, 
[17:59:21.965]                                 success = TRUE)
[17:59:21.965]                               parallel_sendData(master, data)
[17:59:21.965]                             }
[17:59:21.965]                             return(sendCondition)
[17:59:21.965]                           }
[17:59:21.965]                         }
[17:59:21.965]                         frame <- frame + 1L
[17:59:21.965]                         envir <- sys.frame(frame)
[17:59:21.965]                       }
[17:59:21.965]                     }
[17:59:21.965]                     sendCondition <<- function(cond) NULL
[17:59:21.965]                   }
[17:59:21.965]                 })
[17:59:21.965]                 withCallingHandlers({
[17:59:21.965]                   {
[17:59:21.965]                     do.call(function(...) {
[17:59:21.965]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.965]                       if (!identical(...future.globals.maxSize.org, 
[17:59:21.965]                         ...future.globals.maxSize)) {
[17:59:21.965]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.965]                         on.exit(options(oopts), add = TRUE)
[17:59:21.965]                       }
[17:59:21.965]                       {
[17:59:21.965]                         lapply(seq_along(...future.elements_ii), 
[17:59:21.965]                           FUN = function(jj) {
[17:59:21.965]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.965]                             ...future.FUN(...future.X_jj, ...)
[17:59:21.965]                           })
[17:59:21.965]                       }
[17:59:21.965]                     }, args = future.call.arguments)
[17:59:21.965]                   }
[17:59:21.965]                 }, immediateCondition = function(cond) {
[17:59:21.965]                   sendCondition <- ...future.makeSendCondition()
[17:59:21.965]                   sendCondition(cond)
[17:59:21.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.965]                   {
[17:59:21.965]                     inherits <- base::inherits
[17:59:21.965]                     invokeRestart <- base::invokeRestart
[17:59:21.965]                     is.null <- base::is.null
[17:59:21.965]                     muffled <- FALSE
[17:59:21.965]                     if (inherits(cond, "message")) {
[17:59:21.965]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:21.965]                       if (muffled) 
[17:59:21.965]                         invokeRestart("muffleMessage")
[17:59:21.965]                     }
[17:59:21.965]                     else if (inherits(cond, "warning")) {
[17:59:21.965]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:21.965]                       if (muffled) 
[17:59:21.965]                         invokeRestart("muffleWarning")
[17:59:21.965]                     }
[17:59:21.965]                     else if (inherits(cond, "condition")) {
[17:59:21.965]                       if (!is.null(pattern)) {
[17:59:21.965]                         computeRestarts <- base::computeRestarts
[17:59:21.965]                         grepl <- base::grepl
[17:59:21.965]                         restarts <- computeRestarts(cond)
[17:59:21.965]                         for (restart in restarts) {
[17:59:21.965]                           name <- restart$name
[17:59:21.965]                           if (is.null(name)) 
[17:59:21.965]                             next
[17:59:21.965]                           if (!grepl(pattern, name)) 
[17:59:21.965]                             next
[17:59:21.965]                           invokeRestart(restart)
[17:59:21.965]                           muffled <- TRUE
[17:59:21.965]                           break
[17:59:21.965]                         }
[17:59:21.965]                       }
[17:59:21.965]                     }
[17:59:21.965]                     invisible(muffled)
[17:59:21.965]                   }
[17:59:21.965]                   muffleCondition(cond)
[17:59:21.965]                 })
[17:59:21.965]             }))
[17:59:21.965]             future::FutureResult(value = ...future.value$value, 
[17:59:21.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.965]                   ...future.rng), globalenv = if (FALSE) 
[17:59:21.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:21.965]                     ...future.globalenv.names))
[17:59:21.965]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:21.965]         }, condition = base::local({
[17:59:21.965]             c <- base::c
[17:59:21.965]             inherits <- base::inherits
[17:59:21.965]             invokeRestart <- base::invokeRestart
[17:59:21.965]             length <- base::length
[17:59:21.965]             list <- base::list
[17:59:21.965]             seq.int <- base::seq.int
[17:59:21.965]             signalCondition <- base::signalCondition
[17:59:21.965]             sys.calls <- base::sys.calls
[17:59:21.965]             `[[` <- base::`[[`
[17:59:21.965]             `+` <- base::`+`
[17:59:21.965]             `<<-` <- base::`<<-`
[17:59:21.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:21.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:21.965]                   3L)]
[17:59:21.965]             }
[17:59:21.965]             function(cond) {
[17:59:21.965]                 is_error <- inherits(cond, "error")
[17:59:21.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:21.965]                   NULL)
[17:59:21.965]                 if (is_error) {
[17:59:21.965]                   sessionInformation <- function() {
[17:59:21.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:21.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:21.965]                       search = base::search(), system = base::Sys.info())
[17:59:21.965]                   }
[17:59:21.965]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:21.965]                     cond$call), session = sessionInformation(), 
[17:59:21.965]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:21.965]                   signalCondition(cond)
[17:59:21.965]                 }
[17:59:21.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:21.965]                 "immediateCondition"))) {
[17:59:21.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:21.965]                   ...future.conditions[[length(...future.conditions) + 
[17:59:21.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:21.965]                   if (TRUE && !signal) {
[17:59:21.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.965]                     {
[17:59:21.965]                       inherits <- base::inherits
[17:59:21.965]                       invokeRestart <- base::invokeRestart
[17:59:21.965]                       is.null <- base::is.null
[17:59:21.965]                       muffled <- FALSE
[17:59:21.965]                       if (inherits(cond, "message")) {
[17:59:21.965]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.965]                         if (muffled) 
[17:59:21.965]                           invokeRestart("muffleMessage")
[17:59:21.965]                       }
[17:59:21.965]                       else if (inherits(cond, "warning")) {
[17:59:21.965]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.965]                         if (muffled) 
[17:59:21.965]                           invokeRestart("muffleWarning")
[17:59:21.965]                       }
[17:59:21.965]                       else if (inherits(cond, "condition")) {
[17:59:21.965]                         if (!is.null(pattern)) {
[17:59:21.965]                           computeRestarts <- base::computeRestarts
[17:59:21.965]                           grepl <- base::grepl
[17:59:21.965]                           restarts <- computeRestarts(cond)
[17:59:21.965]                           for (restart in restarts) {
[17:59:21.965]                             name <- restart$name
[17:59:21.965]                             if (is.null(name)) 
[17:59:21.965]                               next
[17:59:21.965]                             if (!grepl(pattern, name)) 
[17:59:21.965]                               next
[17:59:21.965]                             invokeRestart(restart)
[17:59:21.965]                             muffled <- TRUE
[17:59:21.965]                             break
[17:59:21.965]                           }
[17:59:21.965]                         }
[17:59:21.965]                       }
[17:59:21.965]                       invisible(muffled)
[17:59:21.965]                     }
[17:59:21.965]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.965]                   }
[17:59:21.965]                 }
[17:59:21.965]                 else {
[17:59:21.965]                   if (TRUE) {
[17:59:21.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:21.965]                     {
[17:59:21.965]                       inherits <- base::inherits
[17:59:21.965]                       invokeRestart <- base::invokeRestart
[17:59:21.965]                       is.null <- base::is.null
[17:59:21.965]                       muffled <- FALSE
[17:59:21.965]                       if (inherits(cond, "message")) {
[17:59:21.965]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:21.965]                         if (muffled) 
[17:59:21.965]                           invokeRestart("muffleMessage")
[17:59:21.965]                       }
[17:59:21.965]                       else if (inherits(cond, "warning")) {
[17:59:21.965]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:21.965]                         if (muffled) 
[17:59:21.965]                           invokeRestart("muffleWarning")
[17:59:21.965]                       }
[17:59:21.965]                       else if (inherits(cond, "condition")) {
[17:59:21.965]                         if (!is.null(pattern)) {
[17:59:21.965]                           computeRestarts <- base::computeRestarts
[17:59:21.965]                           grepl <- base::grepl
[17:59:21.965]                           restarts <- computeRestarts(cond)
[17:59:21.965]                           for (restart in restarts) {
[17:59:21.965]                             name <- restart$name
[17:59:21.965]                             if (is.null(name)) 
[17:59:21.965]                               next
[17:59:21.965]                             if (!grepl(pattern, name)) 
[17:59:21.965]                               next
[17:59:21.965]                             invokeRestart(restart)
[17:59:21.965]                             muffled <- TRUE
[17:59:21.965]                             break
[17:59:21.965]                           }
[17:59:21.965]                         }
[17:59:21.965]                       }
[17:59:21.965]                       invisible(muffled)
[17:59:21.965]                     }
[17:59:21.965]                     muffleCondition(cond, pattern = "^muffle")
[17:59:21.965]                   }
[17:59:21.965]                 }
[17:59:21.965]             }
[17:59:21.965]         }))
[17:59:21.965]     }, error = function(ex) {
[17:59:21.965]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:21.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:21.965]                 ...future.rng), started = ...future.startTime, 
[17:59:21.965]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:21.965]             version = "1.8"), class = "FutureResult")
[17:59:21.965]     }, finally = {
[17:59:21.965]         if (!identical(...future.workdir, getwd())) 
[17:59:21.965]             setwd(...future.workdir)
[17:59:21.965]         {
[17:59:21.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:21.965]                 ...future.oldOptions$nwarnings <- NULL
[17:59:21.965]             }
[17:59:21.965]             base::options(...future.oldOptions)
[17:59:21.965]             if (.Platform$OS.type == "windows") {
[17:59:21.965]                 old_names <- names(...future.oldEnvVars)
[17:59:21.965]                 envs <- base::Sys.getenv()
[17:59:21.965]                 names <- names(envs)
[17:59:21.965]                 common <- intersect(names, old_names)
[17:59:21.965]                 added <- setdiff(names, old_names)
[17:59:21.965]                 removed <- setdiff(old_names, names)
[17:59:21.965]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:21.965]                   envs[common]]
[17:59:21.965]                 NAMES <- toupper(changed)
[17:59:21.965]                 args <- list()
[17:59:21.965]                 for (kk in seq_along(NAMES)) {
[17:59:21.965]                   name <- changed[[kk]]
[17:59:21.965]                   NAME <- NAMES[[kk]]
[17:59:21.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.965]                     next
[17:59:21.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.965]                 }
[17:59:21.965]                 NAMES <- toupper(added)
[17:59:21.965]                 for (kk in seq_along(NAMES)) {
[17:59:21.965]                   name <- added[[kk]]
[17:59:21.965]                   NAME <- NAMES[[kk]]
[17:59:21.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.965]                     next
[17:59:21.965]                   args[[name]] <- ""
[17:59:21.965]                 }
[17:59:21.965]                 NAMES <- toupper(removed)
[17:59:21.965]                 for (kk in seq_along(NAMES)) {
[17:59:21.965]                   name <- removed[[kk]]
[17:59:21.965]                   NAME <- NAMES[[kk]]
[17:59:21.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:21.965]                     next
[17:59:21.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:21.965]                 }
[17:59:21.965]                 if (length(args) > 0) 
[17:59:21.965]                   base::do.call(base::Sys.setenv, args = args)
[17:59:21.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:21.965]             }
[17:59:21.965]             else {
[17:59:21.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:21.965]             }
[17:59:21.965]             {
[17:59:21.965]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:21.965]                   0L) {
[17:59:21.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:21.965]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:21.965]                   base::options(opts)
[17:59:21.965]                 }
[17:59:21.965]                 {
[17:59:21.965]                   {
[17:59:21.965]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:21.965]                     NULL
[17:59:21.965]                   }
[17:59:21.965]                   options(future.plan = NULL)
[17:59:21.965]                   if (is.na(NA_character_)) 
[17:59:21.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:21.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:21.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:21.965]                     .init = FALSE)
[17:59:21.965]                 }
[17:59:21.965]             }
[17:59:21.965]         }
[17:59:21.965]     })
[17:59:21.965]     if (TRUE) {
[17:59:21.965]         base::sink(type = "output", split = FALSE)
[17:59:21.965]         if (TRUE) {
[17:59:21.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:21.965]         }
[17:59:21.965]         else {
[17:59:21.965]             ...future.result["stdout"] <- base::list(NULL)
[17:59:21.965]         }
[17:59:21.965]         base::close(...future.stdout)
[17:59:21.965]         ...future.stdout <- NULL
[17:59:21.965]     }
[17:59:21.965]     ...future.result$conditions <- ...future.conditions
[17:59:21.965]     ...future.result$finished <- base::Sys.time()
[17:59:21.965]     ...future.result
[17:59:21.965] }
[17:59:21.971] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[17:59:21.971] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:21.972] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:21.972] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[17:59:21.973] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[17:59:21.973] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[17:59:21.974] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[17:59:21.974] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:21.975] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:21.976] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:59:21.976] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:59:21.977] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[17:59:21.978] MultisessionFuture started
[17:59:21.978] - Launch lazy future ... done
[17:59:21.978] run() for ‘MultisessionFuture’ ... done
[17:59:21.978] Created future:
[17:59:21.978] MultisessionFuture:
[17:59:21.978] Label: ‘future_apply-2’
[17:59:21.978] Expression:
[17:59:21.978] {
[17:59:21.978]     do.call(function(...) {
[17:59:21.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:21.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:21.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:21.978]             on.exit(options(oopts), add = TRUE)
[17:59:21.978]         }
[17:59:21.978]         {
[17:59:21.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:21.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:21.978]                 ...future.FUN(...future.X_jj, ...)
[17:59:21.978]             })
[17:59:21.978]         }
[17:59:21.978]     }, args = future.call.arguments)
[17:59:21.978] }
[17:59:21.978] Lazy evaluation: FALSE
[17:59:21.978] Asynchronous evaluation: TRUE
[17:59:21.978] Local evaluation: TRUE
[17:59:21.978] Environment: R_GlobalEnv
[17:59:21.978] Capture standard output: TRUE
[17:59:21.978] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:21.978] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:21.978] Packages: <none>
[17:59:21.978] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:21.978] Resolved: FALSE
[17:59:21.978] Value: <not collected>
[17:59:21.978] Conditions captured: <none>
[17:59:21.978] Early signaling: FALSE
[17:59:21.978] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:21.978] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:21.991] Chunk #2 of 2 ... DONE
[17:59:21.991] Launching 2 futures (chunks) ... DONE
[17:59:21.992] Resolving 2 futures (chunks) ...
[17:59:21.992] resolve() on list ...
[17:59:21.992]  recursive: 0
[17:59:21.992]  length: 2
[17:59:21.992] 
[17:59:21.993] receiveMessageFromWorker() for ClusterFuture ...
[17:59:21.994] - Validating connection of MultisessionFuture
[17:59:21.994] - received message: FutureResult
[17:59:21.994] - Received FutureResult
[17:59:21.994] - Erased future from FutureRegistry
[17:59:21.995] result() for ClusterFuture ...
[17:59:21.995] - result already collected: FutureResult
[17:59:21.995] result() for ClusterFuture ... done
[17:59:21.995] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:21.995] Future #1
[17:59:21.996] result() for ClusterFuture ...
[17:59:21.996] - result already collected: FutureResult
[17:59:21.996] result() for ClusterFuture ... done
[17:59:21.996] result() for ClusterFuture ...
[17:59:21.996] - result already collected: FutureResult
[17:59:21.996] result() for ClusterFuture ... done
[17:59:21.997] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:21.997] - nx: 2
[17:59:21.997] - relay: TRUE
[17:59:21.997] - stdout: TRUE
[17:59:21.997] - signal: TRUE
[17:59:21.998] - resignal: FALSE
[17:59:21.998] - force: TRUE
[17:59:21.998] - relayed: [n=2] FALSE, FALSE
[17:59:21.998] - queued futures: [n=2] FALSE, FALSE
[17:59:21.998]  - until=1
[17:59:21.998]  - relaying element #1
[17:59:21.999] result() for ClusterFuture ...
[17:59:21.999] - result already collected: FutureResult
[17:59:21.999] result() for ClusterFuture ... done
[17:59:21.999] result() for ClusterFuture ...
[17:59:21.999] - result already collected: FutureResult
[17:59:22.000] result() for ClusterFuture ... done
[17:59:22.000] result() for ClusterFuture ...
[17:59:22.000] - result already collected: FutureResult
[17:59:22.000] result() for ClusterFuture ... done
[17:59:22.000] result() for ClusterFuture ...
[17:59:22.001] - result already collected: FutureResult
[17:59:22.001] result() for ClusterFuture ... done
[17:59:22.001] - relayed: [n=2] TRUE, FALSE
[17:59:22.001] - queued futures: [n=2] TRUE, FALSE
[17:59:22.001] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:22.002]  length: 1 (resolved future 1)
[17:59:22.024] receiveMessageFromWorker() for ClusterFuture ...
[17:59:22.024] - Validating connection of MultisessionFuture
[17:59:22.024] - received message: FutureResult
[17:59:22.025] - Received FutureResult
[17:59:22.025] - Erased future from FutureRegistry
[17:59:22.025] result() for ClusterFuture ...
[17:59:22.025] - result already collected: FutureResult
[17:59:22.025] result() for ClusterFuture ... done
[17:59:22.026] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:22.026] Future #2
[17:59:22.026] result() for ClusterFuture ...
[17:59:22.026] - result already collected: FutureResult
[17:59:22.026] result() for ClusterFuture ... done
[17:59:22.027] result() for ClusterFuture ...
[17:59:22.027] - result already collected: FutureResult
[17:59:22.027] result() for ClusterFuture ... done
[17:59:22.027] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:22.028] - nx: 2
[17:59:22.028] - relay: TRUE
[17:59:22.028] - stdout: TRUE
[17:59:22.028] - signal: TRUE
[17:59:22.028] - resignal: FALSE
[17:59:22.029] - force: TRUE
[17:59:22.029] - relayed: [n=2] TRUE, FALSE
[17:59:22.029] - queued futures: [n=2] TRUE, FALSE
[17:59:22.029]  - until=2
[17:59:22.029]  - relaying element #2
[17:59:22.030] result() for ClusterFuture ...
[17:59:22.030] - result already collected: FutureResult
[17:59:22.030] result() for ClusterFuture ... done
[17:59:22.030] result() for ClusterFuture ...
[17:59:22.030] - result already collected: FutureResult
[17:59:22.031] result() for ClusterFuture ... done
[17:59:22.031] result() for ClusterFuture ...
[17:59:22.031] - result already collected: FutureResult
[17:59:22.031] result() for ClusterFuture ... done
[17:59:22.031] result() for ClusterFuture ...
[17:59:22.032] - result already collected: FutureResult
[17:59:22.032] result() for ClusterFuture ... done
[17:59:22.032] - relayed: [n=2] TRUE, TRUE
[17:59:22.032] - queued futures: [n=2] TRUE, TRUE
[17:59:22.032] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:22.033]  length: 0 (resolved future 2)
[17:59:22.033] Relaying remaining futures
[17:59:22.033] signalConditionsASAP(NULL, pos=0) ...
[17:59:22.033] - nx: 2
[17:59:22.033] - relay: TRUE
[17:59:22.034] - stdout: TRUE
[17:59:22.034] - signal: TRUE
[17:59:22.034] - resignal: FALSE
[17:59:22.034] - force: TRUE
[17:59:22.034] - relayed: [n=2] TRUE, TRUE
[17:59:22.035] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:22.035] - relayed: [n=2] TRUE, TRUE
[17:59:22.035] - queued futures: [n=2] TRUE, TRUE
[17:59:22.035] signalConditionsASAP(NULL, pos=0) ... done
[17:59:22.035] resolve() on list ... DONE
[17:59:22.036] result() for ClusterFuture ...
[17:59:22.036] - result already collected: FutureResult
[17:59:22.036] result() for ClusterFuture ... done
[17:59:22.036] result() for ClusterFuture ...
[17:59:22.036] - result already collected: FutureResult
[17:59:22.037] result() for ClusterFuture ... done
[17:59:22.037] result() for ClusterFuture ...
[17:59:22.037] - result already collected: FutureResult
[17:59:22.037] result() for ClusterFuture ... done
[17:59:22.037] result() for ClusterFuture ...
[17:59:22.038] - result already collected: FutureResult
[17:59:22.038] result() for ClusterFuture ... done
[17:59:22.038]  - Number of value chunks collected: 2
[17:59:22.038] Resolving 2 futures (chunks) ... DONE
[17:59:22.039] Reducing values from 2 chunks ...
[17:59:22.039]  - Number of values collected after concatenation: 6
[17:59:22.039]  - Number of values expected: 6
[17:59:22.039] Reducing values from 2 chunks ... DONE
[17:59:22.039] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:59:22.041] getGlobalsAndPackagesXApply() ...
[17:59:22.041]  - future.globals: TRUE
[17:59:22.045] getGlobalsAndPackages() ...
[17:59:22.045] Searching for globals...
[17:59:22.047] - globals found: [1] ‘FUN’
[17:59:22.048] Searching for globals ... DONE
[17:59:22.048] Resolving globals: FALSE
[17:59:22.048] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:22.049] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:22.050] - globals: [1] ‘FUN’
[17:59:22.050] 
[17:59:22.050] getGlobalsAndPackages() ... DONE
[17:59:22.050]  - globals found/used: [n=1] ‘FUN’
[17:59:22.051]  - needed namespaces: [n=0] 
[17:59:22.051] Finding globals ... DONE
[17:59:22.051]  - use_args: TRUE
[17:59:22.051]  - Getting '...' globals ...
[17:59:22.052] resolve() on list ...
[17:59:22.052]  recursive: 0
[17:59:22.052]  length: 1
[17:59:22.052]  elements: ‘...’
[17:59:22.053]  length: 0 (resolved future 1)
[17:59:22.053] resolve() on list ... DONE
[17:59:22.053]    - '...' content: [n=0] 
[17:59:22.053] List of 1
[17:59:22.053]  $ ...: list()
[17:59:22.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.053]  - attr(*, "where")=List of 1
[17:59:22.053]   ..$ ...:<environment: 0x56085d9efd10> 
[17:59:22.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.053]  - attr(*, "resolved")= logi TRUE
[17:59:22.053]  - attr(*, "total_size")= num NA
[17:59:22.059]  - Getting '...' globals ... DONE
[17:59:22.059] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:22.059] List of 2
[17:59:22.059]  $ ...future.FUN:function (x)  
[17:59:22.059]  $ ...          : list()
[17:59:22.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.059]  - attr(*, "where")=List of 2
[17:59:22.059]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:22.059]   ..$ ...          :<environment: 0x56085d9efd10> 
[17:59:22.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.059]  - attr(*, "resolved")= logi FALSE
[17:59:22.059]  - attr(*, "total_size")= num 848
[17:59:22.065] Packages to be attached in all futures: [n=0] 
[17:59:22.066] getGlobalsAndPackagesXApply() ... DONE
[17:59:22.071] future_lapply() ...
[17:59:22.078] Number of chunks: 2
[17:59:22.079] getGlobalsAndPackagesXApply() ...
[17:59:22.079]  - future.globals: <name-value list> with names ‘list()’
[17:59:22.080]  - use_args: TRUE
[17:59:22.080] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:22.080] List of 2
[17:59:22.080]  $ ...          : list()
[17:59:22.080]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.080]  $ ...future.FUN:function (x)  
[17:59:22.080]  - attr(*, "where")=List of 2
[17:59:22.080]   ..$ ...          :<environment: 0x56085d9efd10> 
[17:59:22.080]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:22.080]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.080]  - attr(*, "resolved")= logi FALSE
[17:59:22.080]  - attr(*, "total_size")= num NA
[17:59:22.087] Packages to be attached in all futures: [n=0] 
[17:59:22.088] getGlobalsAndPackagesXApply() ... DONE
[17:59:22.088] Number of futures (= number of chunks): 2
[17:59:22.088] Launching 2 futures (chunks) ...
[17:59:22.089] Chunk #1 of 2 ...
[17:59:22.089]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:22.089]  - seeds: <none>
[17:59:22.089]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.090] getGlobalsAndPackages() ...
[17:59:22.090] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.090] Resolving globals: FALSE
[17:59:22.090] Tweak future expression to call with '...' arguments ...
[17:59:22.090] {
[17:59:22.090]     do.call(function(...) {
[17:59:22.090]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.090]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.090]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.090]             on.exit(options(oopts), add = TRUE)
[17:59:22.090]         }
[17:59:22.090]         {
[17:59:22.090]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.090]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.090]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.090]             })
[17:59:22.090]         }
[17:59:22.090]     }, args = future.call.arguments)
[17:59:22.090] }
[17:59:22.091] Tweak future expression to call with '...' arguments ... DONE
[17:59:22.092] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.092] 
[17:59:22.092] getGlobalsAndPackages() ... DONE
[17:59:22.093] run() for ‘Future’ ...
[17:59:22.093] - state: ‘created’
[17:59:22.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:22.117] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.118] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:22.118]   - Field: ‘node’
[17:59:22.118]   - Field: ‘label’
[17:59:22.119]   - Field: ‘local’
[17:59:22.119]   - Field: ‘owner’
[17:59:22.119]   - Field: ‘envir’
[17:59:22.119]   - Field: ‘workers’
[17:59:22.119]   - Field: ‘packages’
[17:59:22.120]   - Field: ‘gc’
[17:59:22.120]   - Field: ‘conditions’
[17:59:22.120]   - Field: ‘persistent’
[17:59:22.120]   - Field: ‘expr’
[17:59:22.120]   - Field: ‘uuid’
[17:59:22.121]   - Field: ‘seed’
[17:59:22.121]   - Field: ‘version’
[17:59:22.121]   - Field: ‘result’
[17:59:22.121]   - Field: ‘asynchronous’
[17:59:22.121]   - Field: ‘calls’
[17:59:22.122]   - Field: ‘globals’
[17:59:22.122]   - Field: ‘stdout’
[17:59:22.122]   - Field: ‘earlySignal’
[17:59:22.122]   - Field: ‘lazy’
[17:59:22.122]   - Field: ‘state’
[17:59:22.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:22.123] - Launch lazy future ...
[17:59:22.123] Packages needed by the future expression (n = 0): <none>
[17:59:22.124] Packages needed by future strategies (n = 0): <none>
[17:59:22.124] {
[17:59:22.124]     {
[17:59:22.124]         {
[17:59:22.124]             ...future.startTime <- base::Sys.time()
[17:59:22.124]             {
[17:59:22.124]                 {
[17:59:22.124]                   {
[17:59:22.124]                     {
[17:59:22.124]                       base::local({
[17:59:22.124]                         has_future <- base::requireNamespace("future", 
[17:59:22.124]                           quietly = TRUE)
[17:59:22.124]                         if (has_future) {
[17:59:22.124]                           ns <- base::getNamespace("future")
[17:59:22.124]                           version <- ns[[".package"]][["version"]]
[17:59:22.124]                           if (is.null(version)) 
[17:59:22.124]                             version <- utils::packageVersion("future")
[17:59:22.124]                         }
[17:59:22.124]                         else {
[17:59:22.124]                           version <- NULL
[17:59:22.124]                         }
[17:59:22.124]                         if (!has_future || version < "1.8.0") {
[17:59:22.124]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:22.124]                             "", base::R.version$version.string), 
[17:59:22.124]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:22.124]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:22.124]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:22.124]                               "release", "version")], collapse = " "), 
[17:59:22.124]                             hostname = base::Sys.info()[["nodename"]])
[17:59:22.124]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:22.124]                             info)
[17:59:22.124]                           info <- base::paste(info, collapse = "; ")
[17:59:22.124]                           if (!has_future) {
[17:59:22.124]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:22.124]                               info)
[17:59:22.124]                           }
[17:59:22.124]                           else {
[17:59:22.124]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:22.124]                               info, version)
[17:59:22.124]                           }
[17:59:22.124]                           base::stop(msg)
[17:59:22.124]                         }
[17:59:22.124]                       })
[17:59:22.124]                     }
[17:59:22.124]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:22.124]                     base::options(mc.cores = 1L)
[17:59:22.124]                   }
[17:59:22.124]                   ...future.strategy.old <- future::plan("list")
[17:59:22.124]                   options(future.plan = NULL)
[17:59:22.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:22.124]                 }
[17:59:22.124]                 ...future.workdir <- getwd()
[17:59:22.124]             }
[17:59:22.124]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:22.124]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:22.124]         }
[17:59:22.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:22.124]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:22.124]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:22.124]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:22.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:22.124]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:22.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:22.124]             base::names(...future.oldOptions))
[17:59:22.124]     }
[17:59:22.124]     if (FALSE) {
[17:59:22.124]     }
[17:59:22.124]     else {
[17:59:22.124]         if (TRUE) {
[17:59:22.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:22.124]                 open = "w")
[17:59:22.124]         }
[17:59:22.124]         else {
[17:59:22.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:22.124]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:22.124]         }
[17:59:22.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:22.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:22.124]             base::sink(type = "output", split = FALSE)
[17:59:22.124]             base::close(...future.stdout)
[17:59:22.124]         }, add = TRUE)
[17:59:22.124]     }
[17:59:22.124]     ...future.frame <- base::sys.nframe()
[17:59:22.124]     ...future.conditions <- base::list()
[17:59:22.124]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:22.124]     if (FALSE) {
[17:59:22.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:22.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:22.124]     }
[17:59:22.124]     ...future.result <- base::tryCatch({
[17:59:22.124]         base::withCallingHandlers({
[17:59:22.124]             ...future.value <- base::withVisible(base::local({
[17:59:22.124]                 ...future.makeSendCondition <- base::local({
[17:59:22.124]                   sendCondition <- NULL
[17:59:22.124]                   function(frame = 1L) {
[17:59:22.124]                     if (is.function(sendCondition)) 
[17:59:22.124]                       return(sendCondition)
[17:59:22.124]                     ns <- getNamespace("parallel")
[17:59:22.124]                     if (exists("sendData", mode = "function", 
[17:59:22.124]                       envir = ns)) {
[17:59:22.124]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:22.124]                         envir = ns)
[17:59:22.124]                       envir <- sys.frame(frame)
[17:59:22.124]                       master <- NULL
[17:59:22.124]                       while (!identical(envir, .GlobalEnv) && 
[17:59:22.124]                         !identical(envir, emptyenv())) {
[17:59:22.124]                         if (exists("master", mode = "list", envir = envir, 
[17:59:22.124]                           inherits = FALSE)) {
[17:59:22.124]                           master <- get("master", mode = "list", 
[17:59:22.124]                             envir = envir, inherits = FALSE)
[17:59:22.124]                           if (inherits(master, c("SOCKnode", 
[17:59:22.124]                             "SOCK0node"))) {
[17:59:22.124]                             sendCondition <<- function(cond) {
[17:59:22.124]                               data <- list(type = "VALUE", value = cond, 
[17:59:22.124]                                 success = TRUE)
[17:59:22.124]                               parallel_sendData(master, data)
[17:59:22.124]                             }
[17:59:22.124]                             return(sendCondition)
[17:59:22.124]                           }
[17:59:22.124]                         }
[17:59:22.124]                         frame <- frame + 1L
[17:59:22.124]                         envir <- sys.frame(frame)
[17:59:22.124]                       }
[17:59:22.124]                     }
[17:59:22.124]                     sendCondition <<- function(cond) NULL
[17:59:22.124]                   }
[17:59:22.124]                 })
[17:59:22.124]                 withCallingHandlers({
[17:59:22.124]                   {
[17:59:22.124]                     do.call(function(...) {
[17:59:22.124]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.124]                       if (!identical(...future.globals.maxSize.org, 
[17:59:22.124]                         ...future.globals.maxSize)) {
[17:59:22.124]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.124]                         on.exit(options(oopts), add = TRUE)
[17:59:22.124]                       }
[17:59:22.124]                       {
[17:59:22.124]                         lapply(seq_along(...future.elements_ii), 
[17:59:22.124]                           FUN = function(jj) {
[17:59:22.124]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.124]                             ...future.FUN(...future.X_jj, ...)
[17:59:22.124]                           })
[17:59:22.124]                       }
[17:59:22.124]                     }, args = future.call.arguments)
[17:59:22.124]                   }
[17:59:22.124]                 }, immediateCondition = function(cond) {
[17:59:22.124]                   sendCondition <- ...future.makeSendCondition()
[17:59:22.124]                   sendCondition(cond)
[17:59:22.124]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.124]                   {
[17:59:22.124]                     inherits <- base::inherits
[17:59:22.124]                     invokeRestart <- base::invokeRestart
[17:59:22.124]                     is.null <- base::is.null
[17:59:22.124]                     muffled <- FALSE
[17:59:22.124]                     if (inherits(cond, "message")) {
[17:59:22.124]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:22.124]                       if (muffled) 
[17:59:22.124]                         invokeRestart("muffleMessage")
[17:59:22.124]                     }
[17:59:22.124]                     else if (inherits(cond, "warning")) {
[17:59:22.124]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:22.124]                       if (muffled) 
[17:59:22.124]                         invokeRestart("muffleWarning")
[17:59:22.124]                     }
[17:59:22.124]                     else if (inherits(cond, "condition")) {
[17:59:22.124]                       if (!is.null(pattern)) {
[17:59:22.124]                         computeRestarts <- base::computeRestarts
[17:59:22.124]                         grepl <- base::grepl
[17:59:22.124]                         restarts <- computeRestarts(cond)
[17:59:22.124]                         for (restart in restarts) {
[17:59:22.124]                           name <- restart$name
[17:59:22.124]                           if (is.null(name)) 
[17:59:22.124]                             next
[17:59:22.124]                           if (!grepl(pattern, name)) 
[17:59:22.124]                             next
[17:59:22.124]                           invokeRestart(restart)
[17:59:22.124]                           muffled <- TRUE
[17:59:22.124]                           break
[17:59:22.124]                         }
[17:59:22.124]                       }
[17:59:22.124]                     }
[17:59:22.124]                     invisible(muffled)
[17:59:22.124]                   }
[17:59:22.124]                   muffleCondition(cond)
[17:59:22.124]                 })
[17:59:22.124]             }))
[17:59:22.124]             future::FutureResult(value = ...future.value$value, 
[17:59:22.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.124]                   ...future.rng), globalenv = if (FALSE) 
[17:59:22.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:22.124]                     ...future.globalenv.names))
[17:59:22.124]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:22.124]         }, condition = base::local({
[17:59:22.124]             c <- base::c
[17:59:22.124]             inherits <- base::inherits
[17:59:22.124]             invokeRestart <- base::invokeRestart
[17:59:22.124]             length <- base::length
[17:59:22.124]             list <- base::list
[17:59:22.124]             seq.int <- base::seq.int
[17:59:22.124]             signalCondition <- base::signalCondition
[17:59:22.124]             sys.calls <- base::sys.calls
[17:59:22.124]             `[[` <- base::`[[`
[17:59:22.124]             `+` <- base::`+`
[17:59:22.124]             `<<-` <- base::`<<-`
[17:59:22.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:22.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:22.124]                   3L)]
[17:59:22.124]             }
[17:59:22.124]             function(cond) {
[17:59:22.124]                 is_error <- inherits(cond, "error")
[17:59:22.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:22.124]                   NULL)
[17:59:22.124]                 if (is_error) {
[17:59:22.124]                   sessionInformation <- function() {
[17:59:22.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:22.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:22.124]                       search = base::search(), system = base::Sys.info())
[17:59:22.124]                   }
[17:59:22.124]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:22.124]                     cond$call), session = sessionInformation(), 
[17:59:22.124]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:22.124]                   signalCondition(cond)
[17:59:22.124]                 }
[17:59:22.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:22.124]                 "immediateCondition"))) {
[17:59:22.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:22.124]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:22.124]                   if (TRUE && !signal) {
[17:59:22.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.124]                     {
[17:59:22.124]                       inherits <- base::inherits
[17:59:22.124]                       invokeRestart <- base::invokeRestart
[17:59:22.124]                       is.null <- base::is.null
[17:59:22.124]                       muffled <- FALSE
[17:59:22.124]                       if (inherits(cond, "message")) {
[17:59:22.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.124]                         if (muffled) 
[17:59:22.124]                           invokeRestart("muffleMessage")
[17:59:22.124]                       }
[17:59:22.124]                       else if (inherits(cond, "warning")) {
[17:59:22.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.124]                         if (muffled) 
[17:59:22.124]                           invokeRestart("muffleWarning")
[17:59:22.124]                       }
[17:59:22.124]                       else if (inherits(cond, "condition")) {
[17:59:22.124]                         if (!is.null(pattern)) {
[17:59:22.124]                           computeRestarts <- base::computeRestarts
[17:59:22.124]                           grepl <- base::grepl
[17:59:22.124]                           restarts <- computeRestarts(cond)
[17:59:22.124]                           for (restart in restarts) {
[17:59:22.124]                             name <- restart$name
[17:59:22.124]                             if (is.null(name)) 
[17:59:22.124]                               next
[17:59:22.124]                             if (!grepl(pattern, name)) 
[17:59:22.124]                               next
[17:59:22.124]                             invokeRestart(restart)
[17:59:22.124]                             muffled <- TRUE
[17:59:22.124]                             break
[17:59:22.124]                           }
[17:59:22.124]                         }
[17:59:22.124]                       }
[17:59:22.124]                       invisible(muffled)
[17:59:22.124]                     }
[17:59:22.124]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.124]                   }
[17:59:22.124]                 }
[17:59:22.124]                 else {
[17:59:22.124]                   if (TRUE) {
[17:59:22.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.124]                     {
[17:59:22.124]                       inherits <- base::inherits
[17:59:22.124]                       invokeRestart <- base::invokeRestart
[17:59:22.124]                       is.null <- base::is.null
[17:59:22.124]                       muffled <- FALSE
[17:59:22.124]                       if (inherits(cond, "message")) {
[17:59:22.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.124]                         if (muffled) 
[17:59:22.124]                           invokeRestart("muffleMessage")
[17:59:22.124]                       }
[17:59:22.124]                       else if (inherits(cond, "warning")) {
[17:59:22.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.124]                         if (muffled) 
[17:59:22.124]                           invokeRestart("muffleWarning")
[17:59:22.124]                       }
[17:59:22.124]                       else if (inherits(cond, "condition")) {
[17:59:22.124]                         if (!is.null(pattern)) {
[17:59:22.124]                           computeRestarts <- base::computeRestarts
[17:59:22.124]                           grepl <- base::grepl
[17:59:22.124]                           restarts <- computeRestarts(cond)
[17:59:22.124]                           for (restart in restarts) {
[17:59:22.124]                             name <- restart$name
[17:59:22.124]                             if (is.null(name)) 
[17:59:22.124]                               next
[17:59:22.124]                             if (!grepl(pattern, name)) 
[17:59:22.124]                               next
[17:59:22.124]                             invokeRestart(restart)
[17:59:22.124]                             muffled <- TRUE
[17:59:22.124]                             break
[17:59:22.124]                           }
[17:59:22.124]                         }
[17:59:22.124]                       }
[17:59:22.124]                       invisible(muffled)
[17:59:22.124]                     }
[17:59:22.124]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.124]                   }
[17:59:22.124]                 }
[17:59:22.124]             }
[17:59:22.124]         }))
[17:59:22.124]     }, error = function(ex) {
[17:59:22.124]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:22.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.124]                 ...future.rng), started = ...future.startTime, 
[17:59:22.124]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:22.124]             version = "1.8"), class = "FutureResult")
[17:59:22.124]     }, finally = {
[17:59:22.124]         if (!identical(...future.workdir, getwd())) 
[17:59:22.124]             setwd(...future.workdir)
[17:59:22.124]         {
[17:59:22.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:22.124]                 ...future.oldOptions$nwarnings <- NULL
[17:59:22.124]             }
[17:59:22.124]             base::options(...future.oldOptions)
[17:59:22.124]             if (.Platform$OS.type == "windows") {
[17:59:22.124]                 old_names <- names(...future.oldEnvVars)
[17:59:22.124]                 envs <- base::Sys.getenv()
[17:59:22.124]                 names <- names(envs)
[17:59:22.124]                 common <- intersect(names, old_names)
[17:59:22.124]                 added <- setdiff(names, old_names)
[17:59:22.124]                 removed <- setdiff(old_names, names)
[17:59:22.124]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:22.124]                   envs[common]]
[17:59:22.124]                 NAMES <- toupper(changed)
[17:59:22.124]                 args <- list()
[17:59:22.124]                 for (kk in seq_along(NAMES)) {
[17:59:22.124]                   name <- changed[[kk]]
[17:59:22.124]                   NAME <- NAMES[[kk]]
[17:59:22.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.124]                     next
[17:59:22.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.124]                 }
[17:59:22.124]                 NAMES <- toupper(added)
[17:59:22.124]                 for (kk in seq_along(NAMES)) {
[17:59:22.124]                   name <- added[[kk]]
[17:59:22.124]                   NAME <- NAMES[[kk]]
[17:59:22.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.124]                     next
[17:59:22.124]                   args[[name]] <- ""
[17:59:22.124]                 }
[17:59:22.124]                 NAMES <- toupper(removed)
[17:59:22.124]                 for (kk in seq_along(NAMES)) {
[17:59:22.124]                   name <- removed[[kk]]
[17:59:22.124]                   NAME <- NAMES[[kk]]
[17:59:22.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.124]                     next
[17:59:22.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.124]                 }
[17:59:22.124]                 if (length(args) > 0) 
[17:59:22.124]                   base::do.call(base::Sys.setenv, args = args)
[17:59:22.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:22.124]             }
[17:59:22.124]             else {
[17:59:22.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:22.124]             }
[17:59:22.124]             {
[17:59:22.124]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:22.124]                   0L) {
[17:59:22.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:22.124]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:22.124]                   base::options(opts)
[17:59:22.124]                 }
[17:59:22.124]                 {
[17:59:22.124]                   {
[17:59:22.124]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:22.124]                     NULL
[17:59:22.124]                   }
[17:59:22.124]                   options(future.plan = NULL)
[17:59:22.124]                   if (is.na(NA_character_)) 
[17:59:22.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:22.124]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:22.124]                     .init = FALSE)
[17:59:22.124]                 }
[17:59:22.124]             }
[17:59:22.124]         }
[17:59:22.124]     })
[17:59:22.124]     if (TRUE) {
[17:59:22.124]         base::sink(type = "output", split = FALSE)
[17:59:22.124]         if (TRUE) {
[17:59:22.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:22.124]         }
[17:59:22.124]         else {
[17:59:22.124]             ...future.result["stdout"] <- base::list(NULL)
[17:59:22.124]         }
[17:59:22.124]         base::close(...future.stdout)
[17:59:22.124]         ...future.stdout <- NULL
[17:59:22.124]     }
[17:59:22.124]     ...future.result$conditions <- ...future.conditions
[17:59:22.124]     ...future.result$finished <- base::Sys.time()
[17:59:22.124]     ...future.result
[17:59:22.124] }
[17:59:22.130] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[17:59:22.131] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:22.132] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:22.132] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:59:22.133] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:59:22.133] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:59:22.134] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:59:22.134] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:22.135] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:22.136] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:59:22.136] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:59:22.137] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[17:59:22.138] MultisessionFuture started
[17:59:22.138] - Launch lazy future ... done
[17:59:22.138] run() for ‘MultisessionFuture’ ... done
[17:59:22.139] Created future:
[17:59:22.140] MultisessionFuture:
[17:59:22.140] Label: ‘future_apply-1’
[17:59:22.140] Expression:
[17:59:22.140] {
[17:59:22.140]     do.call(function(...) {
[17:59:22.140]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.140]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.140]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.140]             on.exit(options(oopts), add = TRUE)
[17:59:22.140]         }
[17:59:22.140]         {
[17:59:22.140]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.140]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.140]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.140]             })
[17:59:22.140]         }
[17:59:22.140]     }, args = future.call.arguments)
[17:59:22.140] }
[17:59:22.140] Lazy evaluation: FALSE
[17:59:22.140] Asynchronous evaluation: TRUE
[17:59:22.140] Local evaluation: TRUE
[17:59:22.140] Environment: R_GlobalEnv
[17:59:22.140] Capture standard output: TRUE
[17:59:22.140] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:22.140] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:22.140] Packages: <none>
[17:59:22.140] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:22.140] Resolved: FALSE
[17:59:22.140] Value: <not collected>
[17:59:22.140] Conditions captured: <none>
[17:59:22.140] Early signaling: FALSE
[17:59:22.140] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:22.140] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.153] Chunk #1 of 2 ... DONE
[17:59:22.153] Chunk #2 of 2 ...
[17:59:22.153]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:22.154]  - seeds: <none>
[17:59:22.154]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.154] getGlobalsAndPackages() ...
[17:59:22.154] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.154] Resolving globals: FALSE
[17:59:22.155] Tweak future expression to call with '...' arguments ...
[17:59:22.155] {
[17:59:22.155]     do.call(function(...) {
[17:59:22.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.155]             on.exit(options(oopts), add = TRUE)
[17:59:22.155]         }
[17:59:22.155]         {
[17:59:22.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.155]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.155]             })
[17:59:22.155]         }
[17:59:22.155]     }, args = future.call.arguments)
[17:59:22.155] }
[17:59:22.155] Tweak future expression to call with '...' arguments ... DONE
[17:59:22.156] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.156] 
[17:59:22.157] getGlobalsAndPackages() ... DONE
[17:59:22.157] run() for ‘Future’ ...
[17:59:22.157] - state: ‘created’
[17:59:22.158] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:22.182] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.183] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:22.183]   - Field: ‘node’
[17:59:22.183]   - Field: ‘label’
[17:59:22.183]   - Field: ‘local’
[17:59:22.184]   - Field: ‘owner’
[17:59:22.184]   - Field: ‘envir’
[17:59:22.184]   - Field: ‘workers’
[17:59:22.184]   - Field: ‘packages’
[17:59:22.184]   - Field: ‘gc’
[17:59:22.185]   - Field: ‘conditions’
[17:59:22.185]   - Field: ‘persistent’
[17:59:22.185]   - Field: ‘expr’
[17:59:22.185]   - Field: ‘uuid’
[17:59:22.185]   - Field: ‘seed’
[17:59:22.186]   - Field: ‘version’
[17:59:22.186]   - Field: ‘result’
[17:59:22.186]   - Field: ‘asynchronous’
[17:59:22.186]   - Field: ‘calls’
[17:59:22.186]   - Field: ‘globals’
[17:59:22.187]   - Field: ‘stdout’
[17:59:22.187]   - Field: ‘earlySignal’
[17:59:22.187]   - Field: ‘lazy’
[17:59:22.187]   - Field: ‘state’
[17:59:22.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:22.188] - Launch lazy future ...
[17:59:22.188] Packages needed by the future expression (n = 0): <none>
[17:59:22.188] Packages needed by future strategies (n = 0): <none>
[17:59:22.189] {
[17:59:22.189]     {
[17:59:22.189]         {
[17:59:22.189]             ...future.startTime <- base::Sys.time()
[17:59:22.189]             {
[17:59:22.189]                 {
[17:59:22.189]                   {
[17:59:22.189]                     {
[17:59:22.189]                       base::local({
[17:59:22.189]                         has_future <- base::requireNamespace("future", 
[17:59:22.189]                           quietly = TRUE)
[17:59:22.189]                         if (has_future) {
[17:59:22.189]                           ns <- base::getNamespace("future")
[17:59:22.189]                           version <- ns[[".package"]][["version"]]
[17:59:22.189]                           if (is.null(version)) 
[17:59:22.189]                             version <- utils::packageVersion("future")
[17:59:22.189]                         }
[17:59:22.189]                         else {
[17:59:22.189]                           version <- NULL
[17:59:22.189]                         }
[17:59:22.189]                         if (!has_future || version < "1.8.0") {
[17:59:22.189]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:22.189]                             "", base::R.version$version.string), 
[17:59:22.189]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:22.189]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:22.189]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:22.189]                               "release", "version")], collapse = " "), 
[17:59:22.189]                             hostname = base::Sys.info()[["nodename"]])
[17:59:22.189]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:22.189]                             info)
[17:59:22.189]                           info <- base::paste(info, collapse = "; ")
[17:59:22.189]                           if (!has_future) {
[17:59:22.189]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:22.189]                               info)
[17:59:22.189]                           }
[17:59:22.189]                           else {
[17:59:22.189]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:22.189]                               info, version)
[17:59:22.189]                           }
[17:59:22.189]                           base::stop(msg)
[17:59:22.189]                         }
[17:59:22.189]                       })
[17:59:22.189]                     }
[17:59:22.189]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:22.189]                     base::options(mc.cores = 1L)
[17:59:22.189]                   }
[17:59:22.189]                   ...future.strategy.old <- future::plan("list")
[17:59:22.189]                   options(future.plan = NULL)
[17:59:22.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:22.189]                 }
[17:59:22.189]                 ...future.workdir <- getwd()
[17:59:22.189]             }
[17:59:22.189]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:22.189]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:22.189]         }
[17:59:22.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:22.189]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:22.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:22.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:22.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:22.189]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:22.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:22.189]             base::names(...future.oldOptions))
[17:59:22.189]     }
[17:59:22.189]     if (FALSE) {
[17:59:22.189]     }
[17:59:22.189]     else {
[17:59:22.189]         if (TRUE) {
[17:59:22.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:22.189]                 open = "w")
[17:59:22.189]         }
[17:59:22.189]         else {
[17:59:22.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:22.189]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:22.189]         }
[17:59:22.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:22.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:22.189]             base::sink(type = "output", split = FALSE)
[17:59:22.189]             base::close(...future.stdout)
[17:59:22.189]         }, add = TRUE)
[17:59:22.189]     }
[17:59:22.189]     ...future.frame <- base::sys.nframe()
[17:59:22.189]     ...future.conditions <- base::list()
[17:59:22.189]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:22.189]     if (FALSE) {
[17:59:22.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:22.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:22.189]     }
[17:59:22.189]     ...future.result <- base::tryCatch({
[17:59:22.189]         base::withCallingHandlers({
[17:59:22.189]             ...future.value <- base::withVisible(base::local({
[17:59:22.189]                 ...future.makeSendCondition <- base::local({
[17:59:22.189]                   sendCondition <- NULL
[17:59:22.189]                   function(frame = 1L) {
[17:59:22.189]                     if (is.function(sendCondition)) 
[17:59:22.189]                       return(sendCondition)
[17:59:22.189]                     ns <- getNamespace("parallel")
[17:59:22.189]                     if (exists("sendData", mode = "function", 
[17:59:22.189]                       envir = ns)) {
[17:59:22.189]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:22.189]                         envir = ns)
[17:59:22.189]                       envir <- sys.frame(frame)
[17:59:22.189]                       master <- NULL
[17:59:22.189]                       while (!identical(envir, .GlobalEnv) && 
[17:59:22.189]                         !identical(envir, emptyenv())) {
[17:59:22.189]                         if (exists("master", mode = "list", envir = envir, 
[17:59:22.189]                           inherits = FALSE)) {
[17:59:22.189]                           master <- get("master", mode = "list", 
[17:59:22.189]                             envir = envir, inherits = FALSE)
[17:59:22.189]                           if (inherits(master, c("SOCKnode", 
[17:59:22.189]                             "SOCK0node"))) {
[17:59:22.189]                             sendCondition <<- function(cond) {
[17:59:22.189]                               data <- list(type = "VALUE", value = cond, 
[17:59:22.189]                                 success = TRUE)
[17:59:22.189]                               parallel_sendData(master, data)
[17:59:22.189]                             }
[17:59:22.189]                             return(sendCondition)
[17:59:22.189]                           }
[17:59:22.189]                         }
[17:59:22.189]                         frame <- frame + 1L
[17:59:22.189]                         envir <- sys.frame(frame)
[17:59:22.189]                       }
[17:59:22.189]                     }
[17:59:22.189]                     sendCondition <<- function(cond) NULL
[17:59:22.189]                   }
[17:59:22.189]                 })
[17:59:22.189]                 withCallingHandlers({
[17:59:22.189]                   {
[17:59:22.189]                     do.call(function(...) {
[17:59:22.189]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.189]                       if (!identical(...future.globals.maxSize.org, 
[17:59:22.189]                         ...future.globals.maxSize)) {
[17:59:22.189]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.189]                         on.exit(options(oopts), add = TRUE)
[17:59:22.189]                       }
[17:59:22.189]                       {
[17:59:22.189]                         lapply(seq_along(...future.elements_ii), 
[17:59:22.189]                           FUN = function(jj) {
[17:59:22.189]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.189]                             ...future.FUN(...future.X_jj, ...)
[17:59:22.189]                           })
[17:59:22.189]                       }
[17:59:22.189]                     }, args = future.call.arguments)
[17:59:22.189]                   }
[17:59:22.189]                 }, immediateCondition = function(cond) {
[17:59:22.189]                   sendCondition <- ...future.makeSendCondition()
[17:59:22.189]                   sendCondition(cond)
[17:59:22.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.189]                   {
[17:59:22.189]                     inherits <- base::inherits
[17:59:22.189]                     invokeRestart <- base::invokeRestart
[17:59:22.189]                     is.null <- base::is.null
[17:59:22.189]                     muffled <- FALSE
[17:59:22.189]                     if (inherits(cond, "message")) {
[17:59:22.189]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:22.189]                       if (muffled) 
[17:59:22.189]                         invokeRestart("muffleMessage")
[17:59:22.189]                     }
[17:59:22.189]                     else if (inherits(cond, "warning")) {
[17:59:22.189]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:22.189]                       if (muffled) 
[17:59:22.189]                         invokeRestart("muffleWarning")
[17:59:22.189]                     }
[17:59:22.189]                     else if (inherits(cond, "condition")) {
[17:59:22.189]                       if (!is.null(pattern)) {
[17:59:22.189]                         computeRestarts <- base::computeRestarts
[17:59:22.189]                         grepl <- base::grepl
[17:59:22.189]                         restarts <- computeRestarts(cond)
[17:59:22.189]                         for (restart in restarts) {
[17:59:22.189]                           name <- restart$name
[17:59:22.189]                           if (is.null(name)) 
[17:59:22.189]                             next
[17:59:22.189]                           if (!grepl(pattern, name)) 
[17:59:22.189]                             next
[17:59:22.189]                           invokeRestart(restart)
[17:59:22.189]                           muffled <- TRUE
[17:59:22.189]                           break
[17:59:22.189]                         }
[17:59:22.189]                       }
[17:59:22.189]                     }
[17:59:22.189]                     invisible(muffled)
[17:59:22.189]                   }
[17:59:22.189]                   muffleCondition(cond)
[17:59:22.189]                 })
[17:59:22.189]             }))
[17:59:22.189]             future::FutureResult(value = ...future.value$value, 
[17:59:22.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.189]                   ...future.rng), globalenv = if (FALSE) 
[17:59:22.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:22.189]                     ...future.globalenv.names))
[17:59:22.189]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:22.189]         }, condition = base::local({
[17:59:22.189]             c <- base::c
[17:59:22.189]             inherits <- base::inherits
[17:59:22.189]             invokeRestart <- base::invokeRestart
[17:59:22.189]             length <- base::length
[17:59:22.189]             list <- base::list
[17:59:22.189]             seq.int <- base::seq.int
[17:59:22.189]             signalCondition <- base::signalCondition
[17:59:22.189]             sys.calls <- base::sys.calls
[17:59:22.189]             `[[` <- base::`[[`
[17:59:22.189]             `+` <- base::`+`
[17:59:22.189]             `<<-` <- base::`<<-`
[17:59:22.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:22.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:22.189]                   3L)]
[17:59:22.189]             }
[17:59:22.189]             function(cond) {
[17:59:22.189]                 is_error <- inherits(cond, "error")
[17:59:22.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:22.189]                   NULL)
[17:59:22.189]                 if (is_error) {
[17:59:22.189]                   sessionInformation <- function() {
[17:59:22.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:22.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:22.189]                       search = base::search(), system = base::Sys.info())
[17:59:22.189]                   }
[17:59:22.189]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:22.189]                     cond$call), session = sessionInformation(), 
[17:59:22.189]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:22.189]                   signalCondition(cond)
[17:59:22.189]                 }
[17:59:22.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:22.189]                 "immediateCondition"))) {
[17:59:22.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:22.189]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:22.189]                   if (TRUE && !signal) {
[17:59:22.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.189]                     {
[17:59:22.189]                       inherits <- base::inherits
[17:59:22.189]                       invokeRestart <- base::invokeRestart
[17:59:22.189]                       is.null <- base::is.null
[17:59:22.189]                       muffled <- FALSE
[17:59:22.189]                       if (inherits(cond, "message")) {
[17:59:22.189]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.189]                         if (muffled) 
[17:59:22.189]                           invokeRestart("muffleMessage")
[17:59:22.189]                       }
[17:59:22.189]                       else if (inherits(cond, "warning")) {
[17:59:22.189]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.189]                         if (muffled) 
[17:59:22.189]                           invokeRestart("muffleWarning")
[17:59:22.189]                       }
[17:59:22.189]                       else if (inherits(cond, "condition")) {
[17:59:22.189]                         if (!is.null(pattern)) {
[17:59:22.189]                           computeRestarts <- base::computeRestarts
[17:59:22.189]                           grepl <- base::grepl
[17:59:22.189]                           restarts <- computeRestarts(cond)
[17:59:22.189]                           for (restart in restarts) {
[17:59:22.189]                             name <- restart$name
[17:59:22.189]                             if (is.null(name)) 
[17:59:22.189]                               next
[17:59:22.189]                             if (!grepl(pattern, name)) 
[17:59:22.189]                               next
[17:59:22.189]                             invokeRestart(restart)
[17:59:22.189]                             muffled <- TRUE
[17:59:22.189]                             break
[17:59:22.189]                           }
[17:59:22.189]                         }
[17:59:22.189]                       }
[17:59:22.189]                       invisible(muffled)
[17:59:22.189]                     }
[17:59:22.189]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.189]                   }
[17:59:22.189]                 }
[17:59:22.189]                 else {
[17:59:22.189]                   if (TRUE) {
[17:59:22.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.189]                     {
[17:59:22.189]                       inherits <- base::inherits
[17:59:22.189]                       invokeRestart <- base::invokeRestart
[17:59:22.189]                       is.null <- base::is.null
[17:59:22.189]                       muffled <- FALSE
[17:59:22.189]                       if (inherits(cond, "message")) {
[17:59:22.189]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.189]                         if (muffled) 
[17:59:22.189]                           invokeRestart("muffleMessage")
[17:59:22.189]                       }
[17:59:22.189]                       else if (inherits(cond, "warning")) {
[17:59:22.189]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.189]                         if (muffled) 
[17:59:22.189]                           invokeRestart("muffleWarning")
[17:59:22.189]                       }
[17:59:22.189]                       else if (inherits(cond, "condition")) {
[17:59:22.189]                         if (!is.null(pattern)) {
[17:59:22.189]                           computeRestarts <- base::computeRestarts
[17:59:22.189]                           grepl <- base::grepl
[17:59:22.189]                           restarts <- computeRestarts(cond)
[17:59:22.189]                           for (restart in restarts) {
[17:59:22.189]                             name <- restart$name
[17:59:22.189]                             if (is.null(name)) 
[17:59:22.189]                               next
[17:59:22.189]                             if (!grepl(pattern, name)) 
[17:59:22.189]                               next
[17:59:22.189]                             invokeRestart(restart)
[17:59:22.189]                             muffled <- TRUE
[17:59:22.189]                             break
[17:59:22.189]                           }
[17:59:22.189]                         }
[17:59:22.189]                       }
[17:59:22.189]                       invisible(muffled)
[17:59:22.189]                     }
[17:59:22.189]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.189]                   }
[17:59:22.189]                 }
[17:59:22.189]             }
[17:59:22.189]         }))
[17:59:22.189]     }, error = function(ex) {
[17:59:22.189]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:22.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.189]                 ...future.rng), started = ...future.startTime, 
[17:59:22.189]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:22.189]             version = "1.8"), class = "FutureResult")
[17:59:22.189]     }, finally = {
[17:59:22.189]         if (!identical(...future.workdir, getwd())) 
[17:59:22.189]             setwd(...future.workdir)
[17:59:22.189]         {
[17:59:22.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:22.189]                 ...future.oldOptions$nwarnings <- NULL
[17:59:22.189]             }
[17:59:22.189]             base::options(...future.oldOptions)
[17:59:22.189]             if (.Platform$OS.type == "windows") {
[17:59:22.189]                 old_names <- names(...future.oldEnvVars)
[17:59:22.189]                 envs <- base::Sys.getenv()
[17:59:22.189]                 names <- names(envs)
[17:59:22.189]                 common <- intersect(names, old_names)
[17:59:22.189]                 added <- setdiff(names, old_names)
[17:59:22.189]                 removed <- setdiff(old_names, names)
[17:59:22.189]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:22.189]                   envs[common]]
[17:59:22.189]                 NAMES <- toupper(changed)
[17:59:22.189]                 args <- list()
[17:59:22.189]                 for (kk in seq_along(NAMES)) {
[17:59:22.189]                   name <- changed[[kk]]
[17:59:22.189]                   NAME <- NAMES[[kk]]
[17:59:22.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.189]                     next
[17:59:22.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.189]                 }
[17:59:22.189]                 NAMES <- toupper(added)
[17:59:22.189]                 for (kk in seq_along(NAMES)) {
[17:59:22.189]                   name <- added[[kk]]
[17:59:22.189]                   NAME <- NAMES[[kk]]
[17:59:22.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.189]                     next
[17:59:22.189]                   args[[name]] <- ""
[17:59:22.189]                 }
[17:59:22.189]                 NAMES <- toupper(removed)
[17:59:22.189]                 for (kk in seq_along(NAMES)) {
[17:59:22.189]                   name <- removed[[kk]]
[17:59:22.189]                   NAME <- NAMES[[kk]]
[17:59:22.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.189]                     next
[17:59:22.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.189]                 }
[17:59:22.189]                 if (length(args) > 0) 
[17:59:22.189]                   base::do.call(base::Sys.setenv, args = args)
[17:59:22.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:22.189]             }
[17:59:22.189]             else {
[17:59:22.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:22.189]             }
[17:59:22.189]             {
[17:59:22.189]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:22.189]                   0L) {
[17:59:22.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:22.189]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:22.189]                   base::options(opts)
[17:59:22.189]                 }
[17:59:22.189]                 {
[17:59:22.189]                   {
[17:59:22.189]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:22.189]                     NULL
[17:59:22.189]                   }
[17:59:22.189]                   options(future.plan = NULL)
[17:59:22.189]                   if (is.na(NA_character_)) 
[17:59:22.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:22.189]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:22.189]                     .init = FALSE)
[17:59:22.189]                 }
[17:59:22.189]             }
[17:59:22.189]         }
[17:59:22.189]     })
[17:59:22.189]     if (TRUE) {
[17:59:22.189]         base::sink(type = "output", split = FALSE)
[17:59:22.189]         if (TRUE) {
[17:59:22.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:22.189]         }
[17:59:22.189]         else {
[17:59:22.189]             ...future.result["stdout"] <- base::list(NULL)
[17:59:22.189]         }
[17:59:22.189]         base::close(...future.stdout)
[17:59:22.189]         ...future.stdout <- NULL
[17:59:22.189]     }
[17:59:22.189]     ...future.result$conditions <- ...future.conditions
[17:59:22.189]     ...future.result$finished <- base::Sys.time()
[17:59:22.189]     ...future.result
[17:59:22.189] }
[17:59:22.195] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[17:59:22.195] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:22.196] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:22.197] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:59:22.198] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:59:22.198] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:59:22.199] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:59:22.199] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:22.200] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:22.200] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:59:22.201] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:59:22.201] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[17:59:22.202] MultisessionFuture started
[17:59:22.203] - Launch lazy future ... done
[17:59:22.203] run() for ‘MultisessionFuture’ ... done
[17:59:22.203] Created future:
[17:59:22.203] MultisessionFuture:
[17:59:22.203] Label: ‘future_apply-2’
[17:59:22.203] Expression:
[17:59:22.203] {
[17:59:22.203]     do.call(function(...) {
[17:59:22.203]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.203]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.203]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.203]             on.exit(options(oopts), add = TRUE)
[17:59:22.203]         }
[17:59:22.203]         {
[17:59:22.203]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.203]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.203]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.203]             })
[17:59:22.203]         }
[17:59:22.203]     }, args = future.call.arguments)
[17:59:22.203] }
[17:59:22.203] Lazy evaluation: FALSE
[17:59:22.203] Asynchronous evaluation: TRUE
[17:59:22.203] Local evaluation: TRUE
[17:59:22.203] Environment: R_GlobalEnv
[17:59:22.203] Capture standard output: TRUE
[17:59:22.203] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:22.203] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:22.203] Packages: <none>
[17:59:22.203] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:22.203] Resolved: FALSE
[17:59:22.203] Value: <not collected>
[17:59:22.203] Conditions captured: <none>
[17:59:22.203] Early signaling: FALSE
[17:59:22.203] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:22.203] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.216] Chunk #2 of 2 ... DONE
[17:59:22.216] Launching 2 futures (chunks) ... DONE
[17:59:22.216] Resolving 2 futures (chunks) ...
[17:59:22.217] resolve() on list ...
[17:59:22.217]  recursive: 0
[17:59:22.217]  length: 2
[17:59:22.217] 
[17:59:22.218] receiveMessageFromWorker() for ClusterFuture ...
[17:59:22.218] - Validating connection of MultisessionFuture
[17:59:22.219] - received message: FutureResult
[17:59:22.219] - Received FutureResult
[17:59:22.219] - Erased future from FutureRegistry
[17:59:22.219] result() for ClusterFuture ...
[17:59:22.220] - result already collected: FutureResult
[17:59:22.220] result() for ClusterFuture ... done
[17:59:22.220] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:22.220] Future #1
[17:59:22.220] result() for ClusterFuture ...
[17:59:22.221] - result already collected: FutureResult
[17:59:22.221] result() for ClusterFuture ... done
[17:59:22.221] result() for ClusterFuture ...
[17:59:22.221] - result already collected: FutureResult
[17:59:22.221] result() for ClusterFuture ... done
[17:59:22.222] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:22.222] - nx: 2
[17:59:22.222] - relay: TRUE
[17:59:22.222] - stdout: TRUE
[17:59:22.222] - signal: TRUE
[17:59:22.222] - resignal: FALSE
[17:59:22.223] - force: TRUE
[17:59:22.223] - relayed: [n=2] FALSE, FALSE
[17:59:22.223] - queued futures: [n=2] FALSE, FALSE
[17:59:22.223]  - until=1
[17:59:22.223]  - relaying element #1
[17:59:22.224] result() for ClusterFuture ...
[17:59:22.224] - result already collected: FutureResult
[17:59:22.224] result() for ClusterFuture ... done
[17:59:22.224] result() for ClusterFuture ...
[17:59:22.224] - result already collected: FutureResult
[17:59:22.224] result() for ClusterFuture ... done
[17:59:22.225] result() for ClusterFuture ...
[17:59:22.225] - result already collected: FutureResult
[17:59:22.225] result() for ClusterFuture ... done
[17:59:22.225] result() for ClusterFuture ...
[17:59:22.225] - result already collected: FutureResult
[17:59:22.226] result() for ClusterFuture ... done
[17:59:22.226] - relayed: [n=2] TRUE, FALSE
[17:59:22.226] - queued futures: [n=2] TRUE, FALSE
[17:59:22.226] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:22.226]  length: 1 (resolved future 1)
[17:59:22.248] receiveMessageFromWorker() for ClusterFuture ...
[17:59:22.249] - Validating connection of MultisessionFuture
[17:59:22.249] - received message: FutureResult
[17:59:22.249] - Received FutureResult
[17:59:22.249] - Erased future from FutureRegistry
[17:59:22.250] result() for ClusterFuture ...
[17:59:22.250] - result already collected: FutureResult
[17:59:22.250] result() for ClusterFuture ... done
[17:59:22.250] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:22.250] Future #2
[17:59:22.251] result() for ClusterFuture ...
[17:59:22.251] - result already collected: FutureResult
[17:59:22.251] result() for ClusterFuture ... done
[17:59:22.251] result() for ClusterFuture ...
[17:59:22.251] - result already collected: FutureResult
[17:59:22.251] result() for ClusterFuture ... done
[17:59:22.252] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:22.252] - nx: 2
[17:59:22.252] - relay: TRUE
[17:59:22.252] - stdout: TRUE
[17:59:22.252] - signal: TRUE
[17:59:22.253] - resignal: FALSE
[17:59:22.253] - force: TRUE
[17:59:22.253] - relayed: [n=2] TRUE, FALSE
[17:59:22.253] - queued futures: [n=2] TRUE, FALSE
[17:59:22.253]  - until=2
[17:59:22.254]  - relaying element #2
[17:59:22.254] result() for ClusterFuture ...
[17:59:22.254] - result already collected: FutureResult
[17:59:22.254] result() for ClusterFuture ... done
[17:59:22.254] result() for ClusterFuture ...
[17:59:22.254] - result already collected: FutureResult
[17:59:22.255] result() for ClusterFuture ... done
[17:59:22.255] result() for ClusterFuture ...
[17:59:22.255] - result already collected: FutureResult
[17:59:22.255] result() for ClusterFuture ... done
[17:59:22.255] result() for ClusterFuture ...
[17:59:22.256] - result already collected: FutureResult
[17:59:22.256] result() for ClusterFuture ... done
[17:59:22.256] - relayed: [n=2] TRUE, TRUE
[17:59:22.256] - queued futures: [n=2] TRUE, TRUE
[17:59:22.256] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:22.257]  length: 0 (resolved future 2)
[17:59:22.257] Relaying remaining futures
[17:59:22.257] signalConditionsASAP(NULL, pos=0) ...
[17:59:22.257] - nx: 2
[17:59:22.257] - relay: TRUE
[17:59:22.257] - stdout: TRUE
[17:59:22.258] - signal: TRUE
[17:59:22.258] - resignal: FALSE
[17:59:22.258] - force: TRUE
[17:59:22.258] - relayed: [n=2] TRUE, TRUE
[17:59:22.258] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:22.259] - relayed: [n=2] TRUE, TRUE
[17:59:22.259] - queued futures: [n=2] TRUE, TRUE
[17:59:22.259] signalConditionsASAP(NULL, pos=0) ... done
[17:59:22.259] resolve() on list ... DONE
[17:59:22.259] result() for ClusterFuture ...
[17:59:22.259] - result already collected: FutureResult
[17:59:22.260] result() for ClusterFuture ... done
[17:59:22.260] result() for ClusterFuture ...
[17:59:22.260] - result already collected: FutureResult
[17:59:22.260] result() for ClusterFuture ... done
[17:59:22.260] result() for ClusterFuture ...
[17:59:22.261] - result already collected: FutureResult
[17:59:22.261] result() for ClusterFuture ... done
[17:59:22.261] result() for ClusterFuture ...
[17:59:22.261] - result already collected: FutureResult
[17:59:22.261] result() for ClusterFuture ... done
[17:59:22.262]  - Number of value chunks collected: 2
[17:59:22.262] Resolving 2 futures (chunks) ... DONE
[17:59:22.262] Reducing values from 2 chunks ...
[17:59:22.262]  - Number of values collected after concatenation: 2
[17:59:22.262]  - Number of values expected: 2
[17:59:22.262] Reducing values from 2 chunks ... DONE
[17:59:22.263] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:59:22.263] getGlobalsAndPackagesXApply() ...
[17:59:22.263]  - future.globals: TRUE
[17:59:22.264] getGlobalsAndPackages() ...
[17:59:22.264] Searching for globals...
[17:59:22.266] - globals found: [1] ‘FUN’
[17:59:22.266] Searching for globals ... DONE
[17:59:22.266] Resolving globals: FALSE
[17:59:22.267] The total size of the 1 globals is 848 bytes (848 bytes)
[17:59:22.267] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:59:22.268] - globals: [1] ‘FUN’
[17:59:22.268] 
[17:59:22.268] getGlobalsAndPackages() ... DONE
[17:59:22.268]  - globals found/used: [n=1] ‘FUN’
[17:59:22.268]  - needed namespaces: [n=0] 
[17:59:22.269] Finding globals ... DONE
[17:59:22.269]  - use_args: TRUE
[17:59:22.269]  - Getting '...' globals ...
[17:59:22.270] resolve() on list ...
[17:59:22.270]  recursive: 0
[17:59:22.270]  length: 1
[17:59:22.270]  elements: ‘...’
[17:59:22.270]  length: 0 (resolved future 1)
[17:59:22.271] resolve() on list ... DONE
[17:59:22.271]    - '...' content: [n=0] 
[17:59:22.271] List of 1
[17:59:22.271]  $ ...: list()
[17:59:22.271]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.271]  - attr(*, "where")=List of 1
[17:59:22.271]   ..$ ...:<environment: 0x56085cc9e490> 
[17:59:22.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.271]  - attr(*, "resolved")= logi TRUE
[17:59:22.271]  - attr(*, "total_size")= num NA
[17:59:22.276]  - Getting '...' globals ... DONE
[17:59:22.276] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:22.276] List of 2
[17:59:22.276]  $ ...future.FUN:function (x)  
[17:59:22.276]  $ ...          : list()
[17:59:22.276]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.276]  - attr(*, "where")=List of 2
[17:59:22.276]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:22.276]   ..$ ...          :<environment: 0x56085cc9e490> 
[17:59:22.276]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.276]  - attr(*, "resolved")= logi FALSE
[17:59:22.276]  - attr(*, "total_size")= num 848
[17:59:22.282] Packages to be attached in all futures: [n=0] 
[17:59:22.282] getGlobalsAndPackagesXApply() ... DONE
[17:59:22.288] future_lapply() ...
[17:59:22.295] Number of chunks: 2
[17:59:22.295] getGlobalsAndPackagesXApply() ...
[17:59:22.295]  - future.globals: <name-value list> with names ‘list()’
[17:59:22.295]  - use_args: TRUE
[17:59:22.296] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:22.296] List of 2
[17:59:22.296]  $ ...          : list()
[17:59:22.296]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.296]  $ ...future.FUN:function (x)  
[17:59:22.296]  - attr(*, "where")=List of 2
[17:59:22.296]   ..$ ...          :<environment: 0x56085cc9e490> 
[17:59:22.296]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:22.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.296]  - attr(*, "resolved")= logi FALSE
[17:59:22.296]  - attr(*, "total_size")= num NA
[17:59:22.303] Packages to be attached in all futures: [n=0] 
[17:59:22.303] getGlobalsAndPackagesXApply() ... DONE
[17:59:22.303] Number of futures (= number of chunks): 2
[17:59:22.303] Launching 2 futures (chunks) ...
[17:59:22.304] Chunk #1 of 2 ...
[17:59:22.304]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:22.304]  - seeds: <none>
[17:59:22.304]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.304] getGlobalsAndPackages() ...
[17:59:22.305] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.305] Resolving globals: FALSE
[17:59:22.305] Tweak future expression to call with '...' arguments ...
[17:59:22.305] {
[17:59:22.305]     do.call(function(...) {
[17:59:22.305]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.305]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.305]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.305]             on.exit(options(oopts), add = TRUE)
[17:59:22.305]         }
[17:59:22.305]         {
[17:59:22.305]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.305]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.305]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.305]             })
[17:59:22.305]         }
[17:59:22.305]     }, args = future.call.arguments)
[17:59:22.305] }
[17:59:22.306] Tweak future expression to call with '...' arguments ... DONE
[17:59:22.307] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.307] 
[17:59:22.307] getGlobalsAndPackages() ... DONE
[17:59:22.308] run() for ‘Future’ ...
[17:59:22.308] - state: ‘created’
[17:59:22.308] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:22.334] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:22.334]   - Field: ‘node’
[17:59:22.334]   - Field: ‘label’
[17:59:22.334]   - Field: ‘local’
[17:59:22.335]   - Field: ‘owner’
[17:59:22.335]   - Field: ‘envir’
[17:59:22.335]   - Field: ‘workers’
[17:59:22.335]   - Field: ‘packages’
[17:59:22.335]   - Field: ‘gc’
[17:59:22.336]   - Field: ‘conditions’
[17:59:22.336]   - Field: ‘persistent’
[17:59:22.336]   - Field: ‘expr’
[17:59:22.336]   - Field: ‘uuid’
[17:59:22.336]   - Field: ‘seed’
[17:59:22.337]   - Field: ‘version’
[17:59:22.337]   - Field: ‘result’
[17:59:22.337]   - Field: ‘asynchronous’
[17:59:22.337]   - Field: ‘calls’
[17:59:22.337]   - Field: ‘globals’
[17:59:22.338]   - Field: ‘stdout’
[17:59:22.338]   - Field: ‘earlySignal’
[17:59:22.338]   - Field: ‘lazy’
[17:59:22.338]   - Field: ‘state’
[17:59:22.338] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:22.339] - Launch lazy future ...
[17:59:22.339] Packages needed by the future expression (n = 0): <none>
[17:59:22.339] Packages needed by future strategies (n = 0): <none>
[17:59:22.340] {
[17:59:22.340]     {
[17:59:22.340]         {
[17:59:22.340]             ...future.startTime <- base::Sys.time()
[17:59:22.340]             {
[17:59:22.340]                 {
[17:59:22.340]                   {
[17:59:22.340]                     {
[17:59:22.340]                       base::local({
[17:59:22.340]                         has_future <- base::requireNamespace("future", 
[17:59:22.340]                           quietly = TRUE)
[17:59:22.340]                         if (has_future) {
[17:59:22.340]                           ns <- base::getNamespace("future")
[17:59:22.340]                           version <- ns[[".package"]][["version"]]
[17:59:22.340]                           if (is.null(version)) 
[17:59:22.340]                             version <- utils::packageVersion("future")
[17:59:22.340]                         }
[17:59:22.340]                         else {
[17:59:22.340]                           version <- NULL
[17:59:22.340]                         }
[17:59:22.340]                         if (!has_future || version < "1.8.0") {
[17:59:22.340]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:22.340]                             "", base::R.version$version.string), 
[17:59:22.340]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:22.340]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:22.340]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:22.340]                               "release", "version")], collapse = " "), 
[17:59:22.340]                             hostname = base::Sys.info()[["nodename"]])
[17:59:22.340]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:22.340]                             info)
[17:59:22.340]                           info <- base::paste(info, collapse = "; ")
[17:59:22.340]                           if (!has_future) {
[17:59:22.340]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:22.340]                               info)
[17:59:22.340]                           }
[17:59:22.340]                           else {
[17:59:22.340]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:22.340]                               info, version)
[17:59:22.340]                           }
[17:59:22.340]                           base::stop(msg)
[17:59:22.340]                         }
[17:59:22.340]                       })
[17:59:22.340]                     }
[17:59:22.340]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:22.340]                     base::options(mc.cores = 1L)
[17:59:22.340]                   }
[17:59:22.340]                   ...future.strategy.old <- future::plan("list")
[17:59:22.340]                   options(future.plan = NULL)
[17:59:22.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:22.340]                 }
[17:59:22.340]                 ...future.workdir <- getwd()
[17:59:22.340]             }
[17:59:22.340]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:22.340]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:22.340]         }
[17:59:22.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:22.340]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:22.340]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:22.340]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:22.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:22.340]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:22.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:22.340]             base::names(...future.oldOptions))
[17:59:22.340]     }
[17:59:22.340]     if (FALSE) {
[17:59:22.340]     }
[17:59:22.340]     else {
[17:59:22.340]         if (TRUE) {
[17:59:22.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:22.340]                 open = "w")
[17:59:22.340]         }
[17:59:22.340]         else {
[17:59:22.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:22.340]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:22.340]         }
[17:59:22.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:22.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:22.340]             base::sink(type = "output", split = FALSE)
[17:59:22.340]             base::close(...future.stdout)
[17:59:22.340]         }, add = TRUE)
[17:59:22.340]     }
[17:59:22.340]     ...future.frame <- base::sys.nframe()
[17:59:22.340]     ...future.conditions <- base::list()
[17:59:22.340]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:22.340]     if (FALSE) {
[17:59:22.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:22.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:22.340]     }
[17:59:22.340]     ...future.result <- base::tryCatch({
[17:59:22.340]         base::withCallingHandlers({
[17:59:22.340]             ...future.value <- base::withVisible(base::local({
[17:59:22.340]                 ...future.makeSendCondition <- base::local({
[17:59:22.340]                   sendCondition <- NULL
[17:59:22.340]                   function(frame = 1L) {
[17:59:22.340]                     if (is.function(sendCondition)) 
[17:59:22.340]                       return(sendCondition)
[17:59:22.340]                     ns <- getNamespace("parallel")
[17:59:22.340]                     if (exists("sendData", mode = "function", 
[17:59:22.340]                       envir = ns)) {
[17:59:22.340]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:22.340]                         envir = ns)
[17:59:22.340]                       envir <- sys.frame(frame)
[17:59:22.340]                       master <- NULL
[17:59:22.340]                       while (!identical(envir, .GlobalEnv) && 
[17:59:22.340]                         !identical(envir, emptyenv())) {
[17:59:22.340]                         if (exists("master", mode = "list", envir = envir, 
[17:59:22.340]                           inherits = FALSE)) {
[17:59:22.340]                           master <- get("master", mode = "list", 
[17:59:22.340]                             envir = envir, inherits = FALSE)
[17:59:22.340]                           if (inherits(master, c("SOCKnode", 
[17:59:22.340]                             "SOCK0node"))) {
[17:59:22.340]                             sendCondition <<- function(cond) {
[17:59:22.340]                               data <- list(type = "VALUE", value = cond, 
[17:59:22.340]                                 success = TRUE)
[17:59:22.340]                               parallel_sendData(master, data)
[17:59:22.340]                             }
[17:59:22.340]                             return(sendCondition)
[17:59:22.340]                           }
[17:59:22.340]                         }
[17:59:22.340]                         frame <- frame + 1L
[17:59:22.340]                         envir <- sys.frame(frame)
[17:59:22.340]                       }
[17:59:22.340]                     }
[17:59:22.340]                     sendCondition <<- function(cond) NULL
[17:59:22.340]                   }
[17:59:22.340]                 })
[17:59:22.340]                 withCallingHandlers({
[17:59:22.340]                   {
[17:59:22.340]                     do.call(function(...) {
[17:59:22.340]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.340]                       if (!identical(...future.globals.maxSize.org, 
[17:59:22.340]                         ...future.globals.maxSize)) {
[17:59:22.340]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.340]                         on.exit(options(oopts), add = TRUE)
[17:59:22.340]                       }
[17:59:22.340]                       {
[17:59:22.340]                         lapply(seq_along(...future.elements_ii), 
[17:59:22.340]                           FUN = function(jj) {
[17:59:22.340]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.340]                             ...future.FUN(...future.X_jj, ...)
[17:59:22.340]                           })
[17:59:22.340]                       }
[17:59:22.340]                     }, args = future.call.arguments)
[17:59:22.340]                   }
[17:59:22.340]                 }, immediateCondition = function(cond) {
[17:59:22.340]                   sendCondition <- ...future.makeSendCondition()
[17:59:22.340]                   sendCondition(cond)
[17:59:22.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.340]                   {
[17:59:22.340]                     inherits <- base::inherits
[17:59:22.340]                     invokeRestart <- base::invokeRestart
[17:59:22.340]                     is.null <- base::is.null
[17:59:22.340]                     muffled <- FALSE
[17:59:22.340]                     if (inherits(cond, "message")) {
[17:59:22.340]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:22.340]                       if (muffled) 
[17:59:22.340]                         invokeRestart("muffleMessage")
[17:59:22.340]                     }
[17:59:22.340]                     else if (inherits(cond, "warning")) {
[17:59:22.340]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:22.340]                       if (muffled) 
[17:59:22.340]                         invokeRestart("muffleWarning")
[17:59:22.340]                     }
[17:59:22.340]                     else if (inherits(cond, "condition")) {
[17:59:22.340]                       if (!is.null(pattern)) {
[17:59:22.340]                         computeRestarts <- base::computeRestarts
[17:59:22.340]                         grepl <- base::grepl
[17:59:22.340]                         restarts <- computeRestarts(cond)
[17:59:22.340]                         for (restart in restarts) {
[17:59:22.340]                           name <- restart$name
[17:59:22.340]                           if (is.null(name)) 
[17:59:22.340]                             next
[17:59:22.340]                           if (!grepl(pattern, name)) 
[17:59:22.340]                             next
[17:59:22.340]                           invokeRestart(restart)
[17:59:22.340]                           muffled <- TRUE
[17:59:22.340]                           break
[17:59:22.340]                         }
[17:59:22.340]                       }
[17:59:22.340]                     }
[17:59:22.340]                     invisible(muffled)
[17:59:22.340]                   }
[17:59:22.340]                   muffleCondition(cond)
[17:59:22.340]                 })
[17:59:22.340]             }))
[17:59:22.340]             future::FutureResult(value = ...future.value$value, 
[17:59:22.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.340]                   ...future.rng), globalenv = if (FALSE) 
[17:59:22.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:22.340]                     ...future.globalenv.names))
[17:59:22.340]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:22.340]         }, condition = base::local({
[17:59:22.340]             c <- base::c
[17:59:22.340]             inherits <- base::inherits
[17:59:22.340]             invokeRestart <- base::invokeRestart
[17:59:22.340]             length <- base::length
[17:59:22.340]             list <- base::list
[17:59:22.340]             seq.int <- base::seq.int
[17:59:22.340]             signalCondition <- base::signalCondition
[17:59:22.340]             sys.calls <- base::sys.calls
[17:59:22.340]             `[[` <- base::`[[`
[17:59:22.340]             `+` <- base::`+`
[17:59:22.340]             `<<-` <- base::`<<-`
[17:59:22.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:22.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:22.340]                   3L)]
[17:59:22.340]             }
[17:59:22.340]             function(cond) {
[17:59:22.340]                 is_error <- inherits(cond, "error")
[17:59:22.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:22.340]                   NULL)
[17:59:22.340]                 if (is_error) {
[17:59:22.340]                   sessionInformation <- function() {
[17:59:22.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:22.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:22.340]                       search = base::search(), system = base::Sys.info())
[17:59:22.340]                   }
[17:59:22.340]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:22.340]                     cond$call), session = sessionInformation(), 
[17:59:22.340]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:22.340]                   signalCondition(cond)
[17:59:22.340]                 }
[17:59:22.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:22.340]                 "immediateCondition"))) {
[17:59:22.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:22.340]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:22.340]                   if (TRUE && !signal) {
[17:59:22.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.340]                     {
[17:59:22.340]                       inherits <- base::inherits
[17:59:22.340]                       invokeRestart <- base::invokeRestart
[17:59:22.340]                       is.null <- base::is.null
[17:59:22.340]                       muffled <- FALSE
[17:59:22.340]                       if (inherits(cond, "message")) {
[17:59:22.340]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.340]                         if (muffled) 
[17:59:22.340]                           invokeRestart("muffleMessage")
[17:59:22.340]                       }
[17:59:22.340]                       else if (inherits(cond, "warning")) {
[17:59:22.340]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.340]                         if (muffled) 
[17:59:22.340]                           invokeRestart("muffleWarning")
[17:59:22.340]                       }
[17:59:22.340]                       else if (inherits(cond, "condition")) {
[17:59:22.340]                         if (!is.null(pattern)) {
[17:59:22.340]                           computeRestarts <- base::computeRestarts
[17:59:22.340]                           grepl <- base::grepl
[17:59:22.340]                           restarts <- computeRestarts(cond)
[17:59:22.340]                           for (restart in restarts) {
[17:59:22.340]                             name <- restart$name
[17:59:22.340]                             if (is.null(name)) 
[17:59:22.340]                               next
[17:59:22.340]                             if (!grepl(pattern, name)) 
[17:59:22.340]                               next
[17:59:22.340]                             invokeRestart(restart)
[17:59:22.340]                             muffled <- TRUE
[17:59:22.340]                             break
[17:59:22.340]                           }
[17:59:22.340]                         }
[17:59:22.340]                       }
[17:59:22.340]                       invisible(muffled)
[17:59:22.340]                     }
[17:59:22.340]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.340]                   }
[17:59:22.340]                 }
[17:59:22.340]                 else {
[17:59:22.340]                   if (TRUE) {
[17:59:22.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.340]                     {
[17:59:22.340]                       inherits <- base::inherits
[17:59:22.340]                       invokeRestart <- base::invokeRestart
[17:59:22.340]                       is.null <- base::is.null
[17:59:22.340]                       muffled <- FALSE
[17:59:22.340]                       if (inherits(cond, "message")) {
[17:59:22.340]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.340]                         if (muffled) 
[17:59:22.340]                           invokeRestart("muffleMessage")
[17:59:22.340]                       }
[17:59:22.340]                       else if (inherits(cond, "warning")) {
[17:59:22.340]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.340]                         if (muffled) 
[17:59:22.340]                           invokeRestart("muffleWarning")
[17:59:22.340]                       }
[17:59:22.340]                       else if (inherits(cond, "condition")) {
[17:59:22.340]                         if (!is.null(pattern)) {
[17:59:22.340]                           computeRestarts <- base::computeRestarts
[17:59:22.340]                           grepl <- base::grepl
[17:59:22.340]                           restarts <- computeRestarts(cond)
[17:59:22.340]                           for (restart in restarts) {
[17:59:22.340]                             name <- restart$name
[17:59:22.340]                             if (is.null(name)) 
[17:59:22.340]                               next
[17:59:22.340]                             if (!grepl(pattern, name)) 
[17:59:22.340]                               next
[17:59:22.340]                             invokeRestart(restart)
[17:59:22.340]                             muffled <- TRUE
[17:59:22.340]                             break
[17:59:22.340]                           }
[17:59:22.340]                         }
[17:59:22.340]                       }
[17:59:22.340]                       invisible(muffled)
[17:59:22.340]                     }
[17:59:22.340]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.340]                   }
[17:59:22.340]                 }
[17:59:22.340]             }
[17:59:22.340]         }))
[17:59:22.340]     }, error = function(ex) {
[17:59:22.340]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:22.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.340]                 ...future.rng), started = ...future.startTime, 
[17:59:22.340]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:22.340]             version = "1.8"), class = "FutureResult")
[17:59:22.340]     }, finally = {
[17:59:22.340]         if (!identical(...future.workdir, getwd())) 
[17:59:22.340]             setwd(...future.workdir)
[17:59:22.340]         {
[17:59:22.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:22.340]                 ...future.oldOptions$nwarnings <- NULL
[17:59:22.340]             }
[17:59:22.340]             base::options(...future.oldOptions)
[17:59:22.340]             if (.Platform$OS.type == "windows") {
[17:59:22.340]                 old_names <- names(...future.oldEnvVars)
[17:59:22.340]                 envs <- base::Sys.getenv()
[17:59:22.340]                 names <- names(envs)
[17:59:22.340]                 common <- intersect(names, old_names)
[17:59:22.340]                 added <- setdiff(names, old_names)
[17:59:22.340]                 removed <- setdiff(old_names, names)
[17:59:22.340]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:22.340]                   envs[common]]
[17:59:22.340]                 NAMES <- toupper(changed)
[17:59:22.340]                 args <- list()
[17:59:22.340]                 for (kk in seq_along(NAMES)) {
[17:59:22.340]                   name <- changed[[kk]]
[17:59:22.340]                   NAME <- NAMES[[kk]]
[17:59:22.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.340]                     next
[17:59:22.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.340]                 }
[17:59:22.340]                 NAMES <- toupper(added)
[17:59:22.340]                 for (kk in seq_along(NAMES)) {
[17:59:22.340]                   name <- added[[kk]]
[17:59:22.340]                   NAME <- NAMES[[kk]]
[17:59:22.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.340]                     next
[17:59:22.340]                   args[[name]] <- ""
[17:59:22.340]                 }
[17:59:22.340]                 NAMES <- toupper(removed)
[17:59:22.340]                 for (kk in seq_along(NAMES)) {
[17:59:22.340]                   name <- removed[[kk]]
[17:59:22.340]                   NAME <- NAMES[[kk]]
[17:59:22.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.340]                     next
[17:59:22.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.340]                 }
[17:59:22.340]                 if (length(args) > 0) 
[17:59:22.340]                   base::do.call(base::Sys.setenv, args = args)
[17:59:22.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:22.340]             }
[17:59:22.340]             else {
[17:59:22.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:22.340]             }
[17:59:22.340]             {
[17:59:22.340]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:22.340]                   0L) {
[17:59:22.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:22.340]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:22.340]                   base::options(opts)
[17:59:22.340]                 }
[17:59:22.340]                 {
[17:59:22.340]                   {
[17:59:22.340]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:22.340]                     NULL
[17:59:22.340]                   }
[17:59:22.340]                   options(future.plan = NULL)
[17:59:22.340]                   if (is.na(NA_character_)) 
[17:59:22.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:22.340]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:22.340]                     .init = FALSE)
[17:59:22.340]                 }
[17:59:22.340]             }
[17:59:22.340]         }
[17:59:22.340]     })
[17:59:22.340]     if (TRUE) {
[17:59:22.340]         base::sink(type = "output", split = FALSE)
[17:59:22.340]         if (TRUE) {
[17:59:22.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:22.340]         }
[17:59:22.340]         else {
[17:59:22.340]             ...future.result["stdout"] <- base::list(NULL)
[17:59:22.340]         }
[17:59:22.340]         base::close(...future.stdout)
[17:59:22.340]         ...future.stdout <- NULL
[17:59:22.340]     }
[17:59:22.340]     ...future.result$conditions <- ...future.conditions
[17:59:22.340]     ...future.result$finished <- base::Sys.time()
[17:59:22.340]     ...future.result
[17:59:22.340] }
[17:59:22.347] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[17:59:22.348] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:22.349] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:22.349] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:59:22.350] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:59:22.350] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[17:59:22.351] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[17:59:22.351] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:22.352] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:22.352] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:59:22.353] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:59:22.353] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[17:59:22.354] MultisessionFuture started
[17:59:22.355] - Launch lazy future ... done
[17:59:22.355] run() for ‘MultisessionFuture’ ... done
[17:59:22.355] Created future:
[17:59:22.355] MultisessionFuture:
[17:59:22.355] Label: ‘future_apply-1’
[17:59:22.355] Expression:
[17:59:22.355] {
[17:59:22.355]     do.call(function(...) {
[17:59:22.355]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.355]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.355]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.355]             on.exit(options(oopts), add = TRUE)
[17:59:22.355]         }
[17:59:22.355]         {
[17:59:22.355]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.355]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.355]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.355]             })
[17:59:22.355]         }
[17:59:22.355]     }, args = future.call.arguments)
[17:59:22.355] }
[17:59:22.355] Lazy evaluation: FALSE
[17:59:22.355] Asynchronous evaluation: TRUE
[17:59:22.355] Local evaluation: TRUE
[17:59:22.355] Environment: R_GlobalEnv
[17:59:22.355] Capture standard output: TRUE
[17:59:22.355] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:22.355] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:22.355] Packages: <none>
[17:59:22.355] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:22.355] Resolved: FALSE
[17:59:22.355] Value: <not collected>
[17:59:22.355] Conditions captured: <none>
[17:59:22.355] Early signaling: FALSE
[17:59:22.355] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:22.355] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.368] Chunk #1 of 2 ... DONE
[17:59:22.368] Chunk #2 of 2 ...
[17:59:22.369]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:22.369]  - seeds: <none>
[17:59:22.369]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.370] getGlobalsAndPackages() ...
[17:59:22.370] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.370] Resolving globals: FALSE
[17:59:22.370] Tweak future expression to call with '...' arguments ...
[17:59:22.370] {
[17:59:22.370]     do.call(function(...) {
[17:59:22.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.370]             on.exit(options(oopts), add = TRUE)
[17:59:22.370]         }
[17:59:22.370]         {
[17:59:22.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.370]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.370]             })
[17:59:22.370]         }
[17:59:22.370]     }, args = future.call.arguments)
[17:59:22.370] }
[17:59:22.371] Tweak future expression to call with '...' arguments ... DONE
[17:59:22.372] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.372] 
[17:59:22.372] getGlobalsAndPackages() ... DONE
[17:59:22.373] run() for ‘Future’ ...
[17:59:22.373] - state: ‘created’
[17:59:22.373] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:22.396] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.397] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:22.397]   - Field: ‘node’
[17:59:22.397]   - Field: ‘label’
[17:59:22.397]   - Field: ‘local’
[17:59:22.398]   - Field: ‘owner’
[17:59:22.398]   - Field: ‘envir’
[17:59:22.398]   - Field: ‘workers’
[17:59:22.398]   - Field: ‘packages’
[17:59:22.398]   - Field: ‘gc’
[17:59:22.399]   - Field: ‘conditions’
[17:59:22.399]   - Field: ‘persistent’
[17:59:22.399]   - Field: ‘expr’
[17:59:22.399]   - Field: ‘uuid’
[17:59:22.399]   - Field: ‘seed’
[17:59:22.400]   - Field: ‘version’
[17:59:22.400]   - Field: ‘result’
[17:59:22.400]   - Field: ‘asynchronous’
[17:59:22.400]   - Field: ‘calls’
[17:59:22.400]   - Field: ‘globals’
[17:59:22.401]   - Field: ‘stdout’
[17:59:22.401]   - Field: ‘earlySignal’
[17:59:22.401]   - Field: ‘lazy’
[17:59:22.401]   - Field: ‘state’
[17:59:22.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:22.402] - Launch lazy future ...
[17:59:22.402] Packages needed by the future expression (n = 0): <none>
[17:59:22.402] Packages needed by future strategies (n = 0): <none>
[17:59:22.403] {
[17:59:22.403]     {
[17:59:22.403]         {
[17:59:22.403]             ...future.startTime <- base::Sys.time()
[17:59:22.403]             {
[17:59:22.403]                 {
[17:59:22.403]                   {
[17:59:22.403]                     {
[17:59:22.403]                       base::local({
[17:59:22.403]                         has_future <- base::requireNamespace("future", 
[17:59:22.403]                           quietly = TRUE)
[17:59:22.403]                         if (has_future) {
[17:59:22.403]                           ns <- base::getNamespace("future")
[17:59:22.403]                           version <- ns[[".package"]][["version"]]
[17:59:22.403]                           if (is.null(version)) 
[17:59:22.403]                             version <- utils::packageVersion("future")
[17:59:22.403]                         }
[17:59:22.403]                         else {
[17:59:22.403]                           version <- NULL
[17:59:22.403]                         }
[17:59:22.403]                         if (!has_future || version < "1.8.0") {
[17:59:22.403]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:22.403]                             "", base::R.version$version.string), 
[17:59:22.403]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:22.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:22.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:22.403]                               "release", "version")], collapse = " "), 
[17:59:22.403]                             hostname = base::Sys.info()[["nodename"]])
[17:59:22.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:22.403]                             info)
[17:59:22.403]                           info <- base::paste(info, collapse = "; ")
[17:59:22.403]                           if (!has_future) {
[17:59:22.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:22.403]                               info)
[17:59:22.403]                           }
[17:59:22.403]                           else {
[17:59:22.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:22.403]                               info, version)
[17:59:22.403]                           }
[17:59:22.403]                           base::stop(msg)
[17:59:22.403]                         }
[17:59:22.403]                       })
[17:59:22.403]                     }
[17:59:22.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:22.403]                     base::options(mc.cores = 1L)
[17:59:22.403]                   }
[17:59:22.403]                   ...future.strategy.old <- future::plan("list")
[17:59:22.403]                   options(future.plan = NULL)
[17:59:22.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:22.403]                 }
[17:59:22.403]                 ...future.workdir <- getwd()
[17:59:22.403]             }
[17:59:22.403]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:22.403]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:22.403]         }
[17:59:22.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:22.403]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:22.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:22.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:22.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:22.403]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:22.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:22.403]             base::names(...future.oldOptions))
[17:59:22.403]     }
[17:59:22.403]     if (FALSE) {
[17:59:22.403]     }
[17:59:22.403]     else {
[17:59:22.403]         if (TRUE) {
[17:59:22.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:22.403]                 open = "w")
[17:59:22.403]         }
[17:59:22.403]         else {
[17:59:22.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:22.403]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:22.403]         }
[17:59:22.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:22.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:22.403]             base::sink(type = "output", split = FALSE)
[17:59:22.403]             base::close(...future.stdout)
[17:59:22.403]         }, add = TRUE)
[17:59:22.403]     }
[17:59:22.403]     ...future.frame <- base::sys.nframe()
[17:59:22.403]     ...future.conditions <- base::list()
[17:59:22.403]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:22.403]     if (FALSE) {
[17:59:22.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:22.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:22.403]     }
[17:59:22.403]     ...future.result <- base::tryCatch({
[17:59:22.403]         base::withCallingHandlers({
[17:59:22.403]             ...future.value <- base::withVisible(base::local({
[17:59:22.403]                 ...future.makeSendCondition <- base::local({
[17:59:22.403]                   sendCondition <- NULL
[17:59:22.403]                   function(frame = 1L) {
[17:59:22.403]                     if (is.function(sendCondition)) 
[17:59:22.403]                       return(sendCondition)
[17:59:22.403]                     ns <- getNamespace("parallel")
[17:59:22.403]                     if (exists("sendData", mode = "function", 
[17:59:22.403]                       envir = ns)) {
[17:59:22.403]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:22.403]                         envir = ns)
[17:59:22.403]                       envir <- sys.frame(frame)
[17:59:22.403]                       master <- NULL
[17:59:22.403]                       while (!identical(envir, .GlobalEnv) && 
[17:59:22.403]                         !identical(envir, emptyenv())) {
[17:59:22.403]                         if (exists("master", mode = "list", envir = envir, 
[17:59:22.403]                           inherits = FALSE)) {
[17:59:22.403]                           master <- get("master", mode = "list", 
[17:59:22.403]                             envir = envir, inherits = FALSE)
[17:59:22.403]                           if (inherits(master, c("SOCKnode", 
[17:59:22.403]                             "SOCK0node"))) {
[17:59:22.403]                             sendCondition <<- function(cond) {
[17:59:22.403]                               data <- list(type = "VALUE", value = cond, 
[17:59:22.403]                                 success = TRUE)
[17:59:22.403]                               parallel_sendData(master, data)
[17:59:22.403]                             }
[17:59:22.403]                             return(sendCondition)
[17:59:22.403]                           }
[17:59:22.403]                         }
[17:59:22.403]                         frame <- frame + 1L
[17:59:22.403]                         envir <- sys.frame(frame)
[17:59:22.403]                       }
[17:59:22.403]                     }
[17:59:22.403]                     sendCondition <<- function(cond) NULL
[17:59:22.403]                   }
[17:59:22.403]                 })
[17:59:22.403]                 withCallingHandlers({
[17:59:22.403]                   {
[17:59:22.403]                     do.call(function(...) {
[17:59:22.403]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.403]                       if (!identical(...future.globals.maxSize.org, 
[17:59:22.403]                         ...future.globals.maxSize)) {
[17:59:22.403]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.403]                         on.exit(options(oopts), add = TRUE)
[17:59:22.403]                       }
[17:59:22.403]                       {
[17:59:22.403]                         lapply(seq_along(...future.elements_ii), 
[17:59:22.403]                           FUN = function(jj) {
[17:59:22.403]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.403]                             ...future.FUN(...future.X_jj, ...)
[17:59:22.403]                           })
[17:59:22.403]                       }
[17:59:22.403]                     }, args = future.call.arguments)
[17:59:22.403]                   }
[17:59:22.403]                 }, immediateCondition = function(cond) {
[17:59:22.403]                   sendCondition <- ...future.makeSendCondition()
[17:59:22.403]                   sendCondition(cond)
[17:59:22.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.403]                   {
[17:59:22.403]                     inherits <- base::inherits
[17:59:22.403]                     invokeRestart <- base::invokeRestart
[17:59:22.403]                     is.null <- base::is.null
[17:59:22.403]                     muffled <- FALSE
[17:59:22.403]                     if (inherits(cond, "message")) {
[17:59:22.403]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:22.403]                       if (muffled) 
[17:59:22.403]                         invokeRestart("muffleMessage")
[17:59:22.403]                     }
[17:59:22.403]                     else if (inherits(cond, "warning")) {
[17:59:22.403]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:22.403]                       if (muffled) 
[17:59:22.403]                         invokeRestart("muffleWarning")
[17:59:22.403]                     }
[17:59:22.403]                     else if (inherits(cond, "condition")) {
[17:59:22.403]                       if (!is.null(pattern)) {
[17:59:22.403]                         computeRestarts <- base::computeRestarts
[17:59:22.403]                         grepl <- base::grepl
[17:59:22.403]                         restarts <- computeRestarts(cond)
[17:59:22.403]                         for (restart in restarts) {
[17:59:22.403]                           name <- restart$name
[17:59:22.403]                           if (is.null(name)) 
[17:59:22.403]                             next
[17:59:22.403]                           if (!grepl(pattern, name)) 
[17:59:22.403]                             next
[17:59:22.403]                           invokeRestart(restart)
[17:59:22.403]                           muffled <- TRUE
[17:59:22.403]                           break
[17:59:22.403]                         }
[17:59:22.403]                       }
[17:59:22.403]                     }
[17:59:22.403]                     invisible(muffled)
[17:59:22.403]                   }
[17:59:22.403]                   muffleCondition(cond)
[17:59:22.403]                 })
[17:59:22.403]             }))
[17:59:22.403]             future::FutureResult(value = ...future.value$value, 
[17:59:22.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.403]                   ...future.rng), globalenv = if (FALSE) 
[17:59:22.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:22.403]                     ...future.globalenv.names))
[17:59:22.403]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:22.403]         }, condition = base::local({
[17:59:22.403]             c <- base::c
[17:59:22.403]             inherits <- base::inherits
[17:59:22.403]             invokeRestart <- base::invokeRestart
[17:59:22.403]             length <- base::length
[17:59:22.403]             list <- base::list
[17:59:22.403]             seq.int <- base::seq.int
[17:59:22.403]             signalCondition <- base::signalCondition
[17:59:22.403]             sys.calls <- base::sys.calls
[17:59:22.403]             `[[` <- base::`[[`
[17:59:22.403]             `+` <- base::`+`
[17:59:22.403]             `<<-` <- base::`<<-`
[17:59:22.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:22.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:22.403]                   3L)]
[17:59:22.403]             }
[17:59:22.403]             function(cond) {
[17:59:22.403]                 is_error <- inherits(cond, "error")
[17:59:22.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:22.403]                   NULL)
[17:59:22.403]                 if (is_error) {
[17:59:22.403]                   sessionInformation <- function() {
[17:59:22.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:22.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:22.403]                       search = base::search(), system = base::Sys.info())
[17:59:22.403]                   }
[17:59:22.403]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:22.403]                     cond$call), session = sessionInformation(), 
[17:59:22.403]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:22.403]                   signalCondition(cond)
[17:59:22.403]                 }
[17:59:22.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:22.403]                 "immediateCondition"))) {
[17:59:22.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:22.403]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:22.403]                   if (TRUE && !signal) {
[17:59:22.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.403]                     {
[17:59:22.403]                       inherits <- base::inherits
[17:59:22.403]                       invokeRestart <- base::invokeRestart
[17:59:22.403]                       is.null <- base::is.null
[17:59:22.403]                       muffled <- FALSE
[17:59:22.403]                       if (inherits(cond, "message")) {
[17:59:22.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.403]                         if (muffled) 
[17:59:22.403]                           invokeRestart("muffleMessage")
[17:59:22.403]                       }
[17:59:22.403]                       else if (inherits(cond, "warning")) {
[17:59:22.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.403]                         if (muffled) 
[17:59:22.403]                           invokeRestart("muffleWarning")
[17:59:22.403]                       }
[17:59:22.403]                       else if (inherits(cond, "condition")) {
[17:59:22.403]                         if (!is.null(pattern)) {
[17:59:22.403]                           computeRestarts <- base::computeRestarts
[17:59:22.403]                           grepl <- base::grepl
[17:59:22.403]                           restarts <- computeRestarts(cond)
[17:59:22.403]                           for (restart in restarts) {
[17:59:22.403]                             name <- restart$name
[17:59:22.403]                             if (is.null(name)) 
[17:59:22.403]                               next
[17:59:22.403]                             if (!grepl(pattern, name)) 
[17:59:22.403]                               next
[17:59:22.403]                             invokeRestart(restart)
[17:59:22.403]                             muffled <- TRUE
[17:59:22.403]                             break
[17:59:22.403]                           }
[17:59:22.403]                         }
[17:59:22.403]                       }
[17:59:22.403]                       invisible(muffled)
[17:59:22.403]                     }
[17:59:22.403]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.403]                   }
[17:59:22.403]                 }
[17:59:22.403]                 else {
[17:59:22.403]                   if (TRUE) {
[17:59:22.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.403]                     {
[17:59:22.403]                       inherits <- base::inherits
[17:59:22.403]                       invokeRestart <- base::invokeRestart
[17:59:22.403]                       is.null <- base::is.null
[17:59:22.403]                       muffled <- FALSE
[17:59:22.403]                       if (inherits(cond, "message")) {
[17:59:22.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.403]                         if (muffled) 
[17:59:22.403]                           invokeRestart("muffleMessage")
[17:59:22.403]                       }
[17:59:22.403]                       else if (inherits(cond, "warning")) {
[17:59:22.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.403]                         if (muffled) 
[17:59:22.403]                           invokeRestart("muffleWarning")
[17:59:22.403]                       }
[17:59:22.403]                       else if (inherits(cond, "condition")) {
[17:59:22.403]                         if (!is.null(pattern)) {
[17:59:22.403]                           computeRestarts <- base::computeRestarts
[17:59:22.403]                           grepl <- base::grepl
[17:59:22.403]                           restarts <- computeRestarts(cond)
[17:59:22.403]                           for (restart in restarts) {
[17:59:22.403]                             name <- restart$name
[17:59:22.403]                             if (is.null(name)) 
[17:59:22.403]                               next
[17:59:22.403]                             if (!grepl(pattern, name)) 
[17:59:22.403]                               next
[17:59:22.403]                             invokeRestart(restart)
[17:59:22.403]                             muffled <- TRUE
[17:59:22.403]                             break
[17:59:22.403]                           }
[17:59:22.403]                         }
[17:59:22.403]                       }
[17:59:22.403]                       invisible(muffled)
[17:59:22.403]                     }
[17:59:22.403]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.403]                   }
[17:59:22.403]                 }
[17:59:22.403]             }
[17:59:22.403]         }))
[17:59:22.403]     }, error = function(ex) {
[17:59:22.403]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:22.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.403]                 ...future.rng), started = ...future.startTime, 
[17:59:22.403]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:22.403]             version = "1.8"), class = "FutureResult")
[17:59:22.403]     }, finally = {
[17:59:22.403]         if (!identical(...future.workdir, getwd())) 
[17:59:22.403]             setwd(...future.workdir)
[17:59:22.403]         {
[17:59:22.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:22.403]                 ...future.oldOptions$nwarnings <- NULL
[17:59:22.403]             }
[17:59:22.403]             base::options(...future.oldOptions)
[17:59:22.403]             if (.Platform$OS.type == "windows") {
[17:59:22.403]                 old_names <- names(...future.oldEnvVars)
[17:59:22.403]                 envs <- base::Sys.getenv()
[17:59:22.403]                 names <- names(envs)
[17:59:22.403]                 common <- intersect(names, old_names)
[17:59:22.403]                 added <- setdiff(names, old_names)
[17:59:22.403]                 removed <- setdiff(old_names, names)
[17:59:22.403]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:22.403]                   envs[common]]
[17:59:22.403]                 NAMES <- toupper(changed)
[17:59:22.403]                 args <- list()
[17:59:22.403]                 for (kk in seq_along(NAMES)) {
[17:59:22.403]                   name <- changed[[kk]]
[17:59:22.403]                   NAME <- NAMES[[kk]]
[17:59:22.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.403]                     next
[17:59:22.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.403]                 }
[17:59:22.403]                 NAMES <- toupper(added)
[17:59:22.403]                 for (kk in seq_along(NAMES)) {
[17:59:22.403]                   name <- added[[kk]]
[17:59:22.403]                   NAME <- NAMES[[kk]]
[17:59:22.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.403]                     next
[17:59:22.403]                   args[[name]] <- ""
[17:59:22.403]                 }
[17:59:22.403]                 NAMES <- toupper(removed)
[17:59:22.403]                 for (kk in seq_along(NAMES)) {
[17:59:22.403]                   name <- removed[[kk]]
[17:59:22.403]                   NAME <- NAMES[[kk]]
[17:59:22.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.403]                     next
[17:59:22.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.403]                 }
[17:59:22.403]                 if (length(args) > 0) 
[17:59:22.403]                   base::do.call(base::Sys.setenv, args = args)
[17:59:22.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:22.403]             }
[17:59:22.403]             else {
[17:59:22.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:22.403]             }
[17:59:22.403]             {
[17:59:22.403]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:22.403]                   0L) {
[17:59:22.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:22.403]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:22.403]                   base::options(opts)
[17:59:22.403]                 }
[17:59:22.403]                 {
[17:59:22.403]                   {
[17:59:22.403]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:22.403]                     NULL
[17:59:22.403]                   }
[17:59:22.403]                   options(future.plan = NULL)
[17:59:22.403]                   if (is.na(NA_character_)) 
[17:59:22.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:22.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:22.403]                     .init = FALSE)
[17:59:22.403]                 }
[17:59:22.403]             }
[17:59:22.403]         }
[17:59:22.403]     })
[17:59:22.403]     if (TRUE) {
[17:59:22.403]         base::sink(type = "output", split = FALSE)
[17:59:22.403]         if (TRUE) {
[17:59:22.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:22.403]         }
[17:59:22.403]         else {
[17:59:22.403]             ...future.result["stdout"] <- base::list(NULL)
[17:59:22.403]         }
[17:59:22.403]         base::close(...future.stdout)
[17:59:22.403]         ...future.stdout <- NULL
[17:59:22.403]     }
[17:59:22.403]     ...future.result$conditions <- ...future.conditions
[17:59:22.403]     ...future.result$finished <- base::Sys.time()
[17:59:22.403]     ...future.result
[17:59:22.403] }
[17:59:22.409] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[17:59:22.410] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:22.410] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:22.411] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:59:22.412] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:59:22.412] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[17:59:22.413] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[17:59:22.413] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:22.414] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:22.414] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:59:22.415] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:59:22.415] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[17:59:22.416] MultisessionFuture started
[17:59:22.418] - Launch lazy future ... done
[17:59:22.418] run() for ‘MultisessionFuture’ ... done
[17:59:22.418] Created future:
[17:59:22.418] MultisessionFuture:
[17:59:22.418] Label: ‘future_apply-2’
[17:59:22.418] Expression:
[17:59:22.418] {
[17:59:22.418]     do.call(function(...) {
[17:59:22.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.418]             on.exit(options(oopts), add = TRUE)
[17:59:22.418]         }
[17:59:22.418]         {
[17:59:22.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.418]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.418]             })
[17:59:22.418]         }
[17:59:22.418]     }, args = future.call.arguments)
[17:59:22.418] }
[17:59:22.418] Lazy evaluation: FALSE
[17:59:22.418] Asynchronous evaluation: TRUE
[17:59:22.418] Local evaluation: TRUE
[17:59:22.418] Environment: R_GlobalEnv
[17:59:22.418] Capture standard output: TRUE
[17:59:22.418] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:22.418] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:22.418] Packages: <none>
[17:59:22.418] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:22.418] Resolved: FALSE
[17:59:22.418] Value: <not collected>
[17:59:22.418] Conditions captured: <none>
[17:59:22.418] Early signaling: FALSE
[17:59:22.418] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:22.418] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.432] Chunk #2 of 2 ... DONE
[17:59:22.432] Launching 2 futures (chunks) ... DONE
[17:59:22.432] Resolving 2 futures (chunks) ...
[17:59:22.432] resolve() on list ...
[17:59:22.432]  recursive: 0
[17:59:22.433]  length: 2
[17:59:22.433] 
[17:59:22.434] receiveMessageFromWorker() for ClusterFuture ...
[17:59:22.434] - Validating connection of MultisessionFuture
[17:59:22.434] - received message: FutureResult
[17:59:22.435] - Received FutureResult
[17:59:22.435] - Erased future from FutureRegistry
[17:59:22.435] result() for ClusterFuture ...
[17:59:22.435] - result already collected: FutureResult
[17:59:22.435] result() for ClusterFuture ... done
[17:59:22.436] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:22.436] Future #1
[17:59:22.436] result() for ClusterFuture ...
[17:59:22.436] - result already collected: FutureResult
[17:59:22.436] result() for ClusterFuture ... done
[17:59:22.437] result() for ClusterFuture ...
[17:59:22.437] - result already collected: FutureResult
[17:59:22.437] result() for ClusterFuture ... done
[17:59:22.437] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:22.437] - nx: 2
[17:59:22.437] - relay: TRUE
[17:59:22.438] - stdout: TRUE
[17:59:22.438] - signal: TRUE
[17:59:22.438] - resignal: FALSE
[17:59:22.438] - force: TRUE
[17:59:22.438] - relayed: [n=2] FALSE, FALSE
[17:59:22.438] - queued futures: [n=2] FALSE, FALSE
[17:59:22.439]  - until=1
[17:59:22.439]  - relaying element #1
[17:59:22.439] result() for ClusterFuture ...
[17:59:22.439] - result already collected: FutureResult
[17:59:22.439] result() for ClusterFuture ... done
[17:59:22.440] result() for ClusterFuture ...
[17:59:22.440] - result already collected: FutureResult
[17:59:22.440] result() for ClusterFuture ... done
[17:59:22.440] result() for ClusterFuture ...
[17:59:22.440] - result already collected: FutureResult
[17:59:22.441] result() for ClusterFuture ... done
[17:59:22.441] result() for ClusterFuture ...
[17:59:22.441] - result already collected: FutureResult
[17:59:22.441] result() for ClusterFuture ... done
[17:59:22.441] - relayed: [n=2] TRUE, FALSE
[17:59:22.441] - queued futures: [n=2] TRUE, FALSE
[17:59:22.442] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:22.442]  length: 1 (resolved future 1)
[17:59:22.464] receiveMessageFromWorker() for ClusterFuture ...
[17:59:22.464] - Validating connection of MultisessionFuture
[17:59:22.464] - received message: FutureResult
[17:59:22.465] - Received FutureResult
[17:59:22.465] - Erased future from FutureRegistry
[17:59:22.465] result() for ClusterFuture ...
[17:59:22.465] - result already collected: FutureResult
[17:59:22.466] result() for ClusterFuture ... done
[17:59:22.466] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:22.466] Future #2
[17:59:22.466] result() for ClusterFuture ...
[17:59:22.466] - result already collected: FutureResult
[17:59:22.466] result() for ClusterFuture ... done
[17:59:22.467] result() for ClusterFuture ...
[17:59:22.467] - result already collected: FutureResult
[17:59:22.467] result() for ClusterFuture ... done
[17:59:22.467] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:22.467] - nx: 2
[17:59:22.468] - relay: TRUE
[17:59:22.468] - stdout: TRUE
[17:59:22.468] - signal: TRUE
[17:59:22.468] - resignal: FALSE
[17:59:22.468] - force: TRUE
[17:59:22.468] - relayed: [n=2] TRUE, FALSE
[17:59:22.469] - queued futures: [n=2] TRUE, FALSE
[17:59:22.469]  - until=2
[17:59:22.469]  - relaying element #2
[17:59:22.469] result() for ClusterFuture ...
[17:59:22.469] - result already collected: FutureResult
[17:59:22.470] result() for ClusterFuture ... done
[17:59:22.470] result() for ClusterFuture ...
[17:59:22.470] - result already collected: FutureResult
[17:59:22.470] result() for ClusterFuture ... done
[17:59:22.470] result() for ClusterFuture ...
[17:59:22.471] - result already collected: FutureResult
[17:59:22.471] result() for ClusterFuture ... done
[17:59:22.471] result() for ClusterFuture ...
[17:59:22.471] - result already collected: FutureResult
[17:59:22.471] result() for ClusterFuture ... done
[17:59:22.472] - relayed: [n=2] TRUE, TRUE
[17:59:22.472] - queued futures: [n=2] TRUE, TRUE
[17:59:22.472] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:22.472]  length: 0 (resolved future 2)
[17:59:22.472] Relaying remaining futures
[17:59:22.472] signalConditionsASAP(NULL, pos=0) ...
[17:59:22.473] - nx: 2
[17:59:22.473] - relay: TRUE
[17:59:22.473] - stdout: TRUE
[17:59:22.473] - signal: TRUE
[17:59:22.473] - resignal: FALSE
[17:59:22.473] - force: TRUE
[17:59:22.474] - relayed: [n=2] TRUE, TRUE
[17:59:22.474] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:22.474] - relayed: [n=2] TRUE, TRUE
[17:59:22.474] - queued futures: [n=2] TRUE, TRUE
[17:59:22.475] signalConditionsASAP(NULL, pos=0) ... done
[17:59:22.475] resolve() on list ... DONE
[17:59:22.475] result() for ClusterFuture ...
[17:59:22.475] - result already collected: FutureResult
[17:59:22.475] result() for ClusterFuture ... done
[17:59:22.475] result() for ClusterFuture ...
[17:59:22.476] - result already collected: FutureResult
[17:59:22.476] result() for ClusterFuture ... done
[17:59:22.476] result() for ClusterFuture ...
[17:59:22.476] - result already collected: FutureResult
[17:59:22.476] result() for ClusterFuture ... done
[17:59:22.477] result() for ClusterFuture ...
[17:59:22.477] - result already collected: FutureResult
[17:59:22.477] result() for ClusterFuture ... done
[17:59:22.477]  - Number of value chunks collected: 2
[17:59:22.477] Resolving 2 futures (chunks) ... DONE
[17:59:22.478] Reducing values from 2 chunks ...
[17:59:22.478]  - Number of values collected after concatenation: 2
[17:59:22.478]  - Number of values expected: 2
[17:59:22.478] Reducing values from 2 chunks ... DONE
[17:59:22.478] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:59:22.479] getGlobalsAndPackagesXApply() ...
[17:59:22.479]  - future.globals: TRUE
[17:59:22.479] getGlobalsAndPackages() ...
[17:59:22.479] Searching for globals...
[17:59:22.484] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:59:22.484] Searching for globals ... DONE
[17:59:22.485] Resolving globals: FALSE
[17:59:22.486] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:59:22.486] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:59:22.487] - globals: [1] ‘FUN’
[17:59:22.487] 
[17:59:22.487] getGlobalsAndPackages() ... DONE
[17:59:22.487]  - globals found/used: [n=1] ‘FUN’
[17:59:22.487]  - needed namespaces: [n=0] 
[17:59:22.488] Finding globals ... DONE
[17:59:22.488]  - use_args: TRUE
[17:59:22.488]  - Getting '...' globals ...
[17:59:22.489] resolve() on list ...
[17:59:22.489]  recursive: 0
[17:59:22.489]  length: 1
[17:59:22.489]  elements: ‘...’
[17:59:22.489]  length: 0 (resolved future 1)
[17:59:22.490] resolve() on list ... DONE
[17:59:22.490]    - '...' content: [n=0] 
[17:59:22.490] List of 1
[17:59:22.490]  $ ...: list()
[17:59:22.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.490]  - attr(*, "where")=List of 1
[17:59:22.490]   ..$ ...:<environment: 0x56085d6266f0> 
[17:59:22.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.490]  - attr(*, "resolved")= logi TRUE
[17:59:22.490]  - attr(*, "total_size")= num NA
[17:59:22.495]  - Getting '...' globals ... DONE
[17:59:22.495] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:22.495] List of 2
[17:59:22.495]  $ ...future.FUN:function (x)  
[17:59:22.495]  $ ...          : list()
[17:59:22.495]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.495]  - attr(*, "where")=List of 2
[17:59:22.495]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:22.495]   ..$ ...          :<environment: 0x56085d6266f0> 
[17:59:22.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.495]  - attr(*, "resolved")= logi FALSE
[17:59:22.495]  - attr(*, "total_size")= num 9888
[17:59:22.501] Packages to be attached in all futures: [n=0] 
[17:59:22.501] getGlobalsAndPackagesXApply() ... DONE
[17:59:22.507] future_lapply() ...
[17:59:22.515] Number of chunks: 2
[17:59:22.516] getGlobalsAndPackagesXApply() ...
[17:59:22.516]  - future.globals: <name-value list> with names ‘list()’
[17:59:22.516]  - use_args: TRUE
[17:59:22.516] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:22.517] List of 2
[17:59:22.517]  $ ...          : list()
[17:59:22.517]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.517]  $ ...future.FUN:function (x)  
[17:59:22.517]  - attr(*, "where")=List of 2
[17:59:22.517]   ..$ ...          :<environment: 0x56085d6266f0> 
[17:59:22.517]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:59:22.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.517]  - attr(*, "resolved")= logi FALSE
[17:59:22.517]  - attr(*, "total_size")= num NA
[17:59:22.522] Packages to be attached in all futures: [n=0] 
[17:59:22.522] getGlobalsAndPackagesXApply() ... DONE
[17:59:22.523] Number of futures (= number of chunks): 2
[17:59:22.523] Launching 2 futures (chunks) ...
[17:59:22.523] Chunk #1 of 2 ...
[17:59:22.523]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:22.524]  - seeds: <none>
[17:59:22.524]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.524] getGlobalsAndPackages() ...
[17:59:22.524] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.525] Resolving globals: FALSE
[17:59:22.525] Tweak future expression to call with '...' arguments ...
[17:59:22.525] {
[17:59:22.525]     do.call(function(...) {
[17:59:22.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.525]             on.exit(options(oopts), add = TRUE)
[17:59:22.525]         }
[17:59:22.525]         {
[17:59:22.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.525]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.525]             })
[17:59:22.525]         }
[17:59:22.525]     }, args = future.call.arguments)
[17:59:22.525] }
[17:59:22.525] Tweak future expression to call with '...' arguments ... DONE
[17:59:22.526] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.526] 
[17:59:22.527] getGlobalsAndPackages() ... DONE
[17:59:22.527] run() for ‘Future’ ...
[17:59:22.527] - state: ‘created’
[17:59:22.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:22.552] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:22.552]   - Field: ‘node’
[17:59:22.553]   - Field: ‘label’
[17:59:22.553]   - Field: ‘local’
[17:59:22.553]   - Field: ‘owner’
[17:59:22.553]   - Field: ‘envir’
[17:59:22.553]   - Field: ‘workers’
[17:59:22.554]   - Field: ‘packages’
[17:59:22.554]   - Field: ‘gc’
[17:59:22.554]   - Field: ‘conditions’
[17:59:22.554]   - Field: ‘persistent’
[17:59:22.554]   - Field: ‘expr’
[17:59:22.555]   - Field: ‘uuid’
[17:59:22.555]   - Field: ‘seed’
[17:59:22.555]   - Field: ‘version’
[17:59:22.555]   - Field: ‘result’
[17:59:22.555]   - Field: ‘asynchronous’
[17:59:22.556]   - Field: ‘calls’
[17:59:22.556]   - Field: ‘globals’
[17:59:22.556]   - Field: ‘stdout’
[17:59:22.556]   - Field: ‘earlySignal’
[17:59:22.556]   - Field: ‘lazy’
[17:59:22.556]   - Field: ‘state’
[17:59:22.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:22.557] - Launch lazy future ...
[17:59:22.557] Packages needed by the future expression (n = 0): <none>
[17:59:22.558] Packages needed by future strategies (n = 0): <none>
[17:59:22.559] {
[17:59:22.559]     {
[17:59:22.559]         {
[17:59:22.559]             ...future.startTime <- base::Sys.time()
[17:59:22.559]             {
[17:59:22.559]                 {
[17:59:22.559]                   {
[17:59:22.559]                     {
[17:59:22.559]                       base::local({
[17:59:22.559]                         has_future <- base::requireNamespace("future", 
[17:59:22.559]                           quietly = TRUE)
[17:59:22.559]                         if (has_future) {
[17:59:22.559]                           ns <- base::getNamespace("future")
[17:59:22.559]                           version <- ns[[".package"]][["version"]]
[17:59:22.559]                           if (is.null(version)) 
[17:59:22.559]                             version <- utils::packageVersion("future")
[17:59:22.559]                         }
[17:59:22.559]                         else {
[17:59:22.559]                           version <- NULL
[17:59:22.559]                         }
[17:59:22.559]                         if (!has_future || version < "1.8.0") {
[17:59:22.559]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:22.559]                             "", base::R.version$version.string), 
[17:59:22.559]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:22.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:22.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:22.559]                               "release", "version")], collapse = " "), 
[17:59:22.559]                             hostname = base::Sys.info()[["nodename"]])
[17:59:22.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:22.559]                             info)
[17:59:22.559]                           info <- base::paste(info, collapse = "; ")
[17:59:22.559]                           if (!has_future) {
[17:59:22.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:22.559]                               info)
[17:59:22.559]                           }
[17:59:22.559]                           else {
[17:59:22.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:22.559]                               info, version)
[17:59:22.559]                           }
[17:59:22.559]                           base::stop(msg)
[17:59:22.559]                         }
[17:59:22.559]                       })
[17:59:22.559]                     }
[17:59:22.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:22.559]                     base::options(mc.cores = 1L)
[17:59:22.559]                   }
[17:59:22.559]                   ...future.strategy.old <- future::plan("list")
[17:59:22.559]                   options(future.plan = NULL)
[17:59:22.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:22.559]                 }
[17:59:22.559]                 ...future.workdir <- getwd()
[17:59:22.559]             }
[17:59:22.559]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:22.559]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:22.559]         }
[17:59:22.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:22.559]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:22.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:22.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:22.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:22.559]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:22.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:22.559]             base::names(...future.oldOptions))
[17:59:22.559]     }
[17:59:22.559]     if (FALSE) {
[17:59:22.559]     }
[17:59:22.559]     else {
[17:59:22.559]         if (TRUE) {
[17:59:22.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:22.559]                 open = "w")
[17:59:22.559]         }
[17:59:22.559]         else {
[17:59:22.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:22.559]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:22.559]         }
[17:59:22.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:22.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:22.559]             base::sink(type = "output", split = FALSE)
[17:59:22.559]             base::close(...future.stdout)
[17:59:22.559]         }, add = TRUE)
[17:59:22.559]     }
[17:59:22.559]     ...future.frame <- base::sys.nframe()
[17:59:22.559]     ...future.conditions <- base::list()
[17:59:22.559]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:22.559]     if (FALSE) {
[17:59:22.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:22.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:22.559]     }
[17:59:22.559]     ...future.result <- base::tryCatch({
[17:59:22.559]         base::withCallingHandlers({
[17:59:22.559]             ...future.value <- base::withVisible(base::local({
[17:59:22.559]                 ...future.makeSendCondition <- base::local({
[17:59:22.559]                   sendCondition <- NULL
[17:59:22.559]                   function(frame = 1L) {
[17:59:22.559]                     if (is.function(sendCondition)) 
[17:59:22.559]                       return(sendCondition)
[17:59:22.559]                     ns <- getNamespace("parallel")
[17:59:22.559]                     if (exists("sendData", mode = "function", 
[17:59:22.559]                       envir = ns)) {
[17:59:22.559]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:22.559]                         envir = ns)
[17:59:22.559]                       envir <- sys.frame(frame)
[17:59:22.559]                       master <- NULL
[17:59:22.559]                       while (!identical(envir, .GlobalEnv) && 
[17:59:22.559]                         !identical(envir, emptyenv())) {
[17:59:22.559]                         if (exists("master", mode = "list", envir = envir, 
[17:59:22.559]                           inherits = FALSE)) {
[17:59:22.559]                           master <- get("master", mode = "list", 
[17:59:22.559]                             envir = envir, inherits = FALSE)
[17:59:22.559]                           if (inherits(master, c("SOCKnode", 
[17:59:22.559]                             "SOCK0node"))) {
[17:59:22.559]                             sendCondition <<- function(cond) {
[17:59:22.559]                               data <- list(type = "VALUE", value = cond, 
[17:59:22.559]                                 success = TRUE)
[17:59:22.559]                               parallel_sendData(master, data)
[17:59:22.559]                             }
[17:59:22.559]                             return(sendCondition)
[17:59:22.559]                           }
[17:59:22.559]                         }
[17:59:22.559]                         frame <- frame + 1L
[17:59:22.559]                         envir <- sys.frame(frame)
[17:59:22.559]                       }
[17:59:22.559]                     }
[17:59:22.559]                     sendCondition <<- function(cond) NULL
[17:59:22.559]                   }
[17:59:22.559]                 })
[17:59:22.559]                 withCallingHandlers({
[17:59:22.559]                   {
[17:59:22.559]                     do.call(function(...) {
[17:59:22.559]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.559]                       if (!identical(...future.globals.maxSize.org, 
[17:59:22.559]                         ...future.globals.maxSize)) {
[17:59:22.559]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.559]                         on.exit(options(oopts), add = TRUE)
[17:59:22.559]                       }
[17:59:22.559]                       {
[17:59:22.559]                         lapply(seq_along(...future.elements_ii), 
[17:59:22.559]                           FUN = function(jj) {
[17:59:22.559]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.559]                             ...future.FUN(...future.X_jj, ...)
[17:59:22.559]                           })
[17:59:22.559]                       }
[17:59:22.559]                     }, args = future.call.arguments)
[17:59:22.559]                   }
[17:59:22.559]                 }, immediateCondition = function(cond) {
[17:59:22.559]                   sendCondition <- ...future.makeSendCondition()
[17:59:22.559]                   sendCondition(cond)
[17:59:22.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.559]                   {
[17:59:22.559]                     inherits <- base::inherits
[17:59:22.559]                     invokeRestart <- base::invokeRestart
[17:59:22.559]                     is.null <- base::is.null
[17:59:22.559]                     muffled <- FALSE
[17:59:22.559]                     if (inherits(cond, "message")) {
[17:59:22.559]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:22.559]                       if (muffled) 
[17:59:22.559]                         invokeRestart("muffleMessage")
[17:59:22.559]                     }
[17:59:22.559]                     else if (inherits(cond, "warning")) {
[17:59:22.559]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:22.559]                       if (muffled) 
[17:59:22.559]                         invokeRestart("muffleWarning")
[17:59:22.559]                     }
[17:59:22.559]                     else if (inherits(cond, "condition")) {
[17:59:22.559]                       if (!is.null(pattern)) {
[17:59:22.559]                         computeRestarts <- base::computeRestarts
[17:59:22.559]                         grepl <- base::grepl
[17:59:22.559]                         restarts <- computeRestarts(cond)
[17:59:22.559]                         for (restart in restarts) {
[17:59:22.559]                           name <- restart$name
[17:59:22.559]                           if (is.null(name)) 
[17:59:22.559]                             next
[17:59:22.559]                           if (!grepl(pattern, name)) 
[17:59:22.559]                             next
[17:59:22.559]                           invokeRestart(restart)
[17:59:22.559]                           muffled <- TRUE
[17:59:22.559]                           break
[17:59:22.559]                         }
[17:59:22.559]                       }
[17:59:22.559]                     }
[17:59:22.559]                     invisible(muffled)
[17:59:22.559]                   }
[17:59:22.559]                   muffleCondition(cond)
[17:59:22.559]                 })
[17:59:22.559]             }))
[17:59:22.559]             future::FutureResult(value = ...future.value$value, 
[17:59:22.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.559]                   ...future.rng), globalenv = if (FALSE) 
[17:59:22.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:22.559]                     ...future.globalenv.names))
[17:59:22.559]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:22.559]         }, condition = base::local({
[17:59:22.559]             c <- base::c
[17:59:22.559]             inherits <- base::inherits
[17:59:22.559]             invokeRestart <- base::invokeRestart
[17:59:22.559]             length <- base::length
[17:59:22.559]             list <- base::list
[17:59:22.559]             seq.int <- base::seq.int
[17:59:22.559]             signalCondition <- base::signalCondition
[17:59:22.559]             sys.calls <- base::sys.calls
[17:59:22.559]             `[[` <- base::`[[`
[17:59:22.559]             `+` <- base::`+`
[17:59:22.559]             `<<-` <- base::`<<-`
[17:59:22.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:22.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:22.559]                   3L)]
[17:59:22.559]             }
[17:59:22.559]             function(cond) {
[17:59:22.559]                 is_error <- inherits(cond, "error")
[17:59:22.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:22.559]                   NULL)
[17:59:22.559]                 if (is_error) {
[17:59:22.559]                   sessionInformation <- function() {
[17:59:22.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:22.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:22.559]                       search = base::search(), system = base::Sys.info())
[17:59:22.559]                   }
[17:59:22.559]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:22.559]                     cond$call), session = sessionInformation(), 
[17:59:22.559]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:22.559]                   signalCondition(cond)
[17:59:22.559]                 }
[17:59:22.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:22.559]                 "immediateCondition"))) {
[17:59:22.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:22.559]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:22.559]                   if (TRUE && !signal) {
[17:59:22.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.559]                     {
[17:59:22.559]                       inherits <- base::inherits
[17:59:22.559]                       invokeRestart <- base::invokeRestart
[17:59:22.559]                       is.null <- base::is.null
[17:59:22.559]                       muffled <- FALSE
[17:59:22.559]                       if (inherits(cond, "message")) {
[17:59:22.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.559]                         if (muffled) 
[17:59:22.559]                           invokeRestart("muffleMessage")
[17:59:22.559]                       }
[17:59:22.559]                       else if (inherits(cond, "warning")) {
[17:59:22.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.559]                         if (muffled) 
[17:59:22.559]                           invokeRestart("muffleWarning")
[17:59:22.559]                       }
[17:59:22.559]                       else if (inherits(cond, "condition")) {
[17:59:22.559]                         if (!is.null(pattern)) {
[17:59:22.559]                           computeRestarts <- base::computeRestarts
[17:59:22.559]                           grepl <- base::grepl
[17:59:22.559]                           restarts <- computeRestarts(cond)
[17:59:22.559]                           for (restart in restarts) {
[17:59:22.559]                             name <- restart$name
[17:59:22.559]                             if (is.null(name)) 
[17:59:22.559]                               next
[17:59:22.559]                             if (!grepl(pattern, name)) 
[17:59:22.559]                               next
[17:59:22.559]                             invokeRestart(restart)
[17:59:22.559]                             muffled <- TRUE
[17:59:22.559]                             break
[17:59:22.559]                           }
[17:59:22.559]                         }
[17:59:22.559]                       }
[17:59:22.559]                       invisible(muffled)
[17:59:22.559]                     }
[17:59:22.559]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.559]                   }
[17:59:22.559]                 }
[17:59:22.559]                 else {
[17:59:22.559]                   if (TRUE) {
[17:59:22.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.559]                     {
[17:59:22.559]                       inherits <- base::inherits
[17:59:22.559]                       invokeRestart <- base::invokeRestart
[17:59:22.559]                       is.null <- base::is.null
[17:59:22.559]                       muffled <- FALSE
[17:59:22.559]                       if (inherits(cond, "message")) {
[17:59:22.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.559]                         if (muffled) 
[17:59:22.559]                           invokeRestart("muffleMessage")
[17:59:22.559]                       }
[17:59:22.559]                       else if (inherits(cond, "warning")) {
[17:59:22.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.559]                         if (muffled) 
[17:59:22.559]                           invokeRestart("muffleWarning")
[17:59:22.559]                       }
[17:59:22.559]                       else if (inherits(cond, "condition")) {
[17:59:22.559]                         if (!is.null(pattern)) {
[17:59:22.559]                           computeRestarts <- base::computeRestarts
[17:59:22.559]                           grepl <- base::grepl
[17:59:22.559]                           restarts <- computeRestarts(cond)
[17:59:22.559]                           for (restart in restarts) {
[17:59:22.559]                             name <- restart$name
[17:59:22.559]                             if (is.null(name)) 
[17:59:22.559]                               next
[17:59:22.559]                             if (!grepl(pattern, name)) 
[17:59:22.559]                               next
[17:59:22.559]                             invokeRestart(restart)
[17:59:22.559]                             muffled <- TRUE
[17:59:22.559]                             break
[17:59:22.559]                           }
[17:59:22.559]                         }
[17:59:22.559]                       }
[17:59:22.559]                       invisible(muffled)
[17:59:22.559]                     }
[17:59:22.559]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.559]                   }
[17:59:22.559]                 }
[17:59:22.559]             }
[17:59:22.559]         }))
[17:59:22.559]     }, error = function(ex) {
[17:59:22.559]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:22.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.559]                 ...future.rng), started = ...future.startTime, 
[17:59:22.559]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:22.559]             version = "1.8"), class = "FutureResult")
[17:59:22.559]     }, finally = {
[17:59:22.559]         if (!identical(...future.workdir, getwd())) 
[17:59:22.559]             setwd(...future.workdir)
[17:59:22.559]         {
[17:59:22.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:22.559]                 ...future.oldOptions$nwarnings <- NULL
[17:59:22.559]             }
[17:59:22.559]             base::options(...future.oldOptions)
[17:59:22.559]             if (.Platform$OS.type == "windows") {
[17:59:22.559]                 old_names <- names(...future.oldEnvVars)
[17:59:22.559]                 envs <- base::Sys.getenv()
[17:59:22.559]                 names <- names(envs)
[17:59:22.559]                 common <- intersect(names, old_names)
[17:59:22.559]                 added <- setdiff(names, old_names)
[17:59:22.559]                 removed <- setdiff(old_names, names)
[17:59:22.559]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:22.559]                   envs[common]]
[17:59:22.559]                 NAMES <- toupper(changed)
[17:59:22.559]                 args <- list()
[17:59:22.559]                 for (kk in seq_along(NAMES)) {
[17:59:22.559]                   name <- changed[[kk]]
[17:59:22.559]                   NAME <- NAMES[[kk]]
[17:59:22.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.559]                     next
[17:59:22.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.559]                 }
[17:59:22.559]                 NAMES <- toupper(added)
[17:59:22.559]                 for (kk in seq_along(NAMES)) {
[17:59:22.559]                   name <- added[[kk]]
[17:59:22.559]                   NAME <- NAMES[[kk]]
[17:59:22.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.559]                     next
[17:59:22.559]                   args[[name]] <- ""
[17:59:22.559]                 }
[17:59:22.559]                 NAMES <- toupper(removed)
[17:59:22.559]                 for (kk in seq_along(NAMES)) {
[17:59:22.559]                   name <- removed[[kk]]
[17:59:22.559]                   NAME <- NAMES[[kk]]
[17:59:22.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.559]                     next
[17:59:22.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.559]                 }
[17:59:22.559]                 if (length(args) > 0) 
[17:59:22.559]                   base::do.call(base::Sys.setenv, args = args)
[17:59:22.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:22.559]             }
[17:59:22.559]             else {
[17:59:22.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:22.559]             }
[17:59:22.559]             {
[17:59:22.559]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:22.559]                   0L) {
[17:59:22.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:22.559]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:22.559]                   base::options(opts)
[17:59:22.559]                 }
[17:59:22.559]                 {
[17:59:22.559]                   {
[17:59:22.559]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:22.559]                     NULL
[17:59:22.559]                   }
[17:59:22.559]                   options(future.plan = NULL)
[17:59:22.559]                   if (is.na(NA_character_)) 
[17:59:22.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:22.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:22.559]                     .init = FALSE)
[17:59:22.559]                 }
[17:59:22.559]             }
[17:59:22.559]         }
[17:59:22.559]     })
[17:59:22.559]     if (TRUE) {
[17:59:22.559]         base::sink(type = "output", split = FALSE)
[17:59:22.559]         if (TRUE) {
[17:59:22.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:22.559]         }
[17:59:22.559]         else {
[17:59:22.559]             ...future.result["stdout"] <- base::list(NULL)
[17:59:22.559]         }
[17:59:22.559]         base::close(...future.stdout)
[17:59:22.559]         ...future.stdout <- NULL
[17:59:22.559]     }
[17:59:22.559]     ...future.result$conditions <- ...future.conditions
[17:59:22.559]     ...future.result$finished <- base::Sys.time()
[17:59:22.559]     ...future.result
[17:59:22.559] }
[17:59:22.565] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[17:59:22.565] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:22.566] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:22.566] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[17:59:22.567] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[17:59:22.567] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:59:22.568] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:59:22.569] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:22.569] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:22.570] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:59:22.571] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:59:22.571] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[17:59:22.572] MultisessionFuture started
[17:59:22.572] - Launch lazy future ... done
[17:59:22.572] run() for ‘MultisessionFuture’ ... done
[17:59:22.572] Created future:
[17:59:22.573] MultisessionFuture:
[17:59:22.573] Label: ‘future_apply-1’
[17:59:22.573] Expression:
[17:59:22.573] {
[17:59:22.573]     do.call(function(...) {
[17:59:22.573]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.573]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.573]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.573]             on.exit(options(oopts), add = TRUE)
[17:59:22.573]         }
[17:59:22.573]         {
[17:59:22.573]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.573]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.573]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.573]             })
[17:59:22.573]         }
[17:59:22.573]     }, args = future.call.arguments)
[17:59:22.573] }
[17:59:22.573] Lazy evaluation: FALSE
[17:59:22.573] Asynchronous evaluation: TRUE
[17:59:22.573] Local evaluation: TRUE
[17:59:22.573] Environment: R_GlobalEnv
[17:59:22.573] Capture standard output: TRUE
[17:59:22.573] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:22.573] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:22.573] Packages: <none>
[17:59:22.573] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:22.573] Resolved: FALSE
[17:59:22.573] Value: <not collected>
[17:59:22.573] Conditions captured: <none>
[17:59:22.573] Early signaling: FALSE
[17:59:22.573] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:22.573] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.586] Chunk #1 of 2 ... DONE
[17:59:22.586] Chunk #2 of 2 ...
[17:59:22.586]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:22.586]  - seeds: <none>
[17:59:22.586]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.587] getGlobalsAndPackages() ...
[17:59:22.587] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.587] Resolving globals: FALSE
[17:59:22.587] Tweak future expression to call with '...' arguments ...
[17:59:22.588] {
[17:59:22.588]     do.call(function(...) {
[17:59:22.588]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.588]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.588]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.588]             on.exit(options(oopts), add = TRUE)
[17:59:22.588]         }
[17:59:22.588]         {
[17:59:22.588]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.588]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.588]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.588]             })
[17:59:22.588]         }
[17:59:22.588]     }, args = future.call.arguments)
[17:59:22.588] }
[17:59:22.588] Tweak future expression to call with '...' arguments ... DONE
[17:59:22.589] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.589] 
[17:59:22.589] getGlobalsAndPackages() ... DONE
[17:59:22.590] run() for ‘Future’ ...
[17:59:22.590] - state: ‘created’
[17:59:22.590] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:22.615] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.615] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:22.616]   - Field: ‘node’
[17:59:22.616]   - Field: ‘label’
[17:59:22.616]   - Field: ‘local’
[17:59:22.616]   - Field: ‘owner’
[17:59:22.616]   - Field: ‘envir’
[17:59:22.617]   - Field: ‘workers’
[17:59:22.617]   - Field: ‘packages’
[17:59:22.617]   - Field: ‘gc’
[17:59:22.617]   - Field: ‘conditions’
[17:59:22.618]   - Field: ‘persistent’
[17:59:22.618]   - Field: ‘expr’
[17:59:22.618]   - Field: ‘uuid’
[17:59:22.618]   - Field: ‘seed’
[17:59:22.618]   - Field: ‘version’
[17:59:22.619]   - Field: ‘result’
[17:59:22.619]   - Field: ‘asynchronous’
[17:59:22.619]   - Field: ‘calls’
[17:59:22.619]   - Field: ‘globals’
[17:59:22.619]   - Field: ‘stdout’
[17:59:22.623]   - Field: ‘earlySignal’
[17:59:22.623]   - Field: ‘lazy’
[17:59:22.623]   - Field: ‘state’
[17:59:22.624] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:22.624] - Launch lazy future ...
[17:59:22.624] Packages needed by the future expression (n = 0): <none>
[17:59:22.625] Packages needed by future strategies (n = 0): <none>
[17:59:22.626] {
[17:59:22.626]     {
[17:59:22.626]         {
[17:59:22.626]             ...future.startTime <- base::Sys.time()
[17:59:22.626]             {
[17:59:22.626]                 {
[17:59:22.626]                   {
[17:59:22.626]                     {
[17:59:22.626]                       base::local({
[17:59:22.626]                         has_future <- base::requireNamespace("future", 
[17:59:22.626]                           quietly = TRUE)
[17:59:22.626]                         if (has_future) {
[17:59:22.626]                           ns <- base::getNamespace("future")
[17:59:22.626]                           version <- ns[[".package"]][["version"]]
[17:59:22.626]                           if (is.null(version)) 
[17:59:22.626]                             version <- utils::packageVersion("future")
[17:59:22.626]                         }
[17:59:22.626]                         else {
[17:59:22.626]                           version <- NULL
[17:59:22.626]                         }
[17:59:22.626]                         if (!has_future || version < "1.8.0") {
[17:59:22.626]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:22.626]                             "", base::R.version$version.string), 
[17:59:22.626]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:22.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:22.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:22.626]                               "release", "version")], collapse = " "), 
[17:59:22.626]                             hostname = base::Sys.info()[["nodename"]])
[17:59:22.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:22.626]                             info)
[17:59:22.626]                           info <- base::paste(info, collapse = "; ")
[17:59:22.626]                           if (!has_future) {
[17:59:22.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:22.626]                               info)
[17:59:22.626]                           }
[17:59:22.626]                           else {
[17:59:22.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:22.626]                               info, version)
[17:59:22.626]                           }
[17:59:22.626]                           base::stop(msg)
[17:59:22.626]                         }
[17:59:22.626]                       })
[17:59:22.626]                     }
[17:59:22.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:22.626]                     base::options(mc.cores = 1L)
[17:59:22.626]                   }
[17:59:22.626]                   ...future.strategy.old <- future::plan("list")
[17:59:22.626]                   options(future.plan = NULL)
[17:59:22.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:22.626]                 }
[17:59:22.626]                 ...future.workdir <- getwd()
[17:59:22.626]             }
[17:59:22.626]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:22.626]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:22.626]         }
[17:59:22.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:22.626]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:22.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:22.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:22.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:22.626]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:22.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:22.626]             base::names(...future.oldOptions))
[17:59:22.626]     }
[17:59:22.626]     if (FALSE) {
[17:59:22.626]     }
[17:59:22.626]     else {
[17:59:22.626]         if (TRUE) {
[17:59:22.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:22.626]                 open = "w")
[17:59:22.626]         }
[17:59:22.626]         else {
[17:59:22.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:22.626]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:22.626]         }
[17:59:22.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:22.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:22.626]             base::sink(type = "output", split = FALSE)
[17:59:22.626]             base::close(...future.stdout)
[17:59:22.626]         }, add = TRUE)
[17:59:22.626]     }
[17:59:22.626]     ...future.frame <- base::sys.nframe()
[17:59:22.626]     ...future.conditions <- base::list()
[17:59:22.626]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:22.626]     if (FALSE) {
[17:59:22.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:22.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:22.626]     }
[17:59:22.626]     ...future.result <- base::tryCatch({
[17:59:22.626]         base::withCallingHandlers({
[17:59:22.626]             ...future.value <- base::withVisible(base::local({
[17:59:22.626]                 ...future.makeSendCondition <- base::local({
[17:59:22.626]                   sendCondition <- NULL
[17:59:22.626]                   function(frame = 1L) {
[17:59:22.626]                     if (is.function(sendCondition)) 
[17:59:22.626]                       return(sendCondition)
[17:59:22.626]                     ns <- getNamespace("parallel")
[17:59:22.626]                     if (exists("sendData", mode = "function", 
[17:59:22.626]                       envir = ns)) {
[17:59:22.626]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:22.626]                         envir = ns)
[17:59:22.626]                       envir <- sys.frame(frame)
[17:59:22.626]                       master <- NULL
[17:59:22.626]                       while (!identical(envir, .GlobalEnv) && 
[17:59:22.626]                         !identical(envir, emptyenv())) {
[17:59:22.626]                         if (exists("master", mode = "list", envir = envir, 
[17:59:22.626]                           inherits = FALSE)) {
[17:59:22.626]                           master <- get("master", mode = "list", 
[17:59:22.626]                             envir = envir, inherits = FALSE)
[17:59:22.626]                           if (inherits(master, c("SOCKnode", 
[17:59:22.626]                             "SOCK0node"))) {
[17:59:22.626]                             sendCondition <<- function(cond) {
[17:59:22.626]                               data <- list(type = "VALUE", value = cond, 
[17:59:22.626]                                 success = TRUE)
[17:59:22.626]                               parallel_sendData(master, data)
[17:59:22.626]                             }
[17:59:22.626]                             return(sendCondition)
[17:59:22.626]                           }
[17:59:22.626]                         }
[17:59:22.626]                         frame <- frame + 1L
[17:59:22.626]                         envir <- sys.frame(frame)
[17:59:22.626]                       }
[17:59:22.626]                     }
[17:59:22.626]                     sendCondition <<- function(cond) NULL
[17:59:22.626]                   }
[17:59:22.626]                 })
[17:59:22.626]                 withCallingHandlers({
[17:59:22.626]                   {
[17:59:22.626]                     do.call(function(...) {
[17:59:22.626]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.626]                       if (!identical(...future.globals.maxSize.org, 
[17:59:22.626]                         ...future.globals.maxSize)) {
[17:59:22.626]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.626]                         on.exit(options(oopts), add = TRUE)
[17:59:22.626]                       }
[17:59:22.626]                       {
[17:59:22.626]                         lapply(seq_along(...future.elements_ii), 
[17:59:22.626]                           FUN = function(jj) {
[17:59:22.626]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.626]                             ...future.FUN(...future.X_jj, ...)
[17:59:22.626]                           })
[17:59:22.626]                       }
[17:59:22.626]                     }, args = future.call.arguments)
[17:59:22.626]                   }
[17:59:22.626]                 }, immediateCondition = function(cond) {
[17:59:22.626]                   sendCondition <- ...future.makeSendCondition()
[17:59:22.626]                   sendCondition(cond)
[17:59:22.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.626]                   {
[17:59:22.626]                     inherits <- base::inherits
[17:59:22.626]                     invokeRestart <- base::invokeRestart
[17:59:22.626]                     is.null <- base::is.null
[17:59:22.626]                     muffled <- FALSE
[17:59:22.626]                     if (inherits(cond, "message")) {
[17:59:22.626]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:22.626]                       if (muffled) 
[17:59:22.626]                         invokeRestart("muffleMessage")
[17:59:22.626]                     }
[17:59:22.626]                     else if (inherits(cond, "warning")) {
[17:59:22.626]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:22.626]                       if (muffled) 
[17:59:22.626]                         invokeRestart("muffleWarning")
[17:59:22.626]                     }
[17:59:22.626]                     else if (inherits(cond, "condition")) {
[17:59:22.626]                       if (!is.null(pattern)) {
[17:59:22.626]                         computeRestarts <- base::computeRestarts
[17:59:22.626]                         grepl <- base::grepl
[17:59:22.626]                         restarts <- computeRestarts(cond)
[17:59:22.626]                         for (restart in restarts) {
[17:59:22.626]                           name <- restart$name
[17:59:22.626]                           if (is.null(name)) 
[17:59:22.626]                             next
[17:59:22.626]                           if (!grepl(pattern, name)) 
[17:59:22.626]                             next
[17:59:22.626]                           invokeRestart(restart)
[17:59:22.626]                           muffled <- TRUE
[17:59:22.626]                           break
[17:59:22.626]                         }
[17:59:22.626]                       }
[17:59:22.626]                     }
[17:59:22.626]                     invisible(muffled)
[17:59:22.626]                   }
[17:59:22.626]                   muffleCondition(cond)
[17:59:22.626]                 })
[17:59:22.626]             }))
[17:59:22.626]             future::FutureResult(value = ...future.value$value, 
[17:59:22.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.626]                   ...future.rng), globalenv = if (FALSE) 
[17:59:22.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:22.626]                     ...future.globalenv.names))
[17:59:22.626]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:22.626]         }, condition = base::local({
[17:59:22.626]             c <- base::c
[17:59:22.626]             inherits <- base::inherits
[17:59:22.626]             invokeRestart <- base::invokeRestart
[17:59:22.626]             length <- base::length
[17:59:22.626]             list <- base::list
[17:59:22.626]             seq.int <- base::seq.int
[17:59:22.626]             signalCondition <- base::signalCondition
[17:59:22.626]             sys.calls <- base::sys.calls
[17:59:22.626]             `[[` <- base::`[[`
[17:59:22.626]             `+` <- base::`+`
[17:59:22.626]             `<<-` <- base::`<<-`
[17:59:22.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:22.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:22.626]                   3L)]
[17:59:22.626]             }
[17:59:22.626]             function(cond) {
[17:59:22.626]                 is_error <- inherits(cond, "error")
[17:59:22.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:22.626]                   NULL)
[17:59:22.626]                 if (is_error) {
[17:59:22.626]                   sessionInformation <- function() {
[17:59:22.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:22.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:22.626]                       search = base::search(), system = base::Sys.info())
[17:59:22.626]                   }
[17:59:22.626]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:22.626]                     cond$call), session = sessionInformation(), 
[17:59:22.626]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:22.626]                   signalCondition(cond)
[17:59:22.626]                 }
[17:59:22.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:22.626]                 "immediateCondition"))) {
[17:59:22.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:22.626]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:22.626]                   if (TRUE && !signal) {
[17:59:22.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.626]                     {
[17:59:22.626]                       inherits <- base::inherits
[17:59:22.626]                       invokeRestart <- base::invokeRestart
[17:59:22.626]                       is.null <- base::is.null
[17:59:22.626]                       muffled <- FALSE
[17:59:22.626]                       if (inherits(cond, "message")) {
[17:59:22.626]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.626]                         if (muffled) 
[17:59:22.626]                           invokeRestart("muffleMessage")
[17:59:22.626]                       }
[17:59:22.626]                       else if (inherits(cond, "warning")) {
[17:59:22.626]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.626]                         if (muffled) 
[17:59:22.626]                           invokeRestart("muffleWarning")
[17:59:22.626]                       }
[17:59:22.626]                       else if (inherits(cond, "condition")) {
[17:59:22.626]                         if (!is.null(pattern)) {
[17:59:22.626]                           computeRestarts <- base::computeRestarts
[17:59:22.626]                           grepl <- base::grepl
[17:59:22.626]                           restarts <- computeRestarts(cond)
[17:59:22.626]                           for (restart in restarts) {
[17:59:22.626]                             name <- restart$name
[17:59:22.626]                             if (is.null(name)) 
[17:59:22.626]                               next
[17:59:22.626]                             if (!grepl(pattern, name)) 
[17:59:22.626]                               next
[17:59:22.626]                             invokeRestart(restart)
[17:59:22.626]                             muffled <- TRUE
[17:59:22.626]                             break
[17:59:22.626]                           }
[17:59:22.626]                         }
[17:59:22.626]                       }
[17:59:22.626]                       invisible(muffled)
[17:59:22.626]                     }
[17:59:22.626]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.626]                   }
[17:59:22.626]                 }
[17:59:22.626]                 else {
[17:59:22.626]                   if (TRUE) {
[17:59:22.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.626]                     {
[17:59:22.626]                       inherits <- base::inherits
[17:59:22.626]                       invokeRestart <- base::invokeRestart
[17:59:22.626]                       is.null <- base::is.null
[17:59:22.626]                       muffled <- FALSE
[17:59:22.626]                       if (inherits(cond, "message")) {
[17:59:22.626]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.626]                         if (muffled) 
[17:59:22.626]                           invokeRestart("muffleMessage")
[17:59:22.626]                       }
[17:59:22.626]                       else if (inherits(cond, "warning")) {
[17:59:22.626]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.626]                         if (muffled) 
[17:59:22.626]                           invokeRestart("muffleWarning")
[17:59:22.626]                       }
[17:59:22.626]                       else if (inherits(cond, "condition")) {
[17:59:22.626]                         if (!is.null(pattern)) {
[17:59:22.626]                           computeRestarts <- base::computeRestarts
[17:59:22.626]                           grepl <- base::grepl
[17:59:22.626]                           restarts <- computeRestarts(cond)
[17:59:22.626]                           for (restart in restarts) {
[17:59:22.626]                             name <- restart$name
[17:59:22.626]                             if (is.null(name)) 
[17:59:22.626]                               next
[17:59:22.626]                             if (!grepl(pattern, name)) 
[17:59:22.626]                               next
[17:59:22.626]                             invokeRestart(restart)
[17:59:22.626]                             muffled <- TRUE
[17:59:22.626]                             break
[17:59:22.626]                           }
[17:59:22.626]                         }
[17:59:22.626]                       }
[17:59:22.626]                       invisible(muffled)
[17:59:22.626]                     }
[17:59:22.626]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.626]                   }
[17:59:22.626]                 }
[17:59:22.626]             }
[17:59:22.626]         }))
[17:59:22.626]     }, error = function(ex) {
[17:59:22.626]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:22.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.626]                 ...future.rng), started = ...future.startTime, 
[17:59:22.626]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:22.626]             version = "1.8"), class = "FutureResult")
[17:59:22.626]     }, finally = {
[17:59:22.626]         if (!identical(...future.workdir, getwd())) 
[17:59:22.626]             setwd(...future.workdir)
[17:59:22.626]         {
[17:59:22.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:22.626]                 ...future.oldOptions$nwarnings <- NULL
[17:59:22.626]             }
[17:59:22.626]             base::options(...future.oldOptions)
[17:59:22.626]             if (.Platform$OS.type == "windows") {
[17:59:22.626]                 old_names <- names(...future.oldEnvVars)
[17:59:22.626]                 envs <- base::Sys.getenv()
[17:59:22.626]                 names <- names(envs)
[17:59:22.626]                 common <- intersect(names, old_names)
[17:59:22.626]                 added <- setdiff(names, old_names)
[17:59:22.626]                 removed <- setdiff(old_names, names)
[17:59:22.626]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:22.626]                   envs[common]]
[17:59:22.626]                 NAMES <- toupper(changed)
[17:59:22.626]                 args <- list()
[17:59:22.626]                 for (kk in seq_along(NAMES)) {
[17:59:22.626]                   name <- changed[[kk]]
[17:59:22.626]                   NAME <- NAMES[[kk]]
[17:59:22.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.626]                     next
[17:59:22.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.626]                 }
[17:59:22.626]                 NAMES <- toupper(added)
[17:59:22.626]                 for (kk in seq_along(NAMES)) {
[17:59:22.626]                   name <- added[[kk]]
[17:59:22.626]                   NAME <- NAMES[[kk]]
[17:59:22.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.626]                     next
[17:59:22.626]                   args[[name]] <- ""
[17:59:22.626]                 }
[17:59:22.626]                 NAMES <- toupper(removed)
[17:59:22.626]                 for (kk in seq_along(NAMES)) {
[17:59:22.626]                   name <- removed[[kk]]
[17:59:22.626]                   NAME <- NAMES[[kk]]
[17:59:22.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.626]                     next
[17:59:22.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.626]                 }
[17:59:22.626]                 if (length(args) > 0) 
[17:59:22.626]                   base::do.call(base::Sys.setenv, args = args)
[17:59:22.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:22.626]             }
[17:59:22.626]             else {
[17:59:22.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:22.626]             }
[17:59:22.626]             {
[17:59:22.626]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:22.626]                   0L) {
[17:59:22.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:22.626]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:22.626]                   base::options(opts)
[17:59:22.626]                 }
[17:59:22.626]                 {
[17:59:22.626]                   {
[17:59:22.626]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:22.626]                     NULL
[17:59:22.626]                   }
[17:59:22.626]                   options(future.plan = NULL)
[17:59:22.626]                   if (is.na(NA_character_)) 
[17:59:22.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:22.626]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:22.626]                     .init = FALSE)
[17:59:22.626]                 }
[17:59:22.626]             }
[17:59:22.626]         }
[17:59:22.626]     })
[17:59:22.626]     if (TRUE) {
[17:59:22.626]         base::sink(type = "output", split = FALSE)
[17:59:22.626]         if (TRUE) {
[17:59:22.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:22.626]         }
[17:59:22.626]         else {
[17:59:22.626]             ...future.result["stdout"] <- base::list(NULL)
[17:59:22.626]         }
[17:59:22.626]         base::close(...future.stdout)
[17:59:22.626]         ...future.stdout <- NULL
[17:59:22.626]     }
[17:59:22.626]     ...future.result$conditions <- ...future.conditions
[17:59:22.626]     ...future.result$finished <- base::Sys.time()
[17:59:22.626]     ...future.result
[17:59:22.626] }
[17:59:22.632] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[17:59:22.632] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:22.633] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:22.634] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[17:59:22.635] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[17:59:22.635] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:59:22.636] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:59:22.636] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:22.637] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:22.637] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:59:22.638] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:59:22.638] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[17:59:22.640] MultisessionFuture started
[17:59:22.641] - Launch lazy future ... done
[17:59:22.641] run() for ‘MultisessionFuture’ ... done
[17:59:22.641] Created future:
[17:59:22.641] MultisessionFuture:
[17:59:22.641] Label: ‘future_apply-2’
[17:59:22.641] Expression:
[17:59:22.641] {
[17:59:22.641]     do.call(function(...) {
[17:59:22.641]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.641]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.641]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.641]             on.exit(options(oopts), add = TRUE)
[17:59:22.641]         }
[17:59:22.641]         {
[17:59:22.641]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.641]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.641]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.641]             })
[17:59:22.641]         }
[17:59:22.641]     }, args = future.call.arguments)
[17:59:22.641] }
[17:59:22.641] Lazy evaluation: FALSE
[17:59:22.641] Asynchronous evaluation: TRUE
[17:59:22.641] Local evaluation: TRUE
[17:59:22.641] Environment: R_GlobalEnv
[17:59:22.641] Capture standard output: TRUE
[17:59:22.641] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:22.641] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:22.641] Packages: <none>
[17:59:22.641] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:22.641] Resolved: FALSE
[17:59:22.641] Value: <not collected>
[17:59:22.641] Conditions captured: <none>
[17:59:22.641] Early signaling: FALSE
[17:59:22.641] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:22.641] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.654] Chunk #2 of 2 ... DONE
[17:59:22.655] Launching 2 futures (chunks) ... DONE
[17:59:22.655] Resolving 2 futures (chunks) ...
[17:59:22.655] resolve() on list ...
[17:59:22.655]  recursive: 0
[17:59:22.656]  length: 2
[17:59:22.656] 
[17:59:22.657] receiveMessageFromWorker() for ClusterFuture ...
[17:59:22.657] - Validating connection of MultisessionFuture
[17:59:22.657] - received message: FutureResult
[17:59:22.657] - Received FutureResult
[17:59:22.658] - Erased future from FutureRegistry
[17:59:22.658] result() for ClusterFuture ...
[17:59:22.658] - result already collected: FutureResult
[17:59:22.658] result() for ClusterFuture ... done
[17:59:22.658] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:22.659] Future #1
[17:59:22.659] result() for ClusterFuture ...
[17:59:22.659] - result already collected: FutureResult
[17:59:22.659] result() for ClusterFuture ... done
[17:59:22.659] result() for ClusterFuture ...
[17:59:22.659] - result already collected: FutureResult
[17:59:22.660] result() for ClusterFuture ... done
[17:59:22.660] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:22.660] - nx: 2
[17:59:22.660] - relay: TRUE
[17:59:22.660] - stdout: TRUE
[17:59:22.661] - signal: TRUE
[17:59:22.661] - resignal: FALSE
[17:59:22.661] - force: TRUE
[17:59:22.661] - relayed: [n=2] FALSE, FALSE
[17:59:22.661] - queued futures: [n=2] FALSE, FALSE
[17:59:22.661]  - until=1
[17:59:22.662]  - relaying element #1
[17:59:22.662] result() for ClusterFuture ...
[17:59:22.662] - result already collected: FutureResult
[17:59:22.662] result() for ClusterFuture ... done
[17:59:22.662] result() for ClusterFuture ...
[17:59:22.663] - result already collected: FutureResult
[17:59:22.663] result() for ClusterFuture ... done
[17:59:22.663] result() for ClusterFuture ...
[17:59:22.663] - result already collected: FutureResult
[17:59:22.663] result() for ClusterFuture ... done
[17:59:22.663] result() for ClusterFuture ...
[17:59:22.664] - result already collected: FutureResult
[17:59:22.664] result() for ClusterFuture ... done
[17:59:22.664] - relayed: [n=2] TRUE, FALSE
[17:59:22.664] - queued futures: [n=2] TRUE, FALSE
[17:59:22.664] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:22.665]  length: 1 (resolved future 1)
[17:59:22.687] receiveMessageFromWorker() for ClusterFuture ...
[17:59:22.687] - Validating connection of MultisessionFuture
[17:59:22.687] - received message: FutureResult
[17:59:22.688] - Received FutureResult
[17:59:22.688] - Erased future from FutureRegistry
[17:59:22.688] result() for ClusterFuture ...
[17:59:22.688] - result already collected: FutureResult
[17:59:22.688] result() for ClusterFuture ... done
[17:59:22.689] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:22.689] Future #2
[17:59:22.689] result() for ClusterFuture ...
[17:59:22.689] - result already collected: FutureResult
[17:59:22.689] result() for ClusterFuture ... done
[17:59:22.690] result() for ClusterFuture ...
[17:59:22.690] - result already collected: FutureResult
[17:59:22.690] result() for ClusterFuture ... done
[17:59:22.690] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:22.690] - nx: 2
[17:59:22.691] - relay: TRUE
[17:59:22.691] - stdout: TRUE
[17:59:22.691] - signal: TRUE
[17:59:22.691] - resignal: FALSE
[17:59:22.691] - force: TRUE
[17:59:22.691] - relayed: [n=2] TRUE, FALSE
[17:59:22.692] - queued futures: [n=2] TRUE, FALSE
[17:59:22.692]  - until=2
[17:59:22.692]  - relaying element #2
[17:59:22.692] result() for ClusterFuture ...
[17:59:22.692] - result already collected: FutureResult
[17:59:22.693] result() for ClusterFuture ... done
[17:59:22.693] result() for ClusterFuture ...
[17:59:22.693] - result already collected: FutureResult
[17:59:22.693] result() for ClusterFuture ... done
[17:59:22.693] result() for ClusterFuture ...
[17:59:22.694] - result already collected: FutureResult
[17:59:22.694] result() for ClusterFuture ... done
[17:59:22.694] result() for ClusterFuture ...
[17:59:22.694] - result already collected: FutureResult
[17:59:22.694] result() for ClusterFuture ... done
[17:59:22.695] - relayed: [n=2] TRUE, TRUE
[17:59:22.695] - queued futures: [n=2] TRUE, TRUE
[17:59:22.695] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:22.695]  length: 0 (resolved future 2)
[17:59:22.695] Relaying remaining futures
[17:59:22.696] signalConditionsASAP(NULL, pos=0) ...
[17:59:22.696] - nx: 2
[17:59:22.696] - relay: TRUE
[17:59:22.696] - stdout: TRUE
[17:59:22.696] - signal: TRUE
[17:59:22.696] - resignal: FALSE
[17:59:22.697] - force: TRUE
[17:59:22.697] - relayed: [n=2] TRUE, TRUE
[17:59:22.697] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:22.697] - relayed: [n=2] TRUE, TRUE
[17:59:22.698] - queued futures: [n=2] TRUE, TRUE
[17:59:22.698] signalConditionsASAP(NULL, pos=0) ... done
[17:59:22.698] resolve() on list ... DONE
[17:59:22.698] result() for ClusterFuture ...
[17:59:22.698] - result already collected: FutureResult
[17:59:22.698] result() for ClusterFuture ... done
[17:59:22.699] result() for ClusterFuture ...
[17:59:22.699] - result already collected: FutureResult
[17:59:22.699] result() for ClusterFuture ... done
[17:59:22.699] result() for ClusterFuture ...
[17:59:22.699] - result already collected: FutureResult
[17:59:22.700] result() for ClusterFuture ... done
[17:59:22.700] result() for ClusterFuture ...
[17:59:22.700] - result already collected: FutureResult
[17:59:22.700] result() for ClusterFuture ... done
[17:59:22.700]  - Number of value chunks collected: 2
[17:59:22.701] Resolving 2 futures (chunks) ... DONE
[17:59:22.701] Reducing values from 2 chunks ...
[17:59:22.701]  - Number of values collected after concatenation: 2
[17:59:22.701]  - Number of values expected: 2
[17:59:22.701] Reducing values from 2 chunks ... DONE
[17:59:22.701] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:59:22.702] getGlobalsAndPackagesXApply() ...
[17:59:22.702]  - future.globals: TRUE
[17:59:22.702] getGlobalsAndPackages() ...
[17:59:22.703] Searching for globals...
[17:59:22.709] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:59:22.709] Searching for globals ... DONE
[17:59:22.710] Resolving globals: FALSE
[17:59:22.711] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:59:22.712] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:59:22.712] - globals: [1] ‘FUN’
[17:59:22.712] 
[17:59:22.712] getGlobalsAndPackages() ... DONE
[17:59:22.713]  - globals found/used: [n=1] ‘FUN’
[17:59:22.713]  - needed namespaces: [n=0] 
[17:59:22.713] Finding globals ... DONE
[17:59:22.713]  - use_args: TRUE
[17:59:22.713]  - Getting '...' globals ...
[17:59:22.714] resolve() on list ...
[17:59:22.714]  recursive: 0
[17:59:22.714]  length: 1
[17:59:22.715]  elements: ‘...’
[17:59:22.715]  length: 0 (resolved future 1)
[17:59:22.715] resolve() on list ... DONE
[17:59:22.715]    - '...' content: [n=0] 
[17:59:22.716] List of 1
[17:59:22.716]  $ ...: list()
[17:59:22.716]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.716]  - attr(*, "where")=List of 1
[17:59:22.716]   ..$ ...:<environment: 0x5608594df2b8> 
[17:59:22.716]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.716]  - attr(*, "resolved")= logi TRUE
[17:59:22.716]  - attr(*, "total_size")= num NA
[17:59:22.721]  - Getting '...' globals ... DONE
[17:59:22.721] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:22.721] List of 2
[17:59:22.721]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:59:22.721]  $ ...          : list()
[17:59:22.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.721]  - attr(*, "where")=List of 2
[17:59:22.721]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:22.721]   ..$ ...          :<environment: 0x5608594df2b8> 
[17:59:22.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.721]  - attr(*, "resolved")= logi FALSE
[17:59:22.721]  - attr(*, "total_size")= num 36296
[17:59:22.727] Packages to be attached in all futures: [n=0] 
[17:59:22.727] getGlobalsAndPackagesXApply() ... DONE
[17:59:22.733] future_lapply() ...
[17:59:22.737] Generating random seeds ...
[17:59:22.737] Generating random seed streams for 2 elements ...
[17:59:22.737] Generating random seed streams for 2 elements ... DONE
[17:59:22.738] Generating random seeds ... DONE
[17:59:22.738] Will set RNG state on exit: 10407, -1422521837, 844425007, 905542574, 1285653380, -1276276413, -47645742
[17:59:22.744] Number of chunks: 2
[17:59:22.744] getGlobalsAndPackagesXApply() ...
[17:59:22.745]  - future.globals: <name-value list> with names ‘list()’
[17:59:22.745]  - use_args: TRUE
[17:59:22.745] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:59:22.746] List of 2
[17:59:22.746]  $ ...          : list()
[17:59:22.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:22.746]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:59:22.746]  - attr(*, "where")=List of 2
[17:59:22.746]   ..$ ...          :<environment: 0x5608594df2b8> 
[17:59:22.746]   ..$ ...future.FUN:<environment: namespace:base> 
[17:59:22.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:22.746]  - attr(*, "resolved")= logi FALSE
[17:59:22.746]  - attr(*, "total_size")= num NA
[17:59:22.752] Packages to be attached in all futures: [n=0] 
[17:59:22.752] getGlobalsAndPackagesXApply() ... DONE
[17:59:22.753] Number of futures (= number of chunks): 2
[17:59:22.753] Launching 2 futures (chunks) ...
[17:59:22.753] Chunk #1 of 2 ...
[17:59:22.753]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:22.754]  - seeds: [1] <seeds>
[17:59:22.754]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.754] getGlobalsAndPackages() ...
[17:59:22.754] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.754] Resolving globals: FALSE
[17:59:22.755] Tweak future expression to call with '...' arguments ...
[17:59:22.755] {
[17:59:22.755]     do.call(function(...) {
[17:59:22.755]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.755]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.755]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.755]             on.exit(options(oopts), add = TRUE)
[17:59:22.755]         }
[17:59:22.755]         {
[17:59:22.755]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.755]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.755]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:22.755]                   envir = globalenv(), inherits = FALSE)
[17:59:22.755]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.755]             })
[17:59:22.755]         }
[17:59:22.755]     }, args = future.call.arguments)
[17:59:22.755] }
[17:59:22.755] Tweak future expression to call with '...' arguments ... DONE
[17:59:22.756] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.756] 
[17:59:22.757] getGlobalsAndPackages() ... DONE
[17:59:22.757] run() for ‘Future’ ...
[17:59:22.757] - state: ‘created’
[17:59:22.758] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:22.782] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:22.782]   - Field: ‘node’
[17:59:22.782]   - Field: ‘label’
[17:59:22.783]   - Field: ‘local’
[17:59:22.783]   - Field: ‘owner’
[17:59:22.783]   - Field: ‘envir’
[17:59:22.783]   - Field: ‘workers’
[17:59:22.783]   - Field: ‘packages’
[17:59:22.784]   - Field: ‘gc’
[17:59:22.784]   - Field: ‘conditions’
[17:59:22.784]   - Field: ‘persistent’
[17:59:22.784]   - Field: ‘expr’
[17:59:22.784]   - Field: ‘uuid’
[17:59:22.785]   - Field: ‘seed’
[17:59:22.785]   - Field: ‘version’
[17:59:22.785]   - Field: ‘result’
[17:59:22.785]   - Field: ‘asynchronous’
[17:59:22.785]   - Field: ‘calls’
[17:59:22.786]   - Field: ‘globals’
[17:59:22.786]   - Field: ‘stdout’
[17:59:22.786]   - Field: ‘earlySignal’
[17:59:22.786]   - Field: ‘lazy’
[17:59:22.786]   - Field: ‘state’
[17:59:22.786] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:22.787] - Launch lazy future ...
[17:59:22.787] Packages needed by the future expression (n = 0): <none>
[17:59:22.787] Packages needed by future strategies (n = 0): <none>
[17:59:22.788] {
[17:59:22.788]     {
[17:59:22.788]         {
[17:59:22.788]             ...future.startTime <- base::Sys.time()
[17:59:22.788]             {
[17:59:22.788]                 {
[17:59:22.788]                   {
[17:59:22.788]                     {
[17:59:22.788]                       base::local({
[17:59:22.788]                         has_future <- base::requireNamespace("future", 
[17:59:22.788]                           quietly = TRUE)
[17:59:22.788]                         if (has_future) {
[17:59:22.788]                           ns <- base::getNamespace("future")
[17:59:22.788]                           version <- ns[[".package"]][["version"]]
[17:59:22.788]                           if (is.null(version)) 
[17:59:22.788]                             version <- utils::packageVersion("future")
[17:59:22.788]                         }
[17:59:22.788]                         else {
[17:59:22.788]                           version <- NULL
[17:59:22.788]                         }
[17:59:22.788]                         if (!has_future || version < "1.8.0") {
[17:59:22.788]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:22.788]                             "", base::R.version$version.string), 
[17:59:22.788]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:22.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:22.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:22.788]                               "release", "version")], collapse = " "), 
[17:59:22.788]                             hostname = base::Sys.info()[["nodename"]])
[17:59:22.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:22.788]                             info)
[17:59:22.788]                           info <- base::paste(info, collapse = "; ")
[17:59:22.788]                           if (!has_future) {
[17:59:22.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:22.788]                               info)
[17:59:22.788]                           }
[17:59:22.788]                           else {
[17:59:22.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:22.788]                               info, version)
[17:59:22.788]                           }
[17:59:22.788]                           base::stop(msg)
[17:59:22.788]                         }
[17:59:22.788]                       })
[17:59:22.788]                     }
[17:59:22.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:22.788]                     base::options(mc.cores = 1L)
[17:59:22.788]                   }
[17:59:22.788]                   ...future.strategy.old <- future::plan("list")
[17:59:22.788]                   options(future.plan = NULL)
[17:59:22.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:22.788]                 }
[17:59:22.788]                 ...future.workdir <- getwd()
[17:59:22.788]             }
[17:59:22.788]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:22.788]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:22.788]         }
[17:59:22.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:22.788]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:22.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:22.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:22.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:22.788]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:22.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:22.788]             base::names(...future.oldOptions))
[17:59:22.788]     }
[17:59:22.788]     if (FALSE) {
[17:59:22.788]     }
[17:59:22.788]     else {
[17:59:22.788]         if (TRUE) {
[17:59:22.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:22.788]                 open = "w")
[17:59:22.788]         }
[17:59:22.788]         else {
[17:59:22.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:22.788]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:22.788]         }
[17:59:22.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:22.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:22.788]             base::sink(type = "output", split = FALSE)
[17:59:22.788]             base::close(...future.stdout)
[17:59:22.788]         }, add = TRUE)
[17:59:22.788]     }
[17:59:22.788]     ...future.frame <- base::sys.nframe()
[17:59:22.788]     ...future.conditions <- base::list()
[17:59:22.788]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:22.788]     if (FALSE) {
[17:59:22.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:22.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:22.788]     }
[17:59:22.788]     ...future.result <- base::tryCatch({
[17:59:22.788]         base::withCallingHandlers({
[17:59:22.788]             ...future.value <- base::withVisible(base::local({
[17:59:22.788]                 ...future.makeSendCondition <- base::local({
[17:59:22.788]                   sendCondition <- NULL
[17:59:22.788]                   function(frame = 1L) {
[17:59:22.788]                     if (is.function(sendCondition)) 
[17:59:22.788]                       return(sendCondition)
[17:59:22.788]                     ns <- getNamespace("parallel")
[17:59:22.788]                     if (exists("sendData", mode = "function", 
[17:59:22.788]                       envir = ns)) {
[17:59:22.788]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:22.788]                         envir = ns)
[17:59:22.788]                       envir <- sys.frame(frame)
[17:59:22.788]                       master <- NULL
[17:59:22.788]                       while (!identical(envir, .GlobalEnv) && 
[17:59:22.788]                         !identical(envir, emptyenv())) {
[17:59:22.788]                         if (exists("master", mode = "list", envir = envir, 
[17:59:22.788]                           inherits = FALSE)) {
[17:59:22.788]                           master <- get("master", mode = "list", 
[17:59:22.788]                             envir = envir, inherits = FALSE)
[17:59:22.788]                           if (inherits(master, c("SOCKnode", 
[17:59:22.788]                             "SOCK0node"))) {
[17:59:22.788]                             sendCondition <<- function(cond) {
[17:59:22.788]                               data <- list(type = "VALUE", value = cond, 
[17:59:22.788]                                 success = TRUE)
[17:59:22.788]                               parallel_sendData(master, data)
[17:59:22.788]                             }
[17:59:22.788]                             return(sendCondition)
[17:59:22.788]                           }
[17:59:22.788]                         }
[17:59:22.788]                         frame <- frame + 1L
[17:59:22.788]                         envir <- sys.frame(frame)
[17:59:22.788]                       }
[17:59:22.788]                     }
[17:59:22.788]                     sendCondition <<- function(cond) NULL
[17:59:22.788]                   }
[17:59:22.788]                 })
[17:59:22.788]                 withCallingHandlers({
[17:59:22.788]                   {
[17:59:22.788]                     do.call(function(...) {
[17:59:22.788]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.788]                       if (!identical(...future.globals.maxSize.org, 
[17:59:22.788]                         ...future.globals.maxSize)) {
[17:59:22.788]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.788]                         on.exit(options(oopts), add = TRUE)
[17:59:22.788]                       }
[17:59:22.788]                       {
[17:59:22.788]                         lapply(seq_along(...future.elements_ii), 
[17:59:22.788]                           FUN = function(jj) {
[17:59:22.788]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.788]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:22.788]                               envir = globalenv(), inherits = FALSE)
[17:59:22.788]                             ...future.FUN(...future.X_jj, ...)
[17:59:22.788]                           })
[17:59:22.788]                       }
[17:59:22.788]                     }, args = future.call.arguments)
[17:59:22.788]                   }
[17:59:22.788]                 }, immediateCondition = function(cond) {
[17:59:22.788]                   sendCondition <- ...future.makeSendCondition()
[17:59:22.788]                   sendCondition(cond)
[17:59:22.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.788]                   {
[17:59:22.788]                     inherits <- base::inherits
[17:59:22.788]                     invokeRestart <- base::invokeRestart
[17:59:22.788]                     is.null <- base::is.null
[17:59:22.788]                     muffled <- FALSE
[17:59:22.788]                     if (inherits(cond, "message")) {
[17:59:22.788]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:22.788]                       if (muffled) 
[17:59:22.788]                         invokeRestart("muffleMessage")
[17:59:22.788]                     }
[17:59:22.788]                     else if (inherits(cond, "warning")) {
[17:59:22.788]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:22.788]                       if (muffled) 
[17:59:22.788]                         invokeRestart("muffleWarning")
[17:59:22.788]                     }
[17:59:22.788]                     else if (inherits(cond, "condition")) {
[17:59:22.788]                       if (!is.null(pattern)) {
[17:59:22.788]                         computeRestarts <- base::computeRestarts
[17:59:22.788]                         grepl <- base::grepl
[17:59:22.788]                         restarts <- computeRestarts(cond)
[17:59:22.788]                         for (restart in restarts) {
[17:59:22.788]                           name <- restart$name
[17:59:22.788]                           if (is.null(name)) 
[17:59:22.788]                             next
[17:59:22.788]                           if (!grepl(pattern, name)) 
[17:59:22.788]                             next
[17:59:22.788]                           invokeRestart(restart)
[17:59:22.788]                           muffled <- TRUE
[17:59:22.788]                           break
[17:59:22.788]                         }
[17:59:22.788]                       }
[17:59:22.788]                     }
[17:59:22.788]                     invisible(muffled)
[17:59:22.788]                   }
[17:59:22.788]                   muffleCondition(cond)
[17:59:22.788]                 })
[17:59:22.788]             }))
[17:59:22.788]             future::FutureResult(value = ...future.value$value, 
[17:59:22.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.788]                   ...future.rng), globalenv = if (FALSE) 
[17:59:22.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:22.788]                     ...future.globalenv.names))
[17:59:22.788]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:22.788]         }, condition = base::local({
[17:59:22.788]             c <- base::c
[17:59:22.788]             inherits <- base::inherits
[17:59:22.788]             invokeRestart <- base::invokeRestart
[17:59:22.788]             length <- base::length
[17:59:22.788]             list <- base::list
[17:59:22.788]             seq.int <- base::seq.int
[17:59:22.788]             signalCondition <- base::signalCondition
[17:59:22.788]             sys.calls <- base::sys.calls
[17:59:22.788]             `[[` <- base::`[[`
[17:59:22.788]             `+` <- base::`+`
[17:59:22.788]             `<<-` <- base::`<<-`
[17:59:22.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:22.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:22.788]                   3L)]
[17:59:22.788]             }
[17:59:22.788]             function(cond) {
[17:59:22.788]                 is_error <- inherits(cond, "error")
[17:59:22.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:22.788]                   NULL)
[17:59:22.788]                 if (is_error) {
[17:59:22.788]                   sessionInformation <- function() {
[17:59:22.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:22.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:22.788]                       search = base::search(), system = base::Sys.info())
[17:59:22.788]                   }
[17:59:22.788]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:22.788]                     cond$call), session = sessionInformation(), 
[17:59:22.788]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:22.788]                   signalCondition(cond)
[17:59:22.788]                 }
[17:59:22.788]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:59:22.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:22.788]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:22.788]                   if (TRUE && !signal) {
[17:59:22.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.788]                     {
[17:59:22.788]                       inherits <- base::inherits
[17:59:22.788]                       invokeRestart <- base::invokeRestart
[17:59:22.788]                       is.null <- base::is.null
[17:59:22.788]                       muffled <- FALSE
[17:59:22.788]                       if (inherits(cond, "message")) {
[17:59:22.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.788]                         if (muffled) 
[17:59:22.788]                           invokeRestart("muffleMessage")
[17:59:22.788]                       }
[17:59:22.788]                       else if (inherits(cond, "warning")) {
[17:59:22.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.788]                         if (muffled) 
[17:59:22.788]                           invokeRestart("muffleWarning")
[17:59:22.788]                       }
[17:59:22.788]                       else if (inherits(cond, "condition")) {
[17:59:22.788]                         if (!is.null(pattern)) {
[17:59:22.788]                           computeRestarts <- base::computeRestarts
[17:59:22.788]                           grepl <- base::grepl
[17:59:22.788]                           restarts <- computeRestarts(cond)
[17:59:22.788]                           for (restart in restarts) {
[17:59:22.788]                             name <- restart$name
[17:59:22.788]                             if (is.null(name)) 
[17:59:22.788]                               next
[17:59:22.788]                             if (!grepl(pattern, name)) 
[17:59:22.788]                               next
[17:59:22.788]                             invokeRestart(restart)
[17:59:22.788]                             muffled <- TRUE
[17:59:22.788]                             break
[17:59:22.788]                           }
[17:59:22.788]                         }
[17:59:22.788]                       }
[17:59:22.788]                       invisible(muffled)
[17:59:22.788]                     }
[17:59:22.788]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.788]                   }
[17:59:22.788]                 }
[17:59:22.788]                 else {
[17:59:22.788]                   if (TRUE) {
[17:59:22.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.788]                     {
[17:59:22.788]                       inherits <- base::inherits
[17:59:22.788]                       invokeRestart <- base::invokeRestart
[17:59:22.788]                       is.null <- base::is.null
[17:59:22.788]                       muffled <- FALSE
[17:59:22.788]                       if (inherits(cond, "message")) {
[17:59:22.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.788]                         if (muffled) 
[17:59:22.788]                           invokeRestart("muffleMessage")
[17:59:22.788]                       }
[17:59:22.788]                       else if (inherits(cond, "warning")) {
[17:59:22.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.788]                         if (muffled) 
[17:59:22.788]                           invokeRestart("muffleWarning")
[17:59:22.788]                       }
[17:59:22.788]                       else if (inherits(cond, "condition")) {
[17:59:22.788]                         if (!is.null(pattern)) {
[17:59:22.788]                           computeRestarts <- base::computeRestarts
[17:59:22.788]                           grepl <- base::grepl
[17:59:22.788]                           restarts <- computeRestarts(cond)
[17:59:22.788]                           for (restart in restarts) {
[17:59:22.788]                             name <- restart$name
[17:59:22.788]                             if (is.null(name)) 
[17:59:22.788]                               next
[17:59:22.788]                             if (!grepl(pattern, name)) 
[17:59:22.788]                               next
[17:59:22.788]                             invokeRestart(restart)
[17:59:22.788]                             muffled <- TRUE
[17:59:22.788]                             break
[17:59:22.788]                           }
[17:59:22.788]                         }
[17:59:22.788]                       }
[17:59:22.788]                       invisible(muffled)
[17:59:22.788]                     }
[17:59:22.788]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.788]                   }
[17:59:22.788]                 }
[17:59:22.788]             }
[17:59:22.788]         }))
[17:59:22.788]     }, error = function(ex) {
[17:59:22.788]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:22.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.788]                 ...future.rng), started = ...future.startTime, 
[17:59:22.788]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:22.788]             version = "1.8"), class = "FutureResult")
[17:59:22.788]     }, finally = {
[17:59:22.788]         if (!identical(...future.workdir, getwd())) 
[17:59:22.788]             setwd(...future.workdir)
[17:59:22.788]         {
[17:59:22.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:22.788]                 ...future.oldOptions$nwarnings <- NULL
[17:59:22.788]             }
[17:59:22.788]             base::options(...future.oldOptions)
[17:59:22.788]             if (.Platform$OS.type == "windows") {
[17:59:22.788]                 old_names <- names(...future.oldEnvVars)
[17:59:22.788]                 envs <- base::Sys.getenv()
[17:59:22.788]                 names <- names(envs)
[17:59:22.788]                 common <- intersect(names, old_names)
[17:59:22.788]                 added <- setdiff(names, old_names)
[17:59:22.788]                 removed <- setdiff(old_names, names)
[17:59:22.788]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:22.788]                   envs[common]]
[17:59:22.788]                 NAMES <- toupper(changed)
[17:59:22.788]                 args <- list()
[17:59:22.788]                 for (kk in seq_along(NAMES)) {
[17:59:22.788]                   name <- changed[[kk]]
[17:59:22.788]                   NAME <- NAMES[[kk]]
[17:59:22.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.788]                     next
[17:59:22.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.788]                 }
[17:59:22.788]                 NAMES <- toupper(added)
[17:59:22.788]                 for (kk in seq_along(NAMES)) {
[17:59:22.788]                   name <- added[[kk]]
[17:59:22.788]                   NAME <- NAMES[[kk]]
[17:59:22.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.788]                     next
[17:59:22.788]                   args[[name]] <- ""
[17:59:22.788]                 }
[17:59:22.788]                 NAMES <- toupper(removed)
[17:59:22.788]                 for (kk in seq_along(NAMES)) {
[17:59:22.788]                   name <- removed[[kk]]
[17:59:22.788]                   NAME <- NAMES[[kk]]
[17:59:22.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.788]                     next
[17:59:22.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.788]                 }
[17:59:22.788]                 if (length(args) > 0) 
[17:59:22.788]                   base::do.call(base::Sys.setenv, args = args)
[17:59:22.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:22.788]             }
[17:59:22.788]             else {
[17:59:22.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:22.788]             }
[17:59:22.788]             {
[17:59:22.788]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:22.788]                   0L) {
[17:59:22.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:22.788]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:22.788]                   base::options(opts)
[17:59:22.788]                 }
[17:59:22.788]                 {
[17:59:22.788]                   {
[17:59:22.788]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:22.788]                     NULL
[17:59:22.788]                   }
[17:59:22.788]                   options(future.plan = NULL)
[17:59:22.788]                   if (is.na(NA_character_)) 
[17:59:22.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:22.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:22.788]                     .init = FALSE)
[17:59:22.788]                 }
[17:59:22.788]             }
[17:59:22.788]         }
[17:59:22.788]     })
[17:59:22.788]     if (TRUE) {
[17:59:22.788]         base::sink(type = "output", split = FALSE)
[17:59:22.788]         if (TRUE) {
[17:59:22.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:22.788]         }
[17:59:22.788]         else {
[17:59:22.788]             ...future.result["stdout"] <- base::list(NULL)
[17:59:22.788]         }
[17:59:22.788]         base::close(...future.stdout)
[17:59:22.788]         ...future.stdout <- NULL
[17:59:22.788]     }
[17:59:22.788]     ...future.result$conditions <- ...future.conditions
[17:59:22.788]     ...future.result$finished <- base::Sys.time()
[17:59:22.788]     ...future.result
[17:59:22.788] }
[17:59:22.794] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[17:59:22.794] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:22.795] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:22.796] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[17:59:22.837] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[17:59:22.838] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:59:22.839] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:59:22.839] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[17:59:22.840] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[17:59:22.840] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:59:22.841] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:59:22.842] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[17:59:22.843] MultisessionFuture started
[17:59:22.843] - Launch lazy future ... done
[17:59:22.843] run() for ‘MultisessionFuture’ ... done
[17:59:22.844] Created future:
[17:59:22.844] MultisessionFuture:
[17:59:22.844] Label: ‘future_apply-1’
[17:59:22.844] Expression:
[17:59:22.844] {
[17:59:22.844]     do.call(function(...) {
[17:59:22.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.844]             on.exit(options(oopts), add = TRUE)
[17:59:22.844]         }
[17:59:22.844]         {
[17:59:22.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.844]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:22.844]                   envir = globalenv(), inherits = FALSE)
[17:59:22.844]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.844]             })
[17:59:22.844]         }
[17:59:22.844]     }, args = future.call.arguments)
[17:59:22.844] }
[17:59:22.844] Lazy evaluation: FALSE
[17:59:22.844] Asynchronous evaluation: TRUE
[17:59:22.844] Local evaluation: TRUE
[17:59:22.844] Environment: R_GlobalEnv
[17:59:22.844] Capture standard output: TRUE
[17:59:22.844] Capture condition classes: <none>
[17:59:22.844] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:22.844] Packages: <none>
[17:59:22.844] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:59:22.844] Resolved: FALSE
[17:59:22.844] Value: <not collected>
[17:59:22.844] Conditions captured: <none>
[17:59:22.844] Early signaling: FALSE
[17:59:22.844] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:22.844] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.857] Chunk #1 of 2 ... DONE
[17:59:22.858] Chunk #2 of 2 ...
[17:59:22.858]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:59:22.858]  - seeds: [1] <seeds>
[17:59:22.859]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.859] getGlobalsAndPackages() ...
[17:59:22.859] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.860] Resolving globals: FALSE
[17:59:22.860] Tweak future expression to call with '...' arguments ...
[17:59:22.860] {
[17:59:22.860]     do.call(function(...) {
[17:59:22.860]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.860]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.860]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.860]             on.exit(options(oopts), add = TRUE)
[17:59:22.860]         }
[17:59:22.860]         {
[17:59:22.860]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.860]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.860]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:22.860]                   envir = globalenv(), inherits = FALSE)
[17:59:22.860]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.860]             })
[17:59:22.860]         }
[17:59:22.860]     }, args = future.call.arguments)
[17:59:22.860] }
[17:59:22.861] Tweak future expression to call with '...' arguments ... DONE
[17:59:22.862] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:22.862] 
[17:59:22.863] getGlobalsAndPackages() ... DONE
[17:59:22.863] run() for ‘Future’ ...
[17:59:22.864] - state: ‘created’
[17:59:22.864] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:22.890] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:22.890]   - Field: ‘node’
[17:59:22.890]   - Field: ‘label’
[17:59:22.891]   - Field: ‘local’
[17:59:22.891]   - Field: ‘owner’
[17:59:22.891]   - Field: ‘envir’
[17:59:22.891]   - Field: ‘workers’
[17:59:22.891]   - Field: ‘packages’
[17:59:22.892]   - Field: ‘gc’
[17:59:22.892]   - Field: ‘conditions’
[17:59:22.892]   - Field: ‘persistent’
[17:59:22.892]   - Field: ‘expr’
[17:59:22.892]   - Field: ‘uuid’
[17:59:22.893]   - Field: ‘seed’
[17:59:22.893]   - Field: ‘version’
[17:59:22.893]   - Field: ‘result’
[17:59:22.893]   - Field: ‘asynchronous’
[17:59:22.893]   - Field: ‘calls’
[17:59:22.894]   - Field: ‘globals’
[17:59:22.894]   - Field: ‘stdout’
[17:59:22.894]   - Field: ‘earlySignal’
[17:59:22.894]   - Field: ‘lazy’
[17:59:22.894]   - Field: ‘state’
[17:59:22.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:22.895] - Launch lazy future ...
[17:59:22.895] Packages needed by the future expression (n = 0): <none>
[17:59:22.895] Packages needed by future strategies (n = 0): <none>
[17:59:22.896] {
[17:59:22.896]     {
[17:59:22.896]         {
[17:59:22.896]             ...future.startTime <- base::Sys.time()
[17:59:22.896]             {
[17:59:22.896]                 {
[17:59:22.896]                   {
[17:59:22.896]                     {
[17:59:22.896]                       base::local({
[17:59:22.896]                         has_future <- base::requireNamespace("future", 
[17:59:22.896]                           quietly = TRUE)
[17:59:22.896]                         if (has_future) {
[17:59:22.896]                           ns <- base::getNamespace("future")
[17:59:22.896]                           version <- ns[[".package"]][["version"]]
[17:59:22.896]                           if (is.null(version)) 
[17:59:22.896]                             version <- utils::packageVersion("future")
[17:59:22.896]                         }
[17:59:22.896]                         else {
[17:59:22.896]                           version <- NULL
[17:59:22.896]                         }
[17:59:22.896]                         if (!has_future || version < "1.8.0") {
[17:59:22.896]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:22.896]                             "", base::R.version$version.string), 
[17:59:22.896]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:22.896]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:22.896]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:22.896]                               "release", "version")], collapse = " "), 
[17:59:22.896]                             hostname = base::Sys.info()[["nodename"]])
[17:59:22.896]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:22.896]                             info)
[17:59:22.896]                           info <- base::paste(info, collapse = "; ")
[17:59:22.896]                           if (!has_future) {
[17:59:22.896]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:22.896]                               info)
[17:59:22.896]                           }
[17:59:22.896]                           else {
[17:59:22.896]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:22.896]                               info, version)
[17:59:22.896]                           }
[17:59:22.896]                           base::stop(msg)
[17:59:22.896]                         }
[17:59:22.896]                       })
[17:59:22.896]                     }
[17:59:22.896]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:22.896]                     base::options(mc.cores = 1L)
[17:59:22.896]                   }
[17:59:22.896]                   ...future.strategy.old <- future::plan("list")
[17:59:22.896]                   options(future.plan = NULL)
[17:59:22.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:22.896]                 }
[17:59:22.896]                 ...future.workdir <- getwd()
[17:59:22.896]             }
[17:59:22.896]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:22.896]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:22.896]         }
[17:59:22.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:22.896]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:59:22.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:22.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:22.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:22.896]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:22.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:22.896]             base::names(...future.oldOptions))
[17:59:22.896]     }
[17:59:22.896]     if (FALSE) {
[17:59:22.896]     }
[17:59:22.896]     else {
[17:59:22.896]         if (TRUE) {
[17:59:22.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:22.896]                 open = "w")
[17:59:22.896]         }
[17:59:22.896]         else {
[17:59:22.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:22.896]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:22.896]         }
[17:59:22.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:22.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:22.896]             base::sink(type = "output", split = FALSE)
[17:59:22.896]             base::close(...future.stdout)
[17:59:22.896]         }, add = TRUE)
[17:59:22.896]     }
[17:59:22.896]     ...future.frame <- base::sys.nframe()
[17:59:22.896]     ...future.conditions <- base::list()
[17:59:22.896]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:22.896]     if (FALSE) {
[17:59:22.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:22.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:22.896]     }
[17:59:22.896]     ...future.result <- base::tryCatch({
[17:59:22.896]         base::withCallingHandlers({
[17:59:22.896]             ...future.value <- base::withVisible(base::local({
[17:59:22.896]                 ...future.makeSendCondition <- base::local({
[17:59:22.896]                   sendCondition <- NULL
[17:59:22.896]                   function(frame = 1L) {
[17:59:22.896]                     if (is.function(sendCondition)) 
[17:59:22.896]                       return(sendCondition)
[17:59:22.896]                     ns <- getNamespace("parallel")
[17:59:22.896]                     if (exists("sendData", mode = "function", 
[17:59:22.896]                       envir = ns)) {
[17:59:22.896]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:22.896]                         envir = ns)
[17:59:22.896]                       envir <- sys.frame(frame)
[17:59:22.896]                       master <- NULL
[17:59:22.896]                       while (!identical(envir, .GlobalEnv) && 
[17:59:22.896]                         !identical(envir, emptyenv())) {
[17:59:22.896]                         if (exists("master", mode = "list", envir = envir, 
[17:59:22.896]                           inherits = FALSE)) {
[17:59:22.896]                           master <- get("master", mode = "list", 
[17:59:22.896]                             envir = envir, inherits = FALSE)
[17:59:22.896]                           if (inherits(master, c("SOCKnode", 
[17:59:22.896]                             "SOCK0node"))) {
[17:59:22.896]                             sendCondition <<- function(cond) {
[17:59:22.896]                               data <- list(type = "VALUE", value = cond, 
[17:59:22.896]                                 success = TRUE)
[17:59:22.896]                               parallel_sendData(master, data)
[17:59:22.896]                             }
[17:59:22.896]                             return(sendCondition)
[17:59:22.896]                           }
[17:59:22.896]                         }
[17:59:22.896]                         frame <- frame + 1L
[17:59:22.896]                         envir <- sys.frame(frame)
[17:59:22.896]                       }
[17:59:22.896]                     }
[17:59:22.896]                     sendCondition <<- function(cond) NULL
[17:59:22.896]                   }
[17:59:22.896]                 })
[17:59:22.896]                 withCallingHandlers({
[17:59:22.896]                   {
[17:59:22.896]                     do.call(function(...) {
[17:59:22.896]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.896]                       if (!identical(...future.globals.maxSize.org, 
[17:59:22.896]                         ...future.globals.maxSize)) {
[17:59:22.896]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.896]                         on.exit(options(oopts), add = TRUE)
[17:59:22.896]                       }
[17:59:22.896]                       {
[17:59:22.896]                         lapply(seq_along(...future.elements_ii), 
[17:59:22.896]                           FUN = function(jj) {
[17:59:22.896]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.896]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:22.896]                               envir = globalenv(), inherits = FALSE)
[17:59:22.896]                             ...future.FUN(...future.X_jj, ...)
[17:59:22.896]                           })
[17:59:22.896]                       }
[17:59:22.896]                     }, args = future.call.arguments)
[17:59:22.896]                   }
[17:59:22.896]                 }, immediateCondition = function(cond) {
[17:59:22.896]                   sendCondition <- ...future.makeSendCondition()
[17:59:22.896]                   sendCondition(cond)
[17:59:22.896]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.896]                   {
[17:59:22.896]                     inherits <- base::inherits
[17:59:22.896]                     invokeRestart <- base::invokeRestart
[17:59:22.896]                     is.null <- base::is.null
[17:59:22.896]                     muffled <- FALSE
[17:59:22.896]                     if (inherits(cond, "message")) {
[17:59:22.896]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:22.896]                       if (muffled) 
[17:59:22.896]                         invokeRestart("muffleMessage")
[17:59:22.896]                     }
[17:59:22.896]                     else if (inherits(cond, "warning")) {
[17:59:22.896]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:22.896]                       if (muffled) 
[17:59:22.896]                         invokeRestart("muffleWarning")
[17:59:22.896]                     }
[17:59:22.896]                     else if (inherits(cond, "condition")) {
[17:59:22.896]                       if (!is.null(pattern)) {
[17:59:22.896]                         computeRestarts <- base::computeRestarts
[17:59:22.896]                         grepl <- base::grepl
[17:59:22.896]                         restarts <- computeRestarts(cond)
[17:59:22.896]                         for (restart in restarts) {
[17:59:22.896]                           name <- restart$name
[17:59:22.896]                           if (is.null(name)) 
[17:59:22.896]                             next
[17:59:22.896]                           if (!grepl(pattern, name)) 
[17:59:22.896]                             next
[17:59:22.896]                           invokeRestart(restart)
[17:59:22.896]                           muffled <- TRUE
[17:59:22.896]                           break
[17:59:22.896]                         }
[17:59:22.896]                       }
[17:59:22.896]                     }
[17:59:22.896]                     invisible(muffled)
[17:59:22.896]                   }
[17:59:22.896]                   muffleCondition(cond)
[17:59:22.896]                 })
[17:59:22.896]             }))
[17:59:22.896]             future::FutureResult(value = ...future.value$value, 
[17:59:22.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.896]                   ...future.rng), globalenv = if (FALSE) 
[17:59:22.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:22.896]                     ...future.globalenv.names))
[17:59:22.896]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:22.896]         }, condition = base::local({
[17:59:22.896]             c <- base::c
[17:59:22.896]             inherits <- base::inherits
[17:59:22.896]             invokeRestart <- base::invokeRestart
[17:59:22.896]             length <- base::length
[17:59:22.896]             list <- base::list
[17:59:22.896]             seq.int <- base::seq.int
[17:59:22.896]             signalCondition <- base::signalCondition
[17:59:22.896]             sys.calls <- base::sys.calls
[17:59:22.896]             `[[` <- base::`[[`
[17:59:22.896]             `+` <- base::`+`
[17:59:22.896]             `<<-` <- base::`<<-`
[17:59:22.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:22.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:22.896]                   3L)]
[17:59:22.896]             }
[17:59:22.896]             function(cond) {
[17:59:22.896]                 is_error <- inherits(cond, "error")
[17:59:22.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:22.896]                   NULL)
[17:59:22.896]                 if (is_error) {
[17:59:22.896]                   sessionInformation <- function() {
[17:59:22.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:22.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:22.896]                       search = base::search(), system = base::Sys.info())
[17:59:22.896]                   }
[17:59:22.896]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:22.896]                     cond$call), session = sessionInformation(), 
[17:59:22.896]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:22.896]                   signalCondition(cond)
[17:59:22.896]                 }
[17:59:22.896]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:59:22.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:22.896]                   ...future.conditions[[length(...future.conditions) + 
[17:59:22.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:22.896]                   if (TRUE && !signal) {
[17:59:22.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.896]                     {
[17:59:22.896]                       inherits <- base::inherits
[17:59:22.896]                       invokeRestart <- base::invokeRestart
[17:59:22.896]                       is.null <- base::is.null
[17:59:22.896]                       muffled <- FALSE
[17:59:22.896]                       if (inherits(cond, "message")) {
[17:59:22.896]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.896]                         if (muffled) 
[17:59:22.896]                           invokeRestart("muffleMessage")
[17:59:22.896]                       }
[17:59:22.896]                       else if (inherits(cond, "warning")) {
[17:59:22.896]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.896]                         if (muffled) 
[17:59:22.896]                           invokeRestart("muffleWarning")
[17:59:22.896]                       }
[17:59:22.896]                       else if (inherits(cond, "condition")) {
[17:59:22.896]                         if (!is.null(pattern)) {
[17:59:22.896]                           computeRestarts <- base::computeRestarts
[17:59:22.896]                           grepl <- base::grepl
[17:59:22.896]                           restarts <- computeRestarts(cond)
[17:59:22.896]                           for (restart in restarts) {
[17:59:22.896]                             name <- restart$name
[17:59:22.896]                             if (is.null(name)) 
[17:59:22.896]                               next
[17:59:22.896]                             if (!grepl(pattern, name)) 
[17:59:22.896]                               next
[17:59:22.896]                             invokeRestart(restart)
[17:59:22.896]                             muffled <- TRUE
[17:59:22.896]                             break
[17:59:22.896]                           }
[17:59:22.896]                         }
[17:59:22.896]                       }
[17:59:22.896]                       invisible(muffled)
[17:59:22.896]                     }
[17:59:22.896]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.896]                   }
[17:59:22.896]                 }
[17:59:22.896]                 else {
[17:59:22.896]                   if (TRUE) {
[17:59:22.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:22.896]                     {
[17:59:22.896]                       inherits <- base::inherits
[17:59:22.896]                       invokeRestart <- base::invokeRestart
[17:59:22.896]                       is.null <- base::is.null
[17:59:22.896]                       muffled <- FALSE
[17:59:22.896]                       if (inherits(cond, "message")) {
[17:59:22.896]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:22.896]                         if (muffled) 
[17:59:22.896]                           invokeRestart("muffleMessage")
[17:59:22.896]                       }
[17:59:22.896]                       else if (inherits(cond, "warning")) {
[17:59:22.896]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:22.896]                         if (muffled) 
[17:59:22.896]                           invokeRestart("muffleWarning")
[17:59:22.896]                       }
[17:59:22.896]                       else if (inherits(cond, "condition")) {
[17:59:22.896]                         if (!is.null(pattern)) {
[17:59:22.896]                           computeRestarts <- base::computeRestarts
[17:59:22.896]                           grepl <- base::grepl
[17:59:22.896]                           restarts <- computeRestarts(cond)
[17:59:22.896]                           for (restart in restarts) {
[17:59:22.896]                             name <- restart$name
[17:59:22.896]                             if (is.null(name)) 
[17:59:22.896]                               next
[17:59:22.896]                             if (!grepl(pattern, name)) 
[17:59:22.896]                               next
[17:59:22.896]                             invokeRestart(restart)
[17:59:22.896]                             muffled <- TRUE
[17:59:22.896]                             break
[17:59:22.896]                           }
[17:59:22.896]                         }
[17:59:22.896]                       }
[17:59:22.896]                       invisible(muffled)
[17:59:22.896]                     }
[17:59:22.896]                     muffleCondition(cond, pattern = "^muffle")
[17:59:22.896]                   }
[17:59:22.896]                 }
[17:59:22.896]             }
[17:59:22.896]         }))
[17:59:22.896]     }, error = function(ex) {
[17:59:22.896]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:22.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:22.896]                 ...future.rng), started = ...future.startTime, 
[17:59:22.896]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:22.896]             version = "1.8"), class = "FutureResult")
[17:59:22.896]     }, finally = {
[17:59:22.896]         if (!identical(...future.workdir, getwd())) 
[17:59:22.896]             setwd(...future.workdir)
[17:59:22.896]         {
[17:59:22.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:22.896]                 ...future.oldOptions$nwarnings <- NULL
[17:59:22.896]             }
[17:59:22.896]             base::options(...future.oldOptions)
[17:59:22.896]             if (.Platform$OS.type == "windows") {
[17:59:22.896]                 old_names <- names(...future.oldEnvVars)
[17:59:22.896]                 envs <- base::Sys.getenv()
[17:59:22.896]                 names <- names(envs)
[17:59:22.896]                 common <- intersect(names, old_names)
[17:59:22.896]                 added <- setdiff(names, old_names)
[17:59:22.896]                 removed <- setdiff(old_names, names)
[17:59:22.896]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:22.896]                   envs[common]]
[17:59:22.896]                 NAMES <- toupper(changed)
[17:59:22.896]                 args <- list()
[17:59:22.896]                 for (kk in seq_along(NAMES)) {
[17:59:22.896]                   name <- changed[[kk]]
[17:59:22.896]                   NAME <- NAMES[[kk]]
[17:59:22.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.896]                     next
[17:59:22.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.896]                 }
[17:59:22.896]                 NAMES <- toupper(added)
[17:59:22.896]                 for (kk in seq_along(NAMES)) {
[17:59:22.896]                   name <- added[[kk]]
[17:59:22.896]                   NAME <- NAMES[[kk]]
[17:59:22.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.896]                     next
[17:59:22.896]                   args[[name]] <- ""
[17:59:22.896]                 }
[17:59:22.896]                 NAMES <- toupper(removed)
[17:59:22.896]                 for (kk in seq_along(NAMES)) {
[17:59:22.896]                   name <- removed[[kk]]
[17:59:22.896]                   NAME <- NAMES[[kk]]
[17:59:22.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:22.896]                     next
[17:59:22.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:22.896]                 }
[17:59:22.896]                 if (length(args) > 0) 
[17:59:22.896]                   base::do.call(base::Sys.setenv, args = args)
[17:59:22.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:22.896]             }
[17:59:22.896]             else {
[17:59:22.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:22.896]             }
[17:59:22.896]             {
[17:59:22.896]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:22.896]                   0L) {
[17:59:22.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:22.896]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:22.896]                   base::options(opts)
[17:59:22.896]                 }
[17:59:22.896]                 {
[17:59:22.896]                   {
[17:59:22.896]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:22.896]                     NULL
[17:59:22.896]                   }
[17:59:22.896]                   options(future.plan = NULL)
[17:59:22.896]                   if (is.na(NA_character_)) 
[17:59:22.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:22.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:22.896]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:22.896]                     .init = FALSE)
[17:59:22.896]                 }
[17:59:22.896]             }
[17:59:22.896]         }
[17:59:22.896]     })
[17:59:22.896]     if (TRUE) {
[17:59:22.896]         base::sink(type = "output", split = FALSE)
[17:59:22.896]         if (TRUE) {
[17:59:22.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:22.896]         }
[17:59:22.896]         else {
[17:59:22.896]             ...future.result["stdout"] <- base::list(NULL)
[17:59:22.896]         }
[17:59:22.896]         base::close(...future.stdout)
[17:59:22.896]         ...future.stdout <- NULL
[17:59:22.896]     }
[17:59:22.896]     ...future.result$conditions <- ...future.conditions
[17:59:22.896]     ...future.result$finished <- base::Sys.time()
[17:59:22.896]     ...future.result
[17:59:22.896] }
[17:59:22.902] Exporting 5 global objects (35.63 KiB) to cluster node #2 ...
[17:59:22.903] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:22.903] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:22.904] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[17:59:22.945] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[17:59:22.946] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:59:22.947] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:59:22.947] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[17:59:22.948] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[17:59:22.949] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:59:22.949] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:59:22.950] Exporting 5 global objects (35.63 KiB) to cluster node #2 ... DONE
[17:59:22.952] MultisessionFuture started
[17:59:22.952] - Launch lazy future ... done
[17:59:22.952] run() for ‘MultisessionFuture’ ... done
[17:59:22.952] Created future:
[17:59:22.952] MultisessionFuture:
[17:59:22.952] Label: ‘future_apply-2’
[17:59:22.952] Expression:
[17:59:22.952] {
[17:59:22.952]     do.call(function(...) {
[17:59:22.952]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:22.952]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:22.952]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:22.952]             on.exit(options(oopts), add = TRUE)
[17:59:22.952]         }
[17:59:22.952]         {
[17:59:22.952]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:22.952]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:22.952]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:59:22.952]                   envir = globalenv(), inherits = FALSE)
[17:59:22.952]                 ...future.FUN(...future.X_jj, ...)
[17:59:22.952]             })
[17:59:22.952]         }
[17:59:22.952]     }, args = future.call.arguments)
[17:59:22.952] }
[17:59:22.952] Lazy evaluation: FALSE
[17:59:22.952] Asynchronous evaluation: TRUE
[17:59:22.952] Local evaluation: TRUE
[17:59:22.952] Environment: R_GlobalEnv
[17:59:22.952] Capture standard output: TRUE
[17:59:22.952] Capture condition classes: <none>
[17:59:22.952] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:59:22.952] Packages: <none>
[17:59:22.952] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:59:22.952] Resolved: FALSE
[17:59:22.952] Value: <not collected>
[17:59:22.952] Conditions captured: <none>
[17:59:22.952] Early signaling: FALSE
[17:59:22.952] Owner process: 8e750815-209b-d78a-0c15-443f046dd386
[17:59:22.952] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:22.966] Chunk #2 of 2 ... DONE
[17:59:22.966] Launching 2 futures (chunks) ... DONE
[17:59:22.967] Resolving 2 futures (chunks) ...
[17:59:22.967] resolve() on list ...
[17:59:22.967]  recursive: 0
[17:59:22.967]  length: 2
[17:59:22.968] 
[17:59:22.969] receiveMessageFromWorker() for ClusterFuture ...
[17:59:22.969] - Validating connection of MultisessionFuture
[17:59:22.969] - received message: FutureResult
[17:59:22.970] - Received FutureResult
[17:59:22.970] - Erased future from FutureRegistry
[17:59:22.970] result() for ClusterFuture ...
[17:59:22.970] - result already collected: FutureResult
[17:59:22.971] result() for ClusterFuture ... done
[17:59:22.971] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:22.971] Future #1
[17:59:22.971] result() for ClusterFuture ...
[17:59:22.972] - result already collected: FutureResult
[17:59:22.972] result() for ClusterFuture ... done
[17:59:22.972] result() for ClusterFuture ...
[17:59:22.972] - result already collected: FutureResult
[17:59:22.973] result() for ClusterFuture ... done
[17:59:22.973] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:22.973] - nx: 2
[17:59:22.973] - relay: TRUE
[17:59:22.974] - stdout: TRUE
[17:59:22.974] - signal: TRUE
[17:59:22.974] - resignal: FALSE
[17:59:22.974] - force: TRUE
[17:59:22.974] - relayed: [n=2] FALSE, FALSE
[17:59:22.975] - queued futures: [n=2] FALSE, FALSE
[17:59:22.975]  - until=1
[17:59:22.975]  - relaying element #1
[17:59:22.975] result() for ClusterFuture ...
[17:59:22.976] - result already collected: FutureResult
[17:59:22.976] result() for ClusterFuture ... done
[17:59:22.976] result() for ClusterFuture ...
[17:59:22.976] - result already collected: FutureResult
[17:59:22.976] result() for ClusterFuture ... done
[17:59:22.977] result() for ClusterFuture ...
[17:59:22.977] - result already collected: FutureResult
[17:59:22.977] result() for ClusterFuture ... done
[17:59:22.978] result() for ClusterFuture ...
[17:59:22.978] - result already collected: FutureResult
[17:59:22.978] result() for ClusterFuture ... done
[17:59:22.978] - relayed: [n=2] TRUE, FALSE
[17:59:22.978] - queued futures: [n=2] TRUE, FALSE
[17:59:22.979] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:22.979]  length: 1 (resolved future 1)
[17:59:23.001] receiveMessageFromWorker() for ClusterFuture ...
[17:59:23.002] - Validating connection of MultisessionFuture
[17:59:23.002] - received message: FutureResult
[17:59:23.002] - Received FutureResult
[17:59:23.003] - Erased future from FutureRegistry
[17:59:23.003] result() for ClusterFuture ...
[17:59:23.003] - result already collected: FutureResult
[17:59:23.003] result() for ClusterFuture ... done
[17:59:23.004] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:23.004] Future #2
[17:59:23.004] result() for ClusterFuture ...
[17:59:23.004] - result already collected: FutureResult
[17:59:23.005] result() for ClusterFuture ... done
[17:59:23.005] result() for ClusterFuture ...
[17:59:23.005] - result already collected: FutureResult
[17:59:23.005] result() for ClusterFuture ... done
[17:59:23.006] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:23.006] - nx: 2
[17:59:23.006] - relay: TRUE
[17:59:23.006] - stdout: TRUE
[17:59:23.007] - signal: TRUE
[17:59:23.007] - resignal: FALSE
[17:59:23.007] - force: TRUE
[17:59:23.007] - relayed: [n=2] TRUE, FALSE
[17:59:23.007] - queued futures: [n=2] TRUE, FALSE
[17:59:23.008]  - until=2
[17:59:23.008]  - relaying element #2
[17:59:23.012] result() for ClusterFuture ...
[17:59:23.012] - result already collected: FutureResult
[17:59:23.012] result() for ClusterFuture ... done
[17:59:23.012] result() for ClusterFuture ...
[17:59:23.013] - result already collected: FutureResult
[17:59:23.013] result() for ClusterFuture ... done
[17:59:23.013] result() for ClusterFuture ...
[17:59:23.013] - result already collected: FutureResult
[17:59:23.014] result() for ClusterFuture ... done
[17:59:23.014] result() for ClusterFuture ...
[17:59:23.014] - result already collected: FutureResult
[17:59:23.014] result() for ClusterFuture ... done
[17:59:23.015] - relayed: [n=2] TRUE, TRUE
[17:59:23.015] - queued futures: [n=2] TRUE, TRUE
[17:59:23.015] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:23.015]  length: 0 (resolved future 2)
[17:59:23.016] Relaying remaining futures
[17:59:23.016] signalConditionsASAP(NULL, pos=0) ...
[17:59:23.016] - nx: 2
[17:59:23.016] - relay: TRUE
[17:59:23.016] - stdout: TRUE
[17:59:23.017] - signal: TRUE
[17:59:23.017] - resignal: FALSE
[17:59:23.017] - force: TRUE
[17:59:23.017] - relayed: [n=2] TRUE, TRUE
[17:59:23.017] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:23.018] - relayed: [n=2] TRUE, TRUE
[17:59:23.018] - queued futures: [n=2] TRUE, TRUE
[17:59:23.018] signalConditionsASAP(NULL, pos=0) ... done
[17:59:23.019] resolve() on list ... DONE
[17:59:23.019] result() for ClusterFuture ...
[17:59:23.019] - result already collected: FutureResult
[17:59:23.019] result() for ClusterFuture ... done
[17:59:23.019] result() for ClusterFuture ...
[17:59:23.020] - result already collected: FutureResult
[17:59:23.020] result() for ClusterFuture ... done
[17:59:23.020] result() for ClusterFuture ...
[17:59:23.020] - result already collected: FutureResult
[17:59:23.021] result() for ClusterFuture ... done
[17:59:23.021] result() for ClusterFuture ...
[17:59:23.021] - result already collected: FutureResult
[17:59:23.021] result() for ClusterFuture ... done
[17:59:23.022]  - Number of value chunks collected: 2
[17:59:23.022] Resolving 2 futures (chunks) ... DONE
[17:59:23.022] Reducing values from 2 chunks ...
[17:59:23.022]  - Number of values collected after concatenation: 2
[17:59:23.022]  - Number of values expected: 2
[17:59:23.023] Reducing values from 2 chunks ... DONE
[17:59:23.023] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:59:23.024] plan(): Setting new future strategy stack:
[17:59:23.024] List of future strategies:
[17:59:23.024] 1. sequential:
[17:59:23.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:23.024]    - tweaked: FALSE
[17:59:23.024]    - call: plan(sequential)
[17:59:23.026] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[17:59:23.031] plan(): Setting new future strategy stack:
[17:59:23.033] List of future strategies:
[17:59:23.033] 1. FutureStrategy:
[17:59:23.033]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:23.033]    - tweaked: FALSE
[17:59:23.033]    - call: future::plan(oplan)
[17:59:23.034] plan(): nbrOfWorkers() = 1
> 
