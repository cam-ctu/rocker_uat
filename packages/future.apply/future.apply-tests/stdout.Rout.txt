
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:01:15.674] plan(): Setting new future strategy stack:
[17:01:15.674] List of future strategies:
[17:01:15.674] 1. sequential:
[17:01:15.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:15.674]    - tweaked: FALSE
[17:01:15.674]    - call: future::plan("sequential")
[17:01:15.688] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[17:01:15.722] plan(): Setting new future strategy stack:
[17:01:15.722] List of future strategies:
[17:01:15.722] 1. sequential:
[17:01:15.722]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:15.722]    - tweaked: FALSE
[17:01:15.722]    - call: plan(strategy)
[17:01:15.733] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:01:15.734] future_lapply() ...
[17:01:15.738] Number of chunks: 1
[17:01:15.738] getGlobalsAndPackagesXApply() ...
[17:01:15.739]  - future.globals: TRUE
[17:01:15.739] getGlobalsAndPackages() ...
[17:01:15.739] Searching for globals...
[17:01:15.742] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:15.742] Searching for globals ... DONE
[17:01:15.742] Resolving globals: FALSE
[17:01:15.743] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:15.744] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:15.744] - globals: [1] ‘FUN’
[17:01:15.744] 
[17:01:15.744] getGlobalsAndPackages() ... DONE
[17:01:15.744]  - globals found/used: [n=1] ‘FUN’
[17:01:15.744]  - needed namespaces: [n=0] 
[17:01:15.744] Finding globals ... DONE
[17:01:15.744]  - use_args: TRUE
[17:01:15.744]  - Getting '...' globals ...
[17:01:15.745] resolve() on list ...
[17:01:15.745]  recursive: 0
[17:01:15.746]  length: 1
[17:01:15.746]  elements: ‘...’
[17:01:15.746]  length: 0 (resolved future 1)
[17:01:15.746] resolve() on list ... DONE
[17:01:15.746]    - '...' content: [n=0] 
[17:01:15.746] List of 1
[17:01:15.746]  $ ...: list()
[17:01:15.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:15.746]  - attr(*, "where")=List of 1
[17:01:15.746]   ..$ ...:<environment: 0x5636f699a310> 
[17:01:15.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:15.746]  - attr(*, "resolved")= logi TRUE
[17:01:15.746]  - attr(*, "total_size")= num NA
[17:01:15.751]  - Getting '...' globals ... DONE
[17:01:15.751] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:15.751] List of 2
[17:01:15.751]  $ ...future.FUN:function (x)  
[17:01:15.751]  $ ...          : list()
[17:01:15.751]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:15.751]  - attr(*, "where")=List of 2
[17:01:15.751]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:15.751]   ..$ ...          :<environment: 0x5636f699a310> 
[17:01:15.751]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:15.751]  - attr(*, "resolved")= logi FALSE
[17:01:15.751]  - attr(*, "total_size")= num 4720
[17:01:15.754] Packages to be attached in all futures: [n=0] 
[17:01:15.756] getGlobalsAndPackagesXApply() ... DONE
[17:01:15.757] Number of futures (= number of chunks): 1
[17:01:15.757] Launching 1 futures (chunks) ...
[17:01:15.757] Chunk #1 of 1 ...
[17:01:15.757]  - Finding globals in 'X' for chunk #1 ...
[17:01:15.757] getGlobalsAndPackages() ...
[17:01:15.757] Searching for globals...
[17:01:15.758] 
[17:01:15.758] Searching for globals ... DONE
[17:01:15.758] - globals: [0] <none>
[17:01:15.758] getGlobalsAndPackages() ... DONE
[17:01:15.758]    + additional globals found: [n=0] 
[17:01:15.758]    + additional namespaces needed: [n=0] 
[17:01:15.758]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:15.758]  - seeds: <none>
[17:01:15.758]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:15.759] getGlobalsAndPackages() ...
[17:01:15.759] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:15.759] Resolving globals: FALSE
[17:01:15.759] Tweak future expression to call with '...' arguments ...
[17:01:15.759] {
[17:01:15.759]     do.call(function(...) {
[17:01:15.759]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:15.759]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:15.759]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:15.759]             on.exit(options(oopts), add = TRUE)
[17:01:15.759]         }
[17:01:15.759]         {
[17:01:15.759]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:15.759]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:15.759]                 ...future.FUN(...future.X_jj, ...)
[17:01:15.759]             })
[17:01:15.759]         }
[17:01:15.759]     }, args = future.call.arguments)
[17:01:15.759] }
[17:01:15.759] Tweak future expression to call with '...' arguments ... DONE
[17:01:15.760] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:15.760] 
[17:01:15.760] getGlobalsAndPackages() ... DONE
[17:01:15.761] run() for ‘Future’ ...
[17:01:15.761] - state: ‘created’
[17:01:15.761] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:15.761] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:15.761] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:15.761]   - Field: ‘label’
[17:01:15.762]   - Field: ‘local’
[17:01:15.762]   - Field: ‘owner’
[17:01:15.762]   - Field: ‘envir’
[17:01:15.762]   - Field: ‘packages’
[17:01:15.762]   - Field: ‘gc’
[17:01:15.762]   - Field: ‘conditions’
[17:01:15.762]   - Field: ‘expr’
[17:01:15.762]   - Field: ‘uuid’
[17:01:15.762]   - Field: ‘seed’
[17:01:15.762]   - Field: ‘version’
[17:01:15.762]   - Field: ‘result’
[17:01:15.763]   - Field: ‘asynchronous’
[17:01:15.763]   - Field: ‘calls’
[17:01:15.763]   - Field: ‘globals’
[17:01:15.763]   - Field: ‘stdout’
[17:01:15.763]   - Field: ‘earlySignal’
[17:01:15.763]   - Field: ‘lazy’
[17:01:15.763]   - Field: ‘state’
[17:01:15.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:15.763] - Launch lazy future ...
[17:01:15.764] Packages needed by the future expression (n = 0): <none>
[17:01:15.764] Packages needed by future strategies (n = 0): <none>
[17:01:15.765] {
[17:01:15.765]     {
[17:01:15.765]         {
[17:01:15.765]             ...future.startTime <- base::Sys.time()
[17:01:15.765]             {
[17:01:15.765]                 {
[17:01:15.765]                   {
[17:01:15.765]                     base::local({
[17:01:15.765]                       has_future <- base::requireNamespace("future", 
[17:01:15.765]                         quietly = TRUE)
[17:01:15.765]                       if (has_future) {
[17:01:15.765]                         ns <- base::getNamespace("future")
[17:01:15.765]                         version <- ns[[".package"]][["version"]]
[17:01:15.765]                         if (is.null(version)) 
[17:01:15.765]                           version <- utils::packageVersion("future")
[17:01:15.765]                       }
[17:01:15.765]                       else {
[17:01:15.765]                         version <- NULL
[17:01:15.765]                       }
[17:01:15.765]                       if (!has_future || version < "1.8.0") {
[17:01:15.765]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:15.765]                           "", base::R.version$version.string), 
[17:01:15.765]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:15.765]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:15.765]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:15.765]                             "release", "version")], collapse = " "), 
[17:01:15.765]                           hostname = base::Sys.info()[["nodename"]])
[17:01:15.765]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:15.765]                           info)
[17:01:15.765]                         info <- base::paste(info, collapse = "; ")
[17:01:15.765]                         if (!has_future) {
[17:01:15.765]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:15.765]                             info)
[17:01:15.765]                         }
[17:01:15.765]                         else {
[17:01:15.765]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:15.765]                             info, version)
[17:01:15.765]                         }
[17:01:15.765]                         base::stop(msg)
[17:01:15.765]                       }
[17:01:15.765]                     })
[17:01:15.765]                   }
[17:01:15.765]                   ...future.strategy.old <- future::plan("list")
[17:01:15.765]                   options(future.plan = NULL)
[17:01:15.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:15.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:15.765]                 }
[17:01:15.765]                 ...future.workdir <- getwd()
[17:01:15.765]             }
[17:01:15.765]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:15.765]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:15.765]         }
[17:01:15.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:15.765]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:15.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:15.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:15.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:15.765]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:15.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:15.765]             base::names(...future.oldOptions))
[17:01:15.765]     }
[17:01:15.765]     if (FALSE) {
[17:01:15.765]     }
[17:01:15.765]     else {
[17:01:15.765]         if (FALSE) {
[17:01:15.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:15.765]                 open = "w")
[17:01:15.765]         }
[17:01:15.765]         else {
[17:01:15.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:15.765]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:15.765]         }
[17:01:15.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:15.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:15.765]             base::sink(type = "output", split = FALSE)
[17:01:15.765]             base::close(...future.stdout)
[17:01:15.765]         }, add = TRUE)
[17:01:15.765]     }
[17:01:15.765]     ...future.frame <- base::sys.nframe()
[17:01:15.765]     ...future.conditions <- base::list()
[17:01:15.765]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:15.765]     if (FALSE) {
[17:01:15.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:15.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:15.765]     }
[17:01:15.765]     ...future.result <- base::tryCatch({
[17:01:15.765]         base::withCallingHandlers({
[17:01:15.765]             ...future.value <- base::withVisible(base::local({
[17:01:15.765]                 do.call(function(...) {
[17:01:15.765]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:15.765]                   if (!identical(...future.globals.maxSize.org, 
[17:01:15.765]                     ...future.globals.maxSize)) {
[17:01:15.765]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:15.765]                     on.exit(options(oopts), add = TRUE)
[17:01:15.765]                   }
[17:01:15.765]                   {
[17:01:15.765]                     lapply(seq_along(...future.elements_ii), 
[17:01:15.765]                       FUN = function(jj) {
[17:01:15.765]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:15.765]                         ...future.FUN(...future.X_jj, ...)
[17:01:15.765]                       })
[17:01:15.765]                   }
[17:01:15.765]                 }, args = future.call.arguments)
[17:01:15.765]             }))
[17:01:15.765]             future::FutureResult(value = ...future.value$value, 
[17:01:15.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:15.765]                   ...future.rng), globalenv = if (FALSE) 
[17:01:15.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:15.765]                     ...future.globalenv.names))
[17:01:15.765]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:15.765]         }, condition = base::local({
[17:01:15.765]             c <- base::c
[17:01:15.765]             inherits <- base::inherits
[17:01:15.765]             invokeRestart <- base::invokeRestart
[17:01:15.765]             length <- base::length
[17:01:15.765]             list <- base::list
[17:01:15.765]             seq.int <- base::seq.int
[17:01:15.765]             signalCondition <- base::signalCondition
[17:01:15.765]             sys.calls <- base::sys.calls
[17:01:15.765]             `[[` <- base::`[[`
[17:01:15.765]             `+` <- base::`+`
[17:01:15.765]             `<<-` <- base::`<<-`
[17:01:15.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:15.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:15.765]                   3L)]
[17:01:15.765]             }
[17:01:15.765]             function(cond) {
[17:01:15.765]                 is_error <- inherits(cond, "error")
[17:01:15.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:15.765]                   NULL)
[17:01:15.765]                 if (is_error) {
[17:01:15.765]                   sessionInformation <- function() {
[17:01:15.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:15.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:15.765]                       search = base::search(), system = base::Sys.info())
[17:01:15.765]                   }
[17:01:15.765]                   ...future.conditions[[length(...future.conditions) + 
[17:01:15.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:15.765]                     cond$call), session = sessionInformation(), 
[17:01:15.765]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:15.765]                   signalCondition(cond)
[17:01:15.765]                 }
[17:01:15.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:15.765]                 "immediateCondition"))) {
[17:01:15.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:15.765]                   ...future.conditions[[length(...future.conditions) + 
[17:01:15.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:15.765]                   if (TRUE && !signal) {
[17:01:15.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:15.765]                     {
[17:01:15.765]                       inherits <- base::inherits
[17:01:15.765]                       invokeRestart <- base::invokeRestart
[17:01:15.765]                       is.null <- base::is.null
[17:01:15.765]                       muffled <- FALSE
[17:01:15.765]                       if (inherits(cond, "message")) {
[17:01:15.765]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:15.765]                         if (muffled) 
[17:01:15.765]                           invokeRestart("muffleMessage")
[17:01:15.765]                       }
[17:01:15.765]                       else if (inherits(cond, "warning")) {
[17:01:15.765]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:15.765]                         if (muffled) 
[17:01:15.765]                           invokeRestart("muffleWarning")
[17:01:15.765]                       }
[17:01:15.765]                       else if (inherits(cond, "condition")) {
[17:01:15.765]                         if (!is.null(pattern)) {
[17:01:15.765]                           computeRestarts <- base::computeRestarts
[17:01:15.765]                           grepl <- base::grepl
[17:01:15.765]                           restarts <- computeRestarts(cond)
[17:01:15.765]                           for (restart in restarts) {
[17:01:15.765]                             name <- restart$name
[17:01:15.765]                             if (is.null(name)) 
[17:01:15.765]                               next
[17:01:15.765]                             if (!grepl(pattern, name)) 
[17:01:15.765]                               next
[17:01:15.765]                             invokeRestart(restart)
[17:01:15.765]                             muffled <- TRUE
[17:01:15.765]                             break
[17:01:15.765]                           }
[17:01:15.765]                         }
[17:01:15.765]                       }
[17:01:15.765]                       invisible(muffled)
[17:01:15.765]                     }
[17:01:15.765]                     muffleCondition(cond, pattern = "^muffle")
[17:01:15.765]                   }
[17:01:15.765]                 }
[17:01:15.765]                 else {
[17:01:15.765]                   if (TRUE) {
[17:01:15.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:15.765]                     {
[17:01:15.765]                       inherits <- base::inherits
[17:01:15.765]                       invokeRestart <- base::invokeRestart
[17:01:15.765]                       is.null <- base::is.null
[17:01:15.765]                       muffled <- FALSE
[17:01:15.765]                       if (inherits(cond, "message")) {
[17:01:15.765]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:15.765]                         if (muffled) 
[17:01:15.765]                           invokeRestart("muffleMessage")
[17:01:15.765]                       }
[17:01:15.765]                       else if (inherits(cond, "warning")) {
[17:01:15.765]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:15.765]                         if (muffled) 
[17:01:15.765]                           invokeRestart("muffleWarning")
[17:01:15.765]                       }
[17:01:15.765]                       else if (inherits(cond, "condition")) {
[17:01:15.765]                         if (!is.null(pattern)) {
[17:01:15.765]                           computeRestarts <- base::computeRestarts
[17:01:15.765]                           grepl <- base::grepl
[17:01:15.765]                           restarts <- computeRestarts(cond)
[17:01:15.765]                           for (restart in restarts) {
[17:01:15.765]                             name <- restart$name
[17:01:15.765]                             if (is.null(name)) 
[17:01:15.765]                               next
[17:01:15.765]                             if (!grepl(pattern, name)) 
[17:01:15.765]                               next
[17:01:15.765]                             invokeRestart(restart)
[17:01:15.765]                             muffled <- TRUE
[17:01:15.765]                             break
[17:01:15.765]                           }
[17:01:15.765]                         }
[17:01:15.765]                       }
[17:01:15.765]                       invisible(muffled)
[17:01:15.765]                     }
[17:01:15.765]                     muffleCondition(cond, pattern = "^muffle")
[17:01:15.765]                   }
[17:01:15.765]                 }
[17:01:15.765]             }
[17:01:15.765]         }))
[17:01:15.765]     }, error = function(ex) {
[17:01:15.765]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:15.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:15.765]                 ...future.rng), started = ...future.startTime, 
[17:01:15.765]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:15.765]             version = "1.8"), class = "FutureResult")
[17:01:15.765]     }, finally = {
[17:01:15.765]         if (!identical(...future.workdir, getwd())) 
[17:01:15.765]             setwd(...future.workdir)
[17:01:15.765]         {
[17:01:15.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:15.765]                 ...future.oldOptions$nwarnings <- NULL
[17:01:15.765]             }
[17:01:15.765]             base::options(...future.oldOptions)
[17:01:15.765]             if (.Platform$OS.type == "windows") {
[17:01:15.765]                 old_names <- names(...future.oldEnvVars)
[17:01:15.765]                 envs <- base::Sys.getenv()
[17:01:15.765]                 names <- names(envs)
[17:01:15.765]                 common <- intersect(names, old_names)
[17:01:15.765]                 added <- setdiff(names, old_names)
[17:01:15.765]                 removed <- setdiff(old_names, names)
[17:01:15.765]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:15.765]                   envs[common]]
[17:01:15.765]                 NAMES <- toupper(changed)
[17:01:15.765]                 args <- list()
[17:01:15.765]                 for (kk in seq_along(NAMES)) {
[17:01:15.765]                   name <- changed[[kk]]
[17:01:15.765]                   NAME <- NAMES[[kk]]
[17:01:15.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:15.765]                     next
[17:01:15.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:15.765]                 }
[17:01:15.765]                 NAMES <- toupper(added)
[17:01:15.765]                 for (kk in seq_along(NAMES)) {
[17:01:15.765]                   name <- added[[kk]]
[17:01:15.765]                   NAME <- NAMES[[kk]]
[17:01:15.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:15.765]                     next
[17:01:15.765]                   args[[name]] <- ""
[17:01:15.765]                 }
[17:01:15.765]                 NAMES <- toupper(removed)
[17:01:15.765]                 for (kk in seq_along(NAMES)) {
[17:01:15.765]                   name <- removed[[kk]]
[17:01:15.765]                   NAME <- NAMES[[kk]]
[17:01:15.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:15.765]                     next
[17:01:15.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:15.765]                 }
[17:01:15.765]                 if (length(args) > 0) 
[17:01:15.765]                   base::do.call(base::Sys.setenv, args = args)
[17:01:15.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:15.765]             }
[17:01:15.765]             else {
[17:01:15.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:15.765]             }
[17:01:15.765]             {
[17:01:15.765]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:15.765]                   0L) {
[17:01:15.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:15.765]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:15.765]                   base::options(opts)
[17:01:15.765]                 }
[17:01:15.765]                 {
[17:01:15.765]                   {
[17:01:15.765]                     NULL
[17:01:15.765]                     RNGkind("Mersenne-Twister")
[17:01:15.765]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:15.765]                       inherits = FALSE)
[17:01:15.765]                   }
[17:01:15.765]                   options(future.plan = NULL)
[17:01:15.765]                   if (is.na(NA_character_)) 
[17:01:15.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:15.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:15.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:15.765]                     .init = FALSE)
[17:01:15.765]                 }
[17:01:15.765]             }
[17:01:15.765]         }
[17:01:15.765]     })
[17:01:15.765]     if (TRUE) {
[17:01:15.765]         base::sink(type = "output", split = FALSE)
[17:01:15.765]         if (FALSE) {
[17:01:15.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:15.765]         }
[17:01:15.765]         else {
[17:01:15.765]             ...future.result["stdout"] <- base::list(NULL)
[17:01:15.765]         }
[17:01:15.765]         base::close(...future.stdout)
[17:01:15.765]         ...future.stdout <- NULL
[17:01:15.765]     }
[17:01:15.765]     ...future.result$conditions <- ...future.conditions
[17:01:15.765]     ...future.result$finished <- base::Sys.time()
[17:01:15.765]     ...future.result
[17:01:15.765] }
[17:01:15.767] assign_globals() ...
[17:01:15.767] List of 5
[17:01:15.767]  $ ...future.FUN            :function (x)  
[17:01:15.767]  $ future.call.arguments    : list()
[17:01:15.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:15.767]  $ ...future.elements_ii    :List of 2
[17:01:15.767]   ..$ : int 1
[17:01:15.767]   ..$ : int 0
[17:01:15.767]  $ ...future.seeds_ii       : NULL
[17:01:15.767]  $ ...future.globals.maxSize: NULL
[17:01:15.767]  - attr(*, "where")=List of 5
[17:01:15.767]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:15.767]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:15.767]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:15.767]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:15.767]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:15.767]  - attr(*, "resolved")= logi FALSE
[17:01:15.767]  - attr(*, "total_size")= num 4720
[17:01:15.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:15.767]  - attr(*, "already-done")= logi TRUE
[17:01:15.772] - reassign environment for ‘...future.FUN’
[17:01:15.772] - copied ‘...future.FUN’ to environment
[17:01:15.772] - copied ‘future.call.arguments’ to environment
[17:01:15.772] - copied ‘...future.elements_ii’ to environment
[17:01:15.772] - copied ‘...future.seeds_ii’ to environment
[17:01:15.772] - copied ‘...future.globals.maxSize’ to environment
[17:01:15.772] assign_globals() ... done
[17:01:15.773] plan(): Setting new future strategy stack:
[17:01:15.773] List of future strategies:
[17:01:15.773] 1. sequential:
[17:01:15.773]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:15.773]    - tweaked: FALSE
[17:01:15.773]    - call: NULL
[17:01:15.773] plan(): nbrOfWorkers() = 1
[17:01:16.276] plan(): Setting new future strategy stack:
[17:01:16.276] List of future strategies:
[17:01:16.276] 1. sequential:
[17:01:16.276]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:16.276]    - tweaked: FALSE
[17:01:16.276]    - call: plan(strategy)
[17:01:16.276] plan(): nbrOfWorkers() = 1
[17:01:16.276] SequentialFuture started (and completed)
[17:01:16.277] - Launch lazy future ... done
[17:01:16.277] run() for ‘SequentialFuture’ ... done
[17:01:16.277] Created future:
[17:01:16.277] SequentialFuture:
[17:01:16.277] Label: ‘future_lapply-1’
[17:01:16.277] Expression:
[17:01:16.277] {
[17:01:16.277]     do.call(function(...) {
[17:01:16.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:16.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:16.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:16.277]             on.exit(options(oopts), add = TRUE)
[17:01:16.277]         }
[17:01:16.277]         {
[17:01:16.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:16.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:16.277]                 ...future.FUN(...future.X_jj, ...)
[17:01:16.277]             })
[17:01:16.277]         }
[17:01:16.277]     }, args = future.call.arguments)
[17:01:16.277] }
[17:01:16.277] Lazy evaluation: FALSE
[17:01:16.277] Asynchronous evaluation: FALSE
[17:01:16.277] Local evaluation: TRUE
[17:01:16.277] Environment: R_GlobalEnv
[17:01:16.277] Capture standard output: FALSE
[17:01:16.277] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:16.277] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:16.277] Packages: <none>
[17:01:16.277] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:16.277] Resolved: TRUE
[17:01:16.277] Value: 112 bytes of class ‘list’
[17:01:16.277] Early signaling: FALSE
[17:01:16.277] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:16.277] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:16.279] Chunk #1 of 1 ... DONE
[17:01:16.279] Launching 1 futures (chunks) ... DONE
[17:01:16.279] Resolving 1 futures (chunks) ...
[17:01:16.279] resolve() on list ...
[17:01:16.279]  recursive: 0
[17:01:16.279]  length: 1
[17:01:16.279] 
[17:01:16.280] resolved() for ‘SequentialFuture’ ...
[17:01:16.280] - state: ‘finished’
[17:01:16.280] - run: TRUE
[17:01:16.280] - result: ‘FutureResult’
[17:01:16.280] resolved() for ‘SequentialFuture’ ... done
[17:01:16.280] Future #1
[17:01:16.281] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:16.281] - nx: 1
[17:01:16.281] - relay: TRUE
[17:01:16.281] - stdout: TRUE
[17:01:16.281] - signal: TRUE
[17:01:16.281] - resignal: FALSE
[17:01:16.281] - force: TRUE
[17:01:16.281] - relayed: [n=1] FALSE
[17:01:16.281] - queued futures: [n=1] FALSE
[17:01:16.281]  - until=1
[17:01:16.281]  - relaying element #1
[17:01:16.282] - relayed: [n=1] TRUE
[17:01:16.282] - queued futures: [n=1] TRUE
[17:01:16.282] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:16.282]  length: 0 (resolved future 1)
[17:01:16.282] Relaying remaining futures
[17:01:16.282] signalConditionsASAP(NULL, pos=0) ...
[17:01:16.282] - nx: 1
[17:01:16.282] - relay: TRUE
[17:01:16.282] - stdout: TRUE
[17:01:16.283] - signal: TRUE
[17:01:16.283] - resignal: FALSE
[17:01:16.283] - force: TRUE
[17:01:16.283] - relayed: [n=1] TRUE
[17:01:16.283] - queued futures: [n=1] TRUE
 - flush all
[17:01:16.283] - relayed: [n=1] TRUE
[17:01:16.283] - queued futures: [n=1] TRUE
[17:01:16.283] signalConditionsASAP(NULL, pos=0) ... done
[17:01:16.283] resolve() on list ... DONE
[17:01:16.283]  - Number of value chunks collected: 1
[17:01:16.284] Resolving 1 futures (chunks) ... DONE
[17:01:16.284] Reducing values from 1 chunks ...
[17:01:16.284]  - Number of values collected after concatenation: 2
[17:01:16.284]  - Number of values expected: 2
[17:01:16.284] Reducing values from 1 chunks ... DONE
[17:01:16.284] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:01:16.284] future_lapply() ...
[17:01:16.285] Number of chunks: 1
[17:01:16.285] getGlobalsAndPackagesXApply() ...
[17:01:16.285]  - future.globals: TRUE
[17:01:16.285] getGlobalsAndPackages() ...
[17:01:16.285] Searching for globals...
[17:01:16.287] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:16.287] Searching for globals ... DONE
[17:01:16.287] Resolving globals: FALSE
[17:01:16.287] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:16.288] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:16.288] - globals: [1] ‘FUN’
[17:01:16.288] 
[17:01:16.288] getGlobalsAndPackages() ... DONE
[17:01:16.290]  - globals found/used: [n=1] ‘FUN’
[17:01:16.290]  - needed namespaces: [n=0] 
[17:01:16.290] Finding globals ... DONE
[17:01:16.290]  - use_args: TRUE
[17:01:16.290]  - Getting '...' globals ...
[17:01:16.291] resolve() on list ...
[17:01:16.291]  recursive: 0
[17:01:16.291]  length: 1
[17:01:16.291]  elements: ‘...’
[17:01:16.291]  length: 0 (resolved future 1)
[17:01:16.291] resolve() on list ... DONE
[17:01:16.291]    - '...' content: [n=0] 
[17:01:16.291] List of 1
[17:01:16.291]  $ ...: list()
[17:01:16.291]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:16.291]  - attr(*, "where")=List of 1
[17:01:16.291]   ..$ ...:<environment: 0x5636f7060250> 
[17:01:16.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:16.291]  - attr(*, "resolved")= logi TRUE
[17:01:16.291]  - attr(*, "total_size")= num NA
[17:01:16.294]  - Getting '...' globals ... DONE
[17:01:16.294] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:16.294] List of 2
[17:01:16.294]  $ ...future.FUN:function (x)  
[17:01:16.294]  $ ...          : list()
[17:01:16.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:16.294]  - attr(*, "where")=List of 2
[17:01:16.294]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:16.294]   ..$ ...          :<environment: 0x5636f7060250> 
[17:01:16.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:16.294]  - attr(*, "resolved")= logi FALSE
[17:01:16.294]  - attr(*, "total_size")= num 4720
[17:01:16.297] Packages to be attached in all futures: [n=0] 
[17:01:16.297] getGlobalsAndPackagesXApply() ... DONE
[17:01:16.297] Number of futures (= number of chunks): 1
[17:01:16.297] Launching 1 futures (chunks) ...
[17:01:16.297] Chunk #1 of 1 ...
[17:01:16.297]  - Finding globals in 'X' for chunk #1 ...
[17:01:16.297] getGlobalsAndPackages() ...
[17:01:16.298] Searching for globals...
[17:01:16.298] 
[17:01:16.298] Searching for globals ... DONE
[17:01:16.298] - globals: [0] <none>
[17:01:16.298] getGlobalsAndPackages() ... DONE
[17:01:16.298]    + additional globals found: [n=0] 
[17:01:16.298]    + additional namespaces needed: [n=0] 
[17:01:16.298]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:16.298]  - seeds: <none>
[17:01:16.298]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:16.299] getGlobalsAndPackages() ...
[17:01:16.299] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:16.299] Resolving globals: FALSE
[17:01:16.299] Tweak future expression to call with '...' arguments ...
[17:01:16.299] {
[17:01:16.299]     do.call(function(...) {
[17:01:16.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:16.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:16.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:16.299]             on.exit(options(oopts), add = TRUE)
[17:01:16.299]         }
[17:01:16.299]         {
[17:01:16.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:16.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:16.299]                 ...future.FUN(...future.X_jj, ...)
[17:01:16.299]             })
[17:01:16.299]         }
[17:01:16.299]     }, args = future.call.arguments)
[17:01:16.299] }
[17:01:16.299] Tweak future expression to call with '...' arguments ... DONE
[17:01:16.300] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:16.300] 
[17:01:16.300] getGlobalsAndPackages() ... DONE
[17:01:16.300] run() for ‘Future’ ...
[17:01:16.300] - state: ‘created’
[17:01:16.300] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:16.301] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:16.301] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:16.301]   - Field: ‘label’
[17:01:16.301]   - Field: ‘local’
[17:01:16.301]   - Field: ‘owner’
[17:01:16.301]   - Field: ‘envir’
[17:01:16.301]   - Field: ‘packages’
[17:01:16.301]   - Field: ‘gc’
[17:01:16.301]   - Field: ‘conditions’
[17:01:16.301]   - Field: ‘expr’
[17:01:16.302]   - Field: ‘uuid’
[17:01:16.302]   - Field: ‘seed’
[17:01:16.302]   - Field: ‘version’
[17:01:16.302]   - Field: ‘result’
[17:01:16.302]   - Field: ‘asynchronous’
[17:01:16.302]   - Field: ‘calls’
[17:01:16.302]   - Field: ‘globals’
[17:01:16.302]   - Field: ‘stdout’
[17:01:16.302]   - Field: ‘earlySignal’
[17:01:16.302]   - Field: ‘lazy’
[17:01:16.302]   - Field: ‘state’
[17:01:16.303] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:16.303] - Launch lazy future ...
[17:01:16.303] Packages needed by the future expression (n = 0): <none>
[17:01:16.303] Packages needed by future strategies (n = 0): <none>
[17:01:16.303] {
[17:01:16.303]     {
[17:01:16.303]         {
[17:01:16.303]             ...future.startTime <- base::Sys.time()
[17:01:16.303]             {
[17:01:16.303]                 {
[17:01:16.303]                   {
[17:01:16.303]                     base::local({
[17:01:16.303]                       has_future <- base::requireNamespace("future", 
[17:01:16.303]                         quietly = TRUE)
[17:01:16.303]                       if (has_future) {
[17:01:16.303]                         ns <- base::getNamespace("future")
[17:01:16.303]                         version <- ns[[".package"]][["version"]]
[17:01:16.303]                         if (is.null(version)) 
[17:01:16.303]                           version <- utils::packageVersion("future")
[17:01:16.303]                       }
[17:01:16.303]                       else {
[17:01:16.303]                         version <- NULL
[17:01:16.303]                       }
[17:01:16.303]                       if (!has_future || version < "1.8.0") {
[17:01:16.303]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:16.303]                           "", base::R.version$version.string), 
[17:01:16.303]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:16.303]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:16.303]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:16.303]                             "release", "version")], collapse = " "), 
[17:01:16.303]                           hostname = base::Sys.info()[["nodename"]])
[17:01:16.303]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:16.303]                           info)
[17:01:16.303]                         info <- base::paste(info, collapse = "; ")
[17:01:16.303]                         if (!has_future) {
[17:01:16.303]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:16.303]                             info)
[17:01:16.303]                         }
[17:01:16.303]                         else {
[17:01:16.303]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:16.303]                             info, version)
[17:01:16.303]                         }
[17:01:16.303]                         base::stop(msg)
[17:01:16.303]                       }
[17:01:16.303]                     })
[17:01:16.303]                   }
[17:01:16.303]                   ...future.strategy.old <- future::plan("list")
[17:01:16.303]                   options(future.plan = NULL)
[17:01:16.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:16.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:16.303]                 }
[17:01:16.303]                 ...future.workdir <- getwd()
[17:01:16.303]             }
[17:01:16.303]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:16.303]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:16.303]         }
[17:01:16.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:16.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:16.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:16.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:16.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:16.303]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:16.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:16.303]             base::names(...future.oldOptions))
[17:01:16.303]     }
[17:01:16.303]     if (FALSE) {
[17:01:16.303]     }
[17:01:16.303]     else {
[17:01:16.303]         if (TRUE) {
[17:01:16.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:16.303]                 open = "w")
[17:01:16.303]         }
[17:01:16.303]         else {
[17:01:16.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:16.303]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:16.303]         }
[17:01:16.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:16.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:16.303]             base::sink(type = "output", split = FALSE)
[17:01:16.303]             base::close(...future.stdout)
[17:01:16.303]         }, add = TRUE)
[17:01:16.303]     }
[17:01:16.303]     ...future.frame <- base::sys.nframe()
[17:01:16.303]     ...future.conditions <- base::list()
[17:01:16.303]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:16.303]     if (FALSE) {
[17:01:16.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:16.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:16.303]     }
[17:01:16.303]     ...future.result <- base::tryCatch({
[17:01:16.303]         base::withCallingHandlers({
[17:01:16.303]             ...future.value <- base::withVisible(base::local({
[17:01:16.303]                 do.call(function(...) {
[17:01:16.303]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:16.303]                   if (!identical(...future.globals.maxSize.org, 
[17:01:16.303]                     ...future.globals.maxSize)) {
[17:01:16.303]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:16.303]                     on.exit(options(oopts), add = TRUE)
[17:01:16.303]                   }
[17:01:16.303]                   {
[17:01:16.303]                     lapply(seq_along(...future.elements_ii), 
[17:01:16.303]                       FUN = function(jj) {
[17:01:16.303]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:16.303]                         ...future.FUN(...future.X_jj, ...)
[17:01:16.303]                       })
[17:01:16.303]                   }
[17:01:16.303]                 }, args = future.call.arguments)
[17:01:16.303]             }))
[17:01:16.303]             future::FutureResult(value = ...future.value$value, 
[17:01:16.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:16.303]                   ...future.rng), globalenv = if (FALSE) 
[17:01:16.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:16.303]                     ...future.globalenv.names))
[17:01:16.303]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:16.303]         }, condition = base::local({
[17:01:16.303]             c <- base::c
[17:01:16.303]             inherits <- base::inherits
[17:01:16.303]             invokeRestart <- base::invokeRestart
[17:01:16.303]             length <- base::length
[17:01:16.303]             list <- base::list
[17:01:16.303]             seq.int <- base::seq.int
[17:01:16.303]             signalCondition <- base::signalCondition
[17:01:16.303]             sys.calls <- base::sys.calls
[17:01:16.303]             `[[` <- base::`[[`
[17:01:16.303]             `+` <- base::`+`
[17:01:16.303]             `<<-` <- base::`<<-`
[17:01:16.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:16.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:16.303]                   3L)]
[17:01:16.303]             }
[17:01:16.303]             function(cond) {
[17:01:16.303]                 is_error <- inherits(cond, "error")
[17:01:16.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:16.303]                   NULL)
[17:01:16.303]                 if (is_error) {
[17:01:16.303]                   sessionInformation <- function() {
[17:01:16.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:16.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:16.303]                       search = base::search(), system = base::Sys.info())
[17:01:16.303]                   }
[17:01:16.303]                   ...future.conditions[[length(...future.conditions) + 
[17:01:16.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:16.303]                     cond$call), session = sessionInformation(), 
[17:01:16.303]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:16.303]                   signalCondition(cond)
[17:01:16.303]                 }
[17:01:16.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:16.303]                 "immediateCondition"))) {
[17:01:16.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:16.303]                   ...future.conditions[[length(...future.conditions) + 
[17:01:16.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:16.303]                   if (TRUE && !signal) {
[17:01:16.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:16.303]                     {
[17:01:16.303]                       inherits <- base::inherits
[17:01:16.303]                       invokeRestart <- base::invokeRestart
[17:01:16.303]                       is.null <- base::is.null
[17:01:16.303]                       muffled <- FALSE
[17:01:16.303]                       if (inherits(cond, "message")) {
[17:01:16.303]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:16.303]                         if (muffled) 
[17:01:16.303]                           invokeRestart("muffleMessage")
[17:01:16.303]                       }
[17:01:16.303]                       else if (inherits(cond, "warning")) {
[17:01:16.303]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:16.303]                         if (muffled) 
[17:01:16.303]                           invokeRestart("muffleWarning")
[17:01:16.303]                       }
[17:01:16.303]                       else if (inherits(cond, "condition")) {
[17:01:16.303]                         if (!is.null(pattern)) {
[17:01:16.303]                           computeRestarts <- base::computeRestarts
[17:01:16.303]                           grepl <- base::grepl
[17:01:16.303]                           restarts <- computeRestarts(cond)
[17:01:16.303]                           for (restart in restarts) {
[17:01:16.303]                             name <- restart$name
[17:01:16.303]                             if (is.null(name)) 
[17:01:16.303]                               next
[17:01:16.303]                             if (!grepl(pattern, name)) 
[17:01:16.303]                               next
[17:01:16.303]                             invokeRestart(restart)
[17:01:16.303]                             muffled <- TRUE
[17:01:16.303]                             break
[17:01:16.303]                           }
[17:01:16.303]                         }
[17:01:16.303]                       }
[17:01:16.303]                       invisible(muffled)
[17:01:16.303]                     }
[17:01:16.303]                     muffleCondition(cond, pattern = "^muffle")
[17:01:16.303]                   }
[17:01:16.303]                 }
[17:01:16.303]                 else {
[17:01:16.303]                   if (TRUE) {
[17:01:16.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:16.303]                     {
[17:01:16.303]                       inherits <- base::inherits
[17:01:16.303]                       invokeRestart <- base::invokeRestart
[17:01:16.303]                       is.null <- base::is.null
[17:01:16.303]                       muffled <- FALSE
[17:01:16.303]                       if (inherits(cond, "message")) {
[17:01:16.303]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:16.303]                         if (muffled) 
[17:01:16.303]                           invokeRestart("muffleMessage")
[17:01:16.303]                       }
[17:01:16.303]                       else if (inherits(cond, "warning")) {
[17:01:16.303]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:16.303]                         if (muffled) 
[17:01:16.303]                           invokeRestart("muffleWarning")
[17:01:16.303]                       }
[17:01:16.303]                       else if (inherits(cond, "condition")) {
[17:01:16.303]                         if (!is.null(pattern)) {
[17:01:16.303]                           computeRestarts <- base::computeRestarts
[17:01:16.303]                           grepl <- base::grepl
[17:01:16.303]                           restarts <- computeRestarts(cond)
[17:01:16.303]                           for (restart in restarts) {
[17:01:16.303]                             name <- restart$name
[17:01:16.303]                             if (is.null(name)) 
[17:01:16.303]                               next
[17:01:16.303]                             if (!grepl(pattern, name)) 
[17:01:16.303]                               next
[17:01:16.303]                             invokeRestart(restart)
[17:01:16.303]                             muffled <- TRUE
[17:01:16.303]                             break
[17:01:16.303]                           }
[17:01:16.303]                         }
[17:01:16.303]                       }
[17:01:16.303]                       invisible(muffled)
[17:01:16.303]                     }
[17:01:16.303]                     muffleCondition(cond, pattern = "^muffle")
[17:01:16.303]                   }
[17:01:16.303]                 }
[17:01:16.303]             }
[17:01:16.303]         }))
[17:01:16.303]     }, error = function(ex) {
[17:01:16.303]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:16.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:16.303]                 ...future.rng), started = ...future.startTime, 
[17:01:16.303]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:16.303]             version = "1.8"), class = "FutureResult")
[17:01:16.303]     }, finally = {
[17:01:16.303]         if (!identical(...future.workdir, getwd())) 
[17:01:16.303]             setwd(...future.workdir)
[17:01:16.303]         {
[17:01:16.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:16.303]                 ...future.oldOptions$nwarnings <- NULL
[17:01:16.303]             }
[17:01:16.303]             base::options(...future.oldOptions)
[17:01:16.303]             if (.Platform$OS.type == "windows") {
[17:01:16.303]                 old_names <- names(...future.oldEnvVars)
[17:01:16.303]                 envs <- base::Sys.getenv()
[17:01:16.303]                 names <- names(envs)
[17:01:16.303]                 common <- intersect(names, old_names)
[17:01:16.303]                 added <- setdiff(names, old_names)
[17:01:16.303]                 removed <- setdiff(old_names, names)
[17:01:16.303]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:16.303]                   envs[common]]
[17:01:16.303]                 NAMES <- toupper(changed)
[17:01:16.303]                 args <- list()
[17:01:16.303]                 for (kk in seq_along(NAMES)) {
[17:01:16.303]                   name <- changed[[kk]]
[17:01:16.303]                   NAME <- NAMES[[kk]]
[17:01:16.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:16.303]                     next
[17:01:16.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:16.303]                 }
[17:01:16.303]                 NAMES <- toupper(added)
[17:01:16.303]                 for (kk in seq_along(NAMES)) {
[17:01:16.303]                   name <- added[[kk]]
[17:01:16.303]                   NAME <- NAMES[[kk]]
[17:01:16.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:16.303]                     next
[17:01:16.303]                   args[[name]] <- ""
[17:01:16.303]                 }
[17:01:16.303]                 NAMES <- toupper(removed)
[17:01:16.303]                 for (kk in seq_along(NAMES)) {
[17:01:16.303]                   name <- removed[[kk]]
[17:01:16.303]                   NAME <- NAMES[[kk]]
[17:01:16.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:16.303]                     next
[17:01:16.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:16.303]                 }
[17:01:16.303]                 if (length(args) > 0) 
[17:01:16.303]                   base::do.call(base::Sys.setenv, args = args)
[17:01:16.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:16.303]             }
[17:01:16.303]             else {
[17:01:16.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:16.303]             }
[17:01:16.303]             {
[17:01:16.303]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:16.303]                   0L) {
[17:01:16.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:16.303]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:16.303]                   base::options(opts)
[17:01:16.303]                 }
[17:01:16.303]                 {
[17:01:16.303]                   {
[17:01:16.303]                     NULL
[17:01:16.303]                     RNGkind("Mersenne-Twister")
[17:01:16.303]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:16.303]                       inherits = FALSE)
[17:01:16.303]                   }
[17:01:16.303]                   options(future.plan = NULL)
[17:01:16.303]                   if (is.na(NA_character_)) 
[17:01:16.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:16.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:16.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:16.303]                     .init = FALSE)
[17:01:16.303]                 }
[17:01:16.303]             }
[17:01:16.303]         }
[17:01:16.303]     })
[17:01:16.303]     if (TRUE) {
[17:01:16.303]         base::sink(type = "output", split = FALSE)
[17:01:16.303]         if (TRUE) {
[17:01:16.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:16.303]         }
[17:01:16.303]         else {
[17:01:16.303]             ...future.result["stdout"] <- base::list(NULL)
[17:01:16.303]         }
[17:01:16.303]         base::close(...future.stdout)
[17:01:16.303]         ...future.stdout <- NULL
[17:01:16.303]     }
[17:01:16.303]     ...future.result$conditions <- ...future.conditions
[17:01:16.303]     ...future.result$finished <- base::Sys.time()
[17:01:16.303]     ...future.result
[17:01:16.303] }
[17:01:16.305] assign_globals() ...
[17:01:16.305] List of 5
[17:01:16.305]  $ ...future.FUN            :function (x)  
[17:01:16.305]  $ future.call.arguments    : list()
[17:01:16.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:16.305]  $ ...future.elements_ii    :List of 2
[17:01:16.305]   ..$ : int 1
[17:01:16.305]   ..$ : int 0
[17:01:16.305]  $ ...future.seeds_ii       : NULL
[17:01:16.305]  $ ...future.globals.maxSize: NULL
[17:01:16.305]  - attr(*, "where")=List of 5
[17:01:16.305]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:16.305]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:16.305]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:16.305]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:16.305]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:16.305]  - attr(*, "resolved")= logi FALSE
[17:01:16.305]  - attr(*, "total_size")= num 4720
[17:01:16.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:16.305]  - attr(*, "already-done")= logi TRUE
[17:01:16.310] - reassign environment for ‘...future.FUN’
[17:01:16.310] - copied ‘...future.FUN’ to environment
[17:01:16.310] - copied ‘future.call.arguments’ to environment
[17:01:16.310] - copied ‘...future.elements_ii’ to environment
[17:01:16.310] - copied ‘...future.seeds_ii’ to environment
[17:01:16.310] - copied ‘...future.globals.maxSize’ to environment
[17:01:16.310] assign_globals() ... done
[17:01:16.311] plan(): Setting new future strategy stack:
[17:01:16.311] List of future strategies:
[17:01:16.311] 1. sequential:
[17:01:16.311]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:16.311]    - tweaked: FALSE
[17:01:16.311]    - call: NULL
[17:01:16.311] plan(): nbrOfWorkers() = 1
[17:01:16.813] plan(): Setting new future strategy stack:
[17:01:16.813] List of future strategies:
[17:01:16.813] 1. sequential:
[17:01:16.813]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:16.813]    - tweaked: FALSE
[17:01:16.813]    - call: plan(strategy)
[17:01:16.814] plan(): nbrOfWorkers() = 1
[17:01:16.814] SequentialFuture started (and completed)
[17:01:16.814] - Launch lazy future ... done
[17:01:16.814] run() for ‘SequentialFuture’ ... done
[17:01:16.814] Created future:
[17:01:16.815] SequentialFuture:
[17:01:16.815] Label: ‘future_lapply-1’
[17:01:16.815] Expression:
[17:01:16.815] {
[17:01:16.815]     do.call(function(...) {
[17:01:16.815]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:16.815]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:16.815]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:16.815]             on.exit(options(oopts), add = TRUE)
[17:01:16.815]         }
[17:01:16.815]         {
[17:01:16.815]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:16.815]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:16.815]                 ...future.FUN(...future.X_jj, ...)
[17:01:16.815]             })
[17:01:16.815]         }
[17:01:16.815]     }, args = future.call.arguments)
[17:01:16.815] }
[17:01:16.815] Lazy evaluation: FALSE
[17:01:16.815] Asynchronous evaluation: FALSE
[17:01:16.815] Local evaluation: TRUE
[17:01:16.815] Environment: R_GlobalEnv
[17:01:16.815] Capture standard output: TRUE
[17:01:16.815] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:16.815] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:16.815] Packages: <none>
[17:01:16.815] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:16.815] Resolved: TRUE
[17:01:16.815] Value: 112 bytes of class ‘list’
[17:01:16.815] Early signaling: FALSE
[17:01:16.815] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:16.815] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:16.816] Chunk #1 of 1 ... DONE
[17:01:16.816] Launching 1 futures (chunks) ... DONE
[17:01:16.816] Resolving 1 futures (chunks) ...
[17:01:16.816] resolve() on list ...
[17:01:16.816]  recursive: 0
[17:01:16.816]  length: 1
[17:01:16.816] 
[17:01:16.816] resolved() for ‘SequentialFuture’ ...
[17:01:16.816] - state: ‘finished’
[17:01:16.816] - run: TRUE
[17:01:16.817] - result: ‘FutureResult’
[17:01:16.817] resolved() for ‘SequentialFuture’ ... done
[17:01:16.817] Future #1
[17:01:16.817] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:16.817] - nx: 1
[17:01:16.817] - relay: TRUE
[17:01:16.817] - stdout: TRUE
[17:01:16.817] - signal: TRUE
[17:01:16.817] - resignal: FALSE
[17:01:16.819] - force: TRUE
[17:01:16.819] - relayed: [n=1] FALSE
[17:01:16.819] - queued futures: [n=1] FALSE
[17:01:16.819]  - until=1
[17:01:16.819]  - relaying element #1
[17:01:16.820] - relayed: [n=1] TRUE
[17:01:16.820] - queued futures: [n=1] TRUE
[17:01:16.820] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:16.820]  length: 0 (resolved future 1)
[17:01:16.820] Relaying remaining futures
[17:01:16.820] signalConditionsASAP(NULL, pos=0) ...
[17:01:16.820] - nx: 1
[17:01:16.820] - relay: TRUE
[17:01:16.820] - stdout: TRUE
[17:01:16.820] - signal: TRUE
[17:01:16.820] - resignal: FALSE
[17:01:16.820] - force: TRUE
[17:01:16.821] - relayed: [n=1] TRUE
[17:01:16.821] - queued futures: [n=1] TRUE
 - flush all
[17:01:16.821] - relayed: [n=1] TRUE
[17:01:16.821] - queued futures: [n=1] TRUE
[17:01:16.821] signalConditionsASAP(NULL, pos=0) ... done
[17:01:16.821] resolve() on list ... DONE
[17:01:16.821]  - Number of value chunks collected: 1
[17:01:16.821] Resolving 1 futures (chunks) ... DONE
[17:01:16.821] Reducing values from 1 chunks ...
[17:01:16.821]  - Number of values collected after concatenation: 2
[17:01:16.822]  - Number of values expected: 2
[17:01:16.822] Reducing values from 1 chunks ... DONE
[17:01:16.822] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:01:16.822] future_lapply() ...
[17:01:16.823] Number of chunks: 1
[17:01:16.823] getGlobalsAndPackagesXApply() ...
[17:01:16.823]  - future.globals: TRUE
[17:01:16.823] getGlobalsAndPackages() ...
[17:01:16.823] Searching for globals...
[17:01:16.824] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:16.825] Searching for globals ... DONE
[17:01:16.825] Resolving globals: FALSE
[17:01:16.825] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:16.825] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:16.826] - globals: [1] ‘FUN’
[17:01:16.826] 
[17:01:16.826] getGlobalsAndPackages() ... DONE
[17:01:16.826]  - globals found/used: [n=1] ‘FUN’
[17:01:16.826]  - needed namespaces: [n=0] 
[17:01:16.826] Finding globals ... DONE
[17:01:16.826]  - use_args: TRUE
[17:01:16.826]  - Getting '...' globals ...
[17:01:16.827] resolve() on list ...
[17:01:16.827]  recursive: 0
[17:01:16.827]  length: 1
[17:01:16.827]  elements: ‘...’
[17:01:16.827]  length: 0 (resolved future 1)
[17:01:16.827] resolve() on list ... DONE
[17:01:16.827]    - '...' content: [n=0] 
[17:01:16.827] List of 1
[17:01:16.827]  $ ...: list()
[17:01:16.827]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:16.827]  - attr(*, "where")=List of 1
[17:01:16.827]   ..$ ...:<environment: 0x5636f52b5458> 
[17:01:16.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:16.827]  - attr(*, "resolved")= logi TRUE
[17:01:16.827]  - attr(*, "total_size")= num NA
[17:01:16.830]  - Getting '...' globals ... DONE
[17:01:16.830] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:16.830] List of 2
[17:01:16.830]  $ ...future.FUN:function (x)  
[17:01:16.830]  $ ...          : list()
[17:01:16.830]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:16.830]  - attr(*, "where")=List of 2
[17:01:16.830]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:16.830]   ..$ ...          :<environment: 0x5636f52b5458> 
[17:01:16.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:16.830]  - attr(*, "resolved")= logi FALSE
[17:01:16.830]  - attr(*, "total_size")= num 4720
[17:01:16.833] Packages to be attached in all futures: [n=0] 
[17:01:16.833] getGlobalsAndPackagesXApply() ... DONE
[17:01:16.833] Number of futures (= number of chunks): 1
[17:01:16.833] Launching 1 futures (chunks) ...
[17:01:16.833] Chunk #1 of 1 ...
[17:01:16.833]  - Finding globals in 'X' for chunk #1 ...
[17:01:16.833] getGlobalsAndPackages() ...
[17:01:16.833] Searching for globals...
[17:01:16.834] 
[17:01:16.834] Searching for globals ... DONE
[17:01:16.834] - globals: [0] <none>
[17:01:16.834] getGlobalsAndPackages() ... DONE
[17:01:16.834]    + additional globals found: [n=0] 
[17:01:16.834]    + additional namespaces needed: [n=0] 
[17:01:16.834]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:16.834]  - seeds: <none>
[17:01:16.834]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:16.834] getGlobalsAndPackages() ...
[17:01:16.835] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:16.835] Resolving globals: FALSE
[17:01:16.835] Tweak future expression to call with '...' arguments ...
[17:01:16.835] {
[17:01:16.835]     do.call(function(...) {
[17:01:16.835]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:16.835]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:16.835]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:16.835]             on.exit(options(oopts), add = TRUE)
[17:01:16.835]         }
[17:01:16.835]         {
[17:01:16.835]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:16.835]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:16.835]                 ...future.FUN(...future.X_jj, ...)
[17:01:16.835]             })
[17:01:16.835]         }
[17:01:16.835]     }, args = future.call.arguments)
[17:01:16.835] }
[17:01:16.835] Tweak future expression to call with '...' arguments ... DONE
[17:01:16.835] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:16.836] 
[17:01:16.836] getGlobalsAndPackages() ... DONE
[17:01:16.836] run() for ‘Future’ ...
[17:01:16.836] - state: ‘created’
[17:01:16.836] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:16.836] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:16.837] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:16.837]   - Field: ‘label’
[17:01:16.837]   - Field: ‘local’
[17:01:16.837]   - Field: ‘owner’
[17:01:16.837]   - Field: ‘envir’
[17:01:16.837]   - Field: ‘packages’
[17:01:16.837]   - Field: ‘gc’
[17:01:16.837]   - Field: ‘conditions’
[17:01:16.837]   - Field: ‘expr’
[17:01:16.837]   - Field: ‘uuid’
[17:01:16.837]   - Field: ‘seed’
[17:01:16.838]   - Field: ‘version’
[17:01:16.838]   - Field: ‘result’
[17:01:16.838]   - Field: ‘asynchronous’
[17:01:16.838]   - Field: ‘calls’
[17:01:16.838]   - Field: ‘globals’
[17:01:16.838]   - Field: ‘stdout’
[17:01:16.838]   - Field: ‘earlySignal’
[17:01:16.838]   - Field: ‘lazy’
[17:01:16.838]   - Field: ‘state’
[17:01:16.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:16.838] - Launch lazy future ...
[17:01:16.839] Packages needed by the future expression (n = 0): <none>
[17:01:16.839] Packages needed by future strategies (n = 0): <none>
[17:01:16.839] {
[17:01:16.839]     {
[17:01:16.839]         {
[17:01:16.839]             ...future.startTime <- base::Sys.time()
[17:01:16.839]             {
[17:01:16.839]                 {
[17:01:16.839]                   {
[17:01:16.839]                     base::local({
[17:01:16.839]                       has_future <- base::requireNamespace("future", 
[17:01:16.839]                         quietly = TRUE)
[17:01:16.839]                       if (has_future) {
[17:01:16.839]                         ns <- base::getNamespace("future")
[17:01:16.839]                         version <- ns[[".package"]][["version"]]
[17:01:16.839]                         if (is.null(version)) 
[17:01:16.839]                           version <- utils::packageVersion("future")
[17:01:16.839]                       }
[17:01:16.839]                       else {
[17:01:16.839]                         version <- NULL
[17:01:16.839]                       }
[17:01:16.839]                       if (!has_future || version < "1.8.0") {
[17:01:16.839]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:16.839]                           "", base::R.version$version.string), 
[17:01:16.839]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:16.839]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:16.839]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:16.839]                             "release", "version")], collapse = " "), 
[17:01:16.839]                           hostname = base::Sys.info()[["nodename"]])
[17:01:16.839]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:16.839]                           info)
[17:01:16.839]                         info <- base::paste(info, collapse = "; ")
[17:01:16.839]                         if (!has_future) {
[17:01:16.839]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:16.839]                             info)
[17:01:16.839]                         }
[17:01:16.839]                         else {
[17:01:16.839]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:16.839]                             info, version)
[17:01:16.839]                         }
[17:01:16.839]                         base::stop(msg)
[17:01:16.839]                       }
[17:01:16.839]                     })
[17:01:16.839]                   }
[17:01:16.839]                   ...future.strategy.old <- future::plan("list")
[17:01:16.839]                   options(future.plan = NULL)
[17:01:16.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:16.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:16.839]                 }
[17:01:16.839]                 ...future.workdir <- getwd()
[17:01:16.839]             }
[17:01:16.839]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:16.839]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:16.839]         }
[17:01:16.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:16.839]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:16.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:16.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:16.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:16.839]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:16.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:16.839]             base::names(...future.oldOptions))
[17:01:16.839]     }
[17:01:16.839]     if (TRUE) {
[17:01:16.839]     }
[17:01:16.839]     else {
[17:01:16.839]         if (NA) {
[17:01:16.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:16.839]                 open = "w")
[17:01:16.839]         }
[17:01:16.839]         else {
[17:01:16.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:16.839]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:16.839]         }
[17:01:16.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:16.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:16.839]             base::sink(type = "output", split = FALSE)
[17:01:16.839]             base::close(...future.stdout)
[17:01:16.839]         }, add = TRUE)
[17:01:16.839]     }
[17:01:16.839]     ...future.frame <- base::sys.nframe()
[17:01:16.839]     ...future.conditions <- base::list()
[17:01:16.839]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:16.839]     if (FALSE) {
[17:01:16.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:16.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:16.839]     }
[17:01:16.839]     ...future.result <- base::tryCatch({
[17:01:16.839]         base::withCallingHandlers({
[17:01:16.839]             ...future.value <- base::withVisible(base::local({
[17:01:16.839]                 do.call(function(...) {
[17:01:16.839]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:16.839]                   if (!identical(...future.globals.maxSize.org, 
[17:01:16.839]                     ...future.globals.maxSize)) {
[17:01:16.839]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:16.839]                     on.exit(options(oopts), add = TRUE)
[17:01:16.839]                   }
[17:01:16.839]                   {
[17:01:16.839]                     lapply(seq_along(...future.elements_ii), 
[17:01:16.839]                       FUN = function(jj) {
[17:01:16.839]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:16.839]                         ...future.FUN(...future.X_jj, ...)
[17:01:16.839]                       })
[17:01:16.839]                   }
[17:01:16.839]                 }, args = future.call.arguments)
[17:01:16.839]             }))
[17:01:16.839]             future::FutureResult(value = ...future.value$value, 
[17:01:16.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:16.839]                   ...future.rng), globalenv = if (FALSE) 
[17:01:16.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:16.839]                     ...future.globalenv.names))
[17:01:16.839]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:16.839]         }, condition = base::local({
[17:01:16.839]             c <- base::c
[17:01:16.839]             inherits <- base::inherits
[17:01:16.839]             invokeRestart <- base::invokeRestart
[17:01:16.839]             length <- base::length
[17:01:16.839]             list <- base::list
[17:01:16.839]             seq.int <- base::seq.int
[17:01:16.839]             signalCondition <- base::signalCondition
[17:01:16.839]             sys.calls <- base::sys.calls
[17:01:16.839]             `[[` <- base::`[[`
[17:01:16.839]             `+` <- base::`+`
[17:01:16.839]             `<<-` <- base::`<<-`
[17:01:16.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:16.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:16.839]                   3L)]
[17:01:16.839]             }
[17:01:16.839]             function(cond) {
[17:01:16.839]                 is_error <- inherits(cond, "error")
[17:01:16.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:16.839]                   NULL)
[17:01:16.839]                 if (is_error) {
[17:01:16.839]                   sessionInformation <- function() {
[17:01:16.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:16.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:16.839]                       search = base::search(), system = base::Sys.info())
[17:01:16.839]                   }
[17:01:16.839]                   ...future.conditions[[length(...future.conditions) + 
[17:01:16.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:16.839]                     cond$call), session = sessionInformation(), 
[17:01:16.839]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:16.839]                   signalCondition(cond)
[17:01:16.839]                 }
[17:01:16.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:16.839]                 "immediateCondition"))) {
[17:01:16.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:16.839]                   ...future.conditions[[length(...future.conditions) + 
[17:01:16.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:16.839]                   if (TRUE && !signal) {
[17:01:16.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:16.839]                     {
[17:01:16.839]                       inherits <- base::inherits
[17:01:16.839]                       invokeRestart <- base::invokeRestart
[17:01:16.839]                       is.null <- base::is.null
[17:01:16.839]                       muffled <- FALSE
[17:01:16.839]                       if (inherits(cond, "message")) {
[17:01:16.839]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:16.839]                         if (muffled) 
[17:01:16.839]                           invokeRestart("muffleMessage")
[17:01:16.839]                       }
[17:01:16.839]                       else if (inherits(cond, "warning")) {
[17:01:16.839]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:16.839]                         if (muffled) 
[17:01:16.839]                           invokeRestart("muffleWarning")
[17:01:16.839]                       }
[17:01:16.839]                       else if (inherits(cond, "condition")) {
[17:01:16.839]                         if (!is.null(pattern)) {
[17:01:16.839]                           computeRestarts <- base::computeRestarts
[17:01:16.839]                           grepl <- base::grepl
[17:01:16.839]                           restarts <- computeRestarts(cond)
[17:01:16.839]                           for (restart in restarts) {
[17:01:16.839]                             name <- restart$name
[17:01:16.839]                             if (is.null(name)) 
[17:01:16.839]                               next
[17:01:16.839]                             if (!grepl(pattern, name)) 
[17:01:16.839]                               next
[17:01:16.839]                             invokeRestart(restart)
[17:01:16.839]                             muffled <- TRUE
[17:01:16.839]                             break
[17:01:16.839]                           }
[17:01:16.839]                         }
[17:01:16.839]                       }
[17:01:16.839]                       invisible(muffled)
[17:01:16.839]                     }
[17:01:16.839]                     muffleCondition(cond, pattern = "^muffle")
[17:01:16.839]                   }
[17:01:16.839]                 }
[17:01:16.839]                 else {
[17:01:16.839]                   if (TRUE) {
[17:01:16.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:16.839]                     {
[17:01:16.839]                       inherits <- base::inherits
[17:01:16.839]                       invokeRestart <- base::invokeRestart
[17:01:16.839]                       is.null <- base::is.null
[17:01:16.839]                       muffled <- FALSE
[17:01:16.839]                       if (inherits(cond, "message")) {
[17:01:16.839]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:16.839]                         if (muffled) 
[17:01:16.839]                           invokeRestart("muffleMessage")
[17:01:16.839]                       }
[17:01:16.839]                       else if (inherits(cond, "warning")) {
[17:01:16.839]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:16.839]                         if (muffled) 
[17:01:16.839]                           invokeRestart("muffleWarning")
[17:01:16.839]                       }
[17:01:16.839]                       else if (inherits(cond, "condition")) {
[17:01:16.839]                         if (!is.null(pattern)) {
[17:01:16.839]                           computeRestarts <- base::computeRestarts
[17:01:16.839]                           grepl <- base::grepl
[17:01:16.839]                           restarts <- computeRestarts(cond)
[17:01:16.839]                           for (restart in restarts) {
[17:01:16.839]                             name <- restart$name
[17:01:16.839]                             if (is.null(name)) 
[17:01:16.839]                               next
[17:01:16.839]                             if (!grepl(pattern, name)) 
[17:01:16.839]                               next
[17:01:16.839]                             invokeRestart(restart)
[17:01:16.839]                             muffled <- TRUE
[17:01:16.839]                             break
[17:01:16.839]                           }
[17:01:16.839]                         }
[17:01:16.839]                       }
[17:01:16.839]                       invisible(muffled)
[17:01:16.839]                     }
[17:01:16.839]                     muffleCondition(cond, pattern = "^muffle")
[17:01:16.839]                   }
[17:01:16.839]                 }
[17:01:16.839]             }
[17:01:16.839]         }))
[17:01:16.839]     }, error = function(ex) {
[17:01:16.839]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:16.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:16.839]                 ...future.rng), started = ...future.startTime, 
[17:01:16.839]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:16.839]             version = "1.8"), class = "FutureResult")
[17:01:16.839]     }, finally = {
[17:01:16.839]         if (!identical(...future.workdir, getwd())) 
[17:01:16.839]             setwd(...future.workdir)
[17:01:16.839]         {
[17:01:16.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:16.839]                 ...future.oldOptions$nwarnings <- NULL
[17:01:16.839]             }
[17:01:16.839]             base::options(...future.oldOptions)
[17:01:16.839]             if (.Platform$OS.type == "windows") {
[17:01:16.839]                 old_names <- names(...future.oldEnvVars)
[17:01:16.839]                 envs <- base::Sys.getenv()
[17:01:16.839]                 names <- names(envs)
[17:01:16.839]                 common <- intersect(names, old_names)
[17:01:16.839]                 added <- setdiff(names, old_names)
[17:01:16.839]                 removed <- setdiff(old_names, names)
[17:01:16.839]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:16.839]                   envs[common]]
[17:01:16.839]                 NAMES <- toupper(changed)
[17:01:16.839]                 args <- list()
[17:01:16.839]                 for (kk in seq_along(NAMES)) {
[17:01:16.839]                   name <- changed[[kk]]
[17:01:16.839]                   NAME <- NAMES[[kk]]
[17:01:16.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:16.839]                     next
[17:01:16.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:16.839]                 }
[17:01:16.839]                 NAMES <- toupper(added)
[17:01:16.839]                 for (kk in seq_along(NAMES)) {
[17:01:16.839]                   name <- added[[kk]]
[17:01:16.839]                   NAME <- NAMES[[kk]]
[17:01:16.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:16.839]                     next
[17:01:16.839]                   args[[name]] <- ""
[17:01:16.839]                 }
[17:01:16.839]                 NAMES <- toupper(removed)
[17:01:16.839]                 for (kk in seq_along(NAMES)) {
[17:01:16.839]                   name <- removed[[kk]]
[17:01:16.839]                   NAME <- NAMES[[kk]]
[17:01:16.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:16.839]                     next
[17:01:16.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:16.839]                 }
[17:01:16.839]                 if (length(args) > 0) 
[17:01:16.839]                   base::do.call(base::Sys.setenv, args = args)
[17:01:16.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:16.839]             }
[17:01:16.839]             else {
[17:01:16.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:16.839]             }
[17:01:16.839]             {
[17:01:16.839]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:16.839]                   0L) {
[17:01:16.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:16.839]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:16.839]                   base::options(opts)
[17:01:16.839]                 }
[17:01:16.839]                 {
[17:01:16.839]                   {
[17:01:16.839]                     NULL
[17:01:16.839]                     RNGkind("Mersenne-Twister")
[17:01:16.839]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:16.839]                       inherits = FALSE)
[17:01:16.839]                   }
[17:01:16.839]                   options(future.plan = NULL)
[17:01:16.839]                   if (is.na(NA_character_)) 
[17:01:16.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:16.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:16.839]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:16.839]                     .init = FALSE)
[17:01:16.839]                 }
[17:01:16.839]             }
[17:01:16.839]         }
[17:01:16.839]     })
[17:01:16.839]     if (FALSE) {
[17:01:16.839]         base::sink(type = "output", split = FALSE)
[17:01:16.839]         if (NA) {
[17:01:16.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:16.839]         }
[17:01:16.839]         else {
[17:01:16.839]             ...future.result["stdout"] <- base::list(NULL)
[17:01:16.839]         }
[17:01:16.839]         base::close(...future.stdout)
[17:01:16.839]         ...future.stdout <- NULL
[17:01:16.839]     }
[17:01:16.839]     ...future.result$conditions <- ...future.conditions
[17:01:16.839]     ...future.result$finished <- base::Sys.time()
[17:01:16.839]     ...future.result
[17:01:16.839] }
[17:01:16.841] assign_globals() ...
[17:01:16.841] List of 5
[17:01:16.841]  $ ...future.FUN            :function (x)  
[17:01:16.841]  $ future.call.arguments    : list()
[17:01:16.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:16.841]  $ ...future.elements_ii    :List of 2
[17:01:16.841]   ..$ : int 1
[17:01:16.841]   ..$ : int 0
[17:01:16.841]  $ ...future.seeds_ii       : NULL
[17:01:16.841]  $ ...future.globals.maxSize: NULL
[17:01:16.841]  - attr(*, "where")=List of 5
[17:01:16.841]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:16.841]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:16.841]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:16.841]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:16.841]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:16.841]  - attr(*, "resolved")= logi FALSE
[17:01:16.841]  - attr(*, "total_size")= num 4720
[17:01:16.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:16.841]  - attr(*, "already-done")= logi TRUE
[17:01:16.847] - reassign environment for ‘...future.FUN’
[17:01:16.847] - copied ‘...future.FUN’ to environment
[17:01:16.848] - copied ‘future.call.arguments’ to environment
[17:01:16.848] - copied ‘...future.elements_ii’ to environment
[17:01:16.848] - copied ‘...future.seeds_ii’ to environment
[17:01:16.848] - copied ‘...future.globals.maxSize’ to environment
[17:01:16.848] assign_globals() ... done
[17:01:16.848] plan(): Setting new future strategy stack:
[17:01:16.848] List of future strategies:
[17:01:16.848] 1. sequential:
[17:01:16.848]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:16.848]    - tweaked: FALSE
[17:01:16.848]    - call: NULL
[17:01:16.849] plan(): nbrOfWorkers() = 1
[17:01:17.350] plan(): Setting new future strategy stack:
[17:01:17.351] List of future strategies:
[17:01:17.351] 1. sequential:
[17:01:17.351]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:17.351]    - tweaked: FALSE
[17:01:17.351]    - call: plan(strategy)
[17:01:17.351] plan(): nbrOfWorkers() = 1
[17:01:17.351] SequentialFuture started (and completed)
[17:01:17.352] - Launch lazy future ... done
[17:01:17.352] run() for ‘SequentialFuture’ ... done
[17:01:17.352] Created future:
[17:01:17.352] SequentialFuture:
[17:01:17.352] Label: ‘future_lapply-1’
[17:01:17.352] Expression:
[17:01:17.352] {
[17:01:17.352]     do.call(function(...) {
[17:01:17.352]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:17.352]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:17.352]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:17.352]             on.exit(options(oopts), add = TRUE)
[17:01:17.352]         }
[17:01:17.352]         {
[17:01:17.352]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:17.352]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:17.352]                 ...future.FUN(...future.X_jj, ...)
[17:01:17.352]             })
[17:01:17.352]         }
[17:01:17.352]     }, args = future.call.arguments)
[17:01:17.352] }
[17:01:17.352] Lazy evaluation: FALSE
[17:01:17.352] Asynchronous evaluation: FALSE
[17:01:17.352] Local evaluation: TRUE
[17:01:17.352] Environment: R_GlobalEnv
[17:01:17.352] Capture standard output: NA
[17:01:17.352] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:17.352] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:17.352] Packages: <none>
[17:01:17.352] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:17.352] Resolved: TRUE
[17:01:17.352] Value: 112 bytes of class ‘list’
[17:01:17.352] Early signaling: FALSE
[17:01:17.352] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:17.352] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:17.353] Chunk #1 of 1 ... DONE
[17:01:17.353] Launching 1 futures (chunks) ... DONE
[17:01:17.353] Resolving 1 futures (chunks) ...
[17:01:17.353] resolve() on list ...
[17:01:17.353]  recursive: 0
[17:01:17.353]  length: 1
[17:01:17.354] 
[17:01:17.354] resolved() for ‘SequentialFuture’ ...
[17:01:17.354] - state: ‘finished’
[17:01:17.354] - run: TRUE
[17:01:17.354] - result: ‘FutureResult’
[17:01:17.354] resolved() for ‘SequentialFuture’ ... done
[17:01:17.354] Future #1
[17:01:17.354] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:17.354] - nx: 1
[17:01:17.354] - relay: TRUE
[17:01:17.355] - stdout: TRUE
[17:01:17.355] - signal: TRUE
[17:01:17.355] - resignal: FALSE
[17:01:17.355] - force: TRUE
[17:01:17.355] - relayed: [n=1] FALSE
[17:01:17.355] - queued futures: [n=1] FALSE
[17:01:17.355]  - until=1
[17:01:17.355]  - relaying element #1
[17:01:17.355] - relayed: [n=1] TRUE
[17:01:17.355] - queued futures: [n=1] TRUE
[17:01:17.355] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:17.356]  length: 0 (resolved future 1)
[17:01:17.356] Relaying remaining futures
[17:01:17.356] signalConditionsASAP(NULL, pos=0) ...
[17:01:17.356] - nx: 1
[17:01:17.356] - relay: TRUE
[17:01:17.356] - stdout: TRUE
[17:01:17.356] - signal: TRUE
[17:01:17.356] - resignal: FALSE
[17:01:17.356] - force: TRUE
[17:01:17.356] - relayed: [n=1] TRUE
[17:01:17.356] - queued futures: [n=1] TRUE
 - flush all
[17:01:17.357] - relayed: [n=1] TRUE
[17:01:17.357] - queued futures: [n=1] TRUE
[17:01:17.357] signalConditionsASAP(NULL, pos=0) ... done
[17:01:17.357] resolve() on list ... DONE
[17:01:17.357]  - Number of value chunks collected: 1
[17:01:17.357] Resolving 1 futures (chunks) ... DONE
[17:01:17.357] Reducing values from 1 chunks ...
[17:01:17.357]  - Number of values collected after concatenation: 2
[17:01:17.357]  - Number of values expected: 2
[17:01:17.357] Reducing values from 1 chunks ... DONE
[17:01:17.358] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:01:17.358] future_mapply() ...
[17:01:17.358] Number of chunks: 1
[17:01:17.358] getGlobalsAndPackagesXApply() ...
[17:01:17.358]  - future.globals: TRUE
[17:01:17.358] getGlobalsAndPackages() ...
[17:01:17.358] Searching for globals...
[17:01:17.360] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:17.360] Searching for globals ... DONE
[17:01:17.360] Resolving globals: FALSE
[17:01:17.361] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:17.361] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:17.361] - globals: [1] ‘FUN’
[17:01:17.361] 
[17:01:17.361] getGlobalsAndPackages() ... DONE
[17:01:17.361]  - globals found/used: [n=1] ‘FUN’
[17:01:17.362]  - needed namespaces: [n=0] 
[17:01:17.362] Finding globals ... DONE
[17:01:17.362] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:17.362] List of 2
[17:01:17.362]  $ ...future.FUN:function (x, y)  
[17:01:17.362]  $ MoreArgs     : NULL
[17:01:17.362]  - attr(*, "where")=List of 2
[17:01:17.362]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:17.362]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:17.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:17.362]  - attr(*, "resolved")= logi FALSE
[17:01:17.362]  - attr(*, "total_size")= num NA
[17:01:17.364] Packages to be attached in all futures: [n=0] 
[17:01:17.364] getGlobalsAndPackagesXApply() ... DONE
[17:01:17.365] Number of futures (= number of chunks): 1
[17:01:17.365] Launching 1 futures (chunks) ...
[17:01:17.365] Chunk #1 of 1 ...
[17:01:17.365]  - Finding globals in '...' for chunk #1 ...
[17:01:17.365] getGlobalsAndPackages() ...
[17:01:17.365] Searching for globals...
[17:01:17.366] 
[17:01:17.366] Searching for globals ... DONE
[17:01:17.366] - globals: [0] <none>
[17:01:17.366] getGlobalsAndPackages() ... DONE
[17:01:17.366]    + additional globals found: [n=0] 
[17:01:17.366]    + additional namespaces needed: [n=0] 
[17:01:17.366]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:17.366]  - seeds: <none>
[17:01:17.366]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:17.366] getGlobalsAndPackages() ...
[17:01:17.366] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:17.367] Resolving globals: FALSE
[17:01:17.367] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:01:17.367] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:17.368] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:17.368] 
[17:01:17.368] getGlobalsAndPackages() ... DONE
[17:01:17.368] run() for ‘Future’ ...
[17:01:17.368] - state: ‘created’
[17:01:17.368] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:17.369] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:17.369] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:17.369]   - Field: ‘label’
[17:01:17.369]   - Field: ‘local’
[17:01:17.369]   - Field: ‘owner’
[17:01:17.369]   - Field: ‘envir’
[17:01:17.369]   - Field: ‘packages’
[17:01:17.369]   - Field: ‘gc’
[17:01:17.369]   - Field: ‘conditions’
[17:01:17.370]   - Field: ‘expr’
[17:01:17.370]   - Field: ‘uuid’
[17:01:17.370]   - Field: ‘seed’
[17:01:17.370]   - Field: ‘version’
[17:01:17.370]   - Field: ‘result’
[17:01:17.370]   - Field: ‘asynchronous’
[17:01:17.370]   - Field: ‘calls’
[17:01:17.370]   - Field: ‘globals’
[17:01:17.370]   - Field: ‘stdout’
[17:01:17.370]   - Field: ‘earlySignal’
[17:01:17.370]   - Field: ‘lazy’
[17:01:17.370]   - Field: ‘state’
[17:01:17.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:17.371] - Launch lazy future ...
[17:01:17.371] Packages needed by the future expression (n = 0): <none>
[17:01:17.371] Packages needed by future strategies (n = 0): <none>
[17:01:17.371] {
[17:01:17.371]     {
[17:01:17.371]         {
[17:01:17.371]             ...future.startTime <- base::Sys.time()
[17:01:17.371]             {
[17:01:17.371]                 {
[17:01:17.371]                   {
[17:01:17.371]                     base::local({
[17:01:17.371]                       has_future <- base::requireNamespace("future", 
[17:01:17.371]                         quietly = TRUE)
[17:01:17.371]                       if (has_future) {
[17:01:17.371]                         ns <- base::getNamespace("future")
[17:01:17.371]                         version <- ns[[".package"]][["version"]]
[17:01:17.371]                         if (is.null(version)) 
[17:01:17.371]                           version <- utils::packageVersion("future")
[17:01:17.371]                       }
[17:01:17.371]                       else {
[17:01:17.371]                         version <- NULL
[17:01:17.371]                       }
[17:01:17.371]                       if (!has_future || version < "1.8.0") {
[17:01:17.371]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:17.371]                           "", base::R.version$version.string), 
[17:01:17.371]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:17.371]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:17.371]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:17.371]                             "release", "version")], collapse = " "), 
[17:01:17.371]                           hostname = base::Sys.info()[["nodename"]])
[17:01:17.371]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:17.371]                           info)
[17:01:17.371]                         info <- base::paste(info, collapse = "; ")
[17:01:17.371]                         if (!has_future) {
[17:01:17.371]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:17.371]                             info)
[17:01:17.371]                         }
[17:01:17.371]                         else {
[17:01:17.371]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:17.371]                             info, version)
[17:01:17.371]                         }
[17:01:17.371]                         base::stop(msg)
[17:01:17.371]                       }
[17:01:17.371]                     })
[17:01:17.371]                   }
[17:01:17.371]                   ...future.strategy.old <- future::plan("list")
[17:01:17.371]                   options(future.plan = NULL)
[17:01:17.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:17.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:17.371]                 }
[17:01:17.371]                 ...future.workdir <- getwd()
[17:01:17.371]             }
[17:01:17.371]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:17.371]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:17.371]         }
[17:01:17.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:17.371]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:17.371]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:17.371]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:17.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:17.371]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:17.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:17.371]             base::names(...future.oldOptions))
[17:01:17.371]     }
[17:01:17.371]     if (FALSE) {
[17:01:17.371]     }
[17:01:17.371]     else {
[17:01:17.371]         if (FALSE) {
[17:01:17.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:17.371]                 open = "w")
[17:01:17.371]         }
[17:01:17.371]         else {
[17:01:17.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:17.371]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:17.371]         }
[17:01:17.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:17.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:17.371]             base::sink(type = "output", split = FALSE)
[17:01:17.371]             base::close(...future.stdout)
[17:01:17.371]         }, add = TRUE)
[17:01:17.371]     }
[17:01:17.371]     ...future.frame <- base::sys.nframe()
[17:01:17.371]     ...future.conditions <- base::list()
[17:01:17.371]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:17.371]     if (FALSE) {
[17:01:17.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:17.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:17.371]     }
[17:01:17.371]     ...future.result <- base::tryCatch({
[17:01:17.371]         base::withCallingHandlers({
[17:01:17.371]             ...future.value <- base::withVisible(base::local({
[17:01:17.371]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:17.371]                 if (!identical(...future.globals.maxSize.org, 
[17:01:17.371]                   ...future.globals.maxSize)) {
[17:01:17.371]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:17.371]                   on.exit(options(oopts), add = TRUE)
[17:01:17.371]                 }
[17:01:17.371]                 {
[17:01:17.371]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:17.371]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:17.371]                     USE.NAMES = FALSE)
[17:01:17.371]                   do.call(mapply, args = args)
[17:01:17.371]                 }
[17:01:17.371]             }))
[17:01:17.371]             future::FutureResult(value = ...future.value$value, 
[17:01:17.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:17.371]                   ...future.rng), globalenv = if (FALSE) 
[17:01:17.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:17.371]                     ...future.globalenv.names))
[17:01:17.371]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:17.371]         }, condition = base::local({
[17:01:17.371]             c <- base::c
[17:01:17.371]             inherits <- base::inherits
[17:01:17.371]             invokeRestart <- base::invokeRestart
[17:01:17.371]             length <- base::length
[17:01:17.371]             list <- base::list
[17:01:17.371]             seq.int <- base::seq.int
[17:01:17.371]             signalCondition <- base::signalCondition
[17:01:17.371]             sys.calls <- base::sys.calls
[17:01:17.371]             `[[` <- base::`[[`
[17:01:17.371]             `+` <- base::`+`
[17:01:17.371]             `<<-` <- base::`<<-`
[17:01:17.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:17.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:17.371]                   3L)]
[17:01:17.371]             }
[17:01:17.371]             function(cond) {
[17:01:17.371]                 is_error <- inherits(cond, "error")
[17:01:17.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:17.371]                   NULL)
[17:01:17.371]                 if (is_error) {
[17:01:17.371]                   sessionInformation <- function() {
[17:01:17.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:17.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:17.371]                       search = base::search(), system = base::Sys.info())
[17:01:17.371]                   }
[17:01:17.371]                   ...future.conditions[[length(...future.conditions) + 
[17:01:17.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:17.371]                     cond$call), session = sessionInformation(), 
[17:01:17.371]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:17.371]                   signalCondition(cond)
[17:01:17.371]                 }
[17:01:17.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:17.371]                 "immediateCondition"))) {
[17:01:17.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:17.371]                   ...future.conditions[[length(...future.conditions) + 
[17:01:17.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:17.371]                   if (TRUE && !signal) {
[17:01:17.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:17.371]                     {
[17:01:17.371]                       inherits <- base::inherits
[17:01:17.371]                       invokeRestart <- base::invokeRestart
[17:01:17.371]                       is.null <- base::is.null
[17:01:17.371]                       muffled <- FALSE
[17:01:17.371]                       if (inherits(cond, "message")) {
[17:01:17.371]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:17.371]                         if (muffled) 
[17:01:17.371]                           invokeRestart("muffleMessage")
[17:01:17.371]                       }
[17:01:17.371]                       else if (inherits(cond, "warning")) {
[17:01:17.371]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:17.371]                         if (muffled) 
[17:01:17.371]                           invokeRestart("muffleWarning")
[17:01:17.371]                       }
[17:01:17.371]                       else if (inherits(cond, "condition")) {
[17:01:17.371]                         if (!is.null(pattern)) {
[17:01:17.371]                           computeRestarts <- base::computeRestarts
[17:01:17.371]                           grepl <- base::grepl
[17:01:17.371]                           restarts <- computeRestarts(cond)
[17:01:17.371]                           for (restart in restarts) {
[17:01:17.371]                             name <- restart$name
[17:01:17.371]                             if (is.null(name)) 
[17:01:17.371]                               next
[17:01:17.371]                             if (!grepl(pattern, name)) 
[17:01:17.371]                               next
[17:01:17.371]                             invokeRestart(restart)
[17:01:17.371]                             muffled <- TRUE
[17:01:17.371]                             break
[17:01:17.371]                           }
[17:01:17.371]                         }
[17:01:17.371]                       }
[17:01:17.371]                       invisible(muffled)
[17:01:17.371]                     }
[17:01:17.371]                     muffleCondition(cond, pattern = "^muffle")
[17:01:17.371]                   }
[17:01:17.371]                 }
[17:01:17.371]                 else {
[17:01:17.371]                   if (TRUE) {
[17:01:17.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:17.371]                     {
[17:01:17.371]                       inherits <- base::inherits
[17:01:17.371]                       invokeRestart <- base::invokeRestart
[17:01:17.371]                       is.null <- base::is.null
[17:01:17.371]                       muffled <- FALSE
[17:01:17.371]                       if (inherits(cond, "message")) {
[17:01:17.371]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:17.371]                         if (muffled) 
[17:01:17.371]                           invokeRestart("muffleMessage")
[17:01:17.371]                       }
[17:01:17.371]                       else if (inherits(cond, "warning")) {
[17:01:17.371]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:17.371]                         if (muffled) 
[17:01:17.371]                           invokeRestart("muffleWarning")
[17:01:17.371]                       }
[17:01:17.371]                       else if (inherits(cond, "condition")) {
[17:01:17.371]                         if (!is.null(pattern)) {
[17:01:17.371]                           computeRestarts <- base::computeRestarts
[17:01:17.371]                           grepl <- base::grepl
[17:01:17.371]                           restarts <- computeRestarts(cond)
[17:01:17.371]                           for (restart in restarts) {
[17:01:17.371]                             name <- restart$name
[17:01:17.371]                             if (is.null(name)) 
[17:01:17.371]                               next
[17:01:17.371]                             if (!grepl(pattern, name)) 
[17:01:17.371]                               next
[17:01:17.371]                             invokeRestart(restart)
[17:01:17.371]                             muffled <- TRUE
[17:01:17.371]                             break
[17:01:17.371]                           }
[17:01:17.371]                         }
[17:01:17.371]                       }
[17:01:17.371]                       invisible(muffled)
[17:01:17.371]                     }
[17:01:17.371]                     muffleCondition(cond, pattern = "^muffle")
[17:01:17.371]                   }
[17:01:17.371]                 }
[17:01:17.371]             }
[17:01:17.371]         }))
[17:01:17.371]     }, error = function(ex) {
[17:01:17.371]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:17.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:17.371]                 ...future.rng), started = ...future.startTime, 
[17:01:17.371]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:17.371]             version = "1.8"), class = "FutureResult")
[17:01:17.371]     }, finally = {
[17:01:17.371]         if (!identical(...future.workdir, getwd())) 
[17:01:17.371]             setwd(...future.workdir)
[17:01:17.371]         {
[17:01:17.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:17.371]                 ...future.oldOptions$nwarnings <- NULL
[17:01:17.371]             }
[17:01:17.371]             base::options(...future.oldOptions)
[17:01:17.371]             if (.Platform$OS.type == "windows") {
[17:01:17.371]                 old_names <- names(...future.oldEnvVars)
[17:01:17.371]                 envs <- base::Sys.getenv()
[17:01:17.371]                 names <- names(envs)
[17:01:17.371]                 common <- intersect(names, old_names)
[17:01:17.371]                 added <- setdiff(names, old_names)
[17:01:17.371]                 removed <- setdiff(old_names, names)
[17:01:17.371]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:17.371]                   envs[common]]
[17:01:17.371]                 NAMES <- toupper(changed)
[17:01:17.371]                 args <- list()
[17:01:17.371]                 for (kk in seq_along(NAMES)) {
[17:01:17.371]                   name <- changed[[kk]]
[17:01:17.371]                   NAME <- NAMES[[kk]]
[17:01:17.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:17.371]                     next
[17:01:17.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:17.371]                 }
[17:01:17.371]                 NAMES <- toupper(added)
[17:01:17.371]                 for (kk in seq_along(NAMES)) {
[17:01:17.371]                   name <- added[[kk]]
[17:01:17.371]                   NAME <- NAMES[[kk]]
[17:01:17.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:17.371]                     next
[17:01:17.371]                   args[[name]] <- ""
[17:01:17.371]                 }
[17:01:17.371]                 NAMES <- toupper(removed)
[17:01:17.371]                 for (kk in seq_along(NAMES)) {
[17:01:17.371]                   name <- removed[[kk]]
[17:01:17.371]                   NAME <- NAMES[[kk]]
[17:01:17.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:17.371]                     next
[17:01:17.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:17.371]                 }
[17:01:17.371]                 if (length(args) > 0) 
[17:01:17.371]                   base::do.call(base::Sys.setenv, args = args)
[17:01:17.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:17.371]             }
[17:01:17.371]             else {
[17:01:17.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:17.371]             }
[17:01:17.371]             {
[17:01:17.371]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:17.371]                   0L) {
[17:01:17.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:17.371]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:17.371]                   base::options(opts)
[17:01:17.371]                 }
[17:01:17.371]                 {
[17:01:17.371]                   {
[17:01:17.371]                     NULL
[17:01:17.371]                     RNGkind("Mersenne-Twister")
[17:01:17.371]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:17.371]                       inherits = FALSE)
[17:01:17.371]                   }
[17:01:17.371]                   options(future.plan = NULL)
[17:01:17.371]                   if (is.na(NA_character_)) 
[17:01:17.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:17.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:17.371]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:17.371]                     .init = FALSE)
[17:01:17.371]                 }
[17:01:17.371]             }
[17:01:17.371]         }
[17:01:17.371]     })
[17:01:17.371]     if (TRUE) {
[17:01:17.371]         base::sink(type = "output", split = FALSE)
[17:01:17.371]         if (FALSE) {
[17:01:17.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:17.371]         }
[17:01:17.371]         else {
[17:01:17.371]             ...future.result["stdout"] <- base::list(NULL)
[17:01:17.371]         }
[17:01:17.371]         base::close(...future.stdout)
[17:01:17.371]         ...future.stdout <- NULL
[17:01:17.371]     }
[17:01:17.371]     ...future.result$conditions <- ...future.conditions
[17:01:17.371]     ...future.result$finished <- base::Sys.time()
[17:01:17.371]     ...future.result
[17:01:17.371] }
[17:01:17.373] assign_globals() ...
[17:01:17.373] List of 5
[17:01:17.373]  $ ...future.FUN            :function (x, y)  
[17:01:17.373]  $ MoreArgs                 : NULL
[17:01:17.373]  $ ...future.elements_ii    :List of 2
[17:01:17.373]   ..$ :List of 2
[17:01:17.373]   .. ..$ : int 1
[17:01:17.373]   .. ..$ : int 0
[17:01:17.373]   ..$ :List of 2
[17:01:17.373]   .. ..$ : int 0
[17:01:17.373]   .. ..$ : int 1
[17:01:17.373]  $ ...future.seeds_ii       : NULL
[17:01:17.373]  $ ...future.globals.maxSize: NULL
[17:01:17.373]  - attr(*, "where")=List of 5
[17:01:17.373]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:17.373]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:17.373]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:17.373]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:17.373]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:17.373]  - attr(*, "resolved")= logi FALSE
[17:01:17.373]  - attr(*, "total_size")= num 6480
[17:01:17.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:17.373]  - attr(*, "already-done")= logi TRUE
[17:01:17.380] - reassign environment for ‘...future.FUN’
[17:01:17.381] - copied ‘...future.FUN’ to environment
[17:01:17.381] - copied ‘MoreArgs’ to environment
[17:01:17.381] - copied ‘...future.elements_ii’ to environment
[17:01:17.381] - copied ‘...future.seeds_ii’ to environment
[17:01:17.381] - copied ‘...future.globals.maxSize’ to environment
[17:01:17.381] assign_globals() ... done
[17:01:17.381] plan(): Setting new future strategy stack:
[17:01:17.381] List of future strategies:
[17:01:17.381] 1. sequential:
[17:01:17.381]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:17.381]    - tweaked: FALSE
[17:01:17.381]    - call: NULL
[17:01:17.382] plan(): nbrOfWorkers() = 1
[17:01:17.884] plan(): Setting new future strategy stack:
[17:01:17.884] List of future strategies:
[17:01:17.884] 1. sequential:
[17:01:17.884]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:17.884]    - tweaked: FALSE
[17:01:17.884]    - call: plan(strategy)
[17:01:17.884] plan(): nbrOfWorkers() = 1
[17:01:17.885] SequentialFuture started (and completed)
[17:01:17.885] - Launch lazy future ... done
[17:01:17.885] run() for ‘SequentialFuture’ ... done
[17:01:17.885] Created future:
[17:01:17.885] SequentialFuture:
[17:01:17.885] Label: ‘future_mapply-1’
[17:01:17.885] Expression:
[17:01:17.885] {
[17:01:17.885]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:17.885]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:17.885]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:17.885]         on.exit(options(oopts), add = TRUE)
[17:01:17.885]     }
[17:01:17.885]     {
[17:01:17.885]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:17.885]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:17.885]         do.call(mapply, args = args)
[17:01:17.885]     }
[17:01:17.885] }
[17:01:17.885] Lazy evaluation: FALSE
[17:01:17.885] Asynchronous evaluation: FALSE
[17:01:17.885] Local evaluation: TRUE
[17:01:17.885] Environment: R_GlobalEnv
[17:01:17.885] Capture standard output: FALSE
[17:01:17.885] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:17.885] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:17.885] Packages: <none>
[17:01:17.885] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:17.885] Resolved: TRUE
[17:01:17.885] Value: 224 bytes of class ‘list’
[17:01:17.885] Early signaling: FALSE
[17:01:17.885] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:17.885] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:17.886] Chunk #1 of 1 ... DONE
[17:01:17.886] Launching 1 futures (chunks) ... DONE
[17:01:17.886] Resolving 1 futures (chunks) ...
[17:01:17.886] resolve() on list ...
[17:01:17.886]  recursive: 0
[17:01:17.887]  length: 1
[17:01:17.887] 
[17:01:17.887] resolved() for ‘SequentialFuture’ ...
[17:01:17.887] - state: ‘finished’
[17:01:17.887] - run: TRUE
[17:01:17.887] - result: ‘FutureResult’
[17:01:17.887] resolved() for ‘SequentialFuture’ ... done
[17:01:17.887] Future #1
[17:01:17.887] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:17.888] - nx: 1
[17:01:17.888] - relay: TRUE
[17:01:17.888] - stdout: TRUE
[17:01:17.888] - signal: TRUE
[17:01:17.888] - resignal: FALSE
[17:01:17.888] - force: TRUE
[17:01:17.888] - relayed: [n=1] FALSE
[17:01:17.888] - queued futures: [n=1] FALSE
[17:01:17.888]  - until=1
[17:01:17.888]  - relaying element #1
[17:01:17.888] - relayed: [n=1] TRUE
[17:01:17.889] - queued futures: [n=1] TRUE
[17:01:17.889] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:17.889]  length: 0 (resolved future 1)
[17:01:17.889] Relaying remaining futures
[17:01:17.889] signalConditionsASAP(NULL, pos=0) ...
[17:01:17.889] - nx: 1
[17:01:17.889] - relay: TRUE
[17:01:17.889] - stdout: TRUE
[17:01:17.889] - signal: TRUE
[17:01:17.889] - resignal: FALSE
[17:01:17.889] - force: TRUE
[17:01:17.889] - relayed: [n=1] TRUE
[17:01:17.890] - queued futures: [n=1] TRUE
 - flush all
[17:01:17.890] - relayed: [n=1] TRUE
[17:01:17.890] - queued futures: [n=1] TRUE
[17:01:17.890] signalConditionsASAP(NULL, pos=0) ... done
[17:01:17.890] resolve() on list ... DONE
[17:01:17.890]  - Number of value chunks collected: 1
[17:01:17.890] Resolving 1 futures (chunks) ... DONE
[17:01:17.890] Reducing values from 1 chunks ...
[17:01:17.890]  - Number of values collected after concatenation: 2
[17:01:17.890]  - Number of values expected: 2
[17:01:17.891] Reducing values from 1 chunks ... DONE
[17:01:17.891] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:01:17.891] future_mapply() ...
[17:01:17.891] Number of chunks: 1
[17:01:17.891] getGlobalsAndPackagesXApply() ...
[17:01:17.891]  - future.globals: TRUE
[17:01:17.892] getGlobalsAndPackages() ...
[17:01:17.892] Searching for globals...
[17:01:17.893] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:17.893] Searching for globals ... DONE
[17:01:17.893] Resolving globals: FALSE
[17:01:17.894] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:17.894] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:17.894] - globals: [1] ‘FUN’
[17:01:17.894] 
[17:01:17.894] getGlobalsAndPackages() ... DONE
[17:01:17.895]  - globals found/used: [n=1] ‘FUN’
[17:01:17.895]  - needed namespaces: [n=0] 
[17:01:17.895] Finding globals ... DONE
[17:01:17.895] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:17.895] List of 2
[17:01:17.895]  $ ...future.FUN:function (x, y)  
[17:01:17.895]  $ MoreArgs     : NULL
[17:01:17.895]  - attr(*, "where")=List of 2
[17:01:17.895]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:17.895]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:17.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:17.895]  - attr(*, "resolved")= logi FALSE
[17:01:17.895]  - attr(*, "total_size")= num NA
[17:01:17.898] Packages to be attached in all futures: [n=0] 
[17:01:17.898] getGlobalsAndPackagesXApply() ... DONE
[17:01:17.898] Number of futures (= number of chunks): 1
[17:01:17.898] Launching 1 futures (chunks) ...
[17:01:17.898] Chunk #1 of 1 ...
[17:01:17.898]  - Finding globals in '...' for chunk #1 ...
[17:01:17.898] getGlobalsAndPackages() ...
[17:01:17.898] Searching for globals...
[17:01:17.899] 
[17:01:17.899] Searching for globals ... DONE
[17:01:17.899] - globals: [0] <none>
[17:01:17.899] getGlobalsAndPackages() ... DONE
[17:01:17.899]    + additional globals found: [n=0] 
[17:01:17.899]    + additional namespaces needed: [n=0] 
[17:01:17.899]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:17.899]  - seeds: <none>
[17:01:17.899]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:17.900] getGlobalsAndPackages() ...
[17:01:17.900] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:17.900] Resolving globals: FALSE
[17:01:17.900] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:01:17.901] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:17.901] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:17.901] 
[17:01:17.901] getGlobalsAndPackages() ... DONE
[17:01:17.903] run() for ‘Future’ ...
[17:01:17.903] - state: ‘created’
[17:01:17.903] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:17.903] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:17.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:17.904]   - Field: ‘label’
[17:01:17.904]   - Field: ‘local’
[17:01:17.904]   - Field: ‘owner’
[17:01:17.904]   - Field: ‘envir’
[17:01:17.904]   - Field: ‘packages’
[17:01:17.904]   - Field: ‘gc’
[17:01:17.904]   - Field: ‘conditions’
[17:01:17.904]   - Field: ‘expr’
[17:01:17.904]   - Field: ‘uuid’
[17:01:17.904]   - Field: ‘seed’
[17:01:17.905]   - Field: ‘version’
[17:01:17.905]   - Field: ‘result’
[17:01:17.905]   - Field: ‘asynchronous’
[17:01:17.905]   - Field: ‘calls’
[17:01:17.905]   - Field: ‘globals’
[17:01:17.905]   - Field: ‘stdout’
[17:01:17.905]   - Field: ‘earlySignal’
[17:01:17.905]   - Field: ‘lazy’
[17:01:17.905]   - Field: ‘state’
[17:01:17.905] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:17.905] - Launch lazy future ...
[17:01:17.906] Packages needed by the future expression (n = 0): <none>
[17:01:17.906] Packages needed by future strategies (n = 0): <none>
[17:01:17.906] {
[17:01:17.906]     {
[17:01:17.906]         {
[17:01:17.906]             ...future.startTime <- base::Sys.time()
[17:01:17.906]             {
[17:01:17.906]                 {
[17:01:17.906]                   {
[17:01:17.906]                     base::local({
[17:01:17.906]                       has_future <- base::requireNamespace("future", 
[17:01:17.906]                         quietly = TRUE)
[17:01:17.906]                       if (has_future) {
[17:01:17.906]                         ns <- base::getNamespace("future")
[17:01:17.906]                         version <- ns[[".package"]][["version"]]
[17:01:17.906]                         if (is.null(version)) 
[17:01:17.906]                           version <- utils::packageVersion("future")
[17:01:17.906]                       }
[17:01:17.906]                       else {
[17:01:17.906]                         version <- NULL
[17:01:17.906]                       }
[17:01:17.906]                       if (!has_future || version < "1.8.0") {
[17:01:17.906]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:17.906]                           "", base::R.version$version.string), 
[17:01:17.906]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:17.906]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:17.906]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:17.906]                             "release", "version")], collapse = " "), 
[17:01:17.906]                           hostname = base::Sys.info()[["nodename"]])
[17:01:17.906]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:17.906]                           info)
[17:01:17.906]                         info <- base::paste(info, collapse = "; ")
[17:01:17.906]                         if (!has_future) {
[17:01:17.906]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:17.906]                             info)
[17:01:17.906]                         }
[17:01:17.906]                         else {
[17:01:17.906]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:17.906]                             info, version)
[17:01:17.906]                         }
[17:01:17.906]                         base::stop(msg)
[17:01:17.906]                       }
[17:01:17.906]                     })
[17:01:17.906]                   }
[17:01:17.906]                   ...future.strategy.old <- future::plan("list")
[17:01:17.906]                   options(future.plan = NULL)
[17:01:17.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:17.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:17.906]                 }
[17:01:17.906]                 ...future.workdir <- getwd()
[17:01:17.906]             }
[17:01:17.906]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:17.906]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:17.906]         }
[17:01:17.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:17.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:17.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:17.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:17.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:17.906]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:17.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:17.906]             base::names(...future.oldOptions))
[17:01:17.906]     }
[17:01:17.906]     if (FALSE) {
[17:01:17.906]     }
[17:01:17.906]     else {
[17:01:17.906]         if (TRUE) {
[17:01:17.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:17.906]                 open = "w")
[17:01:17.906]         }
[17:01:17.906]         else {
[17:01:17.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:17.906]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:17.906]         }
[17:01:17.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:17.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:17.906]             base::sink(type = "output", split = FALSE)
[17:01:17.906]             base::close(...future.stdout)
[17:01:17.906]         }, add = TRUE)
[17:01:17.906]     }
[17:01:17.906]     ...future.frame <- base::sys.nframe()
[17:01:17.906]     ...future.conditions <- base::list()
[17:01:17.906]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:17.906]     if (FALSE) {
[17:01:17.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:17.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:17.906]     }
[17:01:17.906]     ...future.result <- base::tryCatch({
[17:01:17.906]         base::withCallingHandlers({
[17:01:17.906]             ...future.value <- base::withVisible(base::local({
[17:01:17.906]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:17.906]                 if (!identical(...future.globals.maxSize.org, 
[17:01:17.906]                   ...future.globals.maxSize)) {
[17:01:17.906]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:17.906]                   on.exit(options(oopts), add = TRUE)
[17:01:17.906]                 }
[17:01:17.906]                 {
[17:01:17.906]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:17.906]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:17.906]                     USE.NAMES = FALSE)
[17:01:17.906]                   do.call(mapply, args = args)
[17:01:17.906]                 }
[17:01:17.906]             }))
[17:01:17.906]             future::FutureResult(value = ...future.value$value, 
[17:01:17.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:17.906]                   ...future.rng), globalenv = if (FALSE) 
[17:01:17.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:17.906]                     ...future.globalenv.names))
[17:01:17.906]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:17.906]         }, condition = base::local({
[17:01:17.906]             c <- base::c
[17:01:17.906]             inherits <- base::inherits
[17:01:17.906]             invokeRestart <- base::invokeRestart
[17:01:17.906]             length <- base::length
[17:01:17.906]             list <- base::list
[17:01:17.906]             seq.int <- base::seq.int
[17:01:17.906]             signalCondition <- base::signalCondition
[17:01:17.906]             sys.calls <- base::sys.calls
[17:01:17.906]             `[[` <- base::`[[`
[17:01:17.906]             `+` <- base::`+`
[17:01:17.906]             `<<-` <- base::`<<-`
[17:01:17.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:17.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:17.906]                   3L)]
[17:01:17.906]             }
[17:01:17.906]             function(cond) {
[17:01:17.906]                 is_error <- inherits(cond, "error")
[17:01:17.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:17.906]                   NULL)
[17:01:17.906]                 if (is_error) {
[17:01:17.906]                   sessionInformation <- function() {
[17:01:17.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:17.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:17.906]                       search = base::search(), system = base::Sys.info())
[17:01:17.906]                   }
[17:01:17.906]                   ...future.conditions[[length(...future.conditions) + 
[17:01:17.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:17.906]                     cond$call), session = sessionInformation(), 
[17:01:17.906]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:17.906]                   signalCondition(cond)
[17:01:17.906]                 }
[17:01:17.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:17.906]                 "immediateCondition"))) {
[17:01:17.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:17.906]                   ...future.conditions[[length(...future.conditions) + 
[17:01:17.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:17.906]                   if (TRUE && !signal) {
[17:01:17.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:17.906]                     {
[17:01:17.906]                       inherits <- base::inherits
[17:01:17.906]                       invokeRestart <- base::invokeRestart
[17:01:17.906]                       is.null <- base::is.null
[17:01:17.906]                       muffled <- FALSE
[17:01:17.906]                       if (inherits(cond, "message")) {
[17:01:17.906]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:17.906]                         if (muffled) 
[17:01:17.906]                           invokeRestart("muffleMessage")
[17:01:17.906]                       }
[17:01:17.906]                       else if (inherits(cond, "warning")) {
[17:01:17.906]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:17.906]                         if (muffled) 
[17:01:17.906]                           invokeRestart("muffleWarning")
[17:01:17.906]                       }
[17:01:17.906]                       else if (inherits(cond, "condition")) {
[17:01:17.906]                         if (!is.null(pattern)) {
[17:01:17.906]                           computeRestarts <- base::computeRestarts
[17:01:17.906]                           grepl <- base::grepl
[17:01:17.906]                           restarts <- computeRestarts(cond)
[17:01:17.906]                           for (restart in restarts) {
[17:01:17.906]                             name <- restart$name
[17:01:17.906]                             if (is.null(name)) 
[17:01:17.906]                               next
[17:01:17.906]                             if (!grepl(pattern, name)) 
[17:01:17.906]                               next
[17:01:17.906]                             invokeRestart(restart)
[17:01:17.906]                             muffled <- TRUE
[17:01:17.906]                             break
[17:01:17.906]                           }
[17:01:17.906]                         }
[17:01:17.906]                       }
[17:01:17.906]                       invisible(muffled)
[17:01:17.906]                     }
[17:01:17.906]                     muffleCondition(cond, pattern = "^muffle")
[17:01:17.906]                   }
[17:01:17.906]                 }
[17:01:17.906]                 else {
[17:01:17.906]                   if (TRUE) {
[17:01:17.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:17.906]                     {
[17:01:17.906]                       inherits <- base::inherits
[17:01:17.906]                       invokeRestart <- base::invokeRestart
[17:01:17.906]                       is.null <- base::is.null
[17:01:17.906]                       muffled <- FALSE
[17:01:17.906]                       if (inherits(cond, "message")) {
[17:01:17.906]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:17.906]                         if (muffled) 
[17:01:17.906]                           invokeRestart("muffleMessage")
[17:01:17.906]                       }
[17:01:17.906]                       else if (inherits(cond, "warning")) {
[17:01:17.906]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:17.906]                         if (muffled) 
[17:01:17.906]                           invokeRestart("muffleWarning")
[17:01:17.906]                       }
[17:01:17.906]                       else if (inherits(cond, "condition")) {
[17:01:17.906]                         if (!is.null(pattern)) {
[17:01:17.906]                           computeRestarts <- base::computeRestarts
[17:01:17.906]                           grepl <- base::grepl
[17:01:17.906]                           restarts <- computeRestarts(cond)
[17:01:17.906]                           for (restart in restarts) {
[17:01:17.906]                             name <- restart$name
[17:01:17.906]                             if (is.null(name)) 
[17:01:17.906]                               next
[17:01:17.906]                             if (!grepl(pattern, name)) 
[17:01:17.906]                               next
[17:01:17.906]                             invokeRestart(restart)
[17:01:17.906]                             muffled <- TRUE
[17:01:17.906]                             break
[17:01:17.906]                           }
[17:01:17.906]                         }
[17:01:17.906]                       }
[17:01:17.906]                       invisible(muffled)
[17:01:17.906]                     }
[17:01:17.906]                     muffleCondition(cond, pattern = "^muffle")
[17:01:17.906]                   }
[17:01:17.906]                 }
[17:01:17.906]             }
[17:01:17.906]         }))
[17:01:17.906]     }, error = function(ex) {
[17:01:17.906]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:17.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:17.906]                 ...future.rng), started = ...future.startTime, 
[17:01:17.906]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:17.906]             version = "1.8"), class = "FutureResult")
[17:01:17.906]     }, finally = {
[17:01:17.906]         if (!identical(...future.workdir, getwd())) 
[17:01:17.906]             setwd(...future.workdir)
[17:01:17.906]         {
[17:01:17.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:17.906]                 ...future.oldOptions$nwarnings <- NULL
[17:01:17.906]             }
[17:01:17.906]             base::options(...future.oldOptions)
[17:01:17.906]             if (.Platform$OS.type == "windows") {
[17:01:17.906]                 old_names <- names(...future.oldEnvVars)
[17:01:17.906]                 envs <- base::Sys.getenv()
[17:01:17.906]                 names <- names(envs)
[17:01:17.906]                 common <- intersect(names, old_names)
[17:01:17.906]                 added <- setdiff(names, old_names)
[17:01:17.906]                 removed <- setdiff(old_names, names)
[17:01:17.906]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:17.906]                   envs[common]]
[17:01:17.906]                 NAMES <- toupper(changed)
[17:01:17.906]                 args <- list()
[17:01:17.906]                 for (kk in seq_along(NAMES)) {
[17:01:17.906]                   name <- changed[[kk]]
[17:01:17.906]                   NAME <- NAMES[[kk]]
[17:01:17.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:17.906]                     next
[17:01:17.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:17.906]                 }
[17:01:17.906]                 NAMES <- toupper(added)
[17:01:17.906]                 for (kk in seq_along(NAMES)) {
[17:01:17.906]                   name <- added[[kk]]
[17:01:17.906]                   NAME <- NAMES[[kk]]
[17:01:17.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:17.906]                     next
[17:01:17.906]                   args[[name]] <- ""
[17:01:17.906]                 }
[17:01:17.906]                 NAMES <- toupper(removed)
[17:01:17.906]                 for (kk in seq_along(NAMES)) {
[17:01:17.906]                   name <- removed[[kk]]
[17:01:17.906]                   NAME <- NAMES[[kk]]
[17:01:17.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:17.906]                     next
[17:01:17.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:17.906]                 }
[17:01:17.906]                 if (length(args) > 0) 
[17:01:17.906]                   base::do.call(base::Sys.setenv, args = args)
[17:01:17.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:17.906]             }
[17:01:17.906]             else {
[17:01:17.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:17.906]             }
[17:01:17.906]             {
[17:01:17.906]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:17.906]                   0L) {
[17:01:17.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:17.906]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:17.906]                   base::options(opts)
[17:01:17.906]                 }
[17:01:17.906]                 {
[17:01:17.906]                   {
[17:01:17.906]                     NULL
[17:01:17.906]                     RNGkind("Mersenne-Twister")
[17:01:17.906]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:17.906]                       inherits = FALSE)
[17:01:17.906]                   }
[17:01:17.906]                   options(future.plan = NULL)
[17:01:17.906]                   if (is.na(NA_character_)) 
[17:01:17.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:17.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:17.906]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:17.906]                     .init = FALSE)
[17:01:17.906]                 }
[17:01:17.906]             }
[17:01:17.906]         }
[17:01:17.906]     })
[17:01:17.906]     if (TRUE) {
[17:01:17.906]         base::sink(type = "output", split = FALSE)
[17:01:17.906]         if (TRUE) {
[17:01:17.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:17.906]         }
[17:01:17.906]         else {
[17:01:17.906]             ...future.result["stdout"] <- base::list(NULL)
[17:01:17.906]         }
[17:01:17.906]         base::close(...future.stdout)
[17:01:17.906]         ...future.stdout <- NULL
[17:01:17.906]     }
[17:01:17.906]     ...future.result$conditions <- ...future.conditions
[17:01:17.906]     ...future.result$finished <- base::Sys.time()
[17:01:17.906]     ...future.result
[17:01:17.906] }
[17:01:17.908] assign_globals() ...
[17:01:17.908] List of 5
[17:01:17.908]  $ ...future.FUN            :function (x, y)  
[17:01:17.908]  $ MoreArgs                 : NULL
[17:01:17.908]  $ ...future.elements_ii    :List of 2
[17:01:17.908]   ..$ :List of 2
[17:01:17.908]   .. ..$ : int 1
[17:01:17.908]   .. ..$ : int 0
[17:01:17.908]   ..$ :List of 2
[17:01:17.908]   .. ..$ : int 0
[17:01:17.908]   .. ..$ : int 1
[17:01:17.908]  $ ...future.seeds_ii       : NULL
[17:01:17.908]  $ ...future.globals.maxSize: NULL
[17:01:17.908]  - attr(*, "where")=List of 5
[17:01:17.908]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:17.908]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:17.908]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:17.908]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:17.908]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:17.908]  - attr(*, "resolved")= logi FALSE
[17:01:17.908]  - attr(*, "total_size")= num 6480
[17:01:17.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:17.908]  - attr(*, "already-done")= logi TRUE
[17:01:17.914] - reassign environment for ‘...future.FUN’
[17:01:17.914] - copied ‘...future.FUN’ to environment
[17:01:17.914] - copied ‘MoreArgs’ to environment
[17:01:17.914] - copied ‘...future.elements_ii’ to environment
[17:01:17.914] - copied ‘...future.seeds_ii’ to environment
[17:01:17.914] - copied ‘...future.globals.maxSize’ to environment
[17:01:17.914] assign_globals() ... done
[17:01:17.914] plan(): Setting new future strategy stack:
[17:01:17.915] List of future strategies:
[17:01:17.915] 1. sequential:
[17:01:17.915]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:17.915]    - tweaked: FALSE
[17:01:17.915]    - call: NULL
[17:01:17.915] plan(): nbrOfWorkers() = 1
[17:01:18.417] plan(): Setting new future strategy stack:
[17:01:18.417] List of future strategies:
[17:01:18.417] 1. sequential:
[17:01:18.417]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:18.417]    - tweaked: FALSE
[17:01:18.417]    - call: plan(strategy)
[17:01:18.417] plan(): nbrOfWorkers() = 1
[17:01:18.418] SequentialFuture started (and completed)
[17:01:18.418] - Launch lazy future ... done
[17:01:18.418] run() for ‘SequentialFuture’ ... done
[17:01:18.418] Created future:
[17:01:18.418] SequentialFuture:
[17:01:18.418] Label: ‘future_mapply-1’
[17:01:18.418] Expression:
[17:01:18.418] {
[17:01:18.418]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:18.418]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:18.418]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:18.418]         on.exit(options(oopts), add = TRUE)
[17:01:18.418]     }
[17:01:18.418]     {
[17:01:18.418]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:18.418]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:18.418]         do.call(mapply, args = args)
[17:01:18.418]     }
[17:01:18.418] }
[17:01:18.418] Lazy evaluation: FALSE
[17:01:18.418] Asynchronous evaluation: FALSE
[17:01:18.418] Local evaluation: TRUE
[17:01:18.418] Environment: R_GlobalEnv
[17:01:18.418] Capture standard output: TRUE
[17:01:18.418] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:18.418] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:18.418] Packages: <none>
[17:01:18.418] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:18.418] Resolved: TRUE
[17:01:18.418] Value: 224 bytes of class ‘list’
[17:01:18.418] Early signaling: FALSE
[17:01:18.418] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:18.418] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:18.419] Chunk #1 of 1 ... DONE
[17:01:18.419] Launching 1 futures (chunks) ... DONE
[17:01:18.419] Resolving 1 futures (chunks) ...
[17:01:18.419] resolve() on list ...
[17:01:18.419]  recursive: 0
[17:01:18.420]  length: 1
[17:01:18.420] 
[17:01:18.420] resolved() for ‘SequentialFuture’ ...
[17:01:18.420] - state: ‘finished’
[17:01:18.420] - run: TRUE
[17:01:18.420] - result: ‘FutureResult’
[17:01:18.420] resolved() for ‘SequentialFuture’ ... done
[17:01:18.420] Future #1
[17:01:18.420] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:18.420] - nx: 1
[17:01:18.421] - relay: TRUE
[17:01:18.421] - stdout: TRUE
[17:01:18.421] - signal: TRUE
[17:01:18.421] - resignal: FALSE
[17:01:18.421] - force: TRUE
[17:01:18.421] - relayed: [n=1] FALSE
[17:01:18.421] - queued futures: [n=1] FALSE
[17:01:18.421]  - until=1
[17:01:18.421]  - relaying element #1
[17:01:18.421] - relayed: [n=1] TRUE
[17:01:18.421] - queued futures: [n=1] TRUE
[17:01:18.422] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:18.422]  length: 0 (resolved future 1)
[17:01:18.422] Relaying remaining futures
[17:01:18.422] signalConditionsASAP(NULL, pos=0) ...
[17:01:18.422] - nx: 1
[17:01:18.422] - relay: TRUE
[17:01:18.422] - stdout: TRUE
[17:01:18.422] - signal: TRUE
[17:01:18.422] - resignal: FALSE
[17:01:18.422] - force: TRUE
[17:01:18.422] - relayed: [n=1] TRUE
[17:01:18.422] - queued futures: [n=1] TRUE
 - flush all
[17:01:18.423] - relayed: [n=1] TRUE
[17:01:18.423] - queued futures: [n=1] TRUE
[17:01:18.423] signalConditionsASAP(NULL, pos=0) ... done
[17:01:18.423] resolve() on list ... DONE
[17:01:18.423]  - Number of value chunks collected: 1
[17:01:18.423] Resolving 1 futures (chunks) ... DONE
[17:01:18.423] Reducing values from 1 chunks ...
[17:01:18.423]  - Number of values collected after concatenation: 2
[17:01:18.423]  - Number of values expected: 2
[17:01:18.424] Reducing values from 1 chunks ... DONE
[17:01:18.424] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:01:18.424] future_mapply() ...
[17:01:18.424] Number of chunks: 1
[17:01:18.424] getGlobalsAndPackagesXApply() ...
[17:01:18.424]  - future.globals: TRUE
[17:01:18.424] getGlobalsAndPackages() ...
[17:01:18.425] Searching for globals...
[17:01:18.426] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:18.426] Searching for globals ... DONE
[17:01:18.426] Resolving globals: FALSE
[17:01:18.427] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:18.427] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:18.427] - globals: [1] ‘FUN’
[17:01:18.427] 
[17:01:18.427] getGlobalsAndPackages() ... DONE
[17:01:18.427]  - globals found/used: [n=1] ‘FUN’
[17:01:18.428]  - needed namespaces: [n=0] 
[17:01:18.428] Finding globals ... DONE
[17:01:18.428] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:18.428] List of 2
[17:01:18.428]  $ ...future.FUN:function (x, y)  
[17:01:18.428]  $ MoreArgs     : NULL
[17:01:18.428]  - attr(*, "where")=List of 2
[17:01:18.428]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:18.428]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:18.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:18.428]  - attr(*, "resolved")= logi FALSE
[17:01:18.428]  - attr(*, "total_size")= num NA
[17:01:18.432] Packages to be attached in all futures: [n=0] 
[17:01:18.432] getGlobalsAndPackagesXApply() ... DONE
[17:01:18.432] Number of futures (= number of chunks): 1
[17:01:18.432] Launching 1 futures (chunks) ...
[17:01:18.432] Chunk #1 of 1 ...
[17:01:18.433]  - Finding globals in '...' for chunk #1 ...
[17:01:18.433] getGlobalsAndPackages() ...
[17:01:18.433] Searching for globals...
[17:01:18.433] 
[17:01:18.433] Searching for globals ... DONE
[17:01:18.433] - globals: [0] <none>
[17:01:18.433] getGlobalsAndPackages() ... DONE
[17:01:18.433]    + additional globals found: [n=0] 
[17:01:18.434]    + additional namespaces needed: [n=0] 
[17:01:18.434]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:18.434]  - seeds: <none>
[17:01:18.434]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:18.434] getGlobalsAndPackages() ...
[17:01:18.434] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:18.434] Resolving globals: FALSE
[17:01:18.435] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:01:18.435] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:18.435] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:18.435] 
[17:01:18.435] getGlobalsAndPackages() ... DONE
[17:01:18.436] run() for ‘Future’ ...
[17:01:18.436] - state: ‘created’
[17:01:18.436] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:18.436] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:18.436] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:18.436]   - Field: ‘label’
[17:01:18.436]   - Field: ‘local’
[17:01:18.437]   - Field: ‘owner’
[17:01:18.437]   - Field: ‘envir’
[17:01:18.437]   - Field: ‘packages’
[17:01:18.437]   - Field: ‘gc’
[17:01:18.437]   - Field: ‘conditions’
[17:01:18.437]   - Field: ‘expr’
[17:01:18.437]   - Field: ‘uuid’
[17:01:18.437]   - Field: ‘seed’
[17:01:18.437]   - Field: ‘version’
[17:01:18.437]   - Field: ‘result’
[17:01:18.437]   - Field: ‘asynchronous’
[17:01:18.438]   - Field: ‘calls’
[17:01:18.438]   - Field: ‘globals’
[17:01:18.438]   - Field: ‘stdout’
[17:01:18.438]   - Field: ‘earlySignal’
[17:01:18.438]   - Field: ‘lazy’
[17:01:18.438]   - Field: ‘state’
[17:01:18.438] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:18.438] - Launch lazy future ...
[17:01:18.438] Packages needed by the future expression (n = 0): <none>
[17:01:18.438] Packages needed by future strategies (n = 0): <none>
[17:01:18.439] {
[17:01:18.439]     {
[17:01:18.439]         {
[17:01:18.439]             ...future.startTime <- base::Sys.time()
[17:01:18.439]             {
[17:01:18.439]                 {
[17:01:18.439]                   {
[17:01:18.439]                     base::local({
[17:01:18.439]                       has_future <- base::requireNamespace("future", 
[17:01:18.439]                         quietly = TRUE)
[17:01:18.439]                       if (has_future) {
[17:01:18.439]                         ns <- base::getNamespace("future")
[17:01:18.439]                         version <- ns[[".package"]][["version"]]
[17:01:18.439]                         if (is.null(version)) 
[17:01:18.439]                           version <- utils::packageVersion("future")
[17:01:18.439]                       }
[17:01:18.439]                       else {
[17:01:18.439]                         version <- NULL
[17:01:18.439]                       }
[17:01:18.439]                       if (!has_future || version < "1.8.0") {
[17:01:18.439]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:18.439]                           "", base::R.version$version.string), 
[17:01:18.439]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:18.439]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:18.439]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:18.439]                             "release", "version")], collapse = " "), 
[17:01:18.439]                           hostname = base::Sys.info()[["nodename"]])
[17:01:18.439]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:18.439]                           info)
[17:01:18.439]                         info <- base::paste(info, collapse = "; ")
[17:01:18.439]                         if (!has_future) {
[17:01:18.439]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:18.439]                             info)
[17:01:18.439]                         }
[17:01:18.439]                         else {
[17:01:18.439]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:18.439]                             info, version)
[17:01:18.439]                         }
[17:01:18.439]                         base::stop(msg)
[17:01:18.439]                       }
[17:01:18.439]                     })
[17:01:18.439]                   }
[17:01:18.439]                   ...future.strategy.old <- future::plan("list")
[17:01:18.439]                   options(future.plan = NULL)
[17:01:18.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:18.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:18.439]                 }
[17:01:18.439]                 ...future.workdir <- getwd()
[17:01:18.439]             }
[17:01:18.439]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:18.439]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:18.439]         }
[17:01:18.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:18.439]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:18.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:18.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:18.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:18.439]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:18.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:18.439]             base::names(...future.oldOptions))
[17:01:18.439]     }
[17:01:18.439]     if (TRUE) {
[17:01:18.439]     }
[17:01:18.439]     else {
[17:01:18.439]         if (NA) {
[17:01:18.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:18.439]                 open = "w")
[17:01:18.439]         }
[17:01:18.439]         else {
[17:01:18.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:18.439]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:18.439]         }
[17:01:18.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:18.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:18.439]             base::sink(type = "output", split = FALSE)
[17:01:18.439]             base::close(...future.stdout)
[17:01:18.439]         }, add = TRUE)
[17:01:18.439]     }
[17:01:18.439]     ...future.frame <- base::sys.nframe()
[17:01:18.439]     ...future.conditions <- base::list()
[17:01:18.439]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:18.439]     if (FALSE) {
[17:01:18.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:18.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:18.439]     }
[17:01:18.439]     ...future.result <- base::tryCatch({
[17:01:18.439]         base::withCallingHandlers({
[17:01:18.439]             ...future.value <- base::withVisible(base::local({
[17:01:18.439]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:18.439]                 if (!identical(...future.globals.maxSize.org, 
[17:01:18.439]                   ...future.globals.maxSize)) {
[17:01:18.439]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:18.439]                   on.exit(options(oopts), add = TRUE)
[17:01:18.439]                 }
[17:01:18.439]                 {
[17:01:18.439]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:18.439]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:18.439]                     USE.NAMES = FALSE)
[17:01:18.439]                   do.call(mapply, args = args)
[17:01:18.439]                 }
[17:01:18.439]             }))
[17:01:18.439]             future::FutureResult(value = ...future.value$value, 
[17:01:18.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:18.439]                   ...future.rng), globalenv = if (FALSE) 
[17:01:18.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:18.439]                     ...future.globalenv.names))
[17:01:18.439]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:18.439]         }, condition = base::local({
[17:01:18.439]             c <- base::c
[17:01:18.439]             inherits <- base::inherits
[17:01:18.439]             invokeRestart <- base::invokeRestart
[17:01:18.439]             length <- base::length
[17:01:18.439]             list <- base::list
[17:01:18.439]             seq.int <- base::seq.int
[17:01:18.439]             signalCondition <- base::signalCondition
[17:01:18.439]             sys.calls <- base::sys.calls
[17:01:18.439]             `[[` <- base::`[[`
[17:01:18.439]             `+` <- base::`+`
[17:01:18.439]             `<<-` <- base::`<<-`
[17:01:18.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:18.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:18.439]                   3L)]
[17:01:18.439]             }
[17:01:18.439]             function(cond) {
[17:01:18.439]                 is_error <- inherits(cond, "error")
[17:01:18.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:18.439]                   NULL)
[17:01:18.439]                 if (is_error) {
[17:01:18.439]                   sessionInformation <- function() {
[17:01:18.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:18.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:18.439]                       search = base::search(), system = base::Sys.info())
[17:01:18.439]                   }
[17:01:18.439]                   ...future.conditions[[length(...future.conditions) + 
[17:01:18.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:18.439]                     cond$call), session = sessionInformation(), 
[17:01:18.439]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:18.439]                   signalCondition(cond)
[17:01:18.439]                 }
[17:01:18.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:18.439]                 "immediateCondition"))) {
[17:01:18.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:18.439]                   ...future.conditions[[length(...future.conditions) + 
[17:01:18.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:18.439]                   if (TRUE && !signal) {
[17:01:18.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:18.439]                     {
[17:01:18.439]                       inherits <- base::inherits
[17:01:18.439]                       invokeRestart <- base::invokeRestart
[17:01:18.439]                       is.null <- base::is.null
[17:01:18.439]                       muffled <- FALSE
[17:01:18.439]                       if (inherits(cond, "message")) {
[17:01:18.439]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:18.439]                         if (muffled) 
[17:01:18.439]                           invokeRestart("muffleMessage")
[17:01:18.439]                       }
[17:01:18.439]                       else if (inherits(cond, "warning")) {
[17:01:18.439]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:18.439]                         if (muffled) 
[17:01:18.439]                           invokeRestart("muffleWarning")
[17:01:18.439]                       }
[17:01:18.439]                       else if (inherits(cond, "condition")) {
[17:01:18.439]                         if (!is.null(pattern)) {
[17:01:18.439]                           computeRestarts <- base::computeRestarts
[17:01:18.439]                           grepl <- base::grepl
[17:01:18.439]                           restarts <- computeRestarts(cond)
[17:01:18.439]                           for (restart in restarts) {
[17:01:18.439]                             name <- restart$name
[17:01:18.439]                             if (is.null(name)) 
[17:01:18.439]                               next
[17:01:18.439]                             if (!grepl(pattern, name)) 
[17:01:18.439]                               next
[17:01:18.439]                             invokeRestart(restart)
[17:01:18.439]                             muffled <- TRUE
[17:01:18.439]                             break
[17:01:18.439]                           }
[17:01:18.439]                         }
[17:01:18.439]                       }
[17:01:18.439]                       invisible(muffled)
[17:01:18.439]                     }
[17:01:18.439]                     muffleCondition(cond, pattern = "^muffle")
[17:01:18.439]                   }
[17:01:18.439]                 }
[17:01:18.439]                 else {
[17:01:18.439]                   if (TRUE) {
[17:01:18.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:18.439]                     {
[17:01:18.439]                       inherits <- base::inherits
[17:01:18.439]                       invokeRestart <- base::invokeRestart
[17:01:18.439]                       is.null <- base::is.null
[17:01:18.439]                       muffled <- FALSE
[17:01:18.439]                       if (inherits(cond, "message")) {
[17:01:18.439]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:18.439]                         if (muffled) 
[17:01:18.439]                           invokeRestart("muffleMessage")
[17:01:18.439]                       }
[17:01:18.439]                       else if (inherits(cond, "warning")) {
[17:01:18.439]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:18.439]                         if (muffled) 
[17:01:18.439]                           invokeRestart("muffleWarning")
[17:01:18.439]                       }
[17:01:18.439]                       else if (inherits(cond, "condition")) {
[17:01:18.439]                         if (!is.null(pattern)) {
[17:01:18.439]                           computeRestarts <- base::computeRestarts
[17:01:18.439]                           grepl <- base::grepl
[17:01:18.439]                           restarts <- computeRestarts(cond)
[17:01:18.439]                           for (restart in restarts) {
[17:01:18.439]                             name <- restart$name
[17:01:18.439]                             if (is.null(name)) 
[17:01:18.439]                               next
[17:01:18.439]                             if (!grepl(pattern, name)) 
[17:01:18.439]                               next
[17:01:18.439]                             invokeRestart(restart)
[17:01:18.439]                             muffled <- TRUE
[17:01:18.439]                             break
[17:01:18.439]                           }
[17:01:18.439]                         }
[17:01:18.439]                       }
[17:01:18.439]                       invisible(muffled)
[17:01:18.439]                     }
[17:01:18.439]                     muffleCondition(cond, pattern = "^muffle")
[17:01:18.439]                   }
[17:01:18.439]                 }
[17:01:18.439]             }
[17:01:18.439]         }))
[17:01:18.439]     }, error = function(ex) {
[17:01:18.439]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:18.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:18.439]                 ...future.rng), started = ...future.startTime, 
[17:01:18.439]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:18.439]             version = "1.8"), class = "FutureResult")
[17:01:18.439]     }, finally = {
[17:01:18.439]         if (!identical(...future.workdir, getwd())) 
[17:01:18.439]             setwd(...future.workdir)
[17:01:18.439]         {
[17:01:18.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:18.439]                 ...future.oldOptions$nwarnings <- NULL
[17:01:18.439]             }
[17:01:18.439]             base::options(...future.oldOptions)
[17:01:18.439]             if (.Platform$OS.type == "windows") {
[17:01:18.439]                 old_names <- names(...future.oldEnvVars)
[17:01:18.439]                 envs <- base::Sys.getenv()
[17:01:18.439]                 names <- names(envs)
[17:01:18.439]                 common <- intersect(names, old_names)
[17:01:18.439]                 added <- setdiff(names, old_names)
[17:01:18.439]                 removed <- setdiff(old_names, names)
[17:01:18.439]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:18.439]                   envs[common]]
[17:01:18.439]                 NAMES <- toupper(changed)
[17:01:18.439]                 args <- list()
[17:01:18.439]                 for (kk in seq_along(NAMES)) {
[17:01:18.439]                   name <- changed[[kk]]
[17:01:18.439]                   NAME <- NAMES[[kk]]
[17:01:18.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:18.439]                     next
[17:01:18.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:18.439]                 }
[17:01:18.439]                 NAMES <- toupper(added)
[17:01:18.439]                 for (kk in seq_along(NAMES)) {
[17:01:18.439]                   name <- added[[kk]]
[17:01:18.439]                   NAME <- NAMES[[kk]]
[17:01:18.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:18.439]                     next
[17:01:18.439]                   args[[name]] <- ""
[17:01:18.439]                 }
[17:01:18.439]                 NAMES <- toupper(removed)
[17:01:18.439]                 for (kk in seq_along(NAMES)) {
[17:01:18.439]                   name <- removed[[kk]]
[17:01:18.439]                   NAME <- NAMES[[kk]]
[17:01:18.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:18.439]                     next
[17:01:18.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:18.439]                 }
[17:01:18.439]                 if (length(args) > 0) 
[17:01:18.439]                   base::do.call(base::Sys.setenv, args = args)
[17:01:18.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:18.439]             }
[17:01:18.439]             else {
[17:01:18.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:18.439]             }
[17:01:18.439]             {
[17:01:18.439]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:18.439]                   0L) {
[17:01:18.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:18.439]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:18.439]                   base::options(opts)
[17:01:18.439]                 }
[17:01:18.439]                 {
[17:01:18.439]                   {
[17:01:18.439]                     NULL
[17:01:18.439]                     RNGkind("Mersenne-Twister")
[17:01:18.439]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:18.439]                       inherits = FALSE)
[17:01:18.439]                   }
[17:01:18.439]                   options(future.plan = NULL)
[17:01:18.439]                   if (is.na(NA_character_)) 
[17:01:18.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:18.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:18.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:18.439]                     .init = FALSE)
[17:01:18.439]                 }
[17:01:18.439]             }
[17:01:18.439]         }
[17:01:18.439]     })
[17:01:18.439]     if (FALSE) {
[17:01:18.439]         base::sink(type = "output", split = FALSE)
[17:01:18.439]         if (NA) {
[17:01:18.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:18.439]         }
[17:01:18.439]         else {
[17:01:18.439]             ...future.result["stdout"] <- base::list(NULL)
[17:01:18.439]         }
[17:01:18.439]         base::close(...future.stdout)
[17:01:18.439]         ...future.stdout <- NULL
[17:01:18.439]     }
[17:01:18.439]     ...future.result$conditions <- ...future.conditions
[17:01:18.439]     ...future.result$finished <- base::Sys.time()
[17:01:18.439]     ...future.result
[17:01:18.439] }
[17:01:18.440] assign_globals() ...
[17:01:18.441] List of 5
[17:01:18.441]  $ ...future.FUN            :function (x, y)  
[17:01:18.441]  $ MoreArgs                 : NULL
[17:01:18.441]  $ ...future.elements_ii    :List of 2
[17:01:18.441]   ..$ :List of 2
[17:01:18.441]   .. ..$ : int 1
[17:01:18.441]   .. ..$ : int 0
[17:01:18.441]   ..$ :List of 2
[17:01:18.441]   .. ..$ : int 0
[17:01:18.441]   .. ..$ : int 1
[17:01:18.441]  $ ...future.seeds_ii       : NULL
[17:01:18.441]  $ ...future.globals.maxSize: NULL
[17:01:18.441]  - attr(*, "where")=List of 5
[17:01:18.441]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:18.441]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:18.441]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:18.441]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:18.441]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:18.441]  - attr(*, "resolved")= logi FALSE
[17:01:18.441]  - attr(*, "total_size")= num 6480
[17:01:18.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:18.441]  - attr(*, "already-done")= logi TRUE
[17:01:18.447] - reassign environment for ‘...future.FUN’
[17:01:18.447] - copied ‘...future.FUN’ to environment
[17:01:18.447] - copied ‘MoreArgs’ to environment
[17:01:18.447] - copied ‘...future.elements_ii’ to environment
[17:01:18.447] - copied ‘...future.seeds_ii’ to environment
[17:01:18.447] - copied ‘...future.globals.maxSize’ to environment
[17:01:18.447] assign_globals() ... done
[17:01:18.448] plan(): Setting new future strategy stack:
[17:01:18.448] List of future strategies:
[17:01:18.448] 1. sequential:
[17:01:18.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:18.448]    - tweaked: FALSE
[17:01:18.448]    - call: NULL
[17:01:18.448] plan(): nbrOfWorkers() = 1
[17:01:18.950] plan(): Setting new future strategy stack:
[17:01:18.950] List of future strategies:
[17:01:18.950] 1. sequential:
[17:01:18.950]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:18.950]    - tweaked: FALSE
[17:01:18.950]    - call: plan(strategy)
[17:01:18.950] plan(): nbrOfWorkers() = 1
[17:01:18.951] SequentialFuture started (and completed)
[17:01:18.951] - Launch lazy future ... done
[17:01:18.951] run() for ‘SequentialFuture’ ... done
[17:01:18.951] Created future:
[17:01:18.951] SequentialFuture:
[17:01:18.951] Label: ‘future_mapply-1’
[17:01:18.951] Expression:
[17:01:18.951] {
[17:01:18.951]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:18.951]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:18.951]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:18.951]         on.exit(options(oopts), add = TRUE)
[17:01:18.951]     }
[17:01:18.951]     {
[17:01:18.951]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:18.951]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:18.951]         do.call(mapply, args = args)
[17:01:18.951]     }
[17:01:18.951] }
[17:01:18.951] Lazy evaluation: FALSE
[17:01:18.951] Asynchronous evaluation: FALSE
[17:01:18.951] Local evaluation: TRUE
[17:01:18.951] Environment: R_GlobalEnv
[17:01:18.951] Capture standard output: NA
[17:01:18.951] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:18.951] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:18.951] Packages: <none>
[17:01:18.951] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:18.951] Resolved: TRUE
[17:01:18.951] Value: 224 bytes of class ‘list’
[17:01:18.951] Early signaling: FALSE
[17:01:18.951] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:18.951] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:18.952] Chunk #1 of 1 ... DONE
[17:01:18.952] Launching 1 futures (chunks) ... DONE
[17:01:18.952] Resolving 1 futures (chunks) ...
[17:01:18.952] resolve() on list ...
[17:01:18.952]  recursive: 0
[17:01:18.953]  length: 1
[17:01:18.953] 
[17:01:18.953] resolved() for ‘SequentialFuture’ ...
[17:01:18.953] - state: ‘finished’
[17:01:18.953] - run: TRUE
[17:01:18.953] - result: ‘FutureResult’
[17:01:18.953] resolved() for ‘SequentialFuture’ ... done
[17:01:18.953] Future #1
[17:01:18.953] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:18.953] - nx: 1
[17:01:18.954] - relay: TRUE
[17:01:18.954] - stdout: TRUE
[17:01:18.954] - signal: TRUE
[17:01:18.954] - resignal: FALSE
[17:01:18.954] - force: TRUE
[17:01:18.954] - relayed: [n=1] FALSE
[17:01:18.954] - queued futures: [n=1] FALSE
[17:01:18.954]  - until=1
[17:01:18.954]  - relaying element #1
[17:01:18.954] - relayed: [n=1] TRUE
[17:01:18.954] - queued futures: [n=1] TRUE
[17:01:18.955] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:18.955]  length: 0 (resolved future 1)
[17:01:18.955] Relaying remaining futures
[17:01:18.955] signalConditionsASAP(NULL, pos=0) ...
[17:01:18.955] - nx: 1
[17:01:18.955] - relay: TRUE
[17:01:18.955] - stdout: TRUE
[17:01:18.955] - signal: TRUE
[17:01:18.955] - resignal: FALSE
[17:01:18.955] - force: TRUE
[17:01:18.955] - relayed: [n=1] TRUE
[17:01:18.955] - queued futures: [n=1] TRUE
 - flush all
[17:01:18.956] - relayed: [n=1] TRUE
[17:01:18.956] - queued futures: [n=1] TRUE
[17:01:18.956] signalConditionsASAP(NULL, pos=0) ... done
[17:01:18.956] resolve() on list ... DONE
[17:01:18.956]  - Number of value chunks collected: 1
[17:01:18.956] Resolving 1 futures (chunks) ... DONE
[17:01:18.956] Reducing values from 1 chunks ...
[17:01:18.956]  - Number of values collected after concatenation: 2
[17:01:18.956]  - Number of values expected: 2
[17:01:18.956] Reducing values from 1 chunks ... DONE
[17:01:18.957] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[17:01:18.957] plan(): Setting new future strategy stack:
[17:01:18.957] List of future strategies:
[17:01:18.957] 1. multicore:
[17:01:18.957]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:18.957]    - tweaked: FALSE
[17:01:18.957]    - call: plan(strategy)
[17:01:18.963] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:01:18.963] future_lapply() ...
[17:01:18.967] Number of chunks: 1
[17:01:18.967] getGlobalsAndPackagesXApply() ...
[17:01:18.967]  - future.globals: TRUE
[17:01:18.967] getGlobalsAndPackages() ...
[17:01:18.967] Searching for globals...
[17:01:18.969] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:18.969] Searching for globals ... DONE
[17:01:18.969] Resolving globals: FALSE
[17:01:18.969] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:18.969] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:18.970] - globals: [1] ‘FUN’
[17:01:18.970] 
[17:01:18.970] getGlobalsAndPackages() ... DONE
[17:01:18.970]  - globals found/used: [n=1] ‘FUN’
[17:01:18.970]  - needed namespaces: [n=0] 
[17:01:18.970] Finding globals ... DONE
[17:01:18.970]  - use_args: TRUE
[17:01:18.970]  - Getting '...' globals ...
[17:01:18.971] resolve() on list ...
[17:01:18.971]  recursive: 0
[17:01:18.971]  length: 1
[17:01:18.971]  elements: ‘...’
[17:01:18.971]  length: 0 (resolved future 1)
[17:01:18.971] resolve() on list ... DONE
[17:01:18.971]    - '...' content: [n=0] 
[17:01:18.971] List of 1
[17:01:18.971]  $ ...: list()
[17:01:18.971]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:18.971]  - attr(*, "where")=List of 1
[17:01:18.971]   ..$ ...:<environment: 0x5636f6013b18> 
[17:01:18.971]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:18.971]  - attr(*, "resolved")= logi TRUE
[17:01:18.971]  - attr(*, "total_size")= num NA
[17:01:18.974]  - Getting '...' globals ... DONE
[17:01:18.974] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:18.974] List of 2
[17:01:18.974]  $ ...future.FUN:function (x)  
[17:01:18.974]  $ ...          : list()
[17:01:18.974]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:18.974]  - attr(*, "where")=List of 2
[17:01:18.974]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:18.974]   ..$ ...          :<environment: 0x5636f6013b18> 
[17:01:18.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:18.974]  - attr(*, "resolved")= logi FALSE
[17:01:18.974]  - attr(*, "total_size")= num 4720
[17:01:18.977] Packages to be attached in all futures: [n=0] 
[17:01:18.977] getGlobalsAndPackagesXApply() ... DONE
[17:01:18.977] Number of futures (= number of chunks): 1
[17:01:18.977] Launching 1 futures (chunks) ...
[17:01:18.977] Chunk #1 of 1 ...
[17:01:18.977]  - Finding globals in 'X' for chunk #1 ...
[17:01:18.977] getGlobalsAndPackages() ...
[17:01:18.977] Searching for globals...
[17:01:18.978] 
[17:01:18.978] Searching for globals ... DONE
[17:01:18.978] - globals: [0] <none>
[17:01:18.978] getGlobalsAndPackages() ... DONE
[17:01:18.978]    + additional globals found: [n=0] 
[17:01:18.978]    + additional namespaces needed: [n=0] 
[17:01:18.978]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:18.978]  - seeds: <none>
[17:01:18.978]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:18.979] getGlobalsAndPackages() ...
[17:01:18.979] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:18.979] Resolving globals: FALSE
[17:01:18.979] Tweak future expression to call with '...' arguments ...
[17:01:18.979] {
[17:01:18.979]     do.call(function(...) {
[17:01:18.979]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:18.979]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:18.979]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:18.979]             on.exit(options(oopts), add = TRUE)
[17:01:18.979]         }
[17:01:18.979]         {
[17:01:18.979]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:18.979]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:18.979]                 ...future.FUN(...future.X_jj, ...)
[17:01:18.979]             })
[17:01:18.979]         }
[17:01:18.979]     }, args = future.call.arguments)
[17:01:18.979] }
[17:01:18.979] Tweak future expression to call with '...' arguments ... DONE
[17:01:18.980] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:18.980] 
[17:01:18.980] getGlobalsAndPackages() ... DONE
[17:01:18.980] run() for ‘Future’ ...
[17:01:18.980] - state: ‘created’
[17:01:18.980] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:18.984] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:18.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:18.984]   - Field: ‘label’
[17:01:18.984]   - Field: ‘local’
[17:01:18.984]   - Field: ‘owner’
[17:01:18.984]   - Field: ‘envir’
[17:01:18.984]   - Field: ‘packages’
[17:01:18.984]   - Field: ‘gc’
[17:01:18.985]   - Field: ‘conditions’
[17:01:18.985]   - Field: ‘expr’
[17:01:18.985]   - Field: ‘uuid’
[17:01:18.985]   - Field: ‘seed’
[17:01:18.985]   - Field: ‘version’
[17:01:18.985]   - Field: ‘result’
[17:01:18.985]   - Field: ‘asynchronous’
[17:01:18.985]   - Field: ‘calls’
[17:01:18.985]   - Field: ‘globals’
[17:01:18.985]   - Field: ‘stdout’
[17:01:18.985]   - Field: ‘earlySignal’
[17:01:18.985]   - Field: ‘lazy’
[17:01:18.986]   - Field: ‘state’
[17:01:18.986] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:18.986] - Launch lazy future ...
[17:01:18.986] Packages needed by the future expression (n = 0): <none>
[17:01:18.986] Packages needed by future strategies (n = 0): <none>
[17:01:18.987] {
[17:01:18.987]     {
[17:01:18.987]         {
[17:01:18.987]             ...future.startTime <- base::Sys.time()
[17:01:18.987]             {
[17:01:18.987]                 {
[17:01:18.987]                   {
[17:01:18.987]                     base::local({
[17:01:18.987]                       has_future <- base::requireNamespace("future", 
[17:01:18.987]                         quietly = TRUE)
[17:01:18.987]                       if (has_future) {
[17:01:18.987]                         ns <- base::getNamespace("future")
[17:01:18.987]                         version <- ns[[".package"]][["version"]]
[17:01:18.987]                         if (is.null(version)) 
[17:01:18.987]                           version <- utils::packageVersion("future")
[17:01:18.987]                       }
[17:01:18.987]                       else {
[17:01:18.987]                         version <- NULL
[17:01:18.987]                       }
[17:01:18.987]                       if (!has_future || version < "1.8.0") {
[17:01:18.987]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:18.987]                           "", base::R.version$version.string), 
[17:01:18.987]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:18.987]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:18.987]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:18.987]                             "release", "version")], collapse = " "), 
[17:01:18.987]                           hostname = base::Sys.info()[["nodename"]])
[17:01:18.987]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:18.987]                           info)
[17:01:18.987]                         info <- base::paste(info, collapse = "; ")
[17:01:18.987]                         if (!has_future) {
[17:01:18.987]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:18.987]                             info)
[17:01:18.987]                         }
[17:01:18.987]                         else {
[17:01:18.987]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:18.987]                             info, version)
[17:01:18.987]                         }
[17:01:18.987]                         base::stop(msg)
[17:01:18.987]                       }
[17:01:18.987]                     })
[17:01:18.987]                   }
[17:01:18.987]                   ...future.strategy.old <- future::plan("list")
[17:01:18.987]                   options(future.plan = NULL)
[17:01:18.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:18.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:18.987]                 }
[17:01:18.987]                 ...future.workdir <- getwd()
[17:01:18.987]             }
[17:01:18.987]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:18.987]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:18.987]         }
[17:01:18.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:18.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:18.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:18.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:18.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:18.987]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:18.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:18.987]             base::names(...future.oldOptions))
[17:01:18.987]     }
[17:01:18.987]     if (FALSE) {
[17:01:18.987]     }
[17:01:18.987]     else {
[17:01:18.987]         if (FALSE) {
[17:01:18.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:18.987]                 open = "w")
[17:01:18.987]         }
[17:01:18.987]         else {
[17:01:18.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:18.987]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:18.987]         }
[17:01:18.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:18.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:18.987]             base::sink(type = "output", split = FALSE)
[17:01:18.987]             base::close(...future.stdout)
[17:01:18.987]         }, add = TRUE)
[17:01:18.987]     }
[17:01:18.987]     ...future.frame <- base::sys.nframe()
[17:01:18.987]     ...future.conditions <- base::list()
[17:01:18.987]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:18.987]     if (FALSE) {
[17:01:18.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:18.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:18.987]     }
[17:01:18.987]     ...future.result <- base::tryCatch({
[17:01:18.987]         base::withCallingHandlers({
[17:01:18.987]             ...future.value <- base::withVisible(base::local({
[17:01:18.987]                 do.call(function(...) {
[17:01:18.987]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:18.987]                   if (!identical(...future.globals.maxSize.org, 
[17:01:18.987]                     ...future.globals.maxSize)) {
[17:01:18.987]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:18.987]                     on.exit(options(oopts), add = TRUE)
[17:01:18.987]                   }
[17:01:18.987]                   {
[17:01:18.987]                     lapply(seq_along(...future.elements_ii), 
[17:01:18.987]                       FUN = function(jj) {
[17:01:18.987]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:18.987]                         ...future.FUN(...future.X_jj, ...)
[17:01:18.987]                       })
[17:01:18.987]                   }
[17:01:18.987]                 }, args = future.call.arguments)
[17:01:18.987]             }))
[17:01:18.987]             future::FutureResult(value = ...future.value$value, 
[17:01:18.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:18.987]                   ...future.rng), globalenv = if (FALSE) 
[17:01:18.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:18.987]                     ...future.globalenv.names))
[17:01:18.987]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:18.987]         }, condition = base::local({
[17:01:18.987]             c <- base::c
[17:01:18.987]             inherits <- base::inherits
[17:01:18.987]             invokeRestart <- base::invokeRestart
[17:01:18.987]             length <- base::length
[17:01:18.987]             list <- base::list
[17:01:18.987]             seq.int <- base::seq.int
[17:01:18.987]             signalCondition <- base::signalCondition
[17:01:18.987]             sys.calls <- base::sys.calls
[17:01:18.987]             `[[` <- base::`[[`
[17:01:18.987]             `+` <- base::`+`
[17:01:18.987]             `<<-` <- base::`<<-`
[17:01:18.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:18.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:18.987]                   3L)]
[17:01:18.987]             }
[17:01:18.987]             function(cond) {
[17:01:18.987]                 is_error <- inherits(cond, "error")
[17:01:18.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:18.987]                   NULL)
[17:01:18.987]                 if (is_error) {
[17:01:18.987]                   sessionInformation <- function() {
[17:01:18.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:18.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:18.987]                       search = base::search(), system = base::Sys.info())
[17:01:18.987]                   }
[17:01:18.987]                   ...future.conditions[[length(...future.conditions) + 
[17:01:18.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:18.987]                     cond$call), session = sessionInformation(), 
[17:01:18.987]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:18.987]                   signalCondition(cond)
[17:01:18.987]                 }
[17:01:18.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:18.987]                 "immediateCondition"))) {
[17:01:18.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:18.987]                   ...future.conditions[[length(...future.conditions) + 
[17:01:18.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:18.987]                   if (TRUE && !signal) {
[17:01:18.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:18.987]                     {
[17:01:18.987]                       inherits <- base::inherits
[17:01:18.987]                       invokeRestart <- base::invokeRestart
[17:01:18.987]                       is.null <- base::is.null
[17:01:18.987]                       muffled <- FALSE
[17:01:18.987]                       if (inherits(cond, "message")) {
[17:01:18.987]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:18.987]                         if (muffled) 
[17:01:18.987]                           invokeRestart("muffleMessage")
[17:01:18.987]                       }
[17:01:18.987]                       else if (inherits(cond, "warning")) {
[17:01:18.987]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:18.987]                         if (muffled) 
[17:01:18.987]                           invokeRestart("muffleWarning")
[17:01:18.987]                       }
[17:01:18.987]                       else if (inherits(cond, "condition")) {
[17:01:18.987]                         if (!is.null(pattern)) {
[17:01:18.987]                           computeRestarts <- base::computeRestarts
[17:01:18.987]                           grepl <- base::grepl
[17:01:18.987]                           restarts <- computeRestarts(cond)
[17:01:18.987]                           for (restart in restarts) {
[17:01:18.987]                             name <- restart$name
[17:01:18.987]                             if (is.null(name)) 
[17:01:18.987]                               next
[17:01:18.987]                             if (!grepl(pattern, name)) 
[17:01:18.987]                               next
[17:01:18.987]                             invokeRestart(restart)
[17:01:18.987]                             muffled <- TRUE
[17:01:18.987]                             break
[17:01:18.987]                           }
[17:01:18.987]                         }
[17:01:18.987]                       }
[17:01:18.987]                       invisible(muffled)
[17:01:18.987]                     }
[17:01:18.987]                     muffleCondition(cond, pattern = "^muffle")
[17:01:18.987]                   }
[17:01:18.987]                 }
[17:01:18.987]                 else {
[17:01:18.987]                   if (TRUE) {
[17:01:18.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:18.987]                     {
[17:01:18.987]                       inherits <- base::inherits
[17:01:18.987]                       invokeRestart <- base::invokeRestart
[17:01:18.987]                       is.null <- base::is.null
[17:01:18.987]                       muffled <- FALSE
[17:01:18.987]                       if (inherits(cond, "message")) {
[17:01:18.987]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:18.987]                         if (muffled) 
[17:01:18.987]                           invokeRestart("muffleMessage")
[17:01:18.987]                       }
[17:01:18.987]                       else if (inherits(cond, "warning")) {
[17:01:18.987]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:18.987]                         if (muffled) 
[17:01:18.987]                           invokeRestart("muffleWarning")
[17:01:18.987]                       }
[17:01:18.987]                       else if (inherits(cond, "condition")) {
[17:01:18.987]                         if (!is.null(pattern)) {
[17:01:18.987]                           computeRestarts <- base::computeRestarts
[17:01:18.987]                           grepl <- base::grepl
[17:01:18.987]                           restarts <- computeRestarts(cond)
[17:01:18.987]                           for (restart in restarts) {
[17:01:18.987]                             name <- restart$name
[17:01:18.987]                             if (is.null(name)) 
[17:01:18.987]                               next
[17:01:18.987]                             if (!grepl(pattern, name)) 
[17:01:18.987]                               next
[17:01:18.987]                             invokeRestart(restart)
[17:01:18.987]                             muffled <- TRUE
[17:01:18.987]                             break
[17:01:18.987]                           }
[17:01:18.987]                         }
[17:01:18.987]                       }
[17:01:18.987]                       invisible(muffled)
[17:01:18.987]                     }
[17:01:18.987]                     muffleCondition(cond, pattern = "^muffle")
[17:01:18.987]                   }
[17:01:18.987]                 }
[17:01:18.987]             }
[17:01:18.987]         }))
[17:01:18.987]     }, error = function(ex) {
[17:01:18.987]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:18.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:18.987]                 ...future.rng), started = ...future.startTime, 
[17:01:18.987]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:18.987]             version = "1.8"), class = "FutureResult")
[17:01:18.987]     }, finally = {
[17:01:18.987]         if (!identical(...future.workdir, getwd())) 
[17:01:18.987]             setwd(...future.workdir)
[17:01:18.987]         {
[17:01:18.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:18.987]                 ...future.oldOptions$nwarnings <- NULL
[17:01:18.987]             }
[17:01:18.987]             base::options(...future.oldOptions)
[17:01:18.987]             if (.Platform$OS.type == "windows") {
[17:01:18.987]                 old_names <- names(...future.oldEnvVars)
[17:01:18.987]                 envs <- base::Sys.getenv()
[17:01:18.987]                 names <- names(envs)
[17:01:18.987]                 common <- intersect(names, old_names)
[17:01:18.987]                 added <- setdiff(names, old_names)
[17:01:18.987]                 removed <- setdiff(old_names, names)
[17:01:18.987]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:18.987]                   envs[common]]
[17:01:18.987]                 NAMES <- toupper(changed)
[17:01:18.987]                 args <- list()
[17:01:18.987]                 for (kk in seq_along(NAMES)) {
[17:01:18.987]                   name <- changed[[kk]]
[17:01:18.987]                   NAME <- NAMES[[kk]]
[17:01:18.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:18.987]                     next
[17:01:18.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:18.987]                 }
[17:01:18.987]                 NAMES <- toupper(added)
[17:01:18.987]                 for (kk in seq_along(NAMES)) {
[17:01:18.987]                   name <- added[[kk]]
[17:01:18.987]                   NAME <- NAMES[[kk]]
[17:01:18.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:18.987]                     next
[17:01:18.987]                   args[[name]] <- ""
[17:01:18.987]                 }
[17:01:18.987]                 NAMES <- toupper(removed)
[17:01:18.987]                 for (kk in seq_along(NAMES)) {
[17:01:18.987]                   name <- removed[[kk]]
[17:01:18.987]                   NAME <- NAMES[[kk]]
[17:01:18.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:18.987]                     next
[17:01:18.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:18.987]                 }
[17:01:18.987]                 if (length(args) > 0) 
[17:01:18.987]                   base::do.call(base::Sys.setenv, args = args)
[17:01:18.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:18.987]             }
[17:01:18.987]             else {
[17:01:18.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:18.987]             }
[17:01:18.987]             {
[17:01:18.987]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:18.987]                   0L) {
[17:01:18.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:18.987]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:18.987]                   base::options(opts)
[17:01:18.987]                 }
[17:01:18.987]                 {
[17:01:18.987]                   {
[17:01:18.987]                     NULL
[17:01:18.987]                     RNGkind("Mersenne-Twister")
[17:01:18.987]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:18.987]                       inherits = FALSE)
[17:01:18.987]                   }
[17:01:18.987]                   options(future.plan = NULL)
[17:01:18.987]                   if (is.na(NA_character_)) 
[17:01:18.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:18.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:18.987]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:18.987]                     .init = FALSE)
[17:01:18.987]                 }
[17:01:18.987]             }
[17:01:18.987]         }
[17:01:18.987]     })
[17:01:18.987]     if (TRUE) {
[17:01:18.987]         base::sink(type = "output", split = FALSE)
[17:01:18.987]         if (FALSE) {
[17:01:18.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:18.987]         }
[17:01:18.987]         else {
[17:01:18.987]             ...future.result["stdout"] <- base::list(NULL)
[17:01:18.987]         }
[17:01:18.987]         base::close(...future.stdout)
[17:01:18.987]         ...future.stdout <- NULL
[17:01:18.987]     }
[17:01:18.987]     ...future.result$conditions <- ...future.conditions
[17:01:18.987]     ...future.result$finished <- base::Sys.time()
[17:01:18.987]     ...future.result
[17:01:18.987] }
[17:01:18.988] assign_globals() ...
[17:01:18.988] List of 5
[17:01:18.988]  $ ...future.FUN            :function (x)  
[17:01:18.988]  $ future.call.arguments    : list()
[17:01:18.988]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:18.988]  $ ...future.elements_ii    :List of 2
[17:01:18.988]   ..$ : int 1
[17:01:18.988]   ..$ : int 0
[17:01:18.988]  $ ...future.seeds_ii       : NULL
[17:01:18.988]  $ ...future.globals.maxSize: NULL
[17:01:18.988]  - attr(*, "where")=List of 5
[17:01:18.988]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:18.988]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:18.988]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:18.988]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:18.988]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:18.988]  - attr(*, "resolved")= logi FALSE
[17:01:18.988]  - attr(*, "total_size")= num 4720
[17:01:18.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:18.988]  - attr(*, "already-done")= logi TRUE
[17:01:18.995] - reassign environment for ‘...future.FUN’
[17:01:18.995] - copied ‘...future.FUN’ to environment
[17:01:18.995] - copied ‘future.call.arguments’ to environment
[17:01:18.995] - copied ‘...future.elements_ii’ to environment
[17:01:18.995] - copied ‘...future.seeds_ii’ to environment
[17:01:18.995] - copied ‘...future.globals.maxSize’ to environment
[17:01:18.995] assign_globals() ... done
[17:01:18.996] plan(): Setting new future strategy stack:
[17:01:18.996] List of future strategies:
[17:01:18.996] 1. sequential:
[17:01:18.996]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:18.996]    - tweaked: FALSE
[17:01:18.996]    - call: NULL
[17:01:18.996] plan(): nbrOfWorkers() = 1
[17:01:19.498] plan(): Setting new future strategy stack:
[17:01:19.498] List of future strategies:
[17:01:19.498] 1. multicore:
[17:01:19.498]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:19.498]    - tweaked: FALSE
[17:01:19.498]    - call: plan(strategy)
[17:01:19.502] plan(): nbrOfWorkers() = 1
[17:01:19.502] SequentialFuture started (and completed)
[17:01:19.502] - Launch lazy future ... done
[17:01:19.502] run() for ‘SequentialFuture’ ... done
[17:01:19.502] Created future:
[17:01:19.503] SequentialFuture:
[17:01:19.503] Label: ‘future_lapply-1’
[17:01:19.503] Expression:
[17:01:19.503] {
[17:01:19.503]     do.call(function(...) {
[17:01:19.503]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:19.503]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:19.503]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:19.503]             on.exit(options(oopts), add = TRUE)
[17:01:19.503]         }
[17:01:19.503]         {
[17:01:19.503]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:19.503]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:19.503]                 ...future.FUN(...future.X_jj, ...)
[17:01:19.503]             })
[17:01:19.503]         }
[17:01:19.503]     }, args = future.call.arguments)
[17:01:19.503] }
[17:01:19.503] Lazy evaluation: FALSE
[17:01:19.503] Asynchronous evaluation: FALSE
[17:01:19.503] Local evaluation: TRUE
[17:01:19.503] Environment: R_GlobalEnv
[17:01:19.503] Capture standard output: FALSE
[17:01:19.503] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:19.503] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:19.503] Packages: <none>
[17:01:19.503] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:19.503] Resolved: TRUE
[17:01:19.503] Value: 112 bytes of class ‘list’
[17:01:19.503] Early signaling: FALSE
[17:01:19.503] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:19.503] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:19.504] Chunk #1 of 1 ... DONE
[17:01:19.504] Launching 1 futures (chunks) ... DONE
[17:01:19.504] Resolving 1 futures (chunks) ...
[17:01:19.504] resolve() on list ...
[17:01:19.504]  recursive: 0
[17:01:19.504]  length: 1
[17:01:19.504] 
[17:01:19.504] resolved() for ‘SequentialFuture’ ...
[17:01:19.504] - state: ‘finished’
[17:01:19.505] - run: TRUE
[17:01:19.505] - result: ‘FutureResult’
[17:01:19.505] resolved() for ‘SequentialFuture’ ... done
[17:01:19.505] Future #1
[17:01:19.505] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:19.505] - nx: 1
[17:01:19.505] - relay: TRUE
[17:01:19.505] - stdout: TRUE
[17:01:19.505] - signal: TRUE
[17:01:19.505] - resignal: FALSE
[17:01:19.505] - force: TRUE
[17:01:19.506] - relayed: [n=1] FALSE
[17:01:19.506] - queued futures: [n=1] FALSE
[17:01:19.506]  - until=1
[17:01:19.506]  - relaying element #1
[17:01:19.506] - relayed: [n=1] TRUE
[17:01:19.506] - queued futures: [n=1] TRUE
[17:01:19.506] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:19.506]  length: 0 (resolved future 1)
[17:01:19.506] Relaying remaining futures
[17:01:19.506] signalConditionsASAP(NULL, pos=0) ...
[17:01:19.507] - nx: 1
[17:01:19.507] - relay: TRUE
[17:01:19.507] - stdout: TRUE
[17:01:19.507] - signal: TRUE
[17:01:19.507] - resignal: FALSE
[17:01:19.507] - force: TRUE
[17:01:19.507] - relayed: [n=1] TRUE
[17:01:19.507] - queued futures: [n=1] TRUE
 - flush all
[17:01:19.507] - relayed: [n=1] TRUE
[17:01:19.507] - queued futures: [n=1] TRUE
[17:01:19.507] signalConditionsASAP(NULL, pos=0) ... done
[17:01:19.508] resolve() on list ... DONE
[17:01:19.508]  - Number of value chunks collected: 1
[17:01:19.508] Resolving 1 futures (chunks) ... DONE
[17:01:19.508] Reducing values from 1 chunks ...
[17:01:19.508]  - Number of values collected after concatenation: 2
[17:01:19.508]  - Number of values expected: 2
[17:01:19.508] Reducing values from 1 chunks ... DONE
[17:01:19.508] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:01:19.509] future_lapply() ...
[17:01:19.512] Number of chunks: 1
[17:01:19.513] getGlobalsAndPackagesXApply() ...
[17:01:19.513]  - future.globals: TRUE
[17:01:19.513] getGlobalsAndPackages() ...
[17:01:19.513] Searching for globals...
[17:01:19.514] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:19.514] Searching for globals ... DONE
[17:01:19.514] Resolving globals: FALSE
[17:01:19.515] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:19.515] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:19.515] - globals: [1] ‘FUN’
[17:01:19.515] 
[17:01:19.515] getGlobalsAndPackages() ... DONE
[17:01:19.516]  - globals found/used: [n=1] ‘FUN’
[17:01:19.516]  - needed namespaces: [n=0] 
[17:01:19.516] Finding globals ... DONE
[17:01:19.516]  - use_args: TRUE
[17:01:19.516]  - Getting '...' globals ...
[17:01:19.516] resolve() on list ...
[17:01:19.516]  recursive: 0
[17:01:19.516]  length: 1
[17:01:19.517]  elements: ‘...’
[17:01:19.517]  length: 0 (resolved future 1)
[17:01:19.517] resolve() on list ... DONE
[17:01:19.517]    - '...' content: [n=0] 
[17:01:19.517] List of 1
[17:01:19.517]  $ ...: list()
[17:01:19.517]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:19.517]  - attr(*, "where")=List of 1
[17:01:19.517]   ..$ ...:<environment: 0x5636f6454730> 
[17:01:19.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:19.517]  - attr(*, "resolved")= logi TRUE
[17:01:19.517]  - attr(*, "total_size")= num NA
[17:01:19.520]  - Getting '...' globals ... DONE
[17:01:19.520] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:19.520] List of 2
[17:01:19.520]  $ ...future.FUN:function (x)  
[17:01:19.520]  $ ...          : list()
[17:01:19.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:19.520]  - attr(*, "where")=List of 2
[17:01:19.520]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:19.520]   ..$ ...          :<environment: 0x5636f6454730> 
[17:01:19.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:19.520]  - attr(*, "resolved")= logi FALSE
[17:01:19.520]  - attr(*, "total_size")= num 4720
[17:01:19.524] Packages to be attached in all futures: [n=0] 
[17:01:19.524] getGlobalsAndPackagesXApply() ... DONE
[17:01:19.524] Number of futures (= number of chunks): 1
[17:01:19.525] Launching 1 futures (chunks) ...
[17:01:19.525] Chunk #1 of 1 ...
[17:01:19.525]  - Finding globals in 'X' for chunk #1 ...
[17:01:19.525] getGlobalsAndPackages() ...
[17:01:19.525] Searching for globals...
[17:01:19.525] 
[17:01:19.525] Searching for globals ... DONE
[17:01:19.525] - globals: [0] <none>
[17:01:19.525] getGlobalsAndPackages() ... DONE
[17:01:19.526]    + additional globals found: [n=0] 
[17:01:19.526]    + additional namespaces needed: [n=0] 
[17:01:19.526]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:19.526]  - seeds: <none>
[17:01:19.526]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:19.526] getGlobalsAndPackages() ...
[17:01:19.526] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:19.526] Resolving globals: FALSE
[17:01:19.526] Tweak future expression to call with '...' arguments ...
[17:01:19.526] {
[17:01:19.526]     do.call(function(...) {
[17:01:19.526]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:19.526]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:19.526]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:19.526]             on.exit(options(oopts), add = TRUE)
[17:01:19.526]         }
[17:01:19.526]         {
[17:01:19.526]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:19.526]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:19.526]                 ...future.FUN(...future.X_jj, ...)
[17:01:19.526]             })
[17:01:19.526]         }
[17:01:19.526]     }, args = future.call.arguments)
[17:01:19.526] }
[17:01:19.527] Tweak future expression to call with '...' arguments ... DONE
[17:01:19.527] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:19.527] 
[17:01:19.527] getGlobalsAndPackages() ... DONE
[17:01:19.528] run() for ‘Future’ ...
[17:01:19.528] - state: ‘created’
[17:01:19.528] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:19.531] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:19.531] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:19.532]   - Field: ‘label’
[17:01:19.532]   - Field: ‘local’
[17:01:19.532]   - Field: ‘owner’
[17:01:19.532]   - Field: ‘envir’
[17:01:19.532]   - Field: ‘packages’
[17:01:19.532]   - Field: ‘gc’
[17:01:19.532]   - Field: ‘conditions’
[17:01:19.532]   - Field: ‘expr’
[17:01:19.532]   - Field: ‘uuid’
[17:01:19.532]   - Field: ‘seed’
[17:01:19.533]   - Field: ‘version’
[17:01:19.533]   - Field: ‘result’
[17:01:19.533]   - Field: ‘asynchronous’
[17:01:19.533]   - Field: ‘calls’
[17:01:19.533]   - Field: ‘globals’
[17:01:19.533]   - Field: ‘stdout’
[17:01:19.533]   - Field: ‘earlySignal’
[17:01:19.533]   - Field: ‘lazy’
[17:01:19.533]   - Field: ‘state’
[17:01:19.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:19.533] - Launch lazy future ...
[17:01:19.534] Packages needed by the future expression (n = 0): <none>
[17:01:19.534] Packages needed by future strategies (n = 0): <none>
[17:01:19.534] {
[17:01:19.534]     {
[17:01:19.534]         {
[17:01:19.534]             ...future.startTime <- base::Sys.time()
[17:01:19.534]             {
[17:01:19.534]                 {
[17:01:19.534]                   {
[17:01:19.534]                     base::local({
[17:01:19.534]                       has_future <- base::requireNamespace("future", 
[17:01:19.534]                         quietly = TRUE)
[17:01:19.534]                       if (has_future) {
[17:01:19.534]                         ns <- base::getNamespace("future")
[17:01:19.534]                         version <- ns[[".package"]][["version"]]
[17:01:19.534]                         if (is.null(version)) 
[17:01:19.534]                           version <- utils::packageVersion("future")
[17:01:19.534]                       }
[17:01:19.534]                       else {
[17:01:19.534]                         version <- NULL
[17:01:19.534]                       }
[17:01:19.534]                       if (!has_future || version < "1.8.0") {
[17:01:19.534]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:19.534]                           "", base::R.version$version.string), 
[17:01:19.534]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:19.534]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:19.534]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:19.534]                             "release", "version")], collapse = " "), 
[17:01:19.534]                           hostname = base::Sys.info()[["nodename"]])
[17:01:19.534]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:19.534]                           info)
[17:01:19.534]                         info <- base::paste(info, collapse = "; ")
[17:01:19.534]                         if (!has_future) {
[17:01:19.534]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:19.534]                             info)
[17:01:19.534]                         }
[17:01:19.534]                         else {
[17:01:19.534]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:19.534]                             info, version)
[17:01:19.534]                         }
[17:01:19.534]                         base::stop(msg)
[17:01:19.534]                       }
[17:01:19.534]                     })
[17:01:19.534]                   }
[17:01:19.534]                   ...future.strategy.old <- future::plan("list")
[17:01:19.534]                   options(future.plan = NULL)
[17:01:19.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:19.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:19.534]                 }
[17:01:19.534]                 ...future.workdir <- getwd()
[17:01:19.534]             }
[17:01:19.534]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:19.534]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:19.534]         }
[17:01:19.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:19.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:19.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:19.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:19.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:19.534]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:19.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:19.534]             base::names(...future.oldOptions))
[17:01:19.534]     }
[17:01:19.534]     if (FALSE) {
[17:01:19.534]     }
[17:01:19.534]     else {
[17:01:19.534]         if (TRUE) {
[17:01:19.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:19.534]                 open = "w")
[17:01:19.534]         }
[17:01:19.534]         else {
[17:01:19.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:19.534]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:19.534]         }
[17:01:19.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:19.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:19.534]             base::sink(type = "output", split = FALSE)
[17:01:19.534]             base::close(...future.stdout)
[17:01:19.534]         }, add = TRUE)
[17:01:19.534]     }
[17:01:19.534]     ...future.frame <- base::sys.nframe()
[17:01:19.534]     ...future.conditions <- base::list()
[17:01:19.534]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:19.534]     if (FALSE) {
[17:01:19.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:19.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:19.534]     }
[17:01:19.534]     ...future.result <- base::tryCatch({
[17:01:19.534]         base::withCallingHandlers({
[17:01:19.534]             ...future.value <- base::withVisible(base::local({
[17:01:19.534]                 do.call(function(...) {
[17:01:19.534]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:19.534]                   if (!identical(...future.globals.maxSize.org, 
[17:01:19.534]                     ...future.globals.maxSize)) {
[17:01:19.534]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:19.534]                     on.exit(options(oopts), add = TRUE)
[17:01:19.534]                   }
[17:01:19.534]                   {
[17:01:19.534]                     lapply(seq_along(...future.elements_ii), 
[17:01:19.534]                       FUN = function(jj) {
[17:01:19.534]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:19.534]                         ...future.FUN(...future.X_jj, ...)
[17:01:19.534]                       })
[17:01:19.534]                   }
[17:01:19.534]                 }, args = future.call.arguments)
[17:01:19.534]             }))
[17:01:19.534]             future::FutureResult(value = ...future.value$value, 
[17:01:19.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:19.534]                   ...future.rng), globalenv = if (FALSE) 
[17:01:19.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:19.534]                     ...future.globalenv.names))
[17:01:19.534]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:19.534]         }, condition = base::local({
[17:01:19.534]             c <- base::c
[17:01:19.534]             inherits <- base::inherits
[17:01:19.534]             invokeRestart <- base::invokeRestart
[17:01:19.534]             length <- base::length
[17:01:19.534]             list <- base::list
[17:01:19.534]             seq.int <- base::seq.int
[17:01:19.534]             signalCondition <- base::signalCondition
[17:01:19.534]             sys.calls <- base::sys.calls
[17:01:19.534]             `[[` <- base::`[[`
[17:01:19.534]             `+` <- base::`+`
[17:01:19.534]             `<<-` <- base::`<<-`
[17:01:19.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:19.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:19.534]                   3L)]
[17:01:19.534]             }
[17:01:19.534]             function(cond) {
[17:01:19.534]                 is_error <- inherits(cond, "error")
[17:01:19.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:19.534]                   NULL)
[17:01:19.534]                 if (is_error) {
[17:01:19.534]                   sessionInformation <- function() {
[17:01:19.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:19.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:19.534]                       search = base::search(), system = base::Sys.info())
[17:01:19.534]                   }
[17:01:19.534]                   ...future.conditions[[length(...future.conditions) + 
[17:01:19.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:19.534]                     cond$call), session = sessionInformation(), 
[17:01:19.534]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:19.534]                   signalCondition(cond)
[17:01:19.534]                 }
[17:01:19.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:19.534]                 "immediateCondition"))) {
[17:01:19.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:19.534]                   ...future.conditions[[length(...future.conditions) + 
[17:01:19.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:19.534]                   if (TRUE && !signal) {
[17:01:19.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:19.534]                     {
[17:01:19.534]                       inherits <- base::inherits
[17:01:19.534]                       invokeRestart <- base::invokeRestart
[17:01:19.534]                       is.null <- base::is.null
[17:01:19.534]                       muffled <- FALSE
[17:01:19.534]                       if (inherits(cond, "message")) {
[17:01:19.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:19.534]                         if (muffled) 
[17:01:19.534]                           invokeRestart("muffleMessage")
[17:01:19.534]                       }
[17:01:19.534]                       else if (inherits(cond, "warning")) {
[17:01:19.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:19.534]                         if (muffled) 
[17:01:19.534]                           invokeRestart("muffleWarning")
[17:01:19.534]                       }
[17:01:19.534]                       else if (inherits(cond, "condition")) {
[17:01:19.534]                         if (!is.null(pattern)) {
[17:01:19.534]                           computeRestarts <- base::computeRestarts
[17:01:19.534]                           grepl <- base::grepl
[17:01:19.534]                           restarts <- computeRestarts(cond)
[17:01:19.534]                           for (restart in restarts) {
[17:01:19.534]                             name <- restart$name
[17:01:19.534]                             if (is.null(name)) 
[17:01:19.534]                               next
[17:01:19.534]                             if (!grepl(pattern, name)) 
[17:01:19.534]                               next
[17:01:19.534]                             invokeRestart(restart)
[17:01:19.534]                             muffled <- TRUE
[17:01:19.534]                             break
[17:01:19.534]                           }
[17:01:19.534]                         }
[17:01:19.534]                       }
[17:01:19.534]                       invisible(muffled)
[17:01:19.534]                     }
[17:01:19.534]                     muffleCondition(cond, pattern = "^muffle")
[17:01:19.534]                   }
[17:01:19.534]                 }
[17:01:19.534]                 else {
[17:01:19.534]                   if (TRUE) {
[17:01:19.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:19.534]                     {
[17:01:19.534]                       inherits <- base::inherits
[17:01:19.534]                       invokeRestart <- base::invokeRestart
[17:01:19.534]                       is.null <- base::is.null
[17:01:19.534]                       muffled <- FALSE
[17:01:19.534]                       if (inherits(cond, "message")) {
[17:01:19.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:19.534]                         if (muffled) 
[17:01:19.534]                           invokeRestart("muffleMessage")
[17:01:19.534]                       }
[17:01:19.534]                       else if (inherits(cond, "warning")) {
[17:01:19.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:19.534]                         if (muffled) 
[17:01:19.534]                           invokeRestart("muffleWarning")
[17:01:19.534]                       }
[17:01:19.534]                       else if (inherits(cond, "condition")) {
[17:01:19.534]                         if (!is.null(pattern)) {
[17:01:19.534]                           computeRestarts <- base::computeRestarts
[17:01:19.534]                           grepl <- base::grepl
[17:01:19.534]                           restarts <- computeRestarts(cond)
[17:01:19.534]                           for (restart in restarts) {
[17:01:19.534]                             name <- restart$name
[17:01:19.534]                             if (is.null(name)) 
[17:01:19.534]                               next
[17:01:19.534]                             if (!grepl(pattern, name)) 
[17:01:19.534]                               next
[17:01:19.534]                             invokeRestart(restart)
[17:01:19.534]                             muffled <- TRUE
[17:01:19.534]                             break
[17:01:19.534]                           }
[17:01:19.534]                         }
[17:01:19.534]                       }
[17:01:19.534]                       invisible(muffled)
[17:01:19.534]                     }
[17:01:19.534]                     muffleCondition(cond, pattern = "^muffle")
[17:01:19.534]                   }
[17:01:19.534]                 }
[17:01:19.534]             }
[17:01:19.534]         }))
[17:01:19.534]     }, error = function(ex) {
[17:01:19.534]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:19.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:19.534]                 ...future.rng), started = ...future.startTime, 
[17:01:19.534]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:19.534]             version = "1.8"), class = "FutureResult")
[17:01:19.534]     }, finally = {
[17:01:19.534]         if (!identical(...future.workdir, getwd())) 
[17:01:19.534]             setwd(...future.workdir)
[17:01:19.534]         {
[17:01:19.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:19.534]                 ...future.oldOptions$nwarnings <- NULL
[17:01:19.534]             }
[17:01:19.534]             base::options(...future.oldOptions)
[17:01:19.534]             if (.Platform$OS.type == "windows") {
[17:01:19.534]                 old_names <- names(...future.oldEnvVars)
[17:01:19.534]                 envs <- base::Sys.getenv()
[17:01:19.534]                 names <- names(envs)
[17:01:19.534]                 common <- intersect(names, old_names)
[17:01:19.534]                 added <- setdiff(names, old_names)
[17:01:19.534]                 removed <- setdiff(old_names, names)
[17:01:19.534]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:19.534]                   envs[common]]
[17:01:19.534]                 NAMES <- toupper(changed)
[17:01:19.534]                 args <- list()
[17:01:19.534]                 for (kk in seq_along(NAMES)) {
[17:01:19.534]                   name <- changed[[kk]]
[17:01:19.534]                   NAME <- NAMES[[kk]]
[17:01:19.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:19.534]                     next
[17:01:19.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:19.534]                 }
[17:01:19.534]                 NAMES <- toupper(added)
[17:01:19.534]                 for (kk in seq_along(NAMES)) {
[17:01:19.534]                   name <- added[[kk]]
[17:01:19.534]                   NAME <- NAMES[[kk]]
[17:01:19.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:19.534]                     next
[17:01:19.534]                   args[[name]] <- ""
[17:01:19.534]                 }
[17:01:19.534]                 NAMES <- toupper(removed)
[17:01:19.534]                 for (kk in seq_along(NAMES)) {
[17:01:19.534]                   name <- removed[[kk]]
[17:01:19.534]                   NAME <- NAMES[[kk]]
[17:01:19.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:19.534]                     next
[17:01:19.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:19.534]                 }
[17:01:19.534]                 if (length(args) > 0) 
[17:01:19.534]                   base::do.call(base::Sys.setenv, args = args)
[17:01:19.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:19.534]             }
[17:01:19.534]             else {
[17:01:19.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:19.534]             }
[17:01:19.534]             {
[17:01:19.534]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:19.534]                   0L) {
[17:01:19.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:19.534]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:19.534]                   base::options(opts)
[17:01:19.534]                 }
[17:01:19.534]                 {
[17:01:19.534]                   {
[17:01:19.534]                     NULL
[17:01:19.534]                     RNGkind("Mersenne-Twister")
[17:01:19.534]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:19.534]                       inherits = FALSE)
[17:01:19.534]                   }
[17:01:19.534]                   options(future.plan = NULL)
[17:01:19.534]                   if (is.na(NA_character_)) 
[17:01:19.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:19.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:19.534]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:19.534]                     .init = FALSE)
[17:01:19.534]                 }
[17:01:19.534]             }
[17:01:19.534]         }
[17:01:19.534]     })
[17:01:19.534]     if (TRUE) {
[17:01:19.534]         base::sink(type = "output", split = FALSE)
[17:01:19.534]         if (TRUE) {
[17:01:19.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:19.534]         }
[17:01:19.534]         else {
[17:01:19.534]             ...future.result["stdout"] <- base::list(NULL)
[17:01:19.534]         }
[17:01:19.534]         base::close(...future.stdout)
[17:01:19.534]         ...future.stdout <- NULL
[17:01:19.534]     }
[17:01:19.534]     ...future.result$conditions <- ...future.conditions
[17:01:19.534]     ...future.result$finished <- base::Sys.time()
[17:01:19.534]     ...future.result
[17:01:19.534] }
[17:01:19.536] assign_globals() ...
[17:01:19.536] List of 5
[17:01:19.536]  $ ...future.FUN            :function (x)  
[17:01:19.536]  $ future.call.arguments    : list()
[17:01:19.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:19.536]  $ ...future.elements_ii    :List of 2
[17:01:19.536]   ..$ : int 1
[17:01:19.536]   ..$ : int 0
[17:01:19.536]  $ ...future.seeds_ii       : NULL
[17:01:19.536]  $ ...future.globals.maxSize: NULL
[17:01:19.536]  - attr(*, "where")=List of 5
[17:01:19.536]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:19.536]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:19.536]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:19.536]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:19.536]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:19.536]  - attr(*, "resolved")= logi FALSE
[17:01:19.536]  - attr(*, "total_size")= num 4720
[17:01:19.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:19.536]  - attr(*, "already-done")= logi TRUE
[17:01:19.541] - reassign environment for ‘...future.FUN’
[17:01:19.541] - copied ‘...future.FUN’ to environment
[17:01:19.541] - copied ‘future.call.arguments’ to environment
[17:01:19.541] - copied ‘...future.elements_ii’ to environment
[17:01:19.541] - copied ‘...future.seeds_ii’ to environment
[17:01:19.541] - copied ‘...future.globals.maxSize’ to environment
[17:01:19.541] assign_globals() ... done
[17:01:19.542] plan(): Setting new future strategy stack:
[17:01:19.542] List of future strategies:
[17:01:19.542] 1. sequential:
[17:01:19.542]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:19.542]    - tweaked: FALSE
[17:01:19.542]    - call: NULL
[17:01:19.542] plan(): nbrOfWorkers() = 1
[17:01:20.044] plan(): Setting new future strategy stack:
[17:01:20.044] List of future strategies:
[17:01:20.044] 1. multicore:
[17:01:20.044]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:20.044]    - tweaked: FALSE
[17:01:20.044]    - call: plan(strategy)
[17:01:20.048] plan(): nbrOfWorkers() = 1
[17:01:20.048] SequentialFuture started (and completed)
[17:01:20.049] - Launch lazy future ... done
[17:01:20.049] run() for ‘SequentialFuture’ ... done
[17:01:20.049] Created future:
[17:01:20.049] SequentialFuture:
[17:01:20.049] Label: ‘future_lapply-1’
[17:01:20.049] Expression:
[17:01:20.049] {
[17:01:20.049]     do.call(function(...) {
[17:01:20.049]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:20.049]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:20.049]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:20.049]             on.exit(options(oopts), add = TRUE)
[17:01:20.049]         }
[17:01:20.049]         {
[17:01:20.049]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:20.049]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:20.049]                 ...future.FUN(...future.X_jj, ...)
[17:01:20.049]             })
[17:01:20.049]         }
[17:01:20.049]     }, args = future.call.arguments)
[17:01:20.049] }
[17:01:20.049] Lazy evaluation: FALSE
[17:01:20.049] Asynchronous evaluation: FALSE
[17:01:20.049] Local evaluation: TRUE
[17:01:20.049] Environment: R_GlobalEnv
[17:01:20.049] Capture standard output: TRUE
[17:01:20.049] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:20.049] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:20.049] Packages: <none>
[17:01:20.049] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:20.049] Resolved: TRUE
[17:01:20.049] Value: 112 bytes of class ‘list’
[17:01:20.049] Early signaling: FALSE
[17:01:20.049] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:20.049] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:20.050] Chunk #1 of 1 ... DONE
[17:01:20.050] Launching 1 futures (chunks) ... DONE
[17:01:20.050] Resolving 1 futures (chunks) ...
[17:01:20.050] resolve() on list ...
[17:01:20.050]  recursive: 0
[17:01:20.050]  length: 1
[17:01:20.050] 
[17:01:20.051] resolved() for ‘SequentialFuture’ ...
[17:01:20.051] - state: ‘finished’
[17:01:20.051] - run: TRUE
[17:01:20.051] - result: ‘FutureResult’
[17:01:20.051] resolved() for ‘SequentialFuture’ ... done
[17:01:20.051] Future #1
[17:01:20.051] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:20.051] - nx: 1
[17:01:20.051] - relay: TRUE
[17:01:20.051] - stdout: TRUE
[17:01:20.052] - signal: TRUE
[17:01:20.052] - resignal: FALSE
[17:01:20.052] - force: TRUE
[17:01:20.052] - relayed: [n=1] FALSE
[17:01:20.052] - queued futures: [n=1] FALSE
[17:01:20.052]  - until=1
[17:01:20.052]  - relaying element #1
[17:01:20.052] - relayed: [n=1] TRUE
[17:01:20.052] - queued futures: [n=1] TRUE
[17:01:20.052] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:20.053]  length: 0 (resolved future 1)
[17:01:20.053] Relaying remaining futures
[17:01:20.053] signalConditionsASAP(NULL, pos=0) ...
[17:01:20.053] - nx: 1
[17:01:20.053] - relay: TRUE
[17:01:20.053] - stdout: TRUE
[17:01:20.053] - signal: TRUE
[17:01:20.053] - resignal: FALSE
[17:01:20.053] - force: TRUE
[17:01:20.053] - relayed: [n=1] TRUE
[17:01:20.053] - queued futures: [n=1] TRUE
 - flush all
[17:01:20.054] - relayed: [n=1] TRUE
[17:01:20.054] - queued futures: [n=1] TRUE
[17:01:20.054] signalConditionsASAP(NULL, pos=0) ... done
[17:01:20.054] resolve() on list ... DONE
[17:01:20.054]  - Number of value chunks collected: 1
[17:01:20.054] Resolving 1 futures (chunks) ... DONE
[17:01:20.054] Reducing values from 1 chunks ...
[17:01:20.054]  - Number of values collected after concatenation: 2
[17:01:20.054]  - Number of values expected: 2
[17:01:20.054] Reducing values from 1 chunks ... DONE
[17:01:20.054] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:01:20.055] future_lapply() ...
[17:01:20.060] Number of chunks: 1
[17:01:20.061] getGlobalsAndPackagesXApply() ...
[17:01:20.061]  - future.globals: TRUE
[17:01:20.061] getGlobalsAndPackages() ...
[17:01:20.061] Searching for globals...
[17:01:20.062] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:20.062] Searching for globals ... DONE
[17:01:20.062] Resolving globals: FALSE
[17:01:20.063] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:20.063] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:20.063] - globals: [1] ‘FUN’
[17:01:20.063] 
[17:01:20.064] getGlobalsAndPackages() ... DONE
[17:01:20.064]  - globals found/used: [n=1] ‘FUN’
[17:01:20.064]  - needed namespaces: [n=0] 
[17:01:20.064] Finding globals ... DONE
[17:01:20.064]  - use_args: TRUE
[17:01:20.064]  - Getting '...' globals ...
[17:01:20.064] resolve() on list ...
[17:01:20.064]  recursive: 0
[17:01:20.064]  length: 1
[17:01:20.065]  elements: ‘...’
[17:01:20.065]  length: 0 (resolved future 1)
[17:01:20.065] resolve() on list ... DONE
[17:01:20.065]    - '...' content: [n=0] 
[17:01:20.065] List of 1
[17:01:20.065]  $ ...: list()
[17:01:20.065]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:20.065]  - attr(*, "where")=List of 1
[17:01:20.065]   ..$ ...:<environment: 0x5636f74328b8> 
[17:01:20.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:20.065]  - attr(*, "resolved")= logi TRUE
[17:01:20.065]  - attr(*, "total_size")= num NA
[17:01:20.068]  - Getting '...' globals ... DONE
[17:01:20.068] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:20.068] List of 2
[17:01:20.068]  $ ...future.FUN:function (x)  
[17:01:20.068]  $ ...          : list()
[17:01:20.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:20.068]  - attr(*, "where")=List of 2
[17:01:20.068]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:20.068]   ..$ ...          :<environment: 0x5636f74328b8> 
[17:01:20.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:20.068]  - attr(*, "resolved")= logi FALSE
[17:01:20.068]  - attr(*, "total_size")= num 4720
[17:01:20.070] Packages to be attached in all futures: [n=0] 
[17:01:20.071] getGlobalsAndPackagesXApply() ... DONE
[17:01:20.071] Number of futures (= number of chunks): 1
[17:01:20.071] Launching 1 futures (chunks) ...
[17:01:20.071] Chunk #1 of 1 ...
[17:01:20.071]  - Finding globals in 'X' for chunk #1 ...
[17:01:20.071] getGlobalsAndPackages() ...
[17:01:20.071] Searching for globals...
[17:01:20.072] 
[17:01:20.072] Searching for globals ... DONE
[17:01:20.072] - globals: [0] <none>
[17:01:20.072] getGlobalsAndPackages() ... DONE
[17:01:20.072]    + additional globals found: [n=0] 
[17:01:20.072]    + additional namespaces needed: [n=0] 
[17:01:20.072]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:20.072]  - seeds: <none>
[17:01:20.072]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:20.072] getGlobalsAndPackages() ...
[17:01:20.072] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:20.073] Resolving globals: FALSE
[17:01:20.073] Tweak future expression to call with '...' arguments ...
[17:01:20.073] {
[17:01:20.073]     do.call(function(...) {
[17:01:20.073]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:20.073]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:20.073]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:20.073]             on.exit(options(oopts), add = TRUE)
[17:01:20.073]         }
[17:01:20.073]         {
[17:01:20.073]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:20.073]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:20.073]                 ...future.FUN(...future.X_jj, ...)
[17:01:20.073]             })
[17:01:20.073]         }
[17:01:20.073]     }, args = future.call.arguments)
[17:01:20.073] }
[17:01:20.073] Tweak future expression to call with '...' arguments ... DONE
[17:01:20.073] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:20.073] 
[17:01:20.074] getGlobalsAndPackages() ... DONE
[17:01:20.074] run() for ‘Future’ ...
[17:01:20.074] - state: ‘created’
[17:01:20.074] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:20.078] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:20.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:20.078]   - Field: ‘label’
[17:01:20.078]   - Field: ‘local’
[17:01:20.079]   - Field: ‘owner’
[17:01:20.079]   - Field: ‘envir’
[17:01:20.079]   - Field: ‘packages’
[17:01:20.079]   - Field: ‘gc’
[17:01:20.079]   - Field: ‘conditions’
[17:01:20.079]   - Field: ‘expr’
[17:01:20.079]   - Field: ‘uuid’
[17:01:20.080]   - Field: ‘seed’
[17:01:20.080]   - Field: ‘version’
[17:01:20.080]   - Field: ‘result’
[17:01:20.080]   - Field: ‘asynchronous’
[17:01:20.080]   - Field: ‘calls’
[17:01:20.080]   - Field: ‘globals’
[17:01:20.080]   - Field: ‘stdout’
[17:01:20.080]   - Field: ‘earlySignal’
[17:01:20.080]   - Field: ‘lazy’
[17:01:20.081]   - Field: ‘state’
[17:01:20.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:20.081] - Launch lazy future ...
[17:01:20.081] Packages needed by the future expression (n = 0): <none>
[17:01:20.081] Packages needed by future strategies (n = 0): <none>
[17:01:20.081] {
[17:01:20.081]     {
[17:01:20.081]         {
[17:01:20.081]             ...future.startTime <- base::Sys.time()
[17:01:20.081]             {
[17:01:20.081]                 {
[17:01:20.081]                   {
[17:01:20.081]                     base::local({
[17:01:20.081]                       has_future <- base::requireNamespace("future", 
[17:01:20.081]                         quietly = TRUE)
[17:01:20.081]                       if (has_future) {
[17:01:20.081]                         ns <- base::getNamespace("future")
[17:01:20.081]                         version <- ns[[".package"]][["version"]]
[17:01:20.081]                         if (is.null(version)) 
[17:01:20.081]                           version <- utils::packageVersion("future")
[17:01:20.081]                       }
[17:01:20.081]                       else {
[17:01:20.081]                         version <- NULL
[17:01:20.081]                       }
[17:01:20.081]                       if (!has_future || version < "1.8.0") {
[17:01:20.081]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:20.081]                           "", base::R.version$version.string), 
[17:01:20.081]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:20.081]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:20.081]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:20.081]                             "release", "version")], collapse = " "), 
[17:01:20.081]                           hostname = base::Sys.info()[["nodename"]])
[17:01:20.081]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:20.081]                           info)
[17:01:20.081]                         info <- base::paste(info, collapse = "; ")
[17:01:20.081]                         if (!has_future) {
[17:01:20.081]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:20.081]                             info)
[17:01:20.081]                         }
[17:01:20.081]                         else {
[17:01:20.081]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:20.081]                             info, version)
[17:01:20.081]                         }
[17:01:20.081]                         base::stop(msg)
[17:01:20.081]                       }
[17:01:20.081]                     })
[17:01:20.081]                   }
[17:01:20.081]                   ...future.strategy.old <- future::plan("list")
[17:01:20.081]                   options(future.plan = NULL)
[17:01:20.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:20.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:20.081]                 }
[17:01:20.081]                 ...future.workdir <- getwd()
[17:01:20.081]             }
[17:01:20.081]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:20.081]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:20.081]         }
[17:01:20.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:20.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:20.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:20.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:20.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:20.081]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:20.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:20.081]             base::names(...future.oldOptions))
[17:01:20.081]     }
[17:01:20.081]     if (TRUE) {
[17:01:20.081]     }
[17:01:20.081]     else {
[17:01:20.081]         if (NA) {
[17:01:20.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:20.081]                 open = "w")
[17:01:20.081]         }
[17:01:20.081]         else {
[17:01:20.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:20.081]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:20.081]         }
[17:01:20.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:20.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:20.081]             base::sink(type = "output", split = FALSE)
[17:01:20.081]             base::close(...future.stdout)
[17:01:20.081]         }, add = TRUE)
[17:01:20.081]     }
[17:01:20.081]     ...future.frame <- base::sys.nframe()
[17:01:20.081]     ...future.conditions <- base::list()
[17:01:20.081]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:20.081]     if (FALSE) {
[17:01:20.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:20.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:20.081]     }
[17:01:20.081]     ...future.result <- base::tryCatch({
[17:01:20.081]         base::withCallingHandlers({
[17:01:20.081]             ...future.value <- base::withVisible(base::local({
[17:01:20.081]                 do.call(function(...) {
[17:01:20.081]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:20.081]                   if (!identical(...future.globals.maxSize.org, 
[17:01:20.081]                     ...future.globals.maxSize)) {
[17:01:20.081]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:20.081]                     on.exit(options(oopts), add = TRUE)
[17:01:20.081]                   }
[17:01:20.081]                   {
[17:01:20.081]                     lapply(seq_along(...future.elements_ii), 
[17:01:20.081]                       FUN = function(jj) {
[17:01:20.081]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:20.081]                         ...future.FUN(...future.X_jj, ...)
[17:01:20.081]                       })
[17:01:20.081]                   }
[17:01:20.081]                 }, args = future.call.arguments)
[17:01:20.081]             }))
[17:01:20.081]             future::FutureResult(value = ...future.value$value, 
[17:01:20.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:20.081]                   ...future.rng), globalenv = if (FALSE) 
[17:01:20.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:20.081]                     ...future.globalenv.names))
[17:01:20.081]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:20.081]         }, condition = base::local({
[17:01:20.081]             c <- base::c
[17:01:20.081]             inherits <- base::inherits
[17:01:20.081]             invokeRestart <- base::invokeRestart
[17:01:20.081]             length <- base::length
[17:01:20.081]             list <- base::list
[17:01:20.081]             seq.int <- base::seq.int
[17:01:20.081]             signalCondition <- base::signalCondition
[17:01:20.081]             sys.calls <- base::sys.calls
[17:01:20.081]             `[[` <- base::`[[`
[17:01:20.081]             `+` <- base::`+`
[17:01:20.081]             `<<-` <- base::`<<-`
[17:01:20.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:20.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:20.081]                   3L)]
[17:01:20.081]             }
[17:01:20.081]             function(cond) {
[17:01:20.081]                 is_error <- inherits(cond, "error")
[17:01:20.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:20.081]                   NULL)
[17:01:20.081]                 if (is_error) {
[17:01:20.081]                   sessionInformation <- function() {
[17:01:20.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:20.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:20.081]                       search = base::search(), system = base::Sys.info())
[17:01:20.081]                   }
[17:01:20.081]                   ...future.conditions[[length(...future.conditions) + 
[17:01:20.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:20.081]                     cond$call), session = sessionInformation(), 
[17:01:20.081]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:20.081]                   signalCondition(cond)
[17:01:20.081]                 }
[17:01:20.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:20.081]                 "immediateCondition"))) {
[17:01:20.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:20.081]                   ...future.conditions[[length(...future.conditions) + 
[17:01:20.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:20.081]                   if (TRUE && !signal) {
[17:01:20.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:20.081]                     {
[17:01:20.081]                       inherits <- base::inherits
[17:01:20.081]                       invokeRestart <- base::invokeRestart
[17:01:20.081]                       is.null <- base::is.null
[17:01:20.081]                       muffled <- FALSE
[17:01:20.081]                       if (inherits(cond, "message")) {
[17:01:20.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:20.081]                         if (muffled) 
[17:01:20.081]                           invokeRestart("muffleMessage")
[17:01:20.081]                       }
[17:01:20.081]                       else if (inherits(cond, "warning")) {
[17:01:20.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:20.081]                         if (muffled) 
[17:01:20.081]                           invokeRestart("muffleWarning")
[17:01:20.081]                       }
[17:01:20.081]                       else if (inherits(cond, "condition")) {
[17:01:20.081]                         if (!is.null(pattern)) {
[17:01:20.081]                           computeRestarts <- base::computeRestarts
[17:01:20.081]                           grepl <- base::grepl
[17:01:20.081]                           restarts <- computeRestarts(cond)
[17:01:20.081]                           for (restart in restarts) {
[17:01:20.081]                             name <- restart$name
[17:01:20.081]                             if (is.null(name)) 
[17:01:20.081]                               next
[17:01:20.081]                             if (!grepl(pattern, name)) 
[17:01:20.081]                               next
[17:01:20.081]                             invokeRestart(restart)
[17:01:20.081]                             muffled <- TRUE
[17:01:20.081]                             break
[17:01:20.081]                           }
[17:01:20.081]                         }
[17:01:20.081]                       }
[17:01:20.081]                       invisible(muffled)
[17:01:20.081]                     }
[17:01:20.081]                     muffleCondition(cond, pattern = "^muffle")
[17:01:20.081]                   }
[17:01:20.081]                 }
[17:01:20.081]                 else {
[17:01:20.081]                   if (TRUE) {
[17:01:20.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:20.081]                     {
[17:01:20.081]                       inherits <- base::inherits
[17:01:20.081]                       invokeRestart <- base::invokeRestart
[17:01:20.081]                       is.null <- base::is.null
[17:01:20.081]                       muffled <- FALSE
[17:01:20.081]                       if (inherits(cond, "message")) {
[17:01:20.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:20.081]                         if (muffled) 
[17:01:20.081]                           invokeRestart("muffleMessage")
[17:01:20.081]                       }
[17:01:20.081]                       else if (inherits(cond, "warning")) {
[17:01:20.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:20.081]                         if (muffled) 
[17:01:20.081]                           invokeRestart("muffleWarning")
[17:01:20.081]                       }
[17:01:20.081]                       else if (inherits(cond, "condition")) {
[17:01:20.081]                         if (!is.null(pattern)) {
[17:01:20.081]                           computeRestarts <- base::computeRestarts
[17:01:20.081]                           grepl <- base::grepl
[17:01:20.081]                           restarts <- computeRestarts(cond)
[17:01:20.081]                           for (restart in restarts) {
[17:01:20.081]                             name <- restart$name
[17:01:20.081]                             if (is.null(name)) 
[17:01:20.081]                               next
[17:01:20.081]                             if (!grepl(pattern, name)) 
[17:01:20.081]                               next
[17:01:20.081]                             invokeRestart(restart)
[17:01:20.081]                             muffled <- TRUE
[17:01:20.081]                             break
[17:01:20.081]                           }
[17:01:20.081]                         }
[17:01:20.081]                       }
[17:01:20.081]                       invisible(muffled)
[17:01:20.081]                     }
[17:01:20.081]                     muffleCondition(cond, pattern = "^muffle")
[17:01:20.081]                   }
[17:01:20.081]                 }
[17:01:20.081]             }
[17:01:20.081]         }))
[17:01:20.081]     }, error = function(ex) {
[17:01:20.081]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:20.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:20.081]                 ...future.rng), started = ...future.startTime, 
[17:01:20.081]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:20.081]             version = "1.8"), class = "FutureResult")
[17:01:20.081]     }, finally = {
[17:01:20.081]         if (!identical(...future.workdir, getwd())) 
[17:01:20.081]             setwd(...future.workdir)
[17:01:20.081]         {
[17:01:20.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:20.081]                 ...future.oldOptions$nwarnings <- NULL
[17:01:20.081]             }
[17:01:20.081]             base::options(...future.oldOptions)
[17:01:20.081]             if (.Platform$OS.type == "windows") {
[17:01:20.081]                 old_names <- names(...future.oldEnvVars)
[17:01:20.081]                 envs <- base::Sys.getenv()
[17:01:20.081]                 names <- names(envs)
[17:01:20.081]                 common <- intersect(names, old_names)
[17:01:20.081]                 added <- setdiff(names, old_names)
[17:01:20.081]                 removed <- setdiff(old_names, names)
[17:01:20.081]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:20.081]                   envs[common]]
[17:01:20.081]                 NAMES <- toupper(changed)
[17:01:20.081]                 args <- list()
[17:01:20.081]                 for (kk in seq_along(NAMES)) {
[17:01:20.081]                   name <- changed[[kk]]
[17:01:20.081]                   NAME <- NAMES[[kk]]
[17:01:20.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:20.081]                     next
[17:01:20.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:20.081]                 }
[17:01:20.081]                 NAMES <- toupper(added)
[17:01:20.081]                 for (kk in seq_along(NAMES)) {
[17:01:20.081]                   name <- added[[kk]]
[17:01:20.081]                   NAME <- NAMES[[kk]]
[17:01:20.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:20.081]                     next
[17:01:20.081]                   args[[name]] <- ""
[17:01:20.081]                 }
[17:01:20.081]                 NAMES <- toupper(removed)
[17:01:20.081]                 for (kk in seq_along(NAMES)) {
[17:01:20.081]                   name <- removed[[kk]]
[17:01:20.081]                   NAME <- NAMES[[kk]]
[17:01:20.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:20.081]                     next
[17:01:20.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:20.081]                 }
[17:01:20.081]                 if (length(args) > 0) 
[17:01:20.081]                   base::do.call(base::Sys.setenv, args = args)
[17:01:20.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:20.081]             }
[17:01:20.081]             else {
[17:01:20.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:20.081]             }
[17:01:20.081]             {
[17:01:20.081]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:20.081]                   0L) {
[17:01:20.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:20.081]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:20.081]                   base::options(opts)
[17:01:20.081]                 }
[17:01:20.081]                 {
[17:01:20.081]                   {
[17:01:20.081]                     NULL
[17:01:20.081]                     RNGkind("Mersenne-Twister")
[17:01:20.081]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:20.081]                       inherits = FALSE)
[17:01:20.081]                   }
[17:01:20.081]                   options(future.plan = NULL)
[17:01:20.081]                   if (is.na(NA_character_)) 
[17:01:20.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:20.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:20.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:20.081]                     .init = FALSE)
[17:01:20.081]                 }
[17:01:20.081]             }
[17:01:20.081]         }
[17:01:20.081]     })
[17:01:20.081]     if (FALSE) {
[17:01:20.081]         base::sink(type = "output", split = FALSE)
[17:01:20.081]         if (NA) {
[17:01:20.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:20.081]         }
[17:01:20.081]         else {
[17:01:20.081]             ...future.result["stdout"] <- base::list(NULL)
[17:01:20.081]         }
[17:01:20.081]         base::close(...future.stdout)
[17:01:20.081]         ...future.stdout <- NULL
[17:01:20.081]     }
[17:01:20.081]     ...future.result$conditions <- ...future.conditions
[17:01:20.081]     ...future.result$finished <- base::Sys.time()
[17:01:20.081]     ...future.result
[17:01:20.081] }
[17:01:20.083] assign_globals() ...
[17:01:20.083] List of 5
[17:01:20.083]  $ ...future.FUN            :function (x)  
[17:01:20.083]  $ future.call.arguments    : list()
[17:01:20.083]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:20.083]  $ ...future.elements_ii    :List of 2
[17:01:20.083]   ..$ : int 1
[17:01:20.083]   ..$ : int 0
[17:01:20.083]  $ ...future.seeds_ii       : NULL
[17:01:20.083]  $ ...future.globals.maxSize: NULL
[17:01:20.083]  - attr(*, "where")=List of 5
[17:01:20.083]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:20.083]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:20.083]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:20.083]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:20.083]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:20.083]  - attr(*, "resolved")= logi FALSE
[17:01:20.083]  - attr(*, "total_size")= num 4720
[17:01:20.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:20.083]  - attr(*, "already-done")= logi TRUE
[17:01:20.090] - reassign environment for ‘...future.FUN’
[17:01:20.090] - copied ‘...future.FUN’ to environment
[17:01:20.090] - copied ‘future.call.arguments’ to environment
[17:01:20.090] - copied ‘...future.elements_ii’ to environment
[17:01:20.090] - copied ‘...future.seeds_ii’ to environment
[17:01:20.091] - copied ‘...future.globals.maxSize’ to environment
[17:01:20.091] assign_globals() ... done
[17:01:20.091] plan(): Setting new future strategy stack:
[17:01:20.091] List of future strategies:
[17:01:20.091] 1. sequential:
[17:01:20.091]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:20.091]    - tweaked: FALSE
[17:01:20.091]    - call: NULL
[17:01:20.092] plan(): nbrOfWorkers() = 1
[17:01:20.593] plan(): Setting new future strategy stack:
[17:01:20.593] List of future strategies:
[17:01:20.593] 1. multicore:
[17:01:20.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:20.593]    - tweaked: FALSE
[17:01:20.593]    - call: plan(strategy)
[17:01:20.597] plan(): nbrOfWorkers() = 1
[17:01:20.598] SequentialFuture started (and completed)
[17:01:20.598] - Launch lazy future ... done
[17:01:20.598] run() for ‘SequentialFuture’ ... done
[17:01:20.598] Created future:
[17:01:20.598] SequentialFuture:
[17:01:20.598] Label: ‘future_lapply-1’
[17:01:20.598] Expression:
[17:01:20.598] {
[17:01:20.598]     do.call(function(...) {
[17:01:20.598]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:20.598]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:20.598]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:20.598]             on.exit(options(oopts), add = TRUE)
[17:01:20.598]         }
[17:01:20.598]         {
[17:01:20.598]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:20.598]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:20.598]                 ...future.FUN(...future.X_jj, ...)
[17:01:20.598]             })
[17:01:20.598]         }
[17:01:20.598]     }, args = future.call.arguments)
[17:01:20.598] }
[17:01:20.598] Lazy evaluation: FALSE
[17:01:20.598] Asynchronous evaluation: FALSE
[17:01:20.598] Local evaluation: TRUE
[17:01:20.598] Environment: R_GlobalEnv
[17:01:20.598] Capture standard output: NA
[17:01:20.598] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:20.598] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:20.598] Packages: <none>
[17:01:20.598] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:20.598] Resolved: TRUE
[17:01:20.598] Value: 112 bytes of class ‘list’
[17:01:20.598] Early signaling: FALSE
[17:01:20.598] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:20.598] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:20.599] Chunk #1 of 1 ... DONE
[17:01:20.599] Launching 1 futures (chunks) ... DONE
[17:01:20.599] Resolving 1 futures (chunks) ...
[17:01:20.599] resolve() on list ...
[17:01:20.599]  recursive: 0
[17:01:20.600]  length: 1
[17:01:20.600] 
[17:01:20.600] resolved() for ‘SequentialFuture’ ...
[17:01:20.600] - state: ‘finished’
[17:01:20.600] - run: TRUE
[17:01:20.600] - result: ‘FutureResult’
[17:01:20.600] resolved() for ‘SequentialFuture’ ... done
[17:01:20.600] Future #1
[17:01:20.600] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:20.600] - nx: 1
[17:01:20.601] - relay: TRUE
[17:01:20.601] - stdout: TRUE
[17:01:20.601] - signal: TRUE
[17:01:20.601] - resignal: FALSE
[17:01:20.601] - force: TRUE
[17:01:20.601] - relayed: [n=1] FALSE
[17:01:20.601] - queued futures: [n=1] FALSE
[17:01:20.601]  - until=1
[17:01:20.601]  - relaying element #1
[17:01:20.601] - relayed: [n=1] TRUE
[17:01:20.601] - queued futures: [n=1] TRUE
[17:01:20.602] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:20.602]  length: 0 (resolved future 1)
[17:01:20.602] Relaying remaining futures
[17:01:20.602] signalConditionsASAP(NULL, pos=0) ...
[17:01:20.602] - nx: 1
[17:01:20.602] - relay: TRUE
[17:01:20.602] - stdout: TRUE
[17:01:20.602] - signal: TRUE
[17:01:20.602] - resignal: FALSE
[17:01:20.602] - force: TRUE
[17:01:20.602] - relayed: [n=1] TRUE
[17:01:20.603] - queued futures: [n=1] TRUE
 - flush all
[17:01:20.603] - relayed: [n=1] TRUE
[17:01:20.603] - queued futures: [n=1] TRUE
[17:01:20.603] signalConditionsASAP(NULL, pos=0) ... done
[17:01:20.603] resolve() on list ... DONE
[17:01:20.603]  - Number of value chunks collected: 1
[17:01:20.603] Resolving 1 futures (chunks) ... DONE
[17:01:20.603] Reducing values from 1 chunks ...
[17:01:20.603]  - Number of values collected after concatenation: 2
[17:01:20.603]  - Number of values expected: 2
[17:01:20.604] Reducing values from 1 chunks ... DONE
[17:01:20.604] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:01:20.604] future_mapply() ...
[17:01:20.607] Number of chunks: 1
[17:01:20.607] getGlobalsAndPackagesXApply() ...
[17:01:20.608]  - future.globals: TRUE
[17:01:20.608] getGlobalsAndPackages() ...
[17:01:20.608] Searching for globals...
[17:01:20.609] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:20.609] Searching for globals ... DONE
[17:01:20.610] Resolving globals: FALSE
[17:01:20.610] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:20.610] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:20.610] - globals: [1] ‘FUN’
[17:01:20.611] 
[17:01:20.611] getGlobalsAndPackages() ... DONE
[17:01:20.611]  - globals found/used: [n=1] ‘FUN’
[17:01:20.611]  - needed namespaces: [n=0] 
[17:01:20.611] Finding globals ... DONE
[17:01:20.611] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:20.611] List of 2
[17:01:20.611]  $ ...future.FUN:function (x, y)  
[17:01:20.611]  $ MoreArgs     : NULL
[17:01:20.611]  - attr(*, "where")=List of 2
[17:01:20.611]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:20.611]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:20.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:20.611]  - attr(*, "resolved")= logi FALSE
[17:01:20.611]  - attr(*, "total_size")= num NA
[17:01:20.614] Packages to be attached in all futures: [n=0] 
[17:01:20.614] getGlobalsAndPackagesXApply() ... DONE
[17:01:20.614] Number of futures (= number of chunks): 1
[17:01:20.614] Launching 1 futures (chunks) ...
[17:01:20.614] Chunk #1 of 1 ...
[17:01:20.614]  - Finding globals in '...' for chunk #1 ...
[17:01:20.614] getGlobalsAndPackages() ...
[17:01:20.615] Searching for globals...
[17:01:20.615] 
[17:01:20.615] Searching for globals ... DONE
[17:01:20.615] - globals: [0] <none>
[17:01:20.615] getGlobalsAndPackages() ... DONE
[17:01:20.615]    + additional globals found: [n=0] 
[17:01:20.615]    + additional namespaces needed: [n=0] 
[17:01:20.615]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:20.616]  - seeds: <none>
[17:01:20.616]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:20.616] getGlobalsAndPackages() ...
[17:01:20.616] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:20.616] Resolving globals: FALSE
[17:01:20.616] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:01:20.617] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:20.617] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:20.617] 
[17:01:20.617] getGlobalsAndPackages() ... DONE
[17:01:20.617] run() for ‘Future’ ...
[17:01:20.618] - state: ‘created’
[17:01:20.618] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:20.624] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:20.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:20.624]   - Field: ‘label’
[17:01:20.624]   - Field: ‘local’
[17:01:20.624]   - Field: ‘owner’
[17:01:20.624]   - Field: ‘envir’
[17:01:20.624]   - Field: ‘packages’
[17:01:20.624]   - Field: ‘gc’
[17:01:20.625]   - Field: ‘conditions’
[17:01:20.625]   - Field: ‘expr’
[17:01:20.625]   - Field: ‘uuid’
[17:01:20.625]   - Field: ‘seed’
[17:01:20.625]   - Field: ‘version’
[17:01:20.625]   - Field: ‘result’
[17:01:20.625]   - Field: ‘asynchronous’
[17:01:20.625]   - Field: ‘calls’
[17:01:20.625]   - Field: ‘globals’
[17:01:20.625]   - Field: ‘stdout’
[17:01:20.625]   - Field: ‘earlySignal’
[17:01:20.626]   - Field: ‘lazy’
[17:01:20.626]   - Field: ‘state’
[17:01:20.626] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:20.626] - Launch lazy future ...
[17:01:20.626] Packages needed by the future expression (n = 0): <none>
[17:01:20.626] Packages needed by future strategies (n = 0): <none>
[17:01:20.627] {
[17:01:20.627]     {
[17:01:20.627]         {
[17:01:20.627]             ...future.startTime <- base::Sys.time()
[17:01:20.627]             {
[17:01:20.627]                 {
[17:01:20.627]                   {
[17:01:20.627]                     base::local({
[17:01:20.627]                       has_future <- base::requireNamespace("future", 
[17:01:20.627]                         quietly = TRUE)
[17:01:20.627]                       if (has_future) {
[17:01:20.627]                         ns <- base::getNamespace("future")
[17:01:20.627]                         version <- ns[[".package"]][["version"]]
[17:01:20.627]                         if (is.null(version)) 
[17:01:20.627]                           version <- utils::packageVersion("future")
[17:01:20.627]                       }
[17:01:20.627]                       else {
[17:01:20.627]                         version <- NULL
[17:01:20.627]                       }
[17:01:20.627]                       if (!has_future || version < "1.8.0") {
[17:01:20.627]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:20.627]                           "", base::R.version$version.string), 
[17:01:20.627]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:20.627]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:20.627]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:20.627]                             "release", "version")], collapse = " "), 
[17:01:20.627]                           hostname = base::Sys.info()[["nodename"]])
[17:01:20.627]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:20.627]                           info)
[17:01:20.627]                         info <- base::paste(info, collapse = "; ")
[17:01:20.627]                         if (!has_future) {
[17:01:20.627]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:20.627]                             info)
[17:01:20.627]                         }
[17:01:20.627]                         else {
[17:01:20.627]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:20.627]                             info, version)
[17:01:20.627]                         }
[17:01:20.627]                         base::stop(msg)
[17:01:20.627]                       }
[17:01:20.627]                     })
[17:01:20.627]                   }
[17:01:20.627]                   ...future.strategy.old <- future::plan("list")
[17:01:20.627]                   options(future.plan = NULL)
[17:01:20.627]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:20.627]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:20.627]                 }
[17:01:20.627]                 ...future.workdir <- getwd()
[17:01:20.627]             }
[17:01:20.627]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:20.627]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:20.627]         }
[17:01:20.627]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:20.627]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:20.627]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:20.627]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:20.627]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:20.627]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:20.627]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:20.627]             base::names(...future.oldOptions))
[17:01:20.627]     }
[17:01:20.627]     if (FALSE) {
[17:01:20.627]     }
[17:01:20.627]     else {
[17:01:20.627]         if (FALSE) {
[17:01:20.627]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:20.627]                 open = "w")
[17:01:20.627]         }
[17:01:20.627]         else {
[17:01:20.627]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:20.627]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:20.627]         }
[17:01:20.627]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:20.627]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:20.627]             base::sink(type = "output", split = FALSE)
[17:01:20.627]             base::close(...future.stdout)
[17:01:20.627]         }, add = TRUE)
[17:01:20.627]     }
[17:01:20.627]     ...future.frame <- base::sys.nframe()
[17:01:20.627]     ...future.conditions <- base::list()
[17:01:20.627]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:20.627]     if (FALSE) {
[17:01:20.627]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:20.627]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:20.627]     }
[17:01:20.627]     ...future.result <- base::tryCatch({
[17:01:20.627]         base::withCallingHandlers({
[17:01:20.627]             ...future.value <- base::withVisible(base::local({
[17:01:20.627]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:20.627]                 if (!identical(...future.globals.maxSize.org, 
[17:01:20.627]                   ...future.globals.maxSize)) {
[17:01:20.627]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:20.627]                   on.exit(options(oopts), add = TRUE)
[17:01:20.627]                 }
[17:01:20.627]                 {
[17:01:20.627]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:20.627]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:20.627]                     USE.NAMES = FALSE)
[17:01:20.627]                   do.call(mapply, args = args)
[17:01:20.627]                 }
[17:01:20.627]             }))
[17:01:20.627]             future::FutureResult(value = ...future.value$value, 
[17:01:20.627]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:20.627]                   ...future.rng), globalenv = if (FALSE) 
[17:01:20.627]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:20.627]                     ...future.globalenv.names))
[17:01:20.627]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:20.627]         }, condition = base::local({
[17:01:20.627]             c <- base::c
[17:01:20.627]             inherits <- base::inherits
[17:01:20.627]             invokeRestart <- base::invokeRestart
[17:01:20.627]             length <- base::length
[17:01:20.627]             list <- base::list
[17:01:20.627]             seq.int <- base::seq.int
[17:01:20.627]             signalCondition <- base::signalCondition
[17:01:20.627]             sys.calls <- base::sys.calls
[17:01:20.627]             `[[` <- base::`[[`
[17:01:20.627]             `+` <- base::`+`
[17:01:20.627]             `<<-` <- base::`<<-`
[17:01:20.627]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:20.627]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:20.627]                   3L)]
[17:01:20.627]             }
[17:01:20.627]             function(cond) {
[17:01:20.627]                 is_error <- inherits(cond, "error")
[17:01:20.627]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:20.627]                   NULL)
[17:01:20.627]                 if (is_error) {
[17:01:20.627]                   sessionInformation <- function() {
[17:01:20.627]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:20.627]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:20.627]                       search = base::search(), system = base::Sys.info())
[17:01:20.627]                   }
[17:01:20.627]                   ...future.conditions[[length(...future.conditions) + 
[17:01:20.627]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:20.627]                     cond$call), session = sessionInformation(), 
[17:01:20.627]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:20.627]                   signalCondition(cond)
[17:01:20.627]                 }
[17:01:20.627]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:20.627]                 "immediateCondition"))) {
[17:01:20.627]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:20.627]                   ...future.conditions[[length(...future.conditions) + 
[17:01:20.627]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:20.627]                   if (TRUE && !signal) {
[17:01:20.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:20.627]                     {
[17:01:20.627]                       inherits <- base::inherits
[17:01:20.627]                       invokeRestart <- base::invokeRestart
[17:01:20.627]                       is.null <- base::is.null
[17:01:20.627]                       muffled <- FALSE
[17:01:20.627]                       if (inherits(cond, "message")) {
[17:01:20.627]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:20.627]                         if (muffled) 
[17:01:20.627]                           invokeRestart("muffleMessage")
[17:01:20.627]                       }
[17:01:20.627]                       else if (inherits(cond, "warning")) {
[17:01:20.627]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:20.627]                         if (muffled) 
[17:01:20.627]                           invokeRestart("muffleWarning")
[17:01:20.627]                       }
[17:01:20.627]                       else if (inherits(cond, "condition")) {
[17:01:20.627]                         if (!is.null(pattern)) {
[17:01:20.627]                           computeRestarts <- base::computeRestarts
[17:01:20.627]                           grepl <- base::grepl
[17:01:20.627]                           restarts <- computeRestarts(cond)
[17:01:20.627]                           for (restart in restarts) {
[17:01:20.627]                             name <- restart$name
[17:01:20.627]                             if (is.null(name)) 
[17:01:20.627]                               next
[17:01:20.627]                             if (!grepl(pattern, name)) 
[17:01:20.627]                               next
[17:01:20.627]                             invokeRestart(restart)
[17:01:20.627]                             muffled <- TRUE
[17:01:20.627]                             break
[17:01:20.627]                           }
[17:01:20.627]                         }
[17:01:20.627]                       }
[17:01:20.627]                       invisible(muffled)
[17:01:20.627]                     }
[17:01:20.627]                     muffleCondition(cond, pattern = "^muffle")
[17:01:20.627]                   }
[17:01:20.627]                 }
[17:01:20.627]                 else {
[17:01:20.627]                   if (TRUE) {
[17:01:20.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:20.627]                     {
[17:01:20.627]                       inherits <- base::inherits
[17:01:20.627]                       invokeRestart <- base::invokeRestart
[17:01:20.627]                       is.null <- base::is.null
[17:01:20.627]                       muffled <- FALSE
[17:01:20.627]                       if (inherits(cond, "message")) {
[17:01:20.627]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:20.627]                         if (muffled) 
[17:01:20.627]                           invokeRestart("muffleMessage")
[17:01:20.627]                       }
[17:01:20.627]                       else if (inherits(cond, "warning")) {
[17:01:20.627]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:20.627]                         if (muffled) 
[17:01:20.627]                           invokeRestart("muffleWarning")
[17:01:20.627]                       }
[17:01:20.627]                       else if (inherits(cond, "condition")) {
[17:01:20.627]                         if (!is.null(pattern)) {
[17:01:20.627]                           computeRestarts <- base::computeRestarts
[17:01:20.627]                           grepl <- base::grepl
[17:01:20.627]                           restarts <- computeRestarts(cond)
[17:01:20.627]                           for (restart in restarts) {
[17:01:20.627]                             name <- restart$name
[17:01:20.627]                             if (is.null(name)) 
[17:01:20.627]                               next
[17:01:20.627]                             if (!grepl(pattern, name)) 
[17:01:20.627]                               next
[17:01:20.627]                             invokeRestart(restart)
[17:01:20.627]                             muffled <- TRUE
[17:01:20.627]                             break
[17:01:20.627]                           }
[17:01:20.627]                         }
[17:01:20.627]                       }
[17:01:20.627]                       invisible(muffled)
[17:01:20.627]                     }
[17:01:20.627]                     muffleCondition(cond, pattern = "^muffle")
[17:01:20.627]                   }
[17:01:20.627]                 }
[17:01:20.627]             }
[17:01:20.627]         }))
[17:01:20.627]     }, error = function(ex) {
[17:01:20.627]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:20.627]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:20.627]                 ...future.rng), started = ...future.startTime, 
[17:01:20.627]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:20.627]             version = "1.8"), class = "FutureResult")
[17:01:20.627]     }, finally = {
[17:01:20.627]         if (!identical(...future.workdir, getwd())) 
[17:01:20.627]             setwd(...future.workdir)
[17:01:20.627]         {
[17:01:20.627]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:20.627]                 ...future.oldOptions$nwarnings <- NULL
[17:01:20.627]             }
[17:01:20.627]             base::options(...future.oldOptions)
[17:01:20.627]             if (.Platform$OS.type == "windows") {
[17:01:20.627]                 old_names <- names(...future.oldEnvVars)
[17:01:20.627]                 envs <- base::Sys.getenv()
[17:01:20.627]                 names <- names(envs)
[17:01:20.627]                 common <- intersect(names, old_names)
[17:01:20.627]                 added <- setdiff(names, old_names)
[17:01:20.627]                 removed <- setdiff(old_names, names)
[17:01:20.627]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:20.627]                   envs[common]]
[17:01:20.627]                 NAMES <- toupper(changed)
[17:01:20.627]                 args <- list()
[17:01:20.627]                 for (kk in seq_along(NAMES)) {
[17:01:20.627]                   name <- changed[[kk]]
[17:01:20.627]                   NAME <- NAMES[[kk]]
[17:01:20.627]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:20.627]                     next
[17:01:20.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:20.627]                 }
[17:01:20.627]                 NAMES <- toupper(added)
[17:01:20.627]                 for (kk in seq_along(NAMES)) {
[17:01:20.627]                   name <- added[[kk]]
[17:01:20.627]                   NAME <- NAMES[[kk]]
[17:01:20.627]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:20.627]                     next
[17:01:20.627]                   args[[name]] <- ""
[17:01:20.627]                 }
[17:01:20.627]                 NAMES <- toupper(removed)
[17:01:20.627]                 for (kk in seq_along(NAMES)) {
[17:01:20.627]                   name <- removed[[kk]]
[17:01:20.627]                   NAME <- NAMES[[kk]]
[17:01:20.627]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:20.627]                     next
[17:01:20.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:20.627]                 }
[17:01:20.627]                 if (length(args) > 0) 
[17:01:20.627]                   base::do.call(base::Sys.setenv, args = args)
[17:01:20.627]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:20.627]             }
[17:01:20.627]             else {
[17:01:20.627]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:20.627]             }
[17:01:20.627]             {
[17:01:20.627]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:20.627]                   0L) {
[17:01:20.627]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:20.627]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:20.627]                   base::options(opts)
[17:01:20.627]                 }
[17:01:20.627]                 {
[17:01:20.627]                   {
[17:01:20.627]                     NULL
[17:01:20.627]                     RNGkind("Mersenne-Twister")
[17:01:20.627]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:20.627]                       inherits = FALSE)
[17:01:20.627]                   }
[17:01:20.627]                   options(future.plan = NULL)
[17:01:20.627]                   if (is.na(NA_character_)) 
[17:01:20.627]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:20.627]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:20.627]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:20.627]                     .init = FALSE)
[17:01:20.627]                 }
[17:01:20.627]             }
[17:01:20.627]         }
[17:01:20.627]     })
[17:01:20.627]     if (TRUE) {
[17:01:20.627]         base::sink(type = "output", split = FALSE)
[17:01:20.627]         if (FALSE) {
[17:01:20.627]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:20.627]         }
[17:01:20.627]         else {
[17:01:20.627]             ...future.result["stdout"] <- base::list(NULL)
[17:01:20.627]         }
[17:01:20.627]         base::close(...future.stdout)
[17:01:20.627]         ...future.stdout <- NULL
[17:01:20.627]     }
[17:01:20.627]     ...future.result$conditions <- ...future.conditions
[17:01:20.627]     ...future.result$finished <- base::Sys.time()
[17:01:20.627]     ...future.result
[17:01:20.627] }
[17:01:20.628] assign_globals() ...
[17:01:20.628] List of 5
[17:01:20.628]  $ ...future.FUN            :function (x, y)  
[17:01:20.628]  $ MoreArgs                 : NULL
[17:01:20.628]  $ ...future.elements_ii    :List of 2
[17:01:20.628]   ..$ :List of 2
[17:01:20.628]   .. ..$ : int 1
[17:01:20.628]   .. ..$ : int 0
[17:01:20.628]   ..$ :List of 2
[17:01:20.628]   .. ..$ : int 0
[17:01:20.628]   .. ..$ : int 1
[17:01:20.628]  $ ...future.seeds_ii       : NULL
[17:01:20.628]  $ ...future.globals.maxSize: NULL
[17:01:20.628]  - attr(*, "where")=List of 5
[17:01:20.628]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:20.628]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:20.628]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:20.628]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:20.628]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:20.628]  - attr(*, "resolved")= logi FALSE
[17:01:20.628]  - attr(*, "total_size")= num 6480
[17:01:20.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:20.628]  - attr(*, "already-done")= logi TRUE
[17:01:20.634] - reassign environment for ‘...future.FUN’
[17:01:20.634] - copied ‘...future.FUN’ to environment
[17:01:20.634] - copied ‘MoreArgs’ to environment
[17:01:20.634] - copied ‘...future.elements_ii’ to environment
[17:01:20.634] - copied ‘...future.seeds_ii’ to environment
[17:01:20.634] - copied ‘...future.globals.maxSize’ to environment
[17:01:20.635] assign_globals() ... done
[17:01:20.635] plan(): Setting new future strategy stack:
[17:01:20.635] List of future strategies:
[17:01:20.635] 1. sequential:
[17:01:20.635]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:20.635]    - tweaked: FALSE
[17:01:20.635]    - call: NULL
[17:01:20.635] plan(): nbrOfWorkers() = 1
[17:01:21.137] plan(): Setting new future strategy stack:
[17:01:21.137] List of future strategies:
[17:01:21.137] 1. multicore:
[17:01:21.137]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:21.137]    - tweaked: FALSE
[17:01:21.137]    - call: plan(strategy)
[17:01:21.142] plan(): nbrOfWorkers() = 1
[17:01:21.142] SequentialFuture started (and completed)
[17:01:21.142] - Launch lazy future ... done
[17:01:21.142] run() for ‘SequentialFuture’ ... done
[17:01:21.142] Created future:
[17:01:21.142] SequentialFuture:
[17:01:21.142] Label: ‘future_mapply-1’
[17:01:21.142] Expression:
[17:01:21.142] {
[17:01:21.142]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:21.142]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:21.142]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:21.142]         on.exit(options(oopts), add = TRUE)
[17:01:21.142]     }
[17:01:21.142]     {
[17:01:21.142]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:21.142]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:21.142]         do.call(mapply, args = args)
[17:01:21.142]     }
[17:01:21.142] }
[17:01:21.142] Lazy evaluation: FALSE
[17:01:21.142] Asynchronous evaluation: FALSE
[17:01:21.142] Local evaluation: TRUE
[17:01:21.142] Environment: R_GlobalEnv
[17:01:21.142] Capture standard output: FALSE
[17:01:21.142] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:21.142] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:21.142] Packages: <none>
[17:01:21.142] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:21.142] Resolved: TRUE
[17:01:21.142] Value: 224 bytes of class ‘list’
[17:01:21.142] Early signaling: FALSE
[17:01:21.142] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:21.142] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:21.144] Chunk #1 of 1 ... DONE
[17:01:21.144] Launching 1 futures (chunks) ... DONE
[17:01:21.144] Resolving 1 futures (chunks) ...
[17:01:21.144] resolve() on list ...
[17:01:21.144]  recursive: 0
[17:01:21.144]  length: 1
[17:01:21.144] 
[17:01:21.144] resolved() for ‘SequentialFuture’ ...
[17:01:21.144] - state: ‘finished’
[17:01:21.145] - run: TRUE
[17:01:21.145] - result: ‘FutureResult’
[17:01:21.145] resolved() for ‘SequentialFuture’ ... done
[17:01:21.145] Future #1
[17:01:21.145] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:21.145] - nx: 1
[17:01:21.145] - relay: TRUE
[17:01:21.145] - stdout: TRUE
[17:01:21.145] - signal: TRUE
[17:01:21.145] - resignal: FALSE
[17:01:21.145] - force: TRUE
[17:01:21.146] - relayed: [n=1] FALSE
[17:01:21.146] - queued futures: [n=1] FALSE
[17:01:21.146]  - until=1
[17:01:21.146]  - relaying element #1
[17:01:21.146] - relayed: [n=1] TRUE
[17:01:21.146] - queued futures: [n=1] TRUE
[17:01:21.146] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:21.146]  length: 0 (resolved future 1)
[17:01:21.146] Relaying remaining futures
[17:01:21.147] signalConditionsASAP(NULL, pos=0) ...
[17:01:21.147] - nx: 1
[17:01:21.147] - relay: TRUE
[17:01:21.147] - stdout: TRUE
[17:01:21.147] - signal: TRUE
[17:01:21.147] - resignal: FALSE
[17:01:21.147] - force: TRUE
[17:01:21.147] - relayed: [n=1] TRUE
[17:01:21.147] - queued futures: [n=1] TRUE
 - flush all
[17:01:21.147] - relayed: [n=1] TRUE
[17:01:21.147] - queued futures: [n=1] TRUE
[17:01:21.148] signalConditionsASAP(NULL, pos=0) ... done
[17:01:21.148] resolve() on list ... DONE
[17:01:21.148]  - Number of value chunks collected: 1
[17:01:21.148] Resolving 1 futures (chunks) ... DONE
[17:01:21.148] Reducing values from 1 chunks ...
[17:01:21.148]  - Number of values collected after concatenation: 2
[17:01:21.148]  - Number of values expected: 2
[17:01:21.148] Reducing values from 1 chunks ... DONE
[17:01:21.148] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:01:21.149] future_mapply() ...
[17:01:21.152] Number of chunks: 1
[17:01:21.152] getGlobalsAndPackagesXApply() ...
[17:01:21.152]  - future.globals: TRUE
[17:01:21.153] getGlobalsAndPackages() ...
[17:01:21.153] Searching for globals...
[17:01:21.154] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:21.154] Searching for globals ... DONE
[17:01:21.154] Resolving globals: FALSE
[17:01:21.155] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:21.157] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:21.157] - globals: [1] ‘FUN’
[17:01:21.157] 
[17:01:21.157] getGlobalsAndPackages() ... DONE
[17:01:21.158]  - globals found/used: [n=1] ‘FUN’
[17:01:21.158]  - needed namespaces: [n=0] 
[17:01:21.158] Finding globals ... DONE
[17:01:21.158] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:21.158] List of 2
[17:01:21.158]  $ ...future.FUN:function (x, y)  
[17:01:21.158]  $ MoreArgs     : NULL
[17:01:21.158]  - attr(*, "where")=List of 2
[17:01:21.158]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:21.158]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:21.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:21.158]  - attr(*, "resolved")= logi FALSE
[17:01:21.158]  - attr(*, "total_size")= num NA
[17:01:21.161] Packages to be attached in all futures: [n=0] 
[17:01:21.161] getGlobalsAndPackagesXApply() ... DONE
[17:01:21.161] Number of futures (= number of chunks): 1
[17:01:21.161] Launching 1 futures (chunks) ...
[17:01:21.161] Chunk #1 of 1 ...
[17:01:21.161]  - Finding globals in '...' for chunk #1 ...
[17:01:21.161] getGlobalsAndPackages() ...
[17:01:21.161] Searching for globals...
[17:01:21.162] 
[17:01:21.162] Searching for globals ... DONE
[17:01:21.162] - globals: [0] <none>
[17:01:21.162] getGlobalsAndPackages() ... DONE
[17:01:21.162]    + additional globals found: [n=0] 
[17:01:21.162]    + additional namespaces needed: [n=0] 
[17:01:21.162]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:21.162]  - seeds: <none>
[17:01:21.162]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:21.163] getGlobalsAndPackages() ...
[17:01:21.163] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:21.163] Resolving globals: FALSE
[17:01:21.163] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:01:21.164] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:21.164] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:21.164] 
[17:01:21.164] getGlobalsAndPackages() ... DONE
[17:01:21.164] run() for ‘Future’ ...
[17:01:21.165] - state: ‘created’
[17:01:21.165] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:21.169] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:21.169] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:21.169]   - Field: ‘label’
[17:01:21.169]   - Field: ‘local’
[17:01:21.169]   - Field: ‘owner’
[17:01:21.169]   - Field: ‘envir’
[17:01:21.170]   - Field: ‘packages’
[17:01:21.170]   - Field: ‘gc’
[17:01:21.170]   - Field: ‘conditions’
[17:01:21.170]   - Field: ‘expr’
[17:01:21.170]   - Field: ‘uuid’
[17:01:21.170]   - Field: ‘seed’
[17:01:21.170]   - Field: ‘version’
[17:01:21.170]   - Field: ‘result’
[17:01:21.170]   - Field: ‘asynchronous’
[17:01:21.171]   - Field: ‘calls’
[17:01:21.171]   - Field: ‘globals’
[17:01:21.171]   - Field: ‘stdout’
[17:01:21.171]   - Field: ‘earlySignal’
[17:01:21.171]   - Field: ‘lazy’
[17:01:21.171]   - Field: ‘state’
[17:01:21.171] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:21.171] - Launch lazy future ...
[17:01:21.171] Packages needed by the future expression (n = 0): <none>
[17:01:21.172] Packages needed by future strategies (n = 0): <none>
[17:01:21.172] {
[17:01:21.172]     {
[17:01:21.172]         {
[17:01:21.172]             ...future.startTime <- base::Sys.time()
[17:01:21.172]             {
[17:01:21.172]                 {
[17:01:21.172]                   {
[17:01:21.172]                     base::local({
[17:01:21.172]                       has_future <- base::requireNamespace("future", 
[17:01:21.172]                         quietly = TRUE)
[17:01:21.172]                       if (has_future) {
[17:01:21.172]                         ns <- base::getNamespace("future")
[17:01:21.172]                         version <- ns[[".package"]][["version"]]
[17:01:21.172]                         if (is.null(version)) 
[17:01:21.172]                           version <- utils::packageVersion("future")
[17:01:21.172]                       }
[17:01:21.172]                       else {
[17:01:21.172]                         version <- NULL
[17:01:21.172]                       }
[17:01:21.172]                       if (!has_future || version < "1.8.0") {
[17:01:21.172]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:21.172]                           "", base::R.version$version.string), 
[17:01:21.172]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:21.172]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:21.172]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:21.172]                             "release", "version")], collapse = " "), 
[17:01:21.172]                           hostname = base::Sys.info()[["nodename"]])
[17:01:21.172]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:21.172]                           info)
[17:01:21.172]                         info <- base::paste(info, collapse = "; ")
[17:01:21.172]                         if (!has_future) {
[17:01:21.172]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:21.172]                             info)
[17:01:21.172]                         }
[17:01:21.172]                         else {
[17:01:21.172]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:21.172]                             info, version)
[17:01:21.172]                         }
[17:01:21.172]                         base::stop(msg)
[17:01:21.172]                       }
[17:01:21.172]                     })
[17:01:21.172]                   }
[17:01:21.172]                   ...future.strategy.old <- future::plan("list")
[17:01:21.172]                   options(future.plan = NULL)
[17:01:21.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:21.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:21.172]                 }
[17:01:21.172]                 ...future.workdir <- getwd()
[17:01:21.172]             }
[17:01:21.172]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:21.172]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:21.172]         }
[17:01:21.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:21.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:21.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:21.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:21.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:21.172]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:21.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:21.172]             base::names(...future.oldOptions))
[17:01:21.172]     }
[17:01:21.172]     if (FALSE) {
[17:01:21.172]     }
[17:01:21.172]     else {
[17:01:21.172]         if (TRUE) {
[17:01:21.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:21.172]                 open = "w")
[17:01:21.172]         }
[17:01:21.172]         else {
[17:01:21.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:21.172]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:21.172]         }
[17:01:21.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:21.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:21.172]             base::sink(type = "output", split = FALSE)
[17:01:21.172]             base::close(...future.stdout)
[17:01:21.172]         }, add = TRUE)
[17:01:21.172]     }
[17:01:21.172]     ...future.frame <- base::sys.nframe()
[17:01:21.172]     ...future.conditions <- base::list()
[17:01:21.172]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:21.172]     if (FALSE) {
[17:01:21.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:21.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:21.172]     }
[17:01:21.172]     ...future.result <- base::tryCatch({
[17:01:21.172]         base::withCallingHandlers({
[17:01:21.172]             ...future.value <- base::withVisible(base::local({
[17:01:21.172]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:21.172]                 if (!identical(...future.globals.maxSize.org, 
[17:01:21.172]                   ...future.globals.maxSize)) {
[17:01:21.172]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:21.172]                   on.exit(options(oopts), add = TRUE)
[17:01:21.172]                 }
[17:01:21.172]                 {
[17:01:21.172]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:21.172]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:21.172]                     USE.NAMES = FALSE)
[17:01:21.172]                   do.call(mapply, args = args)
[17:01:21.172]                 }
[17:01:21.172]             }))
[17:01:21.172]             future::FutureResult(value = ...future.value$value, 
[17:01:21.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:21.172]                   ...future.rng), globalenv = if (FALSE) 
[17:01:21.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:21.172]                     ...future.globalenv.names))
[17:01:21.172]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:21.172]         }, condition = base::local({
[17:01:21.172]             c <- base::c
[17:01:21.172]             inherits <- base::inherits
[17:01:21.172]             invokeRestart <- base::invokeRestart
[17:01:21.172]             length <- base::length
[17:01:21.172]             list <- base::list
[17:01:21.172]             seq.int <- base::seq.int
[17:01:21.172]             signalCondition <- base::signalCondition
[17:01:21.172]             sys.calls <- base::sys.calls
[17:01:21.172]             `[[` <- base::`[[`
[17:01:21.172]             `+` <- base::`+`
[17:01:21.172]             `<<-` <- base::`<<-`
[17:01:21.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:21.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:21.172]                   3L)]
[17:01:21.172]             }
[17:01:21.172]             function(cond) {
[17:01:21.172]                 is_error <- inherits(cond, "error")
[17:01:21.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:21.172]                   NULL)
[17:01:21.172]                 if (is_error) {
[17:01:21.172]                   sessionInformation <- function() {
[17:01:21.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:21.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:21.172]                       search = base::search(), system = base::Sys.info())
[17:01:21.172]                   }
[17:01:21.172]                   ...future.conditions[[length(...future.conditions) + 
[17:01:21.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:21.172]                     cond$call), session = sessionInformation(), 
[17:01:21.172]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:21.172]                   signalCondition(cond)
[17:01:21.172]                 }
[17:01:21.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:21.172]                 "immediateCondition"))) {
[17:01:21.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:21.172]                   ...future.conditions[[length(...future.conditions) + 
[17:01:21.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:21.172]                   if (TRUE && !signal) {
[17:01:21.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:21.172]                     {
[17:01:21.172]                       inherits <- base::inherits
[17:01:21.172]                       invokeRestart <- base::invokeRestart
[17:01:21.172]                       is.null <- base::is.null
[17:01:21.172]                       muffled <- FALSE
[17:01:21.172]                       if (inherits(cond, "message")) {
[17:01:21.172]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:21.172]                         if (muffled) 
[17:01:21.172]                           invokeRestart("muffleMessage")
[17:01:21.172]                       }
[17:01:21.172]                       else if (inherits(cond, "warning")) {
[17:01:21.172]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:21.172]                         if (muffled) 
[17:01:21.172]                           invokeRestart("muffleWarning")
[17:01:21.172]                       }
[17:01:21.172]                       else if (inherits(cond, "condition")) {
[17:01:21.172]                         if (!is.null(pattern)) {
[17:01:21.172]                           computeRestarts <- base::computeRestarts
[17:01:21.172]                           grepl <- base::grepl
[17:01:21.172]                           restarts <- computeRestarts(cond)
[17:01:21.172]                           for (restart in restarts) {
[17:01:21.172]                             name <- restart$name
[17:01:21.172]                             if (is.null(name)) 
[17:01:21.172]                               next
[17:01:21.172]                             if (!grepl(pattern, name)) 
[17:01:21.172]                               next
[17:01:21.172]                             invokeRestart(restart)
[17:01:21.172]                             muffled <- TRUE
[17:01:21.172]                             break
[17:01:21.172]                           }
[17:01:21.172]                         }
[17:01:21.172]                       }
[17:01:21.172]                       invisible(muffled)
[17:01:21.172]                     }
[17:01:21.172]                     muffleCondition(cond, pattern = "^muffle")
[17:01:21.172]                   }
[17:01:21.172]                 }
[17:01:21.172]                 else {
[17:01:21.172]                   if (TRUE) {
[17:01:21.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:21.172]                     {
[17:01:21.172]                       inherits <- base::inherits
[17:01:21.172]                       invokeRestart <- base::invokeRestart
[17:01:21.172]                       is.null <- base::is.null
[17:01:21.172]                       muffled <- FALSE
[17:01:21.172]                       if (inherits(cond, "message")) {
[17:01:21.172]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:21.172]                         if (muffled) 
[17:01:21.172]                           invokeRestart("muffleMessage")
[17:01:21.172]                       }
[17:01:21.172]                       else if (inherits(cond, "warning")) {
[17:01:21.172]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:21.172]                         if (muffled) 
[17:01:21.172]                           invokeRestart("muffleWarning")
[17:01:21.172]                       }
[17:01:21.172]                       else if (inherits(cond, "condition")) {
[17:01:21.172]                         if (!is.null(pattern)) {
[17:01:21.172]                           computeRestarts <- base::computeRestarts
[17:01:21.172]                           grepl <- base::grepl
[17:01:21.172]                           restarts <- computeRestarts(cond)
[17:01:21.172]                           for (restart in restarts) {
[17:01:21.172]                             name <- restart$name
[17:01:21.172]                             if (is.null(name)) 
[17:01:21.172]                               next
[17:01:21.172]                             if (!grepl(pattern, name)) 
[17:01:21.172]                               next
[17:01:21.172]                             invokeRestart(restart)
[17:01:21.172]                             muffled <- TRUE
[17:01:21.172]                             break
[17:01:21.172]                           }
[17:01:21.172]                         }
[17:01:21.172]                       }
[17:01:21.172]                       invisible(muffled)
[17:01:21.172]                     }
[17:01:21.172]                     muffleCondition(cond, pattern = "^muffle")
[17:01:21.172]                   }
[17:01:21.172]                 }
[17:01:21.172]             }
[17:01:21.172]         }))
[17:01:21.172]     }, error = function(ex) {
[17:01:21.172]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:21.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:21.172]                 ...future.rng), started = ...future.startTime, 
[17:01:21.172]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:21.172]             version = "1.8"), class = "FutureResult")
[17:01:21.172]     }, finally = {
[17:01:21.172]         if (!identical(...future.workdir, getwd())) 
[17:01:21.172]             setwd(...future.workdir)
[17:01:21.172]         {
[17:01:21.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:21.172]                 ...future.oldOptions$nwarnings <- NULL
[17:01:21.172]             }
[17:01:21.172]             base::options(...future.oldOptions)
[17:01:21.172]             if (.Platform$OS.type == "windows") {
[17:01:21.172]                 old_names <- names(...future.oldEnvVars)
[17:01:21.172]                 envs <- base::Sys.getenv()
[17:01:21.172]                 names <- names(envs)
[17:01:21.172]                 common <- intersect(names, old_names)
[17:01:21.172]                 added <- setdiff(names, old_names)
[17:01:21.172]                 removed <- setdiff(old_names, names)
[17:01:21.172]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:21.172]                   envs[common]]
[17:01:21.172]                 NAMES <- toupper(changed)
[17:01:21.172]                 args <- list()
[17:01:21.172]                 for (kk in seq_along(NAMES)) {
[17:01:21.172]                   name <- changed[[kk]]
[17:01:21.172]                   NAME <- NAMES[[kk]]
[17:01:21.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:21.172]                     next
[17:01:21.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:21.172]                 }
[17:01:21.172]                 NAMES <- toupper(added)
[17:01:21.172]                 for (kk in seq_along(NAMES)) {
[17:01:21.172]                   name <- added[[kk]]
[17:01:21.172]                   NAME <- NAMES[[kk]]
[17:01:21.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:21.172]                     next
[17:01:21.172]                   args[[name]] <- ""
[17:01:21.172]                 }
[17:01:21.172]                 NAMES <- toupper(removed)
[17:01:21.172]                 for (kk in seq_along(NAMES)) {
[17:01:21.172]                   name <- removed[[kk]]
[17:01:21.172]                   NAME <- NAMES[[kk]]
[17:01:21.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:21.172]                     next
[17:01:21.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:21.172]                 }
[17:01:21.172]                 if (length(args) > 0) 
[17:01:21.172]                   base::do.call(base::Sys.setenv, args = args)
[17:01:21.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:21.172]             }
[17:01:21.172]             else {
[17:01:21.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:21.172]             }
[17:01:21.172]             {
[17:01:21.172]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:21.172]                   0L) {
[17:01:21.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:21.172]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:21.172]                   base::options(opts)
[17:01:21.172]                 }
[17:01:21.172]                 {
[17:01:21.172]                   {
[17:01:21.172]                     NULL
[17:01:21.172]                     RNGkind("Mersenne-Twister")
[17:01:21.172]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:21.172]                       inherits = FALSE)
[17:01:21.172]                   }
[17:01:21.172]                   options(future.plan = NULL)
[17:01:21.172]                   if (is.na(NA_character_)) 
[17:01:21.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:21.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:21.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:21.172]                     .init = FALSE)
[17:01:21.172]                 }
[17:01:21.172]             }
[17:01:21.172]         }
[17:01:21.172]     })
[17:01:21.172]     if (TRUE) {
[17:01:21.172]         base::sink(type = "output", split = FALSE)
[17:01:21.172]         if (TRUE) {
[17:01:21.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:21.172]         }
[17:01:21.172]         else {
[17:01:21.172]             ...future.result["stdout"] <- base::list(NULL)
[17:01:21.172]         }
[17:01:21.172]         base::close(...future.stdout)
[17:01:21.172]         ...future.stdout <- NULL
[17:01:21.172]     }
[17:01:21.172]     ...future.result$conditions <- ...future.conditions
[17:01:21.172]     ...future.result$finished <- base::Sys.time()
[17:01:21.172]     ...future.result
[17:01:21.172] }
[17:01:21.174] assign_globals() ...
[17:01:21.174] List of 5
[17:01:21.174]  $ ...future.FUN            :function (x, y)  
[17:01:21.174]  $ MoreArgs                 : NULL
[17:01:21.174]  $ ...future.elements_ii    :List of 2
[17:01:21.174]   ..$ :List of 2
[17:01:21.174]   .. ..$ : int 1
[17:01:21.174]   .. ..$ : int 0
[17:01:21.174]   ..$ :List of 2
[17:01:21.174]   .. ..$ : int 0
[17:01:21.174]   .. ..$ : int 1
[17:01:21.174]  $ ...future.seeds_ii       : NULL
[17:01:21.174]  $ ...future.globals.maxSize: NULL
[17:01:21.174]  - attr(*, "where")=List of 5
[17:01:21.174]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:21.174]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:21.174]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:21.174]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:21.174]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:21.174]  - attr(*, "resolved")= logi FALSE
[17:01:21.174]  - attr(*, "total_size")= num 6480
[17:01:21.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:21.174]  - attr(*, "already-done")= logi TRUE
[17:01:21.180] - reassign environment for ‘...future.FUN’
[17:01:21.180] - copied ‘...future.FUN’ to environment
[17:01:21.180] - copied ‘MoreArgs’ to environment
[17:01:21.180] - copied ‘...future.elements_ii’ to environment
[17:01:21.180] - copied ‘...future.seeds_ii’ to environment
[17:01:21.180] - copied ‘...future.globals.maxSize’ to environment
[17:01:21.180] assign_globals() ... done
[17:01:21.180] plan(): Setting new future strategy stack:
[17:01:21.180] List of future strategies:
[17:01:21.180] 1. sequential:
[17:01:21.180]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:21.180]    - tweaked: FALSE
[17:01:21.180]    - call: NULL
[17:01:21.181] plan(): nbrOfWorkers() = 1
[17:01:21.683] plan(): Setting new future strategy stack:
[17:01:21.683] List of future strategies:
[17:01:21.683] 1. multicore:
[17:01:21.683]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:21.683]    - tweaked: FALSE
[17:01:21.683]    - call: plan(strategy)
[17:01:21.687] plan(): nbrOfWorkers() = 1
[17:01:21.687] SequentialFuture started (and completed)
[17:01:21.687] - Launch lazy future ... done
[17:01:21.687] run() for ‘SequentialFuture’ ... done
[17:01:21.687] Created future:
[17:01:21.688] SequentialFuture:
[17:01:21.688] Label: ‘future_mapply-1’
[17:01:21.688] Expression:
[17:01:21.688] {
[17:01:21.688]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:21.688]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:21.688]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:21.688]         on.exit(options(oopts), add = TRUE)
[17:01:21.688]     }
[17:01:21.688]     {
[17:01:21.688]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:21.688]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:21.688]         do.call(mapply, args = args)
[17:01:21.688]     }
[17:01:21.688] }
[17:01:21.688] Lazy evaluation: FALSE
[17:01:21.688] Asynchronous evaluation: FALSE
[17:01:21.688] Local evaluation: TRUE
[17:01:21.688] Environment: R_GlobalEnv
[17:01:21.688] Capture standard output: TRUE
[17:01:21.688] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:21.688] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:21.688] Packages: <none>
[17:01:21.688] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:21.688] Resolved: TRUE
[17:01:21.688] Value: 224 bytes of class ‘list’
[17:01:21.688] Early signaling: FALSE
[17:01:21.688] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:21.688] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:21.689] Chunk #1 of 1 ... DONE
[17:01:21.689] Launching 1 futures (chunks) ... DONE
[17:01:21.689] Resolving 1 futures (chunks) ...
[17:01:21.689] resolve() on list ...
[17:01:21.689]  recursive: 0
[17:01:21.689]  length: 1
[17:01:21.691] 
[17:01:21.691] resolved() for ‘SequentialFuture’ ...
[17:01:21.691] - state: ‘finished’
[17:01:21.691] - run: TRUE
[17:01:21.691] - result: ‘FutureResult’
[17:01:21.692] resolved() for ‘SequentialFuture’ ... done
[17:01:21.692] Future #1
[17:01:21.692] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:21.692] - nx: 1
[17:01:21.692] - relay: TRUE
[17:01:21.692] - stdout: TRUE
[17:01:21.692] - signal: TRUE
[17:01:21.692] - resignal: FALSE
[17:01:21.692] - force: TRUE
[17:01:21.693] - relayed: [n=1] FALSE
[17:01:21.693] - queued futures: [n=1] FALSE
[17:01:21.693]  - until=1
[17:01:21.693]  - relaying element #1
[17:01:21.693] - relayed: [n=1] TRUE
[17:01:21.693] - queued futures: [n=1] TRUE
[17:01:21.693] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:21.693]  length: 0 (resolved future 1)
[17:01:21.693] Relaying remaining futures
[17:01:21.693] signalConditionsASAP(NULL, pos=0) ...
[17:01:21.694] - nx: 1
[17:01:21.694] - relay: TRUE
[17:01:21.694] - stdout: TRUE
[17:01:21.694] - signal: TRUE
[17:01:21.694] - resignal: FALSE
[17:01:21.694] - force: TRUE
[17:01:21.694] - relayed: [n=1] TRUE
[17:01:21.694] - queued futures: [n=1] TRUE
 - flush all
[17:01:21.694] - relayed: [n=1] TRUE
[17:01:21.694] - queued futures: [n=1] TRUE
[17:01:21.694] signalConditionsASAP(NULL, pos=0) ... done
[17:01:21.695] resolve() on list ... DONE
[17:01:21.695]  - Number of value chunks collected: 1
[17:01:21.695] Resolving 1 futures (chunks) ... DONE
[17:01:21.695] Reducing values from 1 chunks ...
[17:01:21.695]  - Number of values collected after concatenation: 2
[17:01:21.695]  - Number of values expected: 2
[17:01:21.695] Reducing values from 1 chunks ... DONE
[17:01:21.695] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:01:21.696] future_mapply() ...
[17:01:21.699] Number of chunks: 1
[17:01:21.699] getGlobalsAndPackagesXApply() ...
[17:01:21.699]  - future.globals: TRUE
[17:01:21.699] getGlobalsAndPackages() ...
[17:01:21.699] Searching for globals...
[17:01:21.701] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:21.701] Searching for globals ... DONE
[17:01:21.701] Resolving globals: FALSE
[17:01:21.702] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:21.702] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:21.702] - globals: [1] ‘FUN’
[17:01:21.702] 
[17:01:21.702] getGlobalsAndPackages() ... DONE
[17:01:21.702]  - globals found/used: [n=1] ‘FUN’
[17:01:21.702]  - needed namespaces: [n=0] 
[17:01:21.702] Finding globals ... DONE
[17:01:21.703] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:21.703] List of 2
[17:01:21.703]  $ ...future.FUN:function (x, y)  
[17:01:21.703]  $ MoreArgs     : NULL
[17:01:21.703]  - attr(*, "where")=List of 2
[17:01:21.703]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:21.703]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:21.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:21.703]  - attr(*, "resolved")= logi FALSE
[17:01:21.703]  - attr(*, "total_size")= num NA
[17:01:21.705] Packages to be attached in all futures: [n=0] 
[17:01:21.705] getGlobalsAndPackagesXApply() ... DONE
[17:01:21.706] Number of futures (= number of chunks): 1
[17:01:21.706] Launching 1 futures (chunks) ...
[17:01:21.706] Chunk #1 of 1 ...
[17:01:21.706]  - Finding globals in '...' for chunk #1 ...
[17:01:21.706] getGlobalsAndPackages() ...
[17:01:21.706] Searching for globals...
[17:01:21.706] 
[17:01:21.706] Searching for globals ... DONE
[17:01:21.707] - globals: [0] <none>
[17:01:21.707] getGlobalsAndPackages() ... DONE
[17:01:21.707]    + additional globals found: [n=0] 
[17:01:21.707]    + additional namespaces needed: [n=0] 
[17:01:21.707]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:21.707]  - seeds: <none>
[17:01:21.707]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:21.707] getGlobalsAndPackages() ...
[17:01:21.707] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:21.707] Resolving globals: FALSE
[17:01:21.708] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:01:21.708] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:21.708] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:21.709] 
[17:01:21.709] getGlobalsAndPackages() ... DONE
[17:01:21.709] run() for ‘Future’ ...
[17:01:21.709] - state: ‘created’
[17:01:21.709] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:21.713] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:21.713] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:21.713]   - Field: ‘label’
[17:01:21.713]   - Field: ‘local’
[17:01:21.713]   - Field: ‘owner’
[17:01:21.713]   - Field: ‘envir’
[17:01:21.713]   - Field: ‘packages’
[17:01:21.713]   - Field: ‘gc’
[17:01:21.714]   - Field: ‘conditions’
[17:01:21.714]   - Field: ‘expr’
[17:01:21.714]   - Field: ‘uuid’
[17:01:21.714]   - Field: ‘seed’
[17:01:21.714]   - Field: ‘version’
[17:01:21.714]   - Field: ‘result’
[17:01:21.714]   - Field: ‘asynchronous’
[17:01:21.714]   - Field: ‘calls’
[17:01:21.714]   - Field: ‘globals’
[17:01:21.714]   - Field: ‘stdout’
[17:01:21.714]   - Field: ‘earlySignal’
[17:01:21.715]   - Field: ‘lazy’
[17:01:21.715]   - Field: ‘state’
[17:01:21.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:21.715] - Launch lazy future ...
[17:01:21.715] Packages needed by the future expression (n = 0): <none>
[17:01:21.715] Packages needed by future strategies (n = 0): <none>
[17:01:21.716] {
[17:01:21.716]     {
[17:01:21.716]         {
[17:01:21.716]             ...future.startTime <- base::Sys.time()
[17:01:21.716]             {
[17:01:21.716]                 {
[17:01:21.716]                   {
[17:01:21.716]                     base::local({
[17:01:21.716]                       has_future <- base::requireNamespace("future", 
[17:01:21.716]                         quietly = TRUE)
[17:01:21.716]                       if (has_future) {
[17:01:21.716]                         ns <- base::getNamespace("future")
[17:01:21.716]                         version <- ns[[".package"]][["version"]]
[17:01:21.716]                         if (is.null(version)) 
[17:01:21.716]                           version <- utils::packageVersion("future")
[17:01:21.716]                       }
[17:01:21.716]                       else {
[17:01:21.716]                         version <- NULL
[17:01:21.716]                       }
[17:01:21.716]                       if (!has_future || version < "1.8.0") {
[17:01:21.716]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:21.716]                           "", base::R.version$version.string), 
[17:01:21.716]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:21.716]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:21.716]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:21.716]                             "release", "version")], collapse = " "), 
[17:01:21.716]                           hostname = base::Sys.info()[["nodename"]])
[17:01:21.716]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:21.716]                           info)
[17:01:21.716]                         info <- base::paste(info, collapse = "; ")
[17:01:21.716]                         if (!has_future) {
[17:01:21.716]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:21.716]                             info)
[17:01:21.716]                         }
[17:01:21.716]                         else {
[17:01:21.716]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:21.716]                             info, version)
[17:01:21.716]                         }
[17:01:21.716]                         base::stop(msg)
[17:01:21.716]                       }
[17:01:21.716]                     })
[17:01:21.716]                   }
[17:01:21.716]                   ...future.strategy.old <- future::plan("list")
[17:01:21.716]                   options(future.plan = NULL)
[17:01:21.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:21.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:21.716]                 }
[17:01:21.716]                 ...future.workdir <- getwd()
[17:01:21.716]             }
[17:01:21.716]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:21.716]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:21.716]         }
[17:01:21.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:21.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:21.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:21.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:21.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:21.716]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:21.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:21.716]             base::names(...future.oldOptions))
[17:01:21.716]     }
[17:01:21.716]     if (TRUE) {
[17:01:21.716]     }
[17:01:21.716]     else {
[17:01:21.716]         if (NA) {
[17:01:21.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:21.716]                 open = "w")
[17:01:21.716]         }
[17:01:21.716]         else {
[17:01:21.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:21.716]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:21.716]         }
[17:01:21.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:21.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:21.716]             base::sink(type = "output", split = FALSE)
[17:01:21.716]             base::close(...future.stdout)
[17:01:21.716]         }, add = TRUE)
[17:01:21.716]     }
[17:01:21.716]     ...future.frame <- base::sys.nframe()
[17:01:21.716]     ...future.conditions <- base::list()
[17:01:21.716]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:21.716]     if (FALSE) {
[17:01:21.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:21.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:21.716]     }
[17:01:21.716]     ...future.result <- base::tryCatch({
[17:01:21.716]         base::withCallingHandlers({
[17:01:21.716]             ...future.value <- base::withVisible(base::local({
[17:01:21.716]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:21.716]                 if (!identical(...future.globals.maxSize.org, 
[17:01:21.716]                   ...future.globals.maxSize)) {
[17:01:21.716]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:21.716]                   on.exit(options(oopts), add = TRUE)
[17:01:21.716]                 }
[17:01:21.716]                 {
[17:01:21.716]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:21.716]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:21.716]                     USE.NAMES = FALSE)
[17:01:21.716]                   do.call(mapply, args = args)
[17:01:21.716]                 }
[17:01:21.716]             }))
[17:01:21.716]             future::FutureResult(value = ...future.value$value, 
[17:01:21.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:21.716]                   ...future.rng), globalenv = if (FALSE) 
[17:01:21.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:21.716]                     ...future.globalenv.names))
[17:01:21.716]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:21.716]         }, condition = base::local({
[17:01:21.716]             c <- base::c
[17:01:21.716]             inherits <- base::inherits
[17:01:21.716]             invokeRestart <- base::invokeRestart
[17:01:21.716]             length <- base::length
[17:01:21.716]             list <- base::list
[17:01:21.716]             seq.int <- base::seq.int
[17:01:21.716]             signalCondition <- base::signalCondition
[17:01:21.716]             sys.calls <- base::sys.calls
[17:01:21.716]             `[[` <- base::`[[`
[17:01:21.716]             `+` <- base::`+`
[17:01:21.716]             `<<-` <- base::`<<-`
[17:01:21.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:21.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:21.716]                   3L)]
[17:01:21.716]             }
[17:01:21.716]             function(cond) {
[17:01:21.716]                 is_error <- inherits(cond, "error")
[17:01:21.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:21.716]                   NULL)
[17:01:21.716]                 if (is_error) {
[17:01:21.716]                   sessionInformation <- function() {
[17:01:21.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:21.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:21.716]                       search = base::search(), system = base::Sys.info())
[17:01:21.716]                   }
[17:01:21.716]                   ...future.conditions[[length(...future.conditions) + 
[17:01:21.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:21.716]                     cond$call), session = sessionInformation(), 
[17:01:21.716]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:21.716]                   signalCondition(cond)
[17:01:21.716]                 }
[17:01:21.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:21.716]                 "immediateCondition"))) {
[17:01:21.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:21.716]                   ...future.conditions[[length(...future.conditions) + 
[17:01:21.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:21.716]                   if (TRUE && !signal) {
[17:01:21.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:21.716]                     {
[17:01:21.716]                       inherits <- base::inherits
[17:01:21.716]                       invokeRestart <- base::invokeRestart
[17:01:21.716]                       is.null <- base::is.null
[17:01:21.716]                       muffled <- FALSE
[17:01:21.716]                       if (inherits(cond, "message")) {
[17:01:21.716]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:21.716]                         if (muffled) 
[17:01:21.716]                           invokeRestart("muffleMessage")
[17:01:21.716]                       }
[17:01:21.716]                       else if (inherits(cond, "warning")) {
[17:01:21.716]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:21.716]                         if (muffled) 
[17:01:21.716]                           invokeRestart("muffleWarning")
[17:01:21.716]                       }
[17:01:21.716]                       else if (inherits(cond, "condition")) {
[17:01:21.716]                         if (!is.null(pattern)) {
[17:01:21.716]                           computeRestarts <- base::computeRestarts
[17:01:21.716]                           grepl <- base::grepl
[17:01:21.716]                           restarts <- computeRestarts(cond)
[17:01:21.716]                           for (restart in restarts) {
[17:01:21.716]                             name <- restart$name
[17:01:21.716]                             if (is.null(name)) 
[17:01:21.716]                               next
[17:01:21.716]                             if (!grepl(pattern, name)) 
[17:01:21.716]                               next
[17:01:21.716]                             invokeRestart(restart)
[17:01:21.716]                             muffled <- TRUE
[17:01:21.716]                             break
[17:01:21.716]                           }
[17:01:21.716]                         }
[17:01:21.716]                       }
[17:01:21.716]                       invisible(muffled)
[17:01:21.716]                     }
[17:01:21.716]                     muffleCondition(cond, pattern = "^muffle")
[17:01:21.716]                   }
[17:01:21.716]                 }
[17:01:21.716]                 else {
[17:01:21.716]                   if (TRUE) {
[17:01:21.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:21.716]                     {
[17:01:21.716]                       inherits <- base::inherits
[17:01:21.716]                       invokeRestart <- base::invokeRestart
[17:01:21.716]                       is.null <- base::is.null
[17:01:21.716]                       muffled <- FALSE
[17:01:21.716]                       if (inherits(cond, "message")) {
[17:01:21.716]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:21.716]                         if (muffled) 
[17:01:21.716]                           invokeRestart("muffleMessage")
[17:01:21.716]                       }
[17:01:21.716]                       else if (inherits(cond, "warning")) {
[17:01:21.716]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:21.716]                         if (muffled) 
[17:01:21.716]                           invokeRestart("muffleWarning")
[17:01:21.716]                       }
[17:01:21.716]                       else if (inherits(cond, "condition")) {
[17:01:21.716]                         if (!is.null(pattern)) {
[17:01:21.716]                           computeRestarts <- base::computeRestarts
[17:01:21.716]                           grepl <- base::grepl
[17:01:21.716]                           restarts <- computeRestarts(cond)
[17:01:21.716]                           for (restart in restarts) {
[17:01:21.716]                             name <- restart$name
[17:01:21.716]                             if (is.null(name)) 
[17:01:21.716]                               next
[17:01:21.716]                             if (!grepl(pattern, name)) 
[17:01:21.716]                               next
[17:01:21.716]                             invokeRestart(restart)
[17:01:21.716]                             muffled <- TRUE
[17:01:21.716]                             break
[17:01:21.716]                           }
[17:01:21.716]                         }
[17:01:21.716]                       }
[17:01:21.716]                       invisible(muffled)
[17:01:21.716]                     }
[17:01:21.716]                     muffleCondition(cond, pattern = "^muffle")
[17:01:21.716]                   }
[17:01:21.716]                 }
[17:01:21.716]             }
[17:01:21.716]         }))
[17:01:21.716]     }, error = function(ex) {
[17:01:21.716]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:21.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:21.716]                 ...future.rng), started = ...future.startTime, 
[17:01:21.716]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:21.716]             version = "1.8"), class = "FutureResult")
[17:01:21.716]     }, finally = {
[17:01:21.716]         if (!identical(...future.workdir, getwd())) 
[17:01:21.716]             setwd(...future.workdir)
[17:01:21.716]         {
[17:01:21.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:21.716]                 ...future.oldOptions$nwarnings <- NULL
[17:01:21.716]             }
[17:01:21.716]             base::options(...future.oldOptions)
[17:01:21.716]             if (.Platform$OS.type == "windows") {
[17:01:21.716]                 old_names <- names(...future.oldEnvVars)
[17:01:21.716]                 envs <- base::Sys.getenv()
[17:01:21.716]                 names <- names(envs)
[17:01:21.716]                 common <- intersect(names, old_names)
[17:01:21.716]                 added <- setdiff(names, old_names)
[17:01:21.716]                 removed <- setdiff(old_names, names)
[17:01:21.716]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:21.716]                   envs[common]]
[17:01:21.716]                 NAMES <- toupper(changed)
[17:01:21.716]                 args <- list()
[17:01:21.716]                 for (kk in seq_along(NAMES)) {
[17:01:21.716]                   name <- changed[[kk]]
[17:01:21.716]                   NAME <- NAMES[[kk]]
[17:01:21.716]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:21.716]                     next
[17:01:21.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:21.716]                 }
[17:01:21.716]                 NAMES <- toupper(added)
[17:01:21.716]                 for (kk in seq_along(NAMES)) {
[17:01:21.716]                   name <- added[[kk]]
[17:01:21.716]                   NAME <- NAMES[[kk]]
[17:01:21.716]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:21.716]                     next
[17:01:21.716]                   args[[name]] <- ""
[17:01:21.716]                 }
[17:01:21.716]                 NAMES <- toupper(removed)
[17:01:21.716]                 for (kk in seq_along(NAMES)) {
[17:01:21.716]                   name <- removed[[kk]]
[17:01:21.716]                   NAME <- NAMES[[kk]]
[17:01:21.716]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:21.716]                     next
[17:01:21.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:21.716]                 }
[17:01:21.716]                 if (length(args) > 0) 
[17:01:21.716]                   base::do.call(base::Sys.setenv, args = args)
[17:01:21.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:21.716]             }
[17:01:21.716]             else {
[17:01:21.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:21.716]             }
[17:01:21.716]             {
[17:01:21.716]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:21.716]                   0L) {
[17:01:21.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:21.716]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:21.716]                   base::options(opts)
[17:01:21.716]                 }
[17:01:21.716]                 {
[17:01:21.716]                   {
[17:01:21.716]                     NULL
[17:01:21.716]                     RNGkind("Mersenne-Twister")
[17:01:21.716]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:21.716]                       inherits = FALSE)
[17:01:21.716]                   }
[17:01:21.716]                   options(future.plan = NULL)
[17:01:21.716]                   if (is.na(NA_character_)) 
[17:01:21.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:21.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:21.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:21.716]                     .init = FALSE)
[17:01:21.716]                 }
[17:01:21.716]             }
[17:01:21.716]         }
[17:01:21.716]     })
[17:01:21.716]     if (FALSE) {
[17:01:21.716]         base::sink(type = "output", split = FALSE)
[17:01:21.716]         if (NA) {
[17:01:21.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:21.716]         }
[17:01:21.716]         else {
[17:01:21.716]             ...future.result["stdout"] <- base::list(NULL)
[17:01:21.716]         }
[17:01:21.716]         base::close(...future.stdout)
[17:01:21.716]         ...future.stdout <- NULL
[17:01:21.716]     }
[17:01:21.716]     ...future.result$conditions <- ...future.conditions
[17:01:21.716]     ...future.result$finished <- base::Sys.time()
[17:01:21.716]     ...future.result
[17:01:21.716] }
[17:01:21.717] assign_globals() ...
[17:01:21.717] List of 5
[17:01:21.717]  $ ...future.FUN            :function (x, y)  
[17:01:21.717]  $ MoreArgs                 : NULL
[17:01:21.717]  $ ...future.elements_ii    :List of 2
[17:01:21.717]   ..$ :List of 2
[17:01:21.717]   .. ..$ : int 1
[17:01:21.717]   .. ..$ : int 0
[17:01:21.717]   ..$ :List of 2
[17:01:21.717]   .. ..$ : int 0
[17:01:21.717]   .. ..$ : int 1
[17:01:21.717]  $ ...future.seeds_ii       : NULL
[17:01:21.717]  $ ...future.globals.maxSize: NULL
[17:01:21.717]  - attr(*, "where")=List of 5
[17:01:21.717]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:21.717]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:21.717]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:21.717]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:21.717]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:21.717]  - attr(*, "resolved")= logi FALSE
[17:01:21.717]  - attr(*, "total_size")= num 6480
[17:01:21.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:21.717]  - attr(*, "already-done")= logi TRUE
[17:01:21.725] - reassign environment for ‘...future.FUN’
[17:01:21.725] - copied ‘...future.FUN’ to environment
[17:01:21.725] - copied ‘MoreArgs’ to environment
[17:01:21.725] - copied ‘...future.elements_ii’ to environment
[17:01:21.725] - copied ‘...future.seeds_ii’ to environment
[17:01:21.725] - copied ‘...future.globals.maxSize’ to environment
[17:01:21.725] assign_globals() ... done
[17:01:21.726] plan(): Setting new future strategy stack:
[17:01:21.726] List of future strategies:
[17:01:21.726] 1. sequential:
[17:01:21.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:21.726]    - tweaked: FALSE
[17:01:21.726]    - call: NULL
[17:01:21.726] plan(): nbrOfWorkers() = 1
[17:01:22.228] plan(): Setting new future strategy stack:
[17:01:22.228] List of future strategies:
[17:01:22.228] 1. multicore:
[17:01:22.228]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:22.228]    - tweaked: FALSE
[17:01:22.228]    - call: plan(strategy)
[17:01:22.232] plan(): nbrOfWorkers() = 1
[17:01:22.232] SequentialFuture started (and completed)
[17:01:22.232] - Launch lazy future ... done
[17:01:22.232] run() for ‘SequentialFuture’ ... done
[17:01:22.232] Created future:
[17:01:22.232] SequentialFuture:
[17:01:22.232] Label: ‘future_mapply-1’
[17:01:22.232] Expression:
[17:01:22.232] {
[17:01:22.232]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:22.232]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:22.232]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:22.232]         on.exit(options(oopts), add = TRUE)
[17:01:22.232]     }
[17:01:22.232]     {
[17:01:22.232]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:22.232]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:22.232]         do.call(mapply, args = args)
[17:01:22.232]     }
[17:01:22.232] }
[17:01:22.232] Lazy evaluation: FALSE
[17:01:22.232] Asynchronous evaluation: FALSE
[17:01:22.232] Local evaluation: TRUE
[17:01:22.232] Environment: R_GlobalEnv
[17:01:22.232] Capture standard output: NA
[17:01:22.232] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:22.232] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:22.232] Packages: <none>
[17:01:22.232] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:22.232] Resolved: TRUE
[17:01:22.232] Value: 224 bytes of class ‘list’
[17:01:22.232] Early signaling: FALSE
[17:01:22.232] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:22.232] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:22.233] Chunk #1 of 1 ... DONE
[17:01:22.233] Launching 1 futures (chunks) ... DONE
[17:01:22.234] Resolving 1 futures (chunks) ...
[17:01:22.234] resolve() on list ...
[17:01:22.234]  recursive: 0
[17:01:22.234]  length: 1
[17:01:22.234] 
[17:01:22.234] resolved() for ‘SequentialFuture’ ...
[17:01:22.234] - state: ‘finished’
[17:01:22.234] - run: TRUE
[17:01:22.234] - result: ‘FutureResult’
[17:01:22.234] resolved() for ‘SequentialFuture’ ... done
[17:01:22.235] Future #1
[17:01:22.235] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:22.235] - nx: 1
[17:01:22.235] - relay: TRUE
[17:01:22.235] - stdout: TRUE
[17:01:22.235] - signal: TRUE
[17:01:22.235] - resignal: FALSE
[17:01:22.235] - force: TRUE
[17:01:22.235] - relayed: [n=1] FALSE
[17:01:22.235] - queued futures: [n=1] FALSE
[17:01:22.236]  - until=1
[17:01:22.236]  - relaying element #1
[17:01:22.236] - relayed: [n=1] TRUE
[17:01:22.236] - queued futures: [n=1] TRUE
[17:01:22.236] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:22.236]  length: 0 (resolved future 1)
[17:01:22.236] Relaying remaining futures
[17:01:22.236] signalConditionsASAP(NULL, pos=0) ...
[17:01:22.236] - nx: 1
[17:01:22.236] - relay: TRUE
[17:01:22.236] - stdout: TRUE
[17:01:22.237] - signal: TRUE
[17:01:22.237] - resignal: FALSE
[17:01:22.237] - force: TRUE
[17:01:22.237] - relayed: [n=1] TRUE
[17:01:22.237] - queued futures: [n=1] TRUE
 - flush all
[17:01:22.237] - relayed: [n=1] TRUE
[17:01:22.237] - queued futures: [n=1] TRUE
[17:01:22.237] signalConditionsASAP(NULL, pos=0) ... done
[17:01:22.237] resolve() on list ... DONE
[17:01:22.237]  - Number of value chunks collected: 1
[17:01:22.238] Resolving 1 futures (chunks) ... DONE
[17:01:22.238] Reducing values from 1 chunks ...
[17:01:22.238]  - Number of values collected after concatenation: 2
[17:01:22.238]  - Number of values expected: 2
[17:01:22.238] Reducing values from 1 chunks ... DONE
[17:01:22.238] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[17:01:22.239] plan(): Setting new future strategy stack:
[17:01:22.239] List of future strategies:
[17:01:22.239] 1. multisession:
[17:01:22.239]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:22.239]    - tweaked: FALSE
[17:01:22.239]    - call: plan(strategy)
[17:01:22.239] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:01:22.239] multisession:
[17:01:22.239] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:22.239] - tweaked: FALSE
[17:01:22.239] - call: plan(strategy)
[17:01:22.243] getGlobalsAndPackages() ...
[17:01:22.243] Not searching for globals
[17:01:22.243] - globals: [0] <none>
[17:01:22.243] getGlobalsAndPackages() ... DONE
[17:01:22.243] Packages needed by the future expression (n = 0): <none>
[17:01:22.244] Packages needed by future strategies (n = 0): <none>
[17:01:22.244] {
[17:01:22.244]     {
[17:01:22.244]         {
[17:01:22.244]             ...future.startTime <- base::Sys.time()
[17:01:22.244]             {
[17:01:22.244]                 {
[17:01:22.244]                   {
[17:01:22.244]                     base::local({
[17:01:22.244]                       has_future <- base::requireNamespace("future", 
[17:01:22.244]                         quietly = TRUE)
[17:01:22.244]                       if (has_future) {
[17:01:22.244]                         ns <- base::getNamespace("future")
[17:01:22.244]                         version <- ns[[".package"]][["version"]]
[17:01:22.244]                         if (is.null(version)) 
[17:01:22.244]                           version <- utils::packageVersion("future")
[17:01:22.244]                       }
[17:01:22.244]                       else {
[17:01:22.244]                         version <- NULL
[17:01:22.244]                       }
[17:01:22.244]                       if (!has_future || version < "1.8.0") {
[17:01:22.244]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:22.244]                           "", base::R.version$version.string), 
[17:01:22.244]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:22.244]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:22.244]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:22.244]                             "release", "version")], collapse = " "), 
[17:01:22.244]                           hostname = base::Sys.info()[["nodename"]])
[17:01:22.244]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:22.244]                           info)
[17:01:22.244]                         info <- base::paste(info, collapse = "; ")
[17:01:22.244]                         if (!has_future) {
[17:01:22.244]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:22.244]                             info)
[17:01:22.244]                         }
[17:01:22.244]                         else {
[17:01:22.244]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:22.244]                             info, version)
[17:01:22.244]                         }
[17:01:22.244]                         base::stop(msg)
[17:01:22.244]                       }
[17:01:22.244]                     })
[17:01:22.244]                   }
[17:01:22.244]                   ...future.strategy.old <- future::plan("list")
[17:01:22.244]                   options(future.plan = NULL)
[17:01:22.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:22.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:22.244]                 }
[17:01:22.244]                 ...future.workdir <- getwd()
[17:01:22.244]             }
[17:01:22.244]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:22.244]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:22.244]         }
[17:01:22.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:22.244]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:22.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:22.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:22.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:22.244]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:22.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:22.244]             base::names(...future.oldOptions))
[17:01:22.244]     }
[17:01:22.244]     if (FALSE) {
[17:01:22.244]     }
[17:01:22.244]     else {
[17:01:22.244]         if (TRUE) {
[17:01:22.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:22.244]                 open = "w")
[17:01:22.244]         }
[17:01:22.244]         else {
[17:01:22.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:22.244]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:22.244]         }
[17:01:22.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:22.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:22.244]             base::sink(type = "output", split = FALSE)
[17:01:22.244]             base::close(...future.stdout)
[17:01:22.244]         }, add = TRUE)
[17:01:22.244]     }
[17:01:22.244]     ...future.frame <- base::sys.nframe()
[17:01:22.244]     ...future.conditions <- base::list()
[17:01:22.244]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:22.244]     if (FALSE) {
[17:01:22.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:22.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:22.244]     }
[17:01:22.244]     ...future.result <- base::tryCatch({
[17:01:22.244]         base::withCallingHandlers({
[17:01:22.244]             ...future.value <- base::withVisible(base::local(NA))
[17:01:22.244]             future::FutureResult(value = ...future.value$value, 
[17:01:22.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:22.244]                   ...future.rng), globalenv = if (FALSE) 
[17:01:22.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:22.244]                     ...future.globalenv.names))
[17:01:22.244]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:22.244]         }, condition = base::local({
[17:01:22.244]             c <- base::c
[17:01:22.244]             inherits <- base::inherits
[17:01:22.244]             invokeRestart <- base::invokeRestart
[17:01:22.244]             length <- base::length
[17:01:22.244]             list <- base::list
[17:01:22.244]             seq.int <- base::seq.int
[17:01:22.244]             signalCondition <- base::signalCondition
[17:01:22.244]             sys.calls <- base::sys.calls
[17:01:22.244]             `[[` <- base::`[[`
[17:01:22.244]             `+` <- base::`+`
[17:01:22.244]             `<<-` <- base::`<<-`
[17:01:22.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:22.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:22.244]                   3L)]
[17:01:22.244]             }
[17:01:22.244]             function(cond) {
[17:01:22.244]                 is_error <- inherits(cond, "error")
[17:01:22.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:22.244]                   NULL)
[17:01:22.244]                 if (is_error) {
[17:01:22.244]                   sessionInformation <- function() {
[17:01:22.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:22.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:22.244]                       search = base::search(), system = base::Sys.info())
[17:01:22.244]                   }
[17:01:22.244]                   ...future.conditions[[length(...future.conditions) + 
[17:01:22.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:22.244]                     cond$call), session = sessionInformation(), 
[17:01:22.244]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:22.244]                   signalCondition(cond)
[17:01:22.244]                 }
[17:01:22.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:22.244]                 "immediateCondition"))) {
[17:01:22.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:22.244]                   ...future.conditions[[length(...future.conditions) + 
[17:01:22.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:22.244]                   if (TRUE && !signal) {
[17:01:22.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:22.244]                     {
[17:01:22.244]                       inherits <- base::inherits
[17:01:22.244]                       invokeRestart <- base::invokeRestart
[17:01:22.244]                       is.null <- base::is.null
[17:01:22.244]                       muffled <- FALSE
[17:01:22.244]                       if (inherits(cond, "message")) {
[17:01:22.244]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:22.244]                         if (muffled) 
[17:01:22.244]                           invokeRestart("muffleMessage")
[17:01:22.244]                       }
[17:01:22.244]                       else if (inherits(cond, "warning")) {
[17:01:22.244]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:22.244]                         if (muffled) 
[17:01:22.244]                           invokeRestart("muffleWarning")
[17:01:22.244]                       }
[17:01:22.244]                       else if (inherits(cond, "condition")) {
[17:01:22.244]                         if (!is.null(pattern)) {
[17:01:22.244]                           computeRestarts <- base::computeRestarts
[17:01:22.244]                           grepl <- base::grepl
[17:01:22.244]                           restarts <- computeRestarts(cond)
[17:01:22.244]                           for (restart in restarts) {
[17:01:22.244]                             name <- restart$name
[17:01:22.244]                             if (is.null(name)) 
[17:01:22.244]                               next
[17:01:22.244]                             if (!grepl(pattern, name)) 
[17:01:22.244]                               next
[17:01:22.244]                             invokeRestart(restart)
[17:01:22.244]                             muffled <- TRUE
[17:01:22.244]                             break
[17:01:22.244]                           }
[17:01:22.244]                         }
[17:01:22.244]                       }
[17:01:22.244]                       invisible(muffled)
[17:01:22.244]                     }
[17:01:22.244]                     muffleCondition(cond, pattern = "^muffle")
[17:01:22.244]                   }
[17:01:22.244]                 }
[17:01:22.244]                 else {
[17:01:22.244]                   if (TRUE) {
[17:01:22.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:22.244]                     {
[17:01:22.244]                       inherits <- base::inherits
[17:01:22.244]                       invokeRestart <- base::invokeRestart
[17:01:22.244]                       is.null <- base::is.null
[17:01:22.244]                       muffled <- FALSE
[17:01:22.244]                       if (inherits(cond, "message")) {
[17:01:22.244]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:22.244]                         if (muffled) 
[17:01:22.244]                           invokeRestart("muffleMessage")
[17:01:22.244]                       }
[17:01:22.244]                       else if (inherits(cond, "warning")) {
[17:01:22.244]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:22.244]                         if (muffled) 
[17:01:22.244]                           invokeRestart("muffleWarning")
[17:01:22.244]                       }
[17:01:22.244]                       else if (inherits(cond, "condition")) {
[17:01:22.244]                         if (!is.null(pattern)) {
[17:01:22.244]                           computeRestarts <- base::computeRestarts
[17:01:22.244]                           grepl <- base::grepl
[17:01:22.244]                           restarts <- computeRestarts(cond)
[17:01:22.244]                           for (restart in restarts) {
[17:01:22.244]                             name <- restart$name
[17:01:22.244]                             if (is.null(name)) 
[17:01:22.244]                               next
[17:01:22.244]                             if (!grepl(pattern, name)) 
[17:01:22.244]                               next
[17:01:22.244]                             invokeRestart(restart)
[17:01:22.244]                             muffled <- TRUE
[17:01:22.244]                             break
[17:01:22.244]                           }
[17:01:22.244]                         }
[17:01:22.244]                       }
[17:01:22.244]                       invisible(muffled)
[17:01:22.244]                     }
[17:01:22.244]                     muffleCondition(cond, pattern = "^muffle")
[17:01:22.244]                   }
[17:01:22.244]                 }
[17:01:22.244]             }
[17:01:22.244]         }))
[17:01:22.244]     }, error = function(ex) {
[17:01:22.244]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:22.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:22.244]                 ...future.rng), started = ...future.startTime, 
[17:01:22.244]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:22.244]             version = "1.8"), class = "FutureResult")
[17:01:22.244]     }, finally = {
[17:01:22.244]         if (!identical(...future.workdir, getwd())) 
[17:01:22.244]             setwd(...future.workdir)
[17:01:22.244]         {
[17:01:22.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:22.244]                 ...future.oldOptions$nwarnings <- NULL
[17:01:22.244]             }
[17:01:22.244]             base::options(...future.oldOptions)
[17:01:22.244]             if (.Platform$OS.type == "windows") {
[17:01:22.244]                 old_names <- names(...future.oldEnvVars)
[17:01:22.244]                 envs <- base::Sys.getenv()
[17:01:22.244]                 names <- names(envs)
[17:01:22.244]                 common <- intersect(names, old_names)
[17:01:22.244]                 added <- setdiff(names, old_names)
[17:01:22.244]                 removed <- setdiff(old_names, names)
[17:01:22.244]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:22.244]                   envs[common]]
[17:01:22.244]                 NAMES <- toupper(changed)
[17:01:22.244]                 args <- list()
[17:01:22.244]                 for (kk in seq_along(NAMES)) {
[17:01:22.244]                   name <- changed[[kk]]
[17:01:22.244]                   NAME <- NAMES[[kk]]
[17:01:22.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:22.244]                     next
[17:01:22.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:22.244]                 }
[17:01:22.244]                 NAMES <- toupper(added)
[17:01:22.244]                 for (kk in seq_along(NAMES)) {
[17:01:22.244]                   name <- added[[kk]]
[17:01:22.244]                   NAME <- NAMES[[kk]]
[17:01:22.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:22.244]                     next
[17:01:22.244]                   args[[name]] <- ""
[17:01:22.244]                 }
[17:01:22.244]                 NAMES <- toupper(removed)
[17:01:22.244]                 for (kk in seq_along(NAMES)) {
[17:01:22.244]                   name <- removed[[kk]]
[17:01:22.244]                   NAME <- NAMES[[kk]]
[17:01:22.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:22.244]                     next
[17:01:22.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:22.244]                 }
[17:01:22.244]                 if (length(args) > 0) 
[17:01:22.244]                   base::do.call(base::Sys.setenv, args = args)
[17:01:22.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:22.244]             }
[17:01:22.244]             else {
[17:01:22.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:22.244]             }
[17:01:22.244]             {
[17:01:22.244]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:22.244]                   0L) {
[17:01:22.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:22.244]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:22.244]                   base::options(opts)
[17:01:22.244]                 }
[17:01:22.244]                 {
[17:01:22.244]                   {
[17:01:22.244]                     NULL
[17:01:22.244]                     RNGkind("Mersenne-Twister")
[17:01:22.244]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:22.244]                       inherits = FALSE)
[17:01:22.244]                   }
[17:01:22.244]                   options(future.plan = NULL)
[17:01:22.244]                   if (is.na(NA_character_)) 
[17:01:22.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:22.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:22.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:22.244]                     .init = FALSE)
[17:01:22.244]                 }
[17:01:22.244]             }
[17:01:22.244]         }
[17:01:22.244]     })
[17:01:22.244]     if (TRUE) {
[17:01:22.244]         base::sink(type = "output", split = FALSE)
[17:01:22.244]         if (TRUE) {
[17:01:22.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:22.244]         }
[17:01:22.244]         else {
[17:01:22.244]             ...future.result["stdout"] <- base::list(NULL)
[17:01:22.244]         }
[17:01:22.244]         base::close(...future.stdout)
[17:01:22.244]         ...future.stdout <- NULL
[17:01:22.244]     }
[17:01:22.244]     ...future.result$conditions <- ...future.conditions
[17:01:22.244]     ...future.result$finished <- base::Sys.time()
[17:01:22.244]     ...future.result
[17:01:22.244] }
[17:01:22.246] plan(): Setting new future strategy stack:
[17:01:22.246] List of future strategies:
[17:01:22.246] 1. sequential:
[17:01:22.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:22.246]    - tweaked: FALSE
[17:01:22.246]    - call: NULL
[17:01:22.246] plan(): nbrOfWorkers() = 1
[17:01:22.247] plan(): Setting new future strategy stack:
[17:01:22.247] List of future strategies:
[17:01:22.247] 1. multisession:
[17:01:22.247]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:22.247]    - tweaked: FALSE
[17:01:22.247]    - call: plan(strategy)
[17:01:22.251] plan(): nbrOfWorkers() = 1
[17:01:22.251] SequentialFuture started (and completed)
[17:01:22.251] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:01:22.254] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:01:22.254] future_lapply() ...
[17:01:22.258] Number of chunks: 1
[17:01:22.258] getGlobalsAndPackagesXApply() ...
[17:01:22.258]  - future.globals: TRUE
[17:01:22.258] getGlobalsAndPackages() ...
[17:01:22.258] Searching for globals...
[17:01:22.262] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:22.262] Searching for globals ... DONE
[17:01:22.262] Resolving globals: FALSE
[17:01:22.262] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:22.263] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:22.263] - globals: [1] ‘FUN’
[17:01:22.263] 
[17:01:22.263] getGlobalsAndPackages() ... DONE
[17:01:22.263]  - globals found/used: [n=1] ‘FUN’
[17:01:22.263]  - needed namespaces: [n=0] 
[17:01:22.263] Finding globals ... DONE
[17:01:22.264]  - use_args: TRUE
[17:01:22.264]  - Getting '...' globals ...
[17:01:22.264] resolve() on list ...
[17:01:22.264]  recursive: 0
[17:01:22.264]  length: 1
[17:01:22.264]  elements: ‘...’
[17:01:22.264]  length: 0 (resolved future 1)
[17:01:22.264] resolve() on list ... DONE
[17:01:22.265]    - '...' content: [n=0] 
[17:01:22.265] List of 1
[17:01:22.265]  $ ...: list()
[17:01:22.265]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:22.265]  - attr(*, "where")=List of 1
[17:01:22.265]   ..$ ...:<environment: 0x5636f6ffb6d0> 
[17:01:22.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:22.265]  - attr(*, "resolved")= logi TRUE
[17:01:22.265]  - attr(*, "total_size")= num NA
[17:01:22.267]  - Getting '...' globals ... DONE
[17:01:22.267] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:22.267] List of 2
[17:01:22.267]  $ ...future.FUN:function (x)  
[17:01:22.267]  $ ...          : list()
[17:01:22.267]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:22.267]  - attr(*, "where")=List of 2
[17:01:22.267]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:22.267]   ..$ ...          :<environment: 0x5636f6ffb6d0> 
[17:01:22.267]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:22.267]  - attr(*, "resolved")= logi FALSE
[17:01:22.267]  - attr(*, "total_size")= num 4720
[17:01:22.270] Packages to be attached in all futures: [n=0] 
[17:01:22.270] getGlobalsAndPackagesXApply() ... DONE
[17:01:22.270] Number of futures (= number of chunks): 1
[17:01:22.271] Launching 1 futures (chunks) ...
[17:01:22.271] Chunk #1 of 1 ...
[17:01:22.271]  - Finding globals in 'X' for chunk #1 ...
[17:01:22.271] getGlobalsAndPackages() ...
[17:01:22.271] Searching for globals...
[17:01:22.271] 
[17:01:22.271] Searching for globals ... DONE
[17:01:22.271] - globals: [0] <none>
[17:01:22.272] getGlobalsAndPackages() ... DONE
[17:01:22.272]    + additional globals found: [n=0] 
[17:01:22.272]    + additional namespaces needed: [n=0] 
[17:01:22.272]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:22.272]  - seeds: <none>
[17:01:22.272]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:22.272] getGlobalsAndPackages() ...
[17:01:22.273] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:22.273] Resolving globals: FALSE
[17:01:22.273] Tweak future expression to call with '...' arguments ...
[17:01:22.273] {
[17:01:22.273]     do.call(function(...) {
[17:01:22.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:22.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:22.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:22.273]             on.exit(options(oopts), add = TRUE)
[17:01:22.273]         }
[17:01:22.273]         {
[17:01:22.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:22.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:22.273]                 ...future.FUN(...future.X_jj, ...)
[17:01:22.273]             })
[17:01:22.273]         }
[17:01:22.273]     }, args = future.call.arguments)
[17:01:22.273] }
[17:01:22.274] Tweak future expression to call with '...' arguments ... DONE
[17:01:22.274] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:22.274] 
[17:01:22.274] getGlobalsAndPackages() ... DONE
[17:01:22.275] run() for ‘Future’ ...
[17:01:22.275] - state: ‘created’
[17:01:22.275] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:22.281] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:22.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:22.281]   - Field: ‘label’
[17:01:22.281]   - Field: ‘local’
[17:01:22.281]   - Field: ‘owner’
[17:01:22.282]   - Field: ‘envir’
[17:01:22.282]   - Field: ‘packages’
[17:01:22.282]   - Field: ‘gc’
[17:01:22.282]   - Field: ‘conditions’
[17:01:22.282]   - Field: ‘expr’
[17:01:22.282]   - Field: ‘uuid’
[17:01:22.282]   - Field: ‘seed’
[17:01:22.282]   - Field: ‘version’
[17:01:22.283]   - Field: ‘result’
[17:01:22.283]   - Field: ‘asynchronous’
[17:01:22.283]   - Field: ‘calls’
[17:01:22.283]   - Field: ‘globals’
[17:01:22.283]   - Field: ‘stdout’
[17:01:22.283]   - Field: ‘earlySignal’
[17:01:22.283]   - Field: ‘lazy’
[17:01:22.284]   - Field: ‘state’
[17:01:22.284] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:22.284] - Launch lazy future ...
[17:01:22.284] Packages needed by the future expression (n = 0): <none>
[17:01:22.284] Packages needed by future strategies (n = 0): <none>
[17:01:22.285] {
[17:01:22.285]     {
[17:01:22.285]         {
[17:01:22.285]             ...future.startTime <- base::Sys.time()
[17:01:22.285]             {
[17:01:22.285]                 {
[17:01:22.285]                   {
[17:01:22.285]                     base::local({
[17:01:22.285]                       has_future <- base::requireNamespace("future", 
[17:01:22.285]                         quietly = TRUE)
[17:01:22.285]                       if (has_future) {
[17:01:22.285]                         ns <- base::getNamespace("future")
[17:01:22.285]                         version <- ns[[".package"]][["version"]]
[17:01:22.285]                         if (is.null(version)) 
[17:01:22.285]                           version <- utils::packageVersion("future")
[17:01:22.285]                       }
[17:01:22.285]                       else {
[17:01:22.285]                         version <- NULL
[17:01:22.285]                       }
[17:01:22.285]                       if (!has_future || version < "1.8.0") {
[17:01:22.285]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:22.285]                           "", base::R.version$version.string), 
[17:01:22.285]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:22.285]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:22.285]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:22.285]                             "release", "version")], collapse = " "), 
[17:01:22.285]                           hostname = base::Sys.info()[["nodename"]])
[17:01:22.285]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:22.285]                           info)
[17:01:22.285]                         info <- base::paste(info, collapse = "; ")
[17:01:22.285]                         if (!has_future) {
[17:01:22.285]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:22.285]                             info)
[17:01:22.285]                         }
[17:01:22.285]                         else {
[17:01:22.285]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:22.285]                             info, version)
[17:01:22.285]                         }
[17:01:22.285]                         base::stop(msg)
[17:01:22.285]                       }
[17:01:22.285]                     })
[17:01:22.285]                   }
[17:01:22.285]                   ...future.strategy.old <- future::plan("list")
[17:01:22.285]                   options(future.plan = NULL)
[17:01:22.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:22.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:22.285]                 }
[17:01:22.285]                 ...future.workdir <- getwd()
[17:01:22.285]             }
[17:01:22.285]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:22.285]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:22.285]         }
[17:01:22.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:22.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:22.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:22.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:22.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:22.285]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:22.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:22.285]             base::names(...future.oldOptions))
[17:01:22.285]     }
[17:01:22.285]     if (FALSE) {
[17:01:22.285]     }
[17:01:22.285]     else {
[17:01:22.285]         if (FALSE) {
[17:01:22.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:22.285]                 open = "w")
[17:01:22.285]         }
[17:01:22.285]         else {
[17:01:22.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:22.285]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:22.285]         }
[17:01:22.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:22.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:22.285]             base::sink(type = "output", split = FALSE)
[17:01:22.285]             base::close(...future.stdout)
[17:01:22.285]         }, add = TRUE)
[17:01:22.285]     }
[17:01:22.285]     ...future.frame <- base::sys.nframe()
[17:01:22.285]     ...future.conditions <- base::list()
[17:01:22.285]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:22.285]     if (FALSE) {
[17:01:22.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:22.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:22.285]     }
[17:01:22.285]     ...future.result <- base::tryCatch({
[17:01:22.285]         base::withCallingHandlers({
[17:01:22.285]             ...future.value <- base::withVisible(base::local({
[17:01:22.285]                 do.call(function(...) {
[17:01:22.285]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:22.285]                   if (!identical(...future.globals.maxSize.org, 
[17:01:22.285]                     ...future.globals.maxSize)) {
[17:01:22.285]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:22.285]                     on.exit(options(oopts), add = TRUE)
[17:01:22.285]                   }
[17:01:22.285]                   {
[17:01:22.285]                     lapply(seq_along(...future.elements_ii), 
[17:01:22.285]                       FUN = function(jj) {
[17:01:22.285]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:22.285]                         ...future.FUN(...future.X_jj, ...)
[17:01:22.285]                       })
[17:01:22.285]                   }
[17:01:22.285]                 }, args = future.call.arguments)
[17:01:22.285]             }))
[17:01:22.285]             future::FutureResult(value = ...future.value$value, 
[17:01:22.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:22.285]                   ...future.rng), globalenv = if (FALSE) 
[17:01:22.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:22.285]                     ...future.globalenv.names))
[17:01:22.285]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:22.285]         }, condition = base::local({
[17:01:22.285]             c <- base::c
[17:01:22.285]             inherits <- base::inherits
[17:01:22.285]             invokeRestart <- base::invokeRestart
[17:01:22.285]             length <- base::length
[17:01:22.285]             list <- base::list
[17:01:22.285]             seq.int <- base::seq.int
[17:01:22.285]             signalCondition <- base::signalCondition
[17:01:22.285]             sys.calls <- base::sys.calls
[17:01:22.285]             `[[` <- base::`[[`
[17:01:22.285]             `+` <- base::`+`
[17:01:22.285]             `<<-` <- base::`<<-`
[17:01:22.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:22.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:22.285]                   3L)]
[17:01:22.285]             }
[17:01:22.285]             function(cond) {
[17:01:22.285]                 is_error <- inherits(cond, "error")
[17:01:22.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:22.285]                   NULL)
[17:01:22.285]                 if (is_error) {
[17:01:22.285]                   sessionInformation <- function() {
[17:01:22.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:22.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:22.285]                       search = base::search(), system = base::Sys.info())
[17:01:22.285]                   }
[17:01:22.285]                   ...future.conditions[[length(...future.conditions) + 
[17:01:22.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:22.285]                     cond$call), session = sessionInformation(), 
[17:01:22.285]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:22.285]                   signalCondition(cond)
[17:01:22.285]                 }
[17:01:22.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:22.285]                 "immediateCondition"))) {
[17:01:22.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:22.285]                   ...future.conditions[[length(...future.conditions) + 
[17:01:22.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:22.285]                   if (TRUE && !signal) {
[17:01:22.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:22.285]                     {
[17:01:22.285]                       inherits <- base::inherits
[17:01:22.285]                       invokeRestart <- base::invokeRestart
[17:01:22.285]                       is.null <- base::is.null
[17:01:22.285]                       muffled <- FALSE
[17:01:22.285]                       if (inherits(cond, "message")) {
[17:01:22.285]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:22.285]                         if (muffled) 
[17:01:22.285]                           invokeRestart("muffleMessage")
[17:01:22.285]                       }
[17:01:22.285]                       else if (inherits(cond, "warning")) {
[17:01:22.285]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:22.285]                         if (muffled) 
[17:01:22.285]                           invokeRestart("muffleWarning")
[17:01:22.285]                       }
[17:01:22.285]                       else if (inherits(cond, "condition")) {
[17:01:22.285]                         if (!is.null(pattern)) {
[17:01:22.285]                           computeRestarts <- base::computeRestarts
[17:01:22.285]                           grepl <- base::grepl
[17:01:22.285]                           restarts <- computeRestarts(cond)
[17:01:22.285]                           for (restart in restarts) {
[17:01:22.285]                             name <- restart$name
[17:01:22.285]                             if (is.null(name)) 
[17:01:22.285]                               next
[17:01:22.285]                             if (!grepl(pattern, name)) 
[17:01:22.285]                               next
[17:01:22.285]                             invokeRestart(restart)
[17:01:22.285]                             muffled <- TRUE
[17:01:22.285]                             break
[17:01:22.285]                           }
[17:01:22.285]                         }
[17:01:22.285]                       }
[17:01:22.285]                       invisible(muffled)
[17:01:22.285]                     }
[17:01:22.285]                     muffleCondition(cond, pattern = "^muffle")
[17:01:22.285]                   }
[17:01:22.285]                 }
[17:01:22.285]                 else {
[17:01:22.285]                   if (TRUE) {
[17:01:22.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:22.285]                     {
[17:01:22.285]                       inherits <- base::inherits
[17:01:22.285]                       invokeRestart <- base::invokeRestart
[17:01:22.285]                       is.null <- base::is.null
[17:01:22.285]                       muffled <- FALSE
[17:01:22.285]                       if (inherits(cond, "message")) {
[17:01:22.285]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:22.285]                         if (muffled) 
[17:01:22.285]                           invokeRestart("muffleMessage")
[17:01:22.285]                       }
[17:01:22.285]                       else if (inherits(cond, "warning")) {
[17:01:22.285]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:22.285]                         if (muffled) 
[17:01:22.285]                           invokeRestart("muffleWarning")
[17:01:22.285]                       }
[17:01:22.285]                       else if (inherits(cond, "condition")) {
[17:01:22.285]                         if (!is.null(pattern)) {
[17:01:22.285]                           computeRestarts <- base::computeRestarts
[17:01:22.285]                           grepl <- base::grepl
[17:01:22.285]                           restarts <- computeRestarts(cond)
[17:01:22.285]                           for (restart in restarts) {
[17:01:22.285]                             name <- restart$name
[17:01:22.285]                             if (is.null(name)) 
[17:01:22.285]                               next
[17:01:22.285]                             if (!grepl(pattern, name)) 
[17:01:22.285]                               next
[17:01:22.285]                             invokeRestart(restart)
[17:01:22.285]                             muffled <- TRUE
[17:01:22.285]                             break
[17:01:22.285]                           }
[17:01:22.285]                         }
[17:01:22.285]                       }
[17:01:22.285]                       invisible(muffled)
[17:01:22.285]                     }
[17:01:22.285]                     muffleCondition(cond, pattern = "^muffle")
[17:01:22.285]                   }
[17:01:22.285]                 }
[17:01:22.285]             }
[17:01:22.285]         }))
[17:01:22.285]     }, error = function(ex) {
[17:01:22.285]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:22.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:22.285]                 ...future.rng), started = ...future.startTime, 
[17:01:22.285]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:22.285]             version = "1.8"), class = "FutureResult")
[17:01:22.285]     }, finally = {
[17:01:22.285]         if (!identical(...future.workdir, getwd())) 
[17:01:22.285]             setwd(...future.workdir)
[17:01:22.285]         {
[17:01:22.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:22.285]                 ...future.oldOptions$nwarnings <- NULL
[17:01:22.285]             }
[17:01:22.285]             base::options(...future.oldOptions)
[17:01:22.285]             if (.Platform$OS.type == "windows") {
[17:01:22.285]                 old_names <- names(...future.oldEnvVars)
[17:01:22.285]                 envs <- base::Sys.getenv()
[17:01:22.285]                 names <- names(envs)
[17:01:22.285]                 common <- intersect(names, old_names)
[17:01:22.285]                 added <- setdiff(names, old_names)
[17:01:22.285]                 removed <- setdiff(old_names, names)
[17:01:22.285]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:22.285]                   envs[common]]
[17:01:22.285]                 NAMES <- toupper(changed)
[17:01:22.285]                 args <- list()
[17:01:22.285]                 for (kk in seq_along(NAMES)) {
[17:01:22.285]                   name <- changed[[kk]]
[17:01:22.285]                   NAME <- NAMES[[kk]]
[17:01:22.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:22.285]                     next
[17:01:22.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:22.285]                 }
[17:01:22.285]                 NAMES <- toupper(added)
[17:01:22.285]                 for (kk in seq_along(NAMES)) {
[17:01:22.285]                   name <- added[[kk]]
[17:01:22.285]                   NAME <- NAMES[[kk]]
[17:01:22.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:22.285]                     next
[17:01:22.285]                   args[[name]] <- ""
[17:01:22.285]                 }
[17:01:22.285]                 NAMES <- toupper(removed)
[17:01:22.285]                 for (kk in seq_along(NAMES)) {
[17:01:22.285]                   name <- removed[[kk]]
[17:01:22.285]                   NAME <- NAMES[[kk]]
[17:01:22.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:22.285]                     next
[17:01:22.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:22.285]                 }
[17:01:22.285]                 if (length(args) > 0) 
[17:01:22.285]                   base::do.call(base::Sys.setenv, args = args)
[17:01:22.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:22.285]             }
[17:01:22.285]             else {
[17:01:22.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:22.285]             }
[17:01:22.285]             {
[17:01:22.285]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:22.285]                   0L) {
[17:01:22.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:22.285]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:22.285]                   base::options(opts)
[17:01:22.285]                 }
[17:01:22.285]                 {
[17:01:22.285]                   {
[17:01:22.285]                     NULL
[17:01:22.285]                     RNGkind("Mersenne-Twister")
[17:01:22.285]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:22.285]                       inherits = FALSE)
[17:01:22.285]                   }
[17:01:22.285]                   options(future.plan = NULL)
[17:01:22.285]                   if (is.na(NA_character_)) 
[17:01:22.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:22.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:22.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:22.285]                     .init = FALSE)
[17:01:22.285]                 }
[17:01:22.285]             }
[17:01:22.285]         }
[17:01:22.285]     })
[17:01:22.285]     if (TRUE) {
[17:01:22.285]         base::sink(type = "output", split = FALSE)
[17:01:22.285]         if (FALSE) {
[17:01:22.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:22.285]         }
[17:01:22.285]         else {
[17:01:22.285]             ...future.result["stdout"] <- base::list(NULL)
[17:01:22.285]         }
[17:01:22.285]         base::close(...future.stdout)
[17:01:22.285]         ...future.stdout <- NULL
[17:01:22.285]     }
[17:01:22.285]     ...future.result$conditions <- ...future.conditions
[17:01:22.285]     ...future.result$finished <- base::Sys.time()
[17:01:22.285]     ...future.result
[17:01:22.285] }
[17:01:22.287] assign_globals() ...
[17:01:22.287] List of 5
[17:01:22.287]  $ ...future.FUN            :function (x)  
[17:01:22.287]  $ future.call.arguments    : list()
[17:01:22.287]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:22.287]  $ ...future.elements_ii    :List of 2
[17:01:22.287]   ..$ : int 1
[17:01:22.287]   ..$ : int 0
[17:01:22.287]  $ ...future.seeds_ii       : NULL
[17:01:22.287]  $ ...future.globals.maxSize: NULL
[17:01:22.287]  - attr(*, "where")=List of 5
[17:01:22.287]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:22.287]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:22.287]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:22.287]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:22.287]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:22.287]  - attr(*, "resolved")= logi FALSE
[17:01:22.287]  - attr(*, "total_size")= num 4720
[17:01:22.287]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:22.287]  - attr(*, "already-done")= logi TRUE
[17:01:22.326] - reassign environment for ‘...future.FUN’
[17:01:22.326] - copied ‘...future.FUN’ to environment
[17:01:22.326] - copied ‘future.call.arguments’ to environment
[17:01:22.326] - copied ‘...future.elements_ii’ to environment
[17:01:22.326] - copied ‘...future.seeds_ii’ to environment
[17:01:22.326] - copied ‘...future.globals.maxSize’ to environment
[17:01:22.326] assign_globals() ... done
[17:01:22.327] plan(): Setting new future strategy stack:
[17:01:22.327] List of future strategies:
[17:01:22.327] 1. sequential:
[17:01:22.327]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:22.327]    - tweaked: FALSE
[17:01:22.327]    - call: NULL
[17:01:22.327] plan(): nbrOfWorkers() = 1
[17:01:22.829] plan(): Setting new future strategy stack:
[17:01:22.829] List of future strategies:
[17:01:22.829] 1. multisession:
[17:01:22.829]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:22.829]    - tweaked: FALSE
[17:01:22.829]    - call: plan(strategy)
[17:01:22.833] plan(): nbrOfWorkers() = 1
[17:01:22.834] SequentialFuture started (and completed)
[17:01:22.834] - Launch lazy future ... done
[17:01:22.834] run() for ‘SequentialFuture’ ... done
[17:01:22.834] Created future:
[17:01:22.834] SequentialFuture:
[17:01:22.834] Label: ‘future_lapply-1’
[17:01:22.834] Expression:
[17:01:22.834] {
[17:01:22.834]     do.call(function(...) {
[17:01:22.834]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:22.834]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:22.834]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:22.834]             on.exit(options(oopts), add = TRUE)
[17:01:22.834]         }
[17:01:22.834]         {
[17:01:22.834]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:22.834]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:22.834]                 ...future.FUN(...future.X_jj, ...)
[17:01:22.834]             })
[17:01:22.834]         }
[17:01:22.834]     }, args = future.call.arguments)
[17:01:22.834] }
[17:01:22.834] Lazy evaluation: FALSE
[17:01:22.834] Asynchronous evaluation: FALSE
[17:01:22.834] Local evaluation: TRUE
[17:01:22.834] Environment: R_GlobalEnv
[17:01:22.834] Capture standard output: FALSE
[17:01:22.834] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:22.834] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:22.834] Packages: <none>
[17:01:22.834] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:22.834] Resolved: TRUE
[17:01:22.834] Value: 112 bytes of class ‘list’
[17:01:22.834] Early signaling: FALSE
[17:01:22.834] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:22.834] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:22.835] Chunk #1 of 1 ... DONE
[17:01:22.835] Launching 1 futures (chunks) ... DONE
[17:01:22.835] Resolving 1 futures (chunks) ...
[17:01:22.836] resolve() on list ...
[17:01:22.836]  recursive: 0
[17:01:22.836]  length: 1
[17:01:22.836] 
[17:01:22.836] resolved() for ‘SequentialFuture’ ...
[17:01:22.836] - state: ‘finished’
[17:01:22.836] - run: TRUE
[17:01:22.836] - result: ‘FutureResult’
[17:01:22.836] resolved() for ‘SequentialFuture’ ... done
[17:01:22.837] Future #1
[17:01:22.837] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:22.837] - nx: 1
[17:01:22.837] - relay: TRUE
[17:01:22.837] - stdout: TRUE
[17:01:22.837] - signal: TRUE
[17:01:22.837] - resignal: FALSE
[17:01:22.837] - force: TRUE
[17:01:22.837] - relayed: [n=1] FALSE
[17:01:22.837] - queued futures: [n=1] FALSE
[17:01:22.837]  - until=1
[17:01:22.838]  - relaying element #1
[17:01:22.838] - relayed: [n=1] TRUE
[17:01:22.838] - queued futures: [n=1] TRUE
[17:01:22.838] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:22.838]  length: 0 (resolved future 1)
[17:01:22.838] Relaying remaining futures
[17:01:22.838] signalConditionsASAP(NULL, pos=0) ...
[17:01:22.838] - nx: 1
[17:01:22.838] - relay: TRUE
[17:01:22.838] - stdout: TRUE
[17:01:22.839] - signal: TRUE
[17:01:22.839] - resignal: FALSE
[17:01:22.839] - force: TRUE
[17:01:22.839] - relayed: [n=1] TRUE
[17:01:22.839] - queued futures: [n=1] TRUE
 - flush all
[17:01:22.839] - relayed: [n=1] TRUE
[17:01:22.839] - queued futures: [n=1] TRUE
[17:01:22.839] signalConditionsASAP(NULL, pos=0) ... done
[17:01:22.839] resolve() on list ... DONE
[17:01:22.839]  - Number of value chunks collected: 1
[17:01:22.840] Resolving 1 futures (chunks) ... DONE
[17:01:22.840] Reducing values from 1 chunks ...
[17:01:22.840]  - Number of values collected after concatenation: 2
[17:01:22.840]  - Number of values expected: 2
[17:01:22.840] Reducing values from 1 chunks ... DONE
[17:01:22.840] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:01:22.840] future_lapply() ...
[17:01:22.844] Number of chunks: 1
[17:01:22.844] getGlobalsAndPackagesXApply() ...
[17:01:22.844]  - future.globals: TRUE
[17:01:22.845] getGlobalsAndPackages() ...
[17:01:22.845] Searching for globals...
[17:01:22.846] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:22.846] Searching for globals ... DONE
[17:01:22.846] Resolving globals: FALSE
[17:01:22.847] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:22.847] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:22.847] - globals: [1] ‘FUN’
[17:01:22.847] 
[17:01:22.847] getGlobalsAndPackages() ... DONE
[17:01:22.847]  - globals found/used: [n=1] ‘FUN’
[17:01:22.847]  - needed namespaces: [n=0] 
[17:01:22.848] Finding globals ... DONE
[17:01:22.848]  - use_args: TRUE
[17:01:22.848]  - Getting '...' globals ...
[17:01:22.848] resolve() on list ...
[17:01:22.848]  recursive: 0
[17:01:22.848]  length: 1
[17:01:22.848]  elements: ‘...’
[17:01:22.848]  length: 0 (resolved future 1)
[17:01:22.849] resolve() on list ... DONE
[17:01:22.849]    - '...' content: [n=0] 
[17:01:22.849] List of 1
[17:01:22.849]  $ ...: list()
[17:01:22.849]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:22.849]  - attr(*, "where")=List of 1
[17:01:22.849]   ..$ ...:<environment: 0x5636f58bb648> 
[17:01:22.849]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:22.849]  - attr(*, "resolved")= logi TRUE
[17:01:22.849]  - attr(*, "total_size")= num NA
[17:01:22.851]  - Getting '...' globals ... DONE
[17:01:22.851] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:22.852] List of 2
[17:01:22.852]  $ ...future.FUN:function (x)  
[17:01:22.852]  $ ...          : list()
[17:01:22.852]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:22.852]  - attr(*, "where")=List of 2
[17:01:22.852]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:22.852]   ..$ ...          :<environment: 0x5636f58bb648> 
[17:01:22.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:22.852]  - attr(*, "resolved")= logi FALSE
[17:01:22.852]  - attr(*, "total_size")= num 4720
[17:01:22.854] Packages to be attached in all futures: [n=0] 
[17:01:22.854] getGlobalsAndPackagesXApply() ... DONE
[17:01:22.854] Number of futures (= number of chunks): 1
[17:01:22.855] Launching 1 futures (chunks) ...
[17:01:22.855] Chunk #1 of 1 ...
[17:01:22.855]  - Finding globals in 'X' for chunk #1 ...
[17:01:22.855] getGlobalsAndPackages() ...
[17:01:22.855] Searching for globals...
[17:01:22.855] 
[17:01:22.855] Searching for globals ... DONE
[17:01:22.855] - globals: [0] <none>
[17:01:22.856] getGlobalsAndPackages() ... DONE
[17:01:22.856]    + additional globals found: [n=0] 
[17:01:22.856]    + additional namespaces needed: [n=0] 
[17:01:22.856]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:22.856]  - seeds: <none>
[17:01:22.856]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:22.856] getGlobalsAndPackages() ...
[17:01:22.856] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:22.856] Resolving globals: FALSE
[17:01:22.856] Tweak future expression to call with '...' arguments ...
[17:01:22.857] {
[17:01:22.857]     do.call(function(...) {
[17:01:22.857]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:22.857]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:22.857]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:22.857]             on.exit(options(oopts), add = TRUE)
[17:01:22.857]         }
[17:01:22.857]         {
[17:01:22.857]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:22.857]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:22.857]                 ...future.FUN(...future.X_jj, ...)
[17:01:22.857]             })
[17:01:22.857]         }
[17:01:22.857]     }, args = future.call.arguments)
[17:01:22.857] }
[17:01:22.857] Tweak future expression to call with '...' arguments ... DONE
[17:01:22.857] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:22.857] 
[17:01:22.857] getGlobalsAndPackages() ... DONE
[17:01:22.858] run() for ‘Future’ ...
[17:01:22.858] - state: ‘created’
[17:01:22.858] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:22.863] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:22.863] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:22.863]   - Field: ‘label’
[17:01:22.864]   - Field: ‘local’
[17:01:22.864]   - Field: ‘owner’
[17:01:22.864]   - Field: ‘envir’
[17:01:22.864]   - Field: ‘packages’
[17:01:22.864]   - Field: ‘gc’
[17:01:22.864]   - Field: ‘conditions’
[17:01:22.864]   - Field: ‘expr’
[17:01:22.865]   - Field: ‘uuid’
[17:01:22.865]   - Field: ‘seed’
[17:01:22.865]   - Field: ‘version’
[17:01:22.865]   - Field: ‘result’
[17:01:22.865]   - Field: ‘asynchronous’
[17:01:22.865]   - Field: ‘calls’
[17:01:22.865]   - Field: ‘globals’
[17:01:22.865]   - Field: ‘stdout’
[17:01:22.865]   - Field: ‘earlySignal’
[17:01:22.865]   - Field: ‘lazy’
[17:01:22.866]   - Field: ‘state’
[17:01:22.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:22.866] - Launch lazy future ...
[17:01:22.866] Packages needed by the future expression (n = 0): <none>
[17:01:22.866] Packages needed by future strategies (n = 0): <none>
[17:01:22.867] {
[17:01:22.867]     {
[17:01:22.867]         {
[17:01:22.867]             ...future.startTime <- base::Sys.time()
[17:01:22.867]             {
[17:01:22.867]                 {
[17:01:22.867]                   {
[17:01:22.867]                     base::local({
[17:01:22.867]                       has_future <- base::requireNamespace("future", 
[17:01:22.867]                         quietly = TRUE)
[17:01:22.867]                       if (has_future) {
[17:01:22.867]                         ns <- base::getNamespace("future")
[17:01:22.867]                         version <- ns[[".package"]][["version"]]
[17:01:22.867]                         if (is.null(version)) 
[17:01:22.867]                           version <- utils::packageVersion("future")
[17:01:22.867]                       }
[17:01:22.867]                       else {
[17:01:22.867]                         version <- NULL
[17:01:22.867]                       }
[17:01:22.867]                       if (!has_future || version < "1.8.0") {
[17:01:22.867]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:22.867]                           "", base::R.version$version.string), 
[17:01:22.867]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:22.867]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:22.867]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:22.867]                             "release", "version")], collapse = " "), 
[17:01:22.867]                           hostname = base::Sys.info()[["nodename"]])
[17:01:22.867]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:22.867]                           info)
[17:01:22.867]                         info <- base::paste(info, collapse = "; ")
[17:01:22.867]                         if (!has_future) {
[17:01:22.867]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:22.867]                             info)
[17:01:22.867]                         }
[17:01:22.867]                         else {
[17:01:22.867]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:22.867]                             info, version)
[17:01:22.867]                         }
[17:01:22.867]                         base::stop(msg)
[17:01:22.867]                       }
[17:01:22.867]                     })
[17:01:22.867]                   }
[17:01:22.867]                   ...future.strategy.old <- future::plan("list")
[17:01:22.867]                   options(future.plan = NULL)
[17:01:22.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:22.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:22.867]                 }
[17:01:22.867]                 ...future.workdir <- getwd()
[17:01:22.867]             }
[17:01:22.867]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:22.867]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:22.867]         }
[17:01:22.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:22.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:22.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:22.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:22.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:22.867]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:22.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:22.867]             base::names(...future.oldOptions))
[17:01:22.867]     }
[17:01:22.867]     if (FALSE) {
[17:01:22.867]     }
[17:01:22.867]     else {
[17:01:22.867]         if (TRUE) {
[17:01:22.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:22.867]                 open = "w")
[17:01:22.867]         }
[17:01:22.867]         else {
[17:01:22.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:22.867]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:22.867]         }
[17:01:22.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:22.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:22.867]             base::sink(type = "output", split = FALSE)
[17:01:22.867]             base::close(...future.stdout)
[17:01:22.867]         }, add = TRUE)
[17:01:22.867]     }
[17:01:22.867]     ...future.frame <- base::sys.nframe()
[17:01:22.867]     ...future.conditions <- base::list()
[17:01:22.867]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:22.867]     if (FALSE) {
[17:01:22.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:22.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:22.867]     }
[17:01:22.867]     ...future.result <- base::tryCatch({
[17:01:22.867]         base::withCallingHandlers({
[17:01:22.867]             ...future.value <- base::withVisible(base::local({
[17:01:22.867]                 do.call(function(...) {
[17:01:22.867]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:22.867]                   if (!identical(...future.globals.maxSize.org, 
[17:01:22.867]                     ...future.globals.maxSize)) {
[17:01:22.867]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:22.867]                     on.exit(options(oopts), add = TRUE)
[17:01:22.867]                   }
[17:01:22.867]                   {
[17:01:22.867]                     lapply(seq_along(...future.elements_ii), 
[17:01:22.867]                       FUN = function(jj) {
[17:01:22.867]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:22.867]                         ...future.FUN(...future.X_jj, ...)
[17:01:22.867]                       })
[17:01:22.867]                   }
[17:01:22.867]                 }, args = future.call.arguments)
[17:01:22.867]             }))
[17:01:22.867]             future::FutureResult(value = ...future.value$value, 
[17:01:22.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:22.867]                   ...future.rng), globalenv = if (FALSE) 
[17:01:22.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:22.867]                     ...future.globalenv.names))
[17:01:22.867]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:22.867]         }, condition = base::local({
[17:01:22.867]             c <- base::c
[17:01:22.867]             inherits <- base::inherits
[17:01:22.867]             invokeRestart <- base::invokeRestart
[17:01:22.867]             length <- base::length
[17:01:22.867]             list <- base::list
[17:01:22.867]             seq.int <- base::seq.int
[17:01:22.867]             signalCondition <- base::signalCondition
[17:01:22.867]             sys.calls <- base::sys.calls
[17:01:22.867]             `[[` <- base::`[[`
[17:01:22.867]             `+` <- base::`+`
[17:01:22.867]             `<<-` <- base::`<<-`
[17:01:22.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:22.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:22.867]                   3L)]
[17:01:22.867]             }
[17:01:22.867]             function(cond) {
[17:01:22.867]                 is_error <- inherits(cond, "error")
[17:01:22.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:22.867]                   NULL)
[17:01:22.867]                 if (is_error) {
[17:01:22.867]                   sessionInformation <- function() {
[17:01:22.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:22.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:22.867]                       search = base::search(), system = base::Sys.info())
[17:01:22.867]                   }
[17:01:22.867]                   ...future.conditions[[length(...future.conditions) + 
[17:01:22.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:22.867]                     cond$call), session = sessionInformation(), 
[17:01:22.867]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:22.867]                   signalCondition(cond)
[17:01:22.867]                 }
[17:01:22.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:22.867]                 "immediateCondition"))) {
[17:01:22.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:22.867]                   ...future.conditions[[length(...future.conditions) + 
[17:01:22.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:22.867]                   if (TRUE && !signal) {
[17:01:22.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:22.867]                     {
[17:01:22.867]                       inherits <- base::inherits
[17:01:22.867]                       invokeRestart <- base::invokeRestart
[17:01:22.867]                       is.null <- base::is.null
[17:01:22.867]                       muffled <- FALSE
[17:01:22.867]                       if (inherits(cond, "message")) {
[17:01:22.867]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:22.867]                         if (muffled) 
[17:01:22.867]                           invokeRestart("muffleMessage")
[17:01:22.867]                       }
[17:01:22.867]                       else if (inherits(cond, "warning")) {
[17:01:22.867]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:22.867]                         if (muffled) 
[17:01:22.867]                           invokeRestart("muffleWarning")
[17:01:22.867]                       }
[17:01:22.867]                       else if (inherits(cond, "condition")) {
[17:01:22.867]                         if (!is.null(pattern)) {
[17:01:22.867]                           computeRestarts <- base::computeRestarts
[17:01:22.867]                           grepl <- base::grepl
[17:01:22.867]                           restarts <- computeRestarts(cond)
[17:01:22.867]                           for (restart in restarts) {
[17:01:22.867]                             name <- restart$name
[17:01:22.867]                             if (is.null(name)) 
[17:01:22.867]                               next
[17:01:22.867]                             if (!grepl(pattern, name)) 
[17:01:22.867]                               next
[17:01:22.867]                             invokeRestart(restart)
[17:01:22.867]                             muffled <- TRUE
[17:01:22.867]                             break
[17:01:22.867]                           }
[17:01:22.867]                         }
[17:01:22.867]                       }
[17:01:22.867]                       invisible(muffled)
[17:01:22.867]                     }
[17:01:22.867]                     muffleCondition(cond, pattern = "^muffle")
[17:01:22.867]                   }
[17:01:22.867]                 }
[17:01:22.867]                 else {
[17:01:22.867]                   if (TRUE) {
[17:01:22.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:22.867]                     {
[17:01:22.867]                       inherits <- base::inherits
[17:01:22.867]                       invokeRestart <- base::invokeRestart
[17:01:22.867]                       is.null <- base::is.null
[17:01:22.867]                       muffled <- FALSE
[17:01:22.867]                       if (inherits(cond, "message")) {
[17:01:22.867]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:22.867]                         if (muffled) 
[17:01:22.867]                           invokeRestart("muffleMessage")
[17:01:22.867]                       }
[17:01:22.867]                       else if (inherits(cond, "warning")) {
[17:01:22.867]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:22.867]                         if (muffled) 
[17:01:22.867]                           invokeRestart("muffleWarning")
[17:01:22.867]                       }
[17:01:22.867]                       else if (inherits(cond, "condition")) {
[17:01:22.867]                         if (!is.null(pattern)) {
[17:01:22.867]                           computeRestarts <- base::computeRestarts
[17:01:22.867]                           grepl <- base::grepl
[17:01:22.867]                           restarts <- computeRestarts(cond)
[17:01:22.867]                           for (restart in restarts) {
[17:01:22.867]                             name <- restart$name
[17:01:22.867]                             if (is.null(name)) 
[17:01:22.867]                               next
[17:01:22.867]                             if (!grepl(pattern, name)) 
[17:01:22.867]                               next
[17:01:22.867]                             invokeRestart(restart)
[17:01:22.867]                             muffled <- TRUE
[17:01:22.867]                             break
[17:01:22.867]                           }
[17:01:22.867]                         }
[17:01:22.867]                       }
[17:01:22.867]                       invisible(muffled)
[17:01:22.867]                     }
[17:01:22.867]                     muffleCondition(cond, pattern = "^muffle")
[17:01:22.867]                   }
[17:01:22.867]                 }
[17:01:22.867]             }
[17:01:22.867]         }))
[17:01:22.867]     }, error = function(ex) {
[17:01:22.867]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:22.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:22.867]                 ...future.rng), started = ...future.startTime, 
[17:01:22.867]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:22.867]             version = "1.8"), class = "FutureResult")
[17:01:22.867]     }, finally = {
[17:01:22.867]         if (!identical(...future.workdir, getwd())) 
[17:01:22.867]             setwd(...future.workdir)
[17:01:22.867]         {
[17:01:22.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:22.867]                 ...future.oldOptions$nwarnings <- NULL
[17:01:22.867]             }
[17:01:22.867]             base::options(...future.oldOptions)
[17:01:22.867]             if (.Platform$OS.type == "windows") {
[17:01:22.867]                 old_names <- names(...future.oldEnvVars)
[17:01:22.867]                 envs <- base::Sys.getenv()
[17:01:22.867]                 names <- names(envs)
[17:01:22.867]                 common <- intersect(names, old_names)
[17:01:22.867]                 added <- setdiff(names, old_names)
[17:01:22.867]                 removed <- setdiff(old_names, names)
[17:01:22.867]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:22.867]                   envs[common]]
[17:01:22.867]                 NAMES <- toupper(changed)
[17:01:22.867]                 args <- list()
[17:01:22.867]                 for (kk in seq_along(NAMES)) {
[17:01:22.867]                   name <- changed[[kk]]
[17:01:22.867]                   NAME <- NAMES[[kk]]
[17:01:22.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:22.867]                     next
[17:01:22.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:22.867]                 }
[17:01:22.867]                 NAMES <- toupper(added)
[17:01:22.867]                 for (kk in seq_along(NAMES)) {
[17:01:22.867]                   name <- added[[kk]]
[17:01:22.867]                   NAME <- NAMES[[kk]]
[17:01:22.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:22.867]                     next
[17:01:22.867]                   args[[name]] <- ""
[17:01:22.867]                 }
[17:01:22.867]                 NAMES <- toupper(removed)
[17:01:22.867]                 for (kk in seq_along(NAMES)) {
[17:01:22.867]                   name <- removed[[kk]]
[17:01:22.867]                   NAME <- NAMES[[kk]]
[17:01:22.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:22.867]                     next
[17:01:22.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:22.867]                 }
[17:01:22.867]                 if (length(args) > 0) 
[17:01:22.867]                   base::do.call(base::Sys.setenv, args = args)
[17:01:22.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:22.867]             }
[17:01:22.867]             else {
[17:01:22.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:22.867]             }
[17:01:22.867]             {
[17:01:22.867]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:22.867]                   0L) {
[17:01:22.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:22.867]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:22.867]                   base::options(opts)
[17:01:22.867]                 }
[17:01:22.867]                 {
[17:01:22.867]                   {
[17:01:22.867]                     NULL
[17:01:22.867]                     RNGkind("Mersenne-Twister")
[17:01:22.867]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:22.867]                       inherits = FALSE)
[17:01:22.867]                   }
[17:01:22.867]                   options(future.plan = NULL)
[17:01:22.867]                   if (is.na(NA_character_)) 
[17:01:22.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:22.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:22.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:22.867]                     .init = FALSE)
[17:01:22.867]                 }
[17:01:22.867]             }
[17:01:22.867]         }
[17:01:22.867]     })
[17:01:22.867]     if (TRUE) {
[17:01:22.867]         base::sink(type = "output", split = FALSE)
[17:01:22.867]         if (TRUE) {
[17:01:22.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:22.867]         }
[17:01:22.867]         else {
[17:01:22.867]             ...future.result["stdout"] <- base::list(NULL)
[17:01:22.867]         }
[17:01:22.867]         base::close(...future.stdout)
[17:01:22.867]         ...future.stdout <- NULL
[17:01:22.867]     }
[17:01:22.867]     ...future.result$conditions <- ...future.conditions
[17:01:22.867]     ...future.result$finished <- base::Sys.time()
[17:01:22.867]     ...future.result
[17:01:22.867] }
[17:01:22.868] assign_globals() ...
[17:01:22.868] List of 5
[17:01:22.868]  $ ...future.FUN            :function (x)  
[17:01:22.868]  $ future.call.arguments    : list()
[17:01:22.868]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:22.868]  $ ...future.elements_ii    :List of 2
[17:01:22.868]   ..$ : int 1
[17:01:22.868]   ..$ : int 0
[17:01:22.868]  $ ...future.seeds_ii       : NULL
[17:01:22.868]  $ ...future.globals.maxSize: NULL
[17:01:22.868]  - attr(*, "where")=List of 5
[17:01:22.868]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:22.868]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:22.868]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:22.868]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:22.868]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:22.868]  - attr(*, "resolved")= logi FALSE
[17:01:22.868]  - attr(*, "total_size")= num 4720
[17:01:22.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:22.868]  - attr(*, "already-done")= logi TRUE
[17:01:22.873] - reassign environment for ‘...future.FUN’
[17:01:22.873] - copied ‘...future.FUN’ to environment
[17:01:22.873] - copied ‘future.call.arguments’ to environment
[17:01:22.874] - copied ‘...future.elements_ii’ to environment
[17:01:22.874] - copied ‘...future.seeds_ii’ to environment
[17:01:22.874] - copied ‘...future.globals.maxSize’ to environment
[17:01:22.874] assign_globals() ... done
[17:01:22.874] plan(): Setting new future strategy stack:
[17:01:22.874] List of future strategies:
[17:01:22.874] 1. sequential:
[17:01:22.874]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:22.874]    - tweaked: FALSE
[17:01:22.874]    - call: NULL
[17:01:22.875] plan(): nbrOfWorkers() = 1
[17:01:23.376] plan(): Setting new future strategy stack:
[17:01:23.377] List of future strategies:
[17:01:23.377] 1. multisession:
[17:01:23.377]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:23.377]    - tweaked: FALSE
[17:01:23.377]    - call: plan(strategy)
[17:01:23.380] plan(): nbrOfWorkers() = 1
[17:01:23.381] SequentialFuture started (and completed)
[17:01:23.381] - Launch lazy future ... done
[17:01:23.381] run() for ‘SequentialFuture’ ... done
[17:01:23.381] Created future:
[17:01:23.381] SequentialFuture:
[17:01:23.381] Label: ‘future_lapply-1’
[17:01:23.381] Expression:
[17:01:23.381] {
[17:01:23.381]     do.call(function(...) {
[17:01:23.381]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:23.381]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:23.381]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:23.381]             on.exit(options(oopts), add = TRUE)
[17:01:23.381]         }
[17:01:23.381]         {
[17:01:23.381]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:23.381]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:23.381]                 ...future.FUN(...future.X_jj, ...)
[17:01:23.381]             })
[17:01:23.381]         }
[17:01:23.381]     }, args = future.call.arguments)
[17:01:23.381] }
[17:01:23.381] Lazy evaluation: FALSE
[17:01:23.381] Asynchronous evaluation: FALSE
[17:01:23.381] Local evaluation: TRUE
[17:01:23.381] Environment: R_GlobalEnv
[17:01:23.381] Capture standard output: TRUE
[17:01:23.381] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:23.381] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:23.381] Packages: <none>
[17:01:23.381] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:23.381] Resolved: TRUE
[17:01:23.381] Value: 112 bytes of class ‘list’
[17:01:23.381] Early signaling: FALSE
[17:01:23.381] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:23.381] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:23.382] Chunk #1 of 1 ... DONE
[17:01:23.382] Launching 1 futures (chunks) ... DONE
[17:01:23.382] Resolving 1 futures (chunks) ...
[17:01:23.383] resolve() on list ...
[17:01:23.383]  recursive: 0
[17:01:23.383]  length: 1
[17:01:23.383] 
[17:01:23.383] resolved() for ‘SequentialFuture’ ...
[17:01:23.383] - state: ‘finished’
[17:01:23.383] - run: TRUE
[17:01:23.383] - result: ‘FutureResult’
[17:01:23.383] resolved() for ‘SequentialFuture’ ... done
[17:01:23.383] Future #1
[17:01:23.384] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:23.384] - nx: 1
[17:01:23.384] - relay: TRUE
[17:01:23.384] - stdout: TRUE
[17:01:23.384] - signal: TRUE
[17:01:23.384] - resignal: FALSE
[17:01:23.384] - force: TRUE
[17:01:23.384] - relayed: [n=1] FALSE
[17:01:23.384] - queued futures: [n=1] FALSE
[17:01:23.384]  - until=1
[17:01:23.384]  - relaying element #1
[17:01:23.385] - relayed: [n=1] TRUE
[17:01:23.385] - queued futures: [n=1] TRUE
[17:01:23.385] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:23.385]  length: 0 (resolved future 1)
[17:01:23.385] Relaying remaining futures
[17:01:23.385] signalConditionsASAP(NULL, pos=0) ...
[17:01:23.385] - nx: 1
[17:01:23.385] - relay: TRUE
[17:01:23.385] - stdout: TRUE
[17:01:23.385] - signal: TRUE
[17:01:23.386] - resignal: FALSE
[17:01:23.386] - force: TRUE
[17:01:23.386] - relayed: [n=1] TRUE
[17:01:23.386] - queued futures: [n=1] TRUE
 - flush all
[17:01:23.386] - relayed: [n=1] TRUE
[17:01:23.386] - queued futures: [n=1] TRUE
[17:01:23.386] signalConditionsASAP(NULL, pos=0) ... done
[17:01:23.386] resolve() on list ... DONE
[17:01:23.386]  - Number of value chunks collected: 1
[17:01:23.386] Resolving 1 futures (chunks) ... DONE
[17:01:23.386] Reducing values from 1 chunks ...
[17:01:23.387]  - Number of values collected after concatenation: 2
[17:01:23.387]  - Number of values expected: 2
[17:01:23.387] Reducing values from 1 chunks ... DONE
[17:01:23.387] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:01:23.387] future_lapply() ...
[17:01:23.391] Number of chunks: 1
[17:01:23.391] getGlobalsAndPackagesXApply() ...
[17:01:23.391]  - future.globals: TRUE
[17:01:23.391] getGlobalsAndPackages() ...
[17:01:23.391] Searching for globals...
[17:01:23.393] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:23.393] Searching for globals ... DONE
[17:01:23.393] Resolving globals: FALSE
[17:01:23.393] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:23.394] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:23.394] - globals: [1] ‘FUN’
[17:01:23.394] 
[17:01:23.394] getGlobalsAndPackages() ... DONE
[17:01:23.394]  - globals found/used: [n=1] ‘FUN’
[17:01:23.394]  - needed namespaces: [n=0] 
[17:01:23.394] Finding globals ... DONE
[17:01:23.394]  - use_args: TRUE
[17:01:23.394]  - Getting '...' globals ...
[17:01:23.395] resolve() on list ...
[17:01:23.395]  recursive: 0
[17:01:23.395]  length: 1
[17:01:23.395]  elements: ‘...’
[17:01:23.395]  length: 0 (resolved future 1)
[17:01:23.395] resolve() on list ... DONE
[17:01:23.395]    - '...' content: [n=0] 
[17:01:23.397] List of 1
[17:01:23.397]  $ ...: list()
[17:01:23.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:23.397]  - attr(*, "where")=List of 1
[17:01:23.397]   ..$ ...:<environment: 0x5636f6d9b6c0> 
[17:01:23.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:23.397]  - attr(*, "resolved")= logi TRUE
[17:01:23.397]  - attr(*, "total_size")= num NA
[17:01:23.400]  - Getting '...' globals ... DONE
[17:01:23.400] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:23.400] List of 2
[17:01:23.400]  $ ...future.FUN:function (x)  
[17:01:23.400]  $ ...          : list()
[17:01:23.400]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:23.400]  - attr(*, "where")=List of 2
[17:01:23.400]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:23.400]   ..$ ...          :<environment: 0x5636f6d9b6c0> 
[17:01:23.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:23.400]  - attr(*, "resolved")= logi FALSE
[17:01:23.400]  - attr(*, "total_size")= num 4720
[17:01:23.403] Packages to be attached in all futures: [n=0] 
[17:01:23.403] getGlobalsAndPackagesXApply() ... DONE
[17:01:23.403] Number of futures (= number of chunks): 1
[17:01:23.403] Launching 1 futures (chunks) ...
[17:01:23.403] Chunk #1 of 1 ...
[17:01:23.403]  - Finding globals in 'X' for chunk #1 ...
[17:01:23.404] getGlobalsAndPackages() ...
[17:01:23.404] Searching for globals...
[17:01:23.404] 
[17:01:23.404] Searching for globals ... DONE
[17:01:23.404] - globals: [0] <none>
[17:01:23.404] getGlobalsAndPackages() ... DONE
[17:01:23.404]    + additional globals found: [n=0] 
[17:01:23.404]    + additional namespaces needed: [n=0] 
[17:01:23.404]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:23.404]  - seeds: <none>
[17:01:23.405]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:23.405] getGlobalsAndPackages() ...
[17:01:23.405] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:23.405] Resolving globals: FALSE
[17:01:23.405] Tweak future expression to call with '...' arguments ...
[17:01:23.405] {
[17:01:23.405]     do.call(function(...) {
[17:01:23.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:23.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:23.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:23.405]             on.exit(options(oopts), add = TRUE)
[17:01:23.405]         }
[17:01:23.405]         {
[17:01:23.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:23.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:23.405]                 ...future.FUN(...future.X_jj, ...)
[17:01:23.405]             })
[17:01:23.405]         }
[17:01:23.405]     }, args = future.call.arguments)
[17:01:23.405] }
[17:01:23.405] Tweak future expression to call with '...' arguments ... DONE
[17:01:23.406] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:23.406] 
[17:01:23.406] getGlobalsAndPackages() ... DONE
[17:01:23.406] run() for ‘Future’ ...
[17:01:23.406] - state: ‘created’
[17:01:23.406] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:23.410] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:23.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:23.410]   - Field: ‘label’
[17:01:23.410]   - Field: ‘local’
[17:01:23.410]   - Field: ‘owner’
[17:01:23.410]   - Field: ‘envir’
[17:01:23.411]   - Field: ‘packages’
[17:01:23.411]   - Field: ‘gc’
[17:01:23.411]   - Field: ‘conditions’
[17:01:23.411]   - Field: ‘expr’
[17:01:23.411]   - Field: ‘uuid’
[17:01:23.411]   - Field: ‘seed’
[17:01:23.411]   - Field: ‘version’
[17:01:23.411]   - Field: ‘result’
[17:01:23.411]   - Field: ‘asynchronous’
[17:01:23.411]   - Field: ‘calls’
[17:01:23.412]   - Field: ‘globals’
[17:01:23.412]   - Field: ‘stdout’
[17:01:23.412]   - Field: ‘earlySignal’
[17:01:23.412]   - Field: ‘lazy’
[17:01:23.412]   - Field: ‘state’
[17:01:23.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:23.412] - Launch lazy future ...
[17:01:23.412] Packages needed by the future expression (n = 0): <none>
[17:01:23.412] Packages needed by future strategies (n = 0): <none>
[17:01:23.413] {
[17:01:23.413]     {
[17:01:23.413]         {
[17:01:23.413]             ...future.startTime <- base::Sys.time()
[17:01:23.413]             {
[17:01:23.413]                 {
[17:01:23.413]                   {
[17:01:23.413]                     base::local({
[17:01:23.413]                       has_future <- base::requireNamespace("future", 
[17:01:23.413]                         quietly = TRUE)
[17:01:23.413]                       if (has_future) {
[17:01:23.413]                         ns <- base::getNamespace("future")
[17:01:23.413]                         version <- ns[[".package"]][["version"]]
[17:01:23.413]                         if (is.null(version)) 
[17:01:23.413]                           version <- utils::packageVersion("future")
[17:01:23.413]                       }
[17:01:23.413]                       else {
[17:01:23.413]                         version <- NULL
[17:01:23.413]                       }
[17:01:23.413]                       if (!has_future || version < "1.8.0") {
[17:01:23.413]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:23.413]                           "", base::R.version$version.string), 
[17:01:23.413]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:23.413]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:23.413]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:23.413]                             "release", "version")], collapse = " "), 
[17:01:23.413]                           hostname = base::Sys.info()[["nodename"]])
[17:01:23.413]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:23.413]                           info)
[17:01:23.413]                         info <- base::paste(info, collapse = "; ")
[17:01:23.413]                         if (!has_future) {
[17:01:23.413]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:23.413]                             info)
[17:01:23.413]                         }
[17:01:23.413]                         else {
[17:01:23.413]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:23.413]                             info, version)
[17:01:23.413]                         }
[17:01:23.413]                         base::stop(msg)
[17:01:23.413]                       }
[17:01:23.413]                     })
[17:01:23.413]                   }
[17:01:23.413]                   ...future.strategy.old <- future::plan("list")
[17:01:23.413]                   options(future.plan = NULL)
[17:01:23.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:23.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:23.413]                 }
[17:01:23.413]                 ...future.workdir <- getwd()
[17:01:23.413]             }
[17:01:23.413]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:23.413]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:23.413]         }
[17:01:23.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:23.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:23.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:23.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:23.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:23.413]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:23.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:23.413]             base::names(...future.oldOptions))
[17:01:23.413]     }
[17:01:23.413]     if (TRUE) {
[17:01:23.413]     }
[17:01:23.413]     else {
[17:01:23.413]         if (NA) {
[17:01:23.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:23.413]                 open = "w")
[17:01:23.413]         }
[17:01:23.413]         else {
[17:01:23.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:23.413]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:23.413]         }
[17:01:23.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:23.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:23.413]             base::sink(type = "output", split = FALSE)
[17:01:23.413]             base::close(...future.stdout)
[17:01:23.413]         }, add = TRUE)
[17:01:23.413]     }
[17:01:23.413]     ...future.frame <- base::sys.nframe()
[17:01:23.413]     ...future.conditions <- base::list()
[17:01:23.413]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:23.413]     if (FALSE) {
[17:01:23.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:23.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:23.413]     }
[17:01:23.413]     ...future.result <- base::tryCatch({
[17:01:23.413]         base::withCallingHandlers({
[17:01:23.413]             ...future.value <- base::withVisible(base::local({
[17:01:23.413]                 do.call(function(...) {
[17:01:23.413]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:23.413]                   if (!identical(...future.globals.maxSize.org, 
[17:01:23.413]                     ...future.globals.maxSize)) {
[17:01:23.413]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:23.413]                     on.exit(options(oopts), add = TRUE)
[17:01:23.413]                   }
[17:01:23.413]                   {
[17:01:23.413]                     lapply(seq_along(...future.elements_ii), 
[17:01:23.413]                       FUN = function(jj) {
[17:01:23.413]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:23.413]                         ...future.FUN(...future.X_jj, ...)
[17:01:23.413]                       })
[17:01:23.413]                   }
[17:01:23.413]                 }, args = future.call.arguments)
[17:01:23.413]             }))
[17:01:23.413]             future::FutureResult(value = ...future.value$value, 
[17:01:23.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:23.413]                   ...future.rng), globalenv = if (FALSE) 
[17:01:23.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:23.413]                     ...future.globalenv.names))
[17:01:23.413]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:23.413]         }, condition = base::local({
[17:01:23.413]             c <- base::c
[17:01:23.413]             inherits <- base::inherits
[17:01:23.413]             invokeRestart <- base::invokeRestart
[17:01:23.413]             length <- base::length
[17:01:23.413]             list <- base::list
[17:01:23.413]             seq.int <- base::seq.int
[17:01:23.413]             signalCondition <- base::signalCondition
[17:01:23.413]             sys.calls <- base::sys.calls
[17:01:23.413]             `[[` <- base::`[[`
[17:01:23.413]             `+` <- base::`+`
[17:01:23.413]             `<<-` <- base::`<<-`
[17:01:23.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:23.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:23.413]                   3L)]
[17:01:23.413]             }
[17:01:23.413]             function(cond) {
[17:01:23.413]                 is_error <- inherits(cond, "error")
[17:01:23.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:23.413]                   NULL)
[17:01:23.413]                 if (is_error) {
[17:01:23.413]                   sessionInformation <- function() {
[17:01:23.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:23.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:23.413]                       search = base::search(), system = base::Sys.info())
[17:01:23.413]                   }
[17:01:23.413]                   ...future.conditions[[length(...future.conditions) + 
[17:01:23.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:23.413]                     cond$call), session = sessionInformation(), 
[17:01:23.413]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:23.413]                   signalCondition(cond)
[17:01:23.413]                 }
[17:01:23.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:23.413]                 "immediateCondition"))) {
[17:01:23.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:23.413]                   ...future.conditions[[length(...future.conditions) + 
[17:01:23.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:23.413]                   if (TRUE && !signal) {
[17:01:23.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:23.413]                     {
[17:01:23.413]                       inherits <- base::inherits
[17:01:23.413]                       invokeRestart <- base::invokeRestart
[17:01:23.413]                       is.null <- base::is.null
[17:01:23.413]                       muffled <- FALSE
[17:01:23.413]                       if (inherits(cond, "message")) {
[17:01:23.413]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:23.413]                         if (muffled) 
[17:01:23.413]                           invokeRestart("muffleMessage")
[17:01:23.413]                       }
[17:01:23.413]                       else if (inherits(cond, "warning")) {
[17:01:23.413]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:23.413]                         if (muffled) 
[17:01:23.413]                           invokeRestart("muffleWarning")
[17:01:23.413]                       }
[17:01:23.413]                       else if (inherits(cond, "condition")) {
[17:01:23.413]                         if (!is.null(pattern)) {
[17:01:23.413]                           computeRestarts <- base::computeRestarts
[17:01:23.413]                           grepl <- base::grepl
[17:01:23.413]                           restarts <- computeRestarts(cond)
[17:01:23.413]                           for (restart in restarts) {
[17:01:23.413]                             name <- restart$name
[17:01:23.413]                             if (is.null(name)) 
[17:01:23.413]                               next
[17:01:23.413]                             if (!grepl(pattern, name)) 
[17:01:23.413]                               next
[17:01:23.413]                             invokeRestart(restart)
[17:01:23.413]                             muffled <- TRUE
[17:01:23.413]                             break
[17:01:23.413]                           }
[17:01:23.413]                         }
[17:01:23.413]                       }
[17:01:23.413]                       invisible(muffled)
[17:01:23.413]                     }
[17:01:23.413]                     muffleCondition(cond, pattern = "^muffle")
[17:01:23.413]                   }
[17:01:23.413]                 }
[17:01:23.413]                 else {
[17:01:23.413]                   if (TRUE) {
[17:01:23.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:23.413]                     {
[17:01:23.413]                       inherits <- base::inherits
[17:01:23.413]                       invokeRestart <- base::invokeRestart
[17:01:23.413]                       is.null <- base::is.null
[17:01:23.413]                       muffled <- FALSE
[17:01:23.413]                       if (inherits(cond, "message")) {
[17:01:23.413]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:23.413]                         if (muffled) 
[17:01:23.413]                           invokeRestart("muffleMessage")
[17:01:23.413]                       }
[17:01:23.413]                       else if (inherits(cond, "warning")) {
[17:01:23.413]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:23.413]                         if (muffled) 
[17:01:23.413]                           invokeRestart("muffleWarning")
[17:01:23.413]                       }
[17:01:23.413]                       else if (inherits(cond, "condition")) {
[17:01:23.413]                         if (!is.null(pattern)) {
[17:01:23.413]                           computeRestarts <- base::computeRestarts
[17:01:23.413]                           grepl <- base::grepl
[17:01:23.413]                           restarts <- computeRestarts(cond)
[17:01:23.413]                           for (restart in restarts) {
[17:01:23.413]                             name <- restart$name
[17:01:23.413]                             if (is.null(name)) 
[17:01:23.413]                               next
[17:01:23.413]                             if (!grepl(pattern, name)) 
[17:01:23.413]                               next
[17:01:23.413]                             invokeRestart(restart)
[17:01:23.413]                             muffled <- TRUE
[17:01:23.413]                             break
[17:01:23.413]                           }
[17:01:23.413]                         }
[17:01:23.413]                       }
[17:01:23.413]                       invisible(muffled)
[17:01:23.413]                     }
[17:01:23.413]                     muffleCondition(cond, pattern = "^muffle")
[17:01:23.413]                   }
[17:01:23.413]                 }
[17:01:23.413]             }
[17:01:23.413]         }))
[17:01:23.413]     }, error = function(ex) {
[17:01:23.413]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:23.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:23.413]                 ...future.rng), started = ...future.startTime, 
[17:01:23.413]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:23.413]             version = "1.8"), class = "FutureResult")
[17:01:23.413]     }, finally = {
[17:01:23.413]         if (!identical(...future.workdir, getwd())) 
[17:01:23.413]             setwd(...future.workdir)
[17:01:23.413]         {
[17:01:23.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:23.413]                 ...future.oldOptions$nwarnings <- NULL
[17:01:23.413]             }
[17:01:23.413]             base::options(...future.oldOptions)
[17:01:23.413]             if (.Platform$OS.type == "windows") {
[17:01:23.413]                 old_names <- names(...future.oldEnvVars)
[17:01:23.413]                 envs <- base::Sys.getenv()
[17:01:23.413]                 names <- names(envs)
[17:01:23.413]                 common <- intersect(names, old_names)
[17:01:23.413]                 added <- setdiff(names, old_names)
[17:01:23.413]                 removed <- setdiff(old_names, names)
[17:01:23.413]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:23.413]                   envs[common]]
[17:01:23.413]                 NAMES <- toupper(changed)
[17:01:23.413]                 args <- list()
[17:01:23.413]                 for (kk in seq_along(NAMES)) {
[17:01:23.413]                   name <- changed[[kk]]
[17:01:23.413]                   NAME <- NAMES[[kk]]
[17:01:23.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:23.413]                     next
[17:01:23.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:23.413]                 }
[17:01:23.413]                 NAMES <- toupper(added)
[17:01:23.413]                 for (kk in seq_along(NAMES)) {
[17:01:23.413]                   name <- added[[kk]]
[17:01:23.413]                   NAME <- NAMES[[kk]]
[17:01:23.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:23.413]                     next
[17:01:23.413]                   args[[name]] <- ""
[17:01:23.413]                 }
[17:01:23.413]                 NAMES <- toupper(removed)
[17:01:23.413]                 for (kk in seq_along(NAMES)) {
[17:01:23.413]                   name <- removed[[kk]]
[17:01:23.413]                   NAME <- NAMES[[kk]]
[17:01:23.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:23.413]                     next
[17:01:23.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:23.413]                 }
[17:01:23.413]                 if (length(args) > 0) 
[17:01:23.413]                   base::do.call(base::Sys.setenv, args = args)
[17:01:23.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:23.413]             }
[17:01:23.413]             else {
[17:01:23.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:23.413]             }
[17:01:23.413]             {
[17:01:23.413]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:23.413]                   0L) {
[17:01:23.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:23.413]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:23.413]                   base::options(opts)
[17:01:23.413]                 }
[17:01:23.413]                 {
[17:01:23.413]                   {
[17:01:23.413]                     NULL
[17:01:23.413]                     RNGkind("Mersenne-Twister")
[17:01:23.413]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:23.413]                       inherits = FALSE)
[17:01:23.413]                   }
[17:01:23.413]                   options(future.plan = NULL)
[17:01:23.413]                   if (is.na(NA_character_)) 
[17:01:23.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:23.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:23.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:23.413]                     .init = FALSE)
[17:01:23.413]                 }
[17:01:23.413]             }
[17:01:23.413]         }
[17:01:23.413]     })
[17:01:23.413]     if (FALSE) {
[17:01:23.413]         base::sink(type = "output", split = FALSE)
[17:01:23.413]         if (NA) {
[17:01:23.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:23.413]         }
[17:01:23.413]         else {
[17:01:23.413]             ...future.result["stdout"] <- base::list(NULL)
[17:01:23.413]         }
[17:01:23.413]         base::close(...future.stdout)
[17:01:23.413]         ...future.stdout <- NULL
[17:01:23.413]     }
[17:01:23.413]     ...future.result$conditions <- ...future.conditions
[17:01:23.413]     ...future.result$finished <- base::Sys.time()
[17:01:23.413]     ...future.result
[17:01:23.413] }
[17:01:23.415] assign_globals() ...
[17:01:23.415] List of 5
[17:01:23.415]  $ ...future.FUN            :function (x)  
[17:01:23.415]  $ future.call.arguments    : list()
[17:01:23.415]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:23.415]  $ ...future.elements_ii    :List of 2
[17:01:23.415]   ..$ : int 1
[17:01:23.415]   ..$ : int 0
[17:01:23.415]  $ ...future.seeds_ii       : NULL
[17:01:23.415]  $ ...future.globals.maxSize: NULL
[17:01:23.415]  - attr(*, "where")=List of 5
[17:01:23.415]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:23.415]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:23.415]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:23.415]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:23.415]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:23.415]  - attr(*, "resolved")= logi FALSE
[17:01:23.415]  - attr(*, "total_size")= num 4720
[17:01:23.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:23.415]  - attr(*, "already-done")= logi TRUE
[17:01:23.420] - reassign environment for ‘...future.FUN’
[17:01:23.420] - copied ‘...future.FUN’ to environment
[17:01:23.420] - copied ‘future.call.arguments’ to environment
[17:01:23.420] - copied ‘...future.elements_ii’ to environment
[17:01:23.420] - copied ‘...future.seeds_ii’ to environment
[17:01:23.420] - copied ‘...future.globals.maxSize’ to environment
[17:01:23.420] assign_globals() ... done
[17:01:23.420] plan(): Setting new future strategy stack:
[17:01:23.421] List of future strategies:
[17:01:23.421] 1. sequential:
[17:01:23.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:23.421]    - tweaked: FALSE
[17:01:23.421]    - call: NULL
[17:01:23.421] plan(): nbrOfWorkers() = 1
[17:01:23.923] plan(): Setting new future strategy stack:
[17:01:23.923] List of future strategies:
[17:01:23.923] 1. multisession:
[17:01:23.923]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:23.923]    - tweaked: FALSE
[17:01:23.923]    - call: plan(strategy)
[17:01:23.927] plan(): nbrOfWorkers() = 1
[17:01:23.927] SequentialFuture started (and completed)
[17:01:23.927] - Launch lazy future ... done
[17:01:23.928] run() for ‘SequentialFuture’ ... done
[17:01:23.928] Created future:
[17:01:23.928] SequentialFuture:
[17:01:23.928] Label: ‘future_lapply-1’
[17:01:23.928] Expression:
[17:01:23.928] {
[17:01:23.928]     do.call(function(...) {
[17:01:23.928]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:23.928]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:23.928]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:23.928]             on.exit(options(oopts), add = TRUE)
[17:01:23.928]         }
[17:01:23.928]         {
[17:01:23.928]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:23.928]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:23.928]                 ...future.FUN(...future.X_jj, ...)
[17:01:23.928]             })
[17:01:23.928]         }
[17:01:23.928]     }, args = future.call.arguments)
[17:01:23.928] }
[17:01:23.928] Lazy evaluation: FALSE
[17:01:23.928] Asynchronous evaluation: FALSE
[17:01:23.928] Local evaluation: TRUE
[17:01:23.928] Environment: R_GlobalEnv
[17:01:23.928] Capture standard output: NA
[17:01:23.928] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:23.928] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:23.928] Packages: <none>
[17:01:23.928] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:23.928] Resolved: TRUE
[17:01:23.928] Value: 112 bytes of class ‘list’
[17:01:23.928] Early signaling: FALSE
[17:01:23.928] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:23.928] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:23.929] Chunk #1 of 1 ... DONE
[17:01:23.929] Launching 1 futures (chunks) ... DONE
[17:01:23.929] Resolving 1 futures (chunks) ...
[17:01:23.930] resolve() on list ...
[17:01:23.930]  recursive: 0
[17:01:23.930]  length: 1
[17:01:23.930] 
[17:01:23.930] resolved() for ‘SequentialFuture’ ...
[17:01:23.930] - state: ‘finished’
[17:01:23.930] - run: TRUE
[17:01:23.930] - result: ‘FutureResult’
[17:01:23.930] resolved() for ‘SequentialFuture’ ... done
[17:01:23.930] Future #1
[17:01:23.931] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:23.931] - nx: 1
[17:01:23.931] - relay: TRUE
[17:01:23.931] - stdout: TRUE
[17:01:23.931] - signal: TRUE
[17:01:23.931] - resignal: FALSE
[17:01:23.933] - force: TRUE
[17:01:23.933] - relayed: [n=1] FALSE
[17:01:23.933] - queued futures: [n=1] FALSE
[17:01:23.933]  - until=1
[17:01:23.933]  - relaying element #1
[17:01:23.933] - relayed: [n=1] TRUE
[17:01:23.933] - queued futures: [n=1] TRUE
[17:01:23.934] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:23.934]  length: 0 (resolved future 1)
[17:01:23.934] Relaying remaining futures
[17:01:23.934] signalConditionsASAP(NULL, pos=0) ...
[17:01:23.934] - nx: 1
[17:01:23.934] - relay: TRUE
[17:01:23.934] - stdout: TRUE
[17:01:23.934] - signal: TRUE
[17:01:23.934] - resignal: FALSE
[17:01:23.935] - force: TRUE
[17:01:23.935] - relayed: [n=1] TRUE
[17:01:23.935] - queued futures: [n=1] TRUE
 - flush all
[17:01:23.935] - relayed: [n=1] TRUE
[17:01:23.935] - queued futures: [n=1] TRUE
[17:01:23.935] signalConditionsASAP(NULL, pos=0) ... done
[17:01:23.935] resolve() on list ... DONE
[17:01:23.935]  - Number of value chunks collected: 1
[17:01:23.936] Resolving 1 futures (chunks) ... DONE
[17:01:23.936] Reducing values from 1 chunks ...
[17:01:23.936]  - Number of values collected after concatenation: 2
[17:01:23.936]  - Number of values expected: 2
[17:01:23.936] Reducing values from 1 chunks ... DONE
[17:01:23.936] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:01:23.936] future_mapply() ...
[17:01:23.940] Number of chunks: 1
[17:01:23.940] getGlobalsAndPackagesXApply() ...
[17:01:23.940]  - future.globals: TRUE
[17:01:23.940] getGlobalsAndPackages() ...
[17:01:23.940] Searching for globals...
[17:01:23.942] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:23.942] Searching for globals ... DONE
[17:01:23.942] Resolving globals: FALSE
[17:01:23.942] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:23.943] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:23.943] - globals: [1] ‘FUN’
[17:01:23.943] 
[17:01:23.943] getGlobalsAndPackages() ... DONE
[17:01:23.943]  - globals found/used: [n=1] ‘FUN’
[17:01:23.943]  - needed namespaces: [n=0] 
[17:01:23.943] Finding globals ... DONE
[17:01:23.943] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:23.944] List of 2
[17:01:23.944]  $ ...future.FUN:function (x, y)  
[17:01:23.944]  $ MoreArgs     : NULL
[17:01:23.944]  - attr(*, "where")=List of 2
[17:01:23.944]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:23.944]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:23.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:23.944]  - attr(*, "resolved")= logi FALSE
[17:01:23.944]  - attr(*, "total_size")= num NA
[17:01:23.946] Packages to be attached in all futures: [n=0] 
[17:01:23.946] getGlobalsAndPackagesXApply() ... DONE
[17:01:23.946] Number of futures (= number of chunks): 1
[17:01:23.946] Launching 1 futures (chunks) ...
[17:01:23.947] Chunk #1 of 1 ...
[17:01:23.947]  - Finding globals in '...' for chunk #1 ...
[17:01:23.947] getGlobalsAndPackages() ...
[17:01:23.947] Searching for globals...
[17:01:23.947] 
[17:01:23.947] Searching for globals ... DONE
[17:01:23.947] - globals: [0] <none>
[17:01:23.947] getGlobalsAndPackages() ... DONE
[17:01:23.948]    + additional globals found: [n=0] 
[17:01:23.948]    + additional namespaces needed: [n=0] 
[17:01:23.948]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:23.948]  - seeds: <none>
[17:01:23.948]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:23.948] getGlobalsAndPackages() ...
[17:01:23.948] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:23.948] Resolving globals: FALSE
[17:01:23.949] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:01:23.949] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:23.949] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:23.950] 
[17:01:23.950] getGlobalsAndPackages() ... DONE
[17:01:23.950] run() for ‘Future’ ...
[17:01:23.950] - state: ‘created’
[17:01:23.950] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:23.954] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:23.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:23.954]   - Field: ‘label’
[17:01:23.954]   - Field: ‘local’
[17:01:23.954]   - Field: ‘owner’
[17:01:23.954]   - Field: ‘envir’
[17:01:23.954]   - Field: ‘packages’
[17:01:23.954]   - Field: ‘gc’
[17:01:23.955]   - Field: ‘conditions’
[17:01:23.955]   - Field: ‘expr’
[17:01:23.955]   - Field: ‘uuid’
[17:01:23.955]   - Field: ‘seed’
[17:01:23.955]   - Field: ‘version’
[17:01:23.955]   - Field: ‘result’
[17:01:23.955]   - Field: ‘asynchronous’
[17:01:23.955]   - Field: ‘calls’
[17:01:23.955]   - Field: ‘globals’
[17:01:23.955]   - Field: ‘stdout’
[17:01:23.956]   - Field: ‘earlySignal’
[17:01:23.956]   - Field: ‘lazy’
[17:01:23.956]   - Field: ‘state’
[17:01:23.956] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:23.956] - Launch lazy future ...
[17:01:23.956] Packages needed by the future expression (n = 0): <none>
[17:01:23.956] Packages needed by future strategies (n = 0): <none>
[17:01:23.957] {
[17:01:23.957]     {
[17:01:23.957]         {
[17:01:23.957]             ...future.startTime <- base::Sys.time()
[17:01:23.957]             {
[17:01:23.957]                 {
[17:01:23.957]                   {
[17:01:23.957]                     base::local({
[17:01:23.957]                       has_future <- base::requireNamespace("future", 
[17:01:23.957]                         quietly = TRUE)
[17:01:23.957]                       if (has_future) {
[17:01:23.957]                         ns <- base::getNamespace("future")
[17:01:23.957]                         version <- ns[[".package"]][["version"]]
[17:01:23.957]                         if (is.null(version)) 
[17:01:23.957]                           version <- utils::packageVersion("future")
[17:01:23.957]                       }
[17:01:23.957]                       else {
[17:01:23.957]                         version <- NULL
[17:01:23.957]                       }
[17:01:23.957]                       if (!has_future || version < "1.8.0") {
[17:01:23.957]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:23.957]                           "", base::R.version$version.string), 
[17:01:23.957]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:23.957]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:23.957]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:23.957]                             "release", "version")], collapse = " "), 
[17:01:23.957]                           hostname = base::Sys.info()[["nodename"]])
[17:01:23.957]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:23.957]                           info)
[17:01:23.957]                         info <- base::paste(info, collapse = "; ")
[17:01:23.957]                         if (!has_future) {
[17:01:23.957]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:23.957]                             info)
[17:01:23.957]                         }
[17:01:23.957]                         else {
[17:01:23.957]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:23.957]                             info, version)
[17:01:23.957]                         }
[17:01:23.957]                         base::stop(msg)
[17:01:23.957]                       }
[17:01:23.957]                     })
[17:01:23.957]                   }
[17:01:23.957]                   ...future.strategy.old <- future::plan("list")
[17:01:23.957]                   options(future.plan = NULL)
[17:01:23.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:23.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:23.957]                 }
[17:01:23.957]                 ...future.workdir <- getwd()
[17:01:23.957]             }
[17:01:23.957]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:23.957]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:23.957]         }
[17:01:23.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:23.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:23.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:23.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:23.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:23.957]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:23.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:23.957]             base::names(...future.oldOptions))
[17:01:23.957]     }
[17:01:23.957]     if (FALSE) {
[17:01:23.957]     }
[17:01:23.957]     else {
[17:01:23.957]         if (FALSE) {
[17:01:23.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:23.957]                 open = "w")
[17:01:23.957]         }
[17:01:23.957]         else {
[17:01:23.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:23.957]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:23.957]         }
[17:01:23.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:23.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:23.957]             base::sink(type = "output", split = FALSE)
[17:01:23.957]             base::close(...future.stdout)
[17:01:23.957]         }, add = TRUE)
[17:01:23.957]     }
[17:01:23.957]     ...future.frame <- base::sys.nframe()
[17:01:23.957]     ...future.conditions <- base::list()
[17:01:23.957]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:23.957]     if (FALSE) {
[17:01:23.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:23.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:23.957]     }
[17:01:23.957]     ...future.result <- base::tryCatch({
[17:01:23.957]         base::withCallingHandlers({
[17:01:23.957]             ...future.value <- base::withVisible(base::local({
[17:01:23.957]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:23.957]                 if (!identical(...future.globals.maxSize.org, 
[17:01:23.957]                   ...future.globals.maxSize)) {
[17:01:23.957]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:23.957]                   on.exit(options(oopts), add = TRUE)
[17:01:23.957]                 }
[17:01:23.957]                 {
[17:01:23.957]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:23.957]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:23.957]                     USE.NAMES = FALSE)
[17:01:23.957]                   do.call(mapply, args = args)
[17:01:23.957]                 }
[17:01:23.957]             }))
[17:01:23.957]             future::FutureResult(value = ...future.value$value, 
[17:01:23.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:23.957]                   ...future.rng), globalenv = if (FALSE) 
[17:01:23.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:23.957]                     ...future.globalenv.names))
[17:01:23.957]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:23.957]         }, condition = base::local({
[17:01:23.957]             c <- base::c
[17:01:23.957]             inherits <- base::inherits
[17:01:23.957]             invokeRestart <- base::invokeRestart
[17:01:23.957]             length <- base::length
[17:01:23.957]             list <- base::list
[17:01:23.957]             seq.int <- base::seq.int
[17:01:23.957]             signalCondition <- base::signalCondition
[17:01:23.957]             sys.calls <- base::sys.calls
[17:01:23.957]             `[[` <- base::`[[`
[17:01:23.957]             `+` <- base::`+`
[17:01:23.957]             `<<-` <- base::`<<-`
[17:01:23.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:23.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:23.957]                   3L)]
[17:01:23.957]             }
[17:01:23.957]             function(cond) {
[17:01:23.957]                 is_error <- inherits(cond, "error")
[17:01:23.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:23.957]                   NULL)
[17:01:23.957]                 if (is_error) {
[17:01:23.957]                   sessionInformation <- function() {
[17:01:23.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:23.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:23.957]                       search = base::search(), system = base::Sys.info())
[17:01:23.957]                   }
[17:01:23.957]                   ...future.conditions[[length(...future.conditions) + 
[17:01:23.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:23.957]                     cond$call), session = sessionInformation(), 
[17:01:23.957]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:23.957]                   signalCondition(cond)
[17:01:23.957]                 }
[17:01:23.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:23.957]                 "immediateCondition"))) {
[17:01:23.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:23.957]                   ...future.conditions[[length(...future.conditions) + 
[17:01:23.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:23.957]                   if (TRUE && !signal) {
[17:01:23.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:23.957]                     {
[17:01:23.957]                       inherits <- base::inherits
[17:01:23.957]                       invokeRestart <- base::invokeRestart
[17:01:23.957]                       is.null <- base::is.null
[17:01:23.957]                       muffled <- FALSE
[17:01:23.957]                       if (inherits(cond, "message")) {
[17:01:23.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:23.957]                         if (muffled) 
[17:01:23.957]                           invokeRestart("muffleMessage")
[17:01:23.957]                       }
[17:01:23.957]                       else if (inherits(cond, "warning")) {
[17:01:23.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:23.957]                         if (muffled) 
[17:01:23.957]                           invokeRestart("muffleWarning")
[17:01:23.957]                       }
[17:01:23.957]                       else if (inherits(cond, "condition")) {
[17:01:23.957]                         if (!is.null(pattern)) {
[17:01:23.957]                           computeRestarts <- base::computeRestarts
[17:01:23.957]                           grepl <- base::grepl
[17:01:23.957]                           restarts <- computeRestarts(cond)
[17:01:23.957]                           for (restart in restarts) {
[17:01:23.957]                             name <- restart$name
[17:01:23.957]                             if (is.null(name)) 
[17:01:23.957]                               next
[17:01:23.957]                             if (!grepl(pattern, name)) 
[17:01:23.957]                               next
[17:01:23.957]                             invokeRestart(restart)
[17:01:23.957]                             muffled <- TRUE
[17:01:23.957]                             break
[17:01:23.957]                           }
[17:01:23.957]                         }
[17:01:23.957]                       }
[17:01:23.957]                       invisible(muffled)
[17:01:23.957]                     }
[17:01:23.957]                     muffleCondition(cond, pattern = "^muffle")
[17:01:23.957]                   }
[17:01:23.957]                 }
[17:01:23.957]                 else {
[17:01:23.957]                   if (TRUE) {
[17:01:23.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:23.957]                     {
[17:01:23.957]                       inherits <- base::inherits
[17:01:23.957]                       invokeRestart <- base::invokeRestart
[17:01:23.957]                       is.null <- base::is.null
[17:01:23.957]                       muffled <- FALSE
[17:01:23.957]                       if (inherits(cond, "message")) {
[17:01:23.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:23.957]                         if (muffled) 
[17:01:23.957]                           invokeRestart("muffleMessage")
[17:01:23.957]                       }
[17:01:23.957]                       else if (inherits(cond, "warning")) {
[17:01:23.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:23.957]                         if (muffled) 
[17:01:23.957]                           invokeRestart("muffleWarning")
[17:01:23.957]                       }
[17:01:23.957]                       else if (inherits(cond, "condition")) {
[17:01:23.957]                         if (!is.null(pattern)) {
[17:01:23.957]                           computeRestarts <- base::computeRestarts
[17:01:23.957]                           grepl <- base::grepl
[17:01:23.957]                           restarts <- computeRestarts(cond)
[17:01:23.957]                           for (restart in restarts) {
[17:01:23.957]                             name <- restart$name
[17:01:23.957]                             if (is.null(name)) 
[17:01:23.957]                               next
[17:01:23.957]                             if (!grepl(pattern, name)) 
[17:01:23.957]                               next
[17:01:23.957]                             invokeRestart(restart)
[17:01:23.957]                             muffled <- TRUE
[17:01:23.957]                             break
[17:01:23.957]                           }
[17:01:23.957]                         }
[17:01:23.957]                       }
[17:01:23.957]                       invisible(muffled)
[17:01:23.957]                     }
[17:01:23.957]                     muffleCondition(cond, pattern = "^muffle")
[17:01:23.957]                   }
[17:01:23.957]                 }
[17:01:23.957]             }
[17:01:23.957]         }))
[17:01:23.957]     }, error = function(ex) {
[17:01:23.957]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:23.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:23.957]                 ...future.rng), started = ...future.startTime, 
[17:01:23.957]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:23.957]             version = "1.8"), class = "FutureResult")
[17:01:23.957]     }, finally = {
[17:01:23.957]         if (!identical(...future.workdir, getwd())) 
[17:01:23.957]             setwd(...future.workdir)
[17:01:23.957]         {
[17:01:23.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:23.957]                 ...future.oldOptions$nwarnings <- NULL
[17:01:23.957]             }
[17:01:23.957]             base::options(...future.oldOptions)
[17:01:23.957]             if (.Platform$OS.type == "windows") {
[17:01:23.957]                 old_names <- names(...future.oldEnvVars)
[17:01:23.957]                 envs <- base::Sys.getenv()
[17:01:23.957]                 names <- names(envs)
[17:01:23.957]                 common <- intersect(names, old_names)
[17:01:23.957]                 added <- setdiff(names, old_names)
[17:01:23.957]                 removed <- setdiff(old_names, names)
[17:01:23.957]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:23.957]                   envs[common]]
[17:01:23.957]                 NAMES <- toupper(changed)
[17:01:23.957]                 args <- list()
[17:01:23.957]                 for (kk in seq_along(NAMES)) {
[17:01:23.957]                   name <- changed[[kk]]
[17:01:23.957]                   NAME <- NAMES[[kk]]
[17:01:23.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:23.957]                     next
[17:01:23.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:23.957]                 }
[17:01:23.957]                 NAMES <- toupper(added)
[17:01:23.957]                 for (kk in seq_along(NAMES)) {
[17:01:23.957]                   name <- added[[kk]]
[17:01:23.957]                   NAME <- NAMES[[kk]]
[17:01:23.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:23.957]                     next
[17:01:23.957]                   args[[name]] <- ""
[17:01:23.957]                 }
[17:01:23.957]                 NAMES <- toupper(removed)
[17:01:23.957]                 for (kk in seq_along(NAMES)) {
[17:01:23.957]                   name <- removed[[kk]]
[17:01:23.957]                   NAME <- NAMES[[kk]]
[17:01:23.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:23.957]                     next
[17:01:23.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:23.957]                 }
[17:01:23.957]                 if (length(args) > 0) 
[17:01:23.957]                   base::do.call(base::Sys.setenv, args = args)
[17:01:23.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:23.957]             }
[17:01:23.957]             else {
[17:01:23.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:23.957]             }
[17:01:23.957]             {
[17:01:23.957]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:23.957]                   0L) {
[17:01:23.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:23.957]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:23.957]                   base::options(opts)
[17:01:23.957]                 }
[17:01:23.957]                 {
[17:01:23.957]                   {
[17:01:23.957]                     NULL
[17:01:23.957]                     RNGkind("Mersenne-Twister")
[17:01:23.957]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:23.957]                       inherits = FALSE)
[17:01:23.957]                   }
[17:01:23.957]                   options(future.plan = NULL)
[17:01:23.957]                   if (is.na(NA_character_)) 
[17:01:23.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:23.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:23.957]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:23.957]                     .init = FALSE)
[17:01:23.957]                 }
[17:01:23.957]             }
[17:01:23.957]         }
[17:01:23.957]     })
[17:01:23.957]     if (TRUE) {
[17:01:23.957]         base::sink(type = "output", split = FALSE)
[17:01:23.957]         if (FALSE) {
[17:01:23.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:23.957]         }
[17:01:23.957]         else {
[17:01:23.957]             ...future.result["stdout"] <- base::list(NULL)
[17:01:23.957]         }
[17:01:23.957]         base::close(...future.stdout)
[17:01:23.957]         ...future.stdout <- NULL
[17:01:23.957]     }
[17:01:23.957]     ...future.result$conditions <- ...future.conditions
[17:01:23.957]     ...future.result$finished <- base::Sys.time()
[17:01:23.957]     ...future.result
[17:01:23.957] }
[17:01:23.958] assign_globals() ...
[17:01:23.958] List of 5
[17:01:23.958]  $ ...future.FUN            :function (x, y)  
[17:01:23.958]  $ MoreArgs                 : NULL
[17:01:23.958]  $ ...future.elements_ii    :List of 2
[17:01:23.958]   ..$ :List of 2
[17:01:23.958]   .. ..$ : int 1
[17:01:23.958]   .. ..$ : int 0
[17:01:23.958]   ..$ :List of 2
[17:01:23.958]   .. ..$ : int 0
[17:01:23.958]   .. ..$ : int 1
[17:01:23.958]  $ ...future.seeds_ii       : NULL
[17:01:23.958]  $ ...future.globals.maxSize: NULL
[17:01:23.958]  - attr(*, "where")=List of 5
[17:01:23.958]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:23.958]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:23.958]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:23.958]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:23.958]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:23.958]  - attr(*, "resolved")= logi FALSE
[17:01:23.958]  - attr(*, "total_size")= num 6480
[17:01:23.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:23.958]  - attr(*, "already-done")= logi TRUE
[17:01:23.964] - reassign environment for ‘...future.FUN’
[17:01:23.966] - copied ‘...future.FUN’ to environment
[17:01:23.966] - copied ‘MoreArgs’ to environment
[17:01:23.966] - copied ‘...future.elements_ii’ to environment
[17:01:23.966] - copied ‘...future.seeds_ii’ to environment
[17:01:23.966] - copied ‘...future.globals.maxSize’ to environment
[17:01:23.966] assign_globals() ... done
[17:01:23.967] plan(): Setting new future strategy stack:
[17:01:23.967] List of future strategies:
[17:01:23.967] 1. sequential:
[17:01:23.967]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:23.967]    - tweaked: FALSE
[17:01:23.967]    - call: NULL
[17:01:23.967] plan(): nbrOfWorkers() = 1
[17:01:24.469] plan(): Setting new future strategy stack:
[17:01:24.469] List of future strategies:
[17:01:24.469] 1. multisession:
[17:01:24.469]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:24.469]    - tweaked: FALSE
[17:01:24.469]    - call: plan(strategy)
[17:01:24.473] plan(): nbrOfWorkers() = 1
[17:01:24.474] SequentialFuture started (and completed)
[17:01:24.474] - Launch lazy future ... done
[17:01:24.474] run() for ‘SequentialFuture’ ... done
[17:01:24.474] Created future:
[17:01:24.474] SequentialFuture:
[17:01:24.474] Label: ‘future_mapply-1’
[17:01:24.474] Expression:
[17:01:24.474] {
[17:01:24.474]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:24.474]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:24.474]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:24.474]         on.exit(options(oopts), add = TRUE)
[17:01:24.474]     }
[17:01:24.474]     {
[17:01:24.474]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:24.474]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:24.474]         do.call(mapply, args = args)
[17:01:24.474]     }
[17:01:24.474] }
[17:01:24.474] Lazy evaluation: FALSE
[17:01:24.474] Asynchronous evaluation: FALSE
[17:01:24.474] Local evaluation: TRUE
[17:01:24.474] Environment: R_GlobalEnv
[17:01:24.474] Capture standard output: FALSE
[17:01:24.474] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:24.474] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:24.474] Packages: <none>
[17:01:24.474] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:24.474] Resolved: TRUE
[17:01:24.474] Value: 224 bytes of class ‘list’
[17:01:24.474] Early signaling: FALSE
[17:01:24.474] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:24.474] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:24.475] Chunk #1 of 1 ... DONE
[17:01:24.476] Launching 1 futures (chunks) ... DONE
[17:01:24.476] Resolving 1 futures (chunks) ...
[17:01:24.476] resolve() on list ...
[17:01:24.476]  recursive: 0
[17:01:24.476]  length: 1
[17:01:24.476] 
[17:01:24.476] resolved() for ‘SequentialFuture’ ...
[17:01:24.476] - state: ‘finished’
[17:01:24.476] - run: TRUE
[17:01:24.477] - result: ‘FutureResult’
[17:01:24.477] resolved() for ‘SequentialFuture’ ... done
[17:01:24.477] Future #1
[17:01:24.477] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:24.477] - nx: 1
[17:01:24.477] - relay: TRUE
[17:01:24.477] - stdout: TRUE
[17:01:24.477] - signal: TRUE
[17:01:24.477] - resignal: FALSE
[17:01:24.477] - force: TRUE
[17:01:24.478] - relayed: [n=1] FALSE
[17:01:24.478] - queued futures: [n=1] FALSE
[17:01:24.478]  - until=1
[17:01:24.478]  - relaying element #1
[17:01:24.478] - relayed: [n=1] TRUE
[17:01:24.478] - queued futures: [n=1] TRUE
[17:01:24.478] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:24.478]  length: 0 (resolved future 1)
[17:01:24.478] Relaying remaining futures
[17:01:24.478] signalConditionsASAP(NULL, pos=0) ...
[17:01:24.479] - nx: 1
[17:01:24.479] - relay: TRUE
[17:01:24.479] - stdout: TRUE
[17:01:24.479] - signal: TRUE
[17:01:24.479] - resignal: FALSE
[17:01:24.479] - force: TRUE
[17:01:24.479] - relayed: [n=1] TRUE
[17:01:24.479] - queued futures: [n=1] TRUE
 - flush all
[17:01:24.479] - relayed: [n=1] TRUE
[17:01:24.479] - queued futures: [n=1] TRUE
[17:01:24.479] signalConditionsASAP(NULL, pos=0) ... done
[17:01:24.480] resolve() on list ... DONE
[17:01:24.480]  - Number of value chunks collected: 1
[17:01:24.480] Resolving 1 futures (chunks) ... DONE
[17:01:24.480] Reducing values from 1 chunks ...
[17:01:24.480]  - Number of values collected after concatenation: 2
[17:01:24.480]  - Number of values expected: 2
[17:01:24.480] Reducing values from 1 chunks ... DONE
[17:01:24.480] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:01:24.481] future_mapply() ...
[17:01:24.484] Number of chunks: 1
[17:01:24.484] getGlobalsAndPackagesXApply() ...
[17:01:24.484]  - future.globals: TRUE
[17:01:24.484] getGlobalsAndPackages() ...
[17:01:24.484] Searching for globals...
[17:01:24.486] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:24.486] Searching for globals ... DONE
[17:01:24.486] Resolving globals: FALSE
[17:01:24.486] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:24.487] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:24.487] - globals: [1] ‘FUN’
[17:01:24.487] 
[17:01:24.487] getGlobalsAndPackages() ... DONE
[17:01:24.487]  - globals found/used: [n=1] ‘FUN’
[17:01:24.487]  - needed namespaces: [n=0] 
[17:01:24.487] Finding globals ... DONE
[17:01:24.488] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:24.488] List of 2
[17:01:24.488]  $ ...future.FUN:function (x, y)  
[17:01:24.488]  $ MoreArgs     : NULL
[17:01:24.488]  - attr(*, "where")=List of 2
[17:01:24.488]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:24.488]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:24.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:24.488]  - attr(*, "resolved")= logi FALSE
[17:01:24.488]  - attr(*, "total_size")= num NA
[17:01:24.490] Packages to be attached in all futures: [n=0] 
[17:01:24.490] getGlobalsAndPackagesXApply() ... DONE
[17:01:24.490] Number of futures (= number of chunks): 1
[17:01:24.491] Launching 1 futures (chunks) ...
[17:01:24.491] Chunk #1 of 1 ...
[17:01:24.491]  - Finding globals in '...' for chunk #1 ...
[17:01:24.491] getGlobalsAndPackages() ...
[17:01:24.491] Searching for globals...
[17:01:24.491] 
[17:01:24.491] Searching for globals ... DONE
[17:01:24.491] - globals: [0] <none>
[17:01:24.492] getGlobalsAndPackages() ... DONE
[17:01:24.492]    + additional globals found: [n=0] 
[17:01:24.492]    + additional namespaces needed: [n=0] 
[17:01:24.492]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:24.492]  - seeds: <none>
[17:01:24.492]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:24.492] getGlobalsAndPackages() ...
[17:01:24.492] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:24.492] Resolving globals: FALSE
[17:01:24.493] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:01:24.493] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:24.493] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:24.493] 
[17:01:24.494] getGlobalsAndPackages() ... DONE
[17:01:24.494] run() for ‘Future’ ...
[17:01:24.494] - state: ‘created’
[17:01:24.494] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:24.498] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:24.498] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:24.498]   - Field: ‘label’
[17:01:24.498]   - Field: ‘local’
[17:01:24.498]   - Field: ‘owner’
[17:01:24.498]   - Field: ‘envir’
[17:01:24.498]   - Field: ‘packages’
[17:01:24.498]   - Field: ‘gc’
[17:01:24.498]   - Field: ‘conditions’
[17:01:24.498]   - Field: ‘expr’
[17:01:24.499]   - Field: ‘uuid’
[17:01:24.499]   - Field: ‘seed’
[17:01:24.499]   - Field: ‘version’
[17:01:24.499]   - Field: ‘result’
[17:01:24.499]   - Field: ‘asynchronous’
[17:01:24.499]   - Field: ‘calls’
[17:01:24.499]   - Field: ‘globals’
[17:01:24.499]   - Field: ‘stdout’
[17:01:24.499]   - Field: ‘earlySignal’
[17:01:24.500]   - Field: ‘lazy’
[17:01:24.500]   - Field: ‘state’
[17:01:24.500] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:24.500] - Launch lazy future ...
[17:01:24.500] Packages needed by the future expression (n = 0): <none>
[17:01:24.500] Packages needed by future strategies (n = 0): <none>
[17:01:24.501] {
[17:01:24.501]     {
[17:01:24.501]         {
[17:01:24.501]             ...future.startTime <- base::Sys.time()
[17:01:24.501]             {
[17:01:24.501]                 {
[17:01:24.501]                   {
[17:01:24.501]                     base::local({
[17:01:24.501]                       has_future <- base::requireNamespace("future", 
[17:01:24.501]                         quietly = TRUE)
[17:01:24.501]                       if (has_future) {
[17:01:24.501]                         ns <- base::getNamespace("future")
[17:01:24.501]                         version <- ns[[".package"]][["version"]]
[17:01:24.501]                         if (is.null(version)) 
[17:01:24.501]                           version <- utils::packageVersion("future")
[17:01:24.501]                       }
[17:01:24.501]                       else {
[17:01:24.501]                         version <- NULL
[17:01:24.501]                       }
[17:01:24.501]                       if (!has_future || version < "1.8.0") {
[17:01:24.501]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:24.501]                           "", base::R.version$version.string), 
[17:01:24.501]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:24.501]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:24.501]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:24.501]                             "release", "version")], collapse = " "), 
[17:01:24.501]                           hostname = base::Sys.info()[["nodename"]])
[17:01:24.501]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:24.501]                           info)
[17:01:24.501]                         info <- base::paste(info, collapse = "; ")
[17:01:24.501]                         if (!has_future) {
[17:01:24.501]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:24.501]                             info)
[17:01:24.501]                         }
[17:01:24.501]                         else {
[17:01:24.501]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:24.501]                             info, version)
[17:01:24.501]                         }
[17:01:24.501]                         base::stop(msg)
[17:01:24.501]                       }
[17:01:24.501]                     })
[17:01:24.501]                   }
[17:01:24.501]                   ...future.strategy.old <- future::plan("list")
[17:01:24.501]                   options(future.plan = NULL)
[17:01:24.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:24.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:24.501]                 }
[17:01:24.501]                 ...future.workdir <- getwd()
[17:01:24.501]             }
[17:01:24.501]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:24.501]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:24.501]         }
[17:01:24.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:24.501]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:24.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:24.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:24.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:24.501]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:24.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:24.501]             base::names(...future.oldOptions))
[17:01:24.501]     }
[17:01:24.501]     if (FALSE) {
[17:01:24.501]     }
[17:01:24.501]     else {
[17:01:24.501]         if (TRUE) {
[17:01:24.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:24.501]                 open = "w")
[17:01:24.501]         }
[17:01:24.501]         else {
[17:01:24.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:24.501]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:24.501]         }
[17:01:24.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:24.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:24.501]             base::sink(type = "output", split = FALSE)
[17:01:24.501]             base::close(...future.stdout)
[17:01:24.501]         }, add = TRUE)
[17:01:24.501]     }
[17:01:24.501]     ...future.frame <- base::sys.nframe()
[17:01:24.501]     ...future.conditions <- base::list()
[17:01:24.501]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:24.501]     if (FALSE) {
[17:01:24.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:24.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:24.501]     }
[17:01:24.501]     ...future.result <- base::tryCatch({
[17:01:24.501]         base::withCallingHandlers({
[17:01:24.501]             ...future.value <- base::withVisible(base::local({
[17:01:24.501]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:24.501]                 if (!identical(...future.globals.maxSize.org, 
[17:01:24.501]                   ...future.globals.maxSize)) {
[17:01:24.501]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:24.501]                   on.exit(options(oopts), add = TRUE)
[17:01:24.501]                 }
[17:01:24.501]                 {
[17:01:24.501]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:24.501]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:24.501]                     USE.NAMES = FALSE)
[17:01:24.501]                   do.call(mapply, args = args)
[17:01:24.501]                 }
[17:01:24.501]             }))
[17:01:24.501]             future::FutureResult(value = ...future.value$value, 
[17:01:24.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:24.501]                   ...future.rng), globalenv = if (FALSE) 
[17:01:24.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:24.501]                     ...future.globalenv.names))
[17:01:24.501]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:24.501]         }, condition = base::local({
[17:01:24.501]             c <- base::c
[17:01:24.501]             inherits <- base::inherits
[17:01:24.501]             invokeRestart <- base::invokeRestart
[17:01:24.501]             length <- base::length
[17:01:24.501]             list <- base::list
[17:01:24.501]             seq.int <- base::seq.int
[17:01:24.501]             signalCondition <- base::signalCondition
[17:01:24.501]             sys.calls <- base::sys.calls
[17:01:24.501]             `[[` <- base::`[[`
[17:01:24.501]             `+` <- base::`+`
[17:01:24.501]             `<<-` <- base::`<<-`
[17:01:24.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:24.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:24.501]                   3L)]
[17:01:24.501]             }
[17:01:24.501]             function(cond) {
[17:01:24.501]                 is_error <- inherits(cond, "error")
[17:01:24.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:24.501]                   NULL)
[17:01:24.501]                 if (is_error) {
[17:01:24.501]                   sessionInformation <- function() {
[17:01:24.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:24.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:24.501]                       search = base::search(), system = base::Sys.info())
[17:01:24.501]                   }
[17:01:24.501]                   ...future.conditions[[length(...future.conditions) + 
[17:01:24.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:24.501]                     cond$call), session = sessionInformation(), 
[17:01:24.501]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:24.501]                   signalCondition(cond)
[17:01:24.501]                 }
[17:01:24.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:24.501]                 "immediateCondition"))) {
[17:01:24.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:24.501]                   ...future.conditions[[length(...future.conditions) + 
[17:01:24.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:24.501]                   if (TRUE && !signal) {
[17:01:24.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:24.501]                     {
[17:01:24.501]                       inherits <- base::inherits
[17:01:24.501]                       invokeRestart <- base::invokeRestart
[17:01:24.501]                       is.null <- base::is.null
[17:01:24.501]                       muffled <- FALSE
[17:01:24.501]                       if (inherits(cond, "message")) {
[17:01:24.501]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:24.501]                         if (muffled) 
[17:01:24.501]                           invokeRestart("muffleMessage")
[17:01:24.501]                       }
[17:01:24.501]                       else if (inherits(cond, "warning")) {
[17:01:24.501]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:24.501]                         if (muffled) 
[17:01:24.501]                           invokeRestart("muffleWarning")
[17:01:24.501]                       }
[17:01:24.501]                       else if (inherits(cond, "condition")) {
[17:01:24.501]                         if (!is.null(pattern)) {
[17:01:24.501]                           computeRestarts <- base::computeRestarts
[17:01:24.501]                           grepl <- base::grepl
[17:01:24.501]                           restarts <- computeRestarts(cond)
[17:01:24.501]                           for (restart in restarts) {
[17:01:24.501]                             name <- restart$name
[17:01:24.501]                             if (is.null(name)) 
[17:01:24.501]                               next
[17:01:24.501]                             if (!grepl(pattern, name)) 
[17:01:24.501]                               next
[17:01:24.501]                             invokeRestart(restart)
[17:01:24.501]                             muffled <- TRUE
[17:01:24.501]                             break
[17:01:24.501]                           }
[17:01:24.501]                         }
[17:01:24.501]                       }
[17:01:24.501]                       invisible(muffled)
[17:01:24.501]                     }
[17:01:24.501]                     muffleCondition(cond, pattern = "^muffle")
[17:01:24.501]                   }
[17:01:24.501]                 }
[17:01:24.501]                 else {
[17:01:24.501]                   if (TRUE) {
[17:01:24.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:24.501]                     {
[17:01:24.501]                       inherits <- base::inherits
[17:01:24.501]                       invokeRestart <- base::invokeRestart
[17:01:24.501]                       is.null <- base::is.null
[17:01:24.501]                       muffled <- FALSE
[17:01:24.501]                       if (inherits(cond, "message")) {
[17:01:24.501]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:24.501]                         if (muffled) 
[17:01:24.501]                           invokeRestart("muffleMessage")
[17:01:24.501]                       }
[17:01:24.501]                       else if (inherits(cond, "warning")) {
[17:01:24.501]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:24.501]                         if (muffled) 
[17:01:24.501]                           invokeRestart("muffleWarning")
[17:01:24.501]                       }
[17:01:24.501]                       else if (inherits(cond, "condition")) {
[17:01:24.501]                         if (!is.null(pattern)) {
[17:01:24.501]                           computeRestarts <- base::computeRestarts
[17:01:24.501]                           grepl <- base::grepl
[17:01:24.501]                           restarts <- computeRestarts(cond)
[17:01:24.501]                           for (restart in restarts) {
[17:01:24.501]                             name <- restart$name
[17:01:24.501]                             if (is.null(name)) 
[17:01:24.501]                               next
[17:01:24.501]                             if (!grepl(pattern, name)) 
[17:01:24.501]                               next
[17:01:24.501]                             invokeRestart(restart)
[17:01:24.501]                             muffled <- TRUE
[17:01:24.501]                             break
[17:01:24.501]                           }
[17:01:24.501]                         }
[17:01:24.501]                       }
[17:01:24.501]                       invisible(muffled)
[17:01:24.501]                     }
[17:01:24.501]                     muffleCondition(cond, pattern = "^muffle")
[17:01:24.501]                   }
[17:01:24.501]                 }
[17:01:24.501]             }
[17:01:24.501]         }))
[17:01:24.501]     }, error = function(ex) {
[17:01:24.501]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:24.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:24.501]                 ...future.rng), started = ...future.startTime, 
[17:01:24.501]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:24.501]             version = "1.8"), class = "FutureResult")
[17:01:24.501]     }, finally = {
[17:01:24.501]         if (!identical(...future.workdir, getwd())) 
[17:01:24.501]             setwd(...future.workdir)
[17:01:24.501]         {
[17:01:24.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:24.501]                 ...future.oldOptions$nwarnings <- NULL
[17:01:24.501]             }
[17:01:24.501]             base::options(...future.oldOptions)
[17:01:24.501]             if (.Platform$OS.type == "windows") {
[17:01:24.501]                 old_names <- names(...future.oldEnvVars)
[17:01:24.501]                 envs <- base::Sys.getenv()
[17:01:24.501]                 names <- names(envs)
[17:01:24.501]                 common <- intersect(names, old_names)
[17:01:24.501]                 added <- setdiff(names, old_names)
[17:01:24.501]                 removed <- setdiff(old_names, names)
[17:01:24.501]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:24.501]                   envs[common]]
[17:01:24.501]                 NAMES <- toupper(changed)
[17:01:24.501]                 args <- list()
[17:01:24.501]                 for (kk in seq_along(NAMES)) {
[17:01:24.501]                   name <- changed[[kk]]
[17:01:24.501]                   NAME <- NAMES[[kk]]
[17:01:24.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:24.501]                     next
[17:01:24.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:24.501]                 }
[17:01:24.501]                 NAMES <- toupper(added)
[17:01:24.501]                 for (kk in seq_along(NAMES)) {
[17:01:24.501]                   name <- added[[kk]]
[17:01:24.501]                   NAME <- NAMES[[kk]]
[17:01:24.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:24.501]                     next
[17:01:24.501]                   args[[name]] <- ""
[17:01:24.501]                 }
[17:01:24.501]                 NAMES <- toupper(removed)
[17:01:24.501]                 for (kk in seq_along(NAMES)) {
[17:01:24.501]                   name <- removed[[kk]]
[17:01:24.501]                   NAME <- NAMES[[kk]]
[17:01:24.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:24.501]                     next
[17:01:24.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:24.501]                 }
[17:01:24.501]                 if (length(args) > 0) 
[17:01:24.501]                   base::do.call(base::Sys.setenv, args = args)
[17:01:24.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:24.501]             }
[17:01:24.501]             else {
[17:01:24.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:24.501]             }
[17:01:24.501]             {
[17:01:24.501]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:24.501]                   0L) {
[17:01:24.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:24.501]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:24.501]                   base::options(opts)
[17:01:24.501]                 }
[17:01:24.501]                 {
[17:01:24.501]                   {
[17:01:24.501]                     NULL
[17:01:24.501]                     RNGkind("Mersenne-Twister")
[17:01:24.501]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:24.501]                       inherits = FALSE)
[17:01:24.501]                   }
[17:01:24.501]                   options(future.plan = NULL)
[17:01:24.501]                   if (is.na(NA_character_)) 
[17:01:24.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:24.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:24.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:24.501]                     .init = FALSE)
[17:01:24.501]                 }
[17:01:24.501]             }
[17:01:24.501]         }
[17:01:24.501]     })
[17:01:24.501]     if (TRUE) {
[17:01:24.501]         base::sink(type = "output", split = FALSE)
[17:01:24.501]         if (TRUE) {
[17:01:24.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:24.501]         }
[17:01:24.501]         else {
[17:01:24.501]             ...future.result["stdout"] <- base::list(NULL)
[17:01:24.501]         }
[17:01:24.501]         base::close(...future.stdout)
[17:01:24.501]         ...future.stdout <- NULL
[17:01:24.501]     }
[17:01:24.501]     ...future.result$conditions <- ...future.conditions
[17:01:24.501]     ...future.result$finished <- base::Sys.time()
[17:01:24.501]     ...future.result
[17:01:24.501] }
[17:01:24.504] assign_globals() ...
[17:01:24.504] List of 5
[17:01:24.504]  $ ...future.FUN            :function (x, y)  
[17:01:24.504]  $ MoreArgs                 : NULL
[17:01:24.504]  $ ...future.elements_ii    :List of 2
[17:01:24.504]   ..$ :List of 2
[17:01:24.504]   .. ..$ : int 1
[17:01:24.504]   .. ..$ : int 0
[17:01:24.504]   ..$ :List of 2
[17:01:24.504]   .. ..$ : int 0
[17:01:24.504]   .. ..$ : int 1
[17:01:24.504]  $ ...future.seeds_ii       : NULL
[17:01:24.504]  $ ...future.globals.maxSize: NULL
[17:01:24.504]  - attr(*, "where")=List of 5
[17:01:24.504]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:24.504]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:24.504]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:24.504]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:24.504]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:24.504]  - attr(*, "resolved")= logi FALSE
[17:01:24.504]  - attr(*, "total_size")= num 6480
[17:01:24.504]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:24.504]  - attr(*, "already-done")= logi TRUE
[17:01:24.510] - reassign environment for ‘...future.FUN’
[17:01:24.510] - copied ‘...future.FUN’ to environment
[17:01:24.510] - copied ‘MoreArgs’ to environment
[17:01:24.511] - copied ‘...future.elements_ii’ to environment
[17:01:24.511] - copied ‘...future.seeds_ii’ to environment
[17:01:24.511] - copied ‘...future.globals.maxSize’ to environment
[17:01:24.511] assign_globals() ... done
[17:01:24.511] plan(): Setting new future strategy stack:
[17:01:24.511] List of future strategies:
[17:01:24.511] 1. sequential:
[17:01:24.511]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:24.511]    - tweaked: FALSE
[17:01:24.511]    - call: NULL
[17:01:24.512] plan(): nbrOfWorkers() = 1
[17:01:25.013] plan(): Setting new future strategy stack:
[17:01:25.014] List of future strategies:
[17:01:25.014] 1. multisession:
[17:01:25.014]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:25.014]    - tweaked: FALSE
[17:01:25.014]    - call: plan(strategy)
[17:01:25.018] plan(): nbrOfWorkers() = 1
[17:01:25.018] SequentialFuture started (and completed)
[17:01:25.018] - Launch lazy future ... done
[17:01:25.018] run() for ‘SequentialFuture’ ... done
[17:01:25.018] Created future:
[17:01:25.018] SequentialFuture:
[17:01:25.018] Label: ‘future_mapply-1’
[17:01:25.018] Expression:
[17:01:25.018] {
[17:01:25.018]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:25.018]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:25.018]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:25.018]         on.exit(options(oopts), add = TRUE)
[17:01:25.018]     }
[17:01:25.018]     {
[17:01:25.018]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:25.018]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:25.018]         do.call(mapply, args = args)
[17:01:25.018]     }
[17:01:25.018] }
[17:01:25.018] Lazy evaluation: FALSE
[17:01:25.018] Asynchronous evaluation: FALSE
[17:01:25.018] Local evaluation: TRUE
[17:01:25.018] Environment: R_GlobalEnv
[17:01:25.018] Capture standard output: TRUE
[17:01:25.018] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:25.018] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:25.018] Packages: <none>
[17:01:25.018] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:25.018] Resolved: TRUE
[17:01:25.018] Value: 224 bytes of class ‘list’
[17:01:25.018] Early signaling: FALSE
[17:01:25.018] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:25.018] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:25.019] Chunk #1 of 1 ... DONE
[17:01:25.019] Launching 1 futures (chunks) ... DONE
[17:01:25.020] Resolving 1 futures (chunks) ...
[17:01:25.020] resolve() on list ...
[17:01:25.020]  recursive: 0
[17:01:25.020]  length: 1
[17:01:25.020] 
[17:01:25.020] resolved() for ‘SequentialFuture’ ...
[17:01:25.020] - state: ‘finished’
[17:01:25.020] - run: TRUE
[17:01:25.020] - result: ‘FutureResult’
[17:01:25.020] resolved() for ‘SequentialFuture’ ... done
[17:01:25.020] Future #1
[17:01:25.021] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:25.021] - nx: 1
[17:01:25.021] - relay: TRUE
[17:01:25.021] - stdout: TRUE
[17:01:25.021] - signal: TRUE
[17:01:25.021] - resignal: FALSE
[17:01:25.021] - force: TRUE
[17:01:25.021] - relayed: [n=1] FALSE
[17:01:25.021] - queued futures: [n=1] FALSE
[17:01:25.021]  - until=1
[17:01:25.021]  - relaying element #1
[17:01:25.022] - relayed: [n=1] TRUE
[17:01:25.022] - queued futures: [n=1] TRUE
[17:01:25.022] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:25.022]  length: 0 (resolved future 1)
[17:01:25.022] Relaying remaining futures
[17:01:25.022] signalConditionsASAP(NULL, pos=0) ...
[17:01:25.022] - nx: 1
[17:01:25.022] - relay: TRUE
[17:01:25.022] - stdout: TRUE
[17:01:25.022] - signal: TRUE
[17:01:25.023] - resignal: FALSE
[17:01:25.023] - force: TRUE
[17:01:25.023] - relayed: [n=1] TRUE
[17:01:25.023] - queued futures: [n=1] TRUE
 - flush all
[17:01:25.023] - relayed: [n=1] TRUE
[17:01:25.023] - queued futures: [n=1] TRUE
[17:01:25.023] signalConditionsASAP(NULL, pos=0) ... done
[17:01:25.023] resolve() on list ... DONE
[17:01:25.023]  - Number of value chunks collected: 1
[17:01:25.023] Resolving 1 futures (chunks) ... DONE
[17:01:25.024] Reducing values from 1 chunks ...
[17:01:25.024]  - Number of values collected after concatenation: 2
[17:01:25.024]  - Number of values expected: 2
[17:01:25.024] Reducing values from 1 chunks ... DONE
[17:01:25.024] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:01:25.024] future_mapply() ...
[17:01:25.028] Number of chunks: 1
[17:01:25.028] getGlobalsAndPackagesXApply() ...
[17:01:25.028]  - future.globals: TRUE
[17:01:25.028] getGlobalsAndPackages() ...
[17:01:25.028] Searching for globals...
[17:01:25.030] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:25.030] Searching for globals ... DONE
[17:01:25.030] Resolving globals: FALSE
[17:01:25.030] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:25.031] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:25.031] - globals: [1] ‘FUN’
[17:01:25.031] 
[17:01:25.031] getGlobalsAndPackages() ... DONE
[17:01:25.031]  - globals found/used: [n=1] ‘FUN’
[17:01:25.031]  - needed namespaces: [n=0] 
[17:01:25.031] Finding globals ... DONE
[17:01:25.031] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:25.032] List of 2
[17:01:25.032]  $ ...future.FUN:function (x, y)  
[17:01:25.032]  $ MoreArgs     : NULL
[17:01:25.032]  - attr(*, "where")=List of 2
[17:01:25.032]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:25.032]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:25.032]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:25.032]  - attr(*, "resolved")= logi FALSE
[17:01:25.032]  - attr(*, "total_size")= num NA
[17:01:25.034] Packages to be attached in all futures: [n=0] 
[17:01:25.034] getGlobalsAndPackagesXApply() ... DONE
[17:01:25.034] Number of futures (= number of chunks): 1
[17:01:25.034] Launching 1 futures (chunks) ...
[17:01:25.035] Chunk #1 of 1 ...
[17:01:25.035]  - Finding globals in '...' for chunk #1 ...
[17:01:25.035] getGlobalsAndPackages() ...
[17:01:25.035] Searching for globals...
[17:01:25.035] 
[17:01:25.035] Searching for globals ... DONE
[17:01:25.035] - globals: [0] <none>
[17:01:25.037] getGlobalsAndPackages() ... DONE
[17:01:25.037]    + additional globals found: [n=0] 
[17:01:25.037]    + additional namespaces needed: [n=0] 
[17:01:25.037]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:25.038]  - seeds: <none>
[17:01:25.038]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:25.038] getGlobalsAndPackages() ...
[17:01:25.038] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:25.038] Resolving globals: FALSE
[17:01:25.039] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:01:25.039] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:25.039] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:25.039] 
[17:01:25.039] getGlobalsAndPackages() ... DONE
[17:01:25.040] run() for ‘Future’ ...
[17:01:25.040] - state: ‘created’
[17:01:25.040] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:25.044] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:25.044] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:25.044]   - Field: ‘label’
[17:01:25.044]   - Field: ‘local’
[17:01:25.044]   - Field: ‘owner’
[17:01:25.044]   - Field: ‘envir’
[17:01:25.045]   - Field: ‘packages’
[17:01:25.045]   - Field: ‘gc’
[17:01:25.045]   - Field: ‘conditions’
[17:01:25.045]   - Field: ‘expr’
[17:01:25.045]   - Field: ‘uuid’
[17:01:25.045]   - Field: ‘seed’
[17:01:25.045]   - Field: ‘version’
[17:01:25.045]   - Field: ‘result’
[17:01:25.046]   - Field: ‘asynchronous’
[17:01:25.046]   - Field: ‘calls’
[17:01:25.046]   - Field: ‘globals’
[17:01:25.046]   - Field: ‘stdout’
[17:01:25.046]   - Field: ‘earlySignal’
[17:01:25.046]   - Field: ‘lazy’
[17:01:25.046]   - Field: ‘state’
[17:01:25.046] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:25.046] - Launch lazy future ...
[17:01:25.046] Packages needed by the future expression (n = 0): <none>
[17:01:25.047] Packages needed by future strategies (n = 0): <none>
[17:01:25.047] {
[17:01:25.047]     {
[17:01:25.047]         {
[17:01:25.047]             ...future.startTime <- base::Sys.time()
[17:01:25.047]             {
[17:01:25.047]                 {
[17:01:25.047]                   {
[17:01:25.047]                     base::local({
[17:01:25.047]                       has_future <- base::requireNamespace("future", 
[17:01:25.047]                         quietly = TRUE)
[17:01:25.047]                       if (has_future) {
[17:01:25.047]                         ns <- base::getNamespace("future")
[17:01:25.047]                         version <- ns[[".package"]][["version"]]
[17:01:25.047]                         if (is.null(version)) 
[17:01:25.047]                           version <- utils::packageVersion("future")
[17:01:25.047]                       }
[17:01:25.047]                       else {
[17:01:25.047]                         version <- NULL
[17:01:25.047]                       }
[17:01:25.047]                       if (!has_future || version < "1.8.0") {
[17:01:25.047]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:25.047]                           "", base::R.version$version.string), 
[17:01:25.047]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:25.047]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:25.047]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:25.047]                             "release", "version")], collapse = " "), 
[17:01:25.047]                           hostname = base::Sys.info()[["nodename"]])
[17:01:25.047]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:25.047]                           info)
[17:01:25.047]                         info <- base::paste(info, collapse = "; ")
[17:01:25.047]                         if (!has_future) {
[17:01:25.047]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:25.047]                             info)
[17:01:25.047]                         }
[17:01:25.047]                         else {
[17:01:25.047]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:25.047]                             info, version)
[17:01:25.047]                         }
[17:01:25.047]                         base::stop(msg)
[17:01:25.047]                       }
[17:01:25.047]                     })
[17:01:25.047]                   }
[17:01:25.047]                   ...future.strategy.old <- future::plan("list")
[17:01:25.047]                   options(future.plan = NULL)
[17:01:25.047]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:25.047]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:25.047]                 }
[17:01:25.047]                 ...future.workdir <- getwd()
[17:01:25.047]             }
[17:01:25.047]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:25.047]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:25.047]         }
[17:01:25.047]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:25.047]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:25.047]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:25.047]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:25.047]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:25.047]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:25.047]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:25.047]             base::names(...future.oldOptions))
[17:01:25.047]     }
[17:01:25.047]     if (TRUE) {
[17:01:25.047]     }
[17:01:25.047]     else {
[17:01:25.047]         if (NA) {
[17:01:25.047]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:25.047]                 open = "w")
[17:01:25.047]         }
[17:01:25.047]         else {
[17:01:25.047]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:25.047]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:25.047]         }
[17:01:25.047]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:25.047]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:25.047]             base::sink(type = "output", split = FALSE)
[17:01:25.047]             base::close(...future.stdout)
[17:01:25.047]         }, add = TRUE)
[17:01:25.047]     }
[17:01:25.047]     ...future.frame <- base::sys.nframe()
[17:01:25.047]     ...future.conditions <- base::list()
[17:01:25.047]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:25.047]     if (FALSE) {
[17:01:25.047]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:25.047]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:25.047]     }
[17:01:25.047]     ...future.result <- base::tryCatch({
[17:01:25.047]         base::withCallingHandlers({
[17:01:25.047]             ...future.value <- base::withVisible(base::local({
[17:01:25.047]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:25.047]                 if (!identical(...future.globals.maxSize.org, 
[17:01:25.047]                   ...future.globals.maxSize)) {
[17:01:25.047]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:25.047]                   on.exit(options(oopts), add = TRUE)
[17:01:25.047]                 }
[17:01:25.047]                 {
[17:01:25.047]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:25.047]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:25.047]                     USE.NAMES = FALSE)
[17:01:25.047]                   do.call(mapply, args = args)
[17:01:25.047]                 }
[17:01:25.047]             }))
[17:01:25.047]             future::FutureResult(value = ...future.value$value, 
[17:01:25.047]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:25.047]                   ...future.rng), globalenv = if (FALSE) 
[17:01:25.047]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:25.047]                     ...future.globalenv.names))
[17:01:25.047]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:25.047]         }, condition = base::local({
[17:01:25.047]             c <- base::c
[17:01:25.047]             inherits <- base::inherits
[17:01:25.047]             invokeRestart <- base::invokeRestart
[17:01:25.047]             length <- base::length
[17:01:25.047]             list <- base::list
[17:01:25.047]             seq.int <- base::seq.int
[17:01:25.047]             signalCondition <- base::signalCondition
[17:01:25.047]             sys.calls <- base::sys.calls
[17:01:25.047]             `[[` <- base::`[[`
[17:01:25.047]             `+` <- base::`+`
[17:01:25.047]             `<<-` <- base::`<<-`
[17:01:25.047]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:25.047]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:25.047]                   3L)]
[17:01:25.047]             }
[17:01:25.047]             function(cond) {
[17:01:25.047]                 is_error <- inherits(cond, "error")
[17:01:25.047]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:25.047]                   NULL)
[17:01:25.047]                 if (is_error) {
[17:01:25.047]                   sessionInformation <- function() {
[17:01:25.047]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:25.047]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:25.047]                       search = base::search(), system = base::Sys.info())
[17:01:25.047]                   }
[17:01:25.047]                   ...future.conditions[[length(...future.conditions) + 
[17:01:25.047]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:25.047]                     cond$call), session = sessionInformation(), 
[17:01:25.047]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:25.047]                   signalCondition(cond)
[17:01:25.047]                 }
[17:01:25.047]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:25.047]                 "immediateCondition"))) {
[17:01:25.047]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:25.047]                   ...future.conditions[[length(...future.conditions) + 
[17:01:25.047]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:25.047]                   if (TRUE && !signal) {
[17:01:25.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:25.047]                     {
[17:01:25.047]                       inherits <- base::inherits
[17:01:25.047]                       invokeRestart <- base::invokeRestart
[17:01:25.047]                       is.null <- base::is.null
[17:01:25.047]                       muffled <- FALSE
[17:01:25.047]                       if (inherits(cond, "message")) {
[17:01:25.047]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:25.047]                         if (muffled) 
[17:01:25.047]                           invokeRestart("muffleMessage")
[17:01:25.047]                       }
[17:01:25.047]                       else if (inherits(cond, "warning")) {
[17:01:25.047]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:25.047]                         if (muffled) 
[17:01:25.047]                           invokeRestart("muffleWarning")
[17:01:25.047]                       }
[17:01:25.047]                       else if (inherits(cond, "condition")) {
[17:01:25.047]                         if (!is.null(pattern)) {
[17:01:25.047]                           computeRestarts <- base::computeRestarts
[17:01:25.047]                           grepl <- base::grepl
[17:01:25.047]                           restarts <- computeRestarts(cond)
[17:01:25.047]                           for (restart in restarts) {
[17:01:25.047]                             name <- restart$name
[17:01:25.047]                             if (is.null(name)) 
[17:01:25.047]                               next
[17:01:25.047]                             if (!grepl(pattern, name)) 
[17:01:25.047]                               next
[17:01:25.047]                             invokeRestart(restart)
[17:01:25.047]                             muffled <- TRUE
[17:01:25.047]                             break
[17:01:25.047]                           }
[17:01:25.047]                         }
[17:01:25.047]                       }
[17:01:25.047]                       invisible(muffled)
[17:01:25.047]                     }
[17:01:25.047]                     muffleCondition(cond, pattern = "^muffle")
[17:01:25.047]                   }
[17:01:25.047]                 }
[17:01:25.047]                 else {
[17:01:25.047]                   if (TRUE) {
[17:01:25.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:25.047]                     {
[17:01:25.047]                       inherits <- base::inherits
[17:01:25.047]                       invokeRestart <- base::invokeRestart
[17:01:25.047]                       is.null <- base::is.null
[17:01:25.047]                       muffled <- FALSE
[17:01:25.047]                       if (inherits(cond, "message")) {
[17:01:25.047]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:25.047]                         if (muffled) 
[17:01:25.047]                           invokeRestart("muffleMessage")
[17:01:25.047]                       }
[17:01:25.047]                       else if (inherits(cond, "warning")) {
[17:01:25.047]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:25.047]                         if (muffled) 
[17:01:25.047]                           invokeRestart("muffleWarning")
[17:01:25.047]                       }
[17:01:25.047]                       else if (inherits(cond, "condition")) {
[17:01:25.047]                         if (!is.null(pattern)) {
[17:01:25.047]                           computeRestarts <- base::computeRestarts
[17:01:25.047]                           grepl <- base::grepl
[17:01:25.047]                           restarts <- computeRestarts(cond)
[17:01:25.047]                           for (restart in restarts) {
[17:01:25.047]                             name <- restart$name
[17:01:25.047]                             if (is.null(name)) 
[17:01:25.047]                               next
[17:01:25.047]                             if (!grepl(pattern, name)) 
[17:01:25.047]                               next
[17:01:25.047]                             invokeRestart(restart)
[17:01:25.047]                             muffled <- TRUE
[17:01:25.047]                             break
[17:01:25.047]                           }
[17:01:25.047]                         }
[17:01:25.047]                       }
[17:01:25.047]                       invisible(muffled)
[17:01:25.047]                     }
[17:01:25.047]                     muffleCondition(cond, pattern = "^muffle")
[17:01:25.047]                   }
[17:01:25.047]                 }
[17:01:25.047]             }
[17:01:25.047]         }))
[17:01:25.047]     }, error = function(ex) {
[17:01:25.047]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:25.047]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:25.047]                 ...future.rng), started = ...future.startTime, 
[17:01:25.047]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:25.047]             version = "1.8"), class = "FutureResult")
[17:01:25.047]     }, finally = {
[17:01:25.047]         if (!identical(...future.workdir, getwd())) 
[17:01:25.047]             setwd(...future.workdir)
[17:01:25.047]         {
[17:01:25.047]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:25.047]                 ...future.oldOptions$nwarnings <- NULL
[17:01:25.047]             }
[17:01:25.047]             base::options(...future.oldOptions)
[17:01:25.047]             if (.Platform$OS.type == "windows") {
[17:01:25.047]                 old_names <- names(...future.oldEnvVars)
[17:01:25.047]                 envs <- base::Sys.getenv()
[17:01:25.047]                 names <- names(envs)
[17:01:25.047]                 common <- intersect(names, old_names)
[17:01:25.047]                 added <- setdiff(names, old_names)
[17:01:25.047]                 removed <- setdiff(old_names, names)
[17:01:25.047]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:25.047]                   envs[common]]
[17:01:25.047]                 NAMES <- toupper(changed)
[17:01:25.047]                 args <- list()
[17:01:25.047]                 for (kk in seq_along(NAMES)) {
[17:01:25.047]                   name <- changed[[kk]]
[17:01:25.047]                   NAME <- NAMES[[kk]]
[17:01:25.047]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:25.047]                     next
[17:01:25.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:25.047]                 }
[17:01:25.047]                 NAMES <- toupper(added)
[17:01:25.047]                 for (kk in seq_along(NAMES)) {
[17:01:25.047]                   name <- added[[kk]]
[17:01:25.047]                   NAME <- NAMES[[kk]]
[17:01:25.047]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:25.047]                     next
[17:01:25.047]                   args[[name]] <- ""
[17:01:25.047]                 }
[17:01:25.047]                 NAMES <- toupper(removed)
[17:01:25.047]                 for (kk in seq_along(NAMES)) {
[17:01:25.047]                   name <- removed[[kk]]
[17:01:25.047]                   NAME <- NAMES[[kk]]
[17:01:25.047]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:25.047]                     next
[17:01:25.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:25.047]                 }
[17:01:25.047]                 if (length(args) > 0) 
[17:01:25.047]                   base::do.call(base::Sys.setenv, args = args)
[17:01:25.047]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:25.047]             }
[17:01:25.047]             else {
[17:01:25.047]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:25.047]             }
[17:01:25.047]             {
[17:01:25.047]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:25.047]                   0L) {
[17:01:25.047]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:25.047]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:25.047]                   base::options(opts)
[17:01:25.047]                 }
[17:01:25.047]                 {
[17:01:25.047]                   {
[17:01:25.047]                     NULL
[17:01:25.047]                     RNGkind("Mersenne-Twister")
[17:01:25.047]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:25.047]                       inherits = FALSE)
[17:01:25.047]                   }
[17:01:25.047]                   options(future.plan = NULL)
[17:01:25.047]                   if (is.na(NA_character_)) 
[17:01:25.047]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:25.047]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:25.047]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:25.047]                     .init = FALSE)
[17:01:25.047]                 }
[17:01:25.047]             }
[17:01:25.047]         }
[17:01:25.047]     })
[17:01:25.047]     if (FALSE) {
[17:01:25.047]         base::sink(type = "output", split = FALSE)
[17:01:25.047]         if (NA) {
[17:01:25.047]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:25.047]         }
[17:01:25.047]         else {
[17:01:25.047]             ...future.result["stdout"] <- base::list(NULL)
[17:01:25.047]         }
[17:01:25.047]         base::close(...future.stdout)
[17:01:25.047]         ...future.stdout <- NULL
[17:01:25.047]     }
[17:01:25.047]     ...future.result$conditions <- ...future.conditions
[17:01:25.047]     ...future.result$finished <- base::Sys.time()
[17:01:25.047]     ...future.result
[17:01:25.047] }
[17:01:25.049] assign_globals() ...
[17:01:25.049] List of 5
[17:01:25.049]  $ ...future.FUN            :function (x, y)  
[17:01:25.049]  $ MoreArgs                 : NULL
[17:01:25.049]  $ ...future.elements_ii    :List of 2
[17:01:25.049]   ..$ :List of 2
[17:01:25.049]   .. ..$ : int 1
[17:01:25.049]   .. ..$ : int 0
[17:01:25.049]   ..$ :List of 2
[17:01:25.049]   .. ..$ : int 0
[17:01:25.049]   .. ..$ : int 1
[17:01:25.049]  $ ...future.seeds_ii       : NULL
[17:01:25.049]  $ ...future.globals.maxSize: NULL
[17:01:25.049]  - attr(*, "where")=List of 5
[17:01:25.049]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:25.049]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:25.049]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:25.049]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:25.049]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:25.049]  - attr(*, "resolved")= logi FALSE
[17:01:25.049]  - attr(*, "total_size")= num 6480
[17:01:25.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:25.049]  - attr(*, "already-done")= logi TRUE
[17:01:25.055] - reassign environment for ‘...future.FUN’
[17:01:25.055] - copied ‘...future.FUN’ to environment
[17:01:25.055] - copied ‘MoreArgs’ to environment
[17:01:25.055] - copied ‘...future.elements_ii’ to environment
[17:01:25.055] - copied ‘...future.seeds_ii’ to environment
[17:01:25.055] - copied ‘...future.globals.maxSize’ to environment
[17:01:25.055] assign_globals() ... done
[17:01:25.055] plan(): Setting new future strategy stack:
[17:01:25.055] List of future strategies:
[17:01:25.055] 1. sequential:
[17:01:25.055]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:25.055]    - tweaked: FALSE
[17:01:25.055]    - call: NULL
[17:01:25.056] plan(): nbrOfWorkers() = 1
[17:01:25.558] plan(): Setting new future strategy stack:
[17:01:25.558] List of future strategies:
[17:01:25.558] 1. multisession:
[17:01:25.558]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:25.558]    - tweaked: FALSE
[17:01:25.558]    - call: plan(strategy)
[17:01:25.562] plan(): nbrOfWorkers() = 1
[17:01:25.562] SequentialFuture started (and completed)
[17:01:25.562] - Launch lazy future ... done
[17:01:25.562] run() for ‘SequentialFuture’ ... done
[17:01:25.562] Created future:
[17:01:25.562] SequentialFuture:
[17:01:25.562] Label: ‘future_mapply-1’
[17:01:25.562] Expression:
[17:01:25.562] {
[17:01:25.562]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:25.562]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:25.562]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:25.562]         on.exit(options(oopts), add = TRUE)
[17:01:25.562]     }
[17:01:25.562]     {
[17:01:25.562]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:25.562]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:25.562]         do.call(mapply, args = args)
[17:01:25.562]     }
[17:01:25.562] }
[17:01:25.562] Lazy evaluation: FALSE
[17:01:25.562] Asynchronous evaluation: FALSE
[17:01:25.562] Local evaluation: TRUE
[17:01:25.562] Environment: R_GlobalEnv
[17:01:25.562] Capture standard output: NA
[17:01:25.562] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:25.562] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:25.562] Packages: <none>
[17:01:25.562] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:25.562] Resolved: TRUE
[17:01:25.562] Value: 224 bytes of class ‘list’
[17:01:25.562] Early signaling: FALSE
[17:01:25.562] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:25.562] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:25.563] Chunk #1 of 1 ... DONE
[17:01:25.563] Launching 1 futures (chunks) ... DONE
[17:01:25.564] Resolving 1 futures (chunks) ...
[17:01:25.564] resolve() on list ...
[17:01:25.564]  recursive: 0
[17:01:25.564]  length: 1
[17:01:25.564] 
[17:01:25.564] resolved() for ‘SequentialFuture’ ...
[17:01:25.564] - state: ‘finished’
[17:01:25.564] - run: TRUE
[17:01:25.564] - result: ‘FutureResult’
[17:01:25.564] resolved() for ‘SequentialFuture’ ... done
[17:01:25.565] Future #1
[17:01:25.565] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:25.565] - nx: 1
[17:01:25.565] - relay: TRUE
[17:01:25.565] - stdout: TRUE
[17:01:25.565] - signal: TRUE
[17:01:25.565] - resignal: FALSE
[17:01:25.565] - force: TRUE
[17:01:25.565] - relayed: [n=1] FALSE
[17:01:25.565] - queued futures: [n=1] FALSE
[17:01:25.565]  - until=1
[17:01:25.566]  - relaying element #1
[17:01:25.566] - relayed: [n=1] TRUE
[17:01:25.566] - queued futures: [n=1] TRUE
[17:01:25.566] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:25.566]  length: 0 (resolved future 1)
[17:01:25.566] Relaying remaining futures
[17:01:25.566] signalConditionsASAP(NULL, pos=0) ...
[17:01:25.566] - nx: 1
[17:01:25.566] - relay: TRUE
[17:01:25.566] - stdout: TRUE
[17:01:25.567] - signal: TRUE
[17:01:25.567] - resignal: FALSE
[17:01:25.567] - force: TRUE
[17:01:25.567] - relayed: [n=1] TRUE
[17:01:25.567] - queued futures: [n=1] TRUE
 - flush all
[17:01:25.567] - relayed: [n=1] TRUE
[17:01:25.567] - queued futures: [n=1] TRUE
[17:01:25.567] signalConditionsASAP(NULL, pos=0) ... done
[17:01:25.567] resolve() on list ... DONE
[17:01:25.567]  - Number of value chunks collected: 1
[17:01:25.568] Resolving 1 futures (chunks) ... DONE
[17:01:25.568] Reducing values from 1 chunks ...
[17:01:25.568]  - Number of values collected after concatenation: 2
[17:01:25.568]  - Number of values expected: 2
[17:01:25.568] Reducing values from 1 chunks ... DONE
[17:01:25.568] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[17:01:25.574] plan(): Setting new future strategy stack:
[17:01:25.574] List of future strategies:
[17:01:25.574] 1. multicore:
[17:01:25.574]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:25.574]    - tweaked: FALSE
[17:01:25.574]    - call: plan(strategy)
[17:01:25.577] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:01:25.578] future_lapply() ...
[17:01:25.583] Number of chunks: 2
[17:01:25.583] getGlobalsAndPackagesXApply() ...
[17:01:25.583]  - future.globals: TRUE
[17:01:25.583] getGlobalsAndPackages() ...
[17:01:25.583] Searching for globals...
[17:01:25.585] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:25.585] Searching for globals ... DONE
[17:01:25.585] Resolving globals: FALSE
[17:01:25.585] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:25.586] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:25.586] - globals: [1] ‘FUN’
[17:01:25.586] 
[17:01:25.586] getGlobalsAndPackages() ... DONE
[17:01:25.586]  - globals found/used: [n=1] ‘FUN’
[17:01:25.586]  - needed namespaces: [n=0] 
[17:01:25.586] Finding globals ... DONE
[17:01:25.586]  - use_args: TRUE
[17:01:25.587]  - Getting '...' globals ...
[17:01:25.587] resolve() on list ...
[17:01:25.587]  recursive: 0
[17:01:25.587]  length: 1
[17:01:25.587]  elements: ‘...’
[17:01:25.587]  length: 0 (resolved future 1)
[17:01:25.587] resolve() on list ... DONE
[17:01:25.587]    - '...' content: [n=0] 
[17:01:25.588] List of 1
[17:01:25.588]  $ ...: list()
[17:01:25.588]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:25.588]  - attr(*, "where")=List of 1
[17:01:25.588]   ..$ ...:<environment: 0x5636f5af0748> 
[17:01:25.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:25.588]  - attr(*, "resolved")= logi TRUE
[17:01:25.588]  - attr(*, "total_size")= num NA
[17:01:25.590]  - Getting '...' globals ... DONE
[17:01:25.590] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:25.590] List of 2
[17:01:25.590]  $ ...future.FUN:function (x)  
[17:01:25.590]  $ ...          : list()
[17:01:25.590]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:25.590]  - attr(*, "where")=List of 2
[17:01:25.590]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:25.590]   ..$ ...          :<environment: 0x5636f5af0748> 
[17:01:25.590]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:25.590]  - attr(*, "resolved")= logi FALSE
[17:01:25.590]  - attr(*, "total_size")= num 4720
[17:01:25.593] Packages to be attached in all futures: [n=0] 
[17:01:25.593] getGlobalsAndPackagesXApply() ... DONE
[17:01:25.593] Number of futures (= number of chunks): 2
[17:01:25.593] Launching 2 futures (chunks) ...
[17:01:25.594] Chunk #1 of 2 ...
[17:01:25.594]  - Finding globals in 'X' for chunk #1 ...
[17:01:25.594] getGlobalsAndPackages() ...
[17:01:25.594] Searching for globals...
[17:01:25.594] 
[17:01:25.594] Searching for globals ... DONE
[17:01:25.594] - globals: [0] <none>
[17:01:25.594] getGlobalsAndPackages() ... DONE
[17:01:25.594]    + additional globals found: [n=0] 
[17:01:25.595]    + additional namespaces needed: [n=0] 
[17:01:25.595]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:25.595]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:25.595]  - seeds: <none>
[17:01:25.595]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:25.595] getGlobalsAndPackages() ...
[17:01:25.595] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:25.595] Resolving globals: FALSE
[17:01:25.595] Tweak future expression to call with '...' arguments ...
[17:01:25.595] {
[17:01:25.595]     do.call(function(...) {
[17:01:25.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:25.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:25.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:25.595]             on.exit(options(oopts), add = TRUE)
[17:01:25.595]         }
[17:01:25.595]         {
[17:01:25.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:25.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:25.595]                 ...future.FUN(...future.X_jj, ...)
[17:01:25.595]             })
[17:01:25.595]         }
[17:01:25.595]     }, args = future.call.arguments)
[17:01:25.595] }
[17:01:25.596] Tweak future expression to call with '...' arguments ... DONE
[17:01:25.596] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:25.596] 
[17:01:25.596] getGlobalsAndPackages() ... DONE
[17:01:25.597] run() for ‘Future’ ...
[17:01:25.597] - state: ‘created’
[17:01:25.597] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:25.601] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:25.601] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:25.601]   - Field: ‘label’
[17:01:25.601]   - Field: ‘local’
[17:01:25.601]   - Field: ‘owner’
[17:01:25.601]   - Field: ‘envir’
[17:01:25.601]   - Field: ‘workers’
[17:01:25.601]   - Field: ‘packages’
[17:01:25.601]   - Field: ‘gc’
[17:01:25.602]   - Field: ‘job’
[17:01:25.602]   - Field: ‘conditions’
[17:01:25.602]   - Field: ‘expr’
[17:01:25.602]   - Field: ‘uuid’
[17:01:25.602]   - Field: ‘seed’
[17:01:25.602]   - Field: ‘version’
[17:01:25.602]   - Field: ‘result’
[17:01:25.602]   - Field: ‘asynchronous’
[17:01:25.602]   - Field: ‘calls’
[17:01:25.602]   - Field: ‘globals’
[17:01:25.602]   - Field: ‘stdout’
[17:01:25.603]   - Field: ‘earlySignal’
[17:01:25.603]   - Field: ‘lazy’
[17:01:25.603]   - Field: ‘state’
[17:01:25.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:25.603] - Launch lazy future ...
[17:01:25.604] Packages needed by the future expression (n = 0): <none>
[17:01:25.604] Packages needed by future strategies (n = 0): <none>
[17:01:25.606] {
[17:01:25.606]     {
[17:01:25.606]         {
[17:01:25.606]             ...future.startTime <- base::Sys.time()
[17:01:25.606]             {
[17:01:25.606]                 {
[17:01:25.606]                   {
[17:01:25.606]                     {
[17:01:25.606]                       base::local({
[17:01:25.606]                         has_future <- base::requireNamespace("future", 
[17:01:25.606]                           quietly = TRUE)
[17:01:25.606]                         if (has_future) {
[17:01:25.606]                           ns <- base::getNamespace("future")
[17:01:25.606]                           version <- ns[[".package"]][["version"]]
[17:01:25.606]                           if (is.null(version)) 
[17:01:25.606]                             version <- utils::packageVersion("future")
[17:01:25.606]                         }
[17:01:25.606]                         else {
[17:01:25.606]                           version <- NULL
[17:01:25.606]                         }
[17:01:25.606]                         if (!has_future || version < "1.8.0") {
[17:01:25.606]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:25.606]                             "", base::R.version$version.string), 
[17:01:25.606]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:25.606]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:25.606]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:25.606]                               "release", "version")], collapse = " "), 
[17:01:25.606]                             hostname = base::Sys.info()[["nodename"]])
[17:01:25.606]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:25.606]                             info)
[17:01:25.606]                           info <- base::paste(info, collapse = "; ")
[17:01:25.606]                           if (!has_future) {
[17:01:25.606]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:25.606]                               info)
[17:01:25.606]                           }
[17:01:25.606]                           else {
[17:01:25.606]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:25.606]                               info, version)
[17:01:25.606]                           }
[17:01:25.606]                           base::stop(msg)
[17:01:25.606]                         }
[17:01:25.606]                       })
[17:01:25.606]                     }
[17:01:25.606]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:25.606]                     base::options(mc.cores = 1L)
[17:01:25.606]                   }
[17:01:25.606]                   ...future.strategy.old <- future::plan("list")
[17:01:25.606]                   options(future.plan = NULL)
[17:01:25.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:25.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:25.606]                 }
[17:01:25.606]                 ...future.workdir <- getwd()
[17:01:25.606]             }
[17:01:25.606]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:25.606]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:25.606]         }
[17:01:25.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:25.606]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:25.606]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:25.606]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:25.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:25.606]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:25.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:25.606]             base::names(...future.oldOptions))
[17:01:25.606]     }
[17:01:25.606]     if (FALSE) {
[17:01:25.606]     }
[17:01:25.606]     else {
[17:01:25.606]         if (FALSE) {
[17:01:25.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:25.606]                 open = "w")
[17:01:25.606]         }
[17:01:25.606]         else {
[17:01:25.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:25.606]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:25.606]         }
[17:01:25.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:25.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:25.606]             base::sink(type = "output", split = FALSE)
[17:01:25.606]             base::close(...future.stdout)
[17:01:25.606]         }, add = TRUE)
[17:01:25.606]     }
[17:01:25.606]     ...future.frame <- base::sys.nframe()
[17:01:25.606]     ...future.conditions <- base::list()
[17:01:25.606]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:25.606]     if (FALSE) {
[17:01:25.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:25.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:25.606]     }
[17:01:25.606]     ...future.result <- base::tryCatch({
[17:01:25.606]         base::withCallingHandlers({
[17:01:25.606]             ...future.value <- base::withVisible(base::local({
[17:01:25.606]                 withCallingHandlers({
[17:01:25.606]                   {
[17:01:25.606]                     do.call(function(...) {
[17:01:25.606]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:25.606]                       if (!identical(...future.globals.maxSize.org, 
[17:01:25.606]                         ...future.globals.maxSize)) {
[17:01:25.606]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:25.606]                         on.exit(options(oopts), add = TRUE)
[17:01:25.606]                       }
[17:01:25.606]                       {
[17:01:25.606]                         lapply(seq_along(...future.elements_ii), 
[17:01:25.606]                           FUN = function(jj) {
[17:01:25.606]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:25.606]                             ...future.FUN(...future.X_jj, ...)
[17:01:25.606]                           })
[17:01:25.606]                       }
[17:01:25.606]                     }, args = future.call.arguments)
[17:01:25.606]                   }
[17:01:25.606]                 }, immediateCondition = function(cond) {
[17:01:25.606]                   save_rds <- function (object, pathname, ...) 
[17:01:25.606]                   {
[17:01:25.606]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:25.606]                     if (file_test("-f", pathname_tmp)) {
[17:01:25.606]                       fi_tmp <- file.info(pathname_tmp)
[17:01:25.606]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:25.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:25.606]                         fi_tmp[["mtime"]])
[17:01:25.606]                     }
[17:01:25.606]                     tryCatch({
[17:01:25.606]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:25.606]                     }, error = function(ex) {
[17:01:25.606]                       msg <- conditionMessage(ex)
[17:01:25.606]                       fi_tmp <- file.info(pathname_tmp)
[17:01:25.606]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:25.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:25.606]                         fi_tmp[["mtime"]], msg)
[17:01:25.606]                       ex$message <- msg
[17:01:25.606]                       stop(ex)
[17:01:25.606]                     })
[17:01:25.606]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:25.606]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:25.606]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:25.606]                       fi_tmp <- file.info(pathname_tmp)
[17:01:25.606]                       fi <- file.info(pathname)
[17:01:25.606]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:25.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:25.606]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:25.606]                         fi[["size"]], fi[["mtime"]])
[17:01:25.606]                       stop(msg)
[17:01:25.606]                     }
[17:01:25.606]                     invisible(pathname)
[17:01:25.606]                   }
[17:01:25.606]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:25.606]                     rootPath = tempdir()) 
[17:01:25.606]                   {
[17:01:25.606]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:25.606]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:25.606]                       tmpdir = path, fileext = ".rds")
[17:01:25.606]                     save_rds(obj, file)
[17:01:25.606]                   }
[17:01:25.606]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:25.606]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:25.606]                   {
[17:01:25.606]                     inherits <- base::inherits
[17:01:25.606]                     invokeRestart <- base::invokeRestart
[17:01:25.606]                     is.null <- base::is.null
[17:01:25.606]                     muffled <- FALSE
[17:01:25.606]                     if (inherits(cond, "message")) {
[17:01:25.606]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:25.606]                       if (muffled) 
[17:01:25.606]                         invokeRestart("muffleMessage")
[17:01:25.606]                     }
[17:01:25.606]                     else if (inherits(cond, "warning")) {
[17:01:25.606]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:25.606]                       if (muffled) 
[17:01:25.606]                         invokeRestart("muffleWarning")
[17:01:25.606]                     }
[17:01:25.606]                     else if (inherits(cond, "condition")) {
[17:01:25.606]                       if (!is.null(pattern)) {
[17:01:25.606]                         computeRestarts <- base::computeRestarts
[17:01:25.606]                         grepl <- base::grepl
[17:01:25.606]                         restarts <- computeRestarts(cond)
[17:01:25.606]                         for (restart in restarts) {
[17:01:25.606]                           name <- restart$name
[17:01:25.606]                           if (is.null(name)) 
[17:01:25.606]                             next
[17:01:25.606]                           if (!grepl(pattern, name)) 
[17:01:25.606]                             next
[17:01:25.606]                           invokeRestart(restart)
[17:01:25.606]                           muffled <- TRUE
[17:01:25.606]                           break
[17:01:25.606]                         }
[17:01:25.606]                       }
[17:01:25.606]                     }
[17:01:25.606]                     invisible(muffled)
[17:01:25.606]                   }
[17:01:25.606]                   muffleCondition(cond)
[17:01:25.606]                 })
[17:01:25.606]             }))
[17:01:25.606]             future::FutureResult(value = ...future.value$value, 
[17:01:25.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:25.606]                   ...future.rng), globalenv = if (FALSE) 
[17:01:25.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:25.606]                     ...future.globalenv.names))
[17:01:25.606]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:25.606]         }, condition = base::local({
[17:01:25.606]             c <- base::c
[17:01:25.606]             inherits <- base::inherits
[17:01:25.606]             invokeRestart <- base::invokeRestart
[17:01:25.606]             length <- base::length
[17:01:25.606]             list <- base::list
[17:01:25.606]             seq.int <- base::seq.int
[17:01:25.606]             signalCondition <- base::signalCondition
[17:01:25.606]             sys.calls <- base::sys.calls
[17:01:25.606]             `[[` <- base::`[[`
[17:01:25.606]             `+` <- base::`+`
[17:01:25.606]             `<<-` <- base::`<<-`
[17:01:25.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:25.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:25.606]                   3L)]
[17:01:25.606]             }
[17:01:25.606]             function(cond) {
[17:01:25.606]                 is_error <- inherits(cond, "error")
[17:01:25.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:25.606]                   NULL)
[17:01:25.606]                 if (is_error) {
[17:01:25.606]                   sessionInformation <- function() {
[17:01:25.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:25.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:25.606]                       search = base::search(), system = base::Sys.info())
[17:01:25.606]                   }
[17:01:25.606]                   ...future.conditions[[length(...future.conditions) + 
[17:01:25.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:25.606]                     cond$call), session = sessionInformation(), 
[17:01:25.606]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:25.606]                   signalCondition(cond)
[17:01:25.606]                 }
[17:01:25.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:25.606]                 "immediateCondition"))) {
[17:01:25.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:25.606]                   ...future.conditions[[length(...future.conditions) + 
[17:01:25.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:25.606]                   if (TRUE && !signal) {
[17:01:25.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:25.606]                     {
[17:01:25.606]                       inherits <- base::inherits
[17:01:25.606]                       invokeRestart <- base::invokeRestart
[17:01:25.606]                       is.null <- base::is.null
[17:01:25.606]                       muffled <- FALSE
[17:01:25.606]                       if (inherits(cond, "message")) {
[17:01:25.606]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:25.606]                         if (muffled) 
[17:01:25.606]                           invokeRestart("muffleMessage")
[17:01:25.606]                       }
[17:01:25.606]                       else if (inherits(cond, "warning")) {
[17:01:25.606]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:25.606]                         if (muffled) 
[17:01:25.606]                           invokeRestart("muffleWarning")
[17:01:25.606]                       }
[17:01:25.606]                       else if (inherits(cond, "condition")) {
[17:01:25.606]                         if (!is.null(pattern)) {
[17:01:25.606]                           computeRestarts <- base::computeRestarts
[17:01:25.606]                           grepl <- base::grepl
[17:01:25.606]                           restarts <- computeRestarts(cond)
[17:01:25.606]                           for (restart in restarts) {
[17:01:25.606]                             name <- restart$name
[17:01:25.606]                             if (is.null(name)) 
[17:01:25.606]                               next
[17:01:25.606]                             if (!grepl(pattern, name)) 
[17:01:25.606]                               next
[17:01:25.606]                             invokeRestart(restart)
[17:01:25.606]                             muffled <- TRUE
[17:01:25.606]                             break
[17:01:25.606]                           }
[17:01:25.606]                         }
[17:01:25.606]                       }
[17:01:25.606]                       invisible(muffled)
[17:01:25.606]                     }
[17:01:25.606]                     muffleCondition(cond, pattern = "^muffle")
[17:01:25.606]                   }
[17:01:25.606]                 }
[17:01:25.606]                 else {
[17:01:25.606]                   if (TRUE) {
[17:01:25.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:25.606]                     {
[17:01:25.606]                       inherits <- base::inherits
[17:01:25.606]                       invokeRestart <- base::invokeRestart
[17:01:25.606]                       is.null <- base::is.null
[17:01:25.606]                       muffled <- FALSE
[17:01:25.606]                       if (inherits(cond, "message")) {
[17:01:25.606]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:25.606]                         if (muffled) 
[17:01:25.606]                           invokeRestart("muffleMessage")
[17:01:25.606]                       }
[17:01:25.606]                       else if (inherits(cond, "warning")) {
[17:01:25.606]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:25.606]                         if (muffled) 
[17:01:25.606]                           invokeRestart("muffleWarning")
[17:01:25.606]                       }
[17:01:25.606]                       else if (inherits(cond, "condition")) {
[17:01:25.606]                         if (!is.null(pattern)) {
[17:01:25.606]                           computeRestarts <- base::computeRestarts
[17:01:25.606]                           grepl <- base::grepl
[17:01:25.606]                           restarts <- computeRestarts(cond)
[17:01:25.606]                           for (restart in restarts) {
[17:01:25.606]                             name <- restart$name
[17:01:25.606]                             if (is.null(name)) 
[17:01:25.606]                               next
[17:01:25.606]                             if (!grepl(pattern, name)) 
[17:01:25.606]                               next
[17:01:25.606]                             invokeRestart(restart)
[17:01:25.606]                             muffled <- TRUE
[17:01:25.606]                             break
[17:01:25.606]                           }
[17:01:25.606]                         }
[17:01:25.606]                       }
[17:01:25.606]                       invisible(muffled)
[17:01:25.606]                     }
[17:01:25.606]                     muffleCondition(cond, pattern = "^muffle")
[17:01:25.606]                   }
[17:01:25.606]                 }
[17:01:25.606]             }
[17:01:25.606]         }))
[17:01:25.606]     }, error = function(ex) {
[17:01:25.606]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:25.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:25.606]                 ...future.rng), started = ...future.startTime, 
[17:01:25.606]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:25.606]             version = "1.8"), class = "FutureResult")
[17:01:25.606]     }, finally = {
[17:01:25.606]         if (!identical(...future.workdir, getwd())) 
[17:01:25.606]             setwd(...future.workdir)
[17:01:25.606]         {
[17:01:25.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:25.606]                 ...future.oldOptions$nwarnings <- NULL
[17:01:25.606]             }
[17:01:25.606]             base::options(...future.oldOptions)
[17:01:25.606]             if (.Platform$OS.type == "windows") {
[17:01:25.606]                 old_names <- names(...future.oldEnvVars)
[17:01:25.606]                 envs <- base::Sys.getenv()
[17:01:25.606]                 names <- names(envs)
[17:01:25.606]                 common <- intersect(names, old_names)
[17:01:25.606]                 added <- setdiff(names, old_names)
[17:01:25.606]                 removed <- setdiff(old_names, names)
[17:01:25.606]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:25.606]                   envs[common]]
[17:01:25.606]                 NAMES <- toupper(changed)
[17:01:25.606]                 args <- list()
[17:01:25.606]                 for (kk in seq_along(NAMES)) {
[17:01:25.606]                   name <- changed[[kk]]
[17:01:25.606]                   NAME <- NAMES[[kk]]
[17:01:25.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:25.606]                     next
[17:01:25.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:25.606]                 }
[17:01:25.606]                 NAMES <- toupper(added)
[17:01:25.606]                 for (kk in seq_along(NAMES)) {
[17:01:25.606]                   name <- added[[kk]]
[17:01:25.606]                   NAME <- NAMES[[kk]]
[17:01:25.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:25.606]                     next
[17:01:25.606]                   args[[name]] <- ""
[17:01:25.606]                 }
[17:01:25.606]                 NAMES <- toupper(removed)
[17:01:25.606]                 for (kk in seq_along(NAMES)) {
[17:01:25.606]                   name <- removed[[kk]]
[17:01:25.606]                   NAME <- NAMES[[kk]]
[17:01:25.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:25.606]                     next
[17:01:25.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:25.606]                 }
[17:01:25.606]                 if (length(args) > 0) 
[17:01:25.606]                   base::do.call(base::Sys.setenv, args = args)
[17:01:25.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:25.606]             }
[17:01:25.606]             else {
[17:01:25.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:25.606]             }
[17:01:25.606]             {
[17:01:25.606]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:25.606]                   0L) {
[17:01:25.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:25.606]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:25.606]                   base::options(opts)
[17:01:25.606]                 }
[17:01:25.606]                 {
[17:01:25.606]                   {
[17:01:25.606]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:25.606]                     NULL
[17:01:25.606]                   }
[17:01:25.606]                   options(future.plan = NULL)
[17:01:25.606]                   if (is.na(NA_character_)) 
[17:01:25.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:25.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:25.606]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:25.606]                     .init = FALSE)
[17:01:25.606]                 }
[17:01:25.606]             }
[17:01:25.606]         }
[17:01:25.606]     })
[17:01:25.606]     if (TRUE) {
[17:01:25.606]         base::sink(type = "output", split = FALSE)
[17:01:25.606]         if (FALSE) {
[17:01:25.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:25.606]         }
[17:01:25.606]         else {
[17:01:25.606]             ...future.result["stdout"] <- base::list(NULL)
[17:01:25.606]         }
[17:01:25.606]         base::close(...future.stdout)
[17:01:25.606]         ...future.stdout <- NULL
[17:01:25.606]     }
[17:01:25.606]     ...future.result$conditions <- ...future.conditions
[17:01:25.606]     ...future.result$finished <- base::Sys.time()
[17:01:25.606]     ...future.result
[17:01:25.606] }
[17:01:25.609] assign_globals() ...
[17:01:25.609] List of 5
[17:01:25.609]  $ ...future.FUN            :function (x)  
[17:01:25.609]  $ future.call.arguments    : list()
[17:01:25.609]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:25.609]  $ ...future.elements_ii    :List of 1
[17:01:25.609]   ..$ : int 1
[17:01:25.609]  $ ...future.seeds_ii       : NULL
[17:01:25.609]  $ ...future.globals.maxSize: NULL
[17:01:25.609]  - attr(*, "where")=List of 5
[17:01:25.609]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:25.609]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:25.609]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:25.609]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:25.609]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:25.609]  - attr(*, "resolved")= logi FALSE
[17:01:25.609]  - attr(*, "total_size")= num 4720
[17:01:25.609]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:25.609]  - attr(*, "already-done")= logi TRUE
[17:01:25.614] - reassign environment for ‘...future.FUN’
[17:01:25.614] - copied ‘...future.FUN’ to environment
[17:01:25.614] - copied ‘future.call.arguments’ to environment
[17:01:25.614] - copied ‘...future.elements_ii’ to environment
[17:01:25.614] - copied ‘...future.seeds_ii’ to environment
[17:01:25.614] - copied ‘...future.globals.maxSize’ to environment
[17:01:25.614] assign_globals() ... done
[17:01:25.615] requestCore(): workers = 2
[17:01:25.618] MulticoreFuture started
[17:01:25.618] - Launch lazy future ... done
[17:01:25.619] run() for ‘MulticoreFuture’ ... done
[17:01:25.619] plan(): Setting new future strategy stack:
[17:01:25.619] Created future:
[17:01:25.619] List of future strategies:
[17:01:25.619] 1. sequential:
[17:01:25.619]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:25.619]    - tweaked: FALSE
[17:01:25.619]    - call: NULL
[17:01:25.620] plan(): nbrOfWorkers() = 1
[17:01:25.619] MulticoreFuture:
[17:01:25.619] Label: ‘future_lapply-1’
[17:01:25.619] Expression:
[17:01:25.619] {
[17:01:25.619]     do.call(function(...) {
[17:01:25.619]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:25.619]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:25.619]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:25.619]             on.exit(options(oopts), add = TRUE)
[17:01:25.619]         }
[17:01:25.619]         {
[17:01:25.619]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:25.619]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:25.619]                 ...future.FUN(...future.X_jj, ...)
[17:01:25.619]             })
[17:01:25.619]         }
[17:01:25.619]     }, args = future.call.arguments)
[17:01:25.619] }
[17:01:25.619] Lazy evaluation: FALSE
[17:01:25.619] Asynchronous evaluation: TRUE
[17:01:25.619] Local evaluation: TRUE
[17:01:25.619] Environment: R_GlobalEnv
[17:01:25.619] Capture standard output: FALSE
[17:01:25.619] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:25.619] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:25.619] Packages: <none>
[17:01:25.619] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:25.619] Resolved: FALSE
[17:01:25.619] Value: <not collected>
[17:01:25.619] Conditions captured: <none>
[17:01:25.619] Early signaling: FALSE
[17:01:25.619] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:25.619] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:25.635] Chunk #1 of 2 ... DONE
[17:01:25.635] Chunk #2 of 2 ...
[17:01:25.635]  - Finding globals in 'X' for chunk #2 ...
[17:01:25.636] getGlobalsAndPackages() ...
[17:01:25.636] Searching for globals...
[17:01:25.637] 
[17:01:25.637] Searching for globals ... DONE
[17:01:25.637] - globals: [0] <none>
[17:01:25.637] getGlobalsAndPackages() ... DONE
[17:01:25.637]    + additional globals found: [n=0] 
[17:01:25.638]    + additional namespaces needed: [n=0] 
[17:01:25.638]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:25.638]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:25.638]  - seeds: <none>
[17:01:25.638]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:25.639] getGlobalsAndPackages() ...
[17:01:25.639] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:25.639] Resolving globals: FALSE
[17:01:25.639] Tweak future expression to call with '...' arguments ...
[17:01:25.639] {
[17:01:25.639]     do.call(function(...) {
[17:01:25.639]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:25.639]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:25.639]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:25.639]             on.exit(options(oopts), add = TRUE)
[17:01:25.639]         }
[17:01:25.639]         {
[17:01:25.639]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:25.639]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:25.639]                 ...future.FUN(...future.X_jj, ...)
[17:01:25.639]             })
[17:01:25.639]         }
[17:01:25.639]     }, args = future.call.arguments)
[17:01:25.639] }
[17:01:25.640] Tweak future expression to call with '...' arguments ... DONE
[17:01:25.641] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:25.641] 
[17:01:25.641] getGlobalsAndPackages() ... DONE
[17:01:25.642] run() for ‘Future’ ...
[17:01:25.642] - state: ‘created’
[17:01:25.642] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:25.648] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:25.648] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:25.648]   - Field: ‘label’
[17:01:25.648]   - Field: ‘local’
[17:01:25.648]   - Field: ‘owner’
[17:01:25.649]   - Field: ‘envir’
[17:01:25.649]   - Field: ‘workers’
[17:01:25.649]   - Field: ‘packages’
[17:01:25.649]   - Field: ‘gc’
[17:01:25.649]   - Field: ‘job’
[17:01:25.649]   - Field: ‘conditions’
[17:01:25.649]   - Field: ‘expr’
[17:01:25.650]   - Field: ‘uuid’
[17:01:25.650]   - Field: ‘seed’
[17:01:25.650]   - Field: ‘version’
[17:01:25.650]   - Field: ‘result’
[17:01:25.650]   - Field: ‘asynchronous’
[17:01:25.650]   - Field: ‘calls’
[17:01:25.650]   - Field: ‘globals’
[17:01:25.651]   - Field: ‘stdout’
[17:01:25.651]   - Field: ‘earlySignal’
[17:01:25.651]   - Field: ‘lazy’
[17:01:25.651]   - Field: ‘state’
[17:01:25.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:25.651] - Launch lazy future ...
[17:01:25.652] Packages needed by the future expression (n = 0): <none>
[17:01:25.652] Packages needed by future strategies (n = 0): <none>
[17:01:25.653] {
[17:01:25.653]     {
[17:01:25.653]         {
[17:01:25.653]             ...future.startTime <- base::Sys.time()
[17:01:25.653]             {
[17:01:25.653]                 {
[17:01:25.653]                   {
[17:01:25.653]                     {
[17:01:25.653]                       base::local({
[17:01:25.653]                         has_future <- base::requireNamespace("future", 
[17:01:25.653]                           quietly = TRUE)
[17:01:25.653]                         if (has_future) {
[17:01:25.653]                           ns <- base::getNamespace("future")
[17:01:25.653]                           version <- ns[[".package"]][["version"]]
[17:01:25.653]                           if (is.null(version)) 
[17:01:25.653]                             version <- utils::packageVersion("future")
[17:01:25.653]                         }
[17:01:25.653]                         else {
[17:01:25.653]                           version <- NULL
[17:01:25.653]                         }
[17:01:25.653]                         if (!has_future || version < "1.8.0") {
[17:01:25.653]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:25.653]                             "", base::R.version$version.string), 
[17:01:25.653]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:25.653]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:25.653]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:25.653]                               "release", "version")], collapse = " "), 
[17:01:25.653]                             hostname = base::Sys.info()[["nodename"]])
[17:01:25.653]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:25.653]                             info)
[17:01:25.653]                           info <- base::paste(info, collapse = "; ")
[17:01:25.653]                           if (!has_future) {
[17:01:25.653]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:25.653]                               info)
[17:01:25.653]                           }
[17:01:25.653]                           else {
[17:01:25.653]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:25.653]                               info, version)
[17:01:25.653]                           }
[17:01:25.653]                           base::stop(msg)
[17:01:25.653]                         }
[17:01:25.653]                       })
[17:01:25.653]                     }
[17:01:25.653]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:25.653]                     base::options(mc.cores = 1L)
[17:01:25.653]                   }
[17:01:25.653]                   ...future.strategy.old <- future::plan("list")
[17:01:25.653]                   options(future.plan = NULL)
[17:01:25.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:25.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:25.653]                 }
[17:01:25.653]                 ...future.workdir <- getwd()
[17:01:25.653]             }
[17:01:25.653]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:25.653]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:25.653]         }
[17:01:25.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:25.653]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:25.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:25.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:25.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:25.653]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:25.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:25.653]             base::names(...future.oldOptions))
[17:01:25.653]     }
[17:01:25.653]     if (FALSE) {
[17:01:25.653]     }
[17:01:25.653]     else {
[17:01:25.653]         if (FALSE) {
[17:01:25.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:25.653]                 open = "w")
[17:01:25.653]         }
[17:01:25.653]         else {
[17:01:25.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:25.653]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:25.653]         }
[17:01:25.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:25.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:25.653]             base::sink(type = "output", split = FALSE)
[17:01:25.653]             base::close(...future.stdout)
[17:01:25.653]         }, add = TRUE)
[17:01:25.653]     }
[17:01:25.653]     ...future.frame <- base::sys.nframe()
[17:01:25.653]     ...future.conditions <- base::list()
[17:01:25.653]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:25.653]     if (FALSE) {
[17:01:25.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:25.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:25.653]     }
[17:01:25.653]     ...future.result <- base::tryCatch({
[17:01:25.653]         base::withCallingHandlers({
[17:01:25.653]             ...future.value <- base::withVisible(base::local({
[17:01:25.653]                 withCallingHandlers({
[17:01:25.653]                   {
[17:01:25.653]                     do.call(function(...) {
[17:01:25.653]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:25.653]                       if (!identical(...future.globals.maxSize.org, 
[17:01:25.653]                         ...future.globals.maxSize)) {
[17:01:25.653]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:25.653]                         on.exit(options(oopts), add = TRUE)
[17:01:25.653]                       }
[17:01:25.653]                       {
[17:01:25.653]                         lapply(seq_along(...future.elements_ii), 
[17:01:25.653]                           FUN = function(jj) {
[17:01:25.653]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:25.653]                             ...future.FUN(...future.X_jj, ...)
[17:01:25.653]                           })
[17:01:25.653]                       }
[17:01:25.653]                     }, args = future.call.arguments)
[17:01:25.653]                   }
[17:01:25.653]                 }, immediateCondition = function(cond) {
[17:01:25.653]                   save_rds <- function (object, pathname, ...) 
[17:01:25.653]                   {
[17:01:25.653]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:25.653]                     if (file_test("-f", pathname_tmp)) {
[17:01:25.653]                       fi_tmp <- file.info(pathname_tmp)
[17:01:25.653]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:25.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:25.653]                         fi_tmp[["mtime"]])
[17:01:25.653]                     }
[17:01:25.653]                     tryCatch({
[17:01:25.653]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:25.653]                     }, error = function(ex) {
[17:01:25.653]                       msg <- conditionMessage(ex)
[17:01:25.653]                       fi_tmp <- file.info(pathname_tmp)
[17:01:25.653]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:25.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:25.653]                         fi_tmp[["mtime"]], msg)
[17:01:25.653]                       ex$message <- msg
[17:01:25.653]                       stop(ex)
[17:01:25.653]                     })
[17:01:25.653]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:25.653]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:25.653]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:25.653]                       fi_tmp <- file.info(pathname_tmp)
[17:01:25.653]                       fi <- file.info(pathname)
[17:01:25.653]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:25.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:25.653]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:25.653]                         fi[["size"]], fi[["mtime"]])
[17:01:25.653]                       stop(msg)
[17:01:25.653]                     }
[17:01:25.653]                     invisible(pathname)
[17:01:25.653]                   }
[17:01:25.653]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:25.653]                     rootPath = tempdir()) 
[17:01:25.653]                   {
[17:01:25.653]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:25.653]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:25.653]                       tmpdir = path, fileext = ".rds")
[17:01:25.653]                     save_rds(obj, file)
[17:01:25.653]                   }
[17:01:25.653]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:25.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:25.653]                   {
[17:01:25.653]                     inherits <- base::inherits
[17:01:25.653]                     invokeRestart <- base::invokeRestart
[17:01:25.653]                     is.null <- base::is.null
[17:01:25.653]                     muffled <- FALSE
[17:01:25.653]                     if (inherits(cond, "message")) {
[17:01:25.653]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:25.653]                       if (muffled) 
[17:01:25.653]                         invokeRestart("muffleMessage")
[17:01:25.653]                     }
[17:01:25.653]                     else if (inherits(cond, "warning")) {
[17:01:25.653]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:25.653]                       if (muffled) 
[17:01:25.653]                         invokeRestart("muffleWarning")
[17:01:25.653]                     }
[17:01:25.653]                     else if (inherits(cond, "condition")) {
[17:01:25.653]                       if (!is.null(pattern)) {
[17:01:25.653]                         computeRestarts <- base::computeRestarts
[17:01:25.653]                         grepl <- base::grepl
[17:01:25.653]                         restarts <- computeRestarts(cond)
[17:01:25.653]                         for (restart in restarts) {
[17:01:25.653]                           name <- restart$name
[17:01:25.653]                           if (is.null(name)) 
[17:01:25.653]                             next
[17:01:25.653]                           if (!grepl(pattern, name)) 
[17:01:25.653]                             next
[17:01:25.653]                           invokeRestart(restart)
[17:01:25.653]                           muffled <- TRUE
[17:01:25.653]                           break
[17:01:25.653]                         }
[17:01:25.653]                       }
[17:01:25.653]                     }
[17:01:25.653]                     invisible(muffled)
[17:01:25.653]                   }
[17:01:25.653]                   muffleCondition(cond)
[17:01:25.653]                 })
[17:01:25.653]             }))
[17:01:25.653]             future::FutureResult(value = ...future.value$value, 
[17:01:25.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:25.653]                   ...future.rng), globalenv = if (FALSE) 
[17:01:25.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:25.653]                     ...future.globalenv.names))
[17:01:25.653]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:25.653]         }, condition = base::local({
[17:01:25.653]             c <- base::c
[17:01:25.653]             inherits <- base::inherits
[17:01:25.653]             invokeRestart <- base::invokeRestart
[17:01:25.653]             length <- base::length
[17:01:25.653]             list <- base::list
[17:01:25.653]             seq.int <- base::seq.int
[17:01:25.653]             signalCondition <- base::signalCondition
[17:01:25.653]             sys.calls <- base::sys.calls
[17:01:25.653]             `[[` <- base::`[[`
[17:01:25.653]             `+` <- base::`+`
[17:01:25.653]             `<<-` <- base::`<<-`
[17:01:25.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:25.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:25.653]                   3L)]
[17:01:25.653]             }
[17:01:25.653]             function(cond) {
[17:01:25.653]                 is_error <- inherits(cond, "error")
[17:01:25.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:25.653]                   NULL)
[17:01:25.653]                 if (is_error) {
[17:01:25.653]                   sessionInformation <- function() {
[17:01:25.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:25.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:25.653]                       search = base::search(), system = base::Sys.info())
[17:01:25.653]                   }
[17:01:25.653]                   ...future.conditions[[length(...future.conditions) + 
[17:01:25.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:25.653]                     cond$call), session = sessionInformation(), 
[17:01:25.653]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:25.653]                   signalCondition(cond)
[17:01:25.653]                 }
[17:01:25.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:25.653]                 "immediateCondition"))) {
[17:01:25.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:25.653]                   ...future.conditions[[length(...future.conditions) + 
[17:01:25.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:25.653]                   if (TRUE && !signal) {
[17:01:25.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:25.653]                     {
[17:01:25.653]                       inherits <- base::inherits
[17:01:25.653]                       invokeRestart <- base::invokeRestart
[17:01:25.653]                       is.null <- base::is.null
[17:01:25.653]                       muffled <- FALSE
[17:01:25.653]                       if (inherits(cond, "message")) {
[17:01:25.653]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:25.653]                         if (muffled) 
[17:01:25.653]                           invokeRestart("muffleMessage")
[17:01:25.653]                       }
[17:01:25.653]                       else if (inherits(cond, "warning")) {
[17:01:25.653]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:25.653]                         if (muffled) 
[17:01:25.653]                           invokeRestart("muffleWarning")
[17:01:25.653]                       }
[17:01:25.653]                       else if (inherits(cond, "condition")) {
[17:01:25.653]                         if (!is.null(pattern)) {
[17:01:25.653]                           computeRestarts <- base::computeRestarts
[17:01:25.653]                           grepl <- base::grepl
[17:01:25.653]                           restarts <- computeRestarts(cond)
[17:01:25.653]                           for (restart in restarts) {
[17:01:25.653]                             name <- restart$name
[17:01:25.653]                             if (is.null(name)) 
[17:01:25.653]                               next
[17:01:25.653]                             if (!grepl(pattern, name)) 
[17:01:25.653]                               next
[17:01:25.653]                             invokeRestart(restart)
[17:01:25.653]                             muffled <- TRUE
[17:01:25.653]                             break
[17:01:25.653]                           }
[17:01:25.653]                         }
[17:01:25.653]                       }
[17:01:25.653]                       invisible(muffled)
[17:01:25.653]                     }
[17:01:25.653]                     muffleCondition(cond, pattern = "^muffle")
[17:01:25.653]                   }
[17:01:25.653]                 }
[17:01:25.653]                 else {
[17:01:25.653]                   if (TRUE) {
[17:01:25.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:25.653]                     {
[17:01:25.653]                       inherits <- base::inherits
[17:01:25.653]                       invokeRestart <- base::invokeRestart
[17:01:25.653]                       is.null <- base::is.null
[17:01:25.653]                       muffled <- FALSE
[17:01:25.653]                       if (inherits(cond, "message")) {
[17:01:25.653]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:25.653]                         if (muffled) 
[17:01:25.653]                           invokeRestart("muffleMessage")
[17:01:25.653]                       }
[17:01:25.653]                       else if (inherits(cond, "warning")) {
[17:01:25.653]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:25.653]                         if (muffled) 
[17:01:25.653]                           invokeRestart("muffleWarning")
[17:01:25.653]                       }
[17:01:25.653]                       else if (inherits(cond, "condition")) {
[17:01:25.653]                         if (!is.null(pattern)) {
[17:01:25.653]                           computeRestarts <- base::computeRestarts
[17:01:25.653]                           grepl <- base::grepl
[17:01:25.653]                           restarts <- computeRestarts(cond)
[17:01:25.653]                           for (restart in restarts) {
[17:01:25.653]                             name <- restart$name
[17:01:25.653]                             if (is.null(name)) 
[17:01:25.653]                               next
[17:01:25.653]                             if (!grepl(pattern, name)) 
[17:01:25.653]                               next
[17:01:25.653]                             invokeRestart(restart)
[17:01:25.653]                             muffled <- TRUE
[17:01:25.653]                             break
[17:01:25.653]                           }
[17:01:25.653]                         }
[17:01:25.653]                       }
[17:01:25.653]                       invisible(muffled)
[17:01:25.653]                     }
[17:01:25.653]                     muffleCondition(cond, pattern = "^muffle")
[17:01:25.653]                   }
[17:01:25.653]                 }
[17:01:25.653]             }
[17:01:25.653]         }))
[17:01:25.653]     }, error = function(ex) {
[17:01:25.653]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:25.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:25.653]                 ...future.rng), started = ...future.startTime, 
[17:01:25.653]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:25.653]             version = "1.8"), class = "FutureResult")
[17:01:25.653]     }, finally = {
[17:01:25.653]         if (!identical(...future.workdir, getwd())) 
[17:01:25.653]             setwd(...future.workdir)
[17:01:25.653]         {
[17:01:25.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:25.653]                 ...future.oldOptions$nwarnings <- NULL
[17:01:25.653]             }
[17:01:25.653]             base::options(...future.oldOptions)
[17:01:25.653]             if (.Platform$OS.type == "windows") {
[17:01:25.653]                 old_names <- names(...future.oldEnvVars)
[17:01:25.653]                 envs <- base::Sys.getenv()
[17:01:25.653]                 names <- names(envs)
[17:01:25.653]                 common <- intersect(names, old_names)
[17:01:25.653]                 added <- setdiff(names, old_names)
[17:01:25.653]                 removed <- setdiff(old_names, names)
[17:01:25.653]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:25.653]                   envs[common]]
[17:01:25.653]                 NAMES <- toupper(changed)
[17:01:25.653]                 args <- list()
[17:01:25.653]                 for (kk in seq_along(NAMES)) {
[17:01:25.653]                   name <- changed[[kk]]
[17:01:25.653]                   NAME <- NAMES[[kk]]
[17:01:25.653]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:25.653]                     next
[17:01:25.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:25.653]                 }
[17:01:25.653]                 NAMES <- toupper(added)
[17:01:25.653]                 for (kk in seq_along(NAMES)) {
[17:01:25.653]                   name <- added[[kk]]
[17:01:25.653]                   NAME <- NAMES[[kk]]
[17:01:25.653]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:25.653]                     next
[17:01:25.653]                   args[[name]] <- ""
[17:01:25.653]                 }
[17:01:25.653]                 NAMES <- toupper(removed)
[17:01:25.653]                 for (kk in seq_along(NAMES)) {
[17:01:25.653]                   name <- removed[[kk]]
[17:01:25.653]                   NAME <- NAMES[[kk]]
[17:01:25.653]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:25.653]                     next
[17:01:25.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:25.653]                 }
[17:01:25.653]                 if (length(args) > 0) 
[17:01:25.653]                   base::do.call(base::Sys.setenv, args = args)
[17:01:25.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:25.653]             }
[17:01:25.653]             else {
[17:01:25.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:25.653]             }
[17:01:25.653]             {
[17:01:25.653]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:25.653]                   0L) {
[17:01:25.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:25.653]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:25.653]                   base::options(opts)
[17:01:25.653]                 }
[17:01:25.653]                 {
[17:01:25.653]                   {
[17:01:25.653]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:25.653]                     NULL
[17:01:25.653]                   }
[17:01:25.653]                   options(future.plan = NULL)
[17:01:25.653]                   if (is.na(NA_character_)) 
[17:01:25.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:25.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:25.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:25.653]                     .init = FALSE)
[17:01:25.653]                 }
[17:01:25.653]             }
[17:01:25.653]         }
[17:01:25.653]     })
[17:01:25.653]     if (TRUE) {
[17:01:25.653]         base::sink(type = "output", split = FALSE)
[17:01:25.653]         if (FALSE) {
[17:01:25.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:25.653]         }
[17:01:25.653]         else {
[17:01:25.653]             ...future.result["stdout"] <- base::list(NULL)
[17:01:25.653]         }
[17:01:25.653]         base::close(...future.stdout)
[17:01:25.653]         ...future.stdout <- NULL
[17:01:25.653]     }
[17:01:25.653]     ...future.result$conditions <- ...future.conditions
[17:01:25.653]     ...future.result$finished <- base::Sys.time()
[17:01:25.653]     ...future.result
[17:01:25.653] }
[17:01:25.656] assign_globals() ...
[17:01:25.656] List of 5
[17:01:25.656]  $ ...future.FUN            :function (x)  
[17:01:25.656]  $ future.call.arguments    : list()
[17:01:25.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:25.656]  $ ...future.elements_ii    :List of 1
[17:01:25.656]   ..$ : int 0
[17:01:25.656]  $ ...future.seeds_ii       : NULL
[17:01:25.656]  $ ...future.globals.maxSize: NULL
[17:01:25.656]  - attr(*, "where")=List of 5
[17:01:25.656]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:25.656]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:25.656]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:25.656]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:25.656]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:25.656]  - attr(*, "resolved")= logi FALSE
[17:01:25.656]  - attr(*, "total_size")= num 4720
[17:01:25.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:25.656]  - attr(*, "already-done")= logi TRUE
[17:01:25.663] - reassign environment for ‘...future.FUN’
[17:01:25.664] - copied ‘...future.FUN’ to environment
[17:01:25.664] - copied ‘future.call.arguments’ to environment
[17:01:25.664] - copied ‘...future.elements_ii’ to environment
[17:01:25.664] - copied ‘...future.seeds_ii’ to environment
[17:01:25.664] - copied ‘...future.globals.maxSize’ to environment
[17:01:25.664] assign_globals() ... done
[17:01:25.664] requestCore(): workers = 2
[17:01:25.675] MulticoreFuture started
[17:01:25.675] - Launch lazy future ... done
[17:01:25.676] plan(): Setting new future strategy stack:
[17:01:25.676] run() for ‘MulticoreFuture’ ... done
[17:01:25.676] Created future:
[17:01:25.676] List of future strategies:
[17:01:25.676] 1. sequential:
[17:01:25.676]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:25.676]    - tweaked: FALSE
[17:01:25.676]    - call: NULL
[17:01:25.678] plan(): nbrOfWorkers() = 1
[17:01:25.680] plan(): Setting new future strategy stack:
[17:01:25.680] List of future strategies:
[17:01:25.680] 1. multicore:
[17:01:25.680]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:25.680]    - tweaked: FALSE
[17:01:25.680]    - call: plan(strategy)
[17:01:25.686] plan(): nbrOfWorkers() = 2
[17:01:25.677] MulticoreFuture:
[17:01:25.677] Label: ‘future_lapply-2’
[17:01:25.677] Expression:
[17:01:25.677] {
[17:01:25.677]     do.call(function(...) {
[17:01:25.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:25.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:25.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:25.677]             on.exit(options(oopts), add = TRUE)
[17:01:25.677]         }
[17:01:25.677]         {
[17:01:25.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:25.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:25.677]                 ...future.FUN(...future.X_jj, ...)
[17:01:25.677]             })
[17:01:25.677]         }
[17:01:25.677]     }, args = future.call.arguments)
[17:01:25.677] }
[17:01:25.677] Lazy evaluation: FALSE
[17:01:25.677] Asynchronous evaluation: TRUE
[17:01:25.677] Local evaluation: TRUE
[17:01:25.677] Environment: R_GlobalEnv
[17:01:25.677] Capture standard output: FALSE
[17:01:25.677] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:25.677] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:25.677] Packages: <none>
[17:01:25.677] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:25.677] Resolved: TRUE
[17:01:25.677] Value: <not collected>
[17:01:25.677] Conditions captured: <none>
[17:01:25.677] Early signaling: FALSE
[17:01:25.677] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:25.677] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:25.687] Chunk #2 of 2 ... DONE
[17:01:25.688] Launching 2 futures (chunks) ... DONE
[17:01:25.688] Resolving 2 futures (chunks) ...
[17:01:25.688] resolve() on list ...
[17:01:25.688]  recursive: 0
[17:01:25.688]  length: 2
[17:01:25.689] 
[17:01:25.699] Future #2
[17:01:25.700] result() for MulticoreFuture ...
[17:01:25.703] result() for MulticoreFuture ...
[17:01:25.703] result() for MulticoreFuture ... done
[17:01:25.703] result() for MulticoreFuture ... done
[17:01:25.703] result() for MulticoreFuture ...
[17:01:25.704] result() for MulticoreFuture ... done
[17:01:25.704] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:25.704] - nx: 2
[17:01:25.704] - relay: TRUE
[17:01:25.704] - stdout: TRUE
[17:01:25.704] - signal: TRUE
[17:01:25.704] - resignal: FALSE
[17:01:25.704] - force: TRUE
[17:01:25.705] - relayed: [n=2] FALSE, FALSE
[17:01:25.705] - queued futures: [n=2] FALSE, FALSE
[17:01:25.705]  - until=1
[17:01:25.705]  - relaying element #1
[17:01:25.705] - relayed: [n=2] FALSE, FALSE
[17:01:25.705] - queued futures: [n=2] FALSE, TRUE
[17:01:25.705] signalConditionsASAP(NULL, pos=2) ... done
[17:01:25.706]  length: 1 (resolved future 2)
[17:01:26.123] plan(): Setting new future strategy stack:
[17:01:26.123] List of future strategies:
[17:01:26.123] 1. multicore:
[17:01:26.123]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:26.123]    - tweaked: FALSE
[17:01:26.123]    - call: plan(strategy)
[17:01:26.128] plan(): nbrOfWorkers() = 2
[17:01:26.128] Future #1
[17:01:26.129] result() for MulticoreFuture ...
[17:01:26.129] result() for MulticoreFuture ...
[17:01:26.130] result() for MulticoreFuture ... done
[17:01:26.130] result() for MulticoreFuture ... done
[17:01:26.130] result() for MulticoreFuture ...
[17:01:26.130] result() for MulticoreFuture ... done
[17:01:26.130] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:26.130] - nx: 2
[17:01:26.130] - relay: TRUE
[17:01:26.130] - stdout: TRUE
[17:01:26.130] - signal: TRUE
[17:01:26.131] - resignal: FALSE
[17:01:26.131] - force: TRUE
[17:01:26.131] - relayed: [n=2] FALSE, FALSE
[17:01:26.131] - queued futures: [n=2] FALSE, TRUE
[17:01:26.131]  - until=1
[17:01:26.131]  - relaying element #1
[17:01:26.131] result() for MulticoreFuture ...
[17:01:26.131] result() for MulticoreFuture ... done
[17:01:26.131] result() for MulticoreFuture ...
[17:01:26.132] result() for MulticoreFuture ... done
[17:01:26.132] result() for MulticoreFuture ...
[17:01:26.132] result() for MulticoreFuture ... done
[17:01:26.132] result() for MulticoreFuture ...
[17:01:26.132] result() for MulticoreFuture ... done
[17:01:26.132] - relayed: [n=2] TRUE, FALSE
[17:01:26.132] - queued futures: [n=2] TRUE, TRUE
[17:01:26.132] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:26.132]  length: 0 (resolved future 1)
[17:01:26.133] Relaying remaining futures
[17:01:26.133] signalConditionsASAP(NULL, pos=0) ...
[17:01:26.133] - nx: 2
[17:01:26.133] - relay: TRUE
[17:01:26.133] - stdout: TRUE
[17:01:26.133] - signal: TRUE
[17:01:26.133] - resignal: FALSE
[17:01:26.133] - force: TRUE
[17:01:26.133] - relayed: [n=2] TRUE, FALSE
[17:01:26.134] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:26.134]  - relaying element #2
[17:01:26.134] result() for MulticoreFuture ...
[17:01:26.134] result() for MulticoreFuture ... done
[17:01:26.134] result() for MulticoreFuture ...
[17:01:26.134] result() for MulticoreFuture ... done
[17:01:26.134] result() for MulticoreFuture ...
[17:01:26.134] result() for MulticoreFuture ... done
[17:01:26.135] result() for MulticoreFuture ...
[17:01:26.135] result() for MulticoreFuture ... done
[17:01:26.135] - relayed: [n=2] TRUE, TRUE
[17:01:26.135] - queued futures: [n=2] TRUE, TRUE
[17:01:26.135] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:01:26.135] resolve() on list ... DONE
[17:01:26.135] result() for MulticoreFuture ...
[17:01:26.135] result() for MulticoreFuture ... done
[17:01:26.135] result() for MulticoreFuture ...
[17:01:26.136] result() for MulticoreFuture ... done
[17:01:26.136] result() for MulticoreFuture ...
[17:01:26.136] result() for MulticoreFuture ... done
[17:01:26.136] result() for MulticoreFuture ...
[17:01:26.136] result() for MulticoreFuture ... done
[17:01:26.136]  - Number of value chunks collected: 2
[17:01:26.136] Resolving 2 futures (chunks) ... DONE
[17:01:26.136] Reducing values from 2 chunks ...
[17:01:26.136]  - Number of values collected after concatenation: 2
[17:01:26.137]  - Number of values expected: 2
[17:01:26.137] Reducing values from 2 chunks ... DONE
[17:01:26.137] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:01:26.137] future_lapply() ...
[17:01:26.143] Number of chunks: 2
[17:01:26.143] getGlobalsAndPackagesXApply() ...
[17:01:26.143]  - future.globals: TRUE
[17:01:26.143] getGlobalsAndPackages() ...
[17:01:26.143] Searching for globals...
[17:01:26.145] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:26.145] Searching for globals ... DONE
[17:01:26.145] Resolving globals: FALSE
[17:01:26.145] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:26.146] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:26.146] - globals: [1] ‘FUN’
[17:01:26.146] 
[17:01:26.146] getGlobalsAndPackages() ... DONE
[17:01:26.146]  - globals found/used: [n=1] ‘FUN’
[17:01:26.146]  - needed namespaces: [n=0] 
[17:01:26.147] Finding globals ... DONE
[17:01:26.147]  - use_args: TRUE
[17:01:26.147]  - Getting '...' globals ...
[17:01:26.147] resolve() on list ...
[17:01:26.147]  recursive: 0
[17:01:26.147]  length: 1
[17:01:26.148]  elements: ‘...’
[17:01:26.148]  length: 0 (resolved future 1)
[17:01:26.148] resolve() on list ... DONE
[17:01:26.148]    - '...' content: [n=0] 
[17:01:26.148] List of 1
[17:01:26.148]  $ ...: list()
[17:01:26.148]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:26.148]  - attr(*, "where")=List of 1
[17:01:26.148]   ..$ ...:<environment: 0x5636f6a13bf0> 
[17:01:26.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:26.148]  - attr(*, "resolved")= logi TRUE
[17:01:26.148]  - attr(*, "total_size")= num NA
[17:01:26.153]  - Getting '...' globals ... DONE
[17:01:26.153] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:26.154] List of 2
[17:01:26.154]  $ ...future.FUN:function (x)  
[17:01:26.154]  $ ...          : list()
[17:01:26.154]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:26.154]  - attr(*, "where")=List of 2
[17:01:26.154]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:26.154]   ..$ ...          :<environment: 0x5636f6a13bf0> 
[17:01:26.154]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:26.154]  - attr(*, "resolved")= logi FALSE
[17:01:26.154]  - attr(*, "total_size")= num 4720
[17:01:26.156] Packages to be attached in all futures: [n=0] 
[17:01:26.157] getGlobalsAndPackagesXApply() ... DONE
[17:01:26.157] Number of futures (= number of chunks): 2
[17:01:26.157] Launching 2 futures (chunks) ...
[17:01:26.157] Chunk #1 of 2 ...
[17:01:26.157]  - Finding globals in 'X' for chunk #1 ...
[17:01:26.157] getGlobalsAndPackages() ...
[17:01:26.157] Searching for globals...
[17:01:26.158] 
[17:01:26.158] Searching for globals ... DONE
[17:01:26.158] - globals: [0] <none>
[17:01:26.158] getGlobalsAndPackages() ... DONE
[17:01:26.158]    + additional globals found: [n=0] 
[17:01:26.158]    + additional namespaces needed: [n=0] 
[17:01:26.158]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:26.158]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:26.158]  - seeds: <none>
[17:01:26.158]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.158] getGlobalsAndPackages() ...
[17:01:26.159] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.159] Resolving globals: FALSE
[17:01:26.159] Tweak future expression to call with '...' arguments ...
[17:01:26.159] {
[17:01:26.159]     do.call(function(...) {
[17:01:26.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:26.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.159]             on.exit(options(oopts), add = TRUE)
[17:01:26.159]         }
[17:01:26.159]         {
[17:01:26.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:26.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.159]                 ...future.FUN(...future.X_jj, ...)
[17:01:26.159]             })
[17:01:26.159]         }
[17:01:26.159]     }, args = future.call.arguments)
[17:01:26.159] }
[17:01:26.159] Tweak future expression to call with '...' arguments ... DONE
[17:01:26.160] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.160] 
[17:01:26.160] getGlobalsAndPackages() ... DONE
[17:01:26.160] run() for ‘Future’ ...
[17:01:26.160] - state: ‘created’
[17:01:26.160] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:26.164] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:26.165] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:26.165]   - Field: ‘label’
[17:01:26.165]   - Field: ‘local’
[17:01:26.165]   - Field: ‘owner’
[17:01:26.165]   - Field: ‘envir’
[17:01:26.165]   - Field: ‘workers’
[17:01:26.165]   - Field: ‘packages’
[17:01:26.166]   - Field: ‘gc’
[17:01:26.166]   - Field: ‘job’
[17:01:26.166]   - Field: ‘conditions’
[17:01:26.166]   - Field: ‘expr’
[17:01:26.166]   - Field: ‘uuid’
[17:01:26.166]   - Field: ‘seed’
[17:01:26.166]   - Field: ‘version’
[17:01:26.166]   - Field: ‘result’
[17:01:26.166]   - Field: ‘asynchronous’
[17:01:26.166]   - Field: ‘calls’
[17:01:26.167]   - Field: ‘globals’
[17:01:26.167]   - Field: ‘stdout’
[17:01:26.167]   - Field: ‘earlySignal’
[17:01:26.167]   - Field: ‘lazy’
[17:01:26.167]   - Field: ‘state’
[17:01:26.167] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:26.167] - Launch lazy future ...
[17:01:26.167] Packages needed by the future expression (n = 0): <none>
[17:01:26.168] Packages needed by future strategies (n = 0): <none>
[17:01:26.168] {
[17:01:26.168]     {
[17:01:26.168]         {
[17:01:26.168]             ...future.startTime <- base::Sys.time()
[17:01:26.168]             {
[17:01:26.168]                 {
[17:01:26.168]                   {
[17:01:26.168]                     {
[17:01:26.168]                       base::local({
[17:01:26.168]                         has_future <- base::requireNamespace("future", 
[17:01:26.168]                           quietly = TRUE)
[17:01:26.168]                         if (has_future) {
[17:01:26.168]                           ns <- base::getNamespace("future")
[17:01:26.168]                           version <- ns[[".package"]][["version"]]
[17:01:26.168]                           if (is.null(version)) 
[17:01:26.168]                             version <- utils::packageVersion("future")
[17:01:26.168]                         }
[17:01:26.168]                         else {
[17:01:26.168]                           version <- NULL
[17:01:26.168]                         }
[17:01:26.168]                         if (!has_future || version < "1.8.0") {
[17:01:26.168]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:26.168]                             "", base::R.version$version.string), 
[17:01:26.168]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:26.168]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:26.168]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:26.168]                               "release", "version")], collapse = " "), 
[17:01:26.168]                             hostname = base::Sys.info()[["nodename"]])
[17:01:26.168]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:26.168]                             info)
[17:01:26.168]                           info <- base::paste(info, collapse = "; ")
[17:01:26.168]                           if (!has_future) {
[17:01:26.168]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:26.168]                               info)
[17:01:26.168]                           }
[17:01:26.168]                           else {
[17:01:26.168]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:26.168]                               info, version)
[17:01:26.168]                           }
[17:01:26.168]                           base::stop(msg)
[17:01:26.168]                         }
[17:01:26.168]                       })
[17:01:26.168]                     }
[17:01:26.168]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:26.168]                     base::options(mc.cores = 1L)
[17:01:26.168]                   }
[17:01:26.168]                   ...future.strategy.old <- future::plan("list")
[17:01:26.168]                   options(future.plan = NULL)
[17:01:26.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:26.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:26.168]                 }
[17:01:26.168]                 ...future.workdir <- getwd()
[17:01:26.168]             }
[17:01:26.168]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:26.168]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:26.168]         }
[17:01:26.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:26.168]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:26.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:26.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:26.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:26.168]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:26.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:26.168]             base::names(...future.oldOptions))
[17:01:26.168]     }
[17:01:26.168]     if (FALSE) {
[17:01:26.168]     }
[17:01:26.168]     else {
[17:01:26.168]         if (TRUE) {
[17:01:26.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:26.168]                 open = "w")
[17:01:26.168]         }
[17:01:26.168]         else {
[17:01:26.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:26.168]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:26.168]         }
[17:01:26.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:26.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:26.168]             base::sink(type = "output", split = FALSE)
[17:01:26.168]             base::close(...future.stdout)
[17:01:26.168]         }, add = TRUE)
[17:01:26.168]     }
[17:01:26.168]     ...future.frame <- base::sys.nframe()
[17:01:26.168]     ...future.conditions <- base::list()
[17:01:26.168]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:26.168]     if (FALSE) {
[17:01:26.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:26.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:26.168]     }
[17:01:26.168]     ...future.result <- base::tryCatch({
[17:01:26.168]         base::withCallingHandlers({
[17:01:26.168]             ...future.value <- base::withVisible(base::local({
[17:01:26.168]                 withCallingHandlers({
[17:01:26.168]                   {
[17:01:26.168]                     do.call(function(...) {
[17:01:26.168]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.168]                       if (!identical(...future.globals.maxSize.org, 
[17:01:26.168]                         ...future.globals.maxSize)) {
[17:01:26.168]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.168]                         on.exit(options(oopts), add = TRUE)
[17:01:26.168]                       }
[17:01:26.168]                       {
[17:01:26.168]                         lapply(seq_along(...future.elements_ii), 
[17:01:26.168]                           FUN = function(jj) {
[17:01:26.168]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.168]                             ...future.FUN(...future.X_jj, ...)
[17:01:26.168]                           })
[17:01:26.168]                       }
[17:01:26.168]                     }, args = future.call.arguments)
[17:01:26.168]                   }
[17:01:26.168]                 }, immediateCondition = function(cond) {
[17:01:26.168]                   save_rds <- function (object, pathname, ...) 
[17:01:26.168]                   {
[17:01:26.168]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:26.168]                     if (file_test("-f", pathname_tmp)) {
[17:01:26.168]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.168]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:26.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.168]                         fi_tmp[["mtime"]])
[17:01:26.168]                     }
[17:01:26.168]                     tryCatch({
[17:01:26.168]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:26.168]                     }, error = function(ex) {
[17:01:26.168]                       msg <- conditionMessage(ex)
[17:01:26.168]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.168]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:26.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.168]                         fi_tmp[["mtime"]], msg)
[17:01:26.168]                       ex$message <- msg
[17:01:26.168]                       stop(ex)
[17:01:26.168]                     })
[17:01:26.168]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:26.168]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:26.168]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:26.168]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.168]                       fi <- file.info(pathname)
[17:01:26.168]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:26.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.168]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:26.168]                         fi[["size"]], fi[["mtime"]])
[17:01:26.168]                       stop(msg)
[17:01:26.168]                     }
[17:01:26.168]                     invisible(pathname)
[17:01:26.168]                   }
[17:01:26.168]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:26.168]                     rootPath = tempdir()) 
[17:01:26.168]                   {
[17:01:26.168]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:26.168]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:26.168]                       tmpdir = path, fileext = ".rds")
[17:01:26.168]                     save_rds(obj, file)
[17:01:26.168]                   }
[17:01:26.168]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:26.168]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.168]                   {
[17:01:26.168]                     inherits <- base::inherits
[17:01:26.168]                     invokeRestart <- base::invokeRestart
[17:01:26.168]                     is.null <- base::is.null
[17:01:26.168]                     muffled <- FALSE
[17:01:26.168]                     if (inherits(cond, "message")) {
[17:01:26.168]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:26.168]                       if (muffled) 
[17:01:26.168]                         invokeRestart("muffleMessage")
[17:01:26.168]                     }
[17:01:26.168]                     else if (inherits(cond, "warning")) {
[17:01:26.168]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:26.168]                       if (muffled) 
[17:01:26.168]                         invokeRestart("muffleWarning")
[17:01:26.168]                     }
[17:01:26.168]                     else if (inherits(cond, "condition")) {
[17:01:26.168]                       if (!is.null(pattern)) {
[17:01:26.168]                         computeRestarts <- base::computeRestarts
[17:01:26.168]                         grepl <- base::grepl
[17:01:26.168]                         restarts <- computeRestarts(cond)
[17:01:26.168]                         for (restart in restarts) {
[17:01:26.168]                           name <- restart$name
[17:01:26.168]                           if (is.null(name)) 
[17:01:26.168]                             next
[17:01:26.168]                           if (!grepl(pattern, name)) 
[17:01:26.168]                             next
[17:01:26.168]                           invokeRestart(restart)
[17:01:26.168]                           muffled <- TRUE
[17:01:26.168]                           break
[17:01:26.168]                         }
[17:01:26.168]                       }
[17:01:26.168]                     }
[17:01:26.168]                     invisible(muffled)
[17:01:26.168]                   }
[17:01:26.168]                   muffleCondition(cond)
[17:01:26.168]                 })
[17:01:26.168]             }))
[17:01:26.168]             future::FutureResult(value = ...future.value$value, 
[17:01:26.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:26.168]                   ...future.rng), globalenv = if (FALSE) 
[17:01:26.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:26.168]                     ...future.globalenv.names))
[17:01:26.168]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:26.168]         }, condition = base::local({
[17:01:26.168]             c <- base::c
[17:01:26.168]             inherits <- base::inherits
[17:01:26.168]             invokeRestart <- base::invokeRestart
[17:01:26.168]             length <- base::length
[17:01:26.168]             list <- base::list
[17:01:26.168]             seq.int <- base::seq.int
[17:01:26.168]             signalCondition <- base::signalCondition
[17:01:26.168]             sys.calls <- base::sys.calls
[17:01:26.168]             `[[` <- base::`[[`
[17:01:26.168]             `+` <- base::`+`
[17:01:26.168]             `<<-` <- base::`<<-`
[17:01:26.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:26.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:26.168]                   3L)]
[17:01:26.168]             }
[17:01:26.168]             function(cond) {
[17:01:26.168]                 is_error <- inherits(cond, "error")
[17:01:26.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:26.168]                   NULL)
[17:01:26.168]                 if (is_error) {
[17:01:26.168]                   sessionInformation <- function() {
[17:01:26.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:26.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:26.168]                       search = base::search(), system = base::Sys.info())
[17:01:26.168]                   }
[17:01:26.168]                   ...future.conditions[[length(...future.conditions) + 
[17:01:26.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:26.168]                     cond$call), session = sessionInformation(), 
[17:01:26.168]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:26.168]                   signalCondition(cond)
[17:01:26.168]                 }
[17:01:26.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:26.168]                 "immediateCondition"))) {
[17:01:26.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:26.168]                   ...future.conditions[[length(...future.conditions) + 
[17:01:26.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:26.168]                   if (TRUE && !signal) {
[17:01:26.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.168]                     {
[17:01:26.168]                       inherits <- base::inherits
[17:01:26.168]                       invokeRestart <- base::invokeRestart
[17:01:26.168]                       is.null <- base::is.null
[17:01:26.168]                       muffled <- FALSE
[17:01:26.168]                       if (inherits(cond, "message")) {
[17:01:26.168]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:26.168]                         if (muffled) 
[17:01:26.168]                           invokeRestart("muffleMessage")
[17:01:26.168]                       }
[17:01:26.168]                       else if (inherits(cond, "warning")) {
[17:01:26.168]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:26.168]                         if (muffled) 
[17:01:26.168]                           invokeRestart("muffleWarning")
[17:01:26.168]                       }
[17:01:26.168]                       else if (inherits(cond, "condition")) {
[17:01:26.168]                         if (!is.null(pattern)) {
[17:01:26.168]                           computeRestarts <- base::computeRestarts
[17:01:26.168]                           grepl <- base::grepl
[17:01:26.168]                           restarts <- computeRestarts(cond)
[17:01:26.168]                           for (restart in restarts) {
[17:01:26.168]                             name <- restart$name
[17:01:26.168]                             if (is.null(name)) 
[17:01:26.168]                               next
[17:01:26.168]                             if (!grepl(pattern, name)) 
[17:01:26.168]                               next
[17:01:26.168]                             invokeRestart(restart)
[17:01:26.168]                             muffled <- TRUE
[17:01:26.168]                             break
[17:01:26.168]                           }
[17:01:26.168]                         }
[17:01:26.168]                       }
[17:01:26.168]                       invisible(muffled)
[17:01:26.168]                     }
[17:01:26.168]                     muffleCondition(cond, pattern = "^muffle")
[17:01:26.168]                   }
[17:01:26.168]                 }
[17:01:26.168]                 else {
[17:01:26.168]                   if (TRUE) {
[17:01:26.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.168]                     {
[17:01:26.168]                       inherits <- base::inherits
[17:01:26.168]                       invokeRestart <- base::invokeRestart
[17:01:26.168]                       is.null <- base::is.null
[17:01:26.168]                       muffled <- FALSE
[17:01:26.168]                       if (inherits(cond, "message")) {
[17:01:26.168]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:26.168]                         if (muffled) 
[17:01:26.168]                           invokeRestart("muffleMessage")
[17:01:26.168]                       }
[17:01:26.168]                       else if (inherits(cond, "warning")) {
[17:01:26.168]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:26.168]                         if (muffled) 
[17:01:26.168]                           invokeRestart("muffleWarning")
[17:01:26.168]                       }
[17:01:26.168]                       else if (inherits(cond, "condition")) {
[17:01:26.168]                         if (!is.null(pattern)) {
[17:01:26.168]                           computeRestarts <- base::computeRestarts
[17:01:26.168]                           grepl <- base::grepl
[17:01:26.168]                           restarts <- computeRestarts(cond)
[17:01:26.168]                           for (restart in restarts) {
[17:01:26.168]                             name <- restart$name
[17:01:26.168]                             if (is.null(name)) 
[17:01:26.168]                               next
[17:01:26.168]                             if (!grepl(pattern, name)) 
[17:01:26.168]                               next
[17:01:26.168]                             invokeRestart(restart)
[17:01:26.168]                             muffled <- TRUE
[17:01:26.168]                             break
[17:01:26.168]                           }
[17:01:26.168]                         }
[17:01:26.168]                       }
[17:01:26.168]                       invisible(muffled)
[17:01:26.168]                     }
[17:01:26.168]                     muffleCondition(cond, pattern = "^muffle")
[17:01:26.168]                   }
[17:01:26.168]                 }
[17:01:26.168]             }
[17:01:26.168]         }))
[17:01:26.168]     }, error = function(ex) {
[17:01:26.168]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:26.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:26.168]                 ...future.rng), started = ...future.startTime, 
[17:01:26.168]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:26.168]             version = "1.8"), class = "FutureResult")
[17:01:26.168]     }, finally = {
[17:01:26.168]         if (!identical(...future.workdir, getwd())) 
[17:01:26.168]             setwd(...future.workdir)
[17:01:26.168]         {
[17:01:26.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:26.168]                 ...future.oldOptions$nwarnings <- NULL
[17:01:26.168]             }
[17:01:26.168]             base::options(...future.oldOptions)
[17:01:26.168]             if (.Platform$OS.type == "windows") {
[17:01:26.168]                 old_names <- names(...future.oldEnvVars)
[17:01:26.168]                 envs <- base::Sys.getenv()
[17:01:26.168]                 names <- names(envs)
[17:01:26.168]                 common <- intersect(names, old_names)
[17:01:26.168]                 added <- setdiff(names, old_names)
[17:01:26.168]                 removed <- setdiff(old_names, names)
[17:01:26.168]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:26.168]                   envs[common]]
[17:01:26.168]                 NAMES <- toupper(changed)
[17:01:26.168]                 args <- list()
[17:01:26.168]                 for (kk in seq_along(NAMES)) {
[17:01:26.168]                   name <- changed[[kk]]
[17:01:26.168]                   NAME <- NAMES[[kk]]
[17:01:26.168]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.168]                     next
[17:01:26.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:26.168]                 }
[17:01:26.168]                 NAMES <- toupper(added)
[17:01:26.168]                 for (kk in seq_along(NAMES)) {
[17:01:26.168]                   name <- added[[kk]]
[17:01:26.168]                   NAME <- NAMES[[kk]]
[17:01:26.168]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.168]                     next
[17:01:26.168]                   args[[name]] <- ""
[17:01:26.168]                 }
[17:01:26.168]                 NAMES <- toupper(removed)
[17:01:26.168]                 for (kk in seq_along(NAMES)) {
[17:01:26.168]                   name <- removed[[kk]]
[17:01:26.168]                   NAME <- NAMES[[kk]]
[17:01:26.168]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.168]                     next
[17:01:26.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:26.168]                 }
[17:01:26.168]                 if (length(args) > 0) 
[17:01:26.168]                   base::do.call(base::Sys.setenv, args = args)
[17:01:26.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:26.168]             }
[17:01:26.168]             else {
[17:01:26.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:26.168]             }
[17:01:26.168]             {
[17:01:26.168]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:26.168]                   0L) {
[17:01:26.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:26.168]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:26.168]                   base::options(opts)
[17:01:26.168]                 }
[17:01:26.168]                 {
[17:01:26.168]                   {
[17:01:26.168]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:26.168]                     NULL
[17:01:26.168]                   }
[17:01:26.168]                   options(future.plan = NULL)
[17:01:26.168]                   if (is.na(NA_character_)) 
[17:01:26.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:26.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:26.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:26.168]                     .init = FALSE)
[17:01:26.168]                 }
[17:01:26.168]             }
[17:01:26.168]         }
[17:01:26.168]     })
[17:01:26.168]     if (TRUE) {
[17:01:26.168]         base::sink(type = "output", split = FALSE)
[17:01:26.168]         if (TRUE) {
[17:01:26.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:26.168]         }
[17:01:26.168]         else {
[17:01:26.168]             ...future.result["stdout"] <- base::list(NULL)
[17:01:26.168]         }
[17:01:26.168]         base::close(...future.stdout)
[17:01:26.168]         ...future.stdout <- NULL
[17:01:26.168]     }
[17:01:26.168]     ...future.result$conditions <- ...future.conditions
[17:01:26.168]     ...future.result$finished <- base::Sys.time()
[17:01:26.168]     ...future.result
[17:01:26.168] }
[17:01:26.171] assign_globals() ...
[17:01:26.171] List of 5
[17:01:26.171]  $ ...future.FUN            :function (x)  
[17:01:26.171]  $ future.call.arguments    : list()
[17:01:26.171]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:26.171]  $ ...future.elements_ii    :List of 1
[17:01:26.171]   ..$ : int 1
[17:01:26.171]  $ ...future.seeds_ii       : NULL
[17:01:26.171]  $ ...future.globals.maxSize: NULL
[17:01:26.171]  - attr(*, "where")=List of 5
[17:01:26.171]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:26.171]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:26.171]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:26.171]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:26.171]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:26.171]  - attr(*, "resolved")= logi FALSE
[17:01:26.171]  - attr(*, "total_size")= num 4720
[17:01:26.171]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:26.171]  - attr(*, "already-done")= logi TRUE
[17:01:26.175] - reassign environment for ‘...future.FUN’
[17:01:26.176] - copied ‘...future.FUN’ to environment
[17:01:26.176] - copied ‘future.call.arguments’ to environment
[17:01:26.176] - copied ‘...future.elements_ii’ to environment
[17:01:26.176] - copied ‘...future.seeds_ii’ to environment
[17:01:26.176] - copied ‘...future.globals.maxSize’ to environment
[17:01:26.176] assign_globals() ... done
[17:01:26.176] requestCore(): workers = 2
[17:01:26.179] MulticoreFuture started
[17:01:26.179] - Launch lazy future ... done
[17:01:26.179] run() for ‘MulticoreFuture’ ... done
[17:01:26.180] Created future:
[17:01:26.180] plan(): Setting new future strategy stack:
[17:01:26.180] List of future strategies:
[17:01:26.180] 1. sequential:
[17:01:26.180]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:26.180]    - tweaked: FALSE
[17:01:26.180]    - call: NULL
[17:01:26.181] plan(): nbrOfWorkers() = 1
[17:01:26.180] MulticoreFuture:
[17:01:26.180] Label: ‘future_lapply-1’
[17:01:26.180] Expression:
[17:01:26.180] {
[17:01:26.180]     do.call(function(...) {
[17:01:26.180]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.180]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:26.180]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.180]             on.exit(options(oopts), add = TRUE)
[17:01:26.180]         }
[17:01:26.180]         {
[17:01:26.180]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:26.180]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.180]                 ...future.FUN(...future.X_jj, ...)
[17:01:26.180]             })
[17:01:26.180]         }
[17:01:26.180]     }, args = future.call.arguments)
[17:01:26.180] }
[17:01:26.180] Lazy evaluation: FALSE
[17:01:26.180] Asynchronous evaluation: TRUE
[17:01:26.180] Local evaluation: TRUE
[17:01:26.180] Environment: R_GlobalEnv
[17:01:26.180] Capture standard output: TRUE
[17:01:26.180] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:26.180] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:26.180] Packages: <none>
[17:01:26.180] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:26.180] Resolved: FALSE
[17:01:26.180] Value: <not collected>
[17:01:26.180] Conditions captured: <none>
[17:01:26.180] Early signaling: FALSE
[17:01:26.180] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:26.180] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:26.193] Chunk #1 of 2 ... DONE
[17:01:26.193] Chunk #2 of 2 ...
[17:01:26.193]  - Finding globals in 'X' for chunk #2 ...
[17:01:26.193] getGlobalsAndPackages() ...
[17:01:26.194] Searching for globals...
[17:01:26.194] 
[17:01:26.194] Searching for globals ... DONE
[17:01:26.194] - globals: [0] <none>
[17:01:26.195] getGlobalsAndPackages() ... DONE
[17:01:26.195]    + additional globals found: [n=0] 
[17:01:26.195]    + additional namespaces needed: [n=0] 
[17:01:26.195]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:26.195]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:26.195]  - seeds: <none>
[17:01:26.196]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.196] getGlobalsAndPackages() ...
[17:01:26.196] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.196] Resolving globals: FALSE
[17:01:26.196] Tweak future expression to call with '...' arguments ...
[17:01:26.196] {
[17:01:26.196]     do.call(function(...) {
[17:01:26.196]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.196]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:26.196]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.196]             on.exit(options(oopts), add = TRUE)
[17:01:26.196]         }
[17:01:26.196]         {
[17:01:26.196]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:26.196]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.196]                 ...future.FUN(...future.X_jj, ...)
[17:01:26.196]             })
[17:01:26.196]         }
[17:01:26.196]     }, args = future.call.arguments)
[17:01:26.196] }
[17:01:26.197] Tweak future expression to call with '...' arguments ... DONE
[17:01:26.201] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.202] 
[17:01:26.202] getGlobalsAndPackages() ... DONE
[17:01:26.203] run() for ‘Future’ ...
[17:01:26.203] - state: ‘created’
[17:01:26.204] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:26.211] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:26.211] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:26.211]   - Field: ‘label’
[17:01:26.211]   - Field: ‘local’
[17:01:26.212]   - Field: ‘owner’
[17:01:26.212]   - Field: ‘envir’
[17:01:26.212]   - Field: ‘workers’
[17:01:26.212]   - Field: ‘packages’
[17:01:26.212]   - Field: ‘gc’
[17:01:26.212]   - Field: ‘job’
[17:01:26.212]   - Field: ‘conditions’
[17:01:26.213]   - Field: ‘expr’
[17:01:26.213]   - Field: ‘uuid’
[17:01:26.213]   - Field: ‘seed’
[17:01:26.213]   - Field: ‘version’
[17:01:26.213]   - Field: ‘result’
[17:01:26.213]   - Field: ‘asynchronous’
[17:01:26.214]   - Field: ‘calls’
[17:01:26.214]   - Field: ‘globals’
[17:01:26.214]   - Field: ‘stdout’
[17:01:26.214]   - Field: ‘earlySignal’
[17:01:26.214]   - Field: ‘lazy’
[17:01:26.214]   - Field: ‘state’
[17:01:26.215] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:26.215] - Launch lazy future ...
[17:01:26.215] Packages needed by the future expression (n = 0): <none>
[17:01:26.216] Packages needed by future strategies (n = 0): <none>
[17:01:26.216] {
[17:01:26.216]     {
[17:01:26.216]         {
[17:01:26.216]             ...future.startTime <- base::Sys.time()
[17:01:26.216]             {
[17:01:26.216]                 {
[17:01:26.216]                   {
[17:01:26.216]                     {
[17:01:26.216]                       base::local({
[17:01:26.216]                         has_future <- base::requireNamespace("future", 
[17:01:26.216]                           quietly = TRUE)
[17:01:26.216]                         if (has_future) {
[17:01:26.216]                           ns <- base::getNamespace("future")
[17:01:26.216]                           version <- ns[[".package"]][["version"]]
[17:01:26.216]                           if (is.null(version)) 
[17:01:26.216]                             version <- utils::packageVersion("future")
[17:01:26.216]                         }
[17:01:26.216]                         else {
[17:01:26.216]                           version <- NULL
[17:01:26.216]                         }
[17:01:26.216]                         if (!has_future || version < "1.8.0") {
[17:01:26.216]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:26.216]                             "", base::R.version$version.string), 
[17:01:26.216]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:26.216]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:26.216]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:26.216]                               "release", "version")], collapse = " "), 
[17:01:26.216]                             hostname = base::Sys.info()[["nodename"]])
[17:01:26.216]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:26.216]                             info)
[17:01:26.216]                           info <- base::paste(info, collapse = "; ")
[17:01:26.216]                           if (!has_future) {
[17:01:26.216]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:26.216]                               info)
[17:01:26.216]                           }
[17:01:26.216]                           else {
[17:01:26.216]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:26.216]                               info, version)
[17:01:26.216]                           }
[17:01:26.216]                           base::stop(msg)
[17:01:26.216]                         }
[17:01:26.216]                       })
[17:01:26.216]                     }
[17:01:26.216]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:26.216]                     base::options(mc.cores = 1L)
[17:01:26.216]                   }
[17:01:26.216]                   ...future.strategy.old <- future::plan("list")
[17:01:26.216]                   options(future.plan = NULL)
[17:01:26.216]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:26.216]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:26.216]                 }
[17:01:26.216]                 ...future.workdir <- getwd()
[17:01:26.216]             }
[17:01:26.216]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:26.216]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:26.216]         }
[17:01:26.216]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:26.216]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:26.216]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:26.216]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:26.216]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:26.216]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:26.216]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:26.216]             base::names(...future.oldOptions))
[17:01:26.216]     }
[17:01:26.216]     if (FALSE) {
[17:01:26.216]     }
[17:01:26.216]     else {
[17:01:26.216]         if (TRUE) {
[17:01:26.216]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:26.216]                 open = "w")
[17:01:26.216]         }
[17:01:26.216]         else {
[17:01:26.216]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:26.216]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:26.216]         }
[17:01:26.216]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:26.216]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:26.216]             base::sink(type = "output", split = FALSE)
[17:01:26.216]             base::close(...future.stdout)
[17:01:26.216]         }, add = TRUE)
[17:01:26.216]     }
[17:01:26.216]     ...future.frame <- base::sys.nframe()
[17:01:26.216]     ...future.conditions <- base::list()
[17:01:26.216]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:26.216]     if (FALSE) {
[17:01:26.216]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:26.216]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:26.216]     }
[17:01:26.216]     ...future.result <- base::tryCatch({
[17:01:26.216]         base::withCallingHandlers({
[17:01:26.216]             ...future.value <- base::withVisible(base::local({
[17:01:26.216]                 withCallingHandlers({
[17:01:26.216]                   {
[17:01:26.216]                     do.call(function(...) {
[17:01:26.216]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.216]                       if (!identical(...future.globals.maxSize.org, 
[17:01:26.216]                         ...future.globals.maxSize)) {
[17:01:26.216]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.216]                         on.exit(options(oopts), add = TRUE)
[17:01:26.216]                       }
[17:01:26.216]                       {
[17:01:26.216]                         lapply(seq_along(...future.elements_ii), 
[17:01:26.216]                           FUN = function(jj) {
[17:01:26.216]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.216]                             ...future.FUN(...future.X_jj, ...)
[17:01:26.216]                           })
[17:01:26.216]                       }
[17:01:26.216]                     }, args = future.call.arguments)
[17:01:26.216]                   }
[17:01:26.216]                 }, immediateCondition = function(cond) {
[17:01:26.216]                   save_rds <- function (object, pathname, ...) 
[17:01:26.216]                   {
[17:01:26.216]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:26.216]                     if (file_test("-f", pathname_tmp)) {
[17:01:26.216]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.216]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:26.216]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.216]                         fi_tmp[["mtime"]])
[17:01:26.216]                     }
[17:01:26.216]                     tryCatch({
[17:01:26.216]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:26.216]                     }, error = function(ex) {
[17:01:26.216]                       msg <- conditionMessage(ex)
[17:01:26.216]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.216]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:26.216]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.216]                         fi_tmp[["mtime"]], msg)
[17:01:26.216]                       ex$message <- msg
[17:01:26.216]                       stop(ex)
[17:01:26.216]                     })
[17:01:26.216]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:26.216]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:26.216]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:26.216]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.216]                       fi <- file.info(pathname)
[17:01:26.216]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:26.216]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.216]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:26.216]                         fi[["size"]], fi[["mtime"]])
[17:01:26.216]                       stop(msg)
[17:01:26.216]                     }
[17:01:26.216]                     invisible(pathname)
[17:01:26.216]                   }
[17:01:26.216]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:26.216]                     rootPath = tempdir()) 
[17:01:26.216]                   {
[17:01:26.216]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:26.216]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:26.216]                       tmpdir = path, fileext = ".rds")
[17:01:26.216]                     save_rds(obj, file)
[17:01:26.216]                   }
[17:01:26.216]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:26.216]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.216]                   {
[17:01:26.216]                     inherits <- base::inherits
[17:01:26.216]                     invokeRestart <- base::invokeRestart
[17:01:26.216]                     is.null <- base::is.null
[17:01:26.216]                     muffled <- FALSE
[17:01:26.216]                     if (inherits(cond, "message")) {
[17:01:26.216]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:26.216]                       if (muffled) 
[17:01:26.216]                         invokeRestart("muffleMessage")
[17:01:26.216]                     }
[17:01:26.216]                     else if (inherits(cond, "warning")) {
[17:01:26.216]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:26.216]                       if (muffled) 
[17:01:26.216]                         invokeRestart("muffleWarning")
[17:01:26.216]                     }
[17:01:26.216]                     else if (inherits(cond, "condition")) {
[17:01:26.216]                       if (!is.null(pattern)) {
[17:01:26.216]                         computeRestarts <- base::computeRestarts
[17:01:26.216]                         grepl <- base::grepl
[17:01:26.216]                         restarts <- computeRestarts(cond)
[17:01:26.216]                         for (restart in restarts) {
[17:01:26.216]                           name <- restart$name
[17:01:26.216]                           if (is.null(name)) 
[17:01:26.216]                             next
[17:01:26.216]                           if (!grepl(pattern, name)) 
[17:01:26.216]                             next
[17:01:26.216]                           invokeRestart(restart)
[17:01:26.216]                           muffled <- TRUE
[17:01:26.216]                           break
[17:01:26.216]                         }
[17:01:26.216]                       }
[17:01:26.216]                     }
[17:01:26.216]                     invisible(muffled)
[17:01:26.216]                   }
[17:01:26.216]                   muffleCondition(cond)
[17:01:26.216]                 })
[17:01:26.216]             }))
[17:01:26.216]             future::FutureResult(value = ...future.value$value, 
[17:01:26.216]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:26.216]                   ...future.rng), globalenv = if (FALSE) 
[17:01:26.216]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:26.216]                     ...future.globalenv.names))
[17:01:26.216]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:26.216]         }, condition = base::local({
[17:01:26.216]             c <- base::c
[17:01:26.216]             inherits <- base::inherits
[17:01:26.216]             invokeRestart <- base::invokeRestart
[17:01:26.216]             length <- base::length
[17:01:26.216]             list <- base::list
[17:01:26.216]             seq.int <- base::seq.int
[17:01:26.216]             signalCondition <- base::signalCondition
[17:01:26.216]             sys.calls <- base::sys.calls
[17:01:26.216]             `[[` <- base::`[[`
[17:01:26.216]             `+` <- base::`+`
[17:01:26.216]             `<<-` <- base::`<<-`
[17:01:26.216]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:26.216]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:26.216]                   3L)]
[17:01:26.216]             }
[17:01:26.216]             function(cond) {
[17:01:26.216]                 is_error <- inherits(cond, "error")
[17:01:26.216]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:26.216]                   NULL)
[17:01:26.216]                 if (is_error) {
[17:01:26.216]                   sessionInformation <- function() {
[17:01:26.216]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:26.216]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:26.216]                       search = base::search(), system = base::Sys.info())
[17:01:26.216]                   }
[17:01:26.216]                   ...future.conditions[[length(...future.conditions) + 
[17:01:26.216]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:26.216]                     cond$call), session = sessionInformation(), 
[17:01:26.216]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:26.216]                   signalCondition(cond)
[17:01:26.216]                 }
[17:01:26.216]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:26.216]                 "immediateCondition"))) {
[17:01:26.216]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:26.216]                   ...future.conditions[[length(...future.conditions) + 
[17:01:26.216]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:26.216]                   if (TRUE && !signal) {
[17:01:26.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.216]                     {
[17:01:26.216]                       inherits <- base::inherits
[17:01:26.216]                       invokeRestart <- base::invokeRestart
[17:01:26.216]                       is.null <- base::is.null
[17:01:26.216]                       muffled <- FALSE
[17:01:26.216]                       if (inherits(cond, "message")) {
[17:01:26.216]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:26.216]                         if (muffled) 
[17:01:26.216]                           invokeRestart("muffleMessage")
[17:01:26.216]                       }
[17:01:26.216]                       else if (inherits(cond, "warning")) {
[17:01:26.216]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:26.216]                         if (muffled) 
[17:01:26.216]                           invokeRestart("muffleWarning")
[17:01:26.216]                       }
[17:01:26.216]                       else if (inherits(cond, "condition")) {
[17:01:26.216]                         if (!is.null(pattern)) {
[17:01:26.216]                           computeRestarts <- base::computeRestarts
[17:01:26.216]                           grepl <- base::grepl
[17:01:26.216]                           restarts <- computeRestarts(cond)
[17:01:26.216]                           for (restart in restarts) {
[17:01:26.216]                             name <- restart$name
[17:01:26.216]                             if (is.null(name)) 
[17:01:26.216]                               next
[17:01:26.216]                             if (!grepl(pattern, name)) 
[17:01:26.216]                               next
[17:01:26.216]                             invokeRestart(restart)
[17:01:26.216]                             muffled <- TRUE
[17:01:26.216]                             break
[17:01:26.216]                           }
[17:01:26.216]                         }
[17:01:26.216]                       }
[17:01:26.216]                       invisible(muffled)
[17:01:26.216]                     }
[17:01:26.216]                     muffleCondition(cond, pattern = "^muffle")
[17:01:26.216]                   }
[17:01:26.216]                 }
[17:01:26.216]                 else {
[17:01:26.216]                   if (TRUE) {
[17:01:26.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.216]                     {
[17:01:26.216]                       inherits <- base::inherits
[17:01:26.216]                       invokeRestart <- base::invokeRestart
[17:01:26.216]                       is.null <- base::is.null
[17:01:26.216]                       muffled <- FALSE
[17:01:26.216]                       if (inherits(cond, "message")) {
[17:01:26.216]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:26.216]                         if (muffled) 
[17:01:26.216]                           invokeRestart("muffleMessage")
[17:01:26.216]                       }
[17:01:26.216]                       else if (inherits(cond, "warning")) {
[17:01:26.216]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:26.216]                         if (muffled) 
[17:01:26.216]                           invokeRestart("muffleWarning")
[17:01:26.216]                       }
[17:01:26.216]                       else if (inherits(cond, "condition")) {
[17:01:26.216]                         if (!is.null(pattern)) {
[17:01:26.216]                           computeRestarts <- base::computeRestarts
[17:01:26.216]                           grepl <- base::grepl
[17:01:26.216]                           restarts <- computeRestarts(cond)
[17:01:26.216]                           for (restart in restarts) {
[17:01:26.216]                             name <- restart$name
[17:01:26.216]                             if (is.null(name)) 
[17:01:26.216]                               next
[17:01:26.216]                             if (!grepl(pattern, name)) 
[17:01:26.216]                               next
[17:01:26.216]                             invokeRestart(restart)
[17:01:26.216]                             muffled <- TRUE
[17:01:26.216]                             break
[17:01:26.216]                           }
[17:01:26.216]                         }
[17:01:26.216]                       }
[17:01:26.216]                       invisible(muffled)
[17:01:26.216]                     }
[17:01:26.216]                     muffleCondition(cond, pattern = "^muffle")
[17:01:26.216]                   }
[17:01:26.216]                 }
[17:01:26.216]             }
[17:01:26.216]         }))
[17:01:26.216]     }, error = function(ex) {
[17:01:26.216]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:26.216]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:26.216]                 ...future.rng), started = ...future.startTime, 
[17:01:26.216]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:26.216]             version = "1.8"), class = "FutureResult")
[17:01:26.216]     }, finally = {
[17:01:26.216]         if (!identical(...future.workdir, getwd())) 
[17:01:26.216]             setwd(...future.workdir)
[17:01:26.216]         {
[17:01:26.216]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:26.216]                 ...future.oldOptions$nwarnings <- NULL
[17:01:26.216]             }
[17:01:26.216]             base::options(...future.oldOptions)
[17:01:26.216]             if (.Platform$OS.type == "windows") {
[17:01:26.216]                 old_names <- names(...future.oldEnvVars)
[17:01:26.216]                 envs <- base::Sys.getenv()
[17:01:26.216]                 names <- names(envs)
[17:01:26.216]                 common <- intersect(names, old_names)
[17:01:26.216]                 added <- setdiff(names, old_names)
[17:01:26.216]                 removed <- setdiff(old_names, names)
[17:01:26.216]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:26.216]                   envs[common]]
[17:01:26.216]                 NAMES <- toupper(changed)
[17:01:26.216]                 args <- list()
[17:01:26.216]                 for (kk in seq_along(NAMES)) {
[17:01:26.216]                   name <- changed[[kk]]
[17:01:26.216]                   NAME <- NAMES[[kk]]
[17:01:26.216]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.216]                     next
[17:01:26.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:26.216]                 }
[17:01:26.216]                 NAMES <- toupper(added)
[17:01:26.216]                 for (kk in seq_along(NAMES)) {
[17:01:26.216]                   name <- added[[kk]]
[17:01:26.216]                   NAME <- NAMES[[kk]]
[17:01:26.216]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.216]                     next
[17:01:26.216]                   args[[name]] <- ""
[17:01:26.216]                 }
[17:01:26.216]                 NAMES <- toupper(removed)
[17:01:26.216]                 for (kk in seq_along(NAMES)) {
[17:01:26.216]                   name <- removed[[kk]]
[17:01:26.216]                   NAME <- NAMES[[kk]]
[17:01:26.216]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.216]                     next
[17:01:26.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:26.216]                 }
[17:01:26.216]                 if (length(args) > 0) 
[17:01:26.216]                   base::do.call(base::Sys.setenv, args = args)
[17:01:26.216]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:26.216]             }
[17:01:26.216]             else {
[17:01:26.216]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:26.216]             }
[17:01:26.216]             {
[17:01:26.216]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:26.216]                   0L) {
[17:01:26.216]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:26.216]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:26.216]                   base::options(opts)
[17:01:26.216]                 }
[17:01:26.216]                 {
[17:01:26.216]                   {
[17:01:26.216]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:26.216]                     NULL
[17:01:26.216]                   }
[17:01:26.216]                   options(future.plan = NULL)
[17:01:26.216]                   if (is.na(NA_character_)) 
[17:01:26.216]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:26.216]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:26.216]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:26.216]                     .init = FALSE)
[17:01:26.216]                 }
[17:01:26.216]             }
[17:01:26.216]         }
[17:01:26.216]     })
[17:01:26.216]     if (TRUE) {
[17:01:26.216]         base::sink(type = "output", split = FALSE)
[17:01:26.216]         if (TRUE) {
[17:01:26.216]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:26.216]         }
[17:01:26.216]         else {
[17:01:26.216]             ...future.result["stdout"] <- base::list(NULL)
[17:01:26.216]         }
[17:01:26.216]         base::close(...future.stdout)
[17:01:26.216]         ...future.stdout <- NULL
[17:01:26.216]     }
[17:01:26.216]     ...future.result$conditions <- ...future.conditions
[17:01:26.216]     ...future.result$finished <- base::Sys.time()
[17:01:26.216]     ...future.result
[17:01:26.216] }
[17:01:26.219] assign_globals() ...
[17:01:26.219] List of 5
[17:01:26.219]  $ ...future.FUN            :function (x)  
[17:01:26.219]  $ future.call.arguments    : list()
[17:01:26.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:26.219]  $ ...future.elements_ii    :List of 1
[17:01:26.219]   ..$ : int 0
[17:01:26.219]  $ ...future.seeds_ii       : NULL
[17:01:26.219]  $ ...future.globals.maxSize: NULL
[17:01:26.219]  - attr(*, "where")=List of 5
[17:01:26.219]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:26.219]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:26.219]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:26.219]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:26.219]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:26.219]  - attr(*, "resolved")= logi FALSE
[17:01:26.219]  - attr(*, "total_size")= num 4720
[17:01:26.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:26.219]  - attr(*, "already-done")= logi TRUE
[17:01:26.227] - reassign environment for ‘...future.FUN’
[17:01:26.227] - copied ‘...future.FUN’ to environment
[17:01:26.227] - copied ‘future.call.arguments’ to environment
[17:01:26.227] - copied ‘...future.elements_ii’ to environment
[17:01:26.227] - copied ‘...future.seeds_ii’ to environment
[17:01:26.228] - copied ‘...future.globals.maxSize’ to environment
[17:01:26.228] assign_globals() ... done
[17:01:26.228] requestCore(): workers = 2
[17:01:26.230] MulticoreFuture started
[17:01:26.230] - Launch lazy future ... done
[17:01:26.231] run() for ‘MulticoreFuture’ ... done
[17:01:26.231] Created future:
[17:01:26.231] plan(): Setting new future strategy stack:
[17:01:26.232] List of future strategies:
[17:01:26.232] 1. sequential:
[17:01:26.232]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:26.232]    - tweaked: FALSE
[17:01:26.232]    - call: NULL
[17:01:26.233] plan(): nbrOfWorkers() = 1
[17:01:26.235] plan(): Setting new future strategy stack:
[17:01:26.235] List of future strategies:
[17:01:26.235] 1. multicore:
[17:01:26.235]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:26.235]    - tweaked: FALSE
[17:01:26.235]    - call: plan(strategy)
[17:01:26.241] plan(): nbrOfWorkers() = 2
[17:01:26.231] MulticoreFuture:
[17:01:26.231] Label: ‘future_lapply-2’
[17:01:26.231] Expression:
[17:01:26.231] {
[17:01:26.231]     do.call(function(...) {
[17:01:26.231]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.231]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:26.231]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.231]             on.exit(options(oopts), add = TRUE)
[17:01:26.231]         }
[17:01:26.231]         {
[17:01:26.231]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:26.231]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.231]                 ...future.FUN(...future.X_jj, ...)
[17:01:26.231]             })
[17:01:26.231]         }
[17:01:26.231]     }, args = future.call.arguments)
[17:01:26.231] }
[17:01:26.231] Lazy evaluation: FALSE
[17:01:26.231] Asynchronous evaluation: TRUE
[17:01:26.231] Local evaluation: TRUE
[17:01:26.231] Environment: R_GlobalEnv
[17:01:26.231] Capture standard output: TRUE
[17:01:26.231] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:26.231] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:26.231] Packages: <none>
[17:01:26.231] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:26.231] Resolved: TRUE
[17:01:26.231] Value: <not collected>
[17:01:26.231] Conditions captured: <none>
[17:01:26.231] Early signaling: FALSE
[17:01:26.231] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:26.231] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:26.242] Chunk #2 of 2 ... DONE
[17:01:26.242] Launching 2 futures (chunks) ... DONE
[17:01:26.242] Resolving 2 futures (chunks) ...
[17:01:26.242] resolve() on list ...
[17:01:26.242]  recursive: 0
[17:01:26.243]  length: 2
[17:01:26.243] 
[17:01:26.253] Future #2
[17:01:26.254] result() for MulticoreFuture ...
[17:01:26.255] result() for MulticoreFuture ...
[17:01:26.255] result() for MulticoreFuture ... done
[17:01:26.255] result() for MulticoreFuture ... done
[17:01:26.256] result() for MulticoreFuture ...
[17:01:26.256] result() for MulticoreFuture ... done
[17:01:26.256] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:26.256] - nx: 2
[17:01:26.257] - relay: TRUE
[17:01:26.257] - stdout: TRUE
[17:01:26.257] - signal: TRUE
[17:01:26.257] - resignal: FALSE
[17:01:26.257] - force: TRUE
[17:01:26.257] - relayed: [n=2] FALSE, FALSE
[17:01:26.258] - queued futures: [n=2] FALSE, FALSE
[17:01:26.258]  - until=1
[17:01:26.258]  - relaying element #1
[17:01:26.258] - relayed: [n=2] FALSE, FALSE
[17:01:26.258] - queued futures: [n=2] FALSE, TRUE
[17:01:26.259] signalConditionsASAP(NULL, pos=2) ... done
[17:01:26.259]  length: 1 (resolved future 2)
[17:01:26.684] plan(): Setting new future strategy stack:
[17:01:26.684] List of future strategies:
[17:01:26.684] 1. multicore:
[17:01:26.684]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:26.684]    - tweaked: FALSE
[17:01:26.684]    - call: plan(strategy)
[17:01:26.689] plan(): nbrOfWorkers() = 2
[17:01:26.700] Future #1
[17:01:26.700] result() for MulticoreFuture ...
[17:01:26.701] result() for MulticoreFuture ...
[17:01:26.701] result() for MulticoreFuture ... done
[17:01:26.701] result() for MulticoreFuture ... done
[17:01:26.701] result() for MulticoreFuture ...
[17:01:26.701] result() for MulticoreFuture ... done
[17:01:26.701] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:26.701] - nx: 2
[17:01:26.702] - relay: TRUE
[17:01:26.702] - stdout: TRUE
[17:01:26.702] - signal: TRUE
[17:01:26.702] - resignal: FALSE
[17:01:26.702] - force: TRUE
[17:01:26.702] - relayed: [n=2] FALSE, FALSE
[17:01:26.702] - queued futures: [n=2] FALSE, TRUE
[17:01:26.702]  - until=1
[17:01:26.702]  - relaying element #1
[17:01:26.703] result() for MulticoreFuture ...
[17:01:26.703] result() for MulticoreFuture ... done
[17:01:26.703] result() for MulticoreFuture ...
[17:01:26.703] result() for MulticoreFuture ... done
[17:01:26.703] result() for MulticoreFuture ...
[17:01:26.703] result() for MulticoreFuture ... done
[17:01:26.703] result() for MulticoreFuture ...
[17:01:26.704] result() for MulticoreFuture ... done
[17:01:26.704] - relayed: [n=2] TRUE, FALSE
[17:01:26.704] - queued futures: [n=2] TRUE, TRUE
[17:01:26.704] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:26.704]  length: 0 (resolved future 1)
[17:01:26.704] Relaying remaining futures
[17:01:26.704] signalConditionsASAP(NULL, pos=0) ...
[17:01:26.705] - nx: 2
[17:01:26.705] - relay: TRUE
[17:01:26.705] - stdout: TRUE
[17:01:26.705] - signal: TRUE
[17:01:26.705] - resignal: FALSE
[17:01:26.705] - force: TRUE
[17:01:26.705] - relayed: [n=2] TRUE, FALSE
[17:01:26.705] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:26.705]  - relaying element #2
[17:01:26.706] result() for MulticoreFuture ...
[17:01:26.706] result() for MulticoreFuture ... done
[17:01:26.706] result() for MulticoreFuture ...
[17:01:26.706] result() for MulticoreFuture ... done
[17:01:26.706] result() for MulticoreFuture ...
[17:01:26.706] result() for MulticoreFuture ... done
[17:01:26.706] result() for MulticoreFuture ...
[17:01:26.709] result() for MulticoreFuture ... done
[17:01:26.709] - relayed: [n=2] TRUE, TRUE
[17:01:26.709] - queued futures: [n=2] TRUE, TRUE
[17:01:26.709] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:01:26.709] resolve() on list ... DONE
[17:01:26.710] result() for MulticoreFuture ...
[17:01:26.710] result() for MulticoreFuture ... done
[17:01:26.710] result() for MulticoreFuture ...
[17:01:26.710] result() for MulticoreFuture ... done
[17:01:26.710] result() for MulticoreFuture ...
[17:01:26.710] result() for MulticoreFuture ... done
[17:01:26.711] result() for MulticoreFuture ...
[17:01:26.711] result() for MulticoreFuture ... done
[17:01:26.711]  - Number of value chunks collected: 2
[17:01:26.711] Resolving 2 futures (chunks) ... DONE
[17:01:26.711] Reducing values from 2 chunks ...
[17:01:26.711]  - Number of values collected after concatenation: 2
[17:01:26.712]  - Number of values expected: 2
[17:01:26.712] Reducing values from 2 chunks ... DONE
[17:01:26.712] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:01:26.712] future_lapply() ...
[17:01:26.718] Number of chunks: 2
[17:01:26.718] getGlobalsAndPackagesXApply() ...
[17:01:26.718]  - future.globals: TRUE
[17:01:26.718] getGlobalsAndPackages() ...
[17:01:26.718] Searching for globals...
[17:01:26.720] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:26.720] Searching for globals ... DONE
[17:01:26.720] Resolving globals: FALSE
[17:01:26.721] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:26.721] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:26.721] - globals: [1] ‘FUN’
[17:01:26.721] 
[17:01:26.721] getGlobalsAndPackages() ... DONE
[17:01:26.722]  - globals found/used: [n=1] ‘FUN’
[17:01:26.722]  - needed namespaces: [n=0] 
[17:01:26.722] Finding globals ... DONE
[17:01:26.722]  - use_args: TRUE
[17:01:26.722]  - Getting '...' globals ...
[17:01:26.722] resolve() on list ...
[17:01:26.722]  recursive: 0
[17:01:26.723]  length: 1
[17:01:26.723]  elements: ‘...’
[17:01:26.723]  length: 0 (resolved future 1)
[17:01:26.723] resolve() on list ... DONE
[17:01:26.723]    - '...' content: [n=0] 
[17:01:26.723] List of 1
[17:01:26.723]  $ ...: list()
[17:01:26.723]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:26.723]  - attr(*, "where")=List of 1
[17:01:26.723]   ..$ ...:<environment: 0x5636f60b1018> 
[17:01:26.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:26.723]  - attr(*, "resolved")= logi TRUE
[17:01:26.723]  - attr(*, "total_size")= num NA
[17:01:26.726]  - Getting '...' globals ... DONE
[17:01:26.726] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:26.726] List of 2
[17:01:26.726]  $ ...future.FUN:function (x)  
[17:01:26.726]  $ ...          : list()
[17:01:26.726]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:26.726]  - attr(*, "where")=List of 2
[17:01:26.726]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:26.726]   ..$ ...          :<environment: 0x5636f60b1018> 
[17:01:26.726]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:26.726]  - attr(*, "resolved")= logi FALSE
[17:01:26.726]  - attr(*, "total_size")= num 4720
[17:01:26.729] Packages to be attached in all futures: [n=0] 
[17:01:26.729] getGlobalsAndPackagesXApply() ... DONE
[17:01:26.729] Number of futures (= number of chunks): 2
[17:01:26.730] Launching 2 futures (chunks) ...
[17:01:26.730] Chunk #1 of 2 ...
[17:01:26.730]  - Finding globals in 'X' for chunk #1 ...
[17:01:26.730] getGlobalsAndPackages() ...
[17:01:26.730] Searching for globals...
[17:01:26.730] 
[17:01:26.730] Searching for globals ... DONE
[17:01:26.730] - globals: [0] <none>
[17:01:26.731] getGlobalsAndPackages() ... DONE
[17:01:26.731]    + additional globals found: [n=0] 
[17:01:26.731]    + additional namespaces needed: [n=0] 
[17:01:26.731]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:26.731]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:26.731]  - seeds: <none>
[17:01:26.731]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.731] getGlobalsAndPackages() ...
[17:01:26.731] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.731] Resolving globals: FALSE
[17:01:26.732] Tweak future expression to call with '...' arguments ...
[17:01:26.732] {
[17:01:26.732]     do.call(function(...) {
[17:01:26.732]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.732]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:26.732]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.732]             on.exit(options(oopts), add = TRUE)
[17:01:26.732]         }
[17:01:26.732]         {
[17:01:26.732]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:26.732]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.732]                 ...future.FUN(...future.X_jj, ...)
[17:01:26.732]             })
[17:01:26.732]         }
[17:01:26.732]     }, args = future.call.arguments)
[17:01:26.732] }
[17:01:26.732] Tweak future expression to call with '...' arguments ... DONE
[17:01:26.732] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.732] 
[17:01:26.732] getGlobalsAndPackages() ... DONE
[17:01:26.733] run() for ‘Future’ ...
[17:01:26.733] - state: ‘created’
[17:01:26.733] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:26.737] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:26.737] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:26.737]   - Field: ‘label’
[17:01:26.737]   - Field: ‘local’
[17:01:26.737]   - Field: ‘owner’
[17:01:26.738]   - Field: ‘envir’
[17:01:26.738]   - Field: ‘workers’
[17:01:26.738]   - Field: ‘packages’
[17:01:26.738]   - Field: ‘gc’
[17:01:26.738]   - Field: ‘job’
[17:01:26.738]   - Field: ‘conditions’
[17:01:26.738]   - Field: ‘expr’
[17:01:26.738]   - Field: ‘uuid’
[17:01:26.738]   - Field: ‘seed’
[17:01:26.738]   - Field: ‘version’
[17:01:26.738]   - Field: ‘result’
[17:01:26.739]   - Field: ‘asynchronous’
[17:01:26.739]   - Field: ‘calls’
[17:01:26.739]   - Field: ‘globals’
[17:01:26.739]   - Field: ‘stdout’
[17:01:26.739]   - Field: ‘earlySignal’
[17:01:26.739]   - Field: ‘lazy’
[17:01:26.739]   - Field: ‘state’
[17:01:26.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:26.739] - Launch lazy future ...
[17:01:26.740] Packages needed by the future expression (n = 0): <none>
[17:01:26.740] Packages needed by future strategies (n = 0): <none>
[17:01:26.742] {
[17:01:26.742]     {
[17:01:26.742]         {
[17:01:26.742]             ...future.startTime <- base::Sys.time()
[17:01:26.742]             {
[17:01:26.742]                 {
[17:01:26.742]                   {
[17:01:26.742]                     {
[17:01:26.742]                       base::local({
[17:01:26.742]                         has_future <- base::requireNamespace("future", 
[17:01:26.742]                           quietly = TRUE)
[17:01:26.742]                         if (has_future) {
[17:01:26.742]                           ns <- base::getNamespace("future")
[17:01:26.742]                           version <- ns[[".package"]][["version"]]
[17:01:26.742]                           if (is.null(version)) 
[17:01:26.742]                             version <- utils::packageVersion("future")
[17:01:26.742]                         }
[17:01:26.742]                         else {
[17:01:26.742]                           version <- NULL
[17:01:26.742]                         }
[17:01:26.742]                         if (!has_future || version < "1.8.0") {
[17:01:26.742]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:26.742]                             "", base::R.version$version.string), 
[17:01:26.742]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:26.742]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:26.742]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:26.742]                               "release", "version")], collapse = " "), 
[17:01:26.742]                             hostname = base::Sys.info()[["nodename"]])
[17:01:26.742]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:26.742]                             info)
[17:01:26.742]                           info <- base::paste(info, collapse = "; ")
[17:01:26.742]                           if (!has_future) {
[17:01:26.742]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:26.742]                               info)
[17:01:26.742]                           }
[17:01:26.742]                           else {
[17:01:26.742]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:26.742]                               info, version)
[17:01:26.742]                           }
[17:01:26.742]                           base::stop(msg)
[17:01:26.742]                         }
[17:01:26.742]                       })
[17:01:26.742]                     }
[17:01:26.742]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:26.742]                     base::options(mc.cores = 1L)
[17:01:26.742]                   }
[17:01:26.742]                   ...future.strategy.old <- future::plan("list")
[17:01:26.742]                   options(future.plan = NULL)
[17:01:26.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:26.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:26.742]                 }
[17:01:26.742]                 ...future.workdir <- getwd()
[17:01:26.742]             }
[17:01:26.742]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:26.742]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:26.742]         }
[17:01:26.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:26.742]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:26.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:26.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:26.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:26.742]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:26.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:26.742]             base::names(...future.oldOptions))
[17:01:26.742]     }
[17:01:26.742]     if (TRUE) {
[17:01:26.742]     }
[17:01:26.742]     else {
[17:01:26.742]         if (NA) {
[17:01:26.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:26.742]                 open = "w")
[17:01:26.742]         }
[17:01:26.742]         else {
[17:01:26.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:26.742]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:26.742]         }
[17:01:26.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:26.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:26.742]             base::sink(type = "output", split = FALSE)
[17:01:26.742]             base::close(...future.stdout)
[17:01:26.742]         }, add = TRUE)
[17:01:26.742]     }
[17:01:26.742]     ...future.frame <- base::sys.nframe()
[17:01:26.742]     ...future.conditions <- base::list()
[17:01:26.742]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:26.742]     if (FALSE) {
[17:01:26.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:26.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:26.742]     }
[17:01:26.742]     ...future.result <- base::tryCatch({
[17:01:26.742]         base::withCallingHandlers({
[17:01:26.742]             ...future.value <- base::withVisible(base::local({
[17:01:26.742]                 withCallingHandlers({
[17:01:26.742]                   {
[17:01:26.742]                     do.call(function(...) {
[17:01:26.742]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.742]                       if (!identical(...future.globals.maxSize.org, 
[17:01:26.742]                         ...future.globals.maxSize)) {
[17:01:26.742]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.742]                         on.exit(options(oopts), add = TRUE)
[17:01:26.742]                       }
[17:01:26.742]                       {
[17:01:26.742]                         lapply(seq_along(...future.elements_ii), 
[17:01:26.742]                           FUN = function(jj) {
[17:01:26.742]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.742]                             ...future.FUN(...future.X_jj, ...)
[17:01:26.742]                           })
[17:01:26.742]                       }
[17:01:26.742]                     }, args = future.call.arguments)
[17:01:26.742]                   }
[17:01:26.742]                 }, immediateCondition = function(cond) {
[17:01:26.742]                   save_rds <- function (object, pathname, ...) 
[17:01:26.742]                   {
[17:01:26.742]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:26.742]                     if (file_test("-f", pathname_tmp)) {
[17:01:26.742]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.742]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:26.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.742]                         fi_tmp[["mtime"]])
[17:01:26.742]                     }
[17:01:26.742]                     tryCatch({
[17:01:26.742]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:26.742]                     }, error = function(ex) {
[17:01:26.742]                       msg <- conditionMessage(ex)
[17:01:26.742]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.742]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:26.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.742]                         fi_tmp[["mtime"]], msg)
[17:01:26.742]                       ex$message <- msg
[17:01:26.742]                       stop(ex)
[17:01:26.742]                     })
[17:01:26.742]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:26.742]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:26.742]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:26.742]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.742]                       fi <- file.info(pathname)
[17:01:26.742]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:26.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.742]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:26.742]                         fi[["size"]], fi[["mtime"]])
[17:01:26.742]                       stop(msg)
[17:01:26.742]                     }
[17:01:26.742]                     invisible(pathname)
[17:01:26.742]                   }
[17:01:26.742]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:26.742]                     rootPath = tempdir()) 
[17:01:26.742]                   {
[17:01:26.742]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:26.742]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:26.742]                       tmpdir = path, fileext = ".rds")
[17:01:26.742]                     save_rds(obj, file)
[17:01:26.742]                   }
[17:01:26.742]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:26.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.742]                   {
[17:01:26.742]                     inherits <- base::inherits
[17:01:26.742]                     invokeRestart <- base::invokeRestart
[17:01:26.742]                     is.null <- base::is.null
[17:01:26.742]                     muffled <- FALSE
[17:01:26.742]                     if (inherits(cond, "message")) {
[17:01:26.742]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:26.742]                       if (muffled) 
[17:01:26.742]                         invokeRestart("muffleMessage")
[17:01:26.742]                     }
[17:01:26.742]                     else if (inherits(cond, "warning")) {
[17:01:26.742]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:26.742]                       if (muffled) 
[17:01:26.742]                         invokeRestart("muffleWarning")
[17:01:26.742]                     }
[17:01:26.742]                     else if (inherits(cond, "condition")) {
[17:01:26.742]                       if (!is.null(pattern)) {
[17:01:26.742]                         computeRestarts <- base::computeRestarts
[17:01:26.742]                         grepl <- base::grepl
[17:01:26.742]                         restarts <- computeRestarts(cond)
[17:01:26.742]                         for (restart in restarts) {
[17:01:26.742]                           name <- restart$name
[17:01:26.742]                           if (is.null(name)) 
[17:01:26.742]                             next
[17:01:26.742]                           if (!grepl(pattern, name)) 
[17:01:26.742]                             next
[17:01:26.742]                           invokeRestart(restart)
[17:01:26.742]                           muffled <- TRUE
[17:01:26.742]                           break
[17:01:26.742]                         }
[17:01:26.742]                       }
[17:01:26.742]                     }
[17:01:26.742]                     invisible(muffled)
[17:01:26.742]                   }
[17:01:26.742]                   muffleCondition(cond)
[17:01:26.742]                 })
[17:01:26.742]             }))
[17:01:26.742]             future::FutureResult(value = ...future.value$value, 
[17:01:26.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:26.742]                   ...future.rng), globalenv = if (FALSE) 
[17:01:26.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:26.742]                     ...future.globalenv.names))
[17:01:26.742]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:26.742]         }, condition = base::local({
[17:01:26.742]             c <- base::c
[17:01:26.742]             inherits <- base::inherits
[17:01:26.742]             invokeRestart <- base::invokeRestart
[17:01:26.742]             length <- base::length
[17:01:26.742]             list <- base::list
[17:01:26.742]             seq.int <- base::seq.int
[17:01:26.742]             signalCondition <- base::signalCondition
[17:01:26.742]             sys.calls <- base::sys.calls
[17:01:26.742]             `[[` <- base::`[[`
[17:01:26.742]             `+` <- base::`+`
[17:01:26.742]             `<<-` <- base::`<<-`
[17:01:26.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:26.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:26.742]                   3L)]
[17:01:26.742]             }
[17:01:26.742]             function(cond) {
[17:01:26.742]                 is_error <- inherits(cond, "error")
[17:01:26.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:26.742]                   NULL)
[17:01:26.742]                 if (is_error) {
[17:01:26.742]                   sessionInformation <- function() {
[17:01:26.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:26.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:26.742]                       search = base::search(), system = base::Sys.info())
[17:01:26.742]                   }
[17:01:26.742]                   ...future.conditions[[length(...future.conditions) + 
[17:01:26.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:26.742]                     cond$call), session = sessionInformation(), 
[17:01:26.742]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:26.742]                   signalCondition(cond)
[17:01:26.742]                 }
[17:01:26.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:26.742]                 "immediateCondition"))) {
[17:01:26.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:26.742]                   ...future.conditions[[length(...future.conditions) + 
[17:01:26.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:26.742]                   if (TRUE && !signal) {
[17:01:26.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.742]                     {
[17:01:26.742]                       inherits <- base::inherits
[17:01:26.742]                       invokeRestart <- base::invokeRestart
[17:01:26.742]                       is.null <- base::is.null
[17:01:26.742]                       muffled <- FALSE
[17:01:26.742]                       if (inherits(cond, "message")) {
[17:01:26.742]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:26.742]                         if (muffled) 
[17:01:26.742]                           invokeRestart("muffleMessage")
[17:01:26.742]                       }
[17:01:26.742]                       else if (inherits(cond, "warning")) {
[17:01:26.742]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:26.742]                         if (muffled) 
[17:01:26.742]                           invokeRestart("muffleWarning")
[17:01:26.742]                       }
[17:01:26.742]                       else if (inherits(cond, "condition")) {
[17:01:26.742]                         if (!is.null(pattern)) {
[17:01:26.742]                           computeRestarts <- base::computeRestarts
[17:01:26.742]                           grepl <- base::grepl
[17:01:26.742]                           restarts <- computeRestarts(cond)
[17:01:26.742]                           for (restart in restarts) {
[17:01:26.742]                             name <- restart$name
[17:01:26.742]                             if (is.null(name)) 
[17:01:26.742]                               next
[17:01:26.742]                             if (!grepl(pattern, name)) 
[17:01:26.742]                               next
[17:01:26.742]                             invokeRestart(restart)
[17:01:26.742]                             muffled <- TRUE
[17:01:26.742]                             break
[17:01:26.742]                           }
[17:01:26.742]                         }
[17:01:26.742]                       }
[17:01:26.742]                       invisible(muffled)
[17:01:26.742]                     }
[17:01:26.742]                     muffleCondition(cond, pattern = "^muffle")
[17:01:26.742]                   }
[17:01:26.742]                 }
[17:01:26.742]                 else {
[17:01:26.742]                   if (TRUE) {
[17:01:26.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.742]                     {
[17:01:26.742]                       inherits <- base::inherits
[17:01:26.742]                       invokeRestart <- base::invokeRestart
[17:01:26.742]                       is.null <- base::is.null
[17:01:26.742]                       muffled <- FALSE
[17:01:26.742]                       if (inherits(cond, "message")) {
[17:01:26.742]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:26.742]                         if (muffled) 
[17:01:26.742]                           invokeRestart("muffleMessage")
[17:01:26.742]                       }
[17:01:26.742]                       else if (inherits(cond, "warning")) {
[17:01:26.742]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:26.742]                         if (muffled) 
[17:01:26.742]                           invokeRestart("muffleWarning")
[17:01:26.742]                       }
[17:01:26.742]                       else if (inherits(cond, "condition")) {
[17:01:26.742]                         if (!is.null(pattern)) {
[17:01:26.742]                           computeRestarts <- base::computeRestarts
[17:01:26.742]                           grepl <- base::grepl
[17:01:26.742]                           restarts <- computeRestarts(cond)
[17:01:26.742]                           for (restart in restarts) {
[17:01:26.742]                             name <- restart$name
[17:01:26.742]                             if (is.null(name)) 
[17:01:26.742]                               next
[17:01:26.742]                             if (!grepl(pattern, name)) 
[17:01:26.742]                               next
[17:01:26.742]                             invokeRestart(restart)
[17:01:26.742]                             muffled <- TRUE
[17:01:26.742]                             break
[17:01:26.742]                           }
[17:01:26.742]                         }
[17:01:26.742]                       }
[17:01:26.742]                       invisible(muffled)
[17:01:26.742]                     }
[17:01:26.742]                     muffleCondition(cond, pattern = "^muffle")
[17:01:26.742]                   }
[17:01:26.742]                 }
[17:01:26.742]             }
[17:01:26.742]         }))
[17:01:26.742]     }, error = function(ex) {
[17:01:26.742]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:26.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:26.742]                 ...future.rng), started = ...future.startTime, 
[17:01:26.742]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:26.742]             version = "1.8"), class = "FutureResult")
[17:01:26.742]     }, finally = {
[17:01:26.742]         if (!identical(...future.workdir, getwd())) 
[17:01:26.742]             setwd(...future.workdir)
[17:01:26.742]         {
[17:01:26.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:26.742]                 ...future.oldOptions$nwarnings <- NULL
[17:01:26.742]             }
[17:01:26.742]             base::options(...future.oldOptions)
[17:01:26.742]             if (.Platform$OS.type == "windows") {
[17:01:26.742]                 old_names <- names(...future.oldEnvVars)
[17:01:26.742]                 envs <- base::Sys.getenv()
[17:01:26.742]                 names <- names(envs)
[17:01:26.742]                 common <- intersect(names, old_names)
[17:01:26.742]                 added <- setdiff(names, old_names)
[17:01:26.742]                 removed <- setdiff(old_names, names)
[17:01:26.742]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:26.742]                   envs[common]]
[17:01:26.742]                 NAMES <- toupper(changed)
[17:01:26.742]                 args <- list()
[17:01:26.742]                 for (kk in seq_along(NAMES)) {
[17:01:26.742]                   name <- changed[[kk]]
[17:01:26.742]                   NAME <- NAMES[[kk]]
[17:01:26.742]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.742]                     next
[17:01:26.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:26.742]                 }
[17:01:26.742]                 NAMES <- toupper(added)
[17:01:26.742]                 for (kk in seq_along(NAMES)) {
[17:01:26.742]                   name <- added[[kk]]
[17:01:26.742]                   NAME <- NAMES[[kk]]
[17:01:26.742]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.742]                     next
[17:01:26.742]                   args[[name]] <- ""
[17:01:26.742]                 }
[17:01:26.742]                 NAMES <- toupper(removed)
[17:01:26.742]                 for (kk in seq_along(NAMES)) {
[17:01:26.742]                   name <- removed[[kk]]
[17:01:26.742]                   NAME <- NAMES[[kk]]
[17:01:26.742]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.742]                     next
[17:01:26.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:26.742]                 }
[17:01:26.742]                 if (length(args) > 0) 
[17:01:26.742]                   base::do.call(base::Sys.setenv, args = args)
[17:01:26.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:26.742]             }
[17:01:26.742]             else {
[17:01:26.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:26.742]             }
[17:01:26.742]             {
[17:01:26.742]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:26.742]                   0L) {
[17:01:26.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:26.742]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:26.742]                   base::options(opts)
[17:01:26.742]                 }
[17:01:26.742]                 {
[17:01:26.742]                   {
[17:01:26.742]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:26.742]                     NULL
[17:01:26.742]                   }
[17:01:26.742]                   options(future.plan = NULL)
[17:01:26.742]                   if (is.na(NA_character_)) 
[17:01:26.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:26.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:26.742]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:26.742]                     .init = FALSE)
[17:01:26.742]                 }
[17:01:26.742]             }
[17:01:26.742]         }
[17:01:26.742]     })
[17:01:26.742]     if (FALSE) {
[17:01:26.742]         base::sink(type = "output", split = FALSE)
[17:01:26.742]         if (NA) {
[17:01:26.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:26.742]         }
[17:01:26.742]         else {
[17:01:26.742]             ...future.result["stdout"] <- base::list(NULL)
[17:01:26.742]         }
[17:01:26.742]         base::close(...future.stdout)
[17:01:26.742]         ...future.stdout <- NULL
[17:01:26.742]     }
[17:01:26.742]     ...future.result$conditions <- ...future.conditions
[17:01:26.742]     ...future.result$finished <- base::Sys.time()
[17:01:26.742]     ...future.result
[17:01:26.742] }
[17:01:26.744] assign_globals() ...
[17:01:26.744] List of 5
[17:01:26.744]  $ ...future.FUN            :function (x)  
[17:01:26.744]  $ future.call.arguments    : list()
[17:01:26.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:26.744]  $ ...future.elements_ii    :List of 1
[17:01:26.744]   ..$ : int 1
[17:01:26.744]  $ ...future.seeds_ii       : NULL
[17:01:26.744]  $ ...future.globals.maxSize: NULL
[17:01:26.744]  - attr(*, "where")=List of 5
[17:01:26.744]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:26.744]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:26.744]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:26.744]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:26.744]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:26.744]  - attr(*, "resolved")= logi FALSE
[17:01:26.744]  - attr(*, "total_size")= num 4720
[17:01:26.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:26.744]  - attr(*, "already-done")= logi TRUE
[17:01:26.749] - reassign environment for ‘...future.FUN’
[17:01:26.750] - copied ‘...future.FUN’ to environment
[17:01:26.750] - copied ‘future.call.arguments’ to environment
[17:01:26.750] - copied ‘...future.elements_ii’ to environment
[17:01:26.750] - copied ‘...future.seeds_ii’ to environment
[17:01:26.750] - copied ‘...future.globals.maxSize’ to environment
[17:01:26.750] assign_globals() ... done
[17:01:26.750] requestCore(): workers = 2
[17:01:26.752] MulticoreFuture started
[17:01:26.753] - Launch lazy future ... done
[17:01:26.753] run() for ‘MulticoreFuture’ ... done
[17:01:26.753] Created future:
[17:01:26.753] plan(): Setting new future strategy stack:
[17:01:26.754] List of future strategies:
[17:01:26.754] 1. sequential:
[17:01:26.754]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:26.754]    - tweaked: FALSE
[17:01:26.754]    - call: NULL
[17:01:26.755] plan(): nbrOfWorkers() = 1
[17:01:26.754] MulticoreFuture:
[17:01:26.754] Label: ‘future_lapply-1’
[17:01:26.754] Expression:
[17:01:26.754] {
[17:01:26.754]     do.call(function(...) {
[17:01:26.754]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.754]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:26.754]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.754]             on.exit(options(oopts), add = TRUE)
[17:01:26.754]         }
[17:01:26.754]         {
[17:01:26.754]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:26.754]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.754]                 ...future.FUN(...future.X_jj, ...)
[17:01:26.754]             })
[17:01:26.754]         }
[17:01:26.754]     }, args = future.call.arguments)
[17:01:26.754] }
[17:01:26.754] Lazy evaluation: FALSE
[17:01:26.754] Asynchronous evaluation: TRUE
[17:01:26.754] Local evaluation: TRUE
[17:01:26.754] Environment: R_GlobalEnv
[17:01:26.754] Capture standard output: NA
[17:01:26.754] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:26.754] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:26.754] Packages: <none>
[17:01:26.754] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:26.754] Resolved: FALSE
[17:01:26.754] Value: <not collected>
[17:01:26.754] Conditions captured: <none>
[17:01:26.754] Early signaling: FALSE
[17:01:26.754] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:26.754] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:26.767] Chunk #1 of 2 ... DONE
[17:01:26.767] Chunk #2 of 2 ...
[17:01:26.767]  - Finding globals in 'X' for chunk #2 ...
[17:01:26.767] getGlobalsAndPackages() ...
[17:01:26.767] Searching for globals...
[17:01:26.768] 
[17:01:26.768] Searching for globals ... DONE
[17:01:26.768] - globals: [0] <none>
[17:01:26.769] getGlobalsAndPackages() ... DONE
[17:01:26.769]    + additional globals found: [n=0] 
[17:01:26.769]    + additional namespaces needed: [n=0] 
[17:01:26.769]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:26.769]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:26.769]  - seeds: <none>
[17:01:26.770]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.770] getGlobalsAndPackages() ...
[17:01:26.770] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.770] Resolving globals: FALSE
[17:01:26.770] Tweak future expression to call with '...' arguments ...
[17:01:26.770] {
[17:01:26.770]     do.call(function(...) {
[17:01:26.770]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.770]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:26.770]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.770]             on.exit(options(oopts), add = TRUE)
[17:01:26.770]         }
[17:01:26.770]         {
[17:01:26.770]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:26.770]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.770]                 ...future.FUN(...future.X_jj, ...)
[17:01:26.770]             })
[17:01:26.770]         }
[17:01:26.770]     }, args = future.call.arguments)
[17:01:26.770] }
[17:01:26.771] Tweak future expression to call with '...' arguments ... DONE
[17:01:26.772] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:26.772] 
[17:01:26.772] getGlobalsAndPackages() ... DONE
[17:01:26.773] run() for ‘Future’ ...
[17:01:26.773] - state: ‘created’
[17:01:26.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:26.778] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:26.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:26.778]   - Field: ‘label’
[17:01:26.779]   - Field: ‘local’
[17:01:26.779]   - Field: ‘owner’
[17:01:26.779]   - Field: ‘envir’
[17:01:26.779]   - Field: ‘workers’
[17:01:26.779]   - Field: ‘packages’
[17:01:26.780]   - Field: ‘gc’
[17:01:26.780]   - Field: ‘job’
[17:01:26.780]   - Field: ‘conditions’
[17:01:26.780]   - Field: ‘expr’
[17:01:26.781]   - Field: ‘uuid’
[17:01:26.781]   - Field: ‘seed’
[17:01:26.781]   - Field: ‘version’
[17:01:26.781]   - Field: ‘result’
[17:01:26.781]   - Field: ‘asynchronous’
[17:01:26.782]   - Field: ‘calls’
[17:01:26.782]   - Field: ‘globals’
[17:01:26.782]   - Field: ‘stdout’
[17:01:26.782]   - Field: ‘earlySignal’
[17:01:26.782]   - Field: ‘lazy’
[17:01:26.783]   - Field: ‘state’
[17:01:26.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:26.783] - Launch lazy future ...
[17:01:26.784] Packages needed by the future expression (n = 0): <none>
[17:01:26.784] Packages needed by future strategies (n = 0): <none>
[17:01:26.785] {
[17:01:26.785]     {
[17:01:26.785]         {
[17:01:26.785]             ...future.startTime <- base::Sys.time()
[17:01:26.785]             {
[17:01:26.785]                 {
[17:01:26.785]                   {
[17:01:26.785]                     {
[17:01:26.785]                       base::local({
[17:01:26.785]                         has_future <- base::requireNamespace("future", 
[17:01:26.785]                           quietly = TRUE)
[17:01:26.785]                         if (has_future) {
[17:01:26.785]                           ns <- base::getNamespace("future")
[17:01:26.785]                           version <- ns[[".package"]][["version"]]
[17:01:26.785]                           if (is.null(version)) 
[17:01:26.785]                             version <- utils::packageVersion("future")
[17:01:26.785]                         }
[17:01:26.785]                         else {
[17:01:26.785]                           version <- NULL
[17:01:26.785]                         }
[17:01:26.785]                         if (!has_future || version < "1.8.0") {
[17:01:26.785]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:26.785]                             "", base::R.version$version.string), 
[17:01:26.785]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:26.785]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:26.785]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:26.785]                               "release", "version")], collapse = " "), 
[17:01:26.785]                             hostname = base::Sys.info()[["nodename"]])
[17:01:26.785]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:26.785]                             info)
[17:01:26.785]                           info <- base::paste(info, collapse = "; ")
[17:01:26.785]                           if (!has_future) {
[17:01:26.785]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:26.785]                               info)
[17:01:26.785]                           }
[17:01:26.785]                           else {
[17:01:26.785]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:26.785]                               info, version)
[17:01:26.785]                           }
[17:01:26.785]                           base::stop(msg)
[17:01:26.785]                         }
[17:01:26.785]                       })
[17:01:26.785]                     }
[17:01:26.785]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:26.785]                     base::options(mc.cores = 1L)
[17:01:26.785]                   }
[17:01:26.785]                   ...future.strategy.old <- future::plan("list")
[17:01:26.785]                   options(future.plan = NULL)
[17:01:26.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:26.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:26.785]                 }
[17:01:26.785]                 ...future.workdir <- getwd()
[17:01:26.785]             }
[17:01:26.785]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:26.785]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:26.785]         }
[17:01:26.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:26.785]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:26.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:26.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:26.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:26.785]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:26.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:26.785]             base::names(...future.oldOptions))
[17:01:26.785]     }
[17:01:26.785]     if (TRUE) {
[17:01:26.785]     }
[17:01:26.785]     else {
[17:01:26.785]         if (NA) {
[17:01:26.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:26.785]                 open = "w")
[17:01:26.785]         }
[17:01:26.785]         else {
[17:01:26.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:26.785]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:26.785]         }
[17:01:26.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:26.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:26.785]             base::sink(type = "output", split = FALSE)
[17:01:26.785]             base::close(...future.stdout)
[17:01:26.785]         }, add = TRUE)
[17:01:26.785]     }
[17:01:26.785]     ...future.frame <- base::sys.nframe()
[17:01:26.785]     ...future.conditions <- base::list()
[17:01:26.785]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:26.785]     if (FALSE) {
[17:01:26.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:26.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:26.785]     }
[17:01:26.785]     ...future.result <- base::tryCatch({
[17:01:26.785]         base::withCallingHandlers({
[17:01:26.785]             ...future.value <- base::withVisible(base::local({
[17:01:26.785]                 withCallingHandlers({
[17:01:26.785]                   {
[17:01:26.785]                     do.call(function(...) {
[17:01:26.785]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.785]                       if (!identical(...future.globals.maxSize.org, 
[17:01:26.785]                         ...future.globals.maxSize)) {
[17:01:26.785]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.785]                         on.exit(options(oopts), add = TRUE)
[17:01:26.785]                       }
[17:01:26.785]                       {
[17:01:26.785]                         lapply(seq_along(...future.elements_ii), 
[17:01:26.785]                           FUN = function(jj) {
[17:01:26.785]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.785]                             ...future.FUN(...future.X_jj, ...)
[17:01:26.785]                           })
[17:01:26.785]                       }
[17:01:26.785]                     }, args = future.call.arguments)
[17:01:26.785]                   }
[17:01:26.785]                 }, immediateCondition = function(cond) {
[17:01:26.785]                   save_rds <- function (object, pathname, ...) 
[17:01:26.785]                   {
[17:01:26.785]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:26.785]                     if (file_test("-f", pathname_tmp)) {
[17:01:26.785]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.785]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:26.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.785]                         fi_tmp[["mtime"]])
[17:01:26.785]                     }
[17:01:26.785]                     tryCatch({
[17:01:26.785]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:26.785]                     }, error = function(ex) {
[17:01:26.785]                       msg <- conditionMessage(ex)
[17:01:26.785]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.785]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:26.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.785]                         fi_tmp[["mtime"]], msg)
[17:01:26.785]                       ex$message <- msg
[17:01:26.785]                       stop(ex)
[17:01:26.785]                     })
[17:01:26.785]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:26.785]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:26.785]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:26.785]                       fi_tmp <- file.info(pathname_tmp)
[17:01:26.785]                       fi <- file.info(pathname)
[17:01:26.785]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:26.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:26.785]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:26.785]                         fi[["size"]], fi[["mtime"]])
[17:01:26.785]                       stop(msg)
[17:01:26.785]                     }
[17:01:26.785]                     invisible(pathname)
[17:01:26.785]                   }
[17:01:26.785]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:26.785]                     rootPath = tempdir()) 
[17:01:26.785]                   {
[17:01:26.785]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:26.785]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:26.785]                       tmpdir = path, fileext = ".rds")
[17:01:26.785]                     save_rds(obj, file)
[17:01:26.785]                   }
[17:01:26.785]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:26.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.785]                   {
[17:01:26.785]                     inherits <- base::inherits
[17:01:26.785]                     invokeRestart <- base::invokeRestart
[17:01:26.785]                     is.null <- base::is.null
[17:01:26.785]                     muffled <- FALSE
[17:01:26.785]                     if (inherits(cond, "message")) {
[17:01:26.785]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:26.785]                       if (muffled) 
[17:01:26.785]                         invokeRestart("muffleMessage")
[17:01:26.785]                     }
[17:01:26.785]                     else if (inherits(cond, "warning")) {
[17:01:26.785]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:26.785]                       if (muffled) 
[17:01:26.785]                         invokeRestart("muffleWarning")
[17:01:26.785]                     }
[17:01:26.785]                     else if (inherits(cond, "condition")) {
[17:01:26.785]                       if (!is.null(pattern)) {
[17:01:26.785]                         computeRestarts <- base::computeRestarts
[17:01:26.785]                         grepl <- base::grepl
[17:01:26.785]                         restarts <- computeRestarts(cond)
[17:01:26.785]                         for (restart in restarts) {
[17:01:26.785]                           name <- restart$name
[17:01:26.785]                           if (is.null(name)) 
[17:01:26.785]                             next
[17:01:26.785]                           if (!grepl(pattern, name)) 
[17:01:26.785]                             next
[17:01:26.785]                           invokeRestart(restart)
[17:01:26.785]                           muffled <- TRUE
[17:01:26.785]                           break
[17:01:26.785]                         }
[17:01:26.785]                       }
[17:01:26.785]                     }
[17:01:26.785]                     invisible(muffled)
[17:01:26.785]                   }
[17:01:26.785]                   muffleCondition(cond)
[17:01:26.785]                 })
[17:01:26.785]             }))
[17:01:26.785]             future::FutureResult(value = ...future.value$value, 
[17:01:26.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:26.785]                   ...future.rng), globalenv = if (FALSE) 
[17:01:26.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:26.785]                     ...future.globalenv.names))
[17:01:26.785]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:26.785]         }, condition = base::local({
[17:01:26.785]             c <- base::c
[17:01:26.785]             inherits <- base::inherits
[17:01:26.785]             invokeRestart <- base::invokeRestart
[17:01:26.785]             length <- base::length
[17:01:26.785]             list <- base::list
[17:01:26.785]             seq.int <- base::seq.int
[17:01:26.785]             signalCondition <- base::signalCondition
[17:01:26.785]             sys.calls <- base::sys.calls
[17:01:26.785]             `[[` <- base::`[[`
[17:01:26.785]             `+` <- base::`+`
[17:01:26.785]             `<<-` <- base::`<<-`
[17:01:26.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:26.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:26.785]                   3L)]
[17:01:26.785]             }
[17:01:26.785]             function(cond) {
[17:01:26.785]                 is_error <- inherits(cond, "error")
[17:01:26.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:26.785]                   NULL)
[17:01:26.785]                 if (is_error) {
[17:01:26.785]                   sessionInformation <- function() {
[17:01:26.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:26.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:26.785]                       search = base::search(), system = base::Sys.info())
[17:01:26.785]                   }
[17:01:26.785]                   ...future.conditions[[length(...future.conditions) + 
[17:01:26.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:26.785]                     cond$call), session = sessionInformation(), 
[17:01:26.785]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:26.785]                   signalCondition(cond)
[17:01:26.785]                 }
[17:01:26.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:26.785]                 "immediateCondition"))) {
[17:01:26.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:26.785]                   ...future.conditions[[length(...future.conditions) + 
[17:01:26.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:26.785]                   if (TRUE && !signal) {
[17:01:26.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.785]                     {
[17:01:26.785]                       inherits <- base::inherits
[17:01:26.785]                       invokeRestart <- base::invokeRestart
[17:01:26.785]                       is.null <- base::is.null
[17:01:26.785]                       muffled <- FALSE
[17:01:26.785]                       if (inherits(cond, "message")) {
[17:01:26.785]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:26.785]                         if (muffled) 
[17:01:26.785]                           invokeRestart("muffleMessage")
[17:01:26.785]                       }
[17:01:26.785]                       else if (inherits(cond, "warning")) {
[17:01:26.785]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:26.785]                         if (muffled) 
[17:01:26.785]                           invokeRestart("muffleWarning")
[17:01:26.785]                       }
[17:01:26.785]                       else if (inherits(cond, "condition")) {
[17:01:26.785]                         if (!is.null(pattern)) {
[17:01:26.785]                           computeRestarts <- base::computeRestarts
[17:01:26.785]                           grepl <- base::grepl
[17:01:26.785]                           restarts <- computeRestarts(cond)
[17:01:26.785]                           for (restart in restarts) {
[17:01:26.785]                             name <- restart$name
[17:01:26.785]                             if (is.null(name)) 
[17:01:26.785]                               next
[17:01:26.785]                             if (!grepl(pattern, name)) 
[17:01:26.785]                               next
[17:01:26.785]                             invokeRestart(restart)
[17:01:26.785]                             muffled <- TRUE
[17:01:26.785]                             break
[17:01:26.785]                           }
[17:01:26.785]                         }
[17:01:26.785]                       }
[17:01:26.785]                       invisible(muffled)
[17:01:26.785]                     }
[17:01:26.785]                     muffleCondition(cond, pattern = "^muffle")
[17:01:26.785]                   }
[17:01:26.785]                 }
[17:01:26.785]                 else {
[17:01:26.785]                   if (TRUE) {
[17:01:26.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:26.785]                     {
[17:01:26.785]                       inherits <- base::inherits
[17:01:26.785]                       invokeRestart <- base::invokeRestart
[17:01:26.785]                       is.null <- base::is.null
[17:01:26.785]                       muffled <- FALSE
[17:01:26.785]                       if (inherits(cond, "message")) {
[17:01:26.785]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:26.785]                         if (muffled) 
[17:01:26.785]                           invokeRestart("muffleMessage")
[17:01:26.785]                       }
[17:01:26.785]                       else if (inherits(cond, "warning")) {
[17:01:26.785]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:26.785]                         if (muffled) 
[17:01:26.785]                           invokeRestart("muffleWarning")
[17:01:26.785]                       }
[17:01:26.785]                       else if (inherits(cond, "condition")) {
[17:01:26.785]                         if (!is.null(pattern)) {
[17:01:26.785]                           computeRestarts <- base::computeRestarts
[17:01:26.785]                           grepl <- base::grepl
[17:01:26.785]                           restarts <- computeRestarts(cond)
[17:01:26.785]                           for (restart in restarts) {
[17:01:26.785]                             name <- restart$name
[17:01:26.785]                             if (is.null(name)) 
[17:01:26.785]                               next
[17:01:26.785]                             if (!grepl(pattern, name)) 
[17:01:26.785]                               next
[17:01:26.785]                             invokeRestart(restart)
[17:01:26.785]                             muffled <- TRUE
[17:01:26.785]                             break
[17:01:26.785]                           }
[17:01:26.785]                         }
[17:01:26.785]                       }
[17:01:26.785]                       invisible(muffled)
[17:01:26.785]                     }
[17:01:26.785]                     muffleCondition(cond, pattern = "^muffle")
[17:01:26.785]                   }
[17:01:26.785]                 }
[17:01:26.785]             }
[17:01:26.785]         }))
[17:01:26.785]     }, error = function(ex) {
[17:01:26.785]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:26.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:26.785]                 ...future.rng), started = ...future.startTime, 
[17:01:26.785]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:26.785]             version = "1.8"), class = "FutureResult")
[17:01:26.785]     }, finally = {
[17:01:26.785]         if (!identical(...future.workdir, getwd())) 
[17:01:26.785]             setwd(...future.workdir)
[17:01:26.785]         {
[17:01:26.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:26.785]                 ...future.oldOptions$nwarnings <- NULL
[17:01:26.785]             }
[17:01:26.785]             base::options(...future.oldOptions)
[17:01:26.785]             if (.Platform$OS.type == "windows") {
[17:01:26.785]                 old_names <- names(...future.oldEnvVars)
[17:01:26.785]                 envs <- base::Sys.getenv()
[17:01:26.785]                 names <- names(envs)
[17:01:26.785]                 common <- intersect(names, old_names)
[17:01:26.785]                 added <- setdiff(names, old_names)
[17:01:26.785]                 removed <- setdiff(old_names, names)
[17:01:26.785]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:26.785]                   envs[common]]
[17:01:26.785]                 NAMES <- toupper(changed)
[17:01:26.785]                 args <- list()
[17:01:26.785]                 for (kk in seq_along(NAMES)) {
[17:01:26.785]                   name <- changed[[kk]]
[17:01:26.785]                   NAME <- NAMES[[kk]]
[17:01:26.785]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.785]                     next
[17:01:26.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:26.785]                 }
[17:01:26.785]                 NAMES <- toupper(added)
[17:01:26.785]                 for (kk in seq_along(NAMES)) {
[17:01:26.785]                   name <- added[[kk]]
[17:01:26.785]                   NAME <- NAMES[[kk]]
[17:01:26.785]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.785]                     next
[17:01:26.785]                   args[[name]] <- ""
[17:01:26.785]                 }
[17:01:26.785]                 NAMES <- toupper(removed)
[17:01:26.785]                 for (kk in seq_along(NAMES)) {
[17:01:26.785]                   name <- removed[[kk]]
[17:01:26.785]                   NAME <- NAMES[[kk]]
[17:01:26.785]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:26.785]                     next
[17:01:26.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:26.785]                 }
[17:01:26.785]                 if (length(args) > 0) 
[17:01:26.785]                   base::do.call(base::Sys.setenv, args = args)
[17:01:26.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:26.785]             }
[17:01:26.785]             else {
[17:01:26.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:26.785]             }
[17:01:26.785]             {
[17:01:26.785]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:26.785]                   0L) {
[17:01:26.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:26.785]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:26.785]                   base::options(opts)
[17:01:26.785]                 }
[17:01:26.785]                 {
[17:01:26.785]                   {
[17:01:26.785]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:26.785]                     NULL
[17:01:26.785]                   }
[17:01:26.785]                   options(future.plan = NULL)
[17:01:26.785]                   if (is.na(NA_character_)) 
[17:01:26.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:26.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:26.785]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:26.785]                     .init = FALSE)
[17:01:26.785]                 }
[17:01:26.785]             }
[17:01:26.785]         }
[17:01:26.785]     })
[17:01:26.785]     if (FALSE) {
[17:01:26.785]         base::sink(type = "output", split = FALSE)
[17:01:26.785]         if (NA) {
[17:01:26.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:26.785]         }
[17:01:26.785]         else {
[17:01:26.785]             ...future.result["stdout"] <- base::list(NULL)
[17:01:26.785]         }
[17:01:26.785]         base::close(...future.stdout)
[17:01:26.785]         ...future.stdout <- NULL
[17:01:26.785]     }
[17:01:26.785]     ...future.result$conditions <- ...future.conditions
[17:01:26.785]     ...future.result$finished <- base::Sys.time()
[17:01:26.785]     ...future.result
[17:01:26.785] }
[17:01:26.788] assign_globals() ...
[17:01:26.788] List of 5
[17:01:26.788]  $ ...future.FUN            :function (x)  
[17:01:26.788]  $ future.call.arguments    : list()
[17:01:26.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:26.788]  $ ...future.elements_ii    :List of 1
[17:01:26.788]   ..$ : int 0
[17:01:26.788]  $ ...future.seeds_ii       : NULL
[17:01:26.788]  $ ...future.globals.maxSize: NULL
[17:01:26.788]  - attr(*, "where")=List of 5
[17:01:26.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:26.788]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:26.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:26.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:26.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:26.788]  - attr(*, "resolved")= logi FALSE
[17:01:26.788]  - attr(*, "total_size")= num 4720
[17:01:26.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:26.788]  - attr(*, "already-done")= logi TRUE
[17:01:26.795] - reassign environment for ‘...future.FUN’
[17:01:26.795] - copied ‘...future.FUN’ to environment
[17:01:26.796] - copied ‘future.call.arguments’ to environment
[17:01:26.796] - copied ‘...future.elements_ii’ to environment
[17:01:26.796] - copied ‘...future.seeds_ii’ to environment
[17:01:26.796] - copied ‘...future.globals.maxSize’ to environment
[17:01:26.796] assign_globals() ... done
[17:01:26.796] requestCore(): workers = 2
[17:01:26.799] MulticoreFuture started
[17:01:26.799] - Launch lazy future ... done
[17:01:26.800] plan(): Setting new future strategy stack:
[17:01:26.799] run() for ‘MulticoreFuture’ ... done
[17:01:26.804] Created future:
[17:01:26.804] List of future strategies:
[17:01:26.804] 1. sequential:
[17:01:26.804]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:26.804]    - tweaked: FALSE
[17:01:26.804]    - call: NULL
[17:01:26.806] plan(): nbrOfWorkers() = 1
[17:01:26.809] plan(): Setting new future strategy stack:
[17:01:26.809] List of future strategies:
[17:01:26.809] 1. multicore:
[17:01:26.809]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:26.809]    - tweaked: FALSE
[17:01:26.809]    - call: plan(strategy)
[17:01:26.815] plan(): nbrOfWorkers() = 2
[17:01:26.805] MulticoreFuture:
[17:01:26.805] Label: ‘future_lapply-2’
[17:01:26.805] Expression:
[17:01:26.805] {
[17:01:26.805]     do.call(function(...) {
[17:01:26.805]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:26.805]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:26.805]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:26.805]             on.exit(options(oopts), add = TRUE)
[17:01:26.805]         }
[17:01:26.805]         {
[17:01:26.805]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:26.805]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:26.805]                 ...future.FUN(...future.X_jj, ...)
[17:01:26.805]             })
[17:01:26.805]         }
[17:01:26.805]     }, args = future.call.arguments)
[17:01:26.805] }
[17:01:26.805] Lazy evaluation: FALSE
[17:01:26.805] Asynchronous evaluation: TRUE
[17:01:26.805] Local evaluation: TRUE
[17:01:26.805] Environment: R_GlobalEnv
[17:01:26.805] Capture standard output: NA
[17:01:26.805] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:26.805] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:26.805] Packages: <none>
[17:01:26.805] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:26.805] Resolved: TRUE
[17:01:26.805] Value: <not collected>
[17:01:26.805] Conditions captured: <none>
[17:01:26.805] Early signaling: FALSE
[17:01:26.805] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:26.805] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:26.817] Chunk #2 of 2 ... DONE
[17:01:26.817] Launching 2 futures (chunks) ... DONE
[17:01:26.817] Resolving 2 futures (chunks) ...
[17:01:26.818] resolve() on list ...
[17:01:26.818]  recursive: 0
[17:01:26.818]  length: 2
[17:01:26.818] 
[17:01:26.829] Future #2
[17:01:26.829] result() for MulticoreFuture ...
[17:01:26.830] result() for MulticoreFuture ...
[17:01:26.831] result() for MulticoreFuture ... done
[17:01:26.831] result() for MulticoreFuture ... done
[17:01:26.831] result() for MulticoreFuture ...
[17:01:26.831] result() for MulticoreFuture ... done
[17:01:26.831] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:26.831] - nx: 2
[17:01:26.832] - relay: TRUE
[17:01:26.832] - stdout: TRUE
[17:01:26.832] - signal: TRUE
[17:01:26.832] - resignal: FALSE
[17:01:26.832] - force: TRUE
[17:01:26.832] - relayed: [n=2] FALSE, FALSE
[17:01:26.832] - queued futures: [n=2] FALSE, FALSE
[17:01:26.833]  - until=1
[17:01:26.833]  - relaying element #1
[17:01:26.833] - relayed: [n=2] FALSE, FALSE
[17:01:26.833] - queued futures: [n=2] FALSE, TRUE
[17:01:26.833] signalConditionsASAP(NULL, pos=2) ... done
[17:01:26.833]  length: 1 (resolved future 2)
[17:01:27.257] plan(): Setting new future strategy stack:
[17:01:27.258] List of future strategies:
[17:01:27.258] 1. multicore:
[17:01:27.258]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:27.258]    - tweaked: FALSE
[17:01:27.258]    - call: plan(strategy)
[17:01:27.262] plan(): nbrOfWorkers() = 2
[17:01:27.263] Future #1
[17:01:27.263] result() for MulticoreFuture ...
[17:01:27.264] result() for MulticoreFuture ...
[17:01:27.264] result() for MulticoreFuture ... done
[17:01:27.264] result() for MulticoreFuture ... done
[17:01:27.264] result() for MulticoreFuture ...
[17:01:27.264] result() for MulticoreFuture ... done
[17:01:27.264] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:27.265] - nx: 2
[17:01:27.265] - relay: TRUE
[17:01:27.265] - stdout: TRUE
[17:01:27.265] - signal: TRUE
[17:01:27.265] - resignal: FALSE
[17:01:27.265] - force: TRUE
[17:01:27.265] - relayed: [n=2] FALSE, FALSE
[17:01:27.265] - queued futures: [n=2] FALSE, TRUE
[17:01:27.265]  - until=1
[17:01:27.266]  - relaying element #1
[17:01:27.266] result() for MulticoreFuture ...
[17:01:27.266] result() for MulticoreFuture ... done
[17:01:27.266] result() for MulticoreFuture ...
[17:01:27.266] result() for MulticoreFuture ... done
[17:01:27.266] result() for MulticoreFuture ...
[17:01:27.266] result() for MulticoreFuture ... done
[17:01:27.266] result() for MulticoreFuture ...
[17:01:27.266] result() for MulticoreFuture ... done
[17:01:27.267] - relayed: [n=2] TRUE, FALSE
[17:01:27.267] - queued futures: [n=2] TRUE, TRUE
[17:01:27.267] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:27.267]  length: 0 (resolved future 1)
[17:01:27.267] Relaying remaining futures
[17:01:27.267] signalConditionsASAP(NULL, pos=0) ...
[17:01:27.267] - nx: 2
[17:01:27.267] - relay: TRUE
[17:01:27.267] - stdout: TRUE
[17:01:27.268] - signal: TRUE
[17:01:27.268] - resignal: FALSE
[17:01:27.268] - force: TRUE
[17:01:27.268] - relayed: [n=2] TRUE, FALSE
[17:01:27.268] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:27.268]  - relaying element #2
[17:01:27.268] result() for MulticoreFuture ...
[17:01:27.268] result() for MulticoreFuture ... done
[17:01:27.268] result() for MulticoreFuture ...
[17:01:27.269] result() for MulticoreFuture ... done
[17:01:27.269] result() for MulticoreFuture ...
[17:01:27.269] result() for MulticoreFuture ... done
[17:01:27.269] result() for MulticoreFuture ...
[17:01:27.269] result() for MulticoreFuture ... done
[17:01:27.269] - relayed: [n=2] TRUE, TRUE
[17:01:27.269] - queued futures: [n=2] TRUE, TRUE
[17:01:27.269] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:01:27.269] resolve() on list ... DONE
[17:01:27.270] result() for MulticoreFuture ...
[17:01:27.270] result() for MulticoreFuture ... done
[17:01:27.270] result() for MulticoreFuture ...
[17:01:27.270] result() for MulticoreFuture ... done
[17:01:27.270] result() for MulticoreFuture ...
[17:01:27.270] result() for MulticoreFuture ... done
[17:01:27.270] result() for MulticoreFuture ...
[17:01:27.270] result() for MulticoreFuture ... done
[17:01:27.270]  - Number of value chunks collected: 2
[17:01:27.271] Resolving 2 futures (chunks) ... DONE
[17:01:27.271] Reducing values from 2 chunks ...
[17:01:27.271]  - Number of values collected after concatenation: 2
[17:01:27.271]  - Number of values expected: 2
[17:01:27.271] Reducing values from 2 chunks ... DONE
[17:01:27.271] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:01:27.272] future_mapply() ...
[17:01:27.276] Number of chunks: 2
[17:01:27.276] getGlobalsAndPackagesXApply() ...
[17:01:27.276]  - future.globals: TRUE
[17:01:27.276] getGlobalsAndPackages() ...
[17:01:27.276] Searching for globals...
[17:01:27.278] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:27.278] Searching for globals ... DONE
[17:01:27.278] Resolving globals: FALSE
[17:01:27.279] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:27.279] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:27.279] - globals: [1] ‘FUN’
[17:01:27.279] 
[17:01:27.280] getGlobalsAndPackages() ... DONE
[17:01:27.280]  - globals found/used: [n=1] ‘FUN’
[17:01:27.280]  - needed namespaces: [n=0] 
[17:01:27.280] Finding globals ... DONE
[17:01:27.280] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:27.280] List of 2
[17:01:27.280]  $ ...future.FUN:function (x, y)  
[17:01:27.280]  $ MoreArgs     : NULL
[17:01:27.280]  - attr(*, "where")=List of 2
[17:01:27.280]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:27.280]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:27.280]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:27.280]  - attr(*, "resolved")= logi FALSE
[17:01:27.280]  - attr(*, "total_size")= num NA
[17:01:27.283] Packages to be attached in all futures: [n=0] 
[17:01:27.283] getGlobalsAndPackagesXApply() ... DONE
[17:01:27.283] Number of futures (= number of chunks): 2
[17:01:27.283] Launching 2 futures (chunks) ...
[17:01:27.284] Chunk #1 of 2 ...
[17:01:27.284]  - Finding globals in '...' for chunk #1 ...
[17:01:27.284] getGlobalsAndPackages() ...
[17:01:27.284] Searching for globals...
[17:01:27.284] 
[17:01:27.284] Searching for globals ... DONE
[17:01:27.284] - globals: [0] <none>
[17:01:27.285] getGlobalsAndPackages() ... DONE
[17:01:27.285]    + additional globals found: [n=0] 
[17:01:27.287]    + additional namespaces needed: [n=0] 
[17:01:27.287]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:27.287]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:27.287]  - seeds: <none>
[17:01:27.287]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.287] getGlobalsAndPackages() ...
[17:01:27.287] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.287] Resolving globals: FALSE
[17:01:27.288] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:27.289] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:27.289] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.289] 
[17:01:27.289] getGlobalsAndPackages() ... DONE
[17:01:27.289] run() for ‘Future’ ...
[17:01:27.289] - state: ‘created’
[17:01:27.290] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:27.293] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:27.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:27.294]   - Field: ‘label’
[17:01:27.294]   - Field: ‘local’
[17:01:27.294]   - Field: ‘owner’
[17:01:27.294]   - Field: ‘envir’
[17:01:27.294]   - Field: ‘workers’
[17:01:27.294]   - Field: ‘packages’
[17:01:27.294]   - Field: ‘gc’
[17:01:27.294]   - Field: ‘job’
[17:01:27.294]   - Field: ‘conditions’
[17:01:27.294]   - Field: ‘expr’
[17:01:27.295]   - Field: ‘uuid’
[17:01:27.295]   - Field: ‘seed’
[17:01:27.295]   - Field: ‘version’
[17:01:27.295]   - Field: ‘result’
[17:01:27.295]   - Field: ‘asynchronous’
[17:01:27.295]   - Field: ‘calls’
[17:01:27.295]   - Field: ‘globals’
[17:01:27.295]   - Field: ‘stdout’
[17:01:27.295]   - Field: ‘earlySignal’
[17:01:27.295]   - Field: ‘lazy’
[17:01:27.296]   - Field: ‘state’
[17:01:27.296] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:27.296] - Launch lazy future ...
[17:01:27.296] Packages needed by the future expression (n = 0): <none>
[17:01:27.296] Packages needed by future strategies (n = 0): <none>
[17:01:27.297] {
[17:01:27.297]     {
[17:01:27.297]         {
[17:01:27.297]             ...future.startTime <- base::Sys.time()
[17:01:27.297]             {
[17:01:27.297]                 {
[17:01:27.297]                   {
[17:01:27.297]                     {
[17:01:27.297]                       base::local({
[17:01:27.297]                         has_future <- base::requireNamespace("future", 
[17:01:27.297]                           quietly = TRUE)
[17:01:27.297]                         if (has_future) {
[17:01:27.297]                           ns <- base::getNamespace("future")
[17:01:27.297]                           version <- ns[[".package"]][["version"]]
[17:01:27.297]                           if (is.null(version)) 
[17:01:27.297]                             version <- utils::packageVersion("future")
[17:01:27.297]                         }
[17:01:27.297]                         else {
[17:01:27.297]                           version <- NULL
[17:01:27.297]                         }
[17:01:27.297]                         if (!has_future || version < "1.8.0") {
[17:01:27.297]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:27.297]                             "", base::R.version$version.string), 
[17:01:27.297]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:27.297]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:27.297]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:27.297]                               "release", "version")], collapse = " "), 
[17:01:27.297]                             hostname = base::Sys.info()[["nodename"]])
[17:01:27.297]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:27.297]                             info)
[17:01:27.297]                           info <- base::paste(info, collapse = "; ")
[17:01:27.297]                           if (!has_future) {
[17:01:27.297]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:27.297]                               info)
[17:01:27.297]                           }
[17:01:27.297]                           else {
[17:01:27.297]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:27.297]                               info, version)
[17:01:27.297]                           }
[17:01:27.297]                           base::stop(msg)
[17:01:27.297]                         }
[17:01:27.297]                       })
[17:01:27.297]                     }
[17:01:27.297]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:27.297]                     base::options(mc.cores = 1L)
[17:01:27.297]                   }
[17:01:27.297]                   ...future.strategy.old <- future::plan("list")
[17:01:27.297]                   options(future.plan = NULL)
[17:01:27.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:27.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:27.297]                 }
[17:01:27.297]                 ...future.workdir <- getwd()
[17:01:27.297]             }
[17:01:27.297]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:27.297]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:27.297]         }
[17:01:27.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:27.297]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:27.297]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:27.297]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:27.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:27.297]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:27.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:27.297]             base::names(...future.oldOptions))
[17:01:27.297]     }
[17:01:27.297]     if (FALSE) {
[17:01:27.297]     }
[17:01:27.297]     else {
[17:01:27.297]         if (FALSE) {
[17:01:27.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:27.297]                 open = "w")
[17:01:27.297]         }
[17:01:27.297]         else {
[17:01:27.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:27.297]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:27.297]         }
[17:01:27.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:27.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:27.297]             base::sink(type = "output", split = FALSE)
[17:01:27.297]             base::close(...future.stdout)
[17:01:27.297]         }, add = TRUE)
[17:01:27.297]     }
[17:01:27.297]     ...future.frame <- base::sys.nframe()
[17:01:27.297]     ...future.conditions <- base::list()
[17:01:27.297]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:27.297]     if (FALSE) {
[17:01:27.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:27.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:27.297]     }
[17:01:27.297]     ...future.result <- base::tryCatch({
[17:01:27.297]         base::withCallingHandlers({
[17:01:27.297]             ...future.value <- base::withVisible(base::local({
[17:01:27.297]                 withCallingHandlers({
[17:01:27.297]                   {
[17:01:27.297]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:27.297]                     if (!identical(...future.globals.maxSize.org, 
[17:01:27.297]                       ...future.globals.maxSize)) {
[17:01:27.297]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:27.297]                       on.exit(options(oopts), add = TRUE)
[17:01:27.297]                     }
[17:01:27.297]                     {
[17:01:27.297]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:27.297]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:27.297]                         USE.NAMES = FALSE)
[17:01:27.297]                       do.call(mapply, args = args)
[17:01:27.297]                     }
[17:01:27.297]                   }
[17:01:27.297]                 }, immediateCondition = function(cond) {
[17:01:27.297]                   save_rds <- function (object, pathname, ...) 
[17:01:27.297]                   {
[17:01:27.297]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:27.297]                     if (file_test("-f", pathname_tmp)) {
[17:01:27.297]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.297]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:27.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.297]                         fi_tmp[["mtime"]])
[17:01:27.297]                     }
[17:01:27.297]                     tryCatch({
[17:01:27.297]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:27.297]                     }, error = function(ex) {
[17:01:27.297]                       msg <- conditionMessage(ex)
[17:01:27.297]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.297]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:27.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.297]                         fi_tmp[["mtime"]], msg)
[17:01:27.297]                       ex$message <- msg
[17:01:27.297]                       stop(ex)
[17:01:27.297]                     })
[17:01:27.297]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:27.297]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:27.297]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:27.297]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.297]                       fi <- file.info(pathname)
[17:01:27.297]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:27.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.297]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:27.297]                         fi[["size"]], fi[["mtime"]])
[17:01:27.297]                       stop(msg)
[17:01:27.297]                     }
[17:01:27.297]                     invisible(pathname)
[17:01:27.297]                   }
[17:01:27.297]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:27.297]                     rootPath = tempdir()) 
[17:01:27.297]                   {
[17:01:27.297]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:27.297]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:27.297]                       tmpdir = path, fileext = ".rds")
[17:01:27.297]                     save_rds(obj, file)
[17:01:27.297]                   }
[17:01:27.297]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:27.297]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.297]                   {
[17:01:27.297]                     inherits <- base::inherits
[17:01:27.297]                     invokeRestart <- base::invokeRestart
[17:01:27.297]                     is.null <- base::is.null
[17:01:27.297]                     muffled <- FALSE
[17:01:27.297]                     if (inherits(cond, "message")) {
[17:01:27.297]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:27.297]                       if (muffled) 
[17:01:27.297]                         invokeRestart("muffleMessage")
[17:01:27.297]                     }
[17:01:27.297]                     else if (inherits(cond, "warning")) {
[17:01:27.297]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:27.297]                       if (muffled) 
[17:01:27.297]                         invokeRestart("muffleWarning")
[17:01:27.297]                     }
[17:01:27.297]                     else if (inherits(cond, "condition")) {
[17:01:27.297]                       if (!is.null(pattern)) {
[17:01:27.297]                         computeRestarts <- base::computeRestarts
[17:01:27.297]                         grepl <- base::grepl
[17:01:27.297]                         restarts <- computeRestarts(cond)
[17:01:27.297]                         for (restart in restarts) {
[17:01:27.297]                           name <- restart$name
[17:01:27.297]                           if (is.null(name)) 
[17:01:27.297]                             next
[17:01:27.297]                           if (!grepl(pattern, name)) 
[17:01:27.297]                             next
[17:01:27.297]                           invokeRestart(restart)
[17:01:27.297]                           muffled <- TRUE
[17:01:27.297]                           break
[17:01:27.297]                         }
[17:01:27.297]                       }
[17:01:27.297]                     }
[17:01:27.297]                     invisible(muffled)
[17:01:27.297]                   }
[17:01:27.297]                   muffleCondition(cond)
[17:01:27.297]                 })
[17:01:27.297]             }))
[17:01:27.297]             future::FutureResult(value = ...future.value$value, 
[17:01:27.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:27.297]                   ...future.rng), globalenv = if (FALSE) 
[17:01:27.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:27.297]                     ...future.globalenv.names))
[17:01:27.297]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:27.297]         }, condition = base::local({
[17:01:27.297]             c <- base::c
[17:01:27.297]             inherits <- base::inherits
[17:01:27.297]             invokeRestart <- base::invokeRestart
[17:01:27.297]             length <- base::length
[17:01:27.297]             list <- base::list
[17:01:27.297]             seq.int <- base::seq.int
[17:01:27.297]             signalCondition <- base::signalCondition
[17:01:27.297]             sys.calls <- base::sys.calls
[17:01:27.297]             `[[` <- base::`[[`
[17:01:27.297]             `+` <- base::`+`
[17:01:27.297]             `<<-` <- base::`<<-`
[17:01:27.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:27.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:27.297]                   3L)]
[17:01:27.297]             }
[17:01:27.297]             function(cond) {
[17:01:27.297]                 is_error <- inherits(cond, "error")
[17:01:27.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:27.297]                   NULL)
[17:01:27.297]                 if (is_error) {
[17:01:27.297]                   sessionInformation <- function() {
[17:01:27.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:27.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:27.297]                       search = base::search(), system = base::Sys.info())
[17:01:27.297]                   }
[17:01:27.297]                   ...future.conditions[[length(...future.conditions) + 
[17:01:27.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:27.297]                     cond$call), session = sessionInformation(), 
[17:01:27.297]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:27.297]                   signalCondition(cond)
[17:01:27.297]                 }
[17:01:27.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:27.297]                 "immediateCondition"))) {
[17:01:27.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:27.297]                   ...future.conditions[[length(...future.conditions) + 
[17:01:27.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:27.297]                   if (TRUE && !signal) {
[17:01:27.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.297]                     {
[17:01:27.297]                       inherits <- base::inherits
[17:01:27.297]                       invokeRestart <- base::invokeRestart
[17:01:27.297]                       is.null <- base::is.null
[17:01:27.297]                       muffled <- FALSE
[17:01:27.297]                       if (inherits(cond, "message")) {
[17:01:27.297]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:27.297]                         if (muffled) 
[17:01:27.297]                           invokeRestart("muffleMessage")
[17:01:27.297]                       }
[17:01:27.297]                       else if (inherits(cond, "warning")) {
[17:01:27.297]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:27.297]                         if (muffled) 
[17:01:27.297]                           invokeRestart("muffleWarning")
[17:01:27.297]                       }
[17:01:27.297]                       else if (inherits(cond, "condition")) {
[17:01:27.297]                         if (!is.null(pattern)) {
[17:01:27.297]                           computeRestarts <- base::computeRestarts
[17:01:27.297]                           grepl <- base::grepl
[17:01:27.297]                           restarts <- computeRestarts(cond)
[17:01:27.297]                           for (restart in restarts) {
[17:01:27.297]                             name <- restart$name
[17:01:27.297]                             if (is.null(name)) 
[17:01:27.297]                               next
[17:01:27.297]                             if (!grepl(pattern, name)) 
[17:01:27.297]                               next
[17:01:27.297]                             invokeRestart(restart)
[17:01:27.297]                             muffled <- TRUE
[17:01:27.297]                             break
[17:01:27.297]                           }
[17:01:27.297]                         }
[17:01:27.297]                       }
[17:01:27.297]                       invisible(muffled)
[17:01:27.297]                     }
[17:01:27.297]                     muffleCondition(cond, pattern = "^muffle")
[17:01:27.297]                   }
[17:01:27.297]                 }
[17:01:27.297]                 else {
[17:01:27.297]                   if (TRUE) {
[17:01:27.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.297]                     {
[17:01:27.297]                       inherits <- base::inherits
[17:01:27.297]                       invokeRestart <- base::invokeRestart
[17:01:27.297]                       is.null <- base::is.null
[17:01:27.297]                       muffled <- FALSE
[17:01:27.297]                       if (inherits(cond, "message")) {
[17:01:27.297]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:27.297]                         if (muffled) 
[17:01:27.297]                           invokeRestart("muffleMessage")
[17:01:27.297]                       }
[17:01:27.297]                       else if (inherits(cond, "warning")) {
[17:01:27.297]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:27.297]                         if (muffled) 
[17:01:27.297]                           invokeRestart("muffleWarning")
[17:01:27.297]                       }
[17:01:27.297]                       else if (inherits(cond, "condition")) {
[17:01:27.297]                         if (!is.null(pattern)) {
[17:01:27.297]                           computeRestarts <- base::computeRestarts
[17:01:27.297]                           grepl <- base::grepl
[17:01:27.297]                           restarts <- computeRestarts(cond)
[17:01:27.297]                           for (restart in restarts) {
[17:01:27.297]                             name <- restart$name
[17:01:27.297]                             if (is.null(name)) 
[17:01:27.297]                               next
[17:01:27.297]                             if (!grepl(pattern, name)) 
[17:01:27.297]                               next
[17:01:27.297]                             invokeRestart(restart)
[17:01:27.297]                             muffled <- TRUE
[17:01:27.297]                             break
[17:01:27.297]                           }
[17:01:27.297]                         }
[17:01:27.297]                       }
[17:01:27.297]                       invisible(muffled)
[17:01:27.297]                     }
[17:01:27.297]                     muffleCondition(cond, pattern = "^muffle")
[17:01:27.297]                   }
[17:01:27.297]                 }
[17:01:27.297]             }
[17:01:27.297]         }))
[17:01:27.297]     }, error = function(ex) {
[17:01:27.297]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:27.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:27.297]                 ...future.rng), started = ...future.startTime, 
[17:01:27.297]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:27.297]             version = "1.8"), class = "FutureResult")
[17:01:27.297]     }, finally = {
[17:01:27.297]         if (!identical(...future.workdir, getwd())) 
[17:01:27.297]             setwd(...future.workdir)
[17:01:27.297]         {
[17:01:27.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:27.297]                 ...future.oldOptions$nwarnings <- NULL
[17:01:27.297]             }
[17:01:27.297]             base::options(...future.oldOptions)
[17:01:27.297]             if (.Platform$OS.type == "windows") {
[17:01:27.297]                 old_names <- names(...future.oldEnvVars)
[17:01:27.297]                 envs <- base::Sys.getenv()
[17:01:27.297]                 names <- names(envs)
[17:01:27.297]                 common <- intersect(names, old_names)
[17:01:27.297]                 added <- setdiff(names, old_names)
[17:01:27.297]                 removed <- setdiff(old_names, names)
[17:01:27.297]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:27.297]                   envs[common]]
[17:01:27.297]                 NAMES <- toupper(changed)
[17:01:27.297]                 args <- list()
[17:01:27.297]                 for (kk in seq_along(NAMES)) {
[17:01:27.297]                   name <- changed[[kk]]
[17:01:27.297]                   NAME <- NAMES[[kk]]
[17:01:27.297]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.297]                     next
[17:01:27.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:27.297]                 }
[17:01:27.297]                 NAMES <- toupper(added)
[17:01:27.297]                 for (kk in seq_along(NAMES)) {
[17:01:27.297]                   name <- added[[kk]]
[17:01:27.297]                   NAME <- NAMES[[kk]]
[17:01:27.297]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.297]                     next
[17:01:27.297]                   args[[name]] <- ""
[17:01:27.297]                 }
[17:01:27.297]                 NAMES <- toupper(removed)
[17:01:27.297]                 for (kk in seq_along(NAMES)) {
[17:01:27.297]                   name <- removed[[kk]]
[17:01:27.297]                   NAME <- NAMES[[kk]]
[17:01:27.297]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.297]                     next
[17:01:27.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:27.297]                 }
[17:01:27.297]                 if (length(args) > 0) 
[17:01:27.297]                   base::do.call(base::Sys.setenv, args = args)
[17:01:27.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:27.297]             }
[17:01:27.297]             else {
[17:01:27.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:27.297]             }
[17:01:27.297]             {
[17:01:27.297]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:27.297]                   0L) {
[17:01:27.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:27.297]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:27.297]                   base::options(opts)
[17:01:27.297]                 }
[17:01:27.297]                 {
[17:01:27.297]                   {
[17:01:27.297]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:27.297]                     NULL
[17:01:27.297]                   }
[17:01:27.297]                   options(future.plan = NULL)
[17:01:27.297]                   if (is.na(NA_character_)) 
[17:01:27.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:27.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:27.297]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:27.297]                     .init = FALSE)
[17:01:27.297]                 }
[17:01:27.297]             }
[17:01:27.297]         }
[17:01:27.297]     })
[17:01:27.297]     if (TRUE) {
[17:01:27.297]         base::sink(type = "output", split = FALSE)
[17:01:27.297]         if (FALSE) {
[17:01:27.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:27.297]         }
[17:01:27.297]         else {
[17:01:27.297]             ...future.result["stdout"] <- base::list(NULL)
[17:01:27.297]         }
[17:01:27.297]         base::close(...future.stdout)
[17:01:27.297]         ...future.stdout <- NULL
[17:01:27.297]     }
[17:01:27.297]     ...future.result$conditions <- ...future.conditions
[17:01:27.297]     ...future.result$finished <- base::Sys.time()
[17:01:27.297]     ...future.result
[17:01:27.297] }
[17:01:27.299] assign_globals() ...
[17:01:27.299] List of 5
[17:01:27.299]  $ ...future.FUN            :function (x, y)  
[17:01:27.299]  $ MoreArgs                 : NULL
[17:01:27.299]  $ ...future.elements_ii    :List of 2
[17:01:27.299]   ..$ :List of 1
[17:01:27.299]   .. ..$ : int 1
[17:01:27.299]   ..$ :List of 1
[17:01:27.299]   .. ..$ : int 0
[17:01:27.299]  $ ...future.seeds_ii       : NULL
[17:01:27.299]  $ ...future.globals.maxSize: NULL
[17:01:27.299]  - attr(*, "where")=List of 5
[17:01:27.299]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:27.299]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:27.299]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:27.299]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:27.299]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:27.299]  - attr(*, "resolved")= logi FALSE
[17:01:27.299]  - attr(*, "total_size")= num 6368
[17:01:27.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:27.299]  - attr(*, "already-done")= logi TRUE
[17:01:27.304] - reassign environment for ‘...future.FUN’
[17:01:27.304] - copied ‘...future.FUN’ to environment
[17:01:27.304] - copied ‘MoreArgs’ to environment
[17:01:27.304] - copied ‘...future.elements_ii’ to environment
[17:01:27.304] - copied ‘...future.seeds_ii’ to environment
[17:01:27.305] - copied ‘...future.globals.maxSize’ to environment
[17:01:27.305] assign_globals() ... done
[17:01:27.305] requestCore(): workers = 2
[17:01:27.307] MulticoreFuture started
[17:01:27.307] - Launch lazy future ... done
[17:01:27.308] run() for ‘MulticoreFuture’ ... done
[17:01:27.308] Created future:
[17:01:27.308] plan(): Setting new future strategy stack:
[17:01:27.308] List of future strategies:
[17:01:27.308] 1. sequential:
[17:01:27.308]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:27.308]    - tweaked: FALSE
[17:01:27.308]    - call: NULL
[17:01:27.309] plan(): nbrOfWorkers() = 1
[17:01:27.308] MulticoreFuture:
[17:01:27.308] Label: ‘future_mapply-1’
[17:01:27.308] Expression:
[17:01:27.308] {
[17:01:27.308]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:27.308]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:27.308]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:27.308]         on.exit(options(oopts), add = TRUE)
[17:01:27.308]     }
[17:01:27.308]     {
[17:01:27.308]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:27.308]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:27.308]         do.call(mapply, args = args)
[17:01:27.308]     }
[17:01:27.308] }
[17:01:27.308] Lazy evaluation: FALSE
[17:01:27.308] Asynchronous evaluation: TRUE
[17:01:27.308] Local evaluation: TRUE
[17:01:27.308] Environment: R_GlobalEnv
[17:01:27.308] Capture standard output: FALSE
[17:01:27.308] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:27.308] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:27.308] Packages: <none>
[17:01:27.308] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:27.308] Resolved: FALSE
[17:01:27.308] Value: <not collected>
[17:01:27.308] Conditions captured: <none>
[17:01:27.308] Early signaling: FALSE
[17:01:27.308] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:27.308] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:27.321] Chunk #1 of 2 ... DONE
[17:01:27.321] Chunk #2 of 2 ...
[17:01:27.321]  - Finding globals in '...' for chunk #2 ...
[17:01:27.321] getGlobalsAndPackages() ...
[17:01:27.322] Searching for globals...
[17:01:27.322] 
[17:01:27.323] Searching for globals ... DONE
[17:01:27.323] - globals: [0] <none>
[17:01:27.323] getGlobalsAndPackages() ... DONE
[17:01:27.323]    + additional globals found: [n=0] 
[17:01:27.323]    + additional namespaces needed: [n=0] 
[17:01:27.323]  - Finding globals in '...' for chunk #2 ... DONE
[17:01:27.323]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:27.324]  - seeds: <none>
[17:01:27.324]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.324] getGlobalsAndPackages() ...
[17:01:27.324] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.324] Resolving globals: FALSE
[17:01:27.325] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:27.326] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:27.326] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.326] 
[17:01:27.327] getGlobalsAndPackages() ... DONE
[17:01:27.327] run() for ‘Future’ ...
[17:01:27.327] - state: ‘created’
[17:01:27.328] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:27.333] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:27.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:27.333]   - Field: ‘label’
[17:01:27.333]   - Field: ‘local’
[17:01:27.334]   - Field: ‘owner’
[17:01:27.334]   - Field: ‘envir’
[17:01:27.334]   - Field: ‘workers’
[17:01:27.334]   - Field: ‘packages’
[17:01:27.334]   - Field: ‘gc’
[17:01:27.334]   - Field: ‘job’
[17:01:27.335]   - Field: ‘conditions’
[17:01:27.335]   - Field: ‘expr’
[17:01:27.335]   - Field: ‘uuid’
[17:01:27.335]   - Field: ‘seed’
[17:01:27.335]   - Field: ‘version’
[17:01:27.335]   - Field: ‘result’
[17:01:27.335]   - Field: ‘asynchronous’
[17:01:27.336]   - Field: ‘calls’
[17:01:27.336]   - Field: ‘globals’
[17:01:27.336]   - Field: ‘stdout’
[17:01:27.336]   - Field: ‘earlySignal’
[17:01:27.336]   - Field: ‘lazy’
[17:01:27.336]   - Field: ‘state’
[17:01:27.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:27.340] - Launch lazy future ...
[17:01:27.341] Packages needed by the future expression (n = 0): <none>
[17:01:27.341] Packages needed by future strategies (n = 0): <none>
[17:01:27.342] {
[17:01:27.342]     {
[17:01:27.342]         {
[17:01:27.342]             ...future.startTime <- base::Sys.time()
[17:01:27.342]             {
[17:01:27.342]                 {
[17:01:27.342]                   {
[17:01:27.342]                     {
[17:01:27.342]                       base::local({
[17:01:27.342]                         has_future <- base::requireNamespace("future", 
[17:01:27.342]                           quietly = TRUE)
[17:01:27.342]                         if (has_future) {
[17:01:27.342]                           ns <- base::getNamespace("future")
[17:01:27.342]                           version <- ns[[".package"]][["version"]]
[17:01:27.342]                           if (is.null(version)) 
[17:01:27.342]                             version <- utils::packageVersion("future")
[17:01:27.342]                         }
[17:01:27.342]                         else {
[17:01:27.342]                           version <- NULL
[17:01:27.342]                         }
[17:01:27.342]                         if (!has_future || version < "1.8.0") {
[17:01:27.342]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:27.342]                             "", base::R.version$version.string), 
[17:01:27.342]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:27.342]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:27.342]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:27.342]                               "release", "version")], collapse = " "), 
[17:01:27.342]                             hostname = base::Sys.info()[["nodename"]])
[17:01:27.342]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:27.342]                             info)
[17:01:27.342]                           info <- base::paste(info, collapse = "; ")
[17:01:27.342]                           if (!has_future) {
[17:01:27.342]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:27.342]                               info)
[17:01:27.342]                           }
[17:01:27.342]                           else {
[17:01:27.342]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:27.342]                               info, version)
[17:01:27.342]                           }
[17:01:27.342]                           base::stop(msg)
[17:01:27.342]                         }
[17:01:27.342]                       })
[17:01:27.342]                     }
[17:01:27.342]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:27.342]                     base::options(mc.cores = 1L)
[17:01:27.342]                   }
[17:01:27.342]                   ...future.strategy.old <- future::plan("list")
[17:01:27.342]                   options(future.plan = NULL)
[17:01:27.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:27.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:27.342]                 }
[17:01:27.342]                 ...future.workdir <- getwd()
[17:01:27.342]             }
[17:01:27.342]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:27.342]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:27.342]         }
[17:01:27.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:27.342]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:27.342]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:27.342]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:27.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:27.342]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:27.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:27.342]             base::names(...future.oldOptions))
[17:01:27.342]     }
[17:01:27.342]     if (FALSE) {
[17:01:27.342]     }
[17:01:27.342]     else {
[17:01:27.342]         if (FALSE) {
[17:01:27.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:27.342]                 open = "w")
[17:01:27.342]         }
[17:01:27.342]         else {
[17:01:27.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:27.342]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:27.342]         }
[17:01:27.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:27.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:27.342]             base::sink(type = "output", split = FALSE)
[17:01:27.342]             base::close(...future.stdout)
[17:01:27.342]         }, add = TRUE)
[17:01:27.342]     }
[17:01:27.342]     ...future.frame <- base::sys.nframe()
[17:01:27.342]     ...future.conditions <- base::list()
[17:01:27.342]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:27.342]     if (FALSE) {
[17:01:27.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:27.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:27.342]     }
[17:01:27.342]     ...future.result <- base::tryCatch({
[17:01:27.342]         base::withCallingHandlers({
[17:01:27.342]             ...future.value <- base::withVisible(base::local({
[17:01:27.342]                 withCallingHandlers({
[17:01:27.342]                   {
[17:01:27.342]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:27.342]                     if (!identical(...future.globals.maxSize.org, 
[17:01:27.342]                       ...future.globals.maxSize)) {
[17:01:27.342]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:27.342]                       on.exit(options(oopts), add = TRUE)
[17:01:27.342]                     }
[17:01:27.342]                     {
[17:01:27.342]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:27.342]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:27.342]                         USE.NAMES = FALSE)
[17:01:27.342]                       do.call(mapply, args = args)
[17:01:27.342]                     }
[17:01:27.342]                   }
[17:01:27.342]                 }, immediateCondition = function(cond) {
[17:01:27.342]                   save_rds <- function (object, pathname, ...) 
[17:01:27.342]                   {
[17:01:27.342]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:27.342]                     if (file_test("-f", pathname_tmp)) {
[17:01:27.342]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.342]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:27.342]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.342]                         fi_tmp[["mtime"]])
[17:01:27.342]                     }
[17:01:27.342]                     tryCatch({
[17:01:27.342]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:27.342]                     }, error = function(ex) {
[17:01:27.342]                       msg <- conditionMessage(ex)
[17:01:27.342]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.342]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:27.342]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.342]                         fi_tmp[["mtime"]], msg)
[17:01:27.342]                       ex$message <- msg
[17:01:27.342]                       stop(ex)
[17:01:27.342]                     })
[17:01:27.342]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:27.342]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:27.342]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:27.342]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.342]                       fi <- file.info(pathname)
[17:01:27.342]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:27.342]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.342]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:27.342]                         fi[["size"]], fi[["mtime"]])
[17:01:27.342]                       stop(msg)
[17:01:27.342]                     }
[17:01:27.342]                     invisible(pathname)
[17:01:27.342]                   }
[17:01:27.342]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:27.342]                     rootPath = tempdir()) 
[17:01:27.342]                   {
[17:01:27.342]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:27.342]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:27.342]                       tmpdir = path, fileext = ".rds")
[17:01:27.342]                     save_rds(obj, file)
[17:01:27.342]                   }
[17:01:27.342]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:27.342]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.342]                   {
[17:01:27.342]                     inherits <- base::inherits
[17:01:27.342]                     invokeRestart <- base::invokeRestart
[17:01:27.342]                     is.null <- base::is.null
[17:01:27.342]                     muffled <- FALSE
[17:01:27.342]                     if (inherits(cond, "message")) {
[17:01:27.342]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:27.342]                       if (muffled) 
[17:01:27.342]                         invokeRestart("muffleMessage")
[17:01:27.342]                     }
[17:01:27.342]                     else if (inherits(cond, "warning")) {
[17:01:27.342]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:27.342]                       if (muffled) 
[17:01:27.342]                         invokeRestart("muffleWarning")
[17:01:27.342]                     }
[17:01:27.342]                     else if (inherits(cond, "condition")) {
[17:01:27.342]                       if (!is.null(pattern)) {
[17:01:27.342]                         computeRestarts <- base::computeRestarts
[17:01:27.342]                         grepl <- base::grepl
[17:01:27.342]                         restarts <- computeRestarts(cond)
[17:01:27.342]                         for (restart in restarts) {
[17:01:27.342]                           name <- restart$name
[17:01:27.342]                           if (is.null(name)) 
[17:01:27.342]                             next
[17:01:27.342]                           if (!grepl(pattern, name)) 
[17:01:27.342]                             next
[17:01:27.342]                           invokeRestart(restart)
[17:01:27.342]                           muffled <- TRUE
[17:01:27.342]                           break
[17:01:27.342]                         }
[17:01:27.342]                       }
[17:01:27.342]                     }
[17:01:27.342]                     invisible(muffled)
[17:01:27.342]                   }
[17:01:27.342]                   muffleCondition(cond)
[17:01:27.342]                 })
[17:01:27.342]             }))
[17:01:27.342]             future::FutureResult(value = ...future.value$value, 
[17:01:27.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:27.342]                   ...future.rng), globalenv = if (FALSE) 
[17:01:27.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:27.342]                     ...future.globalenv.names))
[17:01:27.342]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:27.342]         }, condition = base::local({
[17:01:27.342]             c <- base::c
[17:01:27.342]             inherits <- base::inherits
[17:01:27.342]             invokeRestart <- base::invokeRestart
[17:01:27.342]             length <- base::length
[17:01:27.342]             list <- base::list
[17:01:27.342]             seq.int <- base::seq.int
[17:01:27.342]             signalCondition <- base::signalCondition
[17:01:27.342]             sys.calls <- base::sys.calls
[17:01:27.342]             `[[` <- base::`[[`
[17:01:27.342]             `+` <- base::`+`
[17:01:27.342]             `<<-` <- base::`<<-`
[17:01:27.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:27.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:27.342]                   3L)]
[17:01:27.342]             }
[17:01:27.342]             function(cond) {
[17:01:27.342]                 is_error <- inherits(cond, "error")
[17:01:27.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:27.342]                   NULL)
[17:01:27.342]                 if (is_error) {
[17:01:27.342]                   sessionInformation <- function() {
[17:01:27.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:27.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:27.342]                       search = base::search(), system = base::Sys.info())
[17:01:27.342]                   }
[17:01:27.342]                   ...future.conditions[[length(...future.conditions) + 
[17:01:27.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:27.342]                     cond$call), session = sessionInformation(), 
[17:01:27.342]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:27.342]                   signalCondition(cond)
[17:01:27.342]                 }
[17:01:27.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:27.342]                 "immediateCondition"))) {
[17:01:27.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:27.342]                   ...future.conditions[[length(...future.conditions) + 
[17:01:27.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:27.342]                   if (TRUE && !signal) {
[17:01:27.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.342]                     {
[17:01:27.342]                       inherits <- base::inherits
[17:01:27.342]                       invokeRestart <- base::invokeRestart
[17:01:27.342]                       is.null <- base::is.null
[17:01:27.342]                       muffled <- FALSE
[17:01:27.342]                       if (inherits(cond, "message")) {
[17:01:27.342]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:27.342]                         if (muffled) 
[17:01:27.342]                           invokeRestart("muffleMessage")
[17:01:27.342]                       }
[17:01:27.342]                       else if (inherits(cond, "warning")) {
[17:01:27.342]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:27.342]                         if (muffled) 
[17:01:27.342]                           invokeRestart("muffleWarning")
[17:01:27.342]                       }
[17:01:27.342]                       else if (inherits(cond, "condition")) {
[17:01:27.342]                         if (!is.null(pattern)) {
[17:01:27.342]                           computeRestarts <- base::computeRestarts
[17:01:27.342]                           grepl <- base::grepl
[17:01:27.342]                           restarts <- computeRestarts(cond)
[17:01:27.342]                           for (restart in restarts) {
[17:01:27.342]                             name <- restart$name
[17:01:27.342]                             if (is.null(name)) 
[17:01:27.342]                               next
[17:01:27.342]                             if (!grepl(pattern, name)) 
[17:01:27.342]                               next
[17:01:27.342]                             invokeRestart(restart)
[17:01:27.342]                             muffled <- TRUE
[17:01:27.342]                             break
[17:01:27.342]                           }
[17:01:27.342]                         }
[17:01:27.342]                       }
[17:01:27.342]                       invisible(muffled)
[17:01:27.342]                     }
[17:01:27.342]                     muffleCondition(cond, pattern = "^muffle")
[17:01:27.342]                   }
[17:01:27.342]                 }
[17:01:27.342]                 else {
[17:01:27.342]                   if (TRUE) {
[17:01:27.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.342]                     {
[17:01:27.342]                       inherits <- base::inherits
[17:01:27.342]                       invokeRestart <- base::invokeRestart
[17:01:27.342]                       is.null <- base::is.null
[17:01:27.342]                       muffled <- FALSE
[17:01:27.342]                       if (inherits(cond, "message")) {
[17:01:27.342]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:27.342]                         if (muffled) 
[17:01:27.342]                           invokeRestart("muffleMessage")
[17:01:27.342]                       }
[17:01:27.342]                       else if (inherits(cond, "warning")) {
[17:01:27.342]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:27.342]                         if (muffled) 
[17:01:27.342]                           invokeRestart("muffleWarning")
[17:01:27.342]                       }
[17:01:27.342]                       else if (inherits(cond, "condition")) {
[17:01:27.342]                         if (!is.null(pattern)) {
[17:01:27.342]                           computeRestarts <- base::computeRestarts
[17:01:27.342]                           grepl <- base::grepl
[17:01:27.342]                           restarts <- computeRestarts(cond)
[17:01:27.342]                           for (restart in restarts) {
[17:01:27.342]                             name <- restart$name
[17:01:27.342]                             if (is.null(name)) 
[17:01:27.342]                               next
[17:01:27.342]                             if (!grepl(pattern, name)) 
[17:01:27.342]                               next
[17:01:27.342]                             invokeRestart(restart)
[17:01:27.342]                             muffled <- TRUE
[17:01:27.342]                             break
[17:01:27.342]                           }
[17:01:27.342]                         }
[17:01:27.342]                       }
[17:01:27.342]                       invisible(muffled)
[17:01:27.342]                     }
[17:01:27.342]                     muffleCondition(cond, pattern = "^muffle")
[17:01:27.342]                   }
[17:01:27.342]                 }
[17:01:27.342]             }
[17:01:27.342]         }))
[17:01:27.342]     }, error = function(ex) {
[17:01:27.342]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:27.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:27.342]                 ...future.rng), started = ...future.startTime, 
[17:01:27.342]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:27.342]             version = "1.8"), class = "FutureResult")
[17:01:27.342]     }, finally = {
[17:01:27.342]         if (!identical(...future.workdir, getwd())) 
[17:01:27.342]             setwd(...future.workdir)
[17:01:27.342]         {
[17:01:27.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:27.342]                 ...future.oldOptions$nwarnings <- NULL
[17:01:27.342]             }
[17:01:27.342]             base::options(...future.oldOptions)
[17:01:27.342]             if (.Platform$OS.type == "windows") {
[17:01:27.342]                 old_names <- names(...future.oldEnvVars)
[17:01:27.342]                 envs <- base::Sys.getenv()
[17:01:27.342]                 names <- names(envs)
[17:01:27.342]                 common <- intersect(names, old_names)
[17:01:27.342]                 added <- setdiff(names, old_names)
[17:01:27.342]                 removed <- setdiff(old_names, names)
[17:01:27.342]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:27.342]                   envs[common]]
[17:01:27.342]                 NAMES <- toupper(changed)
[17:01:27.342]                 args <- list()
[17:01:27.342]                 for (kk in seq_along(NAMES)) {
[17:01:27.342]                   name <- changed[[kk]]
[17:01:27.342]                   NAME <- NAMES[[kk]]
[17:01:27.342]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.342]                     next
[17:01:27.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:27.342]                 }
[17:01:27.342]                 NAMES <- toupper(added)
[17:01:27.342]                 for (kk in seq_along(NAMES)) {
[17:01:27.342]                   name <- added[[kk]]
[17:01:27.342]                   NAME <- NAMES[[kk]]
[17:01:27.342]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.342]                     next
[17:01:27.342]                   args[[name]] <- ""
[17:01:27.342]                 }
[17:01:27.342]                 NAMES <- toupper(removed)
[17:01:27.342]                 for (kk in seq_along(NAMES)) {
[17:01:27.342]                   name <- removed[[kk]]
[17:01:27.342]                   NAME <- NAMES[[kk]]
[17:01:27.342]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.342]                     next
[17:01:27.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:27.342]                 }
[17:01:27.342]                 if (length(args) > 0) 
[17:01:27.342]                   base::do.call(base::Sys.setenv, args = args)
[17:01:27.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:27.342]             }
[17:01:27.342]             else {
[17:01:27.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:27.342]             }
[17:01:27.342]             {
[17:01:27.342]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:27.342]                   0L) {
[17:01:27.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:27.342]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:27.342]                   base::options(opts)
[17:01:27.342]                 }
[17:01:27.342]                 {
[17:01:27.342]                   {
[17:01:27.342]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:27.342]                     NULL
[17:01:27.342]                   }
[17:01:27.342]                   options(future.plan = NULL)
[17:01:27.342]                   if (is.na(NA_character_)) 
[17:01:27.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:27.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:27.342]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:27.342]                     .init = FALSE)
[17:01:27.342]                 }
[17:01:27.342]             }
[17:01:27.342]         }
[17:01:27.342]     })
[17:01:27.342]     if (TRUE) {
[17:01:27.342]         base::sink(type = "output", split = FALSE)
[17:01:27.342]         if (FALSE) {
[17:01:27.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:27.342]         }
[17:01:27.342]         else {
[17:01:27.342]             ...future.result["stdout"] <- base::list(NULL)
[17:01:27.342]         }
[17:01:27.342]         base::close(...future.stdout)
[17:01:27.342]         ...future.stdout <- NULL
[17:01:27.342]     }
[17:01:27.342]     ...future.result$conditions <- ...future.conditions
[17:01:27.342]     ...future.result$finished <- base::Sys.time()
[17:01:27.342]     ...future.result
[17:01:27.342] }
[17:01:27.345] assign_globals() ...
[17:01:27.346] List of 5
[17:01:27.346]  $ ...future.FUN            :function (x, y)  
[17:01:27.346]  $ MoreArgs                 : NULL
[17:01:27.346]  $ ...future.elements_ii    :List of 2
[17:01:27.346]   ..$ :List of 1
[17:01:27.346]   .. ..$ : int 0
[17:01:27.346]   ..$ :List of 1
[17:01:27.346]   .. ..$ : int 1
[17:01:27.346]  $ ...future.seeds_ii       : NULL
[17:01:27.346]  $ ...future.globals.maxSize: NULL
[17:01:27.346]  - attr(*, "where")=List of 5
[17:01:27.346]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:27.346]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:27.346]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:27.346]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:27.346]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:27.346]  - attr(*, "resolved")= logi FALSE
[17:01:27.346]  - attr(*, "total_size")= num 6368
[17:01:27.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:27.346]  - attr(*, "already-done")= logi TRUE
[17:01:27.354] - reassign environment for ‘...future.FUN’
[17:01:27.354] - copied ‘...future.FUN’ to environment
[17:01:27.355] - copied ‘MoreArgs’ to environment
[17:01:27.355] - copied ‘...future.elements_ii’ to environment
[17:01:27.355] - copied ‘...future.seeds_ii’ to environment
[17:01:27.355] - copied ‘...future.globals.maxSize’ to environment
[17:01:27.355] assign_globals() ... done
[17:01:27.355] requestCore(): workers = 2
[17:01:27.358] MulticoreFuture started
[17:01:27.358] - Launch lazy future ... done
[17:01:27.358] run() for ‘MulticoreFuture’ ... done
[17:01:27.358] Created future:
[17:01:27.359] plan(): Setting new future strategy stack:
[17:01:27.359] List of future strategies:
[17:01:27.359] 1. sequential:
[17:01:27.359]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:27.359]    - tweaked: FALSE
[17:01:27.359]    - call: NULL
[17:01:27.360] plan(): nbrOfWorkers() = 1
[17:01:27.362] plan(): Setting new future strategy stack:
[17:01:27.362] List of future strategies:
[17:01:27.362] 1. multicore:
[17:01:27.362]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:27.362]    - tweaked: FALSE
[17:01:27.362]    - call: plan(strategy)
[17:01:27.367] plan(): nbrOfWorkers() = 2
[17:01:27.359] MulticoreFuture:
[17:01:27.359] Label: ‘future_mapply-2’
[17:01:27.359] Expression:
[17:01:27.359] {
[17:01:27.359]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:27.359]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:27.359]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:27.359]         on.exit(options(oopts), add = TRUE)
[17:01:27.359]     }
[17:01:27.359]     {
[17:01:27.359]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:27.359]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:27.359]         do.call(mapply, args = args)
[17:01:27.359]     }
[17:01:27.359] }
[17:01:27.359] Lazy evaluation: FALSE
[17:01:27.359] Asynchronous evaluation: TRUE
[17:01:27.359] Local evaluation: TRUE
[17:01:27.359] Environment: R_GlobalEnv
[17:01:27.359] Capture standard output: FALSE
[17:01:27.359] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:27.359] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:27.359] Packages: <none>
[17:01:27.359] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:27.359] Resolved: TRUE
[17:01:27.359] Value: <not collected>
[17:01:27.359] Conditions captured: <none>
[17:01:27.359] Early signaling: FALSE
[17:01:27.359] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:27.359] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:27.368] Chunk #2 of 2 ... DONE
[17:01:27.369] Launching 2 futures (chunks) ... DONE
[17:01:27.369] Resolving 2 futures (chunks) ...
[17:01:27.369] resolve() on list ...
[17:01:27.369]  recursive: 0
[17:01:27.369]  length: 2
[17:01:27.369] 
[17:01:27.380] Future #2
[17:01:27.380] result() for MulticoreFuture ...
[17:01:27.381] result() for MulticoreFuture ...
[17:01:27.381] result() for MulticoreFuture ... done
[17:01:27.382] result() for MulticoreFuture ... done
[17:01:27.382] result() for MulticoreFuture ...
[17:01:27.382] result() for MulticoreFuture ... done
[17:01:27.382] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:27.382] - nx: 2
[17:01:27.382] - relay: TRUE
[17:01:27.382] - stdout: TRUE
[17:01:27.383] - signal: TRUE
[17:01:27.383] - resignal: FALSE
[17:01:27.383] - force: TRUE
[17:01:27.383] - relayed: [n=2] FALSE, FALSE
[17:01:27.383] - queued futures: [n=2] FALSE, FALSE
[17:01:27.383]  - until=1
[17:01:27.383]  - relaying element #1
[17:01:27.384] - relayed: [n=2] FALSE, FALSE
[17:01:27.384] - queued futures: [n=2] FALSE, TRUE
[17:01:27.384] signalConditionsASAP(NULL, pos=2) ... done
[17:01:27.384]  length: 1 (resolved future 2)
[17:01:27.812] plan(): Setting new future strategy stack:
[17:01:27.813] List of future strategies:
[17:01:27.813] 1. multicore:
[17:01:27.813]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:27.813]    - tweaked: FALSE
[17:01:27.813]    - call: plan(strategy)
[17:01:27.817] plan(): nbrOfWorkers() = 2
[17:01:27.824] Future #1
[17:01:27.824] result() for MulticoreFuture ...
[17:01:27.825] result() for MulticoreFuture ...
[17:01:27.825] result() for MulticoreFuture ... done
[17:01:27.825] result() for MulticoreFuture ... done
[17:01:27.825] result() for MulticoreFuture ...
[17:01:27.825] result() for MulticoreFuture ... done
[17:01:27.825] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:27.825] - nx: 2
[17:01:27.825] - relay: TRUE
[17:01:27.826] - stdout: TRUE
[17:01:27.826] - signal: TRUE
[17:01:27.826] - resignal: FALSE
[17:01:27.826] - force: TRUE
[17:01:27.826] - relayed: [n=2] FALSE, FALSE
[17:01:27.826] - queued futures: [n=2] FALSE, TRUE
[17:01:27.826]  - until=1
[17:01:27.826]  - relaying element #1
[17:01:27.826] result() for MulticoreFuture ...
[17:01:27.827] result() for MulticoreFuture ... done
[17:01:27.827] result() for MulticoreFuture ...
[17:01:27.827] result() for MulticoreFuture ... done
[17:01:27.827] result() for MulticoreFuture ...
[17:01:27.827] result() for MulticoreFuture ... done
[17:01:27.827] result() for MulticoreFuture ...
[17:01:27.827] result() for MulticoreFuture ... done
[17:01:27.828] - relayed: [n=2] TRUE, FALSE
[17:01:27.828] - queued futures: [n=2] TRUE, TRUE
[17:01:27.828] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:27.828]  length: 0 (resolved future 1)
[17:01:27.828] Relaying remaining futures
[17:01:27.828] signalConditionsASAP(NULL, pos=0) ...
[17:01:27.828] - nx: 2
[17:01:27.828] - relay: TRUE
[17:01:27.828] - stdout: TRUE
[17:01:27.829] - signal: TRUE
[17:01:27.829] - resignal: FALSE
[17:01:27.829] - force: TRUE
[17:01:27.829] - relayed: [n=2] TRUE, FALSE
[17:01:27.829] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:27.829]  - relaying element #2
[17:01:27.829] result() for MulticoreFuture ...
[17:01:27.829] result() for MulticoreFuture ... done
[17:01:27.830] result() for MulticoreFuture ...
[17:01:27.830] result() for MulticoreFuture ... done
[17:01:27.830] result() for MulticoreFuture ...
[17:01:27.830] result() for MulticoreFuture ... done
[17:01:27.830] result() for MulticoreFuture ...
[17:01:27.830] result() for MulticoreFuture ... done
[17:01:27.830] - relayed: [n=2] TRUE, TRUE
[17:01:27.830] - queued futures: [n=2] TRUE, TRUE
[17:01:27.830] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:01:27.831] resolve() on list ... DONE
[17:01:27.831] result() for MulticoreFuture ...
[17:01:27.831] result() for MulticoreFuture ... done
[17:01:27.831] result() for MulticoreFuture ...
[17:01:27.831] result() for MulticoreFuture ... done
[17:01:27.831] result() for MulticoreFuture ...
[17:01:27.831] result() for MulticoreFuture ... done
[17:01:27.831] result() for MulticoreFuture ...
[17:01:27.831] result() for MulticoreFuture ... done
[17:01:27.832]  - Number of value chunks collected: 2
[17:01:27.832] Resolving 2 futures (chunks) ... DONE
[17:01:27.832] Reducing values from 2 chunks ...
[17:01:27.832]  - Number of values collected after concatenation: 2
[17:01:27.832]  - Number of values expected: 2
[17:01:27.832] Reducing values from 2 chunks ... DONE
[17:01:27.832] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:01:27.833] future_mapply() ...
[17:01:27.840] Number of chunks: 2
[17:01:27.841] getGlobalsAndPackagesXApply() ...
[17:01:27.841]  - future.globals: TRUE
[17:01:27.841] getGlobalsAndPackages() ...
[17:01:27.841] Searching for globals...
[17:01:27.844] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:27.844] Searching for globals ... DONE
[17:01:27.844] Resolving globals: FALSE
[17:01:27.844] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:27.845] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:27.845] - globals: [1] ‘FUN’
[17:01:27.845] 
[17:01:27.845] getGlobalsAndPackages() ... DONE
[17:01:27.845]  - globals found/used: [n=1] ‘FUN’
[17:01:27.845]  - needed namespaces: [n=0] 
[17:01:27.846] Finding globals ... DONE
[17:01:27.846] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:27.846] List of 2
[17:01:27.846]  $ ...future.FUN:function (x, y)  
[17:01:27.846]  $ MoreArgs     : NULL
[17:01:27.846]  - attr(*, "where")=List of 2
[17:01:27.846]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:27.846]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:27.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:27.846]  - attr(*, "resolved")= logi FALSE
[17:01:27.846]  - attr(*, "total_size")= num NA
[17:01:27.849] Packages to be attached in all futures: [n=0] 
[17:01:27.849] getGlobalsAndPackagesXApply() ... DONE
[17:01:27.849] Number of futures (= number of chunks): 2
[17:01:27.850] Launching 2 futures (chunks) ...
[17:01:27.850] Chunk #1 of 2 ...
[17:01:27.850]  - Finding globals in '...' for chunk #1 ...
[17:01:27.850] getGlobalsAndPackages() ...
[17:01:27.850] Searching for globals...
[17:01:27.850] 
[17:01:27.850] Searching for globals ... DONE
[17:01:27.851] - globals: [0] <none>
[17:01:27.851] getGlobalsAndPackages() ... DONE
[17:01:27.851]    + additional globals found: [n=0] 
[17:01:27.851]    + additional namespaces needed: [n=0] 
[17:01:27.851]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:27.851]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:27.851]  - seeds: <none>
[17:01:27.851]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.851] getGlobalsAndPackages() ...
[17:01:27.851] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.852] Resolving globals: FALSE
[17:01:27.852] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:27.853] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:27.853] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.853] 
[17:01:27.853] getGlobalsAndPackages() ... DONE
[17:01:27.853] run() for ‘Future’ ...
[17:01:27.853] - state: ‘created’
[17:01:27.853] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:27.857] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:27.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:27.858]   - Field: ‘label’
[17:01:27.858]   - Field: ‘local’
[17:01:27.858]   - Field: ‘owner’
[17:01:27.858]   - Field: ‘envir’
[17:01:27.858]   - Field: ‘workers’
[17:01:27.858]   - Field: ‘packages’
[17:01:27.858]   - Field: ‘gc’
[17:01:27.858]   - Field: ‘job’
[17:01:27.858]   - Field: ‘conditions’
[17:01:27.858]   - Field: ‘expr’
[17:01:27.858]   - Field: ‘uuid’
[17:01:27.859]   - Field: ‘seed’
[17:01:27.859]   - Field: ‘version’
[17:01:27.859]   - Field: ‘result’
[17:01:27.859]   - Field: ‘asynchronous’
[17:01:27.859]   - Field: ‘calls’
[17:01:27.859]   - Field: ‘globals’
[17:01:27.859]   - Field: ‘stdout’
[17:01:27.859]   - Field: ‘earlySignal’
[17:01:27.859]   - Field: ‘lazy’
[17:01:27.859]   - Field: ‘state’
[17:01:27.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:27.860] - Launch lazy future ...
[17:01:27.860] Packages needed by the future expression (n = 0): <none>
[17:01:27.860] Packages needed by future strategies (n = 0): <none>
[17:01:27.861] {
[17:01:27.861]     {
[17:01:27.861]         {
[17:01:27.861]             ...future.startTime <- base::Sys.time()
[17:01:27.861]             {
[17:01:27.861]                 {
[17:01:27.861]                   {
[17:01:27.861]                     {
[17:01:27.861]                       base::local({
[17:01:27.861]                         has_future <- base::requireNamespace("future", 
[17:01:27.861]                           quietly = TRUE)
[17:01:27.861]                         if (has_future) {
[17:01:27.861]                           ns <- base::getNamespace("future")
[17:01:27.861]                           version <- ns[[".package"]][["version"]]
[17:01:27.861]                           if (is.null(version)) 
[17:01:27.861]                             version <- utils::packageVersion("future")
[17:01:27.861]                         }
[17:01:27.861]                         else {
[17:01:27.861]                           version <- NULL
[17:01:27.861]                         }
[17:01:27.861]                         if (!has_future || version < "1.8.0") {
[17:01:27.861]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:27.861]                             "", base::R.version$version.string), 
[17:01:27.861]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:27.861]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:27.861]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:27.861]                               "release", "version")], collapse = " "), 
[17:01:27.861]                             hostname = base::Sys.info()[["nodename"]])
[17:01:27.861]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:27.861]                             info)
[17:01:27.861]                           info <- base::paste(info, collapse = "; ")
[17:01:27.861]                           if (!has_future) {
[17:01:27.861]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:27.861]                               info)
[17:01:27.861]                           }
[17:01:27.861]                           else {
[17:01:27.861]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:27.861]                               info, version)
[17:01:27.861]                           }
[17:01:27.861]                           base::stop(msg)
[17:01:27.861]                         }
[17:01:27.861]                       })
[17:01:27.861]                     }
[17:01:27.861]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:27.861]                     base::options(mc.cores = 1L)
[17:01:27.861]                   }
[17:01:27.861]                   ...future.strategy.old <- future::plan("list")
[17:01:27.861]                   options(future.plan = NULL)
[17:01:27.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:27.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:27.861]                 }
[17:01:27.861]                 ...future.workdir <- getwd()
[17:01:27.861]             }
[17:01:27.861]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:27.861]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:27.861]         }
[17:01:27.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:27.861]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:27.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:27.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:27.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:27.861]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:27.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:27.861]             base::names(...future.oldOptions))
[17:01:27.861]     }
[17:01:27.861]     if (FALSE) {
[17:01:27.861]     }
[17:01:27.861]     else {
[17:01:27.861]         if (TRUE) {
[17:01:27.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:27.861]                 open = "w")
[17:01:27.861]         }
[17:01:27.861]         else {
[17:01:27.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:27.861]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:27.861]         }
[17:01:27.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:27.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:27.861]             base::sink(type = "output", split = FALSE)
[17:01:27.861]             base::close(...future.stdout)
[17:01:27.861]         }, add = TRUE)
[17:01:27.861]     }
[17:01:27.861]     ...future.frame <- base::sys.nframe()
[17:01:27.861]     ...future.conditions <- base::list()
[17:01:27.861]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:27.861]     if (FALSE) {
[17:01:27.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:27.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:27.861]     }
[17:01:27.861]     ...future.result <- base::tryCatch({
[17:01:27.861]         base::withCallingHandlers({
[17:01:27.861]             ...future.value <- base::withVisible(base::local({
[17:01:27.861]                 withCallingHandlers({
[17:01:27.861]                   {
[17:01:27.861]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:27.861]                     if (!identical(...future.globals.maxSize.org, 
[17:01:27.861]                       ...future.globals.maxSize)) {
[17:01:27.861]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:27.861]                       on.exit(options(oopts), add = TRUE)
[17:01:27.861]                     }
[17:01:27.861]                     {
[17:01:27.861]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:27.861]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:27.861]                         USE.NAMES = FALSE)
[17:01:27.861]                       do.call(mapply, args = args)
[17:01:27.861]                     }
[17:01:27.861]                   }
[17:01:27.861]                 }, immediateCondition = function(cond) {
[17:01:27.861]                   save_rds <- function (object, pathname, ...) 
[17:01:27.861]                   {
[17:01:27.861]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:27.861]                     if (file_test("-f", pathname_tmp)) {
[17:01:27.861]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.861]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:27.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.861]                         fi_tmp[["mtime"]])
[17:01:27.861]                     }
[17:01:27.861]                     tryCatch({
[17:01:27.861]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:27.861]                     }, error = function(ex) {
[17:01:27.861]                       msg <- conditionMessage(ex)
[17:01:27.861]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.861]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:27.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.861]                         fi_tmp[["mtime"]], msg)
[17:01:27.861]                       ex$message <- msg
[17:01:27.861]                       stop(ex)
[17:01:27.861]                     })
[17:01:27.861]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:27.861]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:27.861]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:27.861]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.861]                       fi <- file.info(pathname)
[17:01:27.861]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:27.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.861]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:27.861]                         fi[["size"]], fi[["mtime"]])
[17:01:27.861]                       stop(msg)
[17:01:27.861]                     }
[17:01:27.861]                     invisible(pathname)
[17:01:27.861]                   }
[17:01:27.861]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:27.861]                     rootPath = tempdir()) 
[17:01:27.861]                   {
[17:01:27.861]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:27.861]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:27.861]                       tmpdir = path, fileext = ".rds")
[17:01:27.861]                     save_rds(obj, file)
[17:01:27.861]                   }
[17:01:27.861]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:27.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.861]                   {
[17:01:27.861]                     inherits <- base::inherits
[17:01:27.861]                     invokeRestart <- base::invokeRestart
[17:01:27.861]                     is.null <- base::is.null
[17:01:27.861]                     muffled <- FALSE
[17:01:27.861]                     if (inherits(cond, "message")) {
[17:01:27.861]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:27.861]                       if (muffled) 
[17:01:27.861]                         invokeRestart("muffleMessage")
[17:01:27.861]                     }
[17:01:27.861]                     else if (inherits(cond, "warning")) {
[17:01:27.861]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:27.861]                       if (muffled) 
[17:01:27.861]                         invokeRestart("muffleWarning")
[17:01:27.861]                     }
[17:01:27.861]                     else if (inherits(cond, "condition")) {
[17:01:27.861]                       if (!is.null(pattern)) {
[17:01:27.861]                         computeRestarts <- base::computeRestarts
[17:01:27.861]                         grepl <- base::grepl
[17:01:27.861]                         restarts <- computeRestarts(cond)
[17:01:27.861]                         for (restart in restarts) {
[17:01:27.861]                           name <- restart$name
[17:01:27.861]                           if (is.null(name)) 
[17:01:27.861]                             next
[17:01:27.861]                           if (!grepl(pattern, name)) 
[17:01:27.861]                             next
[17:01:27.861]                           invokeRestart(restart)
[17:01:27.861]                           muffled <- TRUE
[17:01:27.861]                           break
[17:01:27.861]                         }
[17:01:27.861]                       }
[17:01:27.861]                     }
[17:01:27.861]                     invisible(muffled)
[17:01:27.861]                   }
[17:01:27.861]                   muffleCondition(cond)
[17:01:27.861]                 })
[17:01:27.861]             }))
[17:01:27.861]             future::FutureResult(value = ...future.value$value, 
[17:01:27.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:27.861]                   ...future.rng), globalenv = if (FALSE) 
[17:01:27.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:27.861]                     ...future.globalenv.names))
[17:01:27.861]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:27.861]         }, condition = base::local({
[17:01:27.861]             c <- base::c
[17:01:27.861]             inherits <- base::inherits
[17:01:27.861]             invokeRestart <- base::invokeRestart
[17:01:27.861]             length <- base::length
[17:01:27.861]             list <- base::list
[17:01:27.861]             seq.int <- base::seq.int
[17:01:27.861]             signalCondition <- base::signalCondition
[17:01:27.861]             sys.calls <- base::sys.calls
[17:01:27.861]             `[[` <- base::`[[`
[17:01:27.861]             `+` <- base::`+`
[17:01:27.861]             `<<-` <- base::`<<-`
[17:01:27.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:27.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:27.861]                   3L)]
[17:01:27.861]             }
[17:01:27.861]             function(cond) {
[17:01:27.861]                 is_error <- inherits(cond, "error")
[17:01:27.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:27.861]                   NULL)
[17:01:27.861]                 if (is_error) {
[17:01:27.861]                   sessionInformation <- function() {
[17:01:27.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:27.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:27.861]                       search = base::search(), system = base::Sys.info())
[17:01:27.861]                   }
[17:01:27.861]                   ...future.conditions[[length(...future.conditions) + 
[17:01:27.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:27.861]                     cond$call), session = sessionInformation(), 
[17:01:27.861]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:27.861]                   signalCondition(cond)
[17:01:27.861]                 }
[17:01:27.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:27.861]                 "immediateCondition"))) {
[17:01:27.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:27.861]                   ...future.conditions[[length(...future.conditions) + 
[17:01:27.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:27.861]                   if (TRUE && !signal) {
[17:01:27.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.861]                     {
[17:01:27.861]                       inherits <- base::inherits
[17:01:27.861]                       invokeRestart <- base::invokeRestart
[17:01:27.861]                       is.null <- base::is.null
[17:01:27.861]                       muffled <- FALSE
[17:01:27.861]                       if (inherits(cond, "message")) {
[17:01:27.861]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:27.861]                         if (muffled) 
[17:01:27.861]                           invokeRestart("muffleMessage")
[17:01:27.861]                       }
[17:01:27.861]                       else if (inherits(cond, "warning")) {
[17:01:27.861]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:27.861]                         if (muffled) 
[17:01:27.861]                           invokeRestart("muffleWarning")
[17:01:27.861]                       }
[17:01:27.861]                       else if (inherits(cond, "condition")) {
[17:01:27.861]                         if (!is.null(pattern)) {
[17:01:27.861]                           computeRestarts <- base::computeRestarts
[17:01:27.861]                           grepl <- base::grepl
[17:01:27.861]                           restarts <- computeRestarts(cond)
[17:01:27.861]                           for (restart in restarts) {
[17:01:27.861]                             name <- restart$name
[17:01:27.861]                             if (is.null(name)) 
[17:01:27.861]                               next
[17:01:27.861]                             if (!grepl(pattern, name)) 
[17:01:27.861]                               next
[17:01:27.861]                             invokeRestart(restart)
[17:01:27.861]                             muffled <- TRUE
[17:01:27.861]                             break
[17:01:27.861]                           }
[17:01:27.861]                         }
[17:01:27.861]                       }
[17:01:27.861]                       invisible(muffled)
[17:01:27.861]                     }
[17:01:27.861]                     muffleCondition(cond, pattern = "^muffle")
[17:01:27.861]                   }
[17:01:27.861]                 }
[17:01:27.861]                 else {
[17:01:27.861]                   if (TRUE) {
[17:01:27.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.861]                     {
[17:01:27.861]                       inherits <- base::inherits
[17:01:27.861]                       invokeRestart <- base::invokeRestart
[17:01:27.861]                       is.null <- base::is.null
[17:01:27.861]                       muffled <- FALSE
[17:01:27.861]                       if (inherits(cond, "message")) {
[17:01:27.861]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:27.861]                         if (muffled) 
[17:01:27.861]                           invokeRestart("muffleMessage")
[17:01:27.861]                       }
[17:01:27.861]                       else if (inherits(cond, "warning")) {
[17:01:27.861]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:27.861]                         if (muffled) 
[17:01:27.861]                           invokeRestart("muffleWarning")
[17:01:27.861]                       }
[17:01:27.861]                       else if (inherits(cond, "condition")) {
[17:01:27.861]                         if (!is.null(pattern)) {
[17:01:27.861]                           computeRestarts <- base::computeRestarts
[17:01:27.861]                           grepl <- base::grepl
[17:01:27.861]                           restarts <- computeRestarts(cond)
[17:01:27.861]                           for (restart in restarts) {
[17:01:27.861]                             name <- restart$name
[17:01:27.861]                             if (is.null(name)) 
[17:01:27.861]                               next
[17:01:27.861]                             if (!grepl(pattern, name)) 
[17:01:27.861]                               next
[17:01:27.861]                             invokeRestart(restart)
[17:01:27.861]                             muffled <- TRUE
[17:01:27.861]                             break
[17:01:27.861]                           }
[17:01:27.861]                         }
[17:01:27.861]                       }
[17:01:27.861]                       invisible(muffled)
[17:01:27.861]                     }
[17:01:27.861]                     muffleCondition(cond, pattern = "^muffle")
[17:01:27.861]                   }
[17:01:27.861]                 }
[17:01:27.861]             }
[17:01:27.861]         }))
[17:01:27.861]     }, error = function(ex) {
[17:01:27.861]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:27.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:27.861]                 ...future.rng), started = ...future.startTime, 
[17:01:27.861]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:27.861]             version = "1.8"), class = "FutureResult")
[17:01:27.861]     }, finally = {
[17:01:27.861]         if (!identical(...future.workdir, getwd())) 
[17:01:27.861]             setwd(...future.workdir)
[17:01:27.861]         {
[17:01:27.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:27.861]                 ...future.oldOptions$nwarnings <- NULL
[17:01:27.861]             }
[17:01:27.861]             base::options(...future.oldOptions)
[17:01:27.861]             if (.Platform$OS.type == "windows") {
[17:01:27.861]                 old_names <- names(...future.oldEnvVars)
[17:01:27.861]                 envs <- base::Sys.getenv()
[17:01:27.861]                 names <- names(envs)
[17:01:27.861]                 common <- intersect(names, old_names)
[17:01:27.861]                 added <- setdiff(names, old_names)
[17:01:27.861]                 removed <- setdiff(old_names, names)
[17:01:27.861]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:27.861]                   envs[common]]
[17:01:27.861]                 NAMES <- toupper(changed)
[17:01:27.861]                 args <- list()
[17:01:27.861]                 for (kk in seq_along(NAMES)) {
[17:01:27.861]                   name <- changed[[kk]]
[17:01:27.861]                   NAME <- NAMES[[kk]]
[17:01:27.861]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.861]                     next
[17:01:27.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:27.861]                 }
[17:01:27.861]                 NAMES <- toupper(added)
[17:01:27.861]                 for (kk in seq_along(NAMES)) {
[17:01:27.861]                   name <- added[[kk]]
[17:01:27.861]                   NAME <- NAMES[[kk]]
[17:01:27.861]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.861]                     next
[17:01:27.861]                   args[[name]] <- ""
[17:01:27.861]                 }
[17:01:27.861]                 NAMES <- toupper(removed)
[17:01:27.861]                 for (kk in seq_along(NAMES)) {
[17:01:27.861]                   name <- removed[[kk]]
[17:01:27.861]                   NAME <- NAMES[[kk]]
[17:01:27.861]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.861]                     next
[17:01:27.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:27.861]                 }
[17:01:27.861]                 if (length(args) > 0) 
[17:01:27.861]                   base::do.call(base::Sys.setenv, args = args)
[17:01:27.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:27.861]             }
[17:01:27.861]             else {
[17:01:27.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:27.861]             }
[17:01:27.861]             {
[17:01:27.861]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:27.861]                   0L) {
[17:01:27.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:27.861]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:27.861]                   base::options(opts)
[17:01:27.861]                 }
[17:01:27.861]                 {
[17:01:27.861]                   {
[17:01:27.861]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:27.861]                     NULL
[17:01:27.861]                   }
[17:01:27.861]                   options(future.plan = NULL)
[17:01:27.861]                   if (is.na(NA_character_)) 
[17:01:27.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:27.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:27.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:27.861]                     .init = FALSE)
[17:01:27.861]                 }
[17:01:27.861]             }
[17:01:27.861]         }
[17:01:27.861]     })
[17:01:27.861]     if (TRUE) {
[17:01:27.861]         base::sink(type = "output", split = FALSE)
[17:01:27.861]         if (TRUE) {
[17:01:27.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:27.861]         }
[17:01:27.861]         else {
[17:01:27.861]             ...future.result["stdout"] <- base::list(NULL)
[17:01:27.861]         }
[17:01:27.861]         base::close(...future.stdout)
[17:01:27.861]         ...future.stdout <- NULL
[17:01:27.861]     }
[17:01:27.861]     ...future.result$conditions <- ...future.conditions
[17:01:27.861]     ...future.result$finished <- base::Sys.time()
[17:01:27.861]     ...future.result
[17:01:27.861] }
[17:01:27.863] assign_globals() ...
[17:01:27.863] List of 5
[17:01:27.863]  $ ...future.FUN            :function (x, y)  
[17:01:27.863]  $ MoreArgs                 : NULL
[17:01:27.863]  $ ...future.elements_ii    :List of 2
[17:01:27.863]   ..$ :List of 1
[17:01:27.863]   .. ..$ : int 1
[17:01:27.863]   ..$ :List of 1
[17:01:27.863]   .. ..$ : int 0
[17:01:27.863]  $ ...future.seeds_ii       : NULL
[17:01:27.863]  $ ...future.globals.maxSize: NULL
[17:01:27.863]  - attr(*, "where")=List of 5
[17:01:27.863]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:27.863]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:27.863]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:27.863]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:27.863]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:27.863]  - attr(*, "resolved")= logi FALSE
[17:01:27.863]  - attr(*, "total_size")= num 6368
[17:01:27.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:27.863]  - attr(*, "already-done")= logi TRUE
[17:01:27.868] - reassign environment for ‘...future.FUN’
[17:01:27.868] - copied ‘...future.FUN’ to environment
[17:01:27.868] - copied ‘MoreArgs’ to environment
[17:01:27.869] - copied ‘...future.elements_ii’ to environment
[17:01:27.869] - copied ‘...future.seeds_ii’ to environment
[17:01:27.869] - copied ‘...future.globals.maxSize’ to environment
[17:01:27.869] assign_globals() ... done
[17:01:27.871] requestCore(): workers = 2
[17:01:27.874] MulticoreFuture started
[17:01:27.874] - Launch lazy future ... done
[17:01:27.875] plan(): Setting new future strategy stack:
[17:01:27.875] run() for ‘MulticoreFuture’ ... done
[17:01:27.875] Created future:
[17:01:27.875] List of future strategies:
[17:01:27.875] 1. sequential:
[17:01:27.875]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:27.875]    - tweaked: FALSE
[17:01:27.875]    - call: NULL
[17:01:27.877] plan(): nbrOfWorkers() = 1
[17:01:27.876] MulticoreFuture:
[17:01:27.876] Label: ‘future_mapply-1’
[17:01:27.876] Expression:
[17:01:27.876] {
[17:01:27.876]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:27.876]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:27.876]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:27.876]         on.exit(options(oopts), add = TRUE)
[17:01:27.876]     }
[17:01:27.876]     {
[17:01:27.876]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:27.876]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:27.876]         do.call(mapply, args = args)
[17:01:27.876]     }
[17:01:27.876] }
[17:01:27.876] Lazy evaluation: FALSE
[17:01:27.876] Asynchronous evaluation: TRUE
[17:01:27.876] Local evaluation: TRUE
[17:01:27.876] Environment: R_GlobalEnv
[17:01:27.876] Capture standard output: TRUE
[17:01:27.876] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:27.876] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:27.876] Packages: <none>
[17:01:27.876] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:27.876] Resolved: FALSE
[17:01:27.876] Value: <not collected>
[17:01:27.876] Conditions captured: <none>
[17:01:27.876] Early signaling: FALSE
[17:01:27.876] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:27.876] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:27.890] Chunk #1 of 2 ... DONE
[17:01:27.890] Chunk #2 of 2 ...
[17:01:27.891]  - Finding globals in '...' for chunk #2 ...
[17:01:27.891] getGlobalsAndPackages() ...
[17:01:27.891] Searching for globals...
[17:01:27.892] 
[17:01:27.892] Searching for globals ... DONE
[17:01:27.893] - globals: [0] <none>
[17:01:27.893] getGlobalsAndPackages() ... DONE
[17:01:27.893]    + additional globals found: [n=0] 
[17:01:27.893]    + additional namespaces needed: [n=0] 
[17:01:27.893]  - Finding globals in '...' for chunk #2 ... DONE
[17:01:27.893]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:27.894]  - seeds: <none>
[17:01:27.894]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.894] getGlobalsAndPackages() ...
[17:01:27.894] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.894] Resolving globals: FALSE
[17:01:27.895] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:27.896] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:27.897] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:27.897] 
[17:01:27.897] getGlobalsAndPackages() ... DONE
[17:01:27.898] run() for ‘Future’ ...
[17:01:27.898] - state: ‘created’
[17:01:27.898] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:27.903] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:27.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:27.903]   - Field: ‘label’
[17:01:27.903]   - Field: ‘local’
[17:01:27.903]   - Field: ‘owner’
[17:01:27.904]   - Field: ‘envir’
[17:01:27.904]   - Field: ‘workers’
[17:01:27.904]   - Field: ‘packages’
[17:01:27.904]   - Field: ‘gc’
[17:01:27.904]   - Field: ‘job’
[17:01:27.904]   - Field: ‘conditions’
[17:01:27.904]   - Field: ‘expr’
[17:01:27.905]   - Field: ‘uuid’
[17:01:27.905]   - Field: ‘seed’
[17:01:27.905]   - Field: ‘version’
[17:01:27.905]   - Field: ‘result’
[17:01:27.905]   - Field: ‘asynchronous’
[17:01:27.905]   - Field: ‘calls’
[17:01:27.905]   - Field: ‘globals’
[17:01:27.906]   - Field: ‘stdout’
[17:01:27.906]   - Field: ‘earlySignal’
[17:01:27.906]   - Field: ‘lazy’
[17:01:27.906]   - Field: ‘state’
[17:01:27.906] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:27.906] - Launch lazy future ...
[17:01:27.907] Packages needed by the future expression (n = 0): <none>
[17:01:27.907] Packages needed by future strategies (n = 0): <none>
[17:01:27.907] {
[17:01:27.907]     {
[17:01:27.907]         {
[17:01:27.907]             ...future.startTime <- base::Sys.time()
[17:01:27.907]             {
[17:01:27.907]                 {
[17:01:27.907]                   {
[17:01:27.907]                     {
[17:01:27.907]                       base::local({
[17:01:27.907]                         has_future <- base::requireNamespace("future", 
[17:01:27.907]                           quietly = TRUE)
[17:01:27.907]                         if (has_future) {
[17:01:27.907]                           ns <- base::getNamespace("future")
[17:01:27.907]                           version <- ns[[".package"]][["version"]]
[17:01:27.907]                           if (is.null(version)) 
[17:01:27.907]                             version <- utils::packageVersion("future")
[17:01:27.907]                         }
[17:01:27.907]                         else {
[17:01:27.907]                           version <- NULL
[17:01:27.907]                         }
[17:01:27.907]                         if (!has_future || version < "1.8.0") {
[17:01:27.907]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:27.907]                             "", base::R.version$version.string), 
[17:01:27.907]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:27.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:27.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:27.907]                               "release", "version")], collapse = " "), 
[17:01:27.907]                             hostname = base::Sys.info()[["nodename"]])
[17:01:27.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:27.907]                             info)
[17:01:27.907]                           info <- base::paste(info, collapse = "; ")
[17:01:27.907]                           if (!has_future) {
[17:01:27.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:27.907]                               info)
[17:01:27.907]                           }
[17:01:27.907]                           else {
[17:01:27.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:27.907]                               info, version)
[17:01:27.907]                           }
[17:01:27.907]                           base::stop(msg)
[17:01:27.907]                         }
[17:01:27.907]                       })
[17:01:27.907]                     }
[17:01:27.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:27.907]                     base::options(mc.cores = 1L)
[17:01:27.907]                   }
[17:01:27.907]                   ...future.strategy.old <- future::plan("list")
[17:01:27.907]                   options(future.plan = NULL)
[17:01:27.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:27.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:27.907]                 }
[17:01:27.907]                 ...future.workdir <- getwd()
[17:01:27.907]             }
[17:01:27.907]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:27.907]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:27.907]         }
[17:01:27.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:27.907]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:27.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:27.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:27.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:27.907]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:27.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:27.907]             base::names(...future.oldOptions))
[17:01:27.907]     }
[17:01:27.907]     if (FALSE) {
[17:01:27.907]     }
[17:01:27.907]     else {
[17:01:27.907]         if (TRUE) {
[17:01:27.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:27.907]                 open = "w")
[17:01:27.907]         }
[17:01:27.907]         else {
[17:01:27.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:27.907]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:27.907]         }
[17:01:27.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:27.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:27.907]             base::sink(type = "output", split = FALSE)
[17:01:27.907]             base::close(...future.stdout)
[17:01:27.907]         }, add = TRUE)
[17:01:27.907]     }
[17:01:27.907]     ...future.frame <- base::sys.nframe()
[17:01:27.907]     ...future.conditions <- base::list()
[17:01:27.907]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:27.907]     if (FALSE) {
[17:01:27.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:27.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:27.907]     }
[17:01:27.907]     ...future.result <- base::tryCatch({
[17:01:27.907]         base::withCallingHandlers({
[17:01:27.907]             ...future.value <- base::withVisible(base::local({
[17:01:27.907]                 withCallingHandlers({
[17:01:27.907]                   {
[17:01:27.907]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:27.907]                     if (!identical(...future.globals.maxSize.org, 
[17:01:27.907]                       ...future.globals.maxSize)) {
[17:01:27.907]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:27.907]                       on.exit(options(oopts), add = TRUE)
[17:01:27.907]                     }
[17:01:27.907]                     {
[17:01:27.907]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:27.907]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:27.907]                         USE.NAMES = FALSE)
[17:01:27.907]                       do.call(mapply, args = args)
[17:01:27.907]                     }
[17:01:27.907]                   }
[17:01:27.907]                 }, immediateCondition = function(cond) {
[17:01:27.907]                   save_rds <- function (object, pathname, ...) 
[17:01:27.907]                   {
[17:01:27.907]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:27.907]                     if (file_test("-f", pathname_tmp)) {
[17:01:27.907]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.907]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:27.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.907]                         fi_tmp[["mtime"]])
[17:01:27.907]                     }
[17:01:27.907]                     tryCatch({
[17:01:27.907]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:27.907]                     }, error = function(ex) {
[17:01:27.907]                       msg <- conditionMessage(ex)
[17:01:27.907]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.907]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:27.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.907]                         fi_tmp[["mtime"]], msg)
[17:01:27.907]                       ex$message <- msg
[17:01:27.907]                       stop(ex)
[17:01:27.907]                     })
[17:01:27.907]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:27.907]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:27.907]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:27.907]                       fi_tmp <- file.info(pathname_tmp)
[17:01:27.907]                       fi <- file.info(pathname)
[17:01:27.907]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:27.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:27.907]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:27.907]                         fi[["size"]], fi[["mtime"]])
[17:01:27.907]                       stop(msg)
[17:01:27.907]                     }
[17:01:27.907]                     invisible(pathname)
[17:01:27.907]                   }
[17:01:27.907]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:27.907]                     rootPath = tempdir()) 
[17:01:27.907]                   {
[17:01:27.907]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:27.907]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:27.907]                       tmpdir = path, fileext = ".rds")
[17:01:27.907]                     save_rds(obj, file)
[17:01:27.907]                   }
[17:01:27.907]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:27.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.907]                   {
[17:01:27.907]                     inherits <- base::inherits
[17:01:27.907]                     invokeRestart <- base::invokeRestart
[17:01:27.907]                     is.null <- base::is.null
[17:01:27.907]                     muffled <- FALSE
[17:01:27.907]                     if (inherits(cond, "message")) {
[17:01:27.907]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:27.907]                       if (muffled) 
[17:01:27.907]                         invokeRestart("muffleMessage")
[17:01:27.907]                     }
[17:01:27.907]                     else if (inherits(cond, "warning")) {
[17:01:27.907]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:27.907]                       if (muffled) 
[17:01:27.907]                         invokeRestart("muffleWarning")
[17:01:27.907]                     }
[17:01:27.907]                     else if (inherits(cond, "condition")) {
[17:01:27.907]                       if (!is.null(pattern)) {
[17:01:27.907]                         computeRestarts <- base::computeRestarts
[17:01:27.907]                         grepl <- base::grepl
[17:01:27.907]                         restarts <- computeRestarts(cond)
[17:01:27.907]                         for (restart in restarts) {
[17:01:27.907]                           name <- restart$name
[17:01:27.907]                           if (is.null(name)) 
[17:01:27.907]                             next
[17:01:27.907]                           if (!grepl(pattern, name)) 
[17:01:27.907]                             next
[17:01:27.907]                           invokeRestart(restart)
[17:01:27.907]                           muffled <- TRUE
[17:01:27.907]                           break
[17:01:27.907]                         }
[17:01:27.907]                       }
[17:01:27.907]                     }
[17:01:27.907]                     invisible(muffled)
[17:01:27.907]                   }
[17:01:27.907]                   muffleCondition(cond)
[17:01:27.907]                 })
[17:01:27.907]             }))
[17:01:27.907]             future::FutureResult(value = ...future.value$value, 
[17:01:27.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:27.907]                   ...future.rng), globalenv = if (FALSE) 
[17:01:27.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:27.907]                     ...future.globalenv.names))
[17:01:27.907]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:27.907]         }, condition = base::local({
[17:01:27.907]             c <- base::c
[17:01:27.907]             inherits <- base::inherits
[17:01:27.907]             invokeRestart <- base::invokeRestart
[17:01:27.907]             length <- base::length
[17:01:27.907]             list <- base::list
[17:01:27.907]             seq.int <- base::seq.int
[17:01:27.907]             signalCondition <- base::signalCondition
[17:01:27.907]             sys.calls <- base::sys.calls
[17:01:27.907]             `[[` <- base::`[[`
[17:01:27.907]             `+` <- base::`+`
[17:01:27.907]             `<<-` <- base::`<<-`
[17:01:27.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:27.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:27.907]                   3L)]
[17:01:27.907]             }
[17:01:27.907]             function(cond) {
[17:01:27.907]                 is_error <- inherits(cond, "error")
[17:01:27.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:27.907]                   NULL)
[17:01:27.907]                 if (is_error) {
[17:01:27.907]                   sessionInformation <- function() {
[17:01:27.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:27.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:27.907]                       search = base::search(), system = base::Sys.info())
[17:01:27.907]                   }
[17:01:27.907]                   ...future.conditions[[length(...future.conditions) + 
[17:01:27.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:27.907]                     cond$call), session = sessionInformation(), 
[17:01:27.907]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:27.907]                   signalCondition(cond)
[17:01:27.907]                 }
[17:01:27.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:27.907]                 "immediateCondition"))) {
[17:01:27.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:27.907]                   ...future.conditions[[length(...future.conditions) + 
[17:01:27.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:27.907]                   if (TRUE && !signal) {
[17:01:27.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.907]                     {
[17:01:27.907]                       inherits <- base::inherits
[17:01:27.907]                       invokeRestart <- base::invokeRestart
[17:01:27.907]                       is.null <- base::is.null
[17:01:27.907]                       muffled <- FALSE
[17:01:27.907]                       if (inherits(cond, "message")) {
[17:01:27.907]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:27.907]                         if (muffled) 
[17:01:27.907]                           invokeRestart("muffleMessage")
[17:01:27.907]                       }
[17:01:27.907]                       else if (inherits(cond, "warning")) {
[17:01:27.907]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:27.907]                         if (muffled) 
[17:01:27.907]                           invokeRestart("muffleWarning")
[17:01:27.907]                       }
[17:01:27.907]                       else if (inherits(cond, "condition")) {
[17:01:27.907]                         if (!is.null(pattern)) {
[17:01:27.907]                           computeRestarts <- base::computeRestarts
[17:01:27.907]                           grepl <- base::grepl
[17:01:27.907]                           restarts <- computeRestarts(cond)
[17:01:27.907]                           for (restart in restarts) {
[17:01:27.907]                             name <- restart$name
[17:01:27.907]                             if (is.null(name)) 
[17:01:27.907]                               next
[17:01:27.907]                             if (!grepl(pattern, name)) 
[17:01:27.907]                               next
[17:01:27.907]                             invokeRestart(restart)
[17:01:27.907]                             muffled <- TRUE
[17:01:27.907]                             break
[17:01:27.907]                           }
[17:01:27.907]                         }
[17:01:27.907]                       }
[17:01:27.907]                       invisible(muffled)
[17:01:27.907]                     }
[17:01:27.907]                     muffleCondition(cond, pattern = "^muffle")
[17:01:27.907]                   }
[17:01:27.907]                 }
[17:01:27.907]                 else {
[17:01:27.907]                   if (TRUE) {
[17:01:27.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:27.907]                     {
[17:01:27.907]                       inherits <- base::inherits
[17:01:27.907]                       invokeRestart <- base::invokeRestart
[17:01:27.907]                       is.null <- base::is.null
[17:01:27.907]                       muffled <- FALSE
[17:01:27.907]                       if (inherits(cond, "message")) {
[17:01:27.907]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:27.907]                         if (muffled) 
[17:01:27.907]                           invokeRestart("muffleMessage")
[17:01:27.907]                       }
[17:01:27.907]                       else if (inherits(cond, "warning")) {
[17:01:27.907]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:27.907]                         if (muffled) 
[17:01:27.907]                           invokeRestart("muffleWarning")
[17:01:27.907]                       }
[17:01:27.907]                       else if (inherits(cond, "condition")) {
[17:01:27.907]                         if (!is.null(pattern)) {
[17:01:27.907]                           computeRestarts <- base::computeRestarts
[17:01:27.907]                           grepl <- base::grepl
[17:01:27.907]                           restarts <- computeRestarts(cond)
[17:01:27.907]                           for (restart in restarts) {
[17:01:27.907]                             name <- restart$name
[17:01:27.907]                             if (is.null(name)) 
[17:01:27.907]                               next
[17:01:27.907]                             if (!grepl(pattern, name)) 
[17:01:27.907]                               next
[17:01:27.907]                             invokeRestart(restart)
[17:01:27.907]                             muffled <- TRUE
[17:01:27.907]                             break
[17:01:27.907]                           }
[17:01:27.907]                         }
[17:01:27.907]                       }
[17:01:27.907]                       invisible(muffled)
[17:01:27.907]                     }
[17:01:27.907]                     muffleCondition(cond, pattern = "^muffle")
[17:01:27.907]                   }
[17:01:27.907]                 }
[17:01:27.907]             }
[17:01:27.907]         }))
[17:01:27.907]     }, error = function(ex) {
[17:01:27.907]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:27.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:27.907]                 ...future.rng), started = ...future.startTime, 
[17:01:27.907]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:27.907]             version = "1.8"), class = "FutureResult")
[17:01:27.907]     }, finally = {
[17:01:27.907]         if (!identical(...future.workdir, getwd())) 
[17:01:27.907]             setwd(...future.workdir)
[17:01:27.907]         {
[17:01:27.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:27.907]                 ...future.oldOptions$nwarnings <- NULL
[17:01:27.907]             }
[17:01:27.907]             base::options(...future.oldOptions)
[17:01:27.907]             if (.Platform$OS.type == "windows") {
[17:01:27.907]                 old_names <- names(...future.oldEnvVars)
[17:01:27.907]                 envs <- base::Sys.getenv()
[17:01:27.907]                 names <- names(envs)
[17:01:27.907]                 common <- intersect(names, old_names)
[17:01:27.907]                 added <- setdiff(names, old_names)
[17:01:27.907]                 removed <- setdiff(old_names, names)
[17:01:27.907]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:27.907]                   envs[common]]
[17:01:27.907]                 NAMES <- toupper(changed)
[17:01:27.907]                 args <- list()
[17:01:27.907]                 for (kk in seq_along(NAMES)) {
[17:01:27.907]                   name <- changed[[kk]]
[17:01:27.907]                   NAME <- NAMES[[kk]]
[17:01:27.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.907]                     next
[17:01:27.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:27.907]                 }
[17:01:27.907]                 NAMES <- toupper(added)
[17:01:27.907]                 for (kk in seq_along(NAMES)) {
[17:01:27.907]                   name <- added[[kk]]
[17:01:27.907]                   NAME <- NAMES[[kk]]
[17:01:27.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.907]                     next
[17:01:27.907]                   args[[name]] <- ""
[17:01:27.907]                 }
[17:01:27.907]                 NAMES <- toupper(removed)
[17:01:27.907]                 for (kk in seq_along(NAMES)) {
[17:01:27.907]                   name <- removed[[kk]]
[17:01:27.907]                   NAME <- NAMES[[kk]]
[17:01:27.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:27.907]                     next
[17:01:27.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:27.907]                 }
[17:01:27.907]                 if (length(args) > 0) 
[17:01:27.907]                   base::do.call(base::Sys.setenv, args = args)
[17:01:27.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:27.907]             }
[17:01:27.907]             else {
[17:01:27.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:27.907]             }
[17:01:27.907]             {
[17:01:27.907]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:27.907]                   0L) {
[17:01:27.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:27.907]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:27.907]                   base::options(opts)
[17:01:27.907]                 }
[17:01:27.907]                 {
[17:01:27.907]                   {
[17:01:27.907]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:27.907]                     NULL
[17:01:27.907]                   }
[17:01:27.907]                   options(future.plan = NULL)
[17:01:27.907]                   if (is.na(NA_character_)) 
[17:01:27.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:27.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:27.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:27.907]                     .init = FALSE)
[17:01:27.907]                 }
[17:01:27.907]             }
[17:01:27.907]         }
[17:01:27.907]     })
[17:01:27.907]     if (TRUE) {
[17:01:27.907]         base::sink(type = "output", split = FALSE)
[17:01:27.907]         if (TRUE) {
[17:01:27.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:27.907]         }
[17:01:27.907]         else {
[17:01:27.907]             ...future.result["stdout"] <- base::list(NULL)
[17:01:27.907]         }
[17:01:27.907]         base::close(...future.stdout)
[17:01:27.907]         ...future.stdout <- NULL
[17:01:27.907]     }
[17:01:27.907]     ...future.result$conditions <- ...future.conditions
[17:01:27.907]     ...future.result$finished <- base::Sys.time()
[17:01:27.907]     ...future.result
[17:01:27.907] }
[17:01:27.911] assign_globals() ...
[17:01:27.911] List of 5
[17:01:27.911]  $ ...future.FUN            :function (x, y)  
[17:01:27.911]  $ MoreArgs                 : NULL
[17:01:27.911]  $ ...future.elements_ii    :List of 2
[17:01:27.911]   ..$ :List of 1
[17:01:27.911]   .. ..$ : int 0
[17:01:27.911]   ..$ :List of 1
[17:01:27.911]   .. ..$ : int 1
[17:01:27.911]  $ ...future.seeds_ii       : NULL
[17:01:27.911]  $ ...future.globals.maxSize: NULL
[17:01:27.911]  - attr(*, "where")=List of 5
[17:01:27.911]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:27.911]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:27.911]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:27.911]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:27.911]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:27.911]  - attr(*, "resolved")= logi FALSE
[17:01:27.911]  - attr(*, "total_size")= num 6368
[17:01:27.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:27.911]  - attr(*, "already-done")= logi TRUE
[17:01:27.918] - reassign environment for ‘...future.FUN’
[17:01:27.918] - copied ‘...future.FUN’ to environment
[17:01:27.918] - copied ‘MoreArgs’ to environment
[17:01:27.918] - copied ‘...future.elements_ii’ to environment
[17:01:27.918] - copied ‘...future.seeds_ii’ to environment
[17:01:27.919] - copied ‘...future.globals.maxSize’ to environment
[17:01:27.919] assign_globals() ... done
[17:01:27.919] requestCore(): workers = 2
[17:01:27.921] MulticoreFuture started
[17:01:27.922] - Launch lazy future ... done
[17:01:27.922] run() for ‘MulticoreFuture’ ... done
[17:01:27.922] Created future:
[17:01:27.922] plan(): Setting new future strategy stack:
[17:01:27.923] List of future strategies:
[17:01:27.923] 1. sequential:
[17:01:27.923]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:27.923]    - tweaked: FALSE
[17:01:27.923]    - call: NULL
[17:01:27.924] plan(): nbrOfWorkers() = 1
[17:01:27.926] plan(): Setting new future strategy stack:
[17:01:27.926] List of future strategies:
[17:01:27.926] 1. multicore:
[17:01:27.926]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:27.926]    - tweaked: FALSE
[17:01:27.926]    - call: plan(strategy)
[17:01:27.931] plan(): nbrOfWorkers() = 2
[17:01:27.922] MulticoreFuture:
[17:01:27.922] Label: ‘future_mapply-2’
[17:01:27.922] Expression:
[17:01:27.922] {
[17:01:27.922]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:27.922]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:27.922]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:27.922]         on.exit(options(oopts), add = TRUE)
[17:01:27.922]     }
[17:01:27.922]     {
[17:01:27.922]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:27.922]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:27.922]         do.call(mapply, args = args)
[17:01:27.922]     }
[17:01:27.922] }
[17:01:27.922] Lazy evaluation: FALSE
[17:01:27.922] Asynchronous evaluation: TRUE
[17:01:27.922] Local evaluation: TRUE
[17:01:27.922] Environment: R_GlobalEnv
[17:01:27.922] Capture standard output: TRUE
[17:01:27.922] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:27.922] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:27.922] Packages: <none>
[17:01:27.922] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:27.922] Resolved: TRUE
[17:01:27.922] Value: <not collected>
[17:01:27.922] Conditions captured: <none>
[17:01:27.922] Early signaling: FALSE
[17:01:27.922] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:27.922] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:27.932] Chunk #2 of 2 ... DONE
[17:01:27.932] Launching 2 futures (chunks) ... DONE
[17:01:27.933] Resolving 2 futures (chunks) ...
[17:01:27.933] resolve() on list ...
[17:01:27.933]  recursive: 0
[17:01:27.933]  length: 2
[17:01:27.933] 
[17:01:27.944] Future #2
[17:01:27.944] result() for MulticoreFuture ...
[17:01:27.945] result() for MulticoreFuture ...
[17:01:27.945] result() for MulticoreFuture ... done
[17:01:27.945] result() for MulticoreFuture ... done
[17:01:27.946] result() for MulticoreFuture ...
[17:01:27.946] result() for MulticoreFuture ... done
[17:01:27.946] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:27.946] - nx: 2
[17:01:27.946] - relay: TRUE
[17:01:27.946] - stdout: TRUE
[17:01:27.946] - signal: TRUE
[17:01:27.947] - resignal: FALSE
[17:01:27.947] - force: TRUE
[17:01:27.947] - relayed: [n=2] FALSE, FALSE
[17:01:27.947] - queued futures: [n=2] FALSE, FALSE
[17:01:27.947]  - until=1
[17:01:27.947]  - relaying element #1
[17:01:27.947] - relayed: [n=2] FALSE, FALSE
[17:01:27.948] - queued futures: [n=2] FALSE, TRUE
[17:01:27.948] signalConditionsASAP(NULL, pos=2) ... done
[17:01:27.948]  length: 1 (resolved future 2)
[17:01:28.381] plan(): Setting new future strategy stack:
[17:01:28.381] List of future strategies:
[17:01:28.381] 1. multicore:
[17:01:28.381]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:28.381]    - tweaked: FALSE
[17:01:28.381]    - call: plan(strategy)
[17:01:28.386] plan(): nbrOfWorkers() = 2
[17:01:28.391] Future #1
[17:01:28.391] result() for MulticoreFuture ...
[17:01:28.392] result() for MulticoreFuture ...
[17:01:28.393] result() for MulticoreFuture ... done
[17:01:28.393] result() for MulticoreFuture ... done
[17:01:28.393] result() for MulticoreFuture ...
[17:01:28.393] result() for MulticoreFuture ... done
[17:01:28.393] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:28.394] - nx: 2
[17:01:28.394] - relay: TRUE
[17:01:28.394] - stdout: TRUE
[17:01:28.394] - signal: TRUE
[17:01:28.394] - resignal: FALSE
[17:01:28.395] - force: TRUE
[17:01:28.395] - relayed: [n=2] FALSE, FALSE
[17:01:28.395] - queued futures: [n=2] FALSE, TRUE
[17:01:28.395]  - until=1
[17:01:28.395]  - relaying element #1
[17:01:28.395] result() for MulticoreFuture ...
[17:01:28.396] result() for MulticoreFuture ... done
[17:01:28.396] result() for MulticoreFuture ...
[17:01:28.396] result() for MulticoreFuture ... done
[17:01:28.396] result() for MulticoreFuture ...
[17:01:28.396] result() for MulticoreFuture ... done
[17:01:28.396] result() for MulticoreFuture ...
[17:01:28.397] result() for MulticoreFuture ... done
[17:01:28.397] - relayed: [n=2] TRUE, FALSE
[17:01:28.397] - queued futures: [n=2] TRUE, TRUE
[17:01:28.397] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:28.397]  length: 0 (resolved future 1)
[17:01:28.397] Relaying remaining futures
[17:01:28.397] signalConditionsASAP(NULL, pos=0) ...
[17:01:28.398] - nx: 2
[17:01:28.398] - relay: TRUE
[17:01:28.398] - stdout: TRUE
[17:01:28.398] - signal: TRUE
[17:01:28.398] - resignal: FALSE
[17:01:28.398] - force: TRUE
[17:01:28.398] - relayed: [n=2] TRUE, FALSE
[17:01:28.398] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:28.398]  - relaying element #2
[17:01:28.399] result() for MulticoreFuture ...
[17:01:28.399] result() for MulticoreFuture ... done
[17:01:28.399] result() for MulticoreFuture ...
[17:01:28.399] result() for MulticoreFuture ... done
[17:01:28.399] result() for MulticoreFuture ...
[17:01:28.399] result() for MulticoreFuture ... done
[17:01:28.399] result() for MulticoreFuture ...
[17:01:28.399] result() for MulticoreFuture ... done
[17:01:28.400] - relayed: [n=2] TRUE, TRUE
[17:01:28.400] - queued futures: [n=2] TRUE, TRUE
[17:01:28.400] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:01:28.400] resolve() on list ... DONE
[17:01:28.400] result() for MulticoreFuture ...
[17:01:28.400] result() for MulticoreFuture ... done
[17:01:28.400] result() for MulticoreFuture ...
[17:01:28.400] result() for MulticoreFuture ... done
[17:01:28.400] result() for MulticoreFuture ...
[17:01:28.401] result() for MulticoreFuture ... done
[17:01:28.401] result() for MulticoreFuture ...
[17:01:28.401] result() for MulticoreFuture ... done
[17:01:28.401]  - Number of value chunks collected: 2
[17:01:28.401] Resolving 2 futures (chunks) ... DONE
[17:01:28.401] Reducing values from 2 chunks ...
[17:01:28.401]  - Number of values collected after concatenation: 2
[17:01:28.401]  - Number of values expected: 2
[17:01:28.401] Reducing values from 2 chunks ... DONE
[17:01:28.402] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:01:28.402] future_mapply() ...
[17:01:28.406] Number of chunks: 2
[17:01:28.406] getGlobalsAndPackagesXApply() ...
[17:01:28.407]  - future.globals: TRUE
[17:01:28.407] getGlobalsAndPackages() ...
[17:01:28.407] Searching for globals...
[17:01:28.409] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:28.409] Searching for globals ... DONE
[17:01:28.409] Resolving globals: FALSE
[17:01:28.409] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:28.410] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:28.410] - globals: [1] ‘FUN’
[17:01:28.410] 
[17:01:28.410] getGlobalsAndPackages() ... DONE
[17:01:28.410]  - globals found/used: [n=1] ‘FUN’
[17:01:28.410]  - needed namespaces: [n=0] 
[17:01:28.410] Finding globals ... DONE
[17:01:28.411] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:28.411] List of 2
[17:01:28.411]  $ ...future.FUN:function (x, y)  
[17:01:28.411]  $ MoreArgs     : NULL
[17:01:28.411]  - attr(*, "where")=List of 2
[17:01:28.411]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:28.411]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:28.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:28.411]  - attr(*, "resolved")= logi FALSE
[17:01:28.411]  - attr(*, "total_size")= num NA
[17:01:28.414] Packages to be attached in all futures: [n=0] 
[17:01:28.414] getGlobalsAndPackagesXApply() ... DONE
[17:01:28.414] Number of futures (= number of chunks): 2
[17:01:28.414] Launching 2 futures (chunks) ...
[17:01:28.414] Chunk #1 of 2 ...
[17:01:28.414]  - Finding globals in '...' for chunk #1 ...
[17:01:28.415] getGlobalsAndPackages() ...
[17:01:28.415] Searching for globals...
[17:01:28.415] 
[17:01:28.415] Searching for globals ... DONE
[17:01:28.415] - globals: [0] <none>
[17:01:28.415] getGlobalsAndPackages() ... DONE
[17:01:28.415]    + additional globals found: [n=0] 
[17:01:28.415]    + additional namespaces needed: [n=0] 
[17:01:28.416]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:28.416]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:28.416]  - seeds: <none>
[17:01:28.416]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:28.416] getGlobalsAndPackages() ...
[17:01:28.416] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:28.416] Resolving globals: FALSE
[17:01:28.417] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:28.417] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:28.417] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:28.417] 
[17:01:28.417] getGlobalsAndPackages() ... DONE
[17:01:28.418] run() for ‘Future’ ...
[17:01:28.418] - state: ‘created’
[17:01:28.418] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:28.422] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:28.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:28.422]   - Field: ‘label’
[17:01:28.422]   - Field: ‘local’
[17:01:28.422]   - Field: ‘owner’
[17:01:28.422]   - Field: ‘envir’
[17:01:28.423]   - Field: ‘workers’
[17:01:28.424]   - Field: ‘packages’
[17:01:28.425]   - Field: ‘gc’
[17:01:28.425]   - Field: ‘job’
[17:01:28.425]   - Field: ‘conditions’
[17:01:28.425]   - Field: ‘expr’
[17:01:28.425]   - Field: ‘uuid’
[17:01:28.425]   - Field: ‘seed’
[17:01:28.425]   - Field: ‘version’
[17:01:28.425]   - Field: ‘result’
[17:01:28.426]   - Field: ‘asynchronous’
[17:01:28.426]   - Field: ‘calls’
[17:01:28.426]   - Field: ‘globals’
[17:01:28.426]   - Field: ‘stdout’
[17:01:28.426]   - Field: ‘earlySignal’
[17:01:28.426]   - Field: ‘lazy’
[17:01:28.426]   - Field: ‘state’
[17:01:28.426] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:28.427] - Launch lazy future ...
[17:01:28.427] Packages needed by the future expression (n = 0): <none>
[17:01:28.427] Packages needed by future strategies (n = 0): <none>
[17:01:28.428] {
[17:01:28.428]     {
[17:01:28.428]         {
[17:01:28.428]             ...future.startTime <- base::Sys.time()
[17:01:28.428]             {
[17:01:28.428]                 {
[17:01:28.428]                   {
[17:01:28.428]                     {
[17:01:28.428]                       base::local({
[17:01:28.428]                         has_future <- base::requireNamespace("future", 
[17:01:28.428]                           quietly = TRUE)
[17:01:28.428]                         if (has_future) {
[17:01:28.428]                           ns <- base::getNamespace("future")
[17:01:28.428]                           version <- ns[[".package"]][["version"]]
[17:01:28.428]                           if (is.null(version)) 
[17:01:28.428]                             version <- utils::packageVersion("future")
[17:01:28.428]                         }
[17:01:28.428]                         else {
[17:01:28.428]                           version <- NULL
[17:01:28.428]                         }
[17:01:28.428]                         if (!has_future || version < "1.8.0") {
[17:01:28.428]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:28.428]                             "", base::R.version$version.string), 
[17:01:28.428]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:28.428]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:28.428]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:28.428]                               "release", "version")], collapse = " "), 
[17:01:28.428]                             hostname = base::Sys.info()[["nodename"]])
[17:01:28.428]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:28.428]                             info)
[17:01:28.428]                           info <- base::paste(info, collapse = "; ")
[17:01:28.428]                           if (!has_future) {
[17:01:28.428]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:28.428]                               info)
[17:01:28.428]                           }
[17:01:28.428]                           else {
[17:01:28.428]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:28.428]                               info, version)
[17:01:28.428]                           }
[17:01:28.428]                           base::stop(msg)
[17:01:28.428]                         }
[17:01:28.428]                       })
[17:01:28.428]                     }
[17:01:28.428]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:28.428]                     base::options(mc.cores = 1L)
[17:01:28.428]                   }
[17:01:28.428]                   ...future.strategy.old <- future::plan("list")
[17:01:28.428]                   options(future.plan = NULL)
[17:01:28.428]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:28.428]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:28.428]                 }
[17:01:28.428]                 ...future.workdir <- getwd()
[17:01:28.428]             }
[17:01:28.428]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:28.428]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:28.428]         }
[17:01:28.428]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:28.428]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:28.428]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:28.428]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:28.428]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:28.428]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:28.428]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:28.428]             base::names(...future.oldOptions))
[17:01:28.428]     }
[17:01:28.428]     if (TRUE) {
[17:01:28.428]     }
[17:01:28.428]     else {
[17:01:28.428]         if (NA) {
[17:01:28.428]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:28.428]                 open = "w")
[17:01:28.428]         }
[17:01:28.428]         else {
[17:01:28.428]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:28.428]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:28.428]         }
[17:01:28.428]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:28.428]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:28.428]             base::sink(type = "output", split = FALSE)
[17:01:28.428]             base::close(...future.stdout)
[17:01:28.428]         }, add = TRUE)
[17:01:28.428]     }
[17:01:28.428]     ...future.frame <- base::sys.nframe()
[17:01:28.428]     ...future.conditions <- base::list()
[17:01:28.428]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:28.428]     if (FALSE) {
[17:01:28.428]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:28.428]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:28.428]     }
[17:01:28.428]     ...future.result <- base::tryCatch({
[17:01:28.428]         base::withCallingHandlers({
[17:01:28.428]             ...future.value <- base::withVisible(base::local({
[17:01:28.428]                 withCallingHandlers({
[17:01:28.428]                   {
[17:01:28.428]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:28.428]                     if (!identical(...future.globals.maxSize.org, 
[17:01:28.428]                       ...future.globals.maxSize)) {
[17:01:28.428]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:28.428]                       on.exit(options(oopts), add = TRUE)
[17:01:28.428]                     }
[17:01:28.428]                     {
[17:01:28.428]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:28.428]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:28.428]                         USE.NAMES = FALSE)
[17:01:28.428]                       do.call(mapply, args = args)
[17:01:28.428]                     }
[17:01:28.428]                   }
[17:01:28.428]                 }, immediateCondition = function(cond) {
[17:01:28.428]                   save_rds <- function (object, pathname, ...) 
[17:01:28.428]                   {
[17:01:28.428]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:28.428]                     if (file_test("-f", pathname_tmp)) {
[17:01:28.428]                       fi_tmp <- file.info(pathname_tmp)
[17:01:28.428]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:28.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:28.428]                         fi_tmp[["mtime"]])
[17:01:28.428]                     }
[17:01:28.428]                     tryCatch({
[17:01:28.428]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:28.428]                     }, error = function(ex) {
[17:01:28.428]                       msg <- conditionMessage(ex)
[17:01:28.428]                       fi_tmp <- file.info(pathname_tmp)
[17:01:28.428]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:28.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:28.428]                         fi_tmp[["mtime"]], msg)
[17:01:28.428]                       ex$message <- msg
[17:01:28.428]                       stop(ex)
[17:01:28.428]                     })
[17:01:28.428]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:28.428]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:28.428]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:28.428]                       fi_tmp <- file.info(pathname_tmp)
[17:01:28.428]                       fi <- file.info(pathname)
[17:01:28.428]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:28.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:28.428]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:28.428]                         fi[["size"]], fi[["mtime"]])
[17:01:28.428]                       stop(msg)
[17:01:28.428]                     }
[17:01:28.428]                     invisible(pathname)
[17:01:28.428]                   }
[17:01:28.428]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:28.428]                     rootPath = tempdir()) 
[17:01:28.428]                   {
[17:01:28.428]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:28.428]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:28.428]                       tmpdir = path, fileext = ".rds")
[17:01:28.428]                     save_rds(obj, file)
[17:01:28.428]                   }
[17:01:28.428]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:28.428]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:28.428]                   {
[17:01:28.428]                     inherits <- base::inherits
[17:01:28.428]                     invokeRestart <- base::invokeRestart
[17:01:28.428]                     is.null <- base::is.null
[17:01:28.428]                     muffled <- FALSE
[17:01:28.428]                     if (inherits(cond, "message")) {
[17:01:28.428]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:28.428]                       if (muffled) 
[17:01:28.428]                         invokeRestart("muffleMessage")
[17:01:28.428]                     }
[17:01:28.428]                     else if (inherits(cond, "warning")) {
[17:01:28.428]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:28.428]                       if (muffled) 
[17:01:28.428]                         invokeRestart("muffleWarning")
[17:01:28.428]                     }
[17:01:28.428]                     else if (inherits(cond, "condition")) {
[17:01:28.428]                       if (!is.null(pattern)) {
[17:01:28.428]                         computeRestarts <- base::computeRestarts
[17:01:28.428]                         grepl <- base::grepl
[17:01:28.428]                         restarts <- computeRestarts(cond)
[17:01:28.428]                         for (restart in restarts) {
[17:01:28.428]                           name <- restart$name
[17:01:28.428]                           if (is.null(name)) 
[17:01:28.428]                             next
[17:01:28.428]                           if (!grepl(pattern, name)) 
[17:01:28.428]                             next
[17:01:28.428]                           invokeRestart(restart)
[17:01:28.428]                           muffled <- TRUE
[17:01:28.428]                           break
[17:01:28.428]                         }
[17:01:28.428]                       }
[17:01:28.428]                     }
[17:01:28.428]                     invisible(muffled)
[17:01:28.428]                   }
[17:01:28.428]                   muffleCondition(cond)
[17:01:28.428]                 })
[17:01:28.428]             }))
[17:01:28.428]             future::FutureResult(value = ...future.value$value, 
[17:01:28.428]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:28.428]                   ...future.rng), globalenv = if (FALSE) 
[17:01:28.428]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:28.428]                     ...future.globalenv.names))
[17:01:28.428]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:28.428]         }, condition = base::local({
[17:01:28.428]             c <- base::c
[17:01:28.428]             inherits <- base::inherits
[17:01:28.428]             invokeRestart <- base::invokeRestart
[17:01:28.428]             length <- base::length
[17:01:28.428]             list <- base::list
[17:01:28.428]             seq.int <- base::seq.int
[17:01:28.428]             signalCondition <- base::signalCondition
[17:01:28.428]             sys.calls <- base::sys.calls
[17:01:28.428]             `[[` <- base::`[[`
[17:01:28.428]             `+` <- base::`+`
[17:01:28.428]             `<<-` <- base::`<<-`
[17:01:28.428]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:28.428]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:28.428]                   3L)]
[17:01:28.428]             }
[17:01:28.428]             function(cond) {
[17:01:28.428]                 is_error <- inherits(cond, "error")
[17:01:28.428]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:28.428]                   NULL)
[17:01:28.428]                 if (is_error) {
[17:01:28.428]                   sessionInformation <- function() {
[17:01:28.428]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:28.428]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:28.428]                       search = base::search(), system = base::Sys.info())
[17:01:28.428]                   }
[17:01:28.428]                   ...future.conditions[[length(...future.conditions) + 
[17:01:28.428]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:28.428]                     cond$call), session = sessionInformation(), 
[17:01:28.428]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:28.428]                   signalCondition(cond)
[17:01:28.428]                 }
[17:01:28.428]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:28.428]                 "immediateCondition"))) {
[17:01:28.428]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:28.428]                   ...future.conditions[[length(...future.conditions) + 
[17:01:28.428]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:28.428]                   if (TRUE && !signal) {
[17:01:28.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:28.428]                     {
[17:01:28.428]                       inherits <- base::inherits
[17:01:28.428]                       invokeRestart <- base::invokeRestart
[17:01:28.428]                       is.null <- base::is.null
[17:01:28.428]                       muffled <- FALSE
[17:01:28.428]                       if (inherits(cond, "message")) {
[17:01:28.428]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:28.428]                         if (muffled) 
[17:01:28.428]                           invokeRestart("muffleMessage")
[17:01:28.428]                       }
[17:01:28.428]                       else if (inherits(cond, "warning")) {
[17:01:28.428]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:28.428]                         if (muffled) 
[17:01:28.428]                           invokeRestart("muffleWarning")
[17:01:28.428]                       }
[17:01:28.428]                       else if (inherits(cond, "condition")) {
[17:01:28.428]                         if (!is.null(pattern)) {
[17:01:28.428]                           computeRestarts <- base::computeRestarts
[17:01:28.428]                           grepl <- base::grepl
[17:01:28.428]                           restarts <- computeRestarts(cond)
[17:01:28.428]                           for (restart in restarts) {
[17:01:28.428]                             name <- restart$name
[17:01:28.428]                             if (is.null(name)) 
[17:01:28.428]                               next
[17:01:28.428]                             if (!grepl(pattern, name)) 
[17:01:28.428]                               next
[17:01:28.428]                             invokeRestart(restart)
[17:01:28.428]                             muffled <- TRUE
[17:01:28.428]                             break
[17:01:28.428]                           }
[17:01:28.428]                         }
[17:01:28.428]                       }
[17:01:28.428]                       invisible(muffled)
[17:01:28.428]                     }
[17:01:28.428]                     muffleCondition(cond, pattern = "^muffle")
[17:01:28.428]                   }
[17:01:28.428]                 }
[17:01:28.428]                 else {
[17:01:28.428]                   if (TRUE) {
[17:01:28.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:28.428]                     {
[17:01:28.428]                       inherits <- base::inherits
[17:01:28.428]                       invokeRestart <- base::invokeRestart
[17:01:28.428]                       is.null <- base::is.null
[17:01:28.428]                       muffled <- FALSE
[17:01:28.428]                       if (inherits(cond, "message")) {
[17:01:28.428]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:28.428]                         if (muffled) 
[17:01:28.428]                           invokeRestart("muffleMessage")
[17:01:28.428]                       }
[17:01:28.428]                       else if (inherits(cond, "warning")) {
[17:01:28.428]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:28.428]                         if (muffled) 
[17:01:28.428]                           invokeRestart("muffleWarning")
[17:01:28.428]                       }
[17:01:28.428]                       else if (inherits(cond, "condition")) {
[17:01:28.428]                         if (!is.null(pattern)) {
[17:01:28.428]                           computeRestarts <- base::computeRestarts
[17:01:28.428]                           grepl <- base::grepl
[17:01:28.428]                           restarts <- computeRestarts(cond)
[17:01:28.428]                           for (restart in restarts) {
[17:01:28.428]                             name <- restart$name
[17:01:28.428]                             if (is.null(name)) 
[17:01:28.428]                               next
[17:01:28.428]                             if (!grepl(pattern, name)) 
[17:01:28.428]                               next
[17:01:28.428]                             invokeRestart(restart)
[17:01:28.428]                             muffled <- TRUE
[17:01:28.428]                             break
[17:01:28.428]                           }
[17:01:28.428]                         }
[17:01:28.428]                       }
[17:01:28.428]                       invisible(muffled)
[17:01:28.428]                     }
[17:01:28.428]                     muffleCondition(cond, pattern = "^muffle")
[17:01:28.428]                   }
[17:01:28.428]                 }
[17:01:28.428]             }
[17:01:28.428]         }))
[17:01:28.428]     }, error = function(ex) {
[17:01:28.428]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:28.428]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:28.428]                 ...future.rng), started = ...future.startTime, 
[17:01:28.428]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:28.428]             version = "1.8"), class = "FutureResult")
[17:01:28.428]     }, finally = {
[17:01:28.428]         if (!identical(...future.workdir, getwd())) 
[17:01:28.428]             setwd(...future.workdir)
[17:01:28.428]         {
[17:01:28.428]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:28.428]                 ...future.oldOptions$nwarnings <- NULL
[17:01:28.428]             }
[17:01:28.428]             base::options(...future.oldOptions)
[17:01:28.428]             if (.Platform$OS.type == "windows") {
[17:01:28.428]                 old_names <- names(...future.oldEnvVars)
[17:01:28.428]                 envs <- base::Sys.getenv()
[17:01:28.428]                 names <- names(envs)
[17:01:28.428]                 common <- intersect(names, old_names)
[17:01:28.428]                 added <- setdiff(names, old_names)
[17:01:28.428]                 removed <- setdiff(old_names, names)
[17:01:28.428]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:28.428]                   envs[common]]
[17:01:28.428]                 NAMES <- toupper(changed)
[17:01:28.428]                 args <- list()
[17:01:28.428]                 for (kk in seq_along(NAMES)) {
[17:01:28.428]                   name <- changed[[kk]]
[17:01:28.428]                   NAME <- NAMES[[kk]]
[17:01:28.428]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:28.428]                     next
[17:01:28.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:28.428]                 }
[17:01:28.428]                 NAMES <- toupper(added)
[17:01:28.428]                 for (kk in seq_along(NAMES)) {
[17:01:28.428]                   name <- added[[kk]]
[17:01:28.428]                   NAME <- NAMES[[kk]]
[17:01:28.428]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:28.428]                     next
[17:01:28.428]                   args[[name]] <- ""
[17:01:28.428]                 }
[17:01:28.428]                 NAMES <- toupper(removed)
[17:01:28.428]                 for (kk in seq_along(NAMES)) {
[17:01:28.428]                   name <- removed[[kk]]
[17:01:28.428]                   NAME <- NAMES[[kk]]
[17:01:28.428]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:28.428]                     next
[17:01:28.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:28.428]                 }
[17:01:28.428]                 if (length(args) > 0) 
[17:01:28.428]                   base::do.call(base::Sys.setenv, args = args)
[17:01:28.428]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:28.428]             }
[17:01:28.428]             else {
[17:01:28.428]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:28.428]             }
[17:01:28.428]             {
[17:01:28.428]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:28.428]                   0L) {
[17:01:28.428]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:28.428]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:28.428]                   base::options(opts)
[17:01:28.428]                 }
[17:01:28.428]                 {
[17:01:28.428]                   {
[17:01:28.428]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:28.428]                     NULL
[17:01:28.428]                   }
[17:01:28.428]                   options(future.plan = NULL)
[17:01:28.428]                   if (is.na(NA_character_)) 
[17:01:28.428]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:28.428]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:28.428]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:28.428]                     .init = FALSE)
[17:01:28.428]                 }
[17:01:28.428]             }
[17:01:28.428]         }
[17:01:28.428]     })
[17:01:28.428]     if (FALSE) {
[17:01:28.428]         base::sink(type = "output", split = FALSE)
[17:01:28.428]         if (NA) {
[17:01:28.428]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:28.428]         }
[17:01:28.428]         else {
[17:01:28.428]             ...future.result["stdout"] <- base::list(NULL)
[17:01:28.428]         }
[17:01:28.428]         base::close(...future.stdout)
[17:01:28.428]         ...future.stdout <- NULL
[17:01:28.428]     }
[17:01:28.428]     ...future.result$conditions <- ...future.conditions
[17:01:28.428]     ...future.result$finished <- base::Sys.time()
[17:01:28.428]     ...future.result
[17:01:28.428] }
[17:01:28.430] assign_globals() ...
[17:01:28.430] List of 5
[17:01:28.430]  $ ...future.FUN            :function (x, y)  
[17:01:28.430]  $ MoreArgs                 : NULL
[17:01:28.430]  $ ...future.elements_ii    :List of 2
[17:01:28.430]   ..$ :List of 1
[17:01:28.430]   .. ..$ : int 1
[17:01:28.430]   ..$ :List of 1
[17:01:28.430]   .. ..$ : int 0
[17:01:28.430]  $ ...future.seeds_ii       : NULL
[17:01:28.430]  $ ...future.globals.maxSize: NULL
[17:01:28.430]  - attr(*, "where")=List of 5
[17:01:28.430]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:28.430]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:28.430]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:28.430]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:28.430]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:28.430]  - attr(*, "resolved")= logi FALSE
[17:01:28.430]  - attr(*, "total_size")= num 6368
[17:01:28.430]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:28.430]  - attr(*, "already-done")= logi TRUE
[17:01:28.435] - reassign environment for ‘...future.FUN’
[17:01:28.435] - copied ‘...future.FUN’ to environment
[17:01:28.435] - copied ‘MoreArgs’ to environment
[17:01:28.435] - copied ‘...future.elements_ii’ to environment
[17:01:28.435] - copied ‘...future.seeds_ii’ to environment
[17:01:28.435] - copied ‘...future.globals.maxSize’ to environment
[17:01:28.436] assign_globals() ... done
[17:01:28.436] requestCore(): workers = 2
[17:01:28.438] MulticoreFuture started
[17:01:28.438] - Launch lazy future ... done
[17:01:28.438] run() for ‘MulticoreFuture’ ... done
[17:01:28.439] Created future:
[17:01:28.439] plan(): Setting new future strategy stack:
[17:01:28.439] List of future strategies:
[17:01:28.439] 1. sequential:
[17:01:28.439]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:28.439]    - tweaked: FALSE
[17:01:28.439]    - call: NULL
[17:01:28.440] plan(): nbrOfWorkers() = 1
[17:01:28.439] MulticoreFuture:
[17:01:28.439] Label: ‘future_mapply-1’
[17:01:28.439] Expression:
[17:01:28.439] {
[17:01:28.439]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:28.439]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:28.439]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:28.439]         on.exit(options(oopts), add = TRUE)
[17:01:28.439]     }
[17:01:28.439]     {
[17:01:28.439]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:28.439]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:28.439]         do.call(mapply, args = args)
[17:01:28.439]     }
[17:01:28.439] }
[17:01:28.439] Lazy evaluation: FALSE
[17:01:28.439] Asynchronous evaluation: TRUE
[17:01:28.439] Local evaluation: TRUE
[17:01:28.439] Environment: R_GlobalEnv
[17:01:28.439] Capture standard output: NA
[17:01:28.439] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:28.439] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:28.439] Packages: <none>
[17:01:28.439] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:28.439] Resolved: FALSE
[17:01:28.439] Value: <not collected>
[17:01:28.439] Conditions captured: <none>
[17:01:28.439] Early signaling: FALSE
[17:01:28.439] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:28.439] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:28.452] Chunk #1 of 2 ... DONE
[17:01:28.452] Chunk #2 of 2 ...
[17:01:28.452]  - Finding globals in '...' for chunk #2 ...
[17:01:28.452] getGlobalsAndPackages() ...
[17:01:28.452] Searching for globals...
[17:01:28.453] 
[17:01:28.453] Searching for globals ... DONE
[17:01:28.453] - globals: [0] <none>
[17:01:28.453] getGlobalsAndPackages() ... DONE
[17:01:28.454]    + additional globals found: [n=0] 
[17:01:28.454]    + additional namespaces needed: [n=0] 
[17:01:28.454]  - Finding globals in '...' for chunk #2 ... DONE
[17:01:28.454]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:28.454]  - seeds: <none>
[17:01:28.454]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:28.455] getGlobalsAndPackages() ...
[17:01:28.455] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:28.455] Resolving globals: FALSE
[17:01:28.456] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:28.457] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:28.457] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:28.457] 
[17:01:28.457] getGlobalsAndPackages() ... DONE
[17:01:28.458] run() for ‘Future’ ...
[17:01:28.458] - state: ‘created’
[17:01:28.458] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:28.464] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:28.464] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:28.464]   - Field: ‘label’
[17:01:28.465]   - Field: ‘local’
[17:01:28.465]   - Field: ‘owner’
[17:01:28.465]   - Field: ‘envir’
[17:01:28.465]   - Field: ‘workers’
[17:01:28.465]   - Field: ‘packages’
[17:01:28.465]   - Field: ‘gc’
[17:01:28.466]   - Field: ‘job’
[17:01:28.466]   - Field: ‘conditions’
[17:01:28.466]   - Field: ‘expr’
[17:01:28.466]   - Field: ‘uuid’
[17:01:28.466]   - Field: ‘seed’
[17:01:28.466]   - Field: ‘version’
[17:01:28.466]   - Field: ‘result’
[17:01:28.467]   - Field: ‘asynchronous’
[17:01:28.467]   - Field: ‘calls’
[17:01:28.467]   - Field: ‘globals’
[17:01:28.467]   - Field: ‘stdout’
[17:01:28.467]   - Field: ‘earlySignal’
[17:01:28.467]   - Field: ‘lazy’
[17:01:28.467]   - Field: ‘state’
[17:01:28.468] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:28.468] - Launch lazy future ...
[17:01:28.468] Packages needed by the future expression (n = 0): <none>
[17:01:28.468] Packages needed by future strategies (n = 0): <none>
[17:01:28.469] {
[17:01:28.469]     {
[17:01:28.469]         {
[17:01:28.469]             ...future.startTime <- base::Sys.time()
[17:01:28.469]             {
[17:01:28.469]                 {
[17:01:28.469]                   {
[17:01:28.469]                     {
[17:01:28.469]                       base::local({
[17:01:28.469]                         has_future <- base::requireNamespace("future", 
[17:01:28.469]                           quietly = TRUE)
[17:01:28.469]                         if (has_future) {
[17:01:28.469]                           ns <- base::getNamespace("future")
[17:01:28.469]                           version <- ns[[".package"]][["version"]]
[17:01:28.469]                           if (is.null(version)) 
[17:01:28.469]                             version <- utils::packageVersion("future")
[17:01:28.469]                         }
[17:01:28.469]                         else {
[17:01:28.469]                           version <- NULL
[17:01:28.469]                         }
[17:01:28.469]                         if (!has_future || version < "1.8.0") {
[17:01:28.469]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:28.469]                             "", base::R.version$version.string), 
[17:01:28.469]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:28.469]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:28.469]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:28.469]                               "release", "version")], collapse = " "), 
[17:01:28.469]                             hostname = base::Sys.info()[["nodename"]])
[17:01:28.469]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:28.469]                             info)
[17:01:28.469]                           info <- base::paste(info, collapse = "; ")
[17:01:28.469]                           if (!has_future) {
[17:01:28.469]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:28.469]                               info)
[17:01:28.469]                           }
[17:01:28.469]                           else {
[17:01:28.469]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:28.469]                               info, version)
[17:01:28.469]                           }
[17:01:28.469]                           base::stop(msg)
[17:01:28.469]                         }
[17:01:28.469]                       })
[17:01:28.469]                     }
[17:01:28.469]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:28.469]                     base::options(mc.cores = 1L)
[17:01:28.469]                   }
[17:01:28.469]                   ...future.strategy.old <- future::plan("list")
[17:01:28.469]                   options(future.plan = NULL)
[17:01:28.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:28.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:28.469]                 }
[17:01:28.469]                 ...future.workdir <- getwd()
[17:01:28.469]             }
[17:01:28.469]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:28.469]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:28.469]         }
[17:01:28.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:28.469]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:28.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:28.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:28.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:28.469]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:28.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:28.469]             base::names(...future.oldOptions))
[17:01:28.469]     }
[17:01:28.469]     if (TRUE) {
[17:01:28.469]     }
[17:01:28.469]     else {
[17:01:28.469]         if (NA) {
[17:01:28.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:28.469]                 open = "w")
[17:01:28.469]         }
[17:01:28.469]         else {
[17:01:28.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:28.469]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:28.469]         }
[17:01:28.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:28.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:28.469]             base::sink(type = "output", split = FALSE)
[17:01:28.469]             base::close(...future.stdout)
[17:01:28.469]         }, add = TRUE)
[17:01:28.469]     }
[17:01:28.469]     ...future.frame <- base::sys.nframe()
[17:01:28.469]     ...future.conditions <- base::list()
[17:01:28.469]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:28.469]     if (FALSE) {
[17:01:28.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:28.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:28.469]     }
[17:01:28.469]     ...future.result <- base::tryCatch({
[17:01:28.469]         base::withCallingHandlers({
[17:01:28.469]             ...future.value <- base::withVisible(base::local({
[17:01:28.469]                 withCallingHandlers({
[17:01:28.469]                   {
[17:01:28.469]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:28.469]                     if (!identical(...future.globals.maxSize.org, 
[17:01:28.469]                       ...future.globals.maxSize)) {
[17:01:28.469]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:28.469]                       on.exit(options(oopts), add = TRUE)
[17:01:28.469]                     }
[17:01:28.469]                     {
[17:01:28.469]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:28.469]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:28.469]                         USE.NAMES = FALSE)
[17:01:28.469]                       do.call(mapply, args = args)
[17:01:28.469]                     }
[17:01:28.469]                   }
[17:01:28.469]                 }, immediateCondition = function(cond) {
[17:01:28.469]                   save_rds <- function (object, pathname, ...) 
[17:01:28.469]                   {
[17:01:28.469]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:28.469]                     if (file_test("-f", pathname_tmp)) {
[17:01:28.469]                       fi_tmp <- file.info(pathname_tmp)
[17:01:28.469]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:28.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:28.469]                         fi_tmp[["mtime"]])
[17:01:28.469]                     }
[17:01:28.469]                     tryCatch({
[17:01:28.469]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:28.469]                     }, error = function(ex) {
[17:01:28.469]                       msg <- conditionMessage(ex)
[17:01:28.469]                       fi_tmp <- file.info(pathname_tmp)
[17:01:28.469]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:28.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:28.469]                         fi_tmp[["mtime"]], msg)
[17:01:28.469]                       ex$message <- msg
[17:01:28.469]                       stop(ex)
[17:01:28.469]                     })
[17:01:28.469]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:28.469]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:28.469]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:28.469]                       fi_tmp <- file.info(pathname_tmp)
[17:01:28.469]                       fi <- file.info(pathname)
[17:01:28.469]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:28.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:28.469]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:28.469]                         fi[["size"]], fi[["mtime"]])
[17:01:28.469]                       stop(msg)
[17:01:28.469]                     }
[17:01:28.469]                     invisible(pathname)
[17:01:28.469]                   }
[17:01:28.469]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:28.469]                     rootPath = tempdir()) 
[17:01:28.469]                   {
[17:01:28.469]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:28.469]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:28.469]                       tmpdir = path, fileext = ".rds")
[17:01:28.469]                     save_rds(obj, file)
[17:01:28.469]                   }
[17:01:28.469]                   saveImmediateCondition(cond, path = "/tmp/RtmpHdI1Kt/.future/immediateConditions")
[17:01:28.469]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:28.469]                   {
[17:01:28.469]                     inherits <- base::inherits
[17:01:28.469]                     invokeRestart <- base::invokeRestart
[17:01:28.469]                     is.null <- base::is.null
[17:01:28.469]                     muffled <- FALSE
[17:01:28.469]                     if (inherits(cond, "message")) {
[17:01:28.469]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:28.469]                       if (muffled) 
[17:01:28.469]                         invokeRestart("muffleMessage")
[17:01:28.469]                     }
[17:01:28.469]                     else if (inherits(cond, "warning")) {
[17:01:28.469]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:28.469]                       if (muffled) 
[17:01:28.469]                         invokeRestart("muffleWarning")
[17:01:28.469]                     }
[17:01:28.469]                     else if (inherits(cond, "condition")) {
[17:01:28.469]                       if (!is.null(pattern)) {
[17:01:28.469]                         computeRestarts <- base::computeRestarts
[17:01:28.469]                         grepl <- base::grepl
[17:01:28.469]                         restarts <- computeRestarts(cond)
[17:01:28.469]                         for (restart in restarts) {
[17:01:28.469]                           name <- restart$name
[17:01:28.469]                           if (is.null(name)) 
[17:01:28.469]                             next
[17:01:28.469]                           if (!grepl(pattern, name)) 
[17:01:28.469]                             next
[17:01:28.469]                           invokeRestart(restart)
[17:01:28.469]                           muffled <- TRUE
[17:01:28.469]                           break
[17:01:28.469]                         }
[17:01:28.469]                       }
[17:01:28.469]                     }
[17:01:28.469]                     invisible(muffled)
[17:01:28.469]                   }
[17:01:28.469]                   muffleCondition(cond)
[17:01:28.469]                 })
[17:01:28.469]             }))
[17:01:28.469]             future::FutureResult(value = ...future.value$value, 
[17:01:28.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:28.469]                   ...future.rng), globalenv = if (FALSE) 
[17:01:28.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:28.469]                     ...future.globalenv.names))
[17:01:28.469]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:28.469]         }, condition = base::local({
[17:01:28.469]             c <- base::c
[17:01:28.469]             inherits <- base::inherits
[17:01:28.469]             invokeRestart <- base::invokeRestart
[17:01:28.469]             length <- base::length
[17:01:28.469]             list <- base::list
[17:01:28.469]             seq.int <- base::seq.int
[17:01:28.469]             signalCondition <- base::signalCondition
[17:01:28.469]             sys.calls <- base::sys.calls
[17:01:28.469]             `[[` <- base::`[[`
[17:01:28.469]             `+` <- base::`+`
[17:01:28.469]             `<<-` <- base::`<<-`
[17:01:28.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:28.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:28.469]                   3L)]
[17:01:28.469]             }
[17:01:28.469]             function(cond) {
[17:01:28.469]                 is_error <- inherits(cond, "error")
[17:01:28.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:28.469]                   NULL)
[17:01:28.469]                 if (is_error) {
[17:01:28.469]                   sessionInformation <- function() {
[17:01:28.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:28.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:28.469]                       search = base::search(), system = base::Sys.info())
[17:01:28.469]                   }
[17:01:28.469]                   ...future.conditions[[length(...future.conditions) + 
[17:01:28.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:28.469]                     cond$call), session = sessionInformation(), 
[17:01:28.469]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:28.469]                   signalCondition(cond)
[17:01:28.469]                 }
[17:01:28.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:28.469]                 "immediateCondition"))) {
[17:01:28.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:28.469]                   ...future.conditions[[length(...future.conditions) + 
[17:01:28.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:28.469]                   if (TRUE && !signal) {
[17:01:28.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:28.469]                     {
[17:01:28.469]                       inherits <- base::inherits
[17:01:28.469]                       invokeRestart <- base::invokeRestart
[17:01:28.469]                       is.null <- base::is.null
[17:01:28.469]                       muffled <- FALSE
[17:01:28.469]                       if (inherits(cond, "message")) {
[17:01:28.469]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:28.469]                         if (muffled) 
[17:01:28.469]                           invokeRestart("muffleMessage")
[17:01:28.469]                       }
[17:01:28.469]                       else if (inherits(cond, "warning")) {
[17:01:28.469]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:28.469]                         if (muffled) 
[17:01:28.469]                           invokeRestart("muffleWarning")
[17:01:28.469]                       }
[17:01:28.469]                       else if (inherits(cond, "condition")) {
[17:01:28.469]                         if (!is.null(pattern)) {
[17:01:28.469]                           computeRestarts <- base::computeRestarts
[17:01:28.469]                           grepl <- base::grepl
[17:01:28.469]                           restarts <- computeRestarts(cond)
[17:01:28.469]                           for (restart in restarts) {
[17:01:28.469]                             name <- restart$name
[17:01:28.469]                             if (is.null(name)) 
[17:01:28.469]                               next
[17:01:28.469]                             if (!grepl(pattern, name)) 
[17:01:28.469]                               next
[17:01:28.469]                             invokeRestart(restart)
[17:01:28.469]                             muffled <- TRUE
[17:01:28.469]                             break
[17:01:28.469]                           }
[17:01:28.469]                         }
[17:01:28.469]                       }
[17:01:28.469]                       invisible(muffled)
[17:01:28.469]                     }
[17:01:28.469]                     muffleCondition(cond, pattern = "^muffle")
[17:01:28.469]                   }
[17:01:28.469]                 }
[17:01:28.469]                 else {
[17:01:28.469]                   if (TRUE) {
[17:01:28.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:28.469]                     {
[17:01:28.469]                       inherits <- base::inherits
[17:01:28.469]                       invokeRestart <- base::invokeRestart
[17:01:28.469]                       is.null <- base::is.null
[17:01:28.469]                       muffled <- FALSE
[17:01:28.469]                       if (inherits(cond, "message")) {
[17:01:28.469]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:28.469]                         if (muffled) 
[17:01:28.469]                           invokeRestart("muffleMessage")
[17:01:28.469]                       }
[17:01:28.469]                       else if (inherits(cond, "warning")) {
[17:01:28.469]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:28.469]                         if (muffled) 
[17:01:28.469]                           invokeRestart("muffleWarning")
[17:01:28.469]                       }
[17:01:28.469]                       else if (inherits(cond, "condition")) {
[17:01:28.469]                         if (!is.null(pattern)) {
[17:01:28.469]                           computeRestarts <- base::computeRestarts
[17:01:28.469]                           grepl <- base::grepl
[17:01:28.469]                           restarts <- computeRestarts(cond)
[17:01:28.469]                           for (restart in restarts) {
[17:01:28.469]                             name <- restart$name
[17:01:28.469]                             if (is.null(name)) 
[17:01:28.469]                               next
[17:01:28.469]                             if (!grepl(pattern, name)) 
[17:01:28.469]                               next
[17:01:28.469]                             invokeRestart(restart)
[17:01:28.469]                             muffled <- TRUE
[17:01:28.469]                             break
[17:01:28.469]                           }
[17:01:28.469]                         }
[17:01:28.469]                       }
[17:01:28.469]                       invisible(muffled)
[17:01:28.469]                     }
[17:01:28.469]                     muffleCondition(cond, pattern = "^muffle")
[17:01:28.469]                   }
[17:01:28.469]                 }
[17:01:28.469]             }
[17:01:28.469]         }))
[17:01:28.469]     }, error = function(ex) {
[17:01:28.469]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:28.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:28.469]                 ...future.rng), started = ...future.startTime, 
[17:01:28.469]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:28.469]             version = "1.8"), class = "FutureResult")
[17:01:28.469]     }, finally = {
[17:01:28.469]         if (!identical(...future.workdir, getwd())) 
[17:01:28.469]             setwd(...future.workdir)
[17:01:28.469]         {
[17:01:28.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:28.469]                 ...future.oldOptions$nwarnings <- NULL
[17:01:28.469]             }
[17:01:28.469]             base::options(...future.oldOptions)
[17:01:28.469]             if (.Platform$OS.type == "windows") {
[17:01:28.469]                 old_names <- names(...future.oldEnvVars)
[17:01:28.469]                 envs <- base::Sys.getenv()
[17:01:28.469]                 names <- names(envs)
[17:01:28.469]                 common <- intersect(names, old_names)
[17:01:28.469]                 added <- setdiff(names, old_names)
[17:01:28.469]                 removed <- setdiff(old_names, names)
[17:01:28.469]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:28.469]                   envs[common]]
[17:01:28.469]                 NAMES <- toupper(changed)
[17:01:28.469]                 args <- list()
[17:01:28.469]                 for (kk in seq_along(NAMES)) {
[17:01:28.469]                   name <- changed[[kk]]
[17:01:28.469]                   NAME <- NAMES[[kk]]
[17:01:28.469]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:28.469]                     next
[17:01:28.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:28.469]                 }
[17:01:28.469]                 NAMES <- toupper(added)
[17:01:28.469]                 for (kk in seq_along(NAMES)) {
[17:01:28.469]                   name <- added[[kk]]
[17:01:28.469]                   NAME <- NAMES[[kk]]
[17:01:28.469]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:28.469]                     next
[17:01:28.469]                   args[[name]] <- ""
[17:01:28.469]                 }
[17:01:28.469]                 NAMES <- toupper(removed)
[17:01:28.469]                 for (kk in seq_along(NAMES)) {
[17:01:28.469]                   name <- removed[[kk]]
[17:01:28.469]                   NAME <- NAMES[[kk]]
[17:01:28.469]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:28.469]                     next
[17:01:28.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:28.469]                 }
[17:01:28.469]                 if (length(args) > 0) 
[17:01:28.469]                   base::do.call(base::Sys.setenv, args = args)
[17:01:28.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:28.469]             }
[17:01:28.469]             else {
[17:01:28.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:28.469]             }
[17:01:28.469]             {
[17:01:28.469]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:28.469]                   0L) {
[17:01:28.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:28.469]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:28.469]                   base::options(opts)
[17:01:28.469]                 }
[17:01:28.469]                 {
[17:01:28.469]                   {
[17:01:28.469]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:28.469]                     NULL
[17:01:28.469]                   }
[17:01:28.469]                   options(future.plan = NULL)
[17:01:28.469]                   if (is.na(NA_character_)) 
[17:01:28.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:28.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:28.469]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:28.469]                     .init = FALSE)
[17:01:28.469]                 }
[17:01:28.469]             }
[17:01:28.469]         }
[17:01:28.469]     })
[17:01:28.469]     if (FALSE) {
[17:01:28.469]         base::sink(type = "output", split = FALSE)
[17:01:28.469]         if (NA) {
[17:01:28.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:28.469]         }
[17:01:28.469]         else {
[17:01:28.469]             ...future.result["stdout"] <- base::list(NULL)
[17:01:28.469]         }
[17:01:28.469]         base::close(...future.stdout)
[17:01:28.469]         ...future.stdout <- NULL
[17:01:28.469]     }
[17:01:28.469]     ...future.result$conditions <- ...future.conditions
[17:01:28.469]     ...future.result$finished <- base::Sys.time()
[17:01:28.469]     ...future.result
[17:01:28.469] }
[17:01:28.472] assign_globals() ...
[17:01:28.473] List of 5
[17:01:28.473]  $ ...future.FUN            :function (x, y)  
[17:01:28.473]  $ MoreArgs                 : NULL
[17:01:28.473]  $ ...future.elements_ii    :List of 2
[17:01:28.473]   ..$ :List of 1
[17:01:28.473]   .. ..$ : int 0
[17:01:28.473]   ..$ :List of 1
[17:01:28.473]   .. ..$ : int 1
[17:01:28.473]  $ ...future.seeds_ii       : NULL
[17:01:28.473]  $ ...future.globals.maxSize: NULL
[17:01:28.473]  - attr(*, "where")=List of 5
[17:01:28.473]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:28.473]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:01:28.473]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:28.473]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:28.473]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:28.473]  - attr(*, "resolved")= logi FALSE
[17:01:28.473]  - attr(*, "total_size")= num 6368
[17:01:28.473]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:28.473]  - attr(*, "already-done")= logi TRUE
[17:01:28.490] - reassign environment for ‘...future.FUN’
[17:01:28.490] - copied ‘...future.FUN’ to environment
[17:01:28.490] - copied ‘MoreArgs’ to environment
[17:01:28.490] - copied ‘...future.elements_ii’ to environment
[17:01:28.490] - copied ‘...future.seeds_ii’ to environment
[17:01:28.491] - copied ‘...future.globals.maxSize’ to environment
[17:01:28.491] assign_globals() ... done
[17:01:28.491] requestCore(): workers = 2
[17:01:28.493] MulticoreFuture started
[17:01:28.494] - Launch lazy future ... done
[17:01:28.494] run() for ‘MulticoreFuture’ ... done
[17:01:28.494] plan(): Setting new future strategy stack:
[17:01:28.495] Created future:
[17:01:28.495] List of future strategies:
[17:01:28.495] 1. sequential:
[17:01:28.495]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:28.495]    - tweaked: FALSE
[17:01:28.495]    - call: NULL
[17:01:28.496] plan(): nbrOfWorkers() = 1
[17:01:28.499] plan(): Setting new future strategy stack:
[17:01:28.499] List of future strategies:
[17:01:28.499] 1. multicore:
[17:01:28.499]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:28.499]    - tweaked: FALSE
[17:01:28.499]    - call: plan(strategy)
[17:01:28.505] plan(): nbrOfWorkers() = 2
[17:01:28.495] MulticoreFuture:
[17:01:28.495] Label: ‘future_mapply-2’
[17:01:28.495] Expression:
[17:01:28.495] {
[17:01:28.495]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:28.495]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:28.495]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:28.495]         on.exit(options(oopts), add = TRUE)
[17:01:28.495]     }
[17:01:28.495]     {
[17:01:28.495]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:28.495]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:28.495]         do.call(mapply, args = args)
[17:01:28.495]     }
[17:01:28.495] }
[17:01:28.495] Lazy evaluation: FALSE
[17:01:28.495] Asynchronous evaluation: TRUE
[17:01:28.495] Local evaluation: TRUE
[17:01:28.495] Environment: R_GlobalEnv
[17:01:28.495] Capture standard output: NA
[17:01:28.495] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:28.495] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:28.495] Packages: <none>
[17:01:28.495] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:28.495] Resolved: TRUE
[17:01:28.495] Value: <not collected>
[17:01:28.495] Conditions captured: <none>
[17:01:28.495] Early signaling: FALSE
[17:01:28.495] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:28.495] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:28.506] Chunk #2 of 2 ... DONE
[17:01:28.506] Launching 2 futures (chunks) ... DONE
[17:01:28.506] Resolving 2 futures (chunks) ...
[17:01:28.507] resolve() on list ...
[17:01:28.507]  recursive: 0
[17:01:28.507]  length: 2
[17:01:28.507] 
[17:01:28.518] Future #2
[17:01:28.518] result() for MulticoreFuture ...
[17:01:28.519] result() for MulticoreFuture ...
[17:01:28.519] result() for MulticoreFuture ... done
[17:01:28.520] result() for MulticoreFuture ... done
[17:01:28.520] result() for MulticoreFuture ...
[17:01:28.520] result() for MulticoreFuture ... done
[17:01:28.520] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:28.520] - nx: 2
[17:01:28.520] - relay: TRUE
[17:01:28.520] - stdout: TRUE
[17:01:28.521] - signal: TRUE
[17:01:28.521] - resignal: FALSE
[17:01:28.521] - force: TRUE
[17:01:28.521] - relayed: [n=2] FALSE, FALSE
[17:01:28.521] - queued futures: [n=2] FALSE, FALSE
[17:01:28.521]  - until=1
[17:01:28.521]  - relaying element #1
[17:01:28.522] - relayed: [n=2] FALSE, FALSE
[17:01:28.522] - queued futures: [n=2] FALSE, TRUE
[17:01:28.522] signalConditionsASAP(NULL, pos=2) ... done
[17:01:28.522]  length: 1 (resolved future 2)
[17:01:28.943] plan(): Setting new future strategy stack:
[17:01:28.944] List of future strategies:
[17:01:28.944] 1. multicore:
[17:01:28.944]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:28.944]    - tweaked: FALSE
[17:01:28.944]    - call: plan(strategy)
[17:01:28.948] plan(): nbrOfWorkers() = 2
[17:01:28.949] Future #1
[17:01:28.949] result() for MulticoreFuture ...
[17:01:28.950] result() for MulticoreFuture ...
[17:01:28.950] result() for MulticoreFuture ... done
[17:01:28.950] result() for MulticoreFuture ... done
[17:01:28.950] result() for MulticoreFuture ...
[17:01:28.950] result() for MulticoreFuture ... done
[17:01:28.950] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:28.951] - nx: 2
[17:01:28.951] - relay: TRUE
[17:01:28.951] - stdout: TRUE
[17:01:28.951] - signal: TRUE
[17:01:28.951] - resignal: FALSE
[17:01:28.951] - force: TRUE
[17:01:28.951] - relayed: [n=2] FALSE, FALSE
[17:01:28.951] - queued futures: [n=2] FALSE, TRUE
[17:01:28.951]  - until=1
[17:01:28.952]  - relaying element #1
[17:01:28.952] result() for MulticoreFuture ...
[17:01:28.952] result() for MulticoreFuture ... done
[17:01:28.952] result() for MulticoreFuture ...
[17:01:28.952] result() for MulticoreFuture ... done
[17:01:28.952] result() for MulticoreFuture ...
[17:01:28.952] result() for MulticoreFuture ... done
[17:01:28.952] result() for MulticoreFuture ...
[17:01:28.953] result() for MulticoreFuture ... done
[17:01:28.953] - relayed: [n=2] TRUE, FALSE
[17:01:28.953] - queued futures: [n=2] TRUE, TRUE
[17:01:28.953] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:28.953]  length: 0 (resolved future 1)
[17:01:28.953] Relaying remaining futures
[17:01:28.953] signalConditionsASAP(NULL, pos=0) ...
[17:01:28.953] - nx: 2
[17:01:28.953] - relay: TRUE
[17:01:28.953] - stdout: TRUE
[17:01:28.954] - signal: TRUE
[17:01:28.954] - resignal: FALSE
[17:01:28.954] - force: TRUE
[17:01:28.954] - relayed: [n=2] TRUE, FALSE
[17:01:28.954] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:28.954]  - relaying element #2
[17:01:28.954] result() for MulticoreFuture ...
[17:01:28.954] result() for MulticoreFuture ... done
[17:01:28.954] result() for MulticoreFuture ...
[17:01:28.955] result() for MulticoreFuture ... done
[17:01:28.955] result() for MulticoreFuture ...
[17:01:28.955] result() for MulticoreFuture ... done
[17:01:28.955] result() for MulticoreFuture ...
[17:01:28.955] result() for MulticoreFuture ... done
[17:01:28.955] - relayed: [n=2] TRUE, TRUE
[17:01:28.955] - queued futures: [n=2] TRUE, TRUE
[17:01:28.956] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:01:28.956] resolve() on list ... DONE
[17:01:28.956] result() for MulticoreFuture ...
[17:01:28.956] result() for MulticoreFuture ... done
[17:01:28.956] result() for MulticoreFuture ...
[17:01:28.956] result() for MulticoreFuture ... done
[17:01:28.956] result() for MulticoreFuture ...
[17:01:28.956] result() for MulticoreFuture ... done
[17:01:28.957] result() for MulticoreFuture ...
[17:01:28.957] result() for MulticoreFuture ... done
[17:01:28.957]  - Number of value chunks collected: 2
[17:01:28.957] Resolving 2 futures (chunks) ... DONE
[17:01:28.957] Reducing values from 2 chunks ...
[17:01:28.957]  - Number of values collected after concatenation: 2
[17:01:28.957]  - Number of values expected: 2
[17:01:28.957] Reducing values from 2 chunks ... DONE
[17:01:28.957] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[17:01:28.958] plan(): Setting new future strategy stack:
[17:01:28.958] List of future strategies:
[17:01:28.958] 1. multisession:
[17:01:28.958]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:28.958]    - tweaked: FALSE
[17:01:28.958]    - call: plan(strategy)
[17:01:28.959] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:01:28.959] multisession:
[17:01:28.959] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:28.959] - tweaked: FALSE
[17:01:28.959] - call: plan(strategy)
[17:01:28.965] getGlobalsAndPackages() ...
[17:01:28.966] Not searching for globals
[17:01:28.966] - globals: [0] <none>
[17:01:28.966] getGlobalsAndPackages() ... DONE
[17:01:28.966] [local output] makeClusterPSOCK() ...
[17:01:29.015] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:01:29.017] [local output] Base port: 11792
[17:01:29.017] [local output] Getting setup options for 2 cluster nodes ...
[17:01:29.017] [local output]  - Node 1 of 2 ...
[17:01:29.017] [local output] localMachine=TRUE => revtunnel=FALSE

[17:01:29.018] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpHdI1Kt/worker.rank=1.parallelly.parent=37812.93b4bfafa17.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpHdI1Kt/worker.rank=1.parallelly.parent=37812.93b4bfafa17.pid")'’
[17:01:29.211] - Possible to infer worker's PID: TRUE
[17:01:29.211] [local output] Rscript port: 11792

[17:01:29.212] [local output]  - Node 2 of 2 ...
[17:01:29.212] [local output] localMachine=TRUE => revtunnel=FALSE

[17:01:29.213] [local output] Rscript port: 11792

[17:01:29.213] [local output] Getting setup options for 2 cluster nodes ... done
[17:01:29.213] [local output]  - Parallel setup requested for some PSOCK nodes
[17:01:29.214] [local output] Setting up PSOCK nodes in parallel
[17:01:29.214] List of 36
[17:01:29.214]  $ worker          : chr "localhost"
[17:01:29.214]   ..- attr(*, "localhost")= logi TRUE
[17:01:29.214]  $ master          : chr "localhost"
[17:01:29.214]  $ port            : int 11792
[17:01:29.214]  $ connectTimeout  : num 120
[17:01:29.214]  $ timeout         : num 2592000
[17:01:29.214]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:01:29.214]  $ homogeneous     : logi TRUE
[17:01:29.214]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:01:29.214]  $ rscript_envs    : NULL
[17:01:29.214]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:01:29.214]  $ rscript_startup : NULL
[17:01:29.214]  $ rscript_sh      : chr "sh"
[17:01:29.214]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:01:29.214]  $ methods         : logi TRUE
[17:01:29.214]  $ socketOptions   : chr "no-delay"
[17:01:29.214]  $ useXDR          : logi FALSE
[17:01:29.214]  $ outfile         : chr "/dev/null"
[17:01:29.214]  $ renice          : int NA
[17:01:29.214]  $ rshcmd          : NULL
[17:01:29.214]  $ user            : chr(0) 
[17:01:29.214]  $ revtunnel       : logi FALSE
[17:01:29.214]  $ rshlogfile      : NULL
[17:01:29.214]  $ rshopts         : chr(0) 
[17:01:29.214]  $ rank            : int 1
[17:01:29.214]  $ manual          : logi FALSE
[17:01:29.214]  $ dryrun          : logi FALSE
[17:01:29.214]  $ quiet           : logi FALSE
[17:01:29.214]  $ setup_strategy  : chr "parallel"
[17:01:29.214]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:01:29.214]  $ pidfile         : chr "/tmp/RtmpHdI1Kt/worker.rank=1.parallelly.parent=37812.93b4bfafa17.pid"
[17:01:29.214]  $ rshcmd_label    : NULL
[17:01:29.214]  $ rsh_call        : NULL
[17:01:29.214]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:01:29.214]  $ localMachine    : logi TRUE
[17:01:29.214]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:01:29.214]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:01:29.214]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:01:29.214]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:01:29.214]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:01:29.214]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:01:29.214]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:01:29.214]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:01:29.214]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:01:29.214]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:01:29.214]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:01:29.214]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:01:29.214]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:01:29.214]  $ arguments       :List of 28
[17:01:29.214]   ..$ worker          : chr "localhost"
[17:01:29.214]   ..$ master          : NULL
[17:01:29.214]   ..$ port            : int 11792
[17:01:29.214]   ..$ connectTimeout  : num 120
[17:01:29.214]   ..$ timeout         : num 2592000
[17:01:29.214]   ..$ rscript         : NULL
[17:01:29.214]   ..$ homogeneous     : NULL
[17:01:29.214]   ..$ rscript_args    : NULL
[17:01:29.214]   ..$ rscript_envs    : NULL
[17:01:29.214]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:01:29.214]   ..$ rscript_startup : NULL
[17:01:29.214]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:01:29.214]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:01:29.214]   ..$ methods         : logi TRUE
[17:01:29.214]   ..$ socketOptions   : chr "no-delay"
[17:01:29.214]   ..$ useXDR          : logi FALSE
[17:01:29.214]   ..$ outfile         : chr "/dev/null"
[17:01:29.214]   ..$ renice          : int NA
[17:01:29.214]   ..$ rshcmd          : NULL
[17:01:29.214]   ..$ user            : NULL
[17:01:29.214]   ..$ revtunnel       : logi NA
[17:01:29.214]   ..$ rshlogfile      : NULL
[17:01:29.214]   ..$ rshopts         : NULL
[17:01:29.214]   ..$ rank            : int 1
[17:01:29.214]   ..$ manual          : logi FALSE
[17:01:29.214]   ..$ dryrun          : logi FALSE
[17:01:29.214]   ..$ quiet           : logi FALSE
[17:01:29.214]   ..$ setup_strategy  : chr "parallel"
[17:01:29.214]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:01:29.230] [local output] System call to launch all workers:
[17:01:29.231] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpHdI1Kt/worker.rank=1.parallelly.parent=37812.93b4bfafa17.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11792 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:01:29.231] [local output] Starting PSOCK main server
[17:01:29.237] [local output] Workers launched
[17:01:29.237] [local output] Waiting for workers to connect back
[17:01:29.237]  - [local output] 0 workers out of 2 ready
[17:01:29.481]  - [local output] 0 workers out of 2 ready
[17:01:29.482]  - [local output] 1 workers out of 2 ready
[17:01:29.489]  - [local output] 1 workers out of 2 ready
[17:01:29.489]  - [local output] 2 workers out of 2 ready
[17:01:29.489] [local output] Launching of workers completed
[17:01:29.489] [local output] Collecting session information from workers
[17:01:29.490] [local output]  - Worker #1 of 2
[17:01:29.491] [local output]  - Worker #2 of 2
[17:01:29.491] [local output] makeClusterPSOCK() ... done
[17:01:29.502] Packages needed by the future expression (n = 0): <none>
[17:01:29.502] Packages needed by future strategies (n = 0): <none>
[17:01:29.503] {
[17:01:29.503]     {
[17:01:29.503]         {
[17:01:29.503]             ...future.startTime <- base::Sys.time()
[17:01:29.503]             {
[17:01:29.503]                 {
[17:01:29.503]                   {
[17:01:29.503]                     {
[17:01:29.503]                       base::local({
[17:01:29.503]                         has_future <- base::requireNamespace("future", 
[17:01:29.503]                           quietly = TRUE)
[17:01:29.503]                         if (has_future) {
[17:01:29.503]                           ns <- base::getNamespace("future")
[17:01:29.503]                           version <- ns[[".package"]][["version"]]
[17:01:29.503]                           if (is.null(version)) 
[17:01:29.503]                             version <- utils::packageVersion("future")
[17:01:29.503]                         }
[17:01:29.503]                         else {
[17:01:29.503]                           version <- NULL
[17:01:29.503]                         }
[17:01:29.503]                         if (!has_future || version < "1.8.0") {
[17:01:29.503]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:29.503]                             "", base::R.version$version.string), 
[17:01:29.503]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:29.503]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:29.503]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:29.503]                               "release", "version")], collapse = " "), 
[17:01:29.503]                             hostname = base::Sys.info()[["nodename"]])
[17:01:29.503]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:29.503]                             info)
[17:01:29.503]                           info <- base::paste(info, collapse = "; ")
[17:01:29.503]                           if (!has_future) {
[17:01:29.503]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:29.503]                               info)
[17:01:29.503]                           }
[17:01:29.503]                           else {
[17:01:29.503]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:29.503]                               info, version)
[17:01:29.503]                           }
[17:01:29.503]                           base::stop(msg)
[17:01:29.503]                         }
[17:01:29.503]                       })
[17:01:29.503]                     }
[17:01:29.503]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:29.503]                     base::options(mc.cores = 1L)
[17:01:29.503]                   }
[17:01:29.503]                   ...future.strategy.old <- future::plan("list")
[17:01:29.503]                   options(future.plan = NULL)
[17:01:29.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:29.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:29.503]                 }
[17:01:29.503]                 ...future.workdir <- getwd()
[17:01:29.503]             }
[17:01:29.503]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:29.503]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:29.503]         }
[17:01:29.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:29.503]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:29.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:29.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:29.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:29.503]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:29.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:29.503]             base::names(...future.oldOptions))
[17:01:29.503]     }
[17:01:29.503]     if (FALSE) {
[17:01:29.503]     }
[17:01:29.503]     else {
[17:01:29.503]         if (TRUE) {
[17:01:29.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:29.503]                 open = "w")
[17:01:29.503]         }
[17:01:29.503]         else {
[17:01:29.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:29.503]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:29.503]         }
[17:01:29.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:29.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:29.503]             base::sink(type = "output", split = FALSE)
[17:01:29.503]             base::close(...future.stdout)
[17:01:29.503]         }, add = TRUE)
[17:01:29.503]     }
[17:01:29.503]     ...future.frame <- base::sys.nframe()
[17:01:29.503]     ...future.conditions <- base::list()
[17:01:29.503]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:29.503]     if (FALSE) {
[17:01:29.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:29.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:29.503]     }
[17:01:29.503]     ...future.result <- base::tryCatch({
[17:01:29.503]         base::withCallingHandlers({
[17:01:29.503]             ...future.value <- base::withVisible(base::local({
[17:01:29.503]                 ...future.makeSendCondition <- base::local({
[17:01:29.503]                   sendCondition <- NULL
[17:01:29.503]                   function(frame = 1L) {
[17:01:29.503]                     if (is.function(sendCondition)) 
[17:01:29.503]                       return(sendCondition)
[17:01:29.503]                     ns <- getNamespace("parallel")
[17:01:29.503]                     if (exists("sendData", mode = "function", 
[17:01:29.503]                       envir = ns)) {
[17:01:29.503]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:29.503]                         envir = ns)
[17:01:29.503]                       envir <- sys.frame(frame)
[17:01:29.503]                       master <- NULL
[17:01:29.503]                       while (!identical(envir, .GlobalEnv) && 
[17:01:29.503]                         !identical(envir, emptyenv())) {
[17:01:29.503]                         if (exists("master", mode = "list", envir = envir, 
[17:01:29.503]                           inherits = FALSE)) {
[17:01:29.503]                           master <- get("master", mode = "list", 
[17:01:29.503]                             envir = envir, inherits = FALSE)
[17:01:29.503]                           if (inherits(master, c("SOCKnode", 
[17:01:29.503]                             "SOCK0node"))) {
[17:01:29.503]                             sendCondition <<- function(cond) {
[17:01:29.503]                               data <- list(type = "VALUE", value = cond, 
[17:01:29.503]                                 success = TRUE)
[17:01:29.503]                               parallel_sendData(master, data)
[17:01:29.503]                             }
[17:01:29.503]                             return(sendCondition)
[17:01:29.503]                           }
[17:01:29.503]                         }
[17:01:29.503]                         frame <- frame + 1L
[17:01:29.503]                         envir <- sys.frame(frame)
[17:01:29.503]                       }
[17:01:29.503]                     }
[17:01:29.503]                     sendCondition <<- function(cond) NULL
[17:01:29.503]                   }
[17:01:29.503]                 })
[17:01:29.503]                 withCallingHandlers({
[17:01:29.503]                   NA
[17:01:29.503]                 }, immediateCondition = function(cond) {
[17:01:29.503]                   sendCondition <- ...future.makeSendCondition()
[17:01:29.503]                   sendCondition(cond)
[17:01:29.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:29.503]                   {
[17:01:29.503]                     inherits <- base::inherits
[17:01:29.503]                     invokeRestart <- base::invokeRestart
[17:01:29.503]                     is.null <- base::is.null
[17:01:29.503]                     muffled <- FALSE
[17:01:29.503]                     if (inherits(cond, "message")) {
[17:01:29.503]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:29.503]                       if (muffled) 
[17:01:29.503]                         invokeRestart("muffleMessage")
[17:01:29.503]                     }
[17:01:29.503]                     else if (inherits(cond, "warning")) {
[17:01:29.503]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:29.503]                       if (muffled) 
[17:01:29.503]                         invokeRestart("muffleWarning")
[17:01:29.503]                     }
[17:01:29.503]                     else if (inherits(cond, "condition")) {
[17:01:29.503]                       if (!is.null(pattern)) {
[17:01:29.503]                         computeRestarts <- base::computeRestarts
[17:01:29.503]                         grepl <- base::grepl
[17:01:29.503]                         restarts <- computeRestarts(cond)
[17:01:29.503]                         for (restart in restarts) {
[17:01:29.503]                           name <- restart$name
[17:01:29.503]                           if (is.null(name)) 
[17:01:29.503]                             next
[17:01:29.503]                           if (!grepl(pattern, name)) 
[17:01:29.503]                             next
[17:01:29.503]                           invokeRestart(restart)
[17:01:29.503]                           muffled <- TRUE
[17:01:29.503]                           break
[17:01:29.503]                         }
[17:01:29.503]                       }
[17:01:29.503]                     }
[17:01:29.503]                     invisible(muffled)
[17:01:29.503]                   }
[17:01:29.503]                   muffleCondition(cond)
[17:01:29.503]                 })
[17:01:29.503]             }))
[17:01:29.503]             future::FutureResult(value = ...future.value$value, 
[17:01:29.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:29.503]                   ...future.rng), globalenv = if (FALSE) 
[17:01:29.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:29.503]                     ...future.globalenv.names))
[17:01:29.503]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:29.503]         }, condition = base::local({
[17:01:29.503]             c <- base::c
[17:01:29.503]             inherits <- base::inherits
[17:01:29.503]             invokeRestart <- base::invokeRestart
[17:01:29.503]             length <- base::length
[17:01:29.503]             list <- base::list
[17:01:29.503]             seq.int <- base::seq.int
[17:01:29.503]             signalCondition <- base::signalCondition
[17:01:29.503]             sys.calls <- base::sys.calls
[17:01:29.503]             `[[` <- base::`[[`
[17:01:29.503]             `+` <- base::`+`
[17:01:29.503]             `<<-` <- base::`<<-`
[17:01:29.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:29.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:29.503]                   3L)]
[17:01:29.503]             }
[17:01:29.503]             function(cond) {
[17:01:29.503]                 is_error <- inherits(cond, "error")
[17:01:29.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:29.503]                   NULL)
[17:01:29.503]                 if (is_error) {
[17:01:29.503]                   sessionInformation <- function() {
[17:01:29.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:29.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:29.503]                       search = base::search(), system = base::Sys.info())
[17:01:29.503]                   }
[17:01:29.503]                   ...future.conditions[[length(...future.conditions) + 
[17:01:29.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:29.503]                     cond$call), session = sessionInformation(), 
[17:01:29.503]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:29.503]                   signalCondition(cond)
[17:01:29.503]                 }
[17:01:29.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:29.503]                 "immediateCondition"))) {
[17:01:29.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:29.503]                   ...future.conditions[[length(...future.conditions) + 
[17:01:29.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:29.503]                   if (TRUE && !signal) {
[17:01:29.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:29.503]                     {
[17:01:29.503]                       inherits <- base::inherits
[17:01:29.503]                       invokeRestart <- base::invokeRestart
[17:01:29.503]                       is.null <- base::is.null
[17:01:29.503]                       muffled <- FALSE
[17:01:29.503]                       if (inherits(cond, "message")) {
[17:01:29.503]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:29.503]                         if (muffled) 
[17:01:29.503]                           invokeRestart("muffleMessage")
[17:01:29.503]                       }
[17:01:29.503]                       else if (inherits(cond, "warning")) {
[17:01:29.503]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:29.503]                         if (muffled) 
[17:01:29.503]                           invokeRestart("muffleWarning")
[17:01:29.503]                       }
[17:01:29.503]                       else if (inherits(cond, "condition")) {
[17:01:29.503]                         if (!is.null(pattern)) {
[17:01:29.503]                           computeRestarts <- base::computeRestarts
[17:01:29.503]                           grepl <- base::grepl
[17:01:29.503]                           restarts <- computeRestarts(cond)
[17:01:29.503]                           for (restart in restarts) {
[17:01:29.503]                             name <- restart$name
[17:01:29.503]                             if (is.null(name)) 
[17:01:29.503]                               next
[17:01:29.503]                             if (!grepl(pattern, name)) 
[17:01:29.503]                               next
[17:01:29.503]                             invokeRestart(restart)
[17:01:29.503]                             muffled <- TRUE
[17:01:29.503]                             break
[17:01:29.503]                           }
[17:01:29.503]                         }
[17:01:29.503]                       }
[17:01:29.503]                       invisible(muffled)
[17:01:29.503]                     }
[17:01:29.503]                     muffleCondition(cond, pattern = "^muffle")
[17:01:29.503]                   }
[17:01:29.503]                 }
[17:01:29.503]                 else {
[17:01:29.503]                   if (TRUE) {
[17:01:29.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:29.503]                     {
[17:01:29.503]                       inherits <- base::inherits
[17:01:29.503]                       invokeRestart <- base::invokeRestart
[17:01:29.503]                       is.null <- base::is.null
[17:01:29.503]                       muffled <- FALSE
[17:01:29.503]                       if (inherits(cond, "message")) {
[17:01:29.503]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:29.503]                         if (muffled) 
[17:01:29.503]                           invokeRestart("muffleMessage")
[17:01:29.503]                       }
[17:01:29.503]                       else if (inherits(cond, "warning")) {
[17:01:29.503]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:29.503]                         if (muffled) 
[17:01:29.503]                           invokeRestart("muffleWarning")
[17:01:29.503]                       }
[17:01:29.503]                       else if (inherits(cond, "condition")) {
[17:01:29.503]                         if (!is.null(pattern)) {
[17:01:29.503]                           computeRestarts <- base::computeRestarts
[17:01:29.503]                           grepl <- base::grepl
[17:01:29.503]                           restarts <- computeRestarts(cond)
[17:01:29.503]                           for (restart in restarts) {
[17:01:29.503]                             name <- restart$name
[17:01:29.503]                             if (is.null(name)) 
[17:01:29.503]                               next
[17:01:29.503]                             if (!grepl(pattern, name)) 
[17:01:29.503]                               next
[17:01:29.503]                             invokeRestart(restart)
[17:01:29.503]                             muffled <- TRUE
[17:01:29.503]                             break
[17:01:29.503]                           }
[17:01:29.503]                         }
[17:01:29.503]                       }
[17:01:29.503]                       invisible(muffled)
[17:01:29.503]                     }
[17:01:29.503]                     muffleCondition(cond, pattern = "^muffle")
[17:01:29.503]                   }
[17:01:29.503]                 }
[17:01:29.503]             }
[17:01:29.503]         }))
[17:01:29.503]     }, error = function(ex) {
[17:01:29.503]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:29.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:29.503]                 ...future.rng), started = ...future.startTime, 
[17:01:29.503]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:29.503]             version = "1.8"), class = "FutureResult")
[17:01:29.503]     }, finally = {
[17:01:29.503]         if (!identical(...future.workdir, getwd())) 
[17:01:29.503]             setwd(...future.workdir)
[17:01:29.503]         {
[17:01:29.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:29.503]                 ...future.oldOptions$nwarnings <- NULL
[17:01:29.503]             }
[17:01:29.503]             base::options(...future.oldOptions)
[17:01:29.503]             if (.Platform$OS.type == "windows") {
[17:01:29.503]                 old_names <- names(...future.oldEnvVars)
[17:01:29.503]                 envs <- base::Sys.getenv()
[17:01:29.503]                 names <- names(envs)
[17:01:29.503]                 common <- intersect(names, old_names)
[17:01:29.503]                 added <- setdiff(names, old_names)
[17:01:29.503]                 removed <- setdiff(old_names, names)
[17:01:29.503]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:29.503]                   envs[common]]
[17:01:29.503]                 NAMES <- toupper(changed)
[17:01:29.503]                 args <- list()
[17:01:29.503]                 for (kk in seq_along(NAMES)) {
[17:01:29.503]                   name <- changed[[kk]]
[17:01:29.503]                   NAME <- NAMES[[kk]]
[17:01:29.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:29.503]                     next
[17:01:29.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:29.503]                 }
[17:01:29.503]                 NAMES <- toupper(added)
[17:01:29.503]                 for (kk in seq_along(NAMES)) {
[17:01:29.503]                   name <- added[[kk]]
[17:01:29.503]                   NAME <- NAMES[[kk]]
[17:01:29.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:29.503]                     next
[17:01:29.503]                   args[[name]] <- ""
[17:01:29.503]                 }
[17:01:29.503]                 NAMES <- toupper(removed)
[17:01:29.503]                 for (kk in seq_along(NAMES)) {
[17:01:29.503]                   name <- removed[[kk]]
[17:01:29.503]                   NAME <- NAMES[[kk]]
[17:01:29.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:29.503]                     next
[17:01:29.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:29.503]                 }
[17:01:29.503]                 if (length(args) > 0) 
[17:01:29.503]                   base::do.call(base::Sys.setenv, args = args)
[17:01:29.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:29.503]             }
[17:01:29.503]             else {
[17:01:29.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:29.503]             }
[17:01:29.503]             {
[17:01:29.503]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:29.503]                   0L) {
[17:01:29.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:29.503]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:29.503]                   base::options(opts)
[17:01:29.503]                 }
[17:01:29.503]                 {
[17:01:29.503]                   {
[17:01:29.503]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:29.503]                     NULL
[17:01:29.503]                   }
[17:01:29.503]                   options(future.plan = NULL)
[17:01:29.503]                   if (is.na(NA_character_)) 
[17:01:29.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:29.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:29.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:29.503]                     .init = FALSE)
[17:01:29.503]                 }
[17:01:29.503]             }
[17:01:29.503]         }
[17:01:29.503]     })
[17:01:29.503]     if (TRUE) {
[17:01:29.503]         base::sink(type = "output", split = FALSE)
[17:01:29.503]         if (TRUE) {
[17:01:29.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:29.503]         }
[17:01:29.503]         else {
[17:01:29.503]             ...future.result["stdout"] <- base::list(NULL)
[17:01:29.503]         }
[17:01:29.503]         base::close(...future.stdout)
[17:01:29.503]         ...future.stdout <- NULL
[17:01:29.503]     }
[17:01:29.503]     ...future.result$conditions <- ...future.conditions
[17:01:29.503]     ...future.result$finished <- base::Sys.time()
[17:01:29.503]     ...future.result
[17:01:29.503] }
[17:01:29.557] MultisessionFuture started
[17:01:29.557] result() for ClusterFuture ...
[17:01:29.557] receiveMessageFromWorker() for ClusterFuture ...
[17:01:29.558] - Validating connection of MultisessionFuture
[17:01:29.590] - received message: FutureResult
[17:01:29.590] - Received FutureResult
[17:01:29.590] - Erased future from FutureRegistry
[17:01:29.590] result() for ClusterFuture ...
[17:01:29.590] - result already collected: FutureResult
[17:01:29.591] result() for ClusterFuture ... done
[17:01:29.591] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:29.591] result() for ClusterFuture ... done
[17:01:29.591] result() for ClusterFuture ...
[17:01:29.591] - result already collected: FutureResult
[17:01:29.591] result() for ClusterFuture ... done
[17:01:29.591] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:01:29.595] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:01:29.595] future_lapply() ...
[17:01:29.600] Number of chunks: 2
[17:01:29.600] getGlobalsAndPackagesXApply() ...
[17:01:29.600]  - future.globals: TRUE
[17:01:29.600] getGlobalsAndPackages() ...
[17:01:29.600] Searching for globals...
[17:01:29.602] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:29.602] Searching for globals ... DONE
[17:01:29.602] Resolving globals: FALSE
[17:01:29.603] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:29.603] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:29.604] - globals: [1] ‘FUN’
[17:01:29.604] 
[17:01:29.604] getGlobalsAndPackages() ... DONE
[17:01:29.604]  - globals found/used: [n=1] ‘FUN’
[17:01:29.604]  - needed namespaces: [n=0] 
[17:01:29.604] Finding globals ... DONE
[17:01:29.604]  - use_args: TRUE
[17:01:29.604]  - Getting '...' globals ...
[17:01:29.605] resolve() on list ...
[17:01:29.605]  recursive: 0
[17:01:29.605]  length: 1
[17:01:29.605]  elements: ‘...’
[17:01:29.605]  length: 0 (resolved future 1)
[17:01:29.605] resolve() on list ... DONE
[17:01:29.606]    - '...' content: [n=0] 
[17:01:29.606] List of 1
[17:01:29.606]  $ ...: list()
[17:01:29.606]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:29.606]  - attr(*, "where")=List of 1
[17:01:29.606]   ..$ ...:<environment: 0x5636f7f54820> 
[17:01:29.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:29.606]  - attr(*, "resolved")= logi TRUE
[17:01:29.606]  - attr(*, "total_size")= num NA
[17:01:29.609]  - Getting '...' globals ... DONE
[17:01:29.609] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:29.609] List of 2
[17:01:29.609]  $ ...future.FUN:function (x)  
[17:01:29.609]  $ ...          : list()
[17:01:29.609]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:29.609]  - attr(*, "where")=List of 2
[17:01:29.609]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:29.609]   ..$ ...          :<environment: 0x5636f7f54820> 
[17:01:29.609]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:29.609]  - attr(*, "resolved")= logi FALSE
[17:01:29.609]  - attr(*, "total_size")= num 4720
[17:01:29.613] Packages to be attached in all futures: [n=0] 
[17:01:29.613] getGlobalsAndPackagesXApply() ... DONE
[17:01:29.613] Number of futures (= number of chunks): 2
[17:01:29.613] Launching 2 futures (chunks) ...
[17:01:29.613] Chunk #1 of 2 ...
[17:01:29.613]  - Finding globals in 'X' for chunk #1 ...
[17:01:29.614] getGlobalsAndPackages() ...
[17:01:29.614] Searching for globals...
[17:01:29.614] 
[17:01:29.614] Searching for globals ... DONE
[17:01:29.614] - globals: [0] <none>
[17:01:29.614] getGlobalsAndPackages() ... DONE
[17:01:29.614]    + additional globals found: [n=0] 
[17:01:29.615]    + additional namespaces needed: [n=0] 
[17:01:29.615]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:29.615]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:29.615]  - seeds: <none>
[17:01:29.615]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:29.615] getGlobalsAndPackages() ...
[17:01:29.615] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:29.615] Resolving globals: FALSE
[17:01:29.616] Tweak future expression to call with '...' arguments ...
[17:01:29.616] {
[17:01:29.616]     do.call(function(...) {
[17:01:29.616]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:29.616]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:29.616]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:29.616]             on.exit(options(oopts), add = TRUE)
[17:01:29.616]         }
[17:01:29.616]         {
[17:01:29.616]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:29.616]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:29.616]                 ...future.FUN(...future.X_jj, ...)
[17:01:29.616]             })
[17:01:29.616]         }
[17:01:29.616]     }, args = future.call.arguments)
[17:01:29.616] }
[17:01:29.616] Tweak future expression to call with '...' arguments ... DONE
[17:01:29.616] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:29.617] 
[17:01:29.617] getGlobalsAndPackages() ... DONE
[17:01:29.617] run() for ‘Future’ ...
[17:01:29.617] - state: ‘created’
[17:01:29.617] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:29.632] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:29.633] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:29.633]   - Field: ‘node’
[17:01:29.633]   - Field: ‘label’
[17:01:29.633]   - Field: ‘local’
[17:01:29.633]   - Field: ‘owner’
[17:01:29.633]   - Field: ‘envir’
[17:01:29.633]   - Field: ‘workers’
[17:01:29.633]   - Field: ‘packages’
[17:01:29.633]   - Field: ‘gc’
[17:01:29.634]   - Field: ‘conditions’
[17:01:29.634]   - Field: ‘persistent’
[17:01:29.634]   - Field: ‘expr’
[17:01:29.634]   - Field: ‘uuid’
[17:01:29.634]   - Field: ‘seed’
[17:01:29.634]   - Field: ‘version’
[17:01:29.634]   - Field: ‘result’
[17:01:29.634]   - Field: ‘asynchronous’
[17:01:29.634]   - Field: ‘calls’
[17:01:29.635]   - Field: ‘globals’
[17:01:29.635]   - Field: ‘stdout’
[17:01:29.635]   - Field: ‘earlySignal’
[17:01:29.635]   - Field: ‘lazy’
[17:01:29.635]   - Field: ‘state’
[17:01:29.635] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:29.635] - Launch lazy future ...
[17:01:29.636] Packages needed by the future expression (n = 0): <none>
[17:01:29.636] Packages needed by future strategies (n = 0): <none>
[17:01:29.636] {
[17:01:29.636]     {
[17:01:29.636]         {
[17:01:29.636]             ...future.startTime <- base::Sys.time()
[17:01:29.636]             {
[17:01:29.636]                 {
[17:01:29.636]                   {
[17:01:29.636]                     {
[17:01:29.636]                       base::local({
[17:01:29.636]                         has_future <- base::requireNamespace("future", 
[17:01:29.636]                           quietly = TRUE)
[17:01:29.636]                         if (has_future) {
[17:01:29.636]                           ns <- base::getNamespace("future")
[17:01:29.636]                           version <- ns[[".package"]][["version"]]
[17:01:29.636]                           if (is.null(version)) 
[17:01:29.636]                             version <- utils::packageVersion("future")
[17:01:29.636]                         }
[17:01:29.636]                         else {
[17:01:29.636]                           version <- NULL
[17:01:29.636]                         }
[17:01:29.636]                         if (!has_future || version < "1.8.0") {
[17:01:29.636]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:29.636]                             "", base::R.version$version.string), 
[17:01:29.636]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:29.636]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:29.636]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:29.636]                               "release", "version")], collapse = " "), 
[17:01:29.636]                             hostname = base::Sys.info()[["nodename"]])
[17:01:29.636]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:29.636]                             info)
[17:01:29.636]                           info <- base::paste(info, collapse = "; ")
[17:01:29.636]                           if (!has_future) {
[17:01:29.636]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:29.636]                               info)
[17:01:29.636]                           }
[17:01:29.636]                           else {
[17:01:29.636]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:29.636]                               info, version)
[17:01:29.636]                           }
[17:01:29.636]                           base::stop(msg)
[17:01:29.636]                         }
[17:01:29.636]                       })
[17:01:29.636]                     }
[17:01:29.636]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:29.636]                     base::options(mc.cores = 1L)
[17:01:29.636]                   }
[17:01:29.636]                   ...future.strategy.old <- future::plan("list")
[17:01:29.636]                   options(future.plan = NULL)
[17:01:29.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:29.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:29.636]                 }
[17:01:29.636]                 ...future.workdir <- getwd()
[17:01:29.636]             }
[17:01:29.636]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:29.636]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:29.636]         }
[17:01:29.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:29.636]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:29.636]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:29.636]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:29.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:29.636]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:29.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:29.636]             base::names(...future.oldOptions))
[17:01:29.636]     }
[17:01:29.636]     if (FALSE) {
[17:01:29.636]     }
[17:01:29.636]     else {
[17:01:29.636]         if (FALSE) {
[17:01:29.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:29.636]                 open = "w")
[17:01:29.636]         }
[17:01:29.636]         else {
[17:01:29.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:29.636]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:29.636]         }
[17:01:29.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:29.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:29.636]             base::sink(type = "output", split = FALSE)
[17:01:29.636]             base::close(...future.stdout)
[17:01:29.636]         }, add = TRUE)
[17:01:29.636]     }
[17:01:29.636]     ...future.frame <- base::sys.nframe()
[17:01:29.636]     ...future.conditions <- base::list()
[17:01:29.636]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:29.636]     if (FALSE) {
[17:01:29.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:29.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:29.636]     }
[17:01:29.636]     ...future.result <- base::tryCatch({
[17:01:29.636]         base::withCallingHandlers({
[17:01:29.636]             ...future.value <- base::withVisible(base::local({
[17:01:29.636]                 ...future.makeSendCondition <- base::local({
[17:01:29.636]                   sendCondition <- NULL
[17:01:29.636]                   function(frame = 1L) {
[17:01:29.636]                     if (is.function(sendCondition)) 
[17:01:29.636]                       return(sendCondition)
[17:01:29.636]                     ns <- getNamespace("parallel")
[17:01:29.636]                     if (exists("sendData", mode = "function", 
[17:01:29.636]                       envir = ns)) {
[17:01:29.636]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:29.636]                         envir = ns)
[17:01:29.636]                       envir <- sys.frame(frame)
[17:01:29.636]                       master <- NULL
[17:01:29.636]                       while (!identical(envir, .GlobalEnv) && 
[17:01:29.636]                         !identical(envir, emptyenv())) {
[17:01:29.636]                         if (exists("master", mode = "list", envir = envir, 
[17:01:29.636]                           inherits = FALSE)) {
[17:01:29.636]                           master <- get("master", mode = "list", 
[17:01:29.636]                             envir = envir, inherits = FALSE)
[17:01:29.636]                           if (inherits(master, c("SOCKnode", 
[17:01:29.636]                             "SOCK0node"))) {
[17:01:29.636]                             sendCondition <<- function(cond) {
[17:01:29.636]                               data <- list(type = "VALUE", value = cond, 
[17:01:29.636]                                 success = TRUE)
[17:01:29.636]                               parallel_sendData(master, data)
[17:01:29.636]                             }
[17:01:29.636]                             return(sendCondition)
[17:01:29.636]                           }
[17:01:29.636]                         }
[17:01:29.636]                         frame <- frame + 1L
[17:01:29.636]                         envir <- sys.frame(frame)
[17:01:29.636]                       }
[17:01:29.636]                     }
[17:01:29.636]                     sendCondition <<- function(cond) NULL
[17:01:29.636]                   }
[17:01:29.636]                 })
[17:01:29.636]                 withCallingHandlers({
[17:01:29.636]                   {
[17:01:29.636]                     do.call(function(...) {
[17:01:29.636]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:29.636]                       if (!identical(...future.globals.maxSize.org, 
[17:01:29.636]                         ...future.globals.maxSize)) {
[17:01:29.636]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:29.636]                         on.exit(options(oopts), add = TRUE)
[17:01:29.636]                       }
[17:01:29.636]                       {
[17:01:29.636]                         lapply(seq_along(...future.elements_ii), 
[17:01:29.636]                           FUN = function(jj) {
[17:01:29.636]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:29.636]                             ...future.FUN(...future.X_jj, ...)
[17:01:29.636]                           })
[17:01:29.636]                       }
[17:01:29.636]                     }, args = future.call.arguments)
[17:01:29.636]                   }
[17:01:29.636]                 }, immediateCondition = function(cond) {
[17:01:29.636]                   sendCondition <- ...future.makeSendCondition()
[17:01:29.636]                   sendCondition(cond)
[17:01:29.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:29.636]                   {
[17:01:29.636]                     inherits <- base::inherits
[17:01:29.636]                     invokeRestart <- base::invokeRestart
[17:01:29.636]                     is.null <- base::is.null
[17:01:29.636]                     muffled <- FALSE
[17:01:29.636]                     if (inherits(cond, "message")) {
[17:01:29.636]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:29.636]                       if (muffled) 
[17:01:29.636]                         invokeRestart("muffleMessage")
[17:01:29.636]                     }
[17:01:29.636]                     else if (inherits(cond, "warning")) {
[17:01:29.636]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:29.636]                       if (muffled) 
[17:01:29.636]                         invokeRestart("muffleWarning")
[17:01:29.636]                     }
[17:01:29.636]                     else if (inherits(cond, "condition")) {
[17:01:29.636]                       if (!is.null(pattern)) {
[17:01:29.636]                         computeRestarts <- base::computeRestarts
[17:01:29.636]                         grepl <- base::grepl
[17:01:29.636]                         restarts <- computeRestarts(cond)
[17:01:29.636]                         for (restart in restarts) {
[17:01:29.636]                           name <- restart$name
[17:01:29.636]                           if (is.null(name)) 
[17:01:29.636]                             next
[17:01:29.636]                           if (!grepl(pattern, name)) 
[17:01:29.636]                             next
[17:01:29.636]                           invokeRestart(restart)
[17:01:29.636]                           muffled <- TRUE
[17:01:29.636]                           break
[17:01:29.636]                         }
[17:01:29.636]                       }
[17:01:29.636]                     }
[17:01:29.636]                     invisible(muffled)
[17:01:29.636]                   }
[17:01:29.636]                   muffleCondition(cond)
[17:01:29.636]                 })
[17:01:29.636]             }))
[17:01:29.636]             future::FutureResult(value = ...future.value$value, 
[17:01:29.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:29.636]                   ...future.rng), globalenv = if (FALSE) 
[17:01:29.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:29.636]                     ...future.globalenv.names))
[17:01:29.636]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:29.636]         }, condition = base::local({
[17:01:29.636]             c <- base::c
[17:01:29.636]             inherits <- base::inherits
[17:01:29.636]             invokeRestart <- base::invokeRestart
[17:01:29.636]             length <- base::length
[17:01:29.636]             list <- base::list
[17:01:29.636]             seq.int <- base::seq.int
[17:01:29.636]             signalCondition <- base::signalCondition
[17:01:29.636]             sys.calls <- base::sys.calls
[17:01:29.636]             `[[` <- base::`[[`
[17:01:29.636]             `+` <- base::`+`
[17:01:29.636]             `<<-` <- base::`<<-`
[17:01:29.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:29.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:29.636]                   3L)]
[17:01:29.636]             }
[17:01:29.636]             function(cond) {
[17:01:29.636]                 is_error <- inherits(cond, "error")
[17:01:29.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:29.636]                   NULL)
[17:01:29.636]                 if (is_error) {
[17:01:29.636]                   sessionInformation <- function() {
[17:01:29.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:29.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:29.636]                       search = base::search(), system = base::Sys.info())
[17:01:29.636]                   }
[17:01:29.636]                   ...future.conditions[[length(...future.conditions) + 
[17:01:29.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:29.636]                     cond$call), session = sessionInformation(), 
[17:01:29.636]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:29.636]                   signalCondition(cond)
[17:01:29.636]                 }
[17:01:29.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:29.636]                 "immediateCondition"))) {
[17:01:29.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:29.636]                   ...future.conditions[[length(...future.conditions) + 
[17:01:29.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:29.636]                   if (TRUE && !signal) {
[17:01:29.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:29.636]                     {
[17:01:29.636]                       inherits <- base::inherits
[17:01:29.636]                       invokeRestart <- base::invokeRestart
[17:01:29.636]                       is.null <- base::is.null
[17:01:29.636]                       muffled <- FALSE
[17:01:29.636]                       if (inherits(cond, "message")) {
[17:01:29.636]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:29.636]                         if (muffled) 
[17:01:29.636]                           invokeRestart("muffleMessage")
[17:01:29.636]                       }
[17:01:29.636]                       else if (inherits(cond, "warning")) {
[17:01:29.636]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:29.636]                         if (muffled) 
[17:01:29.636]                           invokeRestart("muffleWarning")
[17:01:29.636]                       }
[17:01:29.636]                       else if (inherits(cond, "condition")) {
[17:01:29.636]                         if (!is.null(pattern)) {
[17:01:29.636]                           computeRestarts <- base::computeRestarts
[17:01:29.636]                           grepl <- base::grepl
[17:01:29.636]                           restarts <- computeRestarts(cond)
[17:01:29.636]                           for (restart in restarts) {
[17:01:29.636]                             name <- restart$name
[17:01:29.636]                             if (is.null(name)) 
[17:01:29.636]                               next
[17:01:29.636]                             if (!grepl(pattern, name)) 
[17:01:29.636]                               next
[17:01:29.636]                             invokeRestart(restart)
[17:01:29.636]                             muffled <- TRUE
[17:01:29.636]                             break
[17:01:29.636]                           }
[17:01:29.636]                         }
[17:01:29.636]                       }
[17:01:29.636]                       invisible(muffled)
[17:01:29.636]                     }
[17:01:29.636]                     muffleCondition(cond, pattern = "^muffle")
[17:01:29.636]                   }
[17:01:29.636]                 }
[17:01:29.636]                 else {
[17:01:29.636]                   if (TRUE) {
[17:01:29.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:29.636]                     {
[17:01:29.636]                       inherits <- base::inherits
[17:01:29.636]                       invokeRestart <- base::invokeRestart
[17:01:29.636]                       is.null <- base::is.null
[17:01:29.636]                       muffled <- FALSE
[17:01:29.636]                       if (inherits(cond, "message")) {
[17:01:29.636]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:29.636]                         if (muffled) 
[17:01:29.636]                           invokeRestart("muffleMessage")
[17:01:29.636]                       }
[17:01:29.636]                       else if (inherits(cond, "warning")) {
[17:01:29.636]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:29.636]                         if (muffled) 
[17:01:29.636]                           invokeRestart("muffleWarning")
[17:01:29.636]                       }
[17:01:29.636]                       else if (inherits(cond, "condition")) {
[17:01:29.636]                         if (!is.null(pattern)) {
[17:01:29.636]                           computeRestarts <- base::computeRestarts
[17:01:29.636]                           grepl <- base::grepl
[17:01:29.636]                           restarts <- computeRestarts(cond)
[17:01:29.636]                           for (restart in restarts) {
[17:01:29.636]                             name <- restart$name
[17:01:29.636]                             if (is.null(name)) 
[17:01:29.636]                               next
[17:01:29.636]                             if (!grepl(pattern, name)) 
[17:01:29.636]                               next
[17:01:29.636]                             invokeRestart(restart)
[17:01:29.636]                             muffled <- TRUE
[17:01:29.636]                             break
[17:01:29.636]                           }
[17:01:29.636]                         }
[17:01:29.636]                       }
[17:01:29.636]                       invisible(muffled)
[17:01:29.636]                     }
[17:01:29.636]                     muffleCondition(cond, pattern = "^muffle")
[17:01:29.636]                   }
[17:01:29.636]                 }
[17:01:29.636]             }
[17:01:29.636]         }))
[17:01:29.636]     }, error = function(ex) {
[17:01:29.636]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:29.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:29.636]                 ...future.rng), started = ...future.startTime, 
[17:01:29.636]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:29.636]             version = "1.8"), class = "FutureResult")
[17:01:29.636]     }, finally = {
[17:01:29.636]         if (!identical(...future.workdir, getwd())) 
[17:01:29.636]             setwd(...future.workdir)
[17:01:29.636]         {
[17:01:29.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:29.636]                 ...future.oldOptions$nwarnings <- NULL
[17:01:29.636]             }
[17:01:29.636]             base::options(...future.oldOptions)
[17:01:29.636]             if (.Platform$OS.type == "windows") {
[17:01:29.636]                 old_names <- names(...future.oldEnvVars)
[17:01:29.636]                 envs <- base::Sys.getenv()
[17:01:29.636]                 names <- names(envs)
[17:01:29.636]                 common <- intersect(names, old_names)
[17:01:29.636]                 added <- setdiff(names, old_names)
[17:01:29.636]                 removed <- setdiff(old_names, names)
[17:01:29.636]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:29.636]                   envs[common]]
[17:01:29.636]                 NAMES <- toupper(changed)
[17:01:29.636]                 args <- list()
[17:01:29.636]                 for (kk in seq_along(NAMES)) {
[17:01:29.636]                   name <- changed[[kk]]
[17:01:29.636]                   NAME <- NAMES[[kk]]
[17:01:29.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:29.636]                     next
[17:01:29.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:29.636]                 }
[17:01:29.636]                 NAMES <- toupper(added)
[17:01:29.636]                 for (kk in seq_along(NAMES)) {
[17:01:29.636]                   name <- added[[kk]]
[17:01:29.636]                   NAME <- NAMES[[kk]]
[17:01:29.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:29.636]                     next
[17:01:29.636]                   args[[name]] <- ""
[17:01:29.636]                 }
[17:01:29.636]                 NAMES <- toupper(removed)
[17:01:29.636]                 for (kk in seq_along(NAMES)) {
[17:01:29.636]                   name <- removed[[kk]]
[17:01:29.636]                   NAME <- NAMES[[kk]]
[17:01:29.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:29.636]                     next
[17:01:29.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:29.636]                 }
[17:01:29.636]                 if (length(args) > 0) 
[17:01:29.636]                   base::do.call(base::Sys.setenv, args = args)
[17:01:29.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:29.636]             }
[17:01:29.636]             else {
[17:01:29.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:29.636]             }
[17:01:29.636]             {
[17:01:29.636]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:29.636]                   0L) {
[17:01:29.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:29.636]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:29.636]                   base::options(opts)
[17:01:29.636]                 }
[17:01:29.636]                 {
[17:01:29.636]                   {
[17:01:29.636]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:29.636]                     NULL
[17:01:29.636]                   }
[17:01:29.636]                   options(future.plan = NULL)
[17:01:29.636]                   if (is.na(NA_character_)) 
[17:01:29.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:29.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:29.636]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:29.636]                     .init = FALSE)
[17:01:29.636]                 }
[17:01:29.636]             }
[17:01:29.636]         }
[17:01:29.636]     })
[17:01:29.636]     if (TRUE) {
[17:01:29.636]         base::sink(type = "output", split = FALSE)
[17:01:29.636]         if (FALSE) {
[17:01:29.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:29.636]         }
[17:01:29.636]         else {
[17:01:29.636]             ...future.result["stdout"] <- base::list(NULL)
[17:01:29.636]         }
[17:01:29.636]         base::close(...future.stdout)
[17:01:29.636]         ...future.stdout <- NULL
[17:01:29.636]     }
[17:01:29.636]     ...future.result$conditions <- ...future.conditions
[17:01:29.636]     ...future.result$finished <- base::Sys.time()
[17:01:29.636]     ...future.result
[17:01:29.636] }
[17:01:29.640] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:01:29.640] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:01:29.640] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:01:29.641] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:29.641] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:29.641] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:01:29.642] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:01:29.642] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:29.642] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:29.642] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:29.643] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:29.643] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:01:29.644] MultisessionFuture started
[17:01:29.644] - Launch lazy future ... done
[17:01:29.644] run() for ‘MultisessionFuture’ ... done
[17:01:29.644] Created future:
[17:01:29.644] MultisessionFuture:
[17:01:29.644] Label: ‘future_lapply-1’
[17:01:29.644] Expression:
[17:01:29.644] {
[17:01:29.644]     do.call(function(...) {
[17:01:29.644]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:29.644]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:29.644]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:29.644]             on.exit(options(oopts), add = TRUE)
[17:01:29.644]         }
[17:01:29.644]         {
[17:01:29.644]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:29.644]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:29.644]                 ...future.FUN(...future.X_jj, ...)
[17:01:29.644]             })
[17:01:29.644]         }
[17:01:29.644]     }, args = future.call.arguments)
[17:01:29.644] }
[17:01:29.644] Lazy evaluation: FALSE
[17:01:29.644] Asynchronous evaluation: TRUE
[17:01:29.644] Local evaluation: TRUE
[17:01:29.644] Environment: R_GlobalEnv
[17:01:29.644] Capture standard output: FALSE
[17:01:29.644] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:29.644] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:29.644] Packages: <none>
[17:01:29.644] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:29.644] Resolved: FALSE
[17:01:29.644] Value: <not collected>
[17:01:29.644] Conditions captured: <none>
[17:01:29.644] Early signaling: FALSE
[17:01:29.644] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:29.644] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:29.656] Chunk #1 of 2 ... DONE
[17:01:29.657] Chunk #2 of 2 ...
[17:01:29.657]  - Finding globals in 'X' for chunk #2 ...
[17:01:29.657] getGlobalsAndPackages() ...
[17:01:29.657] Searching for globals...
[17:01:29.657] 
[17:01:29.657] Searching for globals ... DONE
[17:01:29.658] - globals: [0] <none>
[17:01:29.658] getGlobalsAndPackages() ... DONE
[17:01:29.658]    + additional globals found: [n=0] 
[17:01:29.658]    + additional namespaces needed: [n=0] 
[17:01:29.658]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:29.658]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:29.658]  - seeds: <none>
[17:01:29.658]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:29.659] getGlobalsAndPackages() ...
[17:01:29.659] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:29.659] Resolving globals: FALSE
[17:01:29.659] Tweak future expression to call with '...' arguments ...
[17:01:29.659] {
[17:01:29.659]     do.call(function(...) {
[17:01:29.659]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:29.659]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:29.659]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:29.659]             on.exit(options(oopts), add = TRUE)
[17:01:29.659]         }
[17:01:29.659]         {
[17:01:29.659]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:29.659]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:29.659]                 ...future.FUN(...future.X_jj, ...)
[17:01:29.659]             })
[17:01:29.659]         }
[17:01:29.659]     }, args = future.call.arguments)
[17:01:29.659] }
[17:01:29.659] Tweak future expression to call with '...' arguments ... DONE
[17:01:29.660] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:29.660] 
[17:01:29.660] getGlobalsAndPackages() ... DONE
[17:01:29.660] run() for ‘Future’ ...
[17:01:29.661] - state: ‘created’
[17:01:29.661] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:29.675] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:29.676] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:29.676]   - Field: ‘node’
[17:01:29.676]   - Field: ‘label’
[17:01:29.676]   - Field: ‘local’
[17:01:29.676]   - Field: ‘owner’
[17:01:29.676]   - Field: ‘envir’
[17:01:29.676]   - Field: ‘workers’
[17:01:29.676]   - Field: ‘packages’
[17:01:29.676]   - Field: ‘gc’
[17:01:29.677]   - Field: ‘conditions’
[17:01:29.677]   - Field: ‘persistent’
[17:01:29.677]   - Field: ‘expr’
[17:01:29.677]   - Field: ‘uuid’
[17:01:29.677]   - Field: ‘seed’
[17:01:29.677]   - Field: ‘version’
[17:01:29.677]   - Field: ‘result’
[17:01:29.677]   - Field: ‘asynchronous’
[17:01:29.677]   - Field: ‘calls’
[17:01:29.678]   - Field: ‘globals’
[17:01:29.678]   - Field: ‘stdout’
[17:01:29.678]   - Field: ‘earlySignal’
[17:01:29.678]   - Field: ‘lazy’
[17:01:29.678]   - Field: ‘state’
[17:01:29.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:29.678] - Launch lazy future ...
[17:01:29.679] Packages needed by the future expression (n = 0): <none>
[17:01:29.679] Packages needed by future strategies (n = 0): <none>
[17:01:29.679] {
[17:01:29.679]     {
[17:01:29.679]         {
[17:01:29.679]             ...future.startTime <- base::Sys.time()
[17:01:29.679]             {
[17:01:29.679]                 {
[17:01:29.679]                   {
[17:01:29.679]                     {
[17:01:29.679]                       base::local({
[17:01:29.679]                         has_future <- base::requireNamespace("future", 
[17:01:29.679]                           quietly = TRUE)
[17:01:29.679]                         if (has_future) {
[17:01:29.679]                           ns <- base::getNamespace("future")
[17:01:29.679]                           version <- ns[[".package"]][["version"]]
[17:01:29.679]                           if (is.null(version)) 
[17:01:29.679]                             version <- utils::packageVersion("future")
[17:01:29.679]                         }
[17:01:29.679]                         else {
[17:01:29.679]                           version <- NULL
[17:01:29.679]                         }
[17:01:29.679]                         if (!has_future || version < "1.8.0") {
[17:01:29.679]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:29.679]                             "", base::R.version$version.string), 
[17:01:29.679]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:29.679]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:29.679]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:29.679]                               "release", "version")], collapse = " "), 
[17:01:29.679]                             hostname = base::Sys.info()[["nodename"]])
[17:01:29.679]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:29.679]                             info)
[17:01:29.679]                           info <- base::paste(info, collapse = "; ")
[17:01:29.679]                           if (!has_future) {
[17:01:29.679]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:29.679]                               info)
[17:01:29.679]                           }
[17:01:29.679]                           else {
[17:01:29.679]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:29.679]                               info, version)
[17:01:29.679]                           }
[17:01:29.679]                           base::stop(msg)
[17:01:29.679]                         }
[17:01:29.679]                       })
[17:01:29.679]                     }
[17:01:29.679]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:29.679]                     base::options(mc.cores = 1L)
[17:01:29.679]                   }
[17:01:29.679]                   ...future.strategy.old <- future::plan("list")
[17:01:29.679]                   options(future.plan = NULL)
[17:01:29.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:29.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:29.679]                 }
[17:01:29.679]                 ...future.workdir <- getwd()
[17:01:29.679]             }
[17:01:29.679]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:29.679]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:29.679]         }
[17:01:29.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:29.679]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:29.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:29.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:29.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:29.679]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:29.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:29.679]             base::names(...future.oldOptions))
[17:01:29.679]     }
[17:01:29.679]     if (FALSE) {
[17:01:29.679]     }
[17:01:29.679]     else {
[17:01:29.679]         if (FALSE) {
[17:01:29.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:29.679]                 open = "w")
[17:01:29.679]         }
[17:01:29.679]         else {
[17:01:29.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:29.679]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:29.679]         }
[17:01:29.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:29.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:29.679]             base::sink(type = "output", split = FALSE)
[17:01:29.679]             base::close(...future.stdout)
[17:01:29.679]         }, add = TRUE)
[17:01:29.679]     }
[17:01:29.679]     ...future.frame <- base::sys.nframe()
[17:01:29.679]     ...future.conditions <- base::list()
[17:01:29.679]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:29.679]     if (FALSE) {
[17:01:29.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:29.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:29.679]     }
[17:01:29.679]     ...future.result <- base::tryCatch({
[17:01:29.679]         base::withCallingHandlers({
[17:01:29.679]             ...future.value <- base::withVisible(base::local({
[17:01:29.679]                 ...future.makeSendCondition <- base::local({
[17:01:29.679]                   sendCondition <- NULL
[17:01:29.679]                   function(frame = 1L) {
[17:01:29.679]                     if (is.function(sendCondition)) 
[17:01:29.679]                       return(sendCondition)
[17:01:29.679]                     ns <- getNamespace("parallel")
[17:01:29.679]                     if (exists("sendData", mode = "function", 
[17:01:29.679]                       envir = ns)) {
[17:01:29.679]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:29.679]                         envir = ns)
[17:01:29.679]                       envir <- sys.frame(frame)
[17:01:29.679]                       master <- NULL
[17:01:29.679]                       while (!identical(envir, .GlobalEnv) && 
[17:01:29.679]                         !identical(envir, emptyenv())) {
[17:01:29.679]                         if (exists("master", mode = "list", envir = envir, 
[17:01:29.679]                           inherits = FALSE)) {
[17:01:29.679]                           master <- get("master", mode = "list", 
[17:01:29.679]                             envir = envir, inherits = FALSE)
[17:01:29.679]                           if (inherits(master, c("SOCKnode", 
[17:01:29.679]                             "SOCK0node"))) {
[17:01:29.679]                             sendCondition <<- function(cond) {
[17:01:29.679]                               data <- list(type = "VALUE", value = cond, 
[17:01:29.679]                                 success = TRUE)
[17:01:29.679]                               parallel_sendData(master, data)
[17:01:29.679]                             }
[17:01:29.679]                             return(sendCondition)
[17:01:29.679]                           }
[17:01:29.679]                         }
[17:01:29.679]                         frame <- frame + 1L
[17:01:29.679]                         envir <- sys.frame(frame)
[17:01:29.679]                       }
[17:01:29.679]                     }
[17:01:29.679]                     sendCondition <<- function(cond) NULL
[17:01:29.679]                   }
[17:01:29.679]                 })
[17:01:29.679]                 withCallingHandlers({
[17:01:29.679]                   {
[17:01:29.679]                     do.call(function(...) {
[17:01:29.679]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:29.679]                       if (!identical(...future.globals.maxSize.org, 
[17:01:29.679]                         ...future.globals.maxSize)) {
[17:01:29.679]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:29.679]                         on.exit(options(oopts), add = TRUE)
[17:01:29.679]                       }
[17:01:29.679]                       {
[17:01:29.679]                         lapply(seq_along(...future.elements_ii), 
[17:01:29.679]                           FUN = function(jj) {
[17:01:29.679]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:29.679]                             ...future.FUN(...future.X_jj, ...)
[17:01:29.679]                           })
[17:01:29.679]                       }
[17:01:29.679]                     }, args = future.call.arguments)
[17:01:29.679]                   }
[17:01:29.679]                 }, immediateCondition = function(cond) {
[17:01:29.679]                   sendCondition <- ...future.makeSendCondition()
[17:01:29.679]                   sendCondition(cond)
[17:01:29.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:29.679]                   {
[17:01:29.679]                     inherits <- base::inherits
[17:01:29.679]                     invokeRestart <- base::invokeRestart
[17:01:29.679]                     is.null <- base::is.null
[17:01:29.679]                     muffled <- FALSE
[17:01:29.679]                     if (inherits(cond, "message")) {
[17:01:29.679]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:29.679]                       if (muffled) 
[17:01:29.679]                         invokeRestart("muffleMessage")
[17:01:29.679]                     }
[17:01:29.679]                     else if (inherits(cond, "warning")) {
[17:01:29.679]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:29.679]                       if (muffled) 
[17:01:29.679]                         invokeRestart("muffleWarning")
[17:01:29.679]                     }
[17:01:29.679]                     else if (inherits(cond, "condition")) {
[17:01:29.679]                       if (!is.null(pattern)) {
[17:01:29.679]                         computeRestarts <- base::computeRestarts
[17:01:29.679]                         grepl <- base::grepl
[17:01:29.679]                         restarts <- computeRestarts(cond)
[17:01:29.679]                         for (restart in restarts) {
[17:01:29.679]                           name <- restart$name
[17:01:29.679]                           if (is.null(name)) 
[17:01:29.679]                             next
[17:01:29.679]                           if (!grepl(pattern, name)) 
[17:01:29.679]                             next
[17:01:29.679]                           invokeRestart(restart)
[17:01:29.679]                           muffled <- TRUE
[17:01:29.679]                           break
[17:01:29.679]                         }
[17:01:29.679]                       }
[17:01:29.679]                     }
[17:01:29.679]                     invisible(muffled)
[17:01:29.679]                   }
[17:01:29.679]                   muffleCondition(cond)
[17:01:29.679]                 })
[17:01:29.679]             }))
[17:01:29.679]             future::FutureResult(value = ...future.value$value, 
[17:01:29.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:29.679]                   ...future.rng), globalenv = if (FALSE) 
[17:01:29.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:29.679]                     ...future.globalenv.names))
[17:01:29.679]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:29.679]         }, condition = base::local({
[17:01:29.679]             c <- base::c
[17:01:29.679]             inherits <- base::inherits
[17:01:29.679]             invokeRestart <- base::invokeRestart
[17:01:29.679]             length <- base::length
[17:01:29.679]             list <- base::list
[17:01:29.679]             seq.int <- base::seq.int
[17:01:29.679]             signalCondition <- base::signalCondition
[17:01:29.679]             sys.calls <- base::sys.calls
[17:01:29.679]             `[[` <- base::`[[`
[17:01:29.679]             `+` <- base::`+`
[17:01:29.679]             `<<-` <- base::`<<-`
[17:01:29.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:29.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:29.679]                   3L)]
[17:01:29.679]             }
[17:01:29.679]             function(cond) {
[17:01:29.679]                 is_error <- inherits(cond, "error")
[17:01:29.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:29.679]                   NULL)
[17:01:29.679]                 if (is_error) {
[17:01:29.679]                   sessionInformation <- function() {
[17:01:29.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:29.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:29.679]                       search = base::search(), system = base::Sys.info())
[17:01:29.679]                   }
[17:01:29.679]                   ...future.conditions[[length(...future.conditions) + 
[17:01:29.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:29.679]                     cond$call), session = sessionInformation(), 
[17:01:29.679]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:29.679]                   signalCondition(cond)
[17:01:29.679]                 }
[17:01:29.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:29.679]                 "immediateCondition"))) {
[17:01:29.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:29.679]                   ...future.conditions[[length(...future.conditions) + 
[17:01:29.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:29.679]                   if (TRUE && !signal) {
[17:01:29.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:29.679]                     {
[17:01:29.679]                       inherits <- base::inherits
[17:01:29.679]                       invokeRestart <- base::invokeRestart
[17:01:29.679]                       is.null <- base::is.null
[17:01:29.679]                       muffled <- FALSE
[17:01:29.679]                       if (inherits(cond, "message")) {
[17:01:29.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:29.679]                         if (muffled) 
[17:01:29.679]                           invokeRestart("muffleMessage")
[17:01:29.679]                       }
[17:01:29.679]                       else if (inherits(cond, "warning")) {
[17:01:29.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:29.679]                         if (muffled) 
[17:01:29.679]                           invokeRestart("muffleWarning")
[17:01:29.679]                       }
[17:01:29.679]                       else if (inherits(cond, "condition")) {
[17:01:29.679]                         if (!is.null(pattern)) {
[17:01:29.679]                           computeRestarts <- base::computeRestarts
[17:01:29.679]                           grepl <- base::grepl
[17:01:29.679]                           restarts <- computeRestarts(cond)
[17:01:29.679]                           for (restart in restarts) {
[17:01:29.679]                             name <- restart$name
[17:01:29.679]                             if (is.null(name)) 
[17:01:29.679]                               next
[17:01:29.679]                             if (!grepl(pattern, name)) 
[17:01:29.679]                               next
[17:01:29.679]                             invokeRestart(restart)
[17:01:29.679]                             muffled <- TRUE
[17:01:29.679]                             break
[17:01:29.679]                           }
[17:01:29.679]                         }
[17:01:29.679]                       }
[17:01:29.679]                       invisible(muffled)
[17:01:29.679]                     }
[17:01:29.679]                     muffleCondition(cond, pattern = "^muffle")
[17:01:29.679]                   }
[17:01:29.679]                 }
[17:01:29.679]                 else {
[17:01:29.679]                   if (TRUE) {
[17:01:29.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:29.679]                     {
[17:01:29.679]                       inherits <- base::inherits
[17:01:29.679]                       invokeRestart <- base::invokeRestart
[17:01:29.679]                       is.null <- base::is.null
[17:01:29.679]                       muffled <- FALSE
[17:01:29.679]                       if (inherits(cond, "message")) {
[17:01:29.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:29.679]                         if (muffled) 
[17:01:29.679]                           invokeRestart("muffleMessage")
[17:01:29.679]                       }
[17:01:29.679]                       else if (inherits(cond, "warning")) {
[17:01:29.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:29.679]                         if (muffled) 
[17:01:29.679]                           invokeRestart("muffleWarning")
[17:01:29.679]                       }
[17:01:29.679]                       else if (inherits(cond, "condition")) {
[17:01:29.679]                         if (!is.null(pattern)) {
[17:01:29.679]                           computeRestarts <- base::computeRestarts
[17:01:29.679]                           grepl <- base::grepl
[17:01:29.679]                           restarts <- computeRestarts(cond)
[17:01:29.679]                           for (restart in restarts) {
[17:01:29.679]                             name <- restart$name
[17:01:29.679]                             if (is.null(name)) 
[17:01:29.679]                               next
[17:01:29.679]                             if (!grepl(pattern, name)) 
[17:01:29.679]                               next
[17:01:29.679]                             invokeRestart(restart)
[17:01:29.679]                             muffled <- TRUE
[17:01:29.679]                             break
[17:01:29.679]                           }
[17:01:29.679]                         }
[17:01:29.679]                       }
[17:01:29.679]                       invisible(muffled)
[17:01:29.679]                     }
[17:01:29.679]                     muffleCondition(cond, pattern = "^muffle")
[17:01:29.679]                   }
[17:01:29.679]                 }
[17:01:29.679]             }
[17:01:29.679]         }))
[17:01:29.679]     }, error = function(ex) {
[17:01:29.679]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:29.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:29.679]                 ...future.rng), started = ...future.startTime, 
[17:01:29.679]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:29.679]             version = "1.8"), class = "FutureResult")
[17:01:29.679]     }, finally = {
[17:01:29.679]         if (!identical(...future.workdir, getwd())) 
[17:01:29.679]             setwd(...future.workdir)
[17:01:29.679]         {
[17:01:29.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:29.679]                 ...future.oldOptions$nwarnings <- NULL
[17:01:29.679]             }
[17:01:29.679]             base::options(...future.oldOptions)
[17:01:29.679]             if (.Platform$OS.type == "windows") {
[17:01:29.679]                 old_names <- names(...future.oldEnvVars)
[17:01:29.679]                 envs <- base::Sys.getenv()
[17:01:29.679]                 names <- names(envs)
[17:01:29.679]                 common <- intersect(names, old_names)
[17:01:29.679]                 added <- setdiff(names, old_names)
[17:01:29.679]                 removed <- setdiff(old_names, names)
[17:01:29.679]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:29.679]                   envs[common]]
[17:01:29.679]                 NAMES <- toupper(changed)
[17:01:29.679]                 args <- list()
[17:01:29.679]                 for (kk in seq_along(NAMES)) {
[17:01:29.679]                   name <- changed[[kk]]
[17:01:29.679]                   NAME <- NAMES[[kk]]
[17:01:29.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:29.679]                     next
[17:01:29.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:29.679]                 }
[17:01:29.679]                 NAMES <- toupper(added)
[17:01:29.679]                 for (kk in seq_along(NAMES)) {
[17:01:29.679]                   name <- added[[kk]]
[17:01:29.679]                   NAME <- NAMES[[kk]]
[17:01:29.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:29.679]                     next
[17:01:29.679]                   args[[name]] <- ""
[17:01:29.679]                 }
[17:01:29.679]                 NAMES <- toupper(removed)
[17:01:29.679]                 for (kk in seq_along(NAMES)) {
[17:01:29.679]                   name <- removed[[kk]]
[17:01:29.679]                   NAME <- NAMES[[kk]]
[17:01:29.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:29.679]                     next
[17:01:29.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:29.679]                 }
[17:01:29.679]                 if (length(args) > 0) 
[17:01:29.679]                   base::do.call(base::Sys.setenv, args = args)
[17:01:29.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:29.679]             }
[17:01:29.679]             else {
[17:01:29.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:29.679]             }
[17:01:29.679]             {
[17:01:29.679]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:29.679]                   0L) {
[17:01:29.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:29.679]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:29.679]                   base::options(opts)
[17:01:29.679]                 }
[17:01:29.679]                 {
[17:01:29.679]                   {
[17:01:29.679]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:29.679]                     NULL
[17:01:29.679]                   }
[17:01:29.679]                   options(future.plan = NULL)
[17:01:29.679]                   if (is.na(NA_character_)) 
[17:01:29.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:29.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:29.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:29.679]                     .init = FALSE)
[17:01:29.679]                 }
[17:01:29.679]             }
[17:01:29.679]         }
[17:01:29.679]     })
[17:01:29.679]     if (TRUE) {
[17:01:29.679]         base::sink(type = "output", split = FALSE)
[17:01:29.679]         if (FALSE) {
[17:01:29.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:29.679]         }
[17:01:29.679]         else {
[17:01:29.679]             ...future.result["stdout"] <- base::list(NULL)
[17:01:29.679]         }
[17:01:29.679]         base::close(...future.stdout)
[17:01:29.679]         ...future.stdout <- NULL
[17:01:29.679]     }
[17:01:29.679]     ...future.result$conditions <- ...future.conditions
[17:01:29.679]     ...future.result$finished <- base::Sys.time()
[17:01:29.679]     ...future.result
[17:01:29.679] }
[17:01:29.732] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:01:29.733] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:01:29.733] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:01:29.733] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:29.734] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:29.734] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:01:29.734] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:01:29.735] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:29.735] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:29.735] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:29.736] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:29.736] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:01:29.736] MultisessionFuture started
[17:01:29.737] - Launch lazy future ... done
[17:01:29.737] run() for ‘MultisessionFuture’ ... done
[17:01:29.737] Created future:
[17:01:29.737] MultisessionFuture:
[17:01:29.737] Label: ‘future_lapply-2’
[17:01:29.737] Expression:
[17:01:29.737] {
[17:01:29.737]     do.call(function(...) {
[17:01:29.737]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:29.737]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:29.737]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:29.737]             on.exit(options(oopts), add = TRUE)
[17:01:29.737]         }
[17:01:29.737]         {
[17:01:29.737]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:29.737]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:29.737]                 ...future.FUN(...future.X_jj, ...)
[17:01:29.737]             })
[17:01:29.737]         }
[17:01:29.737]     }, args = future.call.arguments)
[17:01:29.737] }
[17:01:29.737] Lazy evaluation: FALSE
[17:01:29.737] Asynchronous evaluation: TRUE
[17:01:29.737] Local evaluation: TRUE
[17:01:29.737] Environment: R_GlobalEnv
[17:01:29.737] Capture standard output: FALSE
[17:01:29.737] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:29.737] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:29.737] Packages: <none>
[17:01:29.737] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:29.737] Resolved: FALSE
[17:01:29.737] Value: <not collected>
[17:01:29.737] Conditions captured: <none>
[17:01:29.737] Early signaling: FALSE
[17:01:29.737] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:29.737] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:29.749] Chunk #2 of 2 ... DONE
[17:01:29.749] Launching 2 futures (chunks) ... DONE
[17:01:29.749] Resolving 2 futures (chunks) ...
[17:01:29.749] resolve() on list ...
[17:01:29.749]  recursive: 0
[17:01:29.750]  length: 2
[17:01:29.750] 
[17:01:29.828] receiveMessageFromWorker() for ClusterFuture ...
[17:01:29.828] - Validating connection of MultisessionFuture
[17:01:29.828] - received message: FutureResult
[17:01:29.828] - Received FutureResult
[17:01:29.828] - Erased future from FutureRegistry
[17:01:29.828] result() for ClusterFuture ...
[17:01:29.828] - result already collected: FutureResult
[17:01:29.828] result() for ClusterFuture ... done
[17:01:29.829] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:29.829] Future #2
[17:01:29.829] result() for ClusterFuture ...
[17:01:29.829] - result already collected: FutureResult
[17:01:29.829] result() for ClusterFuture ... done
[17:01:29.829] result() for ClusterFuture ...
[17:01:29.829] - result already collected: FutureResult
[17:01:29.829] result() for ClusterFuture ... done
[17:01:29.829] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:29.829] - nx: 2
[17:01:29.829] - relay: TRUE
[17:01:29.830] - stdout: TRUE
[17:01:29.830] - signal: TRUE
[17:01:29.830] - resignal: FALSE
[17:01:29.830] - force: TRUE
[17:01:29.830] - relayed: [n=2] FALSE, FALSE
[17:01:29.830] - queued futures: [n=2] FALSE, FALSE
[17:01:29.830]  - until=1
[17:01:29.830]  - relaying element #1
[17:01:29.830] - relayed: [n=2] FALSE, FALSE
[17:01:29.830] - queued futures: [n=2] FALSE, TRUE
[17:01:29.830] signalConditionsASAP(NULL, pos=2) ... done
[17:01:29.830]  length: 1 (resolved future 2)
[17:01:30.194] receiveMessageFromWorker() for ClusterFuture ...
[17:01:30.194] - Validating connection of MultisessionFuture
[17:01:30.195] - received message: FutureResult
[17:01:30.195] - Received FutureResult
[17:01:30.195] - Erased future from FutureRegistry
[17:01:30.195] result() for ClusterFuture ...
[17:01:30.195] - result already collected: FutureResult
[17:01:30.195] result() for ClusterFuture ... done
[17:01:30.195] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:30.195] Future #1
[17:01:30.195] result() for ClusterFuture ...
[17:01:30.195] - result already collected: FutureResult
[17:01:30.196] result() for ClusterFuture ... done
[17:01:30.196] result() for ClusterFuture ...
[17:01:30.196] - result already collected: FutureResult
[17:01:30.196] result() for ClusterFuture ... done
[17:01:30.196] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:30.196] - nx: 2
[17:01:30.196] - relay: TRUE
[17:01:30.196] - stdout: TRUE
[17:01:30.196] - signal: TRUE
[17:01:30.196] - resignal: FALSE
[17:01:30.196] - force: TRUE
[17:01:30.196] - relayed: [n=2] FALSE, FALSE
[17:01:30.197] - queued futures: [n=2] FALSE, TRUE
[17:01:30.197]  - until=1
[17:01:30.197]  - relaying element #1
[17:01:30.197] result() for ClusterFuture ...
[17:01:30.197] - result already collected: FutureResult
[17:01:30.197] result() for ClusterFuture ... done
[17:01:30.197] result() for ClusterFuture ...
[17:01:30.197] - result already collected: FutureResult
[17:01:30.197] result() for ClusterFuture ... done
[17:01:30.197] result() for ClusterFuture ...
[17:01:30.197] - result already collected: FutureResult
[17:01:30.198] result() for ClusterFuture ... done
[17:01:30.198] result() for ClusterFuture ...
[17:01:30.198] - result already collected: FutureResult
[17:01:30.198] result() for ClusterFuture ... done
[17:01:30.198] - relayed: [n=2] TRUE, FALSE
[17:01:30.198] - queued futures: [n=2] TRUE, TRUE
[17:01:30.198] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:30.198]  length: 0 (resolved future 1)
[17:01:30.198] Relaying remaining futures
[17:01:30.198] signalConditionsASAP(NULL, pos=0) ...
[17:01:30.198] - nx: 2
[17:01:30.198] - relay: TRUE
[17:01:30.199] - stdout: TRUE
[17:01:30.199] - signal: TRUE
[17:01:30.199] - resignal: FALSE
[17:01:30.199] - force: TRUE
[17:01:30.199] - relayed: [n=2] TRUE, FALSE
[17:01:30.199] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:30.199]  - relaying element #2
[17:01:30.199] result() for ClusterFuture ...
[17:01:30.199] - result already collected: FutureResult
[17:01:30.199] result() for ClusterFuture ... done
[17:01:30.199] result() for ClusterFuture ...
[17:01:30.200] - result already collected: FutureResult
[17:01:30.200] result() for ClusterFuture ... done
[17:01:30.200] result() for ClusterFuture ...
[17:01:30.200] - result already collected: FutureResult
[17:01:30.200] result() for ClusterFuture ... done
[17:01:30.200] result() for ClusterFuture ...
[17:01:30.200] - result already collected: FutureResult
[17:01:30.200] result() for ClusterFuture ... done
[17:01:30.200] - relayed: [n=2] TRUE, TRUE
[17:01:30.200] - queued futures: [n=2] TRUE, TRUE
[17:01:30.200] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:01:30.200] resolve() on list ... DONE
[17:01:30.201] result() for ClusterFuture ...
[17:01:30.201] - result already collected: FutureResult
[17:01:30.201] result() for ClusterFuture ... done
[17:01:30.201] result() for ClusterFuture ...
[17:01:30.201] - result already collected: FutureResult
[17:01:30.201] result() for ClusterFuture ... done
[17:01:30.201] result() for ClusterFuture ...
[17:01:30.201] - result already collected: FutureResult
[17:01:30.201] result() for ClusterFuture ... done
[17:01:30.201] result() for ClusterFuture ...
[17:01:30.201] - result already collected: FutureResult
[17:01:30.201] result() for ClusterFuture ... done
[17:01:30.202]  - Number of value chunks collected: 2
[17:01:30.202] Resolving 2 futures (chunks) ... DONE
[17:01:30.202] Reducing values from 2 chunks ...
[17:01:30.202]  - Number of values collected after concatenation: 2
[17:01:30.202]  - Number of values expected: 2
[17:01:30.202] Reducing values from 2 chunks ... DONE
[17:01:30.202] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:01:30.202] future_lapply() ...
[17:01:30.207] Number of chunks: 2
[17:01:30.207] getGlobalsAndPackagesXApply() ...
[17:01:30.207]  - future.globals: TRUE
[17:01:30.207] getGlobalsAndPackages() ...
[17:01:30.207] Searching for globals...
[17:01:30.209] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:30.209] Searching for globals ... DONE
[17:01:30.209] Resolving globals: FALSE
[17:01:30.209] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:30.210] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:30.210] - globals: [1] ‘FUN’
[17:01:30.210] 
[17:01:30.210] getGlobalsAndPackages() ... DONE
[17:01:30.210]  - globals found/used: [n=1] ‘FUN’
[17:01:30.210]  - needed namespaces: [n=0] 
[17:01:30.210] Finding globals ... DONE
[17:01:30.210]  - use_args: TRUE
[17:01:30.210]  - Getting '...' globals ...
[17:01:30.211] resolve() on list ...
[17:01:30.211]  recursive: 0
[17:01:30.211]  length: 1
[17:01:30.211]  elements: ‘...’
[17:01:30.211]  length: 0 (resolved future 1)
[17:01:30.211] resolve() on list ... DONE
[17:01:30.211]    - '...' content: [n=0] 
[17:01:30.212] List of 1
[17:01:30.212]  $ ...: list()
[17:01:30.212]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:30.212]  - attr(*, "where")=List of 1
[17:01:30.212]   ..$ ...:<environment: 0x5636f5293d58> 
[17:01:30.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:30.212]  - attr(*, "resolved")= logi TRUE
[17:01:30.212]  - attr(*, "total_size")= num NA
[17:01:30.214]  - Getting '...' globals ... DONE
[17:01:30.214] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:30.214] List of 2
[17:01:30.214]  $ ...future.FUN:function (x)  
[17:01:30.214]  $ ...          : list()
[17:01:30.214]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:30.214]  - attr(*, "where")=List of 2
[17:01:30.214]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:30.214]   ..$ ...          :<environment: 0x5636f5293d58> 
[17:01:30.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:30.214]  - attr(*, "resolved")= logi FALSE
[17:01:30.214]  - attr(*, "total_size")= num 4720
[17:01:30.217] Packages to be attached in all futures: [n=0] 
[17:01:30.217] getGlobalsAndPackagesXApply() ... DONE
[17:01:30.217] Number of futures (= number of chunks): 2
[17:01:30.217] Launching 2 futures (chunks) ...
[17:01:30.217] Chunk #1 of 2 ...
[17:01:30.218]  - Finding globals in 'X' for chunk #1 ...
[17:01:30.218] getGlobalsAndPackages() ...
[17:01:30.218] Searching for globals...
[17:01:30.218] 
[17:01:30.218] Searching for globals ... DONE
[17:01:30.218] - globals: [0] <none>
[17:01:30.218] getGlobalsAndPackages() ... DONE
[17:01:30.218]    + additional globals found: [n=0] 
[17:01:30.218]    + additional namespaces needed: [n=0] 
[17:01:30.218]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:30.219]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:30.219]  - seeds: <none>
[17:01:30.219]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.219] getGlobalsAndPackages() ...
[17:01:30.219] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.219] Resolving globals: FALSE
[17:01:30.219] Tweak future expression to call with '...' arguments ...
[17:01:30.219] {
[17:01:30.219]     do.call(function(...) {
[17:01:30.219]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.219]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:30.219]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.219]             on.exit(options(oopts), add = TRUE)
[17:01:30.219]         }
[17:01:30.219]         {
[17:01:30.219]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:30.219]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.219]                 ...future.FUN(...future.X_jj, ...)
[17:01:30.219]             })
[17:01:30.219]         }
[17:01:30.219]     }, args = future.call.arguments)
[17:01:30.219] }
[17:01:30.220] Tweak future expression to call with '...' arguments ... DONE
[17:01:30.220] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.220] 
[17:01:30.220] getGlobalsAndPackages() ... DONE
[17:01:30.220] run() for ‘Future’ ...
[17:01:30.221] - state: ‘created’
[17:01:30.221] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:30.235] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:30.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:30.235]   - Field: ‘node’
[17:01:30.235]   - Field: ‘label’
[17:01:30.235]   - Field: ‘local’
[17:01:30.236]   - Field: ‘owner’
[17:01:30.236]   - Field: ‘envir’
[17:01:30.236]   - Field: ‘workers’
[17:01:30.236]   - Field: ‘packages’
[17:01:30.236]   - Field: ‘gc’
[17:01:30.236]   - Field: ‘conditions’
[17:01:30.236]   - Field: ‘persistent’
[17:01:30.236]   - Field: ‘expr’
[17:01:30.236]   - Field: ‘uuid’
[17:01:30.236]   - Field: ‘seed’
[17:01:30.236]   - Field: ‘version’
[17:01:30.237]   - Field: ‘result’
[17:01:30.237]   - Field: ‘asynchronous’
[17:01:30.237]   - Field: ‘calls’
[17:01:30.237]   - Field: ‘globals’
[17:01:30.237]   - Field: ‘stdout’
[17:01:30.237]   - Field: ‘earlySignal’
[17:01:30.237]   - Field: ‘lazy’
[17:01:30.237]   - Field: ‘state’
[17:01:30.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:30.237] - Launch lazy future ...
[17:01:30.238] Packages needed by the future expression (n = 0): <none>
[17:01:30.238] Packages needed by future strategies (n = 0): <none>
[17:01:30.238] {
[17:01:30.238]     {
[17:01:30.238]         {
[17:01:30.238]             ...future.startTime <- base::Sys.time()
[17:01:30.238]             {
[17:01:30.238]                 {
[17:01:30.238]                   {
[17:01:30.238]                     {
[17:01:30.238]                       base::local({
[17:01:30.238]                         has_future <- base::requireNamespace("future", 
[17:01:30.238]                           quietly = TRUE)
[17:01:30.238]                         if (has_future) {
[17:01:30.238]                           ns <- base::getNamespace("future")
[17:01:30.238]                           version <- ns[[".package"]][["version"]]
[17:01:30.238]                           if (is.null(version)) 
[17:01:30.238]                             version <- utils::packageVersion("future")
[17:01:30.238]                         }
[17:01:30.238]                         else {
[17:01:30.238]                           version <- NULL
[17:01:30.238]                         }
[17:01:30.238]                         if (!has_future || version < "1.8.0") {
[17:01:30.238]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:30.238]                             "", base::R.version$version.string), 
[17:01:30.238]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:30.238]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:30.238]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:30.238]                               "release", "version")], collapse = " "), 
[17:01:30.238]                             hostname = base::Sys.info()[["nodename"]])
[17:01:30.238]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:30.238]                             info)
[17:01:30.238]                           info <- base::paste(info, collapse = "; ")
[17:01:30.238]                           if (!has_future) {
[17:01:30.238]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:30.238]                               info)
[17:01:30.238]                           }
[17:01:30.238]                           else {
[17:01:30.238]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:30.238]                               info, version)
[17:01:30.238]                           }
[17:01:30.238]                           base::stop(msg)
[17:01:30.238]                         }
[17:01:30.238]                       })
[17:01:30.238]                     }
[17:01:30.238]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:30.238]                     base::options(mc.cores = 1L)
[17:01:30.238]                   }
[17:01:30.238]                   ...future.strategy.old <- future::plan("list")
[17:01:30.238]                   options(future.plan = NULL)
[17:01:30.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:30.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:30.238]                 }
[17:01:30.238]                 ...future.workdir <- getwd()
[17:01:30.238]             }
[17:01:30.238]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:30.238]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:30.238]         }
[17:01:30.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:30.238]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:30.238]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:30.238]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:30.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:30.238]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:30.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:30.238]             base::names(...future.oldOptions))
[17:01:30.238]     }
[17:01:30.238]     if (FALSE) {
[17:01:30.238]     }
[17:01:30.238]     else {
[17:01:30.238]         if (TRUE) {
[17:01:30.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:30.238]                 open = "w")
[17:01:30.238]         }
[17:01:30.238]         else {
[17:01:30.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:30.238]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:30.238]         }
[17:01:30.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:30.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:30.238]             base::sink(type = "output", split = FALSE)
[17:01:30.238]             base::close(...future.stdout)
[17:01:30.238]         }, add = TRUE)
[17:01:30.238]     }
[17:01:30.238]     ...future.frame <- base::sys.nframe()
[17:01:30.238]     ...future.conditions <- base::list()
[17:01:30.238]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:30.238]     if (FALSE) {
[17:01:30.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:30.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:30.238]     }
[17:01:30.238]     ...future.result <- base::tryCatch({
[17:01:30.238]         base::withCallingHandlers({
[17:01:30.238]             ...future.value <- base::withVisible(base::local({
[17:01:30.238]                 ...future.makeSendCondition <- base::local({
[17:01:30.238]                   sendCondition <- NULL
[17:01:30.238]                   function(frame = 1L) {
[17:01:30.238]                     if (is.function(sendCondition)) 
[17:01:30.238]                       return(sendCondition)
[17:01:30.238]                     ns <- getNamespace("parallel")
[17:01:30.238]                     if (exists("sendData", mode = "function", 
[17:01:30.238]                       envir = ns)) {
[17:01:30.238]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:30.238]                         envir = ns)
[17:01:30.238]                       envir <- sys.frame(frame)
[17:01:30.238]                       master <- NULL
[17:01:30.238]                       while (!identical(envir, .GlobalEnv) && 
[17:01:30.238]                         !identical(envir, emptyenv())) {
[17:01:30.238]                         if (exists("master", mode = "list", envir = envir, 
[17:01:30.238]                           inherits = FALSE)) {
[17:01:30.238]                           master <- get("master", mode = "list", 
[17:01:30.238]                             envir = envir, inherits = FALSE)
[17:01:30.238]                           if (inherits(master, c("SOCKnode", 
[17:01:30.238]                             "SOCK0node"))) {
[17:01:30.238]                             sendCondition <<- function(cond) {
[17:01:30.238]                               data <- list(type = "VALUE", value = cond, 
[17:01:30.238]                                 success = TRUE)
[17:01:30.238]                               parallel_sendData(master, data)
[17:01:30.238]                             }
[17:01:30.238]                             return(sendCondition)
[17:01:30.238]                           }
[17:01:30.238]                         }
[17:01:30.238]                         frame <- frame + 1L
[17:01:30.238]                         envir <- sys.frame(frame)
[17:01:30.238]                       }
[17:01:30.238]                     }
[17:01:30.238]                     sendCondition <<- function(cond) NULL
[17:01:30.238]                   }
[17:01:30.238]                 })
[17:01:30.238]                 withCallingHandlers({
[17:01:30.238]                   {
[17:01:30.238]                     do.call(function(...) {
[17:01:30.238]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.238]                       if (!identical(...future.globals.maxSize.org, 
[17:01:30.238]                         ...future.globals.maxSize)) {
[17:01:30.238]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.238]                         on.exit(options(oopts), add = TRUE)
[17:01:30.238]                       }
[17:01:30.238]                       {
[17:01:30.238]                         lapply(seq_along(...future.elements_ii), 
[17:01:30.238]                           FUN = function(jj) {
[17:01:30.238]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.238]                             ...future.FUN(...future.X_jj, ...)
[17:01:30.238]                           })
[17:01:30.238]                       }
[17:01:30.238]                     }, args = future.call.arguments)
[17:01:30.238]                   }
[17:01:30.238]                 }, immediateCondition = function(cond) {
[17:01:30.238]                   sendCondition <- ...future.makeSendCondition()
[17:01:30.238]                   sendCondition(cond)
[17:01:30.238]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.238]                   {
[17:01:30.238]                     inherits <- base::inherits
[17:01:30.238]                     invokeRestart <- base::invokeRestart
[17:01:30.238]                     is.null <- base::is.null
[17:01:30.238]                     muffled <- FALSE
[17:01:30.238]                     if (inherits(cond, "message")) {
[17:01:30.238]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:30.238]                       if (muffled) 
[17:01:30.238]                         invokeRestart("muffleMessage")
[17:01:30.238]                     }
[17:01:30.238]                     else if (inherits(cond, "warning")) {
[17:01:30.238]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:30.238]                       if (muffled) 
[17:01:30.238]                         invokeRestart("muffleWarning")
[17:01:30.238]                     }
[17:01:30.238]                     else if (inherits(cond, "condition")) {
[17:01:30.238]                       if (!is.null(pattern)) {
[17:01:30.238]                         computeRestarts <- base::computeRestarts
[17:01:30.238]                         grepl <- base::grepl
[17:01:30.238]                         restarts <- computeRestarts(cond)
[17:01:30.238]                         for (restart in restarts) {
[17:01:30.238]                           name <- restart$name
[17:01:30.238]                           if (is.null(name)) 
[17:01:30.238]                             next
[17:01:30.238]                           if (!grepl(pattern, name)) 
[17:01:30.238]                             next
[17:01:30.238]                           invokeRestart(restart)
[17:01:30.238]                           muffled <- TRUE
[17:01:30.238]                           break
[17:01:30.238]                         }
[17:01:30.238]                       }
[17:01:30.238]                     }
[17:01:30.238]                     invisible(muffled)
[17:01:30.238]                   }
[17:01:30.238]                   muffleCondition(cond)
[17:01:30.238]                 })
[17:01:30.238]             }))
[17:01:30.238]             future::FutureResult(value = ...future.value$value, 
[17:01:30.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:30.238]                   ...future.rng), globalenv = if (FALSE) 
[17:01:30.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:30.238]                     ...future.globalenv.names))
[17:01:30.238]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:30.238]         }, condition = base::local({
[17:01:30.238]             c <- base::c
[17:01:30.238]             inherits <- base::inherits
[17:01:30.238]             invokeRestart <- base::invokeRestart
[17:01:30.238]             length <- base::length
[17:01:30.238]             list <- base::list
[17:01:30.238]             seq.int <- base::seq.int
[17:01:30.238]             signalCondition <- base::signalCondition
[17:01:30.238]             sys.calls <- base::sys.calls
[17:01:30.238]             `[[` <- base::`[[`
[17:01:30.238]             `+` <- base::`+`
[17:01:30.238]             `<<-` <- base::`<<-`
[17:01:30.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:30.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:30.238]                   3L)]
[17:01:30.238]             }
[17:01:30.238]             function(cond) {
[17:01:30.238]                 is_error <- inherits(cond, "error")
[17:01:30.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:30.238]                   NULL)
[17:01:30.238]                 if (is_error) {
[17:01:30.238]                   sessionInformation <- function() {
[17:01:30.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:30.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:30.238]                       search = base::search(), system = base::Sys.info())
[17:01:30.238]                   }
[17:01:30.238]                   ...future.conditions[[length(...future.conditions) + 
[17:01:30.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:30.238]                     cond$call), session = sessionInformation(), 
[17:01:30.238]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:30.238]                   signalCondition(cond)
[17:01:30.238]                 }
[17:01:30.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:30.238]                 "immediateCondition"))) {
[17:01:30.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:30.238]                   ...future.conditions[[length(...future.conditions) + 
[17:01:30.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:30.238]                   if (TRUE && !signal) {
[17:01:30.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.238]                     {
[17:01:30.238]                       inherits <- base::inherits
[17:01:30.238]                       invokeRestart <- base::invokeRestart
[17:01:30.238]                       is.null <- base::is.null
[17:01:30.238]                       muffled <- FALSE
[17:01:30.238]                       if (inherits(cond, "message")) {
[17:01:30.238]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:30.238]                         if (muffled) 
[17:01:30.238]                           invokeRestart("muffleMessage")
[17:01:30.238]                       }
[17:01:30.238]                       else if (inherits(cond, "warning")) {
[17:01:30.238]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:30.238]                         if (muffled) 
[17:01:30.238]                           invokeRestart("muffleWarning")
[17:01:30.238]                       }
[17:01:30.238]                       else if (inherits(cond, "condition")) {
[17:01:30.238]                         if (!is.null(pattern)) {
[17:01:30.238]                           computeRestarts <- base::computeRestarts
[17:01:30.238]                           grepl <- base::grepl
[17:01:30.238]                           restarts <- computeRestarts(cond)
[17:01:30.238]                           for (restart in restarts) {
[17:01:30.238]                             name <- restart$name
[17:01:30.238]                             if (is.null(name)) 
[17:01:30.238]                               next
[17:01:30.238]                             if (!grepl(pattern, name)) 
[17:01:30.238]                               next
[17:01:30.238]                             invokeRestart(restart)
[17:01:30.238]                             muffled <- TRUE
[17:01:30.238]                             break
[17:01:30.238]                           }
[17:01:30.238]                         }
[17:01:30.238]                       }
[17:01:30.238]                       invisible(muffled)
[17:01:30.238]                     }
[17:01:30.238]                     muffleCondition(cond, pattern = "^muffle")
[17:01:30.238]                   }
[17:01:30.238]                 }
[17:01:30.238]                 else {
[17:01:30.238]                   if (TRUE) {
[17:01:30.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.238]                     {
[17:01:30.238]                       inherits <- base::inherits
[17:01:30.238]                       invokeRestart <- base::invokeRestart
[17:01:30.238]                       is.null <- base::is.null
[17:01:30.238]                       muffled <- FALSE
[17:01:30.238]                       if (inherits(cond, "message")) {
[17:01:30.238]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:30.238]                         if (muffled) 
[17:01:30.238]                           invokeRestart("muffleMessage")
[17:01:30.238]                       }
[17:01:30.238]                       else if (inherits(cond, "warning")) {
[17:01:30.238]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:30.238]                         if (muffled) 
[17:01:30.238]                           invokeRestart("muffleWarning")
[17:01:30.238]                       }
[17:01:30.238]                       else if (inherits(cond, "condition")) {
[17:01:30.238]                         if (!is.null(pattern)) {
[17:01:30.238]                           computeRestarts <- base::computeRestarts
[17:01:30.238]                           grepl <- base::grepl
[17:01:30.238]                           restarts <- computeRestarts(cond)
[17:01:30.238]                           for (restart in restarts) {
[17:01:30.238]                             name <- restart$name
[17:01:30.238]                             if (is.null(name)) 
[17:01:30.238]                               next
[17:01:30.238]                             if (!grepl(pattern, name)) 
[17:01:30.238]                               next
[17:01:30.238]                             invokeRestart(restart)
[17:01:30.238]                             muffled <- TRUE
[17:01:30.238]                             break
[17:01:30.238]                           }
[17:01:30.238]                         }
[17:01:30.238]                       }
[17:01:30.238]                       invisible(muffled)
[17:01:30.238]                     }
[17:01:30.238]                     muffleCondition(cond, pattern = "^muffle")
[17:01:30.238]                   }
[17:01:30.238]                 }
[17:01:30.238]             }
[17:01:30.238]         }))
[17:01:30.238]     }, error = function(ex) {
[17:01:30.238]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:30.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:30.238]                 ...future.rng), started = ...future.startTime, 
[17:01:30.238]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:30.238]             version = "1.8"), class = "FutureResult")
[17:01:30.238]     }, finally = {
[17:01:30.238]         if (!identical(...future.workdir, getwd())) 
[17:01:30.238]             setwd(...future.workdir)
[17:01:30.238]         {
[17:01:30.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:30.238]                 ...future.oldOptions$nwarnings <- NULL
[17:01:30.238]             }
[17:01:30.238]             base::options(...future.oldOptions)
[17:01:30.238]             if (.Platform$OS.type == "windows") {
[17:01:30.238]                 old_names <- names(...future.oldEnvVars)
[17:01:30.238]                 envs <- base::Sys.getenv()
[17:01:30.238]                 names <- names(envs)
[17:01:30.238]                 common <- intersect(names, old_names)
[17:01:30.238]                 added <- setdiff(names, old_names)
[17:01:30.238]                 removed <- setdiff(old_names, names)
[17:01:30.238]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:30.238]                   envs[common]]
[17:01:30.238]                 NAMES <- toupper(changed)
[17:01:30.238]                 args <- list()
[17:01:30.238]                 for (kk in seq_along(NAMES)) {
[17:01:30.238]                   name <- changed[[kk]]
[17:01:30.238]                   NAME <- NAMES[[kk]]
[17:01:30.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.238]                     next
[17:01:30.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:30.238]                 }
[17:01:30.238]                 NAMES <- toupper(added)
[17:01:30.238]                 for (kk in seq_along(NAMES)) {
[17:01:30.238]                   name <- added[[kk]]
[17:01:30.238]                   NAME <- NAMES[[kk]]
[17:01:30.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.238]                     next
[17:01:30.238]                   args[[name]] <- ""
[17:01:30.238]                 }
[17:01:30.238]                 NAMES <- toupper(removed)
[17:01:30.238]                 for (kk in seq_along(NAMES)) {
[17:01:30.238]                   name <- removed[[kk]]
[17:01:30.238]                   NAME <- NAMES[[kk]]
[17:01:30.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.238]                     next
[17:01:30.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:30.238]                 }
[17:01:30.238]                 if (length(args) > 0) 
[17:01:30.238]                   base::do.call(base::Sys.setenv, args = args)
[17:01:30.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:30.238]             }
[17:01:30.238]             else {
[17:01:30.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:30.238]             }
[17:01:30.238]             {
[17:01:30.238]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:30.238]                   0L) {
[17:01:30.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:30.238]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:30.238]                   base::options(opts)
[17:01:30.238]                 }
[17:01:30.238]                 {
[17:01:30.238]                   {
[17:01:30.238]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:30.238]                     NULL
[17:01:30.238]                   }
[17:01:30.238]                   options(future.plan = NULL)
[17:01:30.238]                   if (is.na(NA_character_)) 
[17:01:30.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:30.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:30.238]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:30.238]                     .init = FALSE)
[17:01:30.238]                 }
[17:01:30.238]             }
[17:01:30.238]         }
[17:01:30.238]     })
[17:01:30.238]     if (TRUE) {
[17:01:30.238]         base::sink(type = "output", split = FALSE)
[17:01:30.238]         if (TRUE) {
[17:01:30.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:30.238]         }
[17:01:30.238]         else {
[17:01:30.238]             ...future.result["stdout"] <- base::list(NULL)
[17:01:30.238]         }
[17:01:30.238]         base::close(...future.stdout)
[17:01:30.238]         ...future.stdout <- NULL
[17:01:30.238]     }
[17:01:30.238]     ...future.result$conditions <- ...future.conditions
[17:01:30.238]     ...future.result$finished <- base::Sys.time()
[17:01:30.238]     ...future.result
[17:01:30.238] }
[17:01:30.242] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:01:30.242] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:01:30.242] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:01:30.242] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:30.243] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:30.243] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:01:30.243] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:01:30.243] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:30.244] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:30.244] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:30.244] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:30.244] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:01:30.245] MultisessionFuture started
[17:01:30.245] - Launch lazy future ... done
[17:01:30.245] run() for ‘MultisessionFuture’ ... done
[17:01:30.245] Created future:
[17:01:30.245] MultisessionFuture:
[17:01:30.245] Label: ‘future_lapply-1’
[17:01:30.245] Expression:
[17:01:30.245] {
[17:01:30.245]     do.call(function(...) {
[17:01:30.245]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.245]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:30.245]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.245]             on.exit(options(oopts), add = TRUE)
[17:01:30.245]         }
[17:01:30.245]         {
[17:01:30.245]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:30.245]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.245]                 ...future.FUN(...future.X_jj, ...)
[17:01:30.245]             })
[17:01:30.245]         }
[17:01:30.245]     }, args = future.call.arguments)
[17:01:30.245] }
[17:01:30.245] Lazy evaluation: FALSE
[17:01:30.245] Asynchronous evaluation: TRUE
[17:01:30.245] Local evaluation: TRUE
[17:01:30.245] Environment: R_GlobalEnv
[17:01:30.245] Capture standard output: TRUE
[17:01:30.245] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:30.245] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:30.245] Packages: <none>
[17:01:30.245] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:30.245] Resolved: FALSE
[17:01:30.245] Value: <not collected>
[17:01:30.245] Conditions captured: <none>
[17:01:30.245] Early signaling: FALSE
[17:01:30.245] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:30.245] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:30.257] Chunk #1 of 2 ... DONE
[17:01:30.257] Chunk #2 of 2 ...
[17:01:30.257]  - Finding globals in 'X' for chunk #2 ...
[17:01:30.257] getGlobalsAndPackages() ...
[17:01:30.257] Searching for globals...
[17:01:30.257] 
[17:01:30.257] Searching for globals ... DONE
[17:01:30.258] - globals: [0] <none>
[17:01:30.258] getGlobalsAndPackages() ... DONE
[17:01:30.258]    + additional globals found: [n=0] 
[17:01:30.258]    + additional namespaces needed: [n=0] 
[17:01:30.258]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:30.258]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:30.258]  - seeds: <none>
[17:01:30.258]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.258] getGlobalsAndPackages() ...
[17:01:30.258] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.258] Resolving globals: FALSE
[17:01:30.259] Tweak future expression to call with '...' arguments ...
[17:01:30.259] {
[17:01:30.259]     do.call(function(...) {
[17:01:30.259]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.259]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:30.259]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.259]             on.exit(options(oopts), add = TRUE)
[17:01:30.259]         }
[17:01:30.259]         {
[17:01:30.259]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:30.259]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.259]                 ...future.FUN(...future.X_jj, ...)
[17:01:30.259]             })
[17:01:30.259]         }
[17:01:30.259]     }, args = future.call.arguments)
[17:01:30.259] }
[17:01:30.259] Tweak future expression to call with '...' arguments ... DONE
[17:01:30.259] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.259] 
[17:01:30.260] getGlobalsAndPackages() ... DONE
[17:01:30.260] run() for ‘Future’ ...
[17:01:30.260] - state: ‘created’
[17:01:30.260] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:30.274] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:30.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:30.274]   - Field: ‘node’
[17:01:30.275]   - Field: ‘label’
[17:01:30.275]   - Field: ‘local’
[17:01:30.275]   - Field: ‘owner’
[17:01:30.275]   - Field: ‘envir’
[17:01:30.275]   - Field: ‘workers’
[17:01:30.275]   - Field: ‘packages’
[17:01:30.275]   - Field: ‘gc’
[17:01:30.275]   - Field: ‘conditions’
[17:01:30.275]   - Field: ‘persistent’
[17:01:30.275]   - Field: ‘expr’
[17:01:30.275]   - Field: ‘uuid’
[17:01:30.276]   - Field: ‘seed’
[17:01:30.276]   - Field: ‘version’
[17:01:30.276]   - Field: ‘result’
[17:01:30.276]   - Field: ‘asynchronous’
[17:01:30.276]   - Field: ‘calls’
[17:01:30.276]   - Field: ‘globals’
[17:01:30.276]   - Field: ‘stdout’
[17:01:30.276]   - Field: ‘earlySignal’
[17:01:30.276]   - Field: ‘lazy’
[17:01:30.276]   - Field: ‘state’
[17:01:30.276] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:30.277] - Launch lazy future ...
[17:01:30.277] Packages needed by the future expression (n = 0): <none>
[17:01:30.277] Packages needed by future strategies (n = 0): <none>
[17:01:30.277] {
[17:01:30.277]     {
[17:01:30.277]         {
[17:01:30.277]             ...future.startTime <- base::Sys.time()
[17:01:30.277]             {
[17:01:30.277]                 {
[17:01:30.277]                   {
[17:01:30.277]                     {
[17:01:30.277]                       base::local({
[17:01:30.277]                         has_future <- base::requireNamespace("future", 
[17:01:30.277]                           quietly = TRUE)
[17:01:30.277]                         if (has_future) {
[17:01:30.277]                           ns <- base::getNamespace("future")
[17:01:30.277]                           version <- ns[[".package"]][["version"]]
[17:01:30.277]                           if (is.null(version)) 
[17:01:30.277]                             version <- utils::packageVersion("future")
[17:01:30.277]                         }
[17:01:30.277]                         else {
[17:01:30.277]                           version <- NULL
[17:01:30.277]                         }
[17:01:30.277]                         if (!has_future || version < "1.8.0") {
[17:01:30.277]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:30.277]                             "", base::R.version$version.string), 
[17:01:30.277]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:30.277]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:30.277]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:30.277]                               "release", "version")], collapse = " "), 
[17:01:30.277]                             hostname = base::Sys.info()[["nodename"]])
[17:01:30.277]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:30.277]                             info)
[17:01:30.277]                           info <- base::paste(info, collapse = "; ")
[17:01:30.277]                           if (!has_future) {
[17:01:30.277]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:30.277]                               info)
[17:01:30.277]                           }
[17:01:30.277]                           else {
[17:01:30.277]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:30.277]                               info, version)
[17:01:30.277]                           }
[17:01:30.277]                           base::stop(msg)
[17:01:30.277]                         }
[17:01:30.277]                       })
[17:01:30.277]                     }
[17:01:30.277]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:30.277]                     base::options(mc.cores = 1L)
[17:01:30.277]                   }
[17:01:30.277]                   ...future.strategy.old <- future::plan("list")
[17:01:30.277]                   options(future.plan = NULL)
[17:01:30.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:30.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:30.277]                 }
[17:01:30.277]                 ...future.workdir <- getwd()
[17:01:30.277]             }
[17:01:30.277]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:30.277]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:30.277]         }
[17:01:30.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:30.277]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:30.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:30.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:30.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:30.277]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:30.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:30.277]             base::names(...future.oldOptions))
[17:01:30.277]     }
[17:01:30.277]     if (FALSE) {
[17:01:30.277]     }
[17:01:30.277]     else {
[17:01:30.277]         if (TRUE) {
[17:01:30.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:30.277]                 open = "w")
[17:01:30.277]         }
[17:01:30.277]         else {
[17:01:30.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:30.277]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:30.277]         }
[17:01:30.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:30.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:30.277]             base::sink(type = "output", split = FALSE)
[17:01:30.277]             base::close(...future.stdout)
[17:01:30.277]         }, add = TRUE)
[17:01:30.277]     }
[17:01:30.277]     ...future.frame <- base::sys.nframe()
[17:01:30.277]     ...future.conditions <- base::list()
[17:01:30.277]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:30.277]     if (FALSE) {
[17:01:30.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:30.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:30.277]     }
[17:01:30.277]     ...future.result <- base::tryCatch({
[17:01:30.277]         base::withCallingHandlers({
[17:01:30.277]             ...future.value <- base::withVisible(base::local({
[17:01:30.277]                 ...future.makeSendCondition <- base::local({
[17:01:30.277]                   sendCondition <- NULL
[17:01:30.277]                   function(frame = 1L) {
[17:01:30.277]                     if (is.function(sendCondition)) 
[17:01:30.277]                       return(sendCondition)
[17:01:30.277]                     ns <- getNamespace("parallel")
[17:01:30.277]                     if (exists("sendData", mode = "function", 
[17:01:30.277]                       envir = ns)) {
[17:01:30.277]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:30.277]                         envir = ns)
[17:01:30.277]                       envir <- sys.frame(frame)
[17:01:30.277]                       master <- NULL
[17:01:30.277]                       while (!identical(envir, .GlobalEnv) && 
[17:01:30.277]                         !identical(envir, emptyenv())) {
[17:01:30.277]                         if (exists("master", mode = "list", envir = envir, 
[17:01:30.277]                           inherits = FALSE)) {
[17:01:30.277]                           master <- get("master", mode = "list", 
[17:01:30.277]                             envir = envir, inherits = FALSE)
[17:01:30.277]                           if (inherits(master, c("SOCKnode", 
[17:01:30.277]                             "SOCK0node"))) {
[17:01:30.277]                             sendCondition <<- function(cond) {
[17:01:30.277]                               data <- list(type = "VALUE", value = cond, 
[17:01:30.277]                                 success = TRUE)
[17:01:30.277]                               parallel_sendData(master, data)
[17:01:30.277]                             }
[17:01:30.277]                             return(sendCondition)
[17:01:30.277]                           }
[17:01:30.277]                         }
[17:01:30.277]                         frame <- frame + 1L
[17:01:30.277]                         envir <- sys.frame(frame)
[17:01:30.277]                       }
[17:01:30.277]                     }
[17:01:30.277]                     sendCondition <<- function(cond) NULL
[17:01:30.277]                   }
[17:01:30.277]                 })
[17:01:30.277]                 withCallingHandlers({
[17:01:30.277]                   {
[17:01:30.277]                     do.call(function(...) {
[17:01:30.277]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.277]                       if (!identical(...future.globals.maxSize.org, 
[17:01:30.277]                         ...future.globals.maxSize)) {
[17:01:30.277]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.277]                         on.exit(options(oopts), add = TRUE)
[17:01:30.277]                       }
[17:01:30.277]                       {
[17:01:30.277]                         lapply(seq_along(...future.elements_ii), 
[17:01:30.277]                           FUN = function(jj) {
[17:01:30.277]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.277]                             ...future.FUN(...future.X_jj, ...)
[17:01:30.277]                           })
[17:01:30.277]                       }
[17:01:30.277]                     }, args = future.call.arguments)
[17:01:30.277]                   }
[17:01:30.277]                 }, immediateCondition = function(cond) {
[17:01:30.277]                   sendCondition <- ...future.makeSendCondition()
[17:01:30.277]                   sendCondition(cond)
[17:01:30.277]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.277]                   {
[17:01:30.277]                     inherits <- base::inherits
[17:01:30.277]                     invokeRestart <- base::invokeRestart
[17:01:30.277]                     is.null <- base::is.null
[17:01:30.277]                     muffled <- FALSE
[17:01:30.277]                     if (inherits(cond, "message")) {
[17:01:30.277]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:30.277]                       if (muffled) 
[17:01:30.277]                         invokeRestart("muffleMessage")
[17:01:30.277]                     }
[17:01:30.277]                     else if (inherits(cond, "warning")) {
[17:01:30.277]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:30.277]                       if (muffled) 
[17:01:30.277]                         invokeRestart("muffleWarning")
[17:01:30.277]                     }
[17:01:30.277]                     else if (inherits(cond, "condition")) {
[17:01:30.277]                       if (!is.null(pattern)) {
[17:01:30.277]                         computeRestarts <- base::computeRestarts
[17:01:30.277]                         grepl <- base::grepl
[17:01:30.277]                         restarts <- computeRestarts(cond)
[17:01:30.277]                         for (restart in restarts) {
[17:01:30.277]                           name <- restart$name
[17:01:30.277]                           if (is.null(name)) 
[17:01:30.277]                             next
[17:01:30.277]                           if (!grepl(pattern, name)) 
[17:01:30.277]                             next
[17:01:30.277]                           invokeRestart(restart)
[17:01:30.277]                           muffled <- TRUE
[17:01:30.277]                           break
[17:01:30.277]                         }
[17:01:30.277]                       }
[17:01:30.277]                     }
[17:01:30.277]                     invisible(muffled)
[17:01:30.277]                   }
[17:01:30.277]                   muffleCondition(cond)
[17:01:30.277]                 })
[17:01:30.277]             }))
[17:01:30.277]             future::FutureResult(value = ...future.value$value, 
[17:01:30.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:30.277]                   ...future.rng), globalenv = if (FALSE) 
[17:01:30.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:30.277]                     ...future.globalenv.names))
[17:01:30.277]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:30.277]         }, condition = base::local({
[17:01:30.277]             c <- base::c
[17:01:30.277]             inherits <- base::inherits
[17:01:30.277]             invokeRestart <- base::invokeRestart
[17:01:30.277]             length <- base::length
[17:01:30.277]             list <- base::list
[17:01:30.277]             seq.int <- base::seq.int
[17:01:30.277]             signalCondition <- base::signalCondition
[17:01:30.277]             sys.calls <- base::sys.calls
[17:01:30.277]             `[[` <- base::`[[`
[17:01:30.277]             `+` <- base::`+`
[17:01:30.277]             `<<-` <- base::`<<-`
[17:01:30.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:30.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:30.277]                   3L)]
[17:01:30.277]             }
[17:01:30.277]             function(cond) {
[17:01:30.277]                 is_error <- inherits(cond, "error")
[17:01:30.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:30.277]                   NULL)
[17:01:30.277]                 if (is_error) {
[17:01:30.277]                   sessionInformation <- function() {
[17:01:30.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:30.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:30.277]                       search = base::search(), system = base::Sys.info())
[17:01:30.277]                   }
[17:01:30.277]                   ...future.conditions[[length(...future.conditions) + 
[17:01:30.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:30.277]                     cond$call), session = sessionInformation(), 
[17:01:30.277]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:30.277]                   signalCondition(cond)
[17:01:30.277]                 }
[17:01:30.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:30.277]                 "immediateCondition"))) {
[17:01:30.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:30.277]                   ...future.conditions[[length(...future.conditions) + 
[17:01:30.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:30.277]                   if (TRUE && !signal) {
[17:01:30.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.277]                     {
[17:01:30.277]                       inherits <- base::inherits
[17:01:30.277]                       invokeRestart <- base::invokeRestart
[17:01:30.277]                       is.null <- base::is.null
[17:01:30.277]                       muffled <- FALSE
[17:01:30.277]                       if (inherits(cond, "message")) {
[17:01:30.277]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:30.277]                         if (muffled) 
[17:01:30.277]                           invokeRestart("muffleMessage")
[17:01:30.277]                       }
[17:01:30.277]                       else if (inherits(cond, "warning")) {
[17:01:30.277]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:30.277]                         if (muffled) 
[17:01:30.277]                           invokeRestart("muffleWarning")
[17:01:30.277]                       }
[17:01:30.277]                       else if (inherits(cond, "condition")) {
[17:01:30.277]                         if (!is.null(pattern)) {
[17:01:30.277]                           computeRestarts <- base::computeRestarts
[17:01:30.277]                           grepl <- base::grepl
[17:01:30.277]                           restarts <- computeRestarts(cond)
[17:01:30.277]                           for (restart in restarts) {
[17:01:30.277]                             name <- restart$name
[17:01:30.277]                             if (is.null(name)) 
[17:01:30.277]                               next
[17:01:30.277]                             if (!grepl(pattern, name)) 
[17:01:30.277]                               next
[17:01:30.277]                             invokeRestart(restart)
[17:01:30.277]                             muffled <- TRUE
[17:01:30.277]                             break
[17:01:30.277]                           }
[17:01:30.277]                         }
[17:01:30.277]                       }
[17:01:30.277]                       invisible(muffled)
[17:01:30.277]                     }
[17:01:30.277]                     muffleCondition(cond, pattern = "^muffle")
[17:01:30.277]                   }
[17:01:30.277]                 }
[17:01:30.277]                 else {
[17:01:30.277]                   if (TRUE) {
[17:01:30.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.277]                     {
[17:01:30.277]                       inherits <- base::inherits
[17:01:30.277]                       invokeRestart <- base::invokeRestart
[17:01:30.277]                       is.null <- base::is.null
[17:01:30.277]                       muffled <- FALSE
[17:01:30.277]                       if (inherits(cond, "message")) {
[17:01:30.277]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:30.277]                         if (muffled) 
[17:01:30.277]                           invokeRestart("muffleMessage")
[17:01:30.277]                       }
[17:01:30.277]                       else if (inherits(cond, "warning")) {
[17:01:30.277]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:30.277]                         if (muffled) 
[17:01:30.277]                           invokeRestart("muffleWarning")
[17:01:30.277]                       }
[17:01:30.277]                       else if (inherits(cond, "condition")) {
[17:01:30.277]                         if (!is.null(pattern)) {
[17:01:30.277]                           computeRestarts <- base::computeRestarts
[17:01:30.277]                           grepl <- base::grepl
[17:01:30.277]                           restarts <- computeRestarts(cond)
[17:01:30.277]                           for (restart in restarts) {
[17:01:30.277]                             name <- restart$name
[17:01:30.277]                             if (is.null(name)) 
[17:01:30.277]                               next
[17:01:30.277]                             if (!grepl(pattern, name)) 
[17:01:30.277]                               next
[17:01:30.277]                             invokeRestart(restart)
[17:01:30.277]                             muffled <- TRUE
[17:01:30.277]                             break
[17:01:30.277]                           }
[17:01:30.277]                         }
[17:01:30.277]                       }
[17:01:30.277]                       invisible(muffled)
[17:01:30.277]                     }
[17:01:30.277]                     muffleCondition(cond, pattern = "^muffle")
[17:01:30.277]                   }
[17:01:30.277]                 }
[17:01:30.277]             }
[17:01:30.277]         }))
[17:01:30.277]     }, error = function(ex) {
[17:01:30.277]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:30.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:30.277]                 ...future.rng), started = ...future.startTime, 
[17:01:30.277]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:30.277]             version = "1.8"), class = "FutureResult")
[17:01:30.277]     }, finally = {
[17:01:30.277]         if (!identical(...future.workdir, getwd())) 
[17:01:30.277]             setwd(...future.workdir)
[17:01:30.277]         {
[17:01:30.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:30.277]                 ...future.oldOptions$nwarnings <- NULL
[17:01:30.277]             }
[17:01:30.277]             base::options(...future.oldOptions)
[17:01:30.277]             if (.Platform$OS.type == "windows") {
[17:01:30.277]                 old_names <- names(...future.oldEnvVars)
[17:01:30.277]                 envs <- base::Sys.getenv()
[17:01:30.277]                 names <- names(envs)
[17:01:30.277]                 common <- intersect(names, old_names)
[17:01:30.277]                 added <- setdiff(names, old_names)
[17:01:30.277]                 removed <- setdiff(old_names, names)
[17:01:30.277]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:30.277]                   envs[common]]
[17:01:30.277]                 NAMES <- toupper(changed)
[17:01:30.277]                 args <- list()
[17:01:30.277]                 for (kk in seq_along(NAMES)) {
[17:01:30.277]                   name <- changed[[kk]]
[17:01:30.277]                   NAME <- NAMES[[kk]]
[17:01:30.277]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.277]                     next
[17:01:30.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:30.277]                 }
[17:01:30.277]                 NAMES <- toupper(added)
[17:01:30.277]                 for (kk in seq_along(NAMES)) {
[17:01:30.277]                   name <- added[[kk]]
[17:01:30.277]                   NAME <- NAMES[[kk]]
[17:01:30.277]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.277]                     next
[17:01:30.277]                   args[[name]] <- ""
[17:01:30.277]                 }
[17:01:30.277]                 NAMES <- toupper(removed)
[17:01:30.277]                 for (kk in seq_along(NAMES)) {
[17:01:30.277]                   name <- removed[[kk]]
[17:01:30.277]                   NAME <- NAMES[[kk]]
[17:01:30.277]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.277]                     next
[17:01:30.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:30.277]                 }
[17:01:30.277]                 if (length(args) > 0) 
[17:01:30.277]                   base::do.call(base::Sys.setenv, args = args)
[17:01:30.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:30.277]             }
[17:01:30.277]             else {
[17:01:30.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:30.277]             }
[17:01:30.277]             {
[17:01:30.277]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:30.277]                   0L) {
[17:01:30.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:30.277]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:30.277]                   base::options(opts)
[17:01:30.277]                 }
[17:01:30.277]                 {
[17:01:30.277]                   {
[17:01:30.277]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:30.277]                     NULL
[17:01:30.277]                   }
[17:01:30.277]                   options(future.plan = NULL)
[17:01:30.277]                   if (is.na(NA_character_)) 
[17:01:30.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:30.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:30.277]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:30.277]                     .init = FALSE)
[17:01:30.277]                 }
[17:01:30.277]             }
[17:01:30.277]         }
[17:01:30.277]     })
[17:01:30.277]     if (TRUE) {
[17:01:30.277]         base::sink(type = "output", split = FALSE)
[17:01:30.277]         if (TRUE) {
[17:01:30.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:30.277]         }
[17:01:30.277]         else {
[17:01:30.277]             ...future.result["stdout"] <- base::list(NULL)
[17:01:30.277]         }
[17:01:30.277]         base::close(...future.stdout)
[17:01:30.277]         ...future.stdout <- NULL
[17:01:30.277]     }
[17:01:30.277]     ...future.result$conditions <- ...future.conditions
[17:01:30.277]     ...future.result$finished <- base::Sys.time()
[17:01:30.277]     ...future.result
[17:01:30.277] }
[17:01:30.280] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:01:30.280] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:01:30.281] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:01:30.281] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:30.281] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:30.282] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:01:30.282] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:01:30.282] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:30.282] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:30.282] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:30.283] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:30.283] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:01:30.283] MultisessionFuture started
[17:01:30.283] - Launch lazy future ... done
[17:01:30.284] run() for ‘MultisessionFuture’ ... done
[17:01:30.284] Created future:
[17:01:30.284] MultisessionFuture:
[17:01:30.284] Label: ‘future_lapply-2’
[17:01:30.284] Expression:
[17:01:30.284] {
[17:01:30.284]     do.call(function(...) {
[17:01:30.284]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.284]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:30.284]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.284]             on.exit(options(oopts), add = TRUE)
[17:01:30.284]         }
[17:01:30.284]         {
[17:01:30.284]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:30.284]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.284]                 ...future.FUN(...future.X_jj, ...)
[17:01:30.284]             })
[17:01:30.284]         }
[17:01:30.284]     }, args = future.call.arguments)
[17:01:30.284] }
[17:01:30.284] Lazy evaluation: FALSE
[17:01:30.284] Asynchronous evaluation: TRUE
[17:01:30.284] Local evaluation: TRUE
[17:01:30.284] Environment: R_GlobalEnv
[17:01:30.284] Capture standard output: TRUE
[17:01:30.284] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:30.284] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:30.284] Packages: <none>
[17:01:30.284] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:30.284] Resolved: FALSE
[17:01:30.284] Value: <not collected>
[17:01:30.284] Conditions captured: <none>
[17:01:30.284] Early signaling: FALSE
[17:01:30.284] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:30.284] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:30.295] Chunk #2 of 2 ... DONE
[17:01:30.296] Launching 2 futures (chunks) ... DONE
[17:01:30.296] Resolving 2 futures (chunks) ...
[17:01:30.296] resolve() on list ...
[17:01:30.296]  recursive: 0
[17:01:30.296]  length: 2
[17:01:30.296] 
[17:01:30.339] receiveMessageFromWorker() for ClusterFuture ...
[17:01:30.339] - Validating connection of MultisessionFuture
[17:01:30.339] - received message: FutureResult
[17:01:30.339] - Received FutureResult
[17:01:30.339] - Erased future from FutureRegistry
[17:01:30.339] result() for ClusterFuture ...
[17:01:30.340] - result already collected: FutureResult
[17:01:30.340] result() for ClusterFuture ... done
[17:01:30.340] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:30.340] Future #2
[17:01:30.340] result() for ClusterFuture ...
[17:01:30.340] - result already collected: FutureResult
[17:01:30.340] result() for ClusterFuture ... done
[17:01:30.340] result() for ClusterFuture ...
[17:01:30.340] - result already collected: FutureResult
[17:01:30.340] result() for ClusterFuture ... done
[17:01:30.340] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:30.341] - nx: 2
[17:01:30.341] - relay: TRUE
[17:01:30.341] - stdout: TRUE
[17:01:30.341] - signal: TRUE
[17:01:30.341] - resignal: FALSE
[17:01:30.341] - force: TRUE
[17:01:30.341] - relayed: [n=2] FALSE, FALSE
[17:01:30.341] - queued futures: [n=2] FALSE, FALSE
[17:01:30.341]  - until=1
[17:01:30.341]  - relaying element #1
[17:01:30.341] - relayed: [n=2] FALSE, FALSE
[17:01:30.341] - queued futures: [n=2] FALSE, TRUE
[17:01:30.342] signalConditionsASAP(NULL, pos=2) ... done
[17:01:30.342]  length: 1 (resolved future 2)
[17:01:30.794] receiveMessageFromWorker() for ClusterFuture ...
[17:01:30.794] - Validating connection of MultisessionFuture
[17:01:30.794] - received message: FutureResult
[17:01:30.795] - Received FutureResult
[17:01:30.795] - Erased future from FutureRegistry
[17:01:30.795] result() for ClusterFuture ...
[17:01:30.795] - result already collected: FutureResult
[17:01:30.795] result() for ClusterFuture ... done
[17:01:30.795] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:30.795] Future #1
[17:01:30.795] result() for ClusterFuture ...
[17:01:30.795] - result already collected: FutureResult
[17:01:30.795] result() for ClusterFuture ... done
[17:01:30.796] result() for ClusterFuture ...
[17:01:30.796] - result already collected: FutureResult
[17:01:30.796] result() for ClusterFuture ... done
[17:01:30.796] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:30.796] - nx: 2
[17:01:30.796] - relay: TRUE
[17:01:30.796] - stdout: TRUE
[17:01:30.796] - signal: TRUE
[17:01:30.796] - resignal: FALSE
[17:01:30.796] - force: TRUE
[17:01:30.796] - relayed: [n=2] FALSE, FALSE
[17:01:30.796] - queued futures: [n=2] FALSE, TRUE
[17:01:30.797]  - until=1
[17:01:30.797]  - relaying element #1
[17:01:30.797] result() for ClusterFuture ...
[17:01:30.797] - result already collected: FutureResult
[17:01:30.797] result() for ClusterFuture ... done
[17:01:30.797] result() for ClusterFuture ...
[17:01:30.797] - result already collected: FutureResult
[17:01:30.797] result() for ClusterFuture ... done
[17:01:30.797] result() for ClusterFuture ...
[17:01:30.797] - result already collected: FutureResult
[17:01:30.797] result() for ClusterFuture ... done
[17:01:30.797] result() for ClusterFuture ...
[17:01:30.798] - result already collected: FutureResult
[17:01:30.798] result() for ClusterFuture ... done
[17:01:30.798] - relayed: [n=2] TRUE, FALSE
[17:01:30.798] - queued futures: [n=2] TRUE, TRUE
[17:01:30.798] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:30.798]  length: 0 (resolved future 1)
[17:01:30.798] Relaying remaining futures
[17:01:30.798] signalConditionsASAP(NULL, pos=0) ...
[17:01:30.798] - nx: 2
[17:01:30.798] - relay: TRUE
[17:01:30.798] - stdout: TRUE
[17:01:30.798] - signal: TRUE
[17:01:30.799] - resignal: FALSE
[17:01:30.799] - force: TRUE
[17:01:30.799] - relayed: [n=2] TRUE, FALSE
[17:01:30.799] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:30.799]  - relaying element #2
[17:01:30.799] result() for ClusterFuture ...
[17:01:30.799] - result already collected: FutureResult
[17:01:30.799] result() for ClusterFuture ... done
[17:01:30.799] result() for ClusterFuture ...
[17:01:30.799] - result already collected: FutureResult
[17:01:30.801] result() for ClusterFuture ... done
[17:01:30.801] result() for ClusterFuture ...
[17:01:30.802] - result already collected: FutureResult
[17:01:30.802] result() for ClusterFuture ... done
[17:01:30.802] result() for ClusterFuture ...
[17:01:30.802] - result already collected: FutureResult
[17:01:30.802] result() for ClusterFuture ... done
[17:01:30.802] - relayed: [n=2] TRUE, TRUE
[17:01:30.802] - queued futures: [n=2] TRUE, TRUE
[17:01:30.802] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:01:30.802] resolve() on list ... DONE
[17:01:30.802] result() for ClusterFuture ...
[17:01:30.802] - result already collected: FutureResult
[17:01:30.802] result() for ClusterFuture ... done
[17:01:30.803] result() for ClusterFuture ...
[17:01:30.803] - result already collected: FutureResult
[17:01:30.803] result() for ClusterFuture ... done
[17:01:30.803] result() for ClusterFuture ...
[17:01:30.803] - result already collected: FutureResult
[17:01:30.803] result() for ClusterFuture ... done
[17:01:30.803] result() for ClusterFuture ...
[17:01:30.803] - result already collected: FutureResult
[17:01:30.803] result() for ClusterFuture ... done
[17:01:30.803]  - Number of value chunks collected: 2
[17:01:30.803] Resolving 2 futures (chunks) ... DONE
[17:01:30.804] Reducing values from 2 chunks ...
[17:01:30.804]  - Number of values collected after concatenation: 2
[17:01:30.804]  - Number of values expected: 2
[17:01:30.804] Reducing values from 2 chunks ... DONE
[17:01:30.804] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:01:30.804] future_lapply() ...
[17:01:30.809] Number of chunks: 2
[17:01:30.809] getGlobalsAndPackagesXApply() ...
[17:01:30.809]  - future.globals: TRUE
[17:01:30.809] getGlobalsAndPackages() ...
[17:01:30.809] Searching for globals...
[17:01:30.811] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:01:30.811] Searching for globals ... DONE
[17:01:30.811] Resolving globals: FALSE
[17:01:30.812] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:01:30.812] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:01:30.812] - globals: [1] ‘FUN’
[17:01:30.812] 
[17:01:30.812] getGlobalsAndPackages() ... DONE
[17:01:30.812]  - globals found/used: [n=1] ‘FUN’
[17:01:30.812]  - needed namespaces: [n=0] 
[17:01:30.813] Finding globals ... DONE
[17:01:30.813]  - use_args: TRUE
[17:01:30.813]  - Getting '...' globals ...
[17:01:30.813] resolve() on list ...
[17:01:30.813]  recursive: 0
[17:01:30.813]  length: 1
[17:01:30.813]  elements: ‘...’
[17:01:30.813]  length: 0 (resolved future 1)
[17:01:30.814] resolve() on list ... DONE
[17:01:30.814]    - '...' content: [n=0] 
[17:01:30.814] List of 1
[17:01:30.814]  $ ...: list()
[17:01:30.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:30.814]  - attr(*, "where")=List of 1
[17:01:30.814]   ..$ ...:<environment: 0x5636f74ea220> 
[17:01:30.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:30.814]  - attr(*, "resolved")= logi TRUE
[17:01:30.814]  - attr(*, "total_size")= num NA
[17:01:30.816]  - Getting '...' globals ... DONE
[17:01:30.816] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:30.817] List of 2
[17:01:30.817]  $ ...future.FUN:function (x)  
[17:01:30.817]  $ ...          : list()
[17:01:30.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:30.817]  - attr(*, "where")=List of 2
[17:01:30.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:30.817]   ..$ ...          :<environment: 0x5636f74ea220> 
[17:01:30.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:30.817]  - attr(*, "resolved")= logi FALSE
[17:01:30.817]  - attr(*, "total_size")= num 4720
[17:01:30.819] Packages to be attached in all futures: [n=0] 
[17:01:30.819] getGlobalsAndPackagesXApply() ... DONE
[17:01:30.819] Number of futures (= number of chunks): 2
[17:01:30.820] Launching 2 futures (chunks) ...
[17:01:30.820] Chunk #1 of 2 ...
[17:01:30.820]  - Finding globals in 'X' for chunk #1 ...
[17:01:30.820] getGlobalsAndPackages() ...
[17:01:30.820] Searching for globals...
[17:01:30.820] 
[17:01:30.820] Searching for globals ... DONE
[17:01:30.820] - globals: [0] <none>
[17:01:30.820] getGlobalsAndPackages() ... DONE
[17:01:30.821]    + additional globals found: [n=0] 
[17:01:30.821]    + additional namespaces needed: [n=0] 
[17:01:30.821]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:30.821]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:30.821]  - seeds: <none>
[17:01:30.821]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.821] getGlobalsAndPackages() ...
[17:01:30.821] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.821] Resolving globals: FALSE
[17:01:30.821] Tweak future expression to call with '...' arguments ...
[17:01:30.822] {
[17:01:30.822]     do.call(function(...) {
[17:01:30.822]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.822]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:30.822]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.822]             on.exit(options(oopts), add = TRUE)
[17:01:30.822]         }
[17:01:30.822]         {
[17:01:30.822]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:30.822]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.822]                 ...future.FUN(...future.X_jj, ...)
[17:01:30.822]             })
[17:01:30.822]         }
[17:01:30.822]     }, args = future.call.arguments)
[17:01:30.822] }
[17:01:30.822] Tweak future expression to call with '...' arguments ... DONE
[17:01:30.822] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.822] 
[17:01:30.822] getGlobalsAndPackages() ... DONE
[17:01:30.823] run() for ‘Future’ ...
[17:01:30.823] - state: ‘created’
[17:01:30.823] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:30.839] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:30.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:30.840]   - Field: ‘node’
[17:01:30.840]   - Field: ‘label’
[17:01:30.840]   - Field: ‘local’
[17:01:30.840]   - Field: ‘owner’
[17:01:30.840]   - Field: ‘envir’
[17:01:30.840]   - Field: ‘workers’
[17:01:30.840]   - Field: ‘packages’
[17:01:30.840]   - Field: ‘gc’
[17:01:30.841]   - Field: ‘conditions’
[17:01:30.841]   - Field: ‘persistent’
[17:01:30.841]   - Field: ‘expr’
[17:01:30.841]   - Field: ‘uuid’
[17:01:30.841]   - Field: ‘seed’
[17:01:30.841]   - Field: ‘version’
[17:01:30.841]   - Field: ‘result’
[17:01:30.841]   - Field: ‘asynchronous’
[17:01:30.841]   - Field: ‘calls’
[17:01:30.841]   - Field: ‘globals’
[17:01:30.841]   - Field: ‘stdout’
[17:01:30.842]   - Field: ‘earlySignal’
[17:01:30.842]   - Field: ‘lazy’
[17:01:30.842]   - Field: ‘state’
[17:01:30.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:30.842] - Launch lazy future ...
[17:01:30.842] Packages needed by the future expression (n = 0): <none>
[17:01:30.842] Packages needed by future strategies (n = 0): <none>
[17:01:30.843] {
[17:01:30.843]     {
[17:01:30.843]         {
[17:01:30.843]             ...future.startTime <- base::Sys.time()
[17:01:30.843]             {
[17:01:30.843]                 {
[17:01:30.843]                   {
[17:01:30.843]                     {
[17:01:30.843]                       base::local({
[17:01:30.843]                         has_future <- base::requireNamespace("future", 
[17:01:30.843]                           quietly = TRUE)
[17:01:30.843]                         if (has_future) {
[17:01:30.843]                           ns <- base::getNamespace("future")
[17:01:30.843]                           version <- ns[[".package"]][["version"]]
[17:01:30.843]                           if (is.null(version)) 
[17:01:30.843]                             version <- utils::packageVersion("future")
[17:01:30.843]                         }
[17:01:30.843]                         else {
[17:01:30.843]                           version <- NULL
[17:01:30.843]                         }
[17:01:30.843]                         if (!has_future || version < "1.8.0") {
[17:01:30.843]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:30.843]                             "", base::R.version$version.string), 
[17:01:30.843]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:30.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:30.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:30.843]                               "release", "version")], collapse = " "), 
[17:01:30.843]                             hostname = base::Sys.info()[["nodename"]])
[17:01:30.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:30.843]                             info)
[17:01:30.843]                           info <- base::paste(info, collapse = "; ")
[17:01:30.843]                           if (!has_future) {
[17:01:30.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:30.843]                               info)
[17:01:30.843]                           }
[17:01:30.843]                           else {
[17:01:30.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:30.843]                               info, version)
[17:01:30.843]                           }
[17:01:30.843]                           base::stop(msg)
[17:01:30.843]                         }
[17:01:30.843]                       })
[17:01:30.843]                     }
[17:01:30.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:30.843]                     base::options(mc.cores = 1L)
[17:01:30.843]                   }
[17:01:30.843]                   ...future.strategy.old <- future::plan("list")
[17:01:30.843]                   options(future.plan = NULL)
[17:01:30.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:30.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:30.843]                 }
[17:01:30.843]                 ...future.workdir <- getwd()
[17:01:30.843]             }
[17:01:30.843]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:30.843]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:30.843]         }
[17:01:30.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:30.843]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:30.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:30.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:30.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:30.843]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:30.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:30.843]             base::names(...future.oldOptions))
[17:01:30.843]     }
[17:01:30.843]     if (TRUE) {
[17:01:30.843]     }
[17:01:30.843]     else {
[17:01:30.843]         if (NA) {
[17:01:30.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:30.843]                 open = "w")
[17:01:30.843]         }
[17:01:30.843]         else {
[17:01:30.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:30.843]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:30.843]         }
[17:01:30.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:30.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:30.843]             base::sink(type = "output", split = FALSE)
[17:01:30.843]             base::close(...future.stdout)
[17:01:30.843]         }, add = TRUE)
[17:01:30.843]     }
[17:01:30.843]     ...future.frame <- base::sys.nframe()
[17:01:30.843]     ...future.conditions <- base::list()
[17:01:30.843]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:30.843]     if (FALSE) {
[17:01:30.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:30.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:30.843]     }
[17:01:30.843]     ...future.result <- base::tryCatch({
[17:01:30.843]         base::withCallingHandlers({
[17:01:30.843]             ...future.value <- base::withVisible(base::local({
[17:01:30.843]                 ...future.makeSendCondition <- base::local({
[17:01:30.843]                   sendCondition <- NULL
[17:01:30.843]                   function(frame = 1L) {
[17:01:30.843]                     if (is.function(sendCondition)) 
[17:01:30.843]                       return(sendCondition)
[17:01:30.843]                     ns <- getNamespace("parallel")
[17:01:30.843]                     if (exists("sendData", mode = "function", 
[17:01:30.843]                       envir = ns)) {
[17:01:30.843]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:30.843]                         envir = ns)
[17:01:30.843]                       envir <- sys.frame(frame)
[17:01:30.843]                       master <- NULL
[17:01:30.843]                       while (!identical(envir, .GlobalEnv) && 
[17:01:30.843]                         !identical(envir, emptyenv())) {
[17:01:30.843]                         if (exists("master", mode = "list", envir = envir, 
[17:01:30.843]                           inherits = FALSE)) {
[17:01:30.843]                           master <- get("master", mode = "list", 
[17:01:30.843]                             envir = envir, inherits = FALSE)
[17:01:30.843]                           if (inherits(master, c("SOCKnode", 
[17:01:30.843]                             "SOCK0node"))) {
[17:01:30.843]                             sendCondition <<- function(cond) {
[17:01:30.843]                               data <- list(type = "VALUE", value = cond, 
[17:01:30.843]                                 success = TRUE)
[17:01:30.843]                               parallel_sendData(master, data)
[17:01:30.843]                             }
[17:01:30.843]                             return(sendCondition)
[17:01:30.843]                           }
[17:01:30.843]                         }
[17:01:30.843]                         frame <- frame + 1L
[17:01:30.843]                         envir <- sys.frame(frame)
[17:01:30.843]                       }
[17:01:30.843]                     }
[17:01:30.843]                     sendCondition <<- function(cond) NULL
[17:01:30.843]                   }
[17:01:30.843]                 })
[17:01:30.843]                 withCallingHandlers({
[17:01:30.843]                   {
[17:01:30.843]                     do.call(function(...) {
[17:01:30.843]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.843]                       if (!identical(...future.globals.maxSize.org, 
[17:01:30.843]                         ...future.globals.maxSize)) {
[17:01:30.843]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.843]                         on.exit(options(oopts), add = TRUE)
[17:01:30.843]                       }
[17:01:30.843]                       {
[17:01:30.843]                         lapply(seq_along(...future.elements_ii), 
[17:01:30.843]                           FUN = function(jj) {
[17:01:30.843]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.843]                             ...future.FUN(...future.X_jj, ...)
[17:01:30.843]                           })
[17:01:30.843]                       }
[17:01:30.843]                     }, args = future.call.arguments)
[17:01:30.843]                   }
[17:01:30.843]                 }, immediateCondition = function(cond) {
[17:01:30.843]                   sendCondition <- ...future.makeSendCondition()
[17:01:30.843]                   sendCondition(cond)
[17:01:30.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.843]                   {
[17:01:30.843]                     inherits <- base::inherits
[17:01:30.843]                     invokeRestart <- base::invokeRestart
[17:01:30.843]                     is.null <- base::is.null
[17:01:30.843]                     muffled <- FALSE
[17:01:30.843]                     if (inherits(cond, "message")) {
[17:01:30.843]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:30.843]                       if (muffled) 
[17:01:30.843]                         invokeRestart("muffleMessage")
[17:01:30.843]                     }
[17:01:30.843]                     else if (inherits(cond, "warning")) {
[17:01:30.843]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:30.843]                       if (muffled) 
[17:01:30.843]                         invokeRestart("muffleWarning")
[17:01:30.843]                     }
[17:01:30.843]                     else if (inherits(cond, "condition")) {
[17:01:30.843]                       if (!is.null(pattern)) {
[17:01:30.843]                         computeRestarts <- base::computeRestarts
[17:01:30.843]                         grepl <- base::grepl
[17:01:30.843]                         restarts <- computeRestarts(cond)
[17:01:30.843]                         for (restart in restarts) {
[17:01:30.843]                           name <- restart$name
[17:01:30.843]                           if (is.null(name)) 
[17:01:30.843]                             next
[17:01:30.843]                           if (!grepl(pattern, name)) 
[17:01:30.843]                             next
[17:01:30.843]                           invokeRestart(restart)
[17:01:30.843]                           muffled <- TRUE
[17:01:30.843]                           break
[17:01:30.843]                         }
[17:01:30.843]                       }
[17:01:30.843]                     }
[17:01:30.843]                     invisible(muffled)
[17:01:30.843]                   }
[17:01:30.843]                   muffleCondition(cond)
[17:01:30.843]                 })
[17:01:30.843]             }))
[17:01:30.843]             future::FutureResult(value = ...future.value$value, 
[17:01:30.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:30.843]                   ...future.rng), globalenv = if (FALSE) 
[17:01:30.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:30.843]                     ...future.globalenv.names))
[17:01:30.843]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:30.843]         }, condition = base::local({
[17:01:30.843]             c <- base::c
[17:01:30.843]             inherits <- base::inherits
[17:01:30.843]             invokeRestart <- base::invokeRestart
[17:01:30.843]             length <- base::length
[17:01:30.843]             list <- base::list
[17:01:30.843]             seq.int <- base::seq.int
[17:01:30.843]             signalCondition <- base::signalCondition
[17:01:30.843]             sys.calls <- base::sys.calls
[17:01:30.843]             `[[` <- base::`[[`
[17:01:30.843]             `+` <- base::`+`
[17:01:30.843]             `<<-` <- base::`<<-`
[17:01:30.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:30.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:30.843]                   3L)]
[17:01:30.843]             }
[17:01:30.843]             function(cond) {
[17:01:30.843]                 is_error <- inherits(cond, "error")
[17:01:30.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:30.843]                   NULL)
[17:01:30.843]                 if (is_error) {
[17:01:30.843]                   sessionInformation <- function() {
[17:01:30.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:30.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:30.843]                       search = base::search(), system = base::Sys.info())
[17:01:30.843]                   }
[17:01:30.843]                   ...future.conditions[[length(...future.conditions) + 
[17:01:30.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:30.843]                     cond$call), session = sessionInformation(), 
[17:01:30.843]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:30.843]                   signalCondition(cond)
[17:01:30.843]                 }
[17:01:30.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:30.843]                 "immediateCondition"))) {
[17:01:30.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:30.843]                   ...future.conditions[[length(...future.conditions) + 
[17:01:30.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:30.843]                   if (TRUE && !signal) {
[17:01:30.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.843]                     {
[17:01:30.843]                       inherits <- base::inherits
[17:01:30.843]                       invokeRestart <- base::invokeRestart
[17:01:30.843]                       is.null <- base::is.null
[17:01:30.843]                       muffled <- FALSE
[17:01:30.843]                       if (inherits(cond, "message")) {
[17:01:30.843]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:30.843]                         if (muffled) 
[17:01:30.843]                           invokeRestart("muffleMessage")
[17:01:30.843]                       }
[17:01:30.843]                       else if (inherits(cond, "warning")) {
[17:01:30.843]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:30.843]                         if (muffled) 
[17:01:30.843]                           invokeRestart("muffleWarning")
[17:01:30.843]                       }
[17:01:30.843]                       else if (inherits(cond, "condition")) {
[17:01:30.843]                         if (!is.null(pattern)) {
[17:01:30.843]                           computeRestarts <- base::computeRestarts
[17:01:30.843]                           grepl <- base::grepl
[17:01:30.843]                           restarts <- computeRestarts(cond)
[17:01:30.843]                           for (restart in restarts) {
[17:01:30.843]                             name <- restart$name
[17:01:30.843]                             if (is.null(name)) 
[17:01:30.843]                               next
[17:01:30.843]                             if (!grepl(pattern, name)) 
[17:01:30.843]                               next
[17:01:30.843]                             invokeRestart(restart)
[17:01:30.843]                             muffled <- TRUE
[17:01:30.843]                             break
[17:01:30.843]                           }
[17:01:30.843]                         }
[17:01:30.843]                       }
[17:01:30.843]                       invisible(muffled)
[17:01:30.843]                     }
[17:01:30.843]                     muffleCondition(cond, pattern = "^muffle")
[17:01:30.843]                   }
[17:01:30.843]                 }
[17:01:30.843]                 else {
[17:01:30.843]                   if (TRUE) {
[17:01:30.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.843]                     {
[17:01:30.843]                       inherits <- base::inherits
[17:01:30.843]                       invokeRestart <- base::invokeRestart
[17:01:30.843]                       is.null <- base::is.null
[17:01:30.843]                       muffled <- FALSE
[17:01:30.843]                       if (inherits(cond, "message")) {
[17:01:30.843]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:30.843]                         if (muffled) 
[17:01:30.843]                           invokeRestart("muffleMessage")
[17:01:30.843]                       }
[17:01:30.843]                       else if (inherits(cond, "warning")) {
[17:01:30.843]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:30.843]                         if (muffled) 
[17:01:30.843]                           invokeRestart("muffleWarning")
[17:01:30.843]                       }
[17:01:30.843]                       else if (inherits(cond, "condition")) {
[17:01:30.843]                         if (!is.null(pattern)) {
[17:01:30.843]                           computeRestarts <- base::computeRestarts
[17:01:30.843]                           grepl <- base::grepl
[17:01:30.843]                           restarts <- computeRestarts(cond)
[17:01:30.843]                           for (restart in restarts) {
[17:01:30.843]                             name <- restart$name
[17:01:30.843]                             if (is.null(name)) 
[17:01:30.843]                               next
[17:01:30.843]                             if (!grepl(pattern, name)) 
[17:01:30.843]                               next
[17:01:30.843]                             invokeRestart(restart)
[17:01:30.843]                             muffled <- TRUE
[17:01:30.843]                             break
[17:01:30.843]                           }
[17:01:30.843]                         }
[17:01:30.843]                       }
[17:01:30.843]                       invisible(muffled)
[17:01:30.843]                     }
[17:01:30.843]                     muffleCondition(cond, pattern = "^muffle")
[17:01:30.843]                   }
[17:01:30.843]                 }
[17:01:30.843]             }
[17:01:30.843]         }))
[17:01:30.843]     }, error = function(ex) {
[17:01:30.843]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:30.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:30.843]                 ...future.rng), started = ...future.startTime, 
[17:01:30.843]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:30.843]             version = "1.8"), class = "FutureResult")
[17:01:30.843]     }, finally = {
[17:01:30.843]         if (!identical(...future.workdir, getwd())) 
[17:01:30.843]             setwd(...future.workdir)
[17:01:30.843]         {
[17:01:30.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:30.843]                 ...future.oldOptions$nwarnings <- NULL
[17:01:30.843]             }
[17:01:30.843]             base::options(...future.oldOptions)
[17:01:30.843]             if (.Platform$OS.type == "windows") {
[17:01:30.843]                 old_names <- names(...future.oldEnvVars)
[17:01:30.843]                 envs <- base::Sys.getenv()
[17:01:30.843]                 names <- names(envs)
[17:01:30.843]                 common <- intersect(names, old_names)
[17:01:30.843]                 added <- setdiff(names, old_names)
[17:01:30.843]                 removed <- setdiff(old_names, names)
[17:01:30.843]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:30.843]                   envs[common]]
[17:01:30.843]                 NAMES <- toupper(changed)
[17:01:30.843]                 args <- list()
[17:01:30.843]                 for (kk in seq_along(NAMES)) {
[17:01:30.843]                   name <- changed[[kk]]
[17:01:30.843]                   NAME <- NAMES[[kk]]
[17:01:30.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.843]                     next
[17:01:30.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:30.843]                 }
[17:01:30.843]                 NAMES <- toupper(added)
[17:01:30.843]                 for (kk in seq_along(NAMES)) {
[17:01:30.843]                   name <- added[[kk]]
[17:01:30.843]                   NAME <- NAMES[[kk]]
[17:01:30.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.843]                     next
[17:01:30.843]                   args[[name]] <- ""
[17:01:30.843]                 }
[17:01:30.843]                 NAMES <- toupper(removed)
[17:01:30.843]                 for (kk in seq_along(NAMES)) {
[17:01:30.843]                   name <- removed[[kk]]
[17:01:30.843]                   NAME <- NAMES[[kk]]
[17:01:30.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.843]                     next
[17:01:30.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:30.843]                 }
[17:01:30.843]                 if (length(args) > 0) 
[17:01:30.843]                   base::do.call(base::Sys.setenv, args = args)
[17:01:30.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:30.843]             }
[17:01:30.843]             else {
[17:01:30.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:30.843]             }
[17:01:30.843]             {
[17:01:30.843]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:30.843]                   0L) {
[17:01:30.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:30.843]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:30.843]                   base::options(opts)
[17:01:30.843]                 }
[17:01:30.843]                 {
[17:01:30.843]                   {
[17:01:30.843]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:30.843]                     NULL
[17:01:30.843]                   }
[17:01:30.843]                   options(future.plan = NULL)
[17:01:30.843]                   if (is.na(NA_character_)) 
[17:01:30.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:30.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:30.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:30.843]                     .init = FALSE)
[17:01:30.843]                 }
[17:01:30.843]             }
[17:01:30.843]         }
[17:01:30.843]     })
[17:01:30.843]     if (FALSE) {
[17:01:30.843]         base::sink(type = "output", split = FALSE)
[17:01:30.843]         if (NA) {
[17:01:30.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:30.843]         }
[17:01:30.843]         else {
[17:01:30.843]             ...future.result["stdout"] <- base::list(NULL)
[17:01:30.843]         }
[17:01:30.843]         base::close(...future.stdout)
[17:01:30.843]         ...future.stdout <- NULL
[17:01:30.843]     }
[17:01:30.843]     ...future.result$conditions <- ...future.conditions
[17:01:30.843]     ...future.result$finished <- base::Sys.time()
[17:01:30.843]     ...future.result
[17:01:30.843] }
[17:01:30.846] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:01:30.846] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:01:30.846] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:01:30.846] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:30.847] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:30.847] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:01:30.847] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:01:30.848] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:30.848] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:30.848] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:30.848] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:30.848] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:01:30.849] MultisessionFuture started
[17:01:30.849] - Launch lazy future ... done
[17:01:30.849] run() for ‘MultisessionFuture’ ... done
[17:01:30.850] Created future:
[17:01:30.850] MultisessionFuture:
[17:01:30.850] Label: ‘future_lapply-1’
[17:01:30.850] Expression:
[17:01:30.850] {
[17:01:30.850]     do.call(function(...) {
[17:01:30.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:30.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.850]             on.exit(options(oopts), add = TRUE)
[17:01:30.850]         }
[17:01:30.850]         {
[17:01:30.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:30.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.850]                 ...future.FUN(...future.X_jj, ...)
[17:01:30.850]             })
[17:01:30.850]         }
[17:01:30.850]     }, args = future.call.arguments)
[17:01:30.850] }
[17:01:30.850] Lazy evaluation: FALSE
[17:01:30.850] Asynchronous evaluation: TRUE
[17:01:30.850] Local evaluation: TRUE
[17:01:30.850] Environment: R_GlobalEnv
[17:01:30.850] Capture standard output: NA
[17:01:30.850] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:30.850] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:30.850] Packages: <none>
[17:01:30.850] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:30.850] Resolved: FALSE
[17:01:30.850] Value: <not collected>
[17:01:30.850] Conditions captured: <none>
[17:01:30.850] Early signaling: FALSE
[17:01:30.850] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:30.850] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:30.861] Chunk #1 of 2 ... DONE
[17:01:30.861] Chunk #2 of 2 ...
[17:01:30.861]  - Finding globals in 'X' for chunk #2 ...
[17:01:30.862] getGlobalsAndPackages() ...
[17:01:30.862] Searching for globals...
[17:01:30.862] 
[17:01:30.862] Searching for globals ... DONE
[17:01:30.862] - globals: [0] <none>
[17:01:30.862] getGlobalsAndPackages() ... DONE
[17:01:30.862]    + additional globals found: [n=0] 
[17:01:30.862]    + additional namespaces needed: [n=0] 
[17:01:30.863]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:30.863]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:30.863]  - seeds: <none>
[17:01:30.863]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.863] getGlobalsAndPackages() ...
[17:01:30.863] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.863] Resolving globals: FALSE
[17:01:30.863] Tweak future expression to call with '...' arguments ...
[17:01:30.863] {
[17:01:30.863]     do.call(function(...) {
[17:01:30.863]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.863]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:30.863]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.863]             on.exit(options(oopts), add = TRUE)
[17:01:30.863]         }
[17:01:30.863]         {
[17:01:30.863]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:30.863]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.863]                 ...future.FUN(...future.X_jj, ...)
[17:01:30.863]             })
[17:01:30.863]         }
[17:01:30.863]     }, args = future.call.arguments)
[17:01:30.863] }
[17:01:30.864] Tweak future expression to call with '...' arguments ... DONE
[17:01:30.864] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:30.864] 
[17:01:30.864] getGlobalsAndPackages() ... DONE
[17:01:30.865] run() for ‘Future’ ...
[17:01:30.865] - state: ‘created’
[17:01:30.865] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:30.879] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:30.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:30.879]   - Field: ‘node’
[17:01:30.880]   - Field: ‘label’
[17:01:30.880]   - Field: ‘local’
[17:01:30.880]   - Field: ‘owner’
[17:01:30.880]   - Field: ‘envir’
[17:01:30.880]   - Field: ‘workers’
[17:01:30.880]   - Field: ‘packages’
[17:01:30.880]   - Field: ‘gc’
[17:01:30.880]   - Field: ‘conditions’
[17:01:30.880]   - Field: ‘persistent’
[17:01:30.880]   - Field: ‘expr’
[17:01:30.880]   - Field: ‘uuid’
[17:01:30.881]   - Field: ‘seed’
[17:01:30.881]   - Field: ‘version’
[17:01:30.881]   - Field: ‘result’
[17:01:30.881]   - Field: ‘asynchronous’
[17:01:30.881]   - Field: ‘calls’
[17:01:30.881]   - Field: ‘globals’
[17:01:30.881]   - Field: ‘stdout’
[17:01:30.881]   - Field: ‘earlySignal’
[17:01:30.881]   - Field: ‘lazy’
[17:01:30.881]   - Field: ‘state’
[17:01:30.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:30.882] - Launch lazy future ...
[17:01:30.882] Packages needed by the future expression (n = 0): <none>
[17:01:30.882] Packages needed by future strategies (n = 0): <none>
[17:01:30.882] {
[17:01:30.882]     {
[17:01:30.882]         {
[17:01:30.882]             ...future.startTime <- base::Sys.time()
[17:01:30.882]             {
[17:01:30.882]                 {
[17:01:30.882]                   {
[17:01:30.882]                     {
[17:01:30.882]                       base::local({
[17:01:30.882]                         has_future <- base::requireNamespace("future", 
[17:01:30.882]                           quietly = TRUE)
[17:01:30.882]                         if (has_future) {
[17:01:30.882]                           ns <- base::getNamespace("future")
[17:01:30.882]                           version <- ns[[".package"]][["version"]]
[17:01:30.882]                           if (is.null(version)) 
[17:01:30.882]                             version <- utils::packageVersion("future")
[17:01:30.882]                         }
[17:01:30.882]                         else {
[17:01:30.882]                           version <- NULL
[17:01:30.882]                         }
[17:01:30.882]                         if (!has_future || version < "1.8.0") {
[17:01:30.882]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:30.882]                             "", base::R.version$version.string), 
[17:01:30.882]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:30.882]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:30.882]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:30.882]                               "release", "version")], collapse = " "), 
[17:01:30.882]                             hostname = base::Sys.info()[["nodename"]])
[17:01:30.882]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:30.882]                             info)
[17:01:30.882]                           info <- base::paste(info, collapse = "; ")
[17:01:30.882]                           if (!has_future) {
[17:01:30.882]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:30.882]                               info)
[17:01:30.882]                           }
[17:01:30.882]                           else {
[17:01:30.882]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:30.882]                               info, version)
[17:01:30.882]                           }
[17:01:30.882]                           base::stop(msg)
[17:01:30.882]                         }
[17:01:30.882]                       })
[17:01:30.882]                     }
[17:01:30.882]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:30.882]                     base::options(mc.cores = 1L)
[17:01:30.882]                   }
[17:01:30.882]                   ...future.strategy.old <- future::plan("list")
[17:01:30.882]                   options(future.plan = NULL)
[17:01:30.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:30.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:30.882]                 }
[17:01:30.882]                 ...future.workdir <- getwd()
[17:01:30.882]             }
[17:01:30.882]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:30.882]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:30.882]         }
[17:01:30.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:30.882]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:30.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:30.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:30.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:30.882]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:30.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:30.882]             base::names(...future.oldOptions))
[17:01:30.882]     }
[17:01:30.882]     if (TRUE) {
[17:01:30.882]     }
[17:01:30.882]     else {
[17:01:30.882]         if (NA) {
[17:01:30.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:30.882]                 open = "w")
[17:01:30.882]         }
[17:01:30.882]         else {
[17:01:30.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:30.882]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:30.882]         }
[17:01:30.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:30.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:30.882]             base::sink(type = "output", split = FALSE)
[17:01:30.882]             base::close(...future.stdout)
[17:01:30.882]         }, add = TRUE)
[17:01:30.882]     }
[17:01:30.882]     ...future.frame <- base::sys.nframe()
[17:01:30.882]     ...future.conditions <- base::list()
[17:01:30.882]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:30.882]     if (FALSE) {
[17:01:30.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:30.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:30.882]     }
[17:01:30.882]     ...future.result <- base::tryCatch({
[17:01:30.882]         base::withCallingHandlers({
[17:01:30.882]             ...future.value <- base::withVisible(base::local({
[17:01:30.882]                 ...future.makeSendCondition <- base::local({
[17:01:30.882]                   sendCondition <- NULL
[17:01:30.882]                   function(frame = 1L) {
[17:01:30.882]                     if (is.function(sendCondition)) 
[17:01:30.882]                       return(sendCondition)
[17:01:30.882]                     ns <- getNamespace("parallel")
[17:01:30.882]                     if (exists("sendData", mode = "function", 
[17:01:30.882]                       envir = ns)) {
[17:01:30.882]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:30.882]                         envir = ns)
[17:01:30.882]                       envir <- sys.frame(frame)
[17:01:30.882]                       master <- NULL
[17:01:30.882]                       while (!identical(envir, .GlobalEnv) && 
[17:01:30.882]                         !identical(envir, emptyenv())) {
[17:01:30.882]                         if (exists("master", mode = "list", envir = envir, 
[17:01:30.882]                           inherits = FALSE)) {
[17:01:30.882]                           master <- get("master", mode = "list", 
[17:01:30.882]                             envir = envir, inherits = FALSE)
[17:01:30.882]                           if (inherits(master, c("SOCKnode", 
[17:01:30.882]                             "SOCK0node"))) {
[17:01:30.882]                             sendCondition <<- function(cond) {
[17:01:30.882]                               data <- list(type = "VALUE", value = cond, 
[17:01:30.882]                                 success = TRUE)
[17:01:30.882]                               parallel_sendData(master, data)
[17:01:30.882]                             }
[17:01:30.882]                             return(sendCondition)
[17:01:30.882]                           }
[17:01:30.882]                         }
[17:01:30.882]                         frame <- frame + 1L
[17:01:30.882]                         envir <- sys.frame(frame)
[17:01:30.882]                       }
[17:01:30.882]                     }
[17:01:30.882]                     sendCondition <<- function(cond) NULL
[17:01:30.882]                   }
[17:01:30.882]                 })
[17:01:30.882]                 withCallingHandlers({
[17:01:30.882]                   {
[17:01:30.882]                     do.call(function(...) {
[17:01:30.882]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.882]                       if (!identical(...future.globals.maxSize.org, 
[17:01:30.882]                         ...future.globals.maxSize)) {
[17:01:30.882]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.882]                         on.exit(options(oopts), add = TRUE)
[17:01:30.882]                       }
[17:01:30.882]                       {
[17:01:30.882]                         lapply(seq_along(...future.elements_ii), 
[17:01:30.882]                           FUN = function(jj) {
[17:01:30.882]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.882]                             ...future.FUN(...future.X_jj, ...)
[17:01:30.882]                           })
[17:01:30.882]                       }
[17:01:30.882]                     }, args = future.call.arguments)
[17:01:30.882]                   }
[17:01:30.882]                 }, immediateCondition = function(cond) {
[17:01:30.882]                   sendCondition <- ...future.makeSendCondition()
[17:01:30.882]                   sendCondition(cond)
[17:01:30.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.882]                   {
[17:01:30.882]                     inherits <- base::inherits
[17:01:30.882]                     invokeRestart <- base::invokeRestart
[17:01:30.882]                     is.null <- base::is.null
[17:01:30.882]                     muffled <- FALSE
[17:01:30.882]                     if (inherits(cond, "message")) {
[17:01:30.882]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:30.882]                       if (muffled) 
[17:01:30.882]                         invokeRestart("muffleMessage")
[17:01:30.882]                     }
[17:01:30.882]                     else if (inherits(cond, "warning")) {
[17:01:30.882]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:30.882]                       if (muffled) 
[17:01:30.882]                         invokeRestart("muffleWarning")
[17:01:30.882]                     }
[17:01:30.882]                     else if (inherits(cond, "condition")) {
[17:01:30.882]                       if (!is.null(pattern)) {
[17:01:30.882]                         computeRestarts <- base::computeRestarts
[17:01:30.882]                         grepl <- base::grepl
[17:01:30.882]                         restarts <- computeRestarts(cond)
[17:01:30.882]                         for (restart in restarts) {
[17:01:30.882]                           name <- restart$name
[17:01:30.882]                           if (is.null(name)) 
[17:01:30.882]                             next
[17:01:30.882]                           if (!grepl(pattern, name)) 
[17:01:30.882]                             next
[17:01:30.882]                           invokeRestart(restart)
[17:01:30.882]                           muffled <- TRUE
[17:01:30.882]                           break
[17:01:30.882]                         }
[17:01:30.882]                       }
[17:01:30.882]                     }
[17:01:30.882]                     invisible(muffled)
[17:01:30.882]                   }
[17:01:30.882]                   muffleCondition(cond)
[17:01:30.882]                 })
[17:01:30.882]             }))
[17:01:30.882]             future::FutureResult(value = ...future.value$value, 
[17:01:30.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:30.882]                   ...future.rng), globalenv = if (FALSE) 
[17:01:30.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:30.882]                     ...future.globalenv.names))
[17:01:30.882]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:30.882]         }, condition = base::local({
[17:01:30.882]             c <- base::c
[17:01:30.882]             inherits <- base::inherits
[17:01:30.882]             invokeRestart <- base::invokeRestart
[17:01:30.882]             length <- base::length
[17:01:30.882]             list <- base::list
[17:01:30.882]             seq.int <- base::seq.int
[17:01:30.882]             signalCondition <- base::signalCondition
[17:01:30.882]             sys.calls <- base::sys.calls
[17:01:30.882]             `[[` <- base::`[[`
[17:01:30.882]             `+` <- base::`+`
[17:01:30.882]             `<<-` <- base::`<<-`
[17:01:30.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:30.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:30.882]                   3L)]
[17:01:30.882]             }
[17:01:30.882]             function(cond) {
[17:01:30.882]                 is_error <- inherits(cond, "error")
[17:01:30.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:30.882]                   NULL)
[17:01:30.882]                 if (is_error) {
[17:01:30.882]                   sessionInformation <- function() {
[17:01:30.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:30.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:30.882]                       search = base::search(), system = base::Sys.info())
[17:01:30.882]                   }
[17:01:30.882]                   ...future.conditions[[length(...future.conditions) + 
[17:01:30.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:30.882]                     cond$call), session = sessionInformation(), 
[17:01:30.882]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:30.882]                   signalCondition(cond)
[17:01:30.882]                 }
[17:01:30.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:30.882]                 "immediateCondition"))) {
[17:01:30.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:30.882]                   ...future.conditions[[length(...future.conditions) + 
[17:01:30.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:30.882]                   if (TRUE && !signal) {
[17:01:30.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.882]                     {
[17:01:30.882]                       inherits <- base::inherits
[17:01:30.882]                       invokeRestart <- base::invokeRestart
[17:01:30.882]                       is.null <- base::is.null
[17:01:30.882]                       muffled <- FALSE
[17:01:30.882]                       if (inherits(cond, "message")) {
[17:01:30.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:30.882]                         if (muffled) 
[17:01:30.882]                           invokeRestart("muffleMessage")
[17:01:30.882]                       }
[17:01:30.882]                       else if (inherits(cond, "warning")) {
[17:01:30.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:30.882]                         if (muffled) 
[17:01:30.882]                           invokeRestart("muffleWarning")
[17:01:30.882]                       }
[17:01:30.882]                       else if (inherits(cond, "condition")) {
[17:01:30.882]                         if (!is.null(pattern)) {
[17:01:30.882]                           computeRestarts <- base::computeRestarts
[17:01:30.882]                           grepl <- base::grepl
[17:01:30.882]                           restarts <- computeRestarts(cond)
[17:01:30.882]                           for (restart in restarts) {
[17:01:30.882]                             name <- restart$name
[17:01:30.882]                             if (is.null(name)) 
[17:01:30.882]                               next
[17:01:30.882]                             if (!grepl(pattern, name)) 
[17:01:30.882]                               next
[17:01:30.882]                             invokeRestart(restart)
[17:01:30.882]                             muffled <- TRUE
[17:01:30.882]                             break
[17:01:30.882]                           }
[17:01:30.882]                         }
[17:01:30.882]                       }
[17:01:30.882]                       invisible(muffled)
[17:01:30.882]                     }
[17:01:30.882]                     muffleCondition(cond, pattern = "^muffle")
[17:01:30.882]                   }
[17:01:30.882]                 }
[17:01:30.882]                 else {
[17:01:30.882]                   if (TRUE) {
[17:01:30.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:30.882]                     {
[17:01:30.882]                       inherits <- base::inherits
[17:01:30.882]                       invokeRestart <- base::invokeRestart
[17:01:30.882]                       is.null <- base::is.null
[17:01:30.882]                       muffled <- FALSE
[17:01:30.882]                       if (inherits(cond, "message")) {
[17:01:30.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:30.882]                         if (muffled) 
[17:01:30.882]                           invokeRestart("muffleMessage")
[17:01:30.882]                       }
[17:01:30.882]                       else if (inherits(cond, "warning")) {
[17:01:30.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:30.882]                         if (muffled) 
[17:01:30.882]                           invokeRestart("muffleWarning")
[17:01:30.882]                       }
[17:01:30.882]                       else if (inherits(cond, "condition")) {
[17:01:30.882]                         if (!is.null(pattern)) {
[17:01:30.882]                           computeRestarts <- base::computeRestarts
[17:01:30.882]                           grepl <- base::grepl
[17:01:30.882]                           restarts <- computeRestarts(cond)
[17:01:30.882]                           for (restart in restarts) {
[17:01:30.882]                             name <- restart$name
[17:01:30.882]                             if (is.null(name)) 
[17:01:30.882]                               next
[17:01:30.882]                             if (!grepl(pattern, name)) 
[17:01:30.882]                               next
[17:01:30.882]                             invokeRestart(restart)
[17:01:30.882]                             muffled <- TRUE
[17:01:30.882]                             break
[17:01:30.882]                           }
[17:01:30.882]                         }
[17:01:30.882]                       }
[17:01:30.882]                       invisible(muffled)
[17:01:30.882]                     }
[17:01:30.882]                     muffleCondition(cond, pattern = "^muffle")
[17:01:30.882]                   }
[17:01:30.882]                 }
[17:01:30.882]             }
[17:01:30.882]         }))
[17:01:30.882]     }, error = function(ex) {
[17:01:30.882]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:30.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:30.882]                 ...future.rng), started = ...future.startTime, 
[17:01:30.882]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:30.882]             version = "1.8"), class = "FutureResult")
[17:01:30.882]     }, finally = {
[17:01:30.882]         if (!identical(...future.workdir, getwd())) 
[17:01:30.882]             setwd(...future.workdir)
[17:01:30.882]         {
[17:01:30.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:30.882]                 ...future.oldOptions$nwarnings <- NULL
[17:01:30.882]             }
[17:01:30.882]             base::options(...future.oldOptions)
[17:01:30.882]             if (.Platform$OS.type == "windows") {
[17:01:30.882]                 old_names <- names(...future.oldEnvVars)
[17:01:30.882]                 envs <- base::Sys.getenv()
[17:01:30.882]                 names <- names(envs)
[17:01:30.882]                 common <- intersect(names, old_names)
[17:01:30.882]                 added <- setdiff(names, old_names)
[17:01:30.882]                 removed <- setdiff(old_names, names)
[17:01:30.882]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:30.882]                   envs[common]]
[17:01:30.882]                 NAMES <- toupper(changed)
[17:01:30.882]                 args <- list()
[17:01:30.882]                 for (kk in seq_along(NAMES)) {
[17:01:30.882]                   name <- changed[[kk]]
[17:01:30.882]                   NAME <- NAMES[[kk]]
[17:01:30.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.882]                     next
[17:01:30.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:30.882]                 }
[17:01:30.882]                 NAMES <- toupper(added)
[17:01:30.882]                 for (kk in seq_along(NAMES)) {
[17:01:30.882]                   name <- added[[kk]]
[17:01:30.882]                   NAME <- NAMES[[kk]]
[17:01:30.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.882]                     next
[17:01:30.882]                   args[[name]] <- ""
[17:01:30.882]                 }
[17:01:30.882]                 NAMES <- toupper(removed)
[17:01:30.882]                 for (kk in seq_along(NAMES)) {
[17:01:30.882]                   name <- removed[[kk]]
[17:01:30.882]                   NAME <- NAMES[[kk]]
[17:01:30.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:30.882]                     next
[17:01:30.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:30.882]                 }
[17:01:30.882]                 if (length(args) > 0) 
[17:01:30.882]                   base::do.call(base::Sys.setenv, args = args)
[17:01:30.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:30.882]             }
[17:01:30.882]             else {
[17:01:30.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:30.882]             }
[17:01:30.882]             {
[17:01:30.882]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:30.882]                   0L) {
[17:01:30.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:30.882]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:30.882]                   base::options(opts)
[17:01:30.882]                 }
[17:01:30.882]                 {
[17:01:30.882]                   {
[17:01:30.882]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:30.882]                     NULL
[17:01:30.882]                   }
[17:01:30.882]                   options(future.plan = NULL)
[17:01:30.882]                   if (is.na(NA_character_)) 
[17:01:30.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:30.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:30.882]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:30.882]                     .init = FALSE)
[17:01:30.882]                 }
[17:01:30.882]             }
[17:01:30.882]         }
[17:01:30.882]     })
[17:01:30.882]     if (FALSE) {
[17:01:30.882]         base::sink(type = "output", split = FALSE)
[17:01:30.882]         if (NA) {
[17:01:30.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:30.882]         }
[17:01:30.882]         else {
[17:01:30.882]             ...future.result["stdout"] <- base::list(NULL)
[17:01:30.882]         }
[17:01:30.882]         base::close(...future.stdout)
[17:01:30.882]         ...future.stdout <- NULL
[17:01:30.882]     }
[17:01:30.882]     ...future.result$conditions <- ...future.conditions
[17:01:30.882]     ...future.result$finished <- base::Sys.time()
[17:01:30.882]     ...future.result
[17:01:30.882] }
[17:01:30.885] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:01:30.885] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:01:30.886] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:01:30.886] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:30.889] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:30.890] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:01:30.890] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:01:30.890] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:30.890] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:30.890] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:30.891] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:30.891] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:01:30.891] MultisessionFuture started
[17:01:30.892] - Launch lazy future ... done
[17:01:30.892] run() for ‘MultisessionFuture’ ... done
[17:01:30.892] Created future:
[17:01:30.892] MultisessionFuture:
[17:01:30.892] Label: ‘future_lapply-2’
[17:01:30.892] Expression:
[17:01:30.892] {
[17:01:30.892]     do.call(function(...) {
[17:01:30.892]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:30.892]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:30.892]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:30.892]             on.exit(options(oopts), add = TRUE)
[17:01:30.892]         }
[17:01:30.892]         {
[17:01:30.892]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:30.892]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:30.892]                 ...future.FUN(...future.X_jj, ...)
[17:01:30.892]             })
[17:01:30.892]         }
[17:01:30.892]     }, args = future.call.arguments)
[17:01:30.892] }
[17:01:30.892] Lazy evaluation: FALSE
[17:01:30.892] Asynchronous evaluation: TRUE
[17:01:30.892] Local evaluation: TRUE
[17:01:30.892] Environment: R_GlobalEnv
[17:01:30.892] Capture standard output: NA
[17:01:30.892] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:30.892] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:30.892] Packages: <none>
[17:01:30.892] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:30.892] Resolved: FALSE
[17:01:30.892] Value: <not collected>
[17:01:30.892] Conditions captured: <none>
[17:01:30.892] Early signaling: FALSE
[17:01:30.892] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:30.892] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:30.904] Chunk #2 of 2 ... DONE
[17:01:30.904] Launching 2 futures (chunks) ... DONE
[17:01:30.904] Resolving 2 futures (chunks) ...
[17:01:30.904] resolve() on list ...
[17:01:30.904]  recursive: 0
[17:01:30.904]  length: 2
[17:01:30.904] 
[17:01:30.947] receiveMessageFromWorker() for ClusterFuture ...
[17:01:30.947] - Validating connection of MultisessionFuture
[17:01:30.947] - received message: FutureResult
[17:01:30.947] - Received FutureResult
[17:01:30.947] - Erased future from FutureRegistry
[17:01:30.948] result() for ClusterFuture ...
[17:01:30.948] - result already collected: FutureResult
[17:01:30.948] result() for ClusterFuture ... done
[17:01:30.948] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:30.948] Future #2
[17:01:30.948] result() for ClusterFuture ...
[17:01:30.948] - result already collected: FutureResult
[17:01:30.948] result() for ClusterFuture ... done
[17:01:30.948] result() for ClusterFuture ...
[17:01:30.948] - result already collected: FutureResult
[17:01:30.948] result() for ClusterFuture ... done
[17:01:30.949] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:30.949] - nx: 2
[17:01:30.949] - relay: TRUE
[17:01:30.949] - stdout: TRUE
[17:01:30.949] - signal: TRUE
[17:01:30.949] - resignal: FALSE
[17:01:30.949] - force: TRUE
[17:01:30.949] - relayed: [n=2] FALSE, FALSE
[17:01:30.949] - queued futures: [n=2] FALSE, FALSE
[17:01:30.949]  - until=1
[17:01:30.949]  - relaying element #1
[17:01:30.949] - relayed: [n=2] FALSE, FALSE
[17:01:30.950] - queued futures: [n=2] FALSE, TRUE
[17:01:30.950] signalConditionsASAP(NULL, pos=2) ... done
[17:01:30.950]  length: 1 (resolved future 2)
[17:01:31.397] receiveMessageFromWorker() for ClusterFuture ...
[17:01:31.398] - Validating connection of MultisessionFuture
[17:01:31.398] - received message: FutureResult
[17:01:31.398] - Received FutureResult
[17:01:31.398] - Erased future from FutureRegistry
[17:01:31.398] result() for ClusterFuture ...
[17:01:31.398] - result already collected: FutureResult
[17:01:31.398] result() for ClusterFuture ... done
[17:01:31.398] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:31.399] Future #1
[17:01:31.399] result() for ClusterFuture ...
[17:01:31.399] - result already collected: FutureResult
[17:01:31.399] result() for ClusterFuture ... done
[17:01:31.399] result() for ClusterFuture ...
[17:01:31.399] - result already collected: FutureResult
[17:01:31.399] result() for ClusterFuture ... done
[17:01:31.399] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:31.399] - nx: 2
[17:01:31.399] - relay: TRUE
[17:01:31.400] - stdout: TRUE
[17:01:31.400] - signal: TRUE
[17:01:31.400] - resignal: FALSE
[17:01:31.400] - force: TRUE
[17:01:31.400] - relayed: [n=2] FALSE, FALSE
[17:01:31.400] - queued futures: [n=2] FALSE, TRUE
[17:01:31.400]  - until=1
[17:01:31.400]  - relaying element #1
[17:01:31.400] result() for ClusterFuture ...
[17:01:31.400] - result already collected: FutureResult
[17:01:31.400] result() for ClusterFuture ... done
[17:01:31.400] result() for ClusterFuture ...
[17:01:31.401] - result already collected: FutureResult
[17:01:31.401] result() for ClusterFuture ... done
[17:01:31.401] result() for ClusterFuture ...
[17:01:31.401] - result already collected: FutureResult
[17:01:31.401] result() for ClusterFuture ... done
[17:01:31.401] result() for ClusterFuture ...
[17:01:31.401] - result already collected: FutureResult
[17:01:31.401] result() for ClusterFuture ... done
[17:01:31.401] - relayed: [n=2] TRUE, FALSE
[17:01:31.401] - queued futures: [n=2] TRUE, TRUE
[17:01:31.401] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:31.402]  length: 0 (resolved future 1)
[17:01:31.402] Relaying remaining futures
[17:01:31.402] signalConditionsASAP(NULL, pos=0) ...
[17:01:31.402] - nx: 2
[17:01:31.402] - relay: TRUE
[17:01:31.402] - stdout: TRUE
[17:01:31.402] - signal: TRUE
[17:01:31.402] - resignal: FALSE
[17:01:31.402] - force: TRUE
[17:01:31.402] - relayed: [n=2] TRUE, FALSE
[17:01:31.402] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:31.403]  - relaying element #2
[17:01:31.403] result() for ClusterFuture ...
[17:01:31.403] - result already collected: FutureResult
[17:01:31.403] result() for ClusterFuture ... done
[17:01:31.403] result() for ClusterFuture ...
[17:01:31.403] - result already collected: FutureResult
[17:01:31.403] result() for ClusterFuture ... done
[17:01:31.403] result() for ClusterFuture ...
[17:01:31.403] - result already collected: FutureResult
[17:01:31.403] result() for ClusterFuture ... done
[17:01:31.403] result() for ClusterFuture ...
[17:01:31.404] - result already collected: FutureResult
[17:01:31.404] result() for ClusterFuture ... done
[17:01:31.404] - relayed: [n=2] TRUE, TRUE
[17:01:31.404] - queued futures: [n=2] TRUE, TRUE
[17:01:31.404] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:01:31.404] resolve() on list ... DONE
[17:01:31.404] result() for ClusterFuture ...
[17:01:31.404] - result already collected: FutureResult
[17:01:31.404] result() for ClusterFuture ... done
[17:01:31.404] result() for ClusterFuture ...
[17:01:31.404] - result already collected: FutureResult
[17:01:31.404] result() for ClusterFuture ... done
[17:01:31.405] result() for ClusterFuture ...
[17:01:31.405] - result already collected: FutureResult
[17:01:31.405] result() for ClusterFuture ... done
[17:01:31.405] result() for ClusterFuture ...
[17:01:31.405] - result already collected: FutureResult
[17:01:31.405] result() for ClusterFuture ... done
[17:01:31.405]  - Number of value chunks collected: 2
[17:01:31.405] Resolving 2 futures (chunks) ... DONE
[17:01:31.405] Reducing values from 2 chunks ...
[17:01:31.405]  - Number of values collected after concatenation: 2
[17:01:31.405]  - Number of values expected: 2
[17:01:31.406] Reducing values from 2 chunks ... DONE
[17:01:31.406] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:01:31.406] future_mapply() ...
[17:01:31.410] Number of chunks: 2
[17:01:31.410] getGlobalsAndPackagesXApply() ...
[17:01:31.410]  - future.globals: TRUE
[17:01:31.410] getGlobalsAndPackages() ...
[17:01:31.410] Searching for globals...
[17:01:31.412] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:31.412] Searching for globals ... DONE
[17:01:31.412] Resolving globals: FALSE
[17:01:31.412] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:31.413] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:31.413] - globals: [1] ‘FUN’
[17:01:31.413] 
[17:01:31.413] getGlobalsAndPackages() ... DONE
[17:01:31.413]  - globals found/used: [n=1] ‘FUN’
[17:01:31.413]  - needed namespaces: [n=0] 
[17:01:31.413] Finding globals ... DONE
[17:01:31.414] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:31.414] List of 2
[17:01:31.414]  $ ...future.FUN:function (x, y)  
[17:01:31.414]  $ MoreArgs     : NULL
[17:01:31.414]  - attr(*, "where")=List of 2
[17:01:31.414]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:31.414]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:31.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:31.414]  - attr(*, "resolved")= logi FALSE
[17:01:31.414]  - attr(*, "total_size")= num NA
[17:01:31.416] Packages to be attached in all futures: [n=0] 
[17:01:31.416] getGlobalsAndPackagesXApply() ... DONE
[17:01:31.416] Number of futures (= number of chunks): 2
[17:01:31.417] Launching 2 futures (chunks) ...
[17:01:31.417] Chunk #1 of 2 ...
[17:01:31.417]  - Finding globals in '...' for chunk #1 ...
[17:01:31.417] getGlobalsAndPackages() ...
[17:01:31.417] Searching for globals...
[17:01:31.417] 
[17:01:31.417] Searching for globals ... DONE
[17:01:31.417] - globals: [0] <none>
[17:01:31.418] getGlobalsAndPackages() ... DONE
[17:01:31.418]    + additional globals found: [n=0] 
[17:01:31.418]    + additional namespaces needed: [n=0] 
[17:01:31.418]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:31.418]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:31.418]  - seeds: <none>
[17:01:31.418]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:31.418] getGlobalsAndPackages() ...
[17:01:31.418] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:31.418] Resolving globals: FALSE
[17:01:31.419] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:31.419] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:31.421] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:31.421] 
[17:01:31.422] getGlobalsAndPackages() ... DONE
[17:01:31.422] run() for ‘Future’ ...
[17:01:31.422] - state: ‘created’
[17:01:31.422] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:31.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:31.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:31.436]   - Field: ‘node’
[17:01:31.436]   - Field: ‘label’
[17:01:31.436]   - Field: ‘local’
[17:01:31.437]   - Field: ‘owner’
[17:01:31.437]   - Field: ‘envir’
[17:01:31.437]   - Field: ‘workers’
[17:01:31.437]   - Field: ‘packages’
[17:01:31.437]   - Field: ‘gc’
[17:01:31.437]   - Field: ‘conditions’
[17:01:31.437]   - Field: ‘persistent’
[17:01:31.437]   - Field: ‘expr’
[17:01:31.437]   - Field: ‘uuid’
[17:01:31.437]   - Field: ‘seed’
[17:01:31.437]   - Field: ‘version’
[17:01:31.437]   - Field: ‘result’
[17:01:31.438]   - Field: ‘asynchronous’
[17:01:31.438]   - Field: ‘calls’
[17:01:31.438]   - Field: ‘globals’
[17:01:31.438]   - Field: ‘stdout’
[17:01:31.438]   - Field: ‘earlySignal’
[17:01:31.438]   - Field: ‘lazy’
[17:01:31.438]   - Field: ‘state’
[17:01:31.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:31.438] - Launch lazy future ...
[17:01:31.439] Packages needed by the future expression (n = 0): <none>
[17:01:31.439] Packages needed by future strategies (n = 0): <none>
[17:01:31.439] {
[17:01:31.439]     {
[17:01:31.439]         {
[17:01:31.439]             ...future.startTime <- base::Sys.time()
[17:01:31.439]             {
[17:01:31.439]                 {
[17:01:31.439]                   {
[17:01:31.439]                     {
[17:01:31.439]                       base::local({
[17:01:31.439]                         has_future <- base::requireNamespace("future", 
[17:01:31.439]                           quietly = TRUE)
[17:01:31.439]                         if (has_future) {
[17:01:31.439]                           ns <- base::getNamespace("future")
[17:01:31.439]                           version <- ns[[".package"]][["version"]]
[17:01:31.439]                           if (is.null(version)) 
[17:01:31.439]                             version <- utils::packageVersion("future")
[17:01:31.439]                         }
[17:01:31.439]                         else {
[17:01:31.439]                           version <- NULL
[17:01:31.439]                         }
[17:01:31.439]                         if (!has_future || version < "1.8.0") {
[17:01:31.439]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:31.439]                             "", base::R.version$version.string), 
[17:01:31.439]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:31.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:31.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:31.439]                               "release", "version")], collapse = " "), 
[17:01:31.439]                             hostname = base::Sys.info()[["nodename"]])
[17:01:31.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:31.439]                             info)
[17:01:31.439]                           info <- base::paste(info, collapse = "; ")
[17:01:31.439]                           if (!has_future) {
[17:01:31.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:31.439]                               info)
[17:01:31.439]                           }
[17:01:31.439]                           else {
[17:01:31.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:31.439]                               info, version)
[17:01:31.439]                           }
[17:01:31.439]                           base::stop(msg)
[17:01:31.439]                         }
[17:01:31.439]                       })
[17:01:31.439]                     }
[17:01:31.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:31.439]                     base::options(mc.cores = 1L)
[17:01:31.439]                   }
[17:01:31.439]                   ...future.strategy.old <- future::plan("list")
[17:01:31.439]                   options(future.plan = NULL)
[17:01:31.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:31.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:31.439]                 }
[17:01:31.439]                 ...future.workdir <- getwd()
[17:01:31.439]             }
[17:01:31.439]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:31.439]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:31.439]         }
[17:01:31.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:31.439]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:31.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:31.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:31.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:31.439]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:31.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:31.439]             base::names(...future.oldOptions))
[17:01:31.439]     }
[17:01:31.439]     if (FALSE) {
[17:01:31.439]     }
[17:01:31.439]     else {
[17:01:31.439]         if (FALSE) {
[17:01:31.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:31.439]                 open = "w")
[17:01:31.439]         }
[17:01:31.439]         else {
[17:01:31.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:31.439]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:31.439]         }
[17:01:31.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:31.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:31.439]             base::sink(type = "output", split = FALSE)
[17:01:31.439]             base::close(...future.stdout)
[17:01:31.439]         }, add = TRUE)
[17:01:31.439]     }
[17:01:31.439]     ...future.frame <- base::sys.nframe()
[17:01:31.439]     ...future.conditions <- base::list()
[17:01:31.439]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:31.439]     if (FALSE) {
[17:01:31.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:31.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:31.439]     }
[17:01:31.439]     ...future.result <- base::tryCatch({
[17:01:31.439]         base::withCallingHandlers({
[17:01:31.439]             ...future.value <- base::withVisible(base::local({
[17:01:31.439]                 ...future.makeSendCondition <- base::local({
[17:01:31.439]                   sendCondition <- NULL
[17:01:31.439]                   function(frame = 1L) {
[17:01:31.439]                     if (is.function(sendCondition)) 
[17:01:31.439]                       return(sendCondition)
[17:01:31.439]                     ns <- getNamespace("parallel")
[17:01:31.439]                     if (exists("sendData", mode = "function", 
[17:01:31.439]                       envir = ns)) {
[17:01:31.439]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:31.439]                         envir = ns)
[17:01:31.439]                       envir <- sys.frame(frame)
[17:01:31.439]                       master <- NULL
[17:01:31.439]                       while (!identical(envir, .GlobalEnv) && 
[17:01:31.439]                         !identical(envir, emptyenv())) {
[17:01:31.439]                         if (exists("master", mode = "list", envir = envir, 
[17:01:31.439]                           inherits = FALSE)) {
[17:01:31.439]                           master <- get("master", mode = "list", 
[17:01:31.439]                             envir = envir, inherits = FALSE)
[17:01:31.439]                           if (inherits(master, c("SOCKnode", 
[17:01:31.439]                             "SOCK0node"))) {
[17:01:31.439]                             sendCondition <<- function(cond) {
[17:01:31.439]                               data <- list(type = "VALUE", value = cond, 
[17:01:31.439]                                 success = TRUE)
[17:01:31.439]                               parallel_sendData(master, data)
[17:01:31.439]                             }
[17:01:31.439]                             return(sendCondition)
[17:01:31.439]                           }
[17:01:31.439]                         }
[17:01:31.439]                         frame <- frame + 1L
[17:01:31.439]                         envir <- sys.frame(frame)
[17:01:31.439]                       }
[17:01:31.439]                     }
[17:01:31.439]                     sendCondition <<- function(cond) NULL
[17:01:31.439]                   }
[17:01:31.439]                 })
[17:01:31.439]                 withCallingHandlers({
[17:01:31.439]                   {
[17:01:31.439]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:31.439]                     if (!identical(...future.globals.maxSize.org, 
[17:01:31.439]                       ...future.globals.maxSize)) {
[17:01:31.439]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:31.439]                       on.exit(options(oopts), add = TRUE)
[17:01:31.439]                     }
[17:01:31.439]                     {
[17:01:31.439]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:31.439]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:31.439]                         USE.NAMES = FALSE)
[17:01:31.439]                       do.call(mapply, args = args)
[17:01:31.439]                     }
[17:01:31.439]                   }
[17:01:31.439]                 }, immediateCondition = function(cond) {
[17:01:31.439]                   sendCondition <- ...future.makeSendCondition()
[17:01:31.439]                   sendCondition(cond)
[17:01:31.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:31.439]                   {
[17:01:31.439]                     inherits <- base::inherits
[17:01:31.439]                     invokeRestart <- base::invokeRestart
[17:01:31.439]                     is.null <- base::is.null
[17:01:31.439]                     muffled <- FALSE
[17:01:31.439]                     if (inherits(cond, "message")) {
[17:01:31.439]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:31.439]                       if (muffled) 
[17:01:31.439]                         invokeRestart("muffleMessage")
[17:01:31.439]                     }
[17:01:31.439]                     else if (inherits(cond, "warning")) {
[17:01:31.439]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:31.439]                       if (muffled) 
[17:01:31.439]                         invokeRestart("muffleWarning")
[17:01:31.439]                     }
[17:01:31.439]                     else if (inherits(cond, "condition")) {
[17:01:31.439]                       if (!is.null(pattern)) {
[17:01:31.439]                         computeRestarts <- base::computeRestarts
[17:01:31.439]                         grepl <- base::grepl
[17:01:31.439]                         restarts <- computeRestarts(cond)
[17:01:31.439]                         for (restart in restarts) {
[17:01:31.439]                           name <- restart$name
[17:01:31.439]                           if (is.null(name)) 
[17:01:31.439]                             next
[17:01:31.439]                           if (!grepl(pattern, name)) 
[17:01:31.439]                             next
[17:01:31.439]                           invokeRestart(restart)
[17:01:31.439]                           muffled <- TRUE
[17:01:31.439]                           break
[17:01:31.439]                         }
[17:01:31.439]                       }
[17:01:31.439]                     }
[17:01:31.439]                     invisible(muffled)
[17:01:31.439]                   }
[17:01:31.439]                   muffleCondition(cond)
[17:01:31.439]                 })
[17:01:31.439]             }))
[17:01:31.439]             future::FutureResult(value = ...future.value$value, 
[17:01:31.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:31.439]                   ...future.rng), globalenv = if (FALSE) 
[17:01:31.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:31.439]                     ...future.globalenv.names))
[17:01:31.439]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:31.439]         }, condition = base::local({
[17:01:31.439]             c <- base::c
[17:01:31.439]             inherits <- base::inherits
[17:01:31.439]             invokeRestart <- base::invokeRestart
[17:01:31.439]             length <- base::length
[17:01:31.439]             list <- base::list
[17:01:31.439]             seq.int <- base::seq.int
[17:01:31.439]             signalCondition <- base::signalCondition
[17:01:31.439]             sys.calls <- base::sys.calls
[17:01:31.439]             `[[` <- base::`[[`
[17:01:31.439]             `+` <- base::`+`
[17:01:31.439]             `<<-` <- base::`<<-`
[17:01:31.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:31.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:31.439]                   3L)]
[17:01:31.439]             }
[17:01:31.439]             function(cond) {
[17:01:31.439]                 is_error <- inherits(cond, "error")
[17:01:31.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:31.439]                   NULL)
[17:01:31.439]                 if (is_error) {
[17:01:31.439]                   sessionInformation <- function() {
[17:01:31.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:31.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:31.439]                       search = base::search(), system = base::Sys.info())
[17:01:31.439]                   }
[17:01:31.439]                   ...future.conditions[[length(...future.conditions) + 
[17:01:31.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:31.439]                     cond$call), session = sessionInformation(), 
[17:01:31.439]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:31.439]                   signalCondition(cond)
[17:01:31.439]                 }
[17:01:31.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:31.439]                 "immediateCondition"))) {
[17:01:31.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:31.439]                   ...future.conditions[[length(...future.conditions) + 
[17:01:31.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:31.439]                   if (TRUE && !signal) {
[17:01:31.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:31.439]                     {
[17:01:31.439]                       inherits <- base::inherits
[17:01:31.439]                       invokeRestart <- base::invokeRestart
[17:01:31.439]                       is.null <- base::is.null
[17:01:31.439]                       muffled <- FALSE
[17:01:31.439]                       if (inherits(cond, "message")) {
[17:01:31.439]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:31.439]                         if (muffled) 
[17:01:31.439]                           invokeRestart("muffleMessage")
[17:01:31.439]                       }
[17:01:31.439]                       else if (inherits(cond, "warning")) {
[17:01:31.439]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:31.439]                         if (muffled) 
[17:01:31.439]                           invokeRestart("muffleWarning")
[17:01:31.439]                       }
[17:01:31.439]                       else if (inherits(cond, "condition")) {
[17:01:31.439]                         if (!is.null(pattern)) {
[17:01:31.439]                           computeRestarts <- base::computeRestarts
[17:01:31.439]                           grepl <- base::grepl
[17:01:31.439]                           restarts <- computeRestarts(cond)
[17:01:31.439]                           for (restart in restarts) {
[17:01:31.439]                             name <- restart$name
[17:01:31.439]                             if (is.null(name)) 
[17:01:31.439]                               next
[17:01:31.439]                             if (!grepl(pattern, name)) 
[17:01:31.439]                               next
[17:01:31.439]                             invokeRestart(restart)
[17:01:31.439]                             muffled <- TRUE
[17:01:31.439]                             break
[17:01:31.439]                           }
[17:01:31.439]                         }
[17:01:31.439]                       }
[17:01:31.439]                       invisible(muffled)
[17:01:31.439]                     }
[17:01:31.439]                     muffleCondition(cond, pattern = "^muffle")
[17:01:31.439]                   }
[17:01:31.439]                 }
[17:01:31.439]                 else {
[17:01:31.439]                   if (TRUE) {
[17:01:31.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:31.439]                     {
[17:01:31.439]                       inherits <- base::inherits
[17:01:31.439]                       invokeRestart <- base::invokeRestart
[17:01:31.439]                       is.null <- base::is.null
[17:01:31.439]                       muffled <- FALSE
[17:01:31.439]                       if (inherits(cond, "message")) {
[17:01:31.439]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:31.439]                         if (muffled) 
[17:01:31.439]                           invokeRestart("muffleMessage")
[17:01:31.439]                       }
[17:01:31.439]                       else if (inherits(cond, "warning")) {
[17:01:31.439]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:31.439]                         if (muffled) 
[17:01:31.439]                           invokeRestart("muffleWarning")
[17:01:31.439]                       }
[17:01:31.439]                       else if (inherits(cond, "condition")) {
[17:01:31.439]                         if (!is.null(pattern)) {
[17:01:31.439]                           computeRestarts <- base::computeRestarts
[17:01:31.439]                           grepl <- base::grepl
[17:01:31.439]                           restarts <- computeRestarts(cond)
[17:01:31.439]                           for (restart in restarts) {
[17:01:31.439]                             name <- restart$name
[17:01:31.439]                             if (is.null(name)) 
[17:01:31.439]                               next
[17:01:31.439]                             if (!grepl(pattern, name)) 
[17:01:31.439]                               next
[17:01:31.439]                             invokeRestart(restart)
[17:01:31.439]                             muffled <- TRUE
[17:01:31.439]                             break
[17:01:31.439]                           }
[17:01:31.439]                         }
[17:01:31.439]                       }
[17:01:31.439]                       invisible(muffled)
[17:01:31.439]                     }
[17:01:31.439]                     muffleCondition(cond, pattern = "^muffle")
[17:01:31.439]                   }
[17:01:31.439]                 }
[17:01:31.439]             }
[17:01:31.439]         }))
[17:01:31.439]     }, error = function(ex) {
[17:01:31.439]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:31.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:31.439]                 ...future.rng), started = ...future.startTime, 
[17:01:31.439]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:31.439]             version = "1.8"), class = "FutureResult")
[17:01:31.439]     }, finally = {
[17:01:31.439]         if (!identical(...future.workdir, getwd())) 
[17:01:31.439]             setwd(...future.workdir)
[17:01:31.439]         {
[17:01:31.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:31.439]                 ...future.oldOptions$nwarnings <- NULL
[17:01:31.439]             }
[17:01:31.439]             base::options(...future.oldOptions)
[17:01:31.439]             if (.Platform$OS.type == "windows") {
[17:01:31.439]                 old_names <- names(...future.oldEnvVars)
[17:01:31.439]                 envs <- base::Sys.getenv()
[17:01:31.439]                 names <- names(envs)
[17:01:31.439]                 common <- intersect(names, old_names)
[17:01:31.439]                 added <- setdiff(names, old_names)
[17:01:31.439]                 removed <- setdiff(old_names, names)
[17:01:31.439]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:31.439]                   envs[common]]
[17:01:31.439]                 NAMES <- toupper(changed)
[17:01:31.439]                 args <- list()
[17:01:31.439]                 for (kk in seq_along(NAMES)) {
[17:01:31.439]                   name <- changed[[kk]]
[17:01:31.439]                   NAME <- NAMES[[kk]]
[17:01:31.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:31.439]                     next
[17:01:31.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:31.439]                 }
[17:01:31.439]                 NAMES <- toupper(added)
[17:01:31.439]                 for (kk in seq_along(NAMES)) {
[17:01:31.439]                   name <- added[[kk]]
[17:01:31.439]                   NAME <- NAMES[[kk]]
[17:01:31.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:31.439]                     next
[17:01:31.439]                   args[[name]] <- ""
[17:01:31.439]                 }
[17:01:31.439]                 NAMES <- toupper(removed)
[17:01:31.439]                 for (kk in seq_along(NAMES)) {
[17:01:31.439]                   name <- removed[[kk]]
[17:01:31.439]                   NAME <- NAMES[[kk]]
[17:01:31.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:31.439]                     next
[17:01:31.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:31.439]                 }
[17:01:31.439]                 if (length(args) > 0) 
[17:01:31.439]                   base::do.call(base::Sys.setenv, args = args)
[17:01:31.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:31.439]             }
[17:01:31.439]             else {
[17:01:31.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:31.439]             }
[17:01:31.439]             {
[17:01:31.439]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:31.439]                   0L) {
[17:01:31.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:31.439]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:31.439]                   base::options(opts)
[17:01:31.439]                 }
[17:01:31.439]                 {
[17:01:31.439]                   {
[17:01:31.439]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:31.439]                     NULL
[17:01:31.439]                   }
[17:01:31.439]                   options(future.plan = NULL)
[17:01:31.439]                   if (is.na(NA_character_)) 
[17:01:31.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:31.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:31.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:31.439]                     .init = FALSE)
[17:01:31.439]                 }
[17:01:31.439]             }
[17:01:31.439]         }
[17:01:31.439]     })
[17:01:31.439]     if (TRUE) {
[17:01:31.439]         base::sink(type = "output", split = FALSE)
[17:01:31.439]         if (FALSE) {
[17:01:31.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:31.439]         }
[17:01:31.439]         else {
[17:01:31.439]             ...future.result["stdout"] <- base::list(NULL)
[17:01:31.439]         }
[17:01:31.439]         base::close(...future.stdout)
[17:01:31.439]         ...future.stdout <- NULL
[17:01:31.439]     }
[17:01:31.439]     ...future.result$conditions <- ...future.conditions
[17:01:31.439]     ...future.result$finished <- base::Sys.time()
[17:01:31.439]     ...future.result
[17:01:31.439] }
[17:01:31.442] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:01:31.442] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:01:31.442] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:01:31.443] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:01:31.443] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:01:31.443] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:01:31.443] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:01:31.443] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:31.444] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:31.444] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:31.444] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:31.444] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:01:31.445] MultisessionFuture started
[17:01:31.445] - Launch lazy future ... done
[17:01:31.445] run() for ‘MultisessionFuture’ ... done
[17:01:31.445] Created future:
[17:01:31.445] MultisessionFuture:
[17:01:31.445] Label: ‘future_mapply-1’
[17:01:31.445] Expression:
[17:01:31.445] {
[17:01:31.445]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:31.445]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:31.445]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:31.445]         on.exit(options(oopts), add = TRUE)
[17:01:31.445]     }
[17:01:31.445]     {
[17:01:31.445]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:31.445]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:31.445]         do.call(mapply, args = args)
[17:01:31.445]     }
[17:01:31.445] }
[17:01:31.445] Lazy evaluation: FALSE
[17:01:31.445] Asynchronous evaluation: TRUE
[17:01:31.445] Local evaluation: TRUE
[17:01:31.445] Environment: R_GlobalEnv
[17:01:31.445] Capture standard output: FALSE
[17:01:31.445] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:31.445] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:31.445] Packages: <none>
[17:01:31.445] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:31.445] Resolved: FALSE
[17:01:31.445] Value: <not collected>
[17:01:31.445] Conditions captured: <none>
[17:01:31.445] Early signaling: FALSE
[17:01:31.445] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:31.445] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:31.457] Chunk #1 of 2 ... DONE
[17:01:31.457] Chunk #2 of 2 ...
[17:01:31.457]  - Finding globals in '...' for chunk #2 ...
[17:01:31.457] getGlobalsAndPackages() ...
[17:01:31.457] Searching for globals...
[17:01:31.457] 
[17:01:31.457] Searching for globals ... DONE
[17:01:31.457] - globals: [0] <none>
[17:01:31.458] getGlobalsAndPackages() ... DONE
[17:01:31.458]    + additional globals found: [n=0] 
[17:01:31.458]    + additional namespaces needed: [n=0] 
[17:01:31.458]  - Finding globals in '...' for chunk #2 ... DONE
[17:01:31.458]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:31.458]  - seeds: <none>
[17:01:31.458]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:31.458] getGlobalsAndPackages() ...
[17:01:31.458] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:31.458] Resolving globals: FALSE
[17:01:31.459] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:31.459] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:31.459] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:31.460] 
[17:01:31.460] getGlobalsAndPackages() ... DONE
[17:01:31.460] run() for ‘Future’ ...
[17:01:31.460] - state: ‘created’
[17:01:31.460] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:31.474] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:31.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:31.474]   - Field: ‘node’
[17:01:31.475]   - Field: ‘label’
[17:01:31.475]   - Field: ‘local’
[17:01:31.475]   - Field: ‘owner’
[17:01:31.475]   - Field: ‘envir’
[17:01:31.475]   - Field: ‘workers’
[17:01:31.475]   - Field: ‘packages’
[17:01:31.475]   - Field: ‘gc’
[17:01:31.475]   - Field: ‘conditions’
[17:01:31.475]   - Field: ‘persistent’
[17:01:31.475]   - Field: ‘expr’
[17:01:31.475]   - Field: ‘uuid’
[17:01:31.476]   - Field: ‘seed’
[17:01:31.476]   - Field: ‘version’
[17:01:31.476]   - Field: ‘result’
[17:01:31.476]   - Field: ‘asynchronous’
[17:01:31.476]   - Field: ‘calls’
[17:01:31.476]   - Field: ‘globals’
[17:01:31.476]   - Field: ‘stdout’
[17:01:31.476]   - Field: ‘earlySignal’
[17:01:31.476]   - Field: ‘lazy’
[17:01:31.476]   - Field: ‘state’
[17:01:31.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:31.477] - Launch lazy future ...
[17:01:31.477] Packages needed by the future expression (n = 0): <none>
[17:01:31.477] Packages needed by future strategies (n = 0): <none>
[17:01:31.477] {
[17:01:31.477]     {
[17:01:31.477]         {
[17:01:31.477]             ...future.startTime <- base::Sys.time()
[17:01:31.477]             {
[17:01:31.477]                 {
[17:01:31.477]                   {
[17:01:31.477]                     {
[17:01:31.477]                       base::local({
[17:01:31.477]                         has_future <- base::requireNamespace("future", 
[17:01:31.477]                           quietly = TRUE)
[17:01:31.477]                         if (has_future) {
[17:01:31.477]                           ns <- base::getNamespace("future")
[17:01:31.477]                           version <- ns[[".package"]][["version"]]
[17:01:31.477]                           if (is.null(version)) 
[17:01:31.477]                             version <- utils::packageVersion("future")
[17:01:31.477]                         }
[17:01:31.477]                         else {
[17:01:31.477]                           version <- NULL
[17:01:31.477]                         }
[17:01:31.477]                         if (!has_future || version < "1.8.0") {
[17:01:31.477]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:31.477]                             "", base::R.version$version.string), 
[17:01:31.477]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:31.477]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:31.477]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:31.477]                               "release", "version")], collapse = " "), 
[17:01:31.477]                             hostname = base::Sys.info()[["nodename"]])
[17:01:31.477]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:31.477]                             info)
[17:01:31.477]                           info <- base::paste(info, collapse = "; ")
[17:01:31.477]                           if (!has_future) {
[17:01:31.477]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:31.477]                               info)
[17:01:31.477]                           }
[17:01:31.477]                           else {
[17:01:31.477]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:31.477]                               info, version)
[17:01:31.477]                           }
[17:01:31.477]                           base::stop(msg)
[17:01:31.477]                         }
[17:01:31.477]                       })
[17:01:31.477]                     }
[17:01:31.477]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:31.477]                     base::options(mc.cores = 1L)
[17:01:31.477]                   }
[17:01:31.477]                   ...future.strategy.old <- future::plan("list")
[17:01:31.477]                   options(future.plan = NULL)
[17:01:31.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:31.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:31.477]                 }
[17:01:31.477]                 ...future.workdir <- getwd()
[17:01:31.477]             }
[17:01:31.477]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:31.477]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:31.477]         }
[17:01:31.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:31.477]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:31.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:31.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:31.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:31.477]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:31.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:31.477]             base::names(...future.oldOptions))
[17:01:31.477]     }
[17:01:31.477]     if (FALSE) {
[17:01:31.477]     }
[17:01:31.477]     else {
[17:01:31.477]         if (FALSE) {
[17:01:31.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:31.477]                 open = "w")
[17:01:31.477]         }
[17:01:31.477]         else {
[17:01:31.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:31.477]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:31.477]         }
[17:01:31.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:31.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:31.477]             base::sink(type = "output", split = FALSE)
[17:01:31.477]             base::close(...future.stdout)
[17:01:31.477]         }, add = TRUE)
[17:01:31.477]     }
[17:01:31.477]     ...future.frame <- base::sys.nframe()
[17:01:31.477]     ...future.conditions <- base::list()
[17:01:31.477]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:31.477]     if (FALSE) {
[17:01:31.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:31.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:31.477]     }
[17:01:31.477]     ...future.result <- base::tryCatch({
[17:01:31.477]         base::withCallingHandlers({
[17:01:31.477]             ...future.value <- base::withVisible(base::local({
[17:01:31.477]                 ...future.makeSendCondition <- base::local({
[17:01:31.477]                   sendCondition <- NULL
[17:01:31.477]                   function(frame = 1L) {
[17:01:31.477]                     if (is.function(sendCondition)) 
[17:01:31.477]                       return(sendCondition)
[17:01:31.477]                     ns <- getNamespace("parallel")
[17:01:31.477]                     if (exists("sendData", mode = "function", 
[17:01:31.477]                       envir = ns)) {
[17:01:31.477]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:31.477]                         envir = ns)
[17:01:31.477]                       envir <- sys.frame(frame)
[17:01:31.477]                       master <- NULL
[17:01:31.477]                       while (!identical(envir, .GlobalEnv) && 
[17:01:31.477]                         !identical(envir, emptyenv())) {
[17:01:31.477]                         if (exists("master", mode = "list", envir = envir, 
[17:01:31.477]                           inherits = FALSE)) {
[17:01:31.477]                           master <- get("master", mode = "list", 
[17:01:31.477]                             envir = envir, inherits = FALSE)
[17:01:31.477]                           if (inherits(master, c("SOCKnode", 
[17:01:31.477]                             "SOCK0node"))) {
[17:01:31.477]                             sendCondition <<- function(cond) {
[17:01:31.477]                               data <- list(type = "VALUE", value = cond, 
[17:01:31.477]                                 success = TRUE)
[17:01:31.477]                               parallel_sendData(master, data)
[17:01:31.477]                             }
[17:01:31.477]                             return(sendCondition)
[17:01:31.477]                           }
[17:01:31.477]                         }
[17:01:31.477]                         frame <- frame + 1L
[17:01:31.477]                         envir <- sys.frame(frame)
[17:01:31.477]                       }
[17:01:31.477]                     }
[17:01:31.477]                     sendCondition <<- function(cond) NULL
[17:01:31.477]                   }
[17:01:31.477]                 })
[17:01:31.477]                 withCallingHandlers({
[17:01:31.477]                   {
[17:01:31.477]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:31.477]                     if (!identical(...future.globals.maxSize.org, 
[17:01:31.477]                       ...future.globals.maxSize)) {
[17:01:31.477]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:31.477]                       on.exit(options(oopts), add = TRUE)
[17:01:31.477]                     }
[17:01:31.477]                     {
[17:01:31.477]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:31.477]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:31.477]                         USE.NAMES = FALSE)
[17:01:31.477]                       do.call(mapply, args = args)
[17:01:31.477]                     }
[17:01:31.477]                   }
[17:01:31.477]                 }, immediateCondition = function(cond) {
[17:01:31.477]                   sendCondition <- ...future.makeSendCondition()
[17:01:31.477]                   sendCondition(cond)
[17:01:31.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:31.477]                   {
[17:01:31.477]                     inherits <- base::inherits
[17:01:31.477]                     invokeRestart <- base::invokeRestart
[17:01:31.477]                     is.null <- base::is.null
[17:01:31.477]                     muffled <- FALSE
[17:01:31.477]                     if (inherits(cond, "message")) {
[17:01:31.477]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:31.477]                       if (muffled) 
[17:01:31.477]                         invokeRestart("muffleMessage")
[17:01:31.477]                     }
[17:01:31.477]                     else if (inherits(cond, "warning")) {
[17:01:31.477]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:31.477]                       if (muffled) 
[17:01:31.477]                         invokeRestart("muffleWarning")
[17:01:31.477]                     }
[17:01:31.477]                     else if (inherits(cond, "condition")) {
[17:01:31.477]                       if (!is.null(pattern)) {
[17:01:31.477]                         computeRestarts <- base::computeRestarts
[17:01:31.477]                         grepl <- base::grepl
[17:01:31.477]                         restarts <- computeRestarts(cond)
[17:01:31.477]                         for (restart in restarts) {
[17:01:31.477]                           name <- restart$name
[17:01:31.477]                           if (is.null(name)) 
[17:01:31.477]                             next
[17:01:31.477]                           if (!grepl(pattern, name)) 
[17:01:31.477]                             next
[17:01:31.477]                           invokeRestart(restart)
[17:01:31.477]                           muffled <- TRUE
[17:01:31.477]                           break
[17:01:31.477]                         }
[17:01:31.477]                       }
[17:01:31.477]                     }
[17:01:31.477]                     invisible(muffled)
[17:01:31.477]                   }
[17:01:31.477]                   muffleCondition(cond)
[17:01:31.477]                 })
[17:01:31.477]             }))
[17:01:31.477]             future::FutureResult(value = ...future.value$value, 
[17:01:31.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:31.477]                   ...future.rng), globalenv = if (FALSE) 
[17:01:31.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:31.477]                     ...future.globalenv.names))
[17:01:31.477]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:31.477]         }, condition = base::local({
[17:01:31.477]             c <- base::c
[17:01:31.477]             inherits <- base::inherits
[17:01:31.477]             invokeRestart <- base::invokeRestart
[17:01:31.477]             length <- base::length
[17:01:31.477]             list <- base::list
[17:01:31.477]             seq.int <- base::seq.int
[17:01:31.477]             signalCondition <- base::signalCondition
[17:01:31.477]             sys.calls <- base::sys.calls
[17:01:31.477]             `[[` <- base::`[[`
[17:01:31.477]             `+` <- base::`+`
[17:01:31.477]             `<<-` <- base::`<<-`
[17:01:31.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:31.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:31.477]                   3L)]
[17:01:31.477]             }
[17:01:31.477]             function(cond) {
[17:01:31.477]                 is_error <- inherits(cond, "error")
[17:01:31.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:31.477]                   NULL)
[17:01:31.477]                 if (is_error) {
[17:01:31.477]                   sessionInformation <- function() {
[17:01:31.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:31.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:31.477]                       search = base::search(), system = base::Sys.info())
[17:01:31.477]                   }
[17:01:31.477]                   ...future.conditions[[length(...future.conditions) + 
[17:01:31.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:31.477]                     cond$call), session = sessionInformation(), 
[17:01:31.477]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:31.477]                   signalCondition(cond)
[17:01:31.477]                 }
[17:01:31.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:31.477]                 "immediateCondition"))) {
[17:01:31.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:31.477]                   ...future.conditions[[length(...future.conditions) + 
[17:01:31.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:31.477]                   if (TRUE && !signal) {
[17:01:31.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:31.477]                     {
[17:01:31.477]                       inherits <- base::inherits
[17:01:31.477]                       invokeRestart <- base::invokeRestart
[17:01:31.477]                       is.null <- base::is.null
[17:01:31.477]                       muffled <- FALSE
[17:01:31.477]                       if (inherits(cond, "message")) {
[17:01:31.477]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:31.477]                         if (muffled) 
[17:01:31.477]                           invokeRestart("muffleMessage")
[17:01:31.477]                       }
[17:01:31.477]                       else if (inherits(cond, "warning")) {
[17:01:31.477]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:31.477]                         if (muffled) 
[17:01:31.477]                           invokeRestart("muffleWarning")
[17:01:31.477]                       }
[17:01:31.477]                       else if (inherits(cond, "condition")) {
[17:01:31.477]                         if (!is.null(pattern)) {
[17:01:31.477]                           computeRestarts <- base::computeRestarts
[17:01:31.477]                           grepl <- base::grepl
[17:01:31.477]                           restarts <- computeRestarts(cond)
[17:01:31.477]                           for (restart in restarts) {
[17:01:31.477]                             name <- restart$name
[17:01:31.477]                             if (is.null(name)) 
[17:01:31.477]                               next
[17:01:31.477]                             if (!grepl(pattern, name)) 
[17:01:31.477]                               next
[17:01:31.477]                             invokeRestart(restart)
[17:01:31.477]                             muffled <- TRUE
[17:01:31.477]                             break
[17:01:31.477]                           }
[17:01:31.477]                         }
[17:01:31.477]                       }
[17:01:31.477]                       invisible(muffled)
[17:01:31.477]                     }
[17:01:31.477]                     muffleCondition(cond, pattern = "^muffle")
[17:01:31.477]                   }
[17:01:31.477]                 }
[17:01:31.477]                 else {
[17:01:31.477]                   if (TRUE) {
[17:01:31.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:31.477]                     {
[17:01:31.477]                       inherits <- base::inherits
[17:01:31.477]                       invokeRestart <- base::invokeRestart
[17:01:31.477]                       is.null <- base::is.null
[17:01:31.477]                       muffled <- FALSE
[17:01:31.477]                       if (inherits(cond, "message")) {
[17:01:31.477]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:31.477]                         if (muffled) 
[17:01:31.477]                           invokeRestart("muffleMessage")
[17:01:31.477]                       }
[17:01:31.477]                       else if (inherits(cond, "warning")) {
[17:01:31.477]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:31.477]                         if (muffled) 
[17:01:31.477]                           invokeRestart("muffleWarning")
[17:01:31.477]                       }
[17:01:31.477]                       else if (inherits(cond, "condition")) {
[17:01:31.477]                         if (!is.null(pattern)) {
[17:01:31.477]                           computeRestarts <- base::computeRestarts
[17:01:31.477]                           grepl <- base::grepl
[17:01:31.477]                           restarts <- computeRestarts(cond)
[17:01:31.477]                           for (restart in restarts) {
[17:01:31.477]                             name <- restart$name
[17:01:31.477]                             if (is.null(name)) 
[17:01:31.477]                               next
[17:01:31.477]                             if (!grepl(pattern, name)) 
[17:01:31.477]                               next
[17:01:31.477]                             invokeRestart(restart)
[17:01:31.477]                             muffled <- TRUE
[17:01:31.477]                             break
[17:01:31.477]                           }
[17:01:31.477]                         }
[17:01:31.477]                       }
[17:01:31.477]                       invisible(muffled)
[17:01:31.477]                     }
[17:01:31.477]                     muffleCondition(cond, pattern = "^muffle")
[17:01:31.477]                   }
[17:01:31.477]                 }
[17:01:31.477]             }
[17:01:31.477]         }))
[17:01:31.477]     }, error = function(ex) {
[17:01:31.477]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:31.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:31.477]                 ...future.rng), started = ...future.startTime, 
[17:01:31.477]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:31.477]             version = "1.8"), class = "FutureResult")
[17:01:31.477]     }, finally = {
[17:01:31.477]         if (!identical(...future.workdir, getwd())) 
[17:01:31.477]             setwd(...future.workdir)
[17:01:31.477]         {
[17:01:31.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:31.477]                 ...future.oldOptions$nwarnings <- NULL
[17:01:31.477]             }
[17:01:31.477]             base::options(...future.oldOptions)
[17:01:31.477]             if (.Platform$OS.type == "windows") {
[17:01:31.477]                 old_names <- names(...future.oldEnvVars)
[17:01:31.477]                 envs <- base::Sys.getenv()
[17:01:31.477]                 names <- names(envs)
[17:01:31.477]                 common <- intersect(names, old_names)
[17:01:31.477]                 added <- setdiff(names, old_names)
[17:01:31.477]                 removed <- setdiff(old_names, names)
[17:01:31.477]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:31.477]                   envs[common]]
[17:01:31.477]                 NAMES <- toupper(changed)
[17:01:31.477]                 args <- list()
[17:01:31.477]                 for (kk in seq_along(NAMES)) {
[17:01:31.477]                   name <- changed[[kk]]
[17:01:31.477]                   NAME <- NAMES[[kk]]
[17:01:31.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:31.477]                     next
[17:01:31.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:31.477]                 }
[17:01:31.477]                 NAMES <- toupper(added)
[17:01:31.477]                 for (kk in seq_along(NAMES)) {
[17:01:31.477]                   name <- added[[kk]]
[17:01:31.477]                   NAME <- NAMES[[kk]]
[17:01:31.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:31.477]                     next
[17:01:31.477]                   args[[name]] <- ""
[17:01:31.477]                 }
[17:01:31.477]                 NAMES <- toupper(removed)
[17:01:31.477]                 for (kk in seq_along(NAMES)) {
[17:01:31.477]                   name <- removed[[kk]]
[17:01:31.477]                   NAME <- NAMES[[kk]]
[17:01:31.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:31.477]                     next
[17:01:31.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:31.477]                 }
[17:01:31.477]                 if (length(args) > 0) 
[17:01:31.477]                   base::do.call(base::Sys.setenv, args = args)
[17:01:31.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:31.477]             }
[17:01:31.477]             else {
[17:01:31.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:31.477]             }
[17:01:31.477]             {
[17:01:31.477]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:31.477]                   0L) {
[17:01:31.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:31.477]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:31.477]                   base::options(opts)
[17:01:31.477]                 }
[17:01:31.477]                 {
[17:01:31.477]                   {
[17:01:31.477]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:31.477]                     NULL
[17:01:31.477]                   }
[17:01:31.477]                   options(future.plan = NULL)
[17:01:31.477]                   if (is.na(NA_character_)) 
[17:01:31.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:31.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:31.477]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:31.477]                     .init = FALSE)
[17:01:31.477]                 }
[17:01:31.477]             }
[17:01:31.477]         }
[17:01:31.477]     })
[17:01:31.477]     if (TRUE) {
[17:01:31.477]         base::sink(type = "output", split = FALSE)
[17:01:31.477]         if (FALSE) {
[17:01:31.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:31.477]         }
[17:01:31.477]         else {
[17:01:31.477]             ...future.result["stdout"] <- base::list(NULL)
[17:01:31.477]         }
[17:01:31.477]         base::close(...future.stdout)
[17:01:31.477]         ...future.stdout <- NULL
[17:01:31.477]     }
[17:01:31.477]     ...future.result$conditions <- ...future.conditions
[17:01:31.477]     ...future.result$finished <- base::Sys.time()
[17:01:31.477]     ...future.result
[17:01:31.477] }
[17:01:31.480] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:01:31.480] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:01:31.481] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:01:31.481] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:01:31.481] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:01:31.481] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:01:31.482] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:01:31.482] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:31.482] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:31.482] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:31.483] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:31.483] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:01:31.483] MultisessionFuture started
[17:01:31.484] - Launch lazy future ... done
[17:01:31.484] run() for ‘MultisessionFuture’ ... done
[17:01:31.484] Created future:
[17:01:31.484] MultisessionFuture:
[17:01:31.484] Label: ‘future_mapply-2’
[17:01:31.484] Expression:
[17:01:31.484] {
[17:01:31.484]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:31.484]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:31.484]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:31.484]         on.exit(options(oopts), add = TRUE)
[17:01:31.484]     }
[17:01:31.484]     {
[17:01:31.484]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:31.484]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:31.484]         do.call(mapply, args = args)
[17:01:31.484]     }
[17:01:31.484] }
[17:01:31.484] Lazy evaluation: FALSE
[17:01:31.484] Asynchronous evaluation: TRUE
[17:01:31.484] Local evaluation: TRUE
[17:01:31.484] Environment: R_GlobalEnv
[17:01:31.484] Capture standard output: FALSE
[17:01:31.484] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:31.484] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:31.484] Packages: <none>
[17:01:31.484] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:31.484] Resolved: FALSE
[17:01:31.484] Value: <not collected>
[17:01:31.484] Conditions captured: <none>
[17:01:31.484] Early signaling: FALSE
[17:01:31.484] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:31.484] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:31.496] Chunk #2 of 2 ... DONE
[17:01:31.496] Launching 2 futures (chunks) ... DONE
[17:01:31.496] Resolving 2 futures (chunks) ...
[17:01:31.496] resolve() on list ...
[17:01:31.496]  recursive: 0
[17:01:31.496]  length: 2
[17:01:31.496] 
[17:01:31.539] receiveMessageFromWorker() for ClusterFuture ...
[17:01:31.539] - Validating connection of MultisessionFuture
[17:01:31.539] - received message: FutureResult
[17:01:31.539] - Received FutureResult
[17:01:31.539] - Erased future from FutureRegistry
[17:01:31.540] result() for ClusterFuture ...
[17:01:31.540] - result already collected: FutureResult
[17:01:31.540] result() for ClusterFuture ... done
[17:01:31.540] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:31.540] Future #2
[17:01:31.540] result() for ClusterFuture ...
[17:01:31.540] - result already collected: FutureResult
[17:01:31.540] result() for ClusterFuture ... done
[17:01:31.540] result() for ClusterFuture ...
[17:01:31.540] - result already collected: FutureResult
[17:01:31.540] result() for ClusterFuture ... done
[17:01:31.541] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:31.541] - nx: 2
[17:01:31.541] - relay: TRUE
[17:01:31.541] - stdout: TRUE
[17:01:31.541] - signal: TRUE
[17:01:31.541] - resignal: FALSE
[17:01:31.541] - force: TRUE
[17:01:31.541] - relayed: [n=2] FALSE, FALSE
[17:01:31.541] - queued futures: [n=2] FALSE, FALSE
[17:01:31.541]  - until=1
[17:01:31.541]  - relaying element #1
[17:01:31.541] - relayed: [n=2] FALSE, FALSE
[17:01:31.542] - queued futures: [n=2] FALSE, TRUE
[17:01:31.542] signalConditionsASAP(NULL, pos=2) ... done
[17:01:31.542]  length: 1 (resolved future 2)
[17:01:31.994] receiveMessageFromWorker() for ClusterFuture ...
[17:01:31.994] - Validating connection of MultisessionFuture
[17:01:31.994] - received message: FutureResult
[17:01:31.995] - Received FutureResult
[17:01:31.995] - Erased future from FutureRegistry
[17:01:31.995] result() for ClusterFuture ...
[17:01:31.995] - result already collected: FutureResult
[17:01:31.995] result() for ClusterFuture ... done
[17:01:31.995] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:31.995] Future #1
[17:01:31.995] result() for ClusterFuture ...
[17:01:31.995] - result already collected: FutureResult
[17:01:31.996] result() for ClusterFuture ... done
[17:01:31.996] result() for ClusterFuture ...
[17:01:31.996] - result already collected: FutureResult
[17:01:31.996] result() for ClusterFuture ... done
[17:01:31.996] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:31.996] - nx: 2
[17:01:31.996] - relay: TRUE
[17:01:31.996] - stdout: TRUE
[17:01:31.996] - signal: TRUE
[17:01:31.996] - resignal: FALSE
[17:01:31.996] - force: TRUE
[17:01:31.996] - relayed: [n=2] FALSE, FALSE
[17:01:31.997] - queued futures: [n=2] FALSE, TRUE
[17:01:31.997]  - until=1
[17:01:31.997]  - relaying element #1
[17:01:31.997] result() for ClusterFuture ...
[17:01:31.997] - result already collected: FutureResult
[17:01:31.997] result() for ClusterFuture ... done
[17:01:31.997] result() for ClusterFuture ...
[17:01:31.997] - result already collected: FutureResult
[17:01:31.997] result() for ClusterFuture ... done
[17:01:31.997] result() for ClusterFuture ...
[17:01:31.997] - result already collected: FutureResult
[17:01:31.998] result() for ClusterFuture ... done
[17:01:31.998] result() for ClusterFuture ...
[17:01:31.998] - result already collected: FutureResult
[17:01:31.998] result() for ClusterFuture ... done
[17:01:31.998] - relayed: [n=2] TRUE, FALSE
[17:01:31.998] - queued futures: [n=2] TRUE, TRUE
[17:01:31.998] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:31.998]  length: 0 (resolved future 1)
[17:01:31.998] Relaying remaining futures
[17:01:31.998] signalConditionsASAP(NULL, pos=0) ...
[17:01:31.998] - nx: 2
[17:01:31.998] - relay: TRUE
[17:01:31.999] - stdout: TRUE
[17:01:31.999] - signal: TRUE
[17:01:31.999] - resignal: FALSE
[17:01:31.999] - force: TRUE
[17:01:31.999] - relayed: [n=2] TRUE, FALSE
[17:01:31.999] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:31.999]  - relaying element #2
[17:01:31.999] result() for ClusterFuture ...
[17:01:31.999] - result already collected: FutureResult
[17:01:31.999] result() for ClusterFuture ... done
[17:01:32.000] result() for ClusterFuture ...
[17:01:32.000] - result already collected: FutureResult
[17:01:32.000] result() for ClusterFuture ... done
[17:01:32.000] result() for ClusterFuture ...
[17:01:32.000] - result already collected: FutureResult
[17:01:32.000] result() for ClusterFuture ... done
[17:01:32.000] result() for ClusterFuture ...
[17:01:32.000] - result already collected: FutureResult
[17:01:32.000] result() for ClusterFuture ... done
[17:01:32.000] - relayed: [n=2] TRUE, TRUE
[17:01:32.000] - queued futures: [n=2] TRUE, TRUE
[17:01:32.000] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:01:32.001] resolve() on list ... DONE
[17:01:32.001] result() for ClusterFuture ...
[17:01:32.001] - result already collected: FutureResult
[17:01:32.001] result() for ClusterFuture ... done
[17:01:32.001] result() for ClusterFuture ...
[17:01:32.001] - result already collected: FutureResult
[17:01:32.001] result() for ClusterFuture ... done
[17:01:32.001] result() for ClusterFuture ...
[17:01:32.001] - result already collected: FutureResult
[17:01:32.001] result() for ClusterFuture ... done
[17:01:32.001] result() for ClusterFuture ...
[17:01:32.001] - result already collected: FutureResult
[17:01:32.002] result() for ClusterFuture ... done
[17:01:32.002]  - Number of value chunks collected: 2
[17:01:32.002] Resolving 2 futures (chunks) ... DONE
[17:01:32.002] Reducing values from 2 chunks ...
[17:01:32.002]  - Number of values collected after concatenation: 2
[17:01:32.002]  - Number of values expected: 2
[17:01:32.002] Reducing values from 2 chunks ... DONE
[17:01:32.002] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:01:32.003] future_mapply() ...
[17:01:32.007] Number of chunks: 2
[17:01:32.007] getGlobalsAndPackagesXApply() ...
[17:01:32.007]  - future.globals: TRUE
[17:01:32.007] getGlobalsAndPackages() ...
[17:01:32.007] Searching for globals...
[17:01:32.009] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:32.009] Searching for globals ... DONE
[17:01:32.009] Resolving globals: FALSE
[17:01:32.010] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:32.010] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:32.010] - globals: [1] ‘FUN’
[17:01:32.010] 
[17:01:32.010] getGlobalsAndPackages() ... DONE
[17:01:32.010]  - globals found/used: [n=1] ‘FUN’
[17:01:32.011]  - needed namespaces: [n=0] 
[17:01:32.011] Finding globals ... DONE
[17:01:32.011] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:32.011] List of 2
[17:01:32.011]  $ ...future.FUN:function (x, y)  
[17:01:32.011]  $ MoreArgs     : NULL
[17:01:32.011]  - attr(*, "where")=List of 2
[17:01:32.011]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:32.011]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:32.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:32.011]  - attr(*, "resolved")= logi FALSE
[17:01:32.011]  - attr(*, "total_size")= num NA
[17:01:32.013] Packages to be attached in all futures: [n=0] 
[17:01:32.014] getGlobalsAndPackagesXApply() ... DONE
[17:01:32.014] Number of futures (= number of chunks): 2
[17:01:32.014] Launching 2 futures (chunks) ...
[17:01:32.014] Chunk #1 of 2 ...
[17:01:32.014]  - Finding globals in '...' for chunk #1 ...
[17:01:32.014] getGlobalsAndPackages() ...
[17:01:32.014] Searching for globals...
[17:01:32.015] 
[17:01:32.015] Searching for globals ... DONE
[17:01:32.015] - globals: [0] <none>
[17:01:32.015] getGlobalsAndPackages() ... DONE
[17:01:32.015]    + additional globals found: [n=0] 
[17:01:32.015]    + additional namespaces needed: [n=0] 
[17:01:32.015]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:32.015]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:32.015]  - seeds: <none>
[17:01:32.015]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.016] getGlobalsAndPackages() ...
[17:01:32.016] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.016] Resolving globals: FALSE
[17:01:32.016] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:32.017] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:32.017] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.017] 
[17:01:32.017] getGlobalsAndPackages() ... DONE
[17:01:32.017] run() for ‘Future’ ...
[17:01:32.017] - state: ‘created’
[17:01:32.018] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:32.032] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:32.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:32.032]   - Field: ‘node’
[17:01:32.032]   - Field: ‘label’
[17:01:32.032]   - Field: ‘local’
[17:01:32.032]   - Field: ‘owner’
[17:01:32.032]   - Field: ‘envir’
[17:01:32.032]   - Field: ‘workers’
[17:01:32.033]   - Field: ‘packages’
[17:01:32.033]   - Field: ‘gc’
[17:01:32.033]   - Field: ‘conditions’
[17:01:32.033]   - Field: ‘persistent’
[17:01:32.033]   - Field: ‘expr’
[17:01:32.033]   - Field: ‘uuid’
[17:01:32.033]   - Field: ‘seed’
[17:01:32.033]   - Field: ‘version’
[17:01:32.033]   - Field: ‘result’
[17:01:32.033]   - Field: ‘asynchronous’
[17:01:32.033]   - Field: ‘calls’
[17:01:32.034]   - Field: ‘globals’
[17:01:32.034]   - Field: ‘stdout’
[17:01:32.034]   - Field: ‘earlySignal’
[17:01:32.034]   - Field: ‘lazy’
[17:01:32.034]   - Field: ‘state’
[17:01:32.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:32.034] - Launch lazy future ...
[17:01:32.034] Packages needed by the future expression (n = 0): <none>
[17:01:32.034] Packages needed by future strategies (n = 0): <none>
[17:01:32.035] {
[17:01:32.035]     {
[17:01:32.035]         {
[17:01:32.035]             ...future.startTime <- base::Sys.time()
[17:01:32.035]             {
[17:01:32.035]                 {
[17:01:32.035]                   {
[17:01:32.035]                     {
[17:01:32.035]                       base::local({
[17:01:32.035]                         has_future <- base::requireNamespace("future", 
[17:01:32.035]                           quietly = TRUE)
[17:01:32.035]                         if (has_future) {
[17:01:32.035]                           ns <- base::getNamespace("future")
[17:01:32.035]                           version <- ns[[".package"]][["version"]]
[17:01:32.035]                           if (is.null(version)) 
[17:01:32.035]                             version <- utils::packageVersion("future")
[17:01:32.035]                         }
[17:01:32.035]                         else {
[17:01:32.035]                           version <- NULL
[17:01:32.035]                         }
[17:01:32.035]                         if (!has_future || version < "1.8.0") {
[17:01:32.035]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:32.035]                             "", base::R.version$version.string), 
[17:01:32.035]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:32.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:32.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:32.035]                               "release", "version")], collapse = " "), 
[17:01:32.035]                             hostname = base::Sys.info()[["nodename"]])
[17:01:32.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:32.035]                             info)
[17:01:32.035]                           info <- base::paste(info, collapse = "; ")
[17:01:32.035]                           if (!has_future) {
[17:01:32.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:32.035]                               info)
[17:01:32.035]                           }
[17:01:32.035]                           else {
[17:01:32.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:32.035]                               info, version)
[17:01:32.035]                           }
[17:01:32.035]                           base::stop(msg)
[17:01:32.035]                         }
[17:01:32.035]                       })
[17:01:32.035]                     }
[17:01:32.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:32.035]                     base::options(mc.cores = 1L)
[17:01:32.035]                   }
[17:01:32.035]                   ...future.strategy.old <- future::plan("list")
[17:01:32.035]                   options(future.plan = NULL)
[17:01:32.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:32.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:32.035]                 }
[17:01:32.035]                 ...future.workdir <- getwd()
[17:01:32.035]             }
[17:01:32.035]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:32.035]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:32.035]         }
[17:01:32.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:32.035]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:32.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:32.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:32.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:32.035]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:32.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:32.035]             base::names(...future.oldOptions))
[17:01:32.035]     }
[17:01:32.035]     if (FALSE) {
[17:01:32.035]     }
[17:01:32.035]     else {
[17:01:32.035]         if (TRUE) {
[17:01:32.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:32.035]                 open = "w")
[17:01:32.035]         }
[17:01:32.035]         else {
[17:01:32.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:32.035]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:32.035]         }
[17:01:32.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:32.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:32.035]             base::sink(type = "output", split = FALSE)
[17:01:32.035]             base::close(...future.stdout)
[17:01:32.035]         }, add = TRUE)
[17:01:32.035]     }
[17:01:32.035]     ...future.frame <- base::sys.nframe()
[17:01:32.035]     ...future.conditions <- base::list()
[17:01:32.035]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:32.035]     if (FALSE) {
[17:01:32.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:32.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:32.035]     }
[17:01:32.035]     ...future.result <- base::tryCatch({
[17:01:32.035]         base::withCallingHandlers({
[17:01:32.035]             ...future.value <- base::withVisible(base::local({
[17:01:32.035]                 ...future.makeSendCondition <- base::local({
[17:01:32.035]                   sendCondition <- NULL
[17:01:32.035]                   function(frame = 1L) {
[17:01:32.035]                     if (is.function(sendCondition)) 
[17:01:32.035]                       return(sendCondition)
[17:01:32.035]                     ns <- getNamespace("parallel")
[17:01:32.035]                     if (exists("sendData", mode = "function", 
[17:01:32.035]                       envir = ns)) {
[17:01:32.035]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:32.035]                         envir = ns)
[17:01:32.035]                       envir <- sys.frame(frame)
[17:01:32.035]                       master <- NULL
[17:01:32.035]                       while (!identical(envir, .GlobalEnv) && 
[17:01:32.035]                         !identical(envir, emptyenv())) {
[17:01:32.035]                         if (exists("master", mode = "list", envir = envir, 
[17:01:32.035]                           inherits = FALSE)) {
[17:01:32.035]                           master <- get("master", mode = "list", 
[17:01:32.035]                             envir = envir, inherits = FALSE)
[17:01:32.035]                           if (inherits(master, c("SOCKnode", 
[17:01:32.035]                             "SOCK0node"))) {
[17:01:32.035]                             sendCondition <<- function(cond) {
[17:01:32.035]                               data <- list(type = "VALUE", value = cond, 
[17:01:32.035]                                 success = TRUE)
[17:01:32.035]                               parallel_sendData(master, data)
[17:01:32.035]                             }
[17:01:32.035]                             return(sendCondition)
[17:01:32.035]                           }
[17:01:32.035]                         }
[17:01:32.035]                         frame <- frame + 1L
[17:01:32.035]                         envir <- sys.frame(frame)
[17:01:32.035]                       }
[17:01:32.035]                     }
[17:01:32.035]                     sendCondition <<- function(cond) NULL
[17:01:32.035]                   }
[17:01:32.035]                 })
[17:01:32.035]                 withCallingHandlers({
[17:01:32.035]                   {
[17:01:32.035]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:32.035]                     if (!identical(...future.globals.maxSize.org, 
[17:01:32.035]                       ...future.globals.maxSize)) {
[17:01:32.035]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:32.035]                       on.exit(options(oopts), add = TRUE)
[17:01:32.035]                     }
[17:01:32.035]                     {
[17:01:32.035]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:32.035]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:32.035]                         USE.NAMES = FALSE)
[17:01:32.035]                       do.call(mapply, args = args)
[17:01:32.035]                     }
[17:01:32.035]                   }
[17:01:32.035]                 }, immediateCondition = function(cond) {
[17:01:32.035]                   sendCondition <- ...future.makeSendCondition()
[17:01:32.035]                   sendCondition(cond)
[17:01:32.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.035]                   {
[17:01:32.035]                     inherits <- base::inherits
[17:01:32.035]                     invokeRestart <- base::invokeRestart
[17:01:32.035]                     is.null <- base::is.null
[17:01:32.035]                     muffled <- FALSE
[17:01:32.035]                     if (inherits(cond, "message")) {
[17:01:32.035]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:32.035]                       if (muffled) 
[17:01:32.035]                         invokeRestart("muffleMessage")
[17:01:32.035]                     }
[17:01:32.035]                     else if (inherits(cond, "warning")) {
[17:01:32.035]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:32.035]                       if (muffled) 
[17:01:32.035]                         invokeRestart("muffleWarning")
[17:01:32.035]                     }
[17:01:32.035]                     else if (inherits(cond, "condition")) {
[17:01:32.035]                       if (!is.null(pattern)) {
[17:01:32.035]                         computeRestarts <- base::computeRestarts
[17:01:32.035]                         grepl <- base::grepl
[17:01:32.035]                         restarts <- computeRestarts(cond)
[17:01:32.035]                         for (restart in restarts) {
[17:01:32.035]                           name <- restart$name
[17:01:32.035]                           if (is.null(name)) 
[17:01:32.035]                             next
[17:01:32.035]                           if (!grepl(pattern, name)) 
[17:01:32.035]                             next
[17:01:32.035]                           invokeRestart(restart)
[17:01:32.035]                           muffled <- TRUE
[17:01:32.035]                           break
[17:01:32.035]                         }
[17:01:32.035]                       }
[17:01:32.035]                     }
[17:01:32.035]                     invisible(muffled)
[17:01:32.035]                   }
[17:01:32.035]                   muffleCondition(cond)
[17:01:32.035]                 })
[17:01:32.035]             }))
[17:01:32.035]             future::FutureResult(value = ...future.value$value, 
[17:01:32.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:32.035]                   ...future.rng), globalenv = if (FALSE) 
[17:01:32.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:32.035]                     ...future.globalenv.names))
[17:01:32.035]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:32.035]         }, condition = base::local({
[17:01:32.035]             c <- base::c
[17:01:32.035]             inherits <- base::inherits
[17:01:32.035]             invokeRestart <- base::invokeRestart
[17:01:32.035]             length <- base::length
[17:01:32.035]             list <- base::list
[17:01:32.035]             seq.int <- base::seq.int
[17:01:32.035]             signalCondition <- base::signalCondition
[17:01:32.035]             sys.calls <- base::sys.calls
[17:01:32.035]             `[[` <- base::`[[`
[17:01:32.035]             `+` <- base::`+`
[17:01:32.035]             `<<-` <- base::`<<-`
[17:01:32.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:32.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:32.035]                   3L)]
[17:01:32.035]             }
[17:01:32.035]             function(cond) {
[17:01:32.035]                 is_error <- inherits(cond, "error")
[17:01:32.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:32.035]                   NULL)
[17:01:32.035]                 if (is_error) {
[17:01:32.035]                   sessionInformation <- function() {
[17:01:32.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:32.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:32.035]                       search = base::search(), system = base::Sys.info())
[17:01:32.035]                   }
[17:01:32.035]                   ...future.conditions[[length(...future.conditions) + 
[17:01:32.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:32.035]                     cond$call), session = sessionInformation(), 
[17:01:32.035]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:32.035]                   signalCondition(cond)
[17:01:32.035]                 }
[17:01:32.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:32.035]                 "immediateCondition"))) {
[17:01:32.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:32.035]                   ...future.conditions[[length(...future.conditions) + 
[17:01:32.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:32.035]                   if (TRUE && !signal) {
[17:01:32.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.035]                     {
[17:01:32.035]                       inherits <- base::inherits
[17:01:32.035]                       invokeRestart <- base::invokeRestart
[17:01:32.035]                       is.null <- base::is.null
[17:01:32.035]                       muffled <- FALSE
[17:01:32.035]                       if (inherits(cond, "message")) {
[17:01:32.035]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:32.035]                         if (muffled) 
[17:01:32.035]                           invokeRestart("muffleMessage")
[17:01:32.035]                       }
[17:01:32.035]                       else if (inherits(cond, "warning")) {
[17:01:32.035]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:32.035]                         if (muffled) 
[17:01:32.035]                           invokeRestart("muffleWarning")
[17:01:32.035]                       }
[17:01:32.035]                       else if (inherits(cond, "condition")) {
[17:01:32.035]                         if (!is.null(pattern)) {
[17:01:32.035]                           computeRestarts <- base::computeRestarts
[17:01:32.035]                           grepl <- base::grepl
[17:01:32.035]                           restarts <- computeRestarts(cond)
[17:01:32.035]                           for (restart in restarts) {
[17:01:32.035]                             name <- restart$name
[17:01:32.035]                             if (is.null(name)) 
[17:01:32.035]                               next
[17:01:32.035]                             if (!grepl(pattern, name)) 
[17:01:32.035]                               next
[17:01:32.035]                             invokeRestart(restart)
[17:01:32.035]                             muffled <- TRUE
[17:01:32.035]                             break
[17:01:32.035]                           }
[17:01:32.035]                         }
[17:01:32.035]                       }
[17:01:32.035]                       invisible(muffled)
[17:01:32.035]                     }
[17:01:32.035]                     muffleCondition(cond, pattern = "^muffle")
[17:01:32.035]                   }
[17:01:32.035]                 }
[17:01:32.035]                 else {
[17:01:32.035]                   if (TRUE) {
[17:01:32.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.035]                     {
[17:01:32.035]                       inherits <- base::inherits
[17:01:32.035]                       invokeRestart <- base::invokeRestart
[17:01:32.035]                       is.null <- base::is.null
[17:01:32.035]                       muffled <- FALSE
[17:01:32.035]                       if (inherits(cond, "message")) {
[17:01:32.035]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:32.035]                         if (muffled) 
[17:01:32.035]                           invokeRestart("muffleMessage")
[17:01:32.035]                       }
[17:01:32.035]                       else if (inherits(cond, "warning")) {
[17:01:32.035]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:32.035]                         if (muffled) 
[17:01:32.035]                           invokeRestart("muffleWarning")
[17:01:32.035]                       }
[17:01:32.035]                       else if (inherits(cond, "condition")) {
[17:01:32.035]                         if (!is.null(pattern)) {
[17:01:32.035]                           computeRestarts <- base::computeRestarts
[17:01:32.035]                           grepl <- base::grepl
[17:01:32.035]                           restarts <- computeRestarts(cond)
[17:01:32.035]                           for (restart in restarts) {
[17:01:32.035]                             name <- restart$name
[17:01:32.035]                             if (is.null(name)) 
[17:01:32.035]                               next
[17:01:32.035]                             if (!grepl(pattern, name)) 
[17:01:32.035]                               next
[17:01:32.035]                             invokeRestart(restart)
[17:01:32.035]                             muffled <- TRUE
[17:01:32.035]                             break
[17:01:32.035]                           }
[17:01:32.035]                         }
[17:01:32.035]                       }
[17:01:32.035]                       invisible(muffled)
[17:01:32.035]                     }
[17:01:32.035]                     muffleCondition(cond, pattern = "^muffle")
[17:01:32.035]                   }
[17:01:32.035]                 }
[17:01:32.035]             }
[17:01:32.035]         }))
[17:01:32.035]     }, error = function(ex) {
[17:01:32.035]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:32.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:32.035]                 ...future.rng), started = ...future.startTime, 
[17:01:32.035]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:32.035]             version = "1.8"), class = "FutureResult")
[17:01:32.035]     }, finally = {
[17:01:32.035]         if (!identical(...future.workdir, getwd())) 
[17:01:32.035]             setwd(...future.workdir)
[17:01:32.035]         {
[17:01:32.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:32.035]                 ...future.oldOptions$nwarnings <- NULL
[17:01:32.035]             }
[17:01:32.035]             base::options(...future.oldOptions)
[17:01:32.035]             if (.Platform$OS.type == "windows") {
[17:01:32.035]                 old_names <- names(...future.oldEnvVars)
[17:01:32.035]                 envs <- base::Sys.getenv()
[17:01:32.035]                 names <- names(envs)
[17:01:32.035]                 common <- intersect(names, old_names)
[17:01:32.035]                 added <- setdiff(names, old_names)
[17:01:32.035]                 removed <- setdiff(old_names, names)
[17:01:32.035]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:32.035]                   envs[common]]
[17:01:32.035]                 NAMES <- toupper(changed)
[17:01:32.035]                 args <- list()
[17:01:32.035]                 for (kk in seq_along(NAMES)) {
[17:01:32.035]                   name <- changed[[kk]]
[17:01:32.035]                   NAME <- NAMES[[kk]]
[17:01:32.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.035]                     next
[17:01:32.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:32.035]                 }
[17:01:32.035]                 NAMES <- toupper(added)
[17:01:32.035]                 for (kk in seq_along(NAMES)) {
[17:01:32.035]                   name <- added[[kk]]
[17:01:32.035]                   NAME <- NAMES[[kk]]
[17:01:32.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.035]                     next
[17:01:32.035]                   args[[name]] <- ""
[17:01:32.035]                 }
[17:01:32.035]                 NAMES <- toupper(removed)
[17:01:32.035]                 for (kk in seq_along(NAMES)) {
[17:01:32.035]                   name <- removed[[kk]]
[17:01:32.035]                   NAME <- NAMES[[kk]]
[17:01:32.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.035]                     next
[17:01:32.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:32.035]                 }
[17:01:32.035]                 if (length(args) > 0) 
[17:01:32.035]                   base::do.call(base::Sys.setenv, args = args)
[17:01:32.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:32.035]             }
[17:01:32.035]             else {
[17:01:32.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:32.035]             }
[17:01:32.035]             {
[17:01:32.035]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:32.035]                   0L) {
[17:01:32.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:32.035]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:32.035]                   base::options(opts)
[17:01:32.035]                 }
[17:01:32.035]                 {
[17:01:32.035]                   {
[17:01:32.035]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:32.035]                     NULL
[17:01:32.035]                   }
[17:01:32.035]                   options(future.plan = NULL)
[17:01:32.035]                   if (is.na(NA_character_)) 
[17:01:32.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:32.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:32.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:32.035]                     .init = FALSE)
[17:01:32.035]                 }
[17:01:32.035]             }
[17:01:32.035]         }
[17:01:32.035]     })
[17:01:32.035]     if (TRUE) {
[17:01:32.035]         base::sink(type = "output", split = FALSE)
[17:01:32.035]         if (TRUE) {
[17:01:32.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:32.035]         }
[17:01:32.035]         else {
[17:01:32.035]             ...future.result["stdout"] <- base::list(NULL)
[17:01:32.035]         }
[17:01:32.035]         base::close(...future.stdout)
[17:01:32.035]         ...future.stdout <- NULL
[17:01:32.035]     }
[17:01:32.035]     ...future.result$conditions <- ...future.conditions
[17:01:32.035]     ...future.result$finished <- base::Sys.time()
[17:01:32.035]     ...future.result
[17:01:32.035] }
[17:01:32.038] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:01:32.038] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:01:32.038] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:01:32.038] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:01:32.039] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:01:32.039] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:01:32.039] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:01:32.039] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:32.040] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:32.040] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:32.040] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:32.040] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:01:32.041] MultisessionFuture started
[17:01:32.041] - Launch lazy future ... done
[17:01:32.041] run() for ‘MultisessionFuture’ ... done
[17:01:32.041] Created future:
[17:01:32.041] MultisessionFuture:
[17:01:32.041] Label: ‘future_mapply-1’
[17:01:32.041] Expression:
[17:01:32.041] {
[17:01:32.041]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:32.041]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:32.041]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:32.041]         on.exit(options(oopts), add = TRUE)
[17:01:32.041]     }
[17:01:32.041]     {
[17:01:32.041]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:32.041]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:32.041]         do.call(mapply, args = args)
[17:01:32.041]     }
[17:01:32.041] }
[17:01:32.041] Lazy evaluation: FALSE
[17:01:32.041] Asynchronous evaluation: TRUE
[17:01:32.041] Local evaluation: TRUE
[17:01:32.041] Environment: R_GlobalEnv
[17:01:32.041] Capture standard output: TRUE
[17:01:32.041] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:32.041] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:32.041] Packages: <none>
[17:01:32.041] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:32.041] Resolved: FALSE
[17:01:32.041] Value: <not collected>
[17:01:32.041] Conditions captured: <none>
[17:01:32.041] Early signaling: FALSE
[17:01:32.041] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:32.041] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:32.052] Chunk #1 of 2 ... DONE
[17:01:32.053] Chunk #2 of 2 ...
[17:01:32.053]  - Finding globals in '...' for chunk #2 ...
[17:01:32.053] getGlobalsAndPackages() ...
[17:01:32.053] Searching for globals...
[17:01:32.053] 
[17:01:32.053] Searching for globals ... DONE
[17:01:32.053] - globals: [0] <none>
[17:01:32.054] getGlobalsAndPackages() ... DONE
[17:01:32.054]    + additional globals found: [n=0] 
[17:01:32.054]    + additional namespaces needed: [n=0] 
[17:01:32.054]  - Finding globals in '...' for chunk #2 ... DONE
[17:01:32.054]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:32.054]  - seeds: <none>
[17:01:32.054]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.054] getGlobalsAndPackages() ...
[17:01:32.054] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.054] Resolving globals: FALSE
[17:01:32.055] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:32.055] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:32.056] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.056] 
[17:01:32.056] getGlobalsAndPackages() ... DONE
[17:01:32.056] run() for ‘Future’ ...
[17:01:32.056] - state: ‘created’
[17:01:32.056] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:32.071] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:32.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:32.071]   - Field: ‘node’
[17:01:32.071]   - Field: ‘label’
[17:01:32.071]   - Field: ‘local’
[17:01:32.071]   - Field: ‘owner’
[17:01:32.072]   - Field: ‘envir’
[17:01:32.072]   - Field: ‘workers’
[17:01:32.072]   - Field: ‘packages’
[17:01:32.072]   - Field: ‘gc’
[17:01:32.072]   - Field: ‘conditions’
[17:01:32.072]   - Field: ‘persistent’
[17:01:32.072]   - Field: ‘expr’
[17:01:32.072]   - Field: ‘uuid’
[17:01:32.072]   - Field: ‘seed’
[17:01:32.072]   - Field: ‘version’
[17:01:32.072]   - Field: ‘result’
[17:01:32.075]   - Field: ‘asynchronous’
[17:01:32.075]   - Field: ‘calls’
[17:01:32.075]   - Field: ‘globals’
[17:01:32.075]   - Field: ‘stdout’
[17:01:32.075]   - Field: ‘earlySignal’
[17:01:32.075]   - Field: ‘lazy’
[17:01:32.075]   - Field: ‘state’
[17:01:32.075] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:32.075] - Launch lazy future ...
[17:01:32.076] Packages needed by the future expression (n = 0): <none>
[17:01:32.076] Packages needed by future strategies (n = 0): <none>
[17:01:32.076] {
[17:01:32.076]     {
[17:01:32.076]         {
[17:01:32.076]             ...future.startTime <- base::Sys.time()
[17:01:32.076]             {
[17:01:32.076]                 {
[17:01:32.076]                   {
[17:01:32.076]                     {
[17:01:32.076]                       base::local({
[17:01:32.076]                         has_future <- base::requireNamespace("future", 
[17:01:32.076]                           quietly = TRUE)
[17:01:32.076]                         if (has_future) {
[17:01:32.076]                           ns <- base::getNamespace("future")
[17:01:32.076]                           version <- ns[[".package"]][["version"]]
[17:01:32.076]                           if (is.null(version)) 
[17:01:32.076]                             version <- utils::packageVersion("future")
[17:01:32.076]                         }
[17:01:32.076]                         else {
[17:01:32.076]                           version <- NULL
[17:01:32.076]                         }
[17:01:32.076]                         if (!has_future || version < "1.8.0") {
[17:01:32.076]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:32.076]                             "", base::R.version$version.string), 
[17:01:32.076]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:32.076]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:32.076]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:32.076]                               "release", "version")], collapse = " "), 
[17:01:32.076]                             hostname = base::Sys.info()[["nodename"]])
[17:01:32.076]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:32.076]                             info)
[17:01:32.076]                           info <- base::paste(info, collapse = "; ")
[17:01:32.076]                           if (!has_future) {
[17:01:32.076]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:32.076]                               info)
[17:01:32.076]                           }
[17:01:32.076]                           else {
[17:01:32.076]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:32.076]                               info, version)
[17:01:32.076]                           }
[17:01:32.076]                           base::stop(msg)
[17:01:32.076]                         }
[17:01:32.076]                       })
[17:01:32.076]                     }
[17:01:32.076]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:32.076]                     base::options(mc.cores = 1L)
[17:01:32.076]                   }
[17:01:32.076]                   ...future.strategy.old <- future::plan("list")
[17:01:32.076]                   options(future.plan = NULL)
[17:01:32.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:32.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:32.076]                 }
[17:01:32.076]                 ...future.workdir <- getwd()
[17:01:32.076]             }
[17:01:32.076]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:32.076]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:32.076]         }
[17:01:32.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:32.076]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:32.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:32.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:32.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:32.076]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:32.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:32.076]             base::names(...future.oldOptions))
[17:01:32.076]     }
[17:01:32.076]     if (FALSE) {
[17:01:32.076]     }
[17:01:32.076]     else {
[17:01:32.076]         if (TRUE) {
[17:01:32.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:32.076]                 open = "w")
[17:01:32.076]         }
[17:01:32.076]         else {
[17:01:32.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:32.076]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:32.076]         }
[17:01:32.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:32.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:32.076]             base::sink(type = "output", split = FALSE)
[17:01:32.076]             base::close(...future.stdout)
[17:01:32.076]         }, add = TRUE)
[17:01:32.076]     }
[17:01:32.076]     ...future.frame <- base::sys.nframe()
[17:01:32.076]     ...future.conditions <- base::list()
[17:01:32.076]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:32.076]     if (FALSE) {
[17:01:32.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:32.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:32.076]     }
[17:01:32.076]     ...future.result <- base::tryCatch({
[17:01:32.076]         base::withCallingHandlers({
[17:01:32.076]             ...future.value <- base::withVisible(base::local({
[17:01:32.076]                 ...future.makeSendCondition <- base::local({
[17:01:32.076]                   sendCondition <- NULL
[17:01:32.076]                   function(frame = 1L) {
[17:01:32.076]                     if (is.function(sendCondition)) 
[17:01:32.076]                       return(sendCondition)
[17:01:32.076]                     ns <- getNamespace("parallel")
[17:01:32.076]                     if (exists("sendData", mode = "function", 
[17:01:32.076]                       envir = ns)) {
[17:01:32.076]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:32.076]                         envir = ns)
[17:01:32.076]                       envir <- sys.frame(frame)
[17:01:32.076]                       master <- NULL
[17:01:32.076]                       while (!identical(envir, .GlobalEnv) && 
[17:01:32.076]                         !identical(envir, emptyenv())) {
[17:01:32.076]                         if (exists("master", mode = "list", envir = envir, 
[17:01:32.076]                           inherits = FALSE)) {
[17:01:32.076]                           master <- get("master", mode = "list", 
[17:01:32.076]                             envir = envir, inherits = FALSE)
[17:01:32.076]                           if (inherits(master, c("SOCKnode", 
[17:01:32.076]                             "SOCK0node"))) {
[17:01:32.076]                             sendCondition <<- function(cond) {
[17:01:32.076]                               data <- list(type = "VALUE", value = cond, 
[17:01:32.076]                                 success = TRUE)
[17:01:32.076]                               parallel_sendData(master, data)
[17:01:32.076]                             }
[17:01:32.076]                             return(sendCondition)
[17:01:32.076]                           }
[17:01:32.076]                         }
[17:01:32.076]                         frame <- frame + 1L
[17:01:32.076]                         envir <- sys.frame(frame)
[17:01:32.076]                       }
[17:01:32.076]                     }
[17:01:32.076]                     sendCondition <<- function(cond) NULL
[17:01:32.076]                   }
[17:01:32.076]                 })
[17:01:32.076]                 withCallingHandlers({
[17:01:32.076]                   {
[17:01:32.076]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:32.076]                     if (!identical(...future.globals.maxSize.org, 
[17:01:32.076]                       ...future.globals.maxSize)) {
[17:01:32.076]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:32.076]                       on.exit(options(oopts), add = TRUE)
[17:01:32.076]                     }
[17:01:32.076]                     {
[17:01:32.076]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:32.076]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:32.076]                         USE.NAMES = FALSE)
[17:01:32.076]                       do.call(mapply, args = args)
[17:01:32.076]                     }
[17:01:32.076]                   }
[17:01:32.076]                 }, immediateCondition = function(cond) {
[17:01:32.076]                   sendCondition <- ...future.makeSendCondition()
[17:01:32.076]                   sendCondition(cond)
[17:01:32.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.076]                   {
[17:01:32.076]                     inherits <- base::inherits
[17:01:32.076]                     invokeRestart <- base::invokeRestart
[17:01:32.076]                     is.null <- base::is.null
[17:01:32.076]                     muffled <- FALSE
[17:01:32.076]                     if (inherits(cond, "message")) {
[17:01:32.076]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:32.076]                       if (muffled) 
[17:01:32.076]                         invokeRestart("muffleMessage")
[17:01:32.076]                     }
[17:01:32.076]                     else if (inherits(cond, "warning")) {
[17:01:32.076]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:32.076]                       if (muffled) 
[17:01:32.076]                         invokeRestart("muffleWarning")
[17:01:32.076]                     }
[17:01:32.076]                     else if (inherits(cond, "condition")) {
[17:01:32.076]                       if (!is.null(pattern)) {
[17:01:32.076]                         computeRestarts <- base::computeRestarts
[17:01:32.076]                         grepl <- base::grepl
[17:01:32.076]                         restarts <- computeRestarts(cond)
[17:01:32.076]                         for (restart in restarts) {
[17:01:32.076]                           name <- restart$name
[17:01:32.076]                           if (is.null(name)) 
[17:01:32.076]                             next
[17:01:32.076]                           if (!grepl(pattern, name)) 
[17:01:32.076]                             next
[17:01:32.076]                           invokeRestart(restart)
[17:01:32.076]                           muffled <- TRUE
[17:01:32.076]                           break
[17:01:32.076]                         }
[17:01:32.076]                       }
[17:01:32.076]                     }
[17:01:32.076]                     invisible(muffled)
[17:01:32.076]                   }
[17:01:32.076]                   muffleCondition(cond)
[17:01:32.076]                 })
[17:01:32.076]             }))
[17:01:32.076]             future::FutureResult(value = ...future.value$value, 
[17:01:32.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:32.076]                   ...future.rng), globalenv = if (FALSE) 
[17:01:32.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:32.076]                     ...future.globalenv.names))
[17:01:32.076]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:32.076]         }, condition = base::local({
[17:01:32.076]             c <- base::c
[17:01:32.076]             inherits <- base::inherits
[17:01:32.076]             invokeRestart <- base::invokeRestart
[17:01:32.076]             length <- base::length
[17:01:32.076]             list <- base::list
[17:01:32.076]             seq.int <- base::seq.int
[17:01:32.076]             signalCondition <- base::signalCondition
[17:01:32.076]             sys.calls <- base::sys.calls
[17:01:32.076]             `[[` <- base::`[[`
[17:01:32.076]             `+` <- base::`+`
[17:01:32.076]             `<<-` <- base::`<<-`
[17:01:32.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:32.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:32.076]                   3L)]
[17:01:32.076]             }
[17:01:32.076]             function(cond) {
[17:01:32.076]                 is_error <- inherits(cond, "error")
[17:01:32.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:32.076]                   NULL)
[17:01:32.076]                 if (is_error) {
[17:01:32.076]                   sessionInformation <- function() {
[17:01:32.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:32.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:32.076]                       search = base::search(), system = base::Sys.info())
[17:01:32.076]                   }
[17:01:32.076]                   ...future.conditions[[length(...future.conditions) + 
[17:01:32.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:32.076]                     cond$call), session = sessionInformation(), 
[17:01:32.076]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:32.076]                   signalCondition(cond)
[17:01:32.076]                 }
[17:01:32.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:32.076]                 "immediateCondition"))) {
[17:01:32.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:32.076]                   ...future.conditions[[length(...future.conditions) + 
[17:01:32.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:32.076]                   if (TRUE && !signal) {
[17:01:32.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.076]                     {
[17:01:32.076]                       inherits <- base::inherits
[17:01:32.076]                       invokeRestart <- base::invokeRestart
[17:01:32.076]                       is.null <- base::is.null
[17:01:32.076]                       muffled <- FALSE
[17:01:32.076]                       if (inherits(cond, "message")) {
[17:01:32.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:32.076]                         if (muffled) 
[17:01:32.076]                           invokeRestart("muffleMessage")
[17:01:32.076]                       }
[17:01:32.076]                       else if (inherits(cond, "warning")) {
[17:01:32.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:32.076]                         if (muffled) 
[17:01:32.076]                           invokeRestart("muffleWarning")
[17:01:32.076]                       }
[17:01:32.076]                       else if (inherits(cond, "condition")) {
[17:01:32.076]                         if (!is.null(pattern)) {
[17:01:32.076]                           computeRestarts <- base::computeRestarts
[17:01:32.076]                           grepl <- base::grepl
[17:01:32.076]                           restarts <- computeRestarts(cond)
[17:01:32.076]                           for (restart in restarts) {
[17:01:32.076]                             name <- restart$name
[17:01:32.076]                             if (is.null(name)) 
[17:01:32.076]                               next
[17:01:32.076]                             if (!grepl(pattern, name)) 
[17:01:32.076]                               next
[17:01:32.076]                             invokeRestart(restart)
[17:01:32.076]                             muffled <- TRUE
[17:01:32.076]                             break
[17:01:32.076]                           }
[17:01:32.076]                         }
[17:01:32.076]                       }
[17:01:32.076]                       invisible(muffled)
[17:01:32.076]                     }
[17:01:32.076]                     muffleCondition(cond, pattern = "^muffle")
[17:01:32.076]                   }
[17:01:32.076]                 }
[17:01:32.076]                 else {
[17:01:32.076]                   if (TRUE) {
[17:01:32.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.076]                     {
[17:01:32.076]                       inherits <- base::inherits
[17:01:32.076]                       invokeRestart <- base::invokeRestart
[17:01:32.076]                       is.null <- base::is.null
[17:01:32.076]                       muffled <- FALSE
[17:01:32.076]                       if (inherits(cond, "message")) {
[17:01:32.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:32.076]                         if (muffled) 
[17:01:32.076]                           invokeRestart("muffleMessage")
[17:01:32.076]                       }
[17:01:32.076]                       else if (inherits(cond, "warning")) {
[17:01:32.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:32.076]                         if (muffled) 
[17:01:32.076]                           invokeRestart("muffleWarning")
[17:01:32.076]                       }
[17:01:32.076]                       else if (inherits(cond, "condition")) {
[17:01:32.076]                         if (!is.null(pattern)) {
[17:01:32.076]                           computeRestarts <- base::computeRestarts
[17:01:32.076]                           grepl <- base::grepl
[17:01:32.076]                           restarts <- computeRestarts(cond)
[17:01:32.076]                           for (restart in restarts) {
[17:01:32.076]                             name <- restart$name
[17:01:32.076]                             if (is.null(name)) 
[17:01:32.076]                               next
[17:01:32.076]                             if (!grepl(pattern, name)) 
[17:01:32.076]                               next
[17:01:32.076]                             invokeRestart(restart)
[17:01:32.076]                             muffled <- TRUE
[17:01:32.076]                             break
[17:01:32.076]                           }
[17:01:32.076]                         }
[17:01:32.076]                       }
[17:01:32.076]                       invisible(muffled)
[17:01:32.076]                     }
[17:01:32.076]                     muffleCondition(cond, pattern = "^muffle")
[17:01:32.076]                   }
[17:01:32.076]                 }
[17:01:32.076]             }
[17:01:32.076]         }))
[17:01:32.076]     }, error = function(ex) {
[17:01:32.076]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:32.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:32.076]                 ...future.rng), started = ...future.startTime, 
[17:01:32.076]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:32.076]             version = "1.8"), class = "FutureResult")
[17:01:32.076]     }, finally = {
[17:01:32.076]         if (!identical(...future.workdir, getwd())) 
[17:01:32.076]             setwd(...future.workdir)
[17:01:32.076]         {
[17:01:32.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:32.076]                 ...future.oldOptions$nwarnings <- NULL
[17:01:32.076]             }
[17:01:32.076]             base::options(...future.oldOptions)
[17:01:32.076]             if (.Platform$OS.type == "windows") {
[17:01:32.076]                 old_names <- names(...future.oldEnvVars)
[17:01:32.076]                 envs <- base::Sys.getenv()
[17:01:32.076]                 names <- names(envs)
[17:01:32.076]                 common <- intersect(names, old_names)
[17:01:32.076]                 added <- setdiff(names, old_names)
[17:01:32.076]                 removed <- setdiff(old_names, names)
[17:01:32.076]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:32.076]                   envs[common]]
[17:01:32.076]                 NAMES <- toupper(changed)
[17:01:32.076]                 args <- list()
[17:01:32.076]                 for (kk in seq_along(NAMES)) {
[17:01:32.076]                   name <- changed[[kk]]
[17:01:32.076]                   NAME <- NAMES[[kk]]
[17:01:32.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.076]                     next
[17:01:32.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:32.076]                 }
[17:01:32.076]                 NAMES <- toupper(added)
[17:01:32.076]                 for (kk in seq_along(NAMES)) {
[17:01:32.076]                   name <- added[[kk]]
[17:01:32.076]                   NAME <- NAMES[[kk]]
[17:01:32.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.076]                     next
[17:01:32.076]                   args[[name]] <- ""
[17:01:32.076]                 }
[17:01:32.076]                 NAMES <- toupper(removed)
[17:01:32.076]                 for (kk in seq_along(NAMES)) {
[17:01:32.076]                   name <- removed[[kk]]
[17:01:32.076]                   NAME <- NAMES[[kk]]
[17:01:32.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.076]                     next
[17:01:32.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:32.076]                 }
[17:01:32.076]                 if (length(args) > 0) 
[17:01:32.076]                   base::do.call(base::Sys.setenv, args = args)
[17:01:32.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:32.076]             }
[17:01:32.076]             else {
[17:01:32.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:32.076]             }
[17:01:32.076]             {
[17:01:32.076]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:32.076]                   0L) {
[17:01:32.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:32.076]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:32.076]                   base::options(opts)
[17:01:32.076]                 }
[17:01:32.076]                 {
[17:01:32.076]                   {
[17:01:32.076]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:32.076]                     NULL
[17:01:32.076]                   }
[17:01:32.076]                   options(future.plan = NULL)
[17:01:32.076]                   if (is.na(NA_character_)) 
[17:01:32.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:32.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:32.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:32.076]                     .init = FALSE)
[17:01:32.076]                 }
[17:01:32.076]             }
[17:01:32.076]         }
[17:01:32.076]     })
[17:01:32.076]     if (TRUE) {
[17:01:32.076]         base::sink(type = "output", split = FALSE)
[17:01:32.076]         if (TRUE) {
[17:01:32.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:32.076]         }
[17:01:32.076]         else {
[17:01:32.076]             ...future.result["stdout"] <- base::list(NULL)
[17:01:32.076]         }
[17:01:32.076]         base::close(...future.stdout)
[17:01:32.076]         ...future.stdout <- NULL
[17:01:32.076]     }
[17:01:32.076]     ...future.result$conditions <- ...future.conditions
[17:01:32.076]     ...future.result$finished <- base::Sys.time()
[17:01:32.076]     ...future.result
[17:01:32.076] }
[17:01:32.079] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:01:32.079] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:01:32.080] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:01:32.080] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:01:32.080] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:01:32.080] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:01:32.080] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:01:32.081] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:32.081] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:32.081] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:32.081] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:32.081] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:01:32.082] MultisessionFuture started
[17:01:32.082] - Launch lazy future ... done
[17:01:32.082] run() for ‘MultisessionFuture’ ... done
[17:01:32.082] Created future:
[17:01:32.082] MultisessionFuture:
[17:01:32.082] Label: ‘future_mapply-2’
[17:01:32.082] Expression:
[17:01:32.082] {
[17:01:32.082]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:32.082]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:32.082]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:32.082]         on.exit(options(oopts), add = TRUE)
[17:01:32.082]     }
[17:01:32.082]     {
[17:01:32.082]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:32.082]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:32.082]         do.call(mapply, args = args)
[17:01:32.082]     }
[17:01:32.082] }
[17:01:32.082] Lazy evaluation: FALSE
[17:01:32.082] Asynchronous evaluation: TRUE
[17:01:32.082] Local evaluation: TRUE
[17:01:32.082] Environment: R_GlobalEnv
[17:01:32.082] Capture standard output: TRUE
[17:01:32.082] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:32.082] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:32.082] Packages: <none>
[17:01:32.082] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:32.082] Resolved: FALSE
[17:01:32.082] Value: <not collected>
[17:01:32.082] Conditions captured: <none>
[17:01:32.082] Early signaling: FALSE
[17:01:32.082] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:32.082] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:32.094] Chunk #2 of 2 ... DONE
[17:01:32.094] Launching 2 futures (chunks) ... DONE
[17:01:32.094] Resolving 2 futures (chunks) ...
[17:01:32.094] resolve() on list ...
[17:01:32.094]  recursive: 0
[17:01:32.095]  length: 2
[17:01:32.095] 
[17:01:32.137] receiveMessageFromWorker() for ClusterFuture ...
[17:01:32.137] - Validating connection of MultisessionFuture
[17:01:32.138] - received message: FutureResult
[17:01:32.138] - Received FutureResult
[17:01:32.138] - Erased future from FutureRegistry
[17:01:32.138] result() for ClusterFuture ...
[17:01:32.138] - result already collected: FutureResult
[17:01:32.138] result() for ClusterFuture ... done
[17:01:32.138] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:32.138] Future #2
[17:01:32.138] result() for ClusterFuture ...
[17:01:32.139] - result already collected: FutureResult
[17:01:32.139] result() for ClusterFuture ... done
[17:01:32.139] result() for ClusterFuture ...
[17:01:32.139] - result already collected: FutureResult
[17:01:32.139] result() for ClusterFuture ... done
[17:01:32.139] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:32.139] - nx: 2
[17:01:32.139] - relay: TRUE
[17:01:32.139] - stdout: TRUE
[17:01:32.139] - signal: TRUE
[17:01:32.139] - resignal: FALSE
[17:01:32.140] - force: TRUE
[17:01:32.140] - relayed: [n=2] FALSE, FALSE
[17:01:32.140] - queued futures: [n=2] FALSE, FALSE
[17:01:32.140]  - until=1
[17:01:32.140]  - relaying element #1
[17:01:32.140] - relayed: [n=2] FALSE, FALSE
[17:01:32.140] - queued futures: [n=2] FALSE, TRUE
[17:01:32.140] signalConditionsASAP(NULL, pos=2) ... done
[17:01:32.140]  length: 1 (resolved future 2)
[17:01:32.589] receiveMessageFromWorker() for ClusterFuture ...
[17:01:32.589] - Validating connection of MultisessionFuture
[17:01:32.589] - received message: FutureResult
[17:01:32.589] - Received FutureResult
[17:01:32.590] - Erased future from FutureRegistry
[17:01:32.590] result() for ClusterFuture ...
[17:01:32.590] - result already collected: FutureResult
[17:01:32.590] result() for ClusterFuture ... done
[17:01:32.590] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:32.590] Future #1
[17:01:32.590] result() for ClusterFuture ...
[17:01:32.590] - result already collected: FutureResult
[17:01:32.590] result() for ClusterFuture ... done
[17:01:32.590] result() for ClusterFuture ...
[17:01:32.590] - result already collected: FutureResult
[17:01:32.591] result() for ClusterFuture ... done
[17:01:32.591] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:32.591] - nx: 2
[17:01:32.591] - relay: TRUE
[17:01:32.591] - stdout: TRUE
[17:01:32.591] - signal: TRUE
[17:01:32.591] - resignal: FALSE
[17:01:32.591] - force: TRUE
[17:01:32.591] - relayed: [n=2] FALSE, FALSE
[17:01:32.591] - queued futures: [n=2] FALSE, TRUE
[17:01:32.591]  - until=1
[17:01:32.592]  - relaying element #1
[17:01:32.592] result() for ClusterFuture ...
[17:01:32.592] - result already collected: FutureResult
[17:01:32.592] result() for ClusterFuture ... done
[17:01:32.592] result() for ClusterFuture ...
[17:01:32.592] - result already collected: FutureResult
[17:01:32.592] result() for ClusterFuture ... done
[17:01:32.592] result() for ClusterFuture ...
[17:01:32.592] - result already collected: FutureResult
[17:01:32.592] result() for ClusterFuture ... done
[17:01:32.592] result() for ClusterFuture ...
[17:01:32.593] - result already collected: FutureResult
[17:01:32.593] result() for ClusterFuture ... done
[17:01:32.593] - relayed: [n=2] TRUE, FALSE
[17:01:32.593] - queued futures: [n=2] TRUE, TRUE
[17:01:32.593] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:32.593]  length: 0 (resolved future 1)
[17:01:32.593] Relaying remaining futures
[17:01:32.593] signalConditionsASAP(NULL, pos=0) ...
[17:01:32.593] - nx: 2
[17:01:32.593] - relay: TRUE
[17:01:32.593] - stdout: TRUE
[17:01:32.593] - signal: TRUE
[17:01:32.594] - resignal: FALSE
[17:01:32.594] - force: TRUE
[17:01:32.594] - relayed: [n=2] TRUE, FALSE
[17:01:32.594] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:32.594]  - relaying element #2
[17:01:32.594] result() for ClusterFuture ...
[17:01:32.594] - result already collected: FutureResult
[17:01:32.594] result() for ClusterFuture ... done
[17:01:32.594] result() for ClusterFuture ...
[17:01:32.594] - result already collected: FutureResult
[17:01:32.594] result() for ClusterFuture ... done
[17:01:32.595] result() for ClusterFuture ...
[17:01:32.595] - result already collected: FutureResult
[17:01:32.595] result() for ClusterFuture ... done
[17:01:32.595] result() for ClusterFuture ...
[17:01:32.595] - result already collected: FutureResult
[17:01:32.595] result() for ClusterFuture ... done
[17:01:32.595] - relayed: [n=2] TRUE, TRUE
[17:01:32.595] - queued futures: [n=2] TRUE, TRUE
[17:01:32.595] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:01:32.595] resolve() on list ... DONE
[17:01:32.596] result() for ClusterFuture ...
[17:01:32.596] - result already collected: FutureResult
[17:01:32.596] result() for ClusterFuture ... done
[17:01:32.596] result() for ClusterFuture ...
[17:01:32.596] - result already collected: FutureResult
[17:01:32.596] result() for ClusterFuture ... done
[17:01:32.596] result() for ClusterFuture ...
[17:01:32.596] - result already collected: FutureResult
[17:01:32.596] result() for ClusterFuture ... done
[17:01:32.596] result() for ClusterFuture ...
[17:01:32.596] - result already collected: FutureResult
[17:01:32.596] result() for ClusterFuture ... done
[17:01:32.597]  - Number of value chunks collected: 2
[17:01:32.597] Resolving 2 futures (chunks) ... DONE
[17:01:32.597] Reducing values from 2 chunks ...
[17:01:32.597]  - Number of values collected after concatenation: 2
[17:01:32.597]  - Number of values expected: 2
[17:01:32.597] Reducing values from 2 chunks ... DONE
[17:01:32.597] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:01:32.598] future_mapply() ...
[17:01:32.602] Number of chunks: 2
[17:01:32.602] getGlobalsAndPackagesXApply() ...
[17:01:32.602]  - future.globals: TRUE
[17:01:32.602] getGlobalsAndPackages() ...
[17:01:32.602] Searching for globals...
[17:01:32.604] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:01:32.604] Searching for globals ... DONE
[17:01:32.604] Resolving globals: FALSE
[17:01:32.605] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:01:32.605] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:01:32.605] - globals: [1] ‘FUN’
[17:01:32.605] 
[17:01:32.606] getGlobalsAndPackages() ... DONE
[17:01:32.606]  - globals found/used: [n=1] ‘FUN’
[17:01:32.606]  - needed namespaces: [n=0] 
[17:01:32.606] Finding globals ... DONE
[17:01:32.606] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:01:32.606] List of 2
[17:01:32.606]  $ ...future.FUN:function (x, y)  
[17:01:32.606]  $ MoreArgs     : NULL
[17:01:32.606]  - attr(*, "where")=List of 2
[17:01:32.606]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:32.606]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:01:32.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:32.606]  - attr(*, "resolved")= logi FALSE
[17:01:32.606]  - attr(*, "total_size")= num NA
[17:01:32.609] Packages to be attached in all futures: [n=0] 
[17:01:32.609] getGlobalsAndPackagesXApply() ... DONE
[17:01:32.609] Number of futures (= number of chunks): 2
[17:01:32.609] Launching 2 futures (chunks) ...
[17:01:32.609] Chunk #1 of 2 ...
[17:01:32.609]  - Finding globals in '...' for chunk #1 ...
[17:01:32.609] getGlobalsAndPackages() ...
[17:01:32.609] Searching for globals...
[17:01:32.610] 
[17:01:32.610] Searching for globals ... DONE
[17:01:32.610] - globals: [0] <none>
[17:01:32.610] getGlobalsAndPackages() ... DONE
[17:01:32.610]    + additional globals found: [n=0] 
[17:01:32.610]    + additional namespaces needed: [n=0] 
[17:01:32.610]  - Finding globals in '...' for chunk #1 ... DONE
[17:01:32.610]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:32.610]  - seeds: <none>
[17:01:32.611]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.611] getGlobalsAndPackages() ...
[17:01:32.611] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.611] Resolving globals: FALSE
[17:01:32.611] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:32.612] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:32.612] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.612] 
[17:01:32.612] getGlobalsAndPackages() ... DONE
[17:01:32.612] run() for ‘Future’ ...
[17:01:32.613] - state: ‘created’
[17:01:32.613] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:32.626] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:32.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:32.627]   - Field: ‘node’
[17:01:32.627]   - Field: ‘label’
[17:01:32.627]   - Field: ‘local’
[17:01:32.627]   - Field: ‘owner’
[17:01:32.627]   - Field: ‘envir’
[17:01:32.627]   - Field: ‘workers’
[17:01:32.627]   - Field: ‘packages’
[17:01:32.627]   - Field: ‘gc’
[17:01:32.628]   - Field: ‘conditions’
[17:01:32.628]   - Field: ‘persistent’
[17:01:32.628]   - Field: ‘expr’
[17:01:32.628]   - Field: ‘uuid’
[17:01:32.628]   - Field: ‘seed’
[17:01:32.628]   - Field: ‘version’
[17:01:32.628]   - Field: ‘result’
[17:01:32.628]   - Field: ‘asynchronous’
[17:01:32.628]   - Field: ‘calls’
[17:01:32.628]   - Field: ‘globals’
[17:01:32.628]   - Field: ‘stdout’
[17:01:32.629]   - Field: ‘earlySignal’
[17:01:32.629]   - Field: ‘lazy’
[17:01:32.629]   - Field: ‘state’
[17:01:32.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:32.629] - Launch lazy future ...
[17:01:32.629] Packages needed by the future expression (n = 0): <none>
[17:01:32.629] Packages needed by future strategies (n = 0): <none>
[17:01:32.630] {
[17:01:32.630]     {
[17:01:32.630]         {
[17:01:32.630]             ...future.startTime <- base::Sys.time()
[17:01:32.630]             {
[17:01:32.630]                 {
[17:01:32.630]                   {
[17:01:32.630]                     {
[17:01:32.630]                       base::local({
[17:01:32.630]                         has_future <- base::requireNamespace("future", 
[17:01:32.630]                           quietly = TRUE)
[17:01:32.630]                         if (has_future) {
[17:01:32.630]                           ns <- base::getNamespace("future")
[17:01:32.630]                           version <- ns[[".package"]][["version"]]
[17:01:32.630]                           if (is.null(version)) 
[17:01:32.630]                             version <- utils::packageVersion("future")
[17:01:32.630]                         }
[17:01:32.630]                         else {
[17:01:32.630]                           version <- NULL
[17:01:32.630]                         }
[17:01:32.630]                         if (!has_future || version < "1.8.0") {
[17:01:32.630]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:32.630]                             "", base::R.version$version.string), 
[17:01:32.630]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:32.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:32.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:32.630]                               "release", "version")], collapse = " "), 
[17:01:32.630]                             hostname = base::Sys.info()[["nodename"]])
[17:01:32.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:32.630]                             info)
[17:01:32.630]                           info <- base::paste(info, collapse = "; ")
[17:01:32.630]                           if (!has_future) {
[17:01:32.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:32.630]                               info)
[17:01:32.630]                           }
[17:01:32.630]                           else {
[17:01:32.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:32.630]                               info, version)
[17:01:32.630]                           }
[17:01:32.630]                           base::stop(msg)
[17:01:32.630]                         }
[17:01:32.630]                       })
[17:01:32.630]                     }
[17:01:32.630]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:32.630]                     base::options(mc.cores = 1L)
[17:01:32.630]                   }
[17:01:32.630]                   ...future.strategy.old <- future::plan("list")
[17:01:32.630]                   options(future.plan = NULL)
[17:01:32.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:32.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:32.630]                 }
[17:01:32.630]                 ...future.workdir <- getwd()
[17:01:32.630]             }
[17:01:32.630]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:32.630]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:32.630]         }
[17:01:32.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:32.630]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:32.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:32.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:32.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:32.630]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:32.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:32.630]             base::names(...future.oldOptions))
[17:01:32.630]     }
[17:01:32.630]     if (TRUE) {
[17:01:32.630]     }
[17:01:32.630]     else {
[17:01:32.630]         if (NA) {
[17:01:32.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:32.630]                 open = "w")
[17:01:32.630]         }
[17:01:32.630]         else {
[17:01:32.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:32.630]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:32.630]         }
[17:01:32.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:32.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:32.630]             base::sink(type = "output", split = FALSE)
[17:01:32.630]             base::close(...future.stdout)
[17:01:32.630]         }, add = TRUE)
[17:01:32.630]     }
[17:01:32.630]     ...future.frame <- base::sys.nframe()
[17:01:32.630]     ...future.conditions <- base::list()
[17:01:32.630]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:32.630]     if (FALSE) {
[17:01:32.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:32.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:32.630]     }
[17:01:32.630]     ...future.result <- base::tryCatch({
[17:01:32.630]         base::withCallingHandlers({
[17:01:32.630]             ...future.value <- base::withVisible(base::local({
[17:01:32.630]                 ...future.makeSendCondition <- base::local({
[17:01:32.630]                   sendCondition <- NULL
[17:01:32.630]                   function(frame = 1L) {
[17:01:32.630]                     if (is.function(sendCondition)) 
[17:01:32.630]                       return(sendCondition)
[17:01:32.630]                     ns <- getNamespace("parallel")
[17:01:32.630]                     if (exists("sendData", mode = "function", 
[17:01:32.630]                       envir = ns)) {
[17:01:32.630]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:32.630]                         envir = ns)
[17:01:32.630]                       envir <- sys.frame(frame)
[17:01:32.630]                       master <- NULL
[17:01:32.630]                       while (!identical(envir, .GlobalEnv) && 
[17:01:32.630]                         !identical(envir, emptyenv())) {
[17:01:32.630]                         if (exists("master", mode = "list", envir = envir, 
[17:01:32.630]                           inherits = FALSE)) {
[17:01:32.630]                           master <- get("master", mode = "list", 
[17:01:32.630]                             envir = envir, inherits = FALSE)
[17:01:32.630]                           if (inherits(master, c("SOCKnode", 
[17:01:32.630]                             "SOCK0node"))) {
[17:01:32.630]                             sendCondition <<- function(cond) {
[17:01:32.630]                               data <- list(type = "VALUE", value = cond, 
[17:01:32.630]                                 success = TRUE)
[17:01:32.630]                               parallel_sendData(master, data)
[17:01:32.630]                             }
[17:01:32.630]                             return(sendCondition)
[17:01:32.630]                           }
[17:01:32.630]                         }
[17:01:32.630]                         frame <- frame + 1L
[17:01:32.630]                         envir <- sys.frame(frame)
[17:01:32.630]                       }
[17:01:32.630]                     }
[17:01:32.630]                     sendCondition <<- function(cond) NULL
[17:01:32.630]                   }
[17:01:32.630]                 })
[17:01:32.630]                 withCallingHandlers({
[17:01:32.630]                   {
[17:01:32.630]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:32.630]                     if (!identical(...future.globals.maxSize.org, 
[17:01:32.630]                       ...future.globals.maxSize)) {
[17:01:32.630]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:32.630]                       on.exit(options(oopts), add = TRUE)
[17:01:32.630]                     }
[17:01:32.630]                     {
[17:01:32.630]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:32.630]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:32.630]                         USE.NAMES = FALSE)
[17:01:32.630]                       do.call(mapply, args = args)
[17:01:32.630]                     }
[17:01:32.630]                   }
[17:01:32.630]                 }, immediateCondition = function(cond) {
[17:01:32.630]                   sendCondition <- ...future.makeSendCondition()
[17:01:32.630]                   sendCondition(cond)
[17:01:32.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.630]                   {
[17:01:32.630]                     inherits <- base::inherits
[17:01:32.630]                     invokeRestart <- base::invokeRestart
[17:01:32.630]                     is.null <- base::is.null
[17:01:32.630]                     muffled <- FALSE
[17:01:32.630]                     if (inherits(cond, "message")) {
[17:01:32.630]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:32.630]                       if (muffled) 
[17:01:32.630]                         invokeRestart("muffleMessage")
[17:01:32.630]                     }
[17:01:32.630]                     else if (inherits(cond, "warning")) {
[17:01:32.630]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:32.630]                       if (muffled) 
[17:01:32.630]                         invokeRestart("muffleWarning")
[17:01:32.630]                     }
[17:01:32.630]                     else if (inherits(cond, "condition")) {
[17:01:32.630]                       if (!is.null(pattern)) {
[17:01:32.630]                         computeRestarts <- base::computeRestarts
[17:01:32.630]                         grepl <- base::grepl
[17:01:32.630]                         restarts <- computeRestarts(cond)
[17:01:32.630]                         for (restart in restarts) {
[17:01:32.630]                           name <- restart$name
[17:01:32.630]                           if (is.null(name)) 
[17:01:32.630]                             next
[17:01:32.630]                           if (!grepl(pattern, name)) 
[17:01:32.630]                             next
[17:01:32.630]                           invokeRestart(restart)
[17:01:32.630]                           muffled <- TRUE
[17:01:32.630]                           break
[17:01:32.630]                         }
[17:01:32.630]                       }
[17:01:32.630]                     }
[17:01:32.630]                     invisible(muffled)
[17:01:32.630]                   }
[17:01:32.630]                   muffleCondition(cond)
[17:01:32.630]                 })
[17:01:32.630]             }))
[17:01:32.630]             future::FutureResult(value = ...future.value$value, 
[17:01:32.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:32.630]                   ...future.rng), globalenv = if (FALSE) 
[17:01:32.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:32.630]                     ...future.globalenv.names))
[17:01:32.630]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:32.630]         }, condition = base::local({
[17:01:32.630]             c <- base::c
[17:01:32.630]             inherits <- base::inherits
[17:01:32.630]             invokeRestart <- base::invokeRestart
[17:01:32.630]             length <- base::length
[17:01:32.630]             list <- base::list
[17:01:32.630]             seq.int <- base::seq.int
[17:01:32.630]             signalCondition <- base::signalCondition
[17:01:32.630]             sys.calls <- base::sys.calls
[17:01:32.630]             `[[` <- base::`[[`
[17:01:32.630]             `+` <- base::`+`
[17:01:32.630]             `<<-` <- base::`<<-`
[17:01:32.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:32.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:32.630]                   3L)]
[17:01:32.630]             }
[17:01:32.630]             function(cond) {
[17:01:32.630]                 is_error <- inherits(cond, "error")
[17:01:32.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:32.630]                   NULL)
[17:01:32.630]                 if (is_error) {
[17:01:32.630]                   sessionInformation <- function() {
[17:01:32.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:32.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:32.630]                       search = base::search(), system = base::Sys.info())
[17:01:32.630]                   }
[17:01:32.630]                   ...future.conditions[[length(...future.conditions) + 
[17:01:32.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:32.630]                     cond$call), session = sessionInformation(), 
[17:01:32.630]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:32.630]                   signalCondition(cond)
[17:01:32.630]                 }
[17:01:32.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:32.630]                 "immediateCondition"))) {
[17:01:32.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:32.630]                   ...future.conditions[[length(...future.conditions) + 
[17:01:32.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:32.630]                   if (TRUE && !signal) {
[17:01:32.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.630]                     {
[17:01:32.630]                       inherits <- base::inherits
[17:01:32.630]                       invokeRestart <- base::invokeRestart
[17:01:32.630]                       is.null <- base::is.null
[17:01:32.630]                       muffled <- FALSE
[17:01:32.630]                       if (inherits(cond, "message")) {
[17:01:32.630]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:32.630]                         if (muffled) 
[17:01:32.630]                           invokeRestart("muffleMessage")
[17:01:32.630]                       }
[17:01:32.630]                       else if (inherits(cond, "warning")) {
[17:01:32.630]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:32.630]                         if (muffled) 
[17:01:32.630]                           invokeRestart("muffleWarning")
[17:01:32.630]                       }
[17:01:32.630]                       else if (inherits(cond, "condition")) {
[17:01:32.630]                         if (!is.null(pattern)) {
[17:01:32.630]                           computeRestarts <- base::computeRestarts
[17:01:32.630]                           grepl <- base::grepl
[17:01:32.630]                           restarts <- computeRestarts(cond)
[17:01:32.630]                           for (restart in restarts) {
[17:01:32.630]                             name <- restart$name
[17:01:32.630]                             if (is.null(name)) 
[17:01:32.630]                               next
[17:01:32.630]                             if (!grepl(pattern, name)) 
[17:01:32.630]                               next
[17:01:32.630]                             invokeRestart(restart)
[17:01:32.630]                             muffled <- TRUE
[17:01:32.630]                             break
[17:01:32.630]                           }
[17:01:32.630]                         }
[17:01:32.630]                       }
[17:01:32.630]                       invisible(muffled)
[17:01:32.630]                     }
[17:01:32.630]                     muffleCondition(cond, pattern = "^muffle")
[17:01:32.630]                   }
[17:01:32.630]                 }
[17:01:32.630]                 else {
[17:01:32.630]                   if (TRUE) {
[17:01:32.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.630]                     {
[17:01:32.630]                       inherits <- base::inherits
[17:01:32.630]                       invokeRestart <- base::invokeRestart
[17:01:32.630]                       is.null <- base::is.null
[17:01:32.630]                       muffled <- FALSE
[17:01:32.630]                       if (inherits(cond, "message")) {
[17:01:32.630]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:32.630]                         if (muffled) 
[17:01:32.630]                           invokeRestart("muffleMessage")
[17:01:32.630]                       }
[17:01:32.630]                       else if (inherits(cond, "warning")) {
[17:01:32.630]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:32.630]                         if (muffled) 
[17:01:32.630]                           invokeRestart("muffleWarning")
[17:01:32.630]                       }
[17:01:32.630]                       else if (inherits(cond, "condition")) {
[17:01:32.630]                         if (!is.null(pattern)) {
[17:01:32.630]                           computeRestarts <- base::computeRestarts
[17:01:32.630]                           grepl <- base::grepl
[17:01:32.630]                           restarts <- computeRestarts(cond)
[17:01:32.630]                           for (restart in restarts) {
[17:01:32.630]                             name <- restart$name
[17:01:32.630]                             if (is.null(name)) 
[17:01:32.630]                               next
[17:01:32.630]                             if (!grepl(pattern, name)) 
[17:01:32.630]                               next
[17:01:32.630]                             invokeRestart(restart)
[17:01:32.630]                             muffled <- TRUE
[17:01:32.630]                             break
[17:01:32.630]                           }
[17:01:32.630]                         }
[17:01:32.630]                       }
[17:01:32.630]                       invisible(muffled)
[17:01:32.630]                     }
[17:01:32.630]                     muffleCondition(cond, pattern = "^muffle")
[17:01:32.630]                   }
[17:01:32.630]                 }
[17:01:32.630]             }
[17:01:32.630]         }))
[17:01:32.630]     }, error = function(ex) {
[17:01:32.630]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:32.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:32.630]                 ...future.rng), started = ...future.startTime, 
[17:01:32.630]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:32.630]             version = "1.8"), class = "FutureResult")
[17:01:32.630]     }, finally = {
[17:01:32.630]         if (!identical(...future.workdir, getwd())) 
[17:01:32.630]             setwd(...future.workdir)
[17:01:32.630]         {
[17:01:32.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:32.630]                 ...future.oldOptions$nwarnings <- NULL
[17:01:32.630]             }
[17:01:32.630]             base::options(...future.oldOptions)
[17:01:32.630]             if (.Platform$OS.type == "windows") {
[17:01:32.630]                 old_names <- names(...future.oldEnvVars)
[17:01:32.630]                 envs <- base::Sys.getenv()
[17:01:32.630]                 names <- names(envs)
[17:01:32.630]                 common <- intersect(names, old_names)
[17:01:32.630]                 added <- setdiff(names, old_names)
[17:01:32.630]                 removed <- setdiff(old_names, names)
[17:01:32.630]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:32.630]                   envs[common]]
[17:01:32.630]                 NAMES <- toupper(changed)
[17:01:32.630]                 args <- list()
[17:01:32.630]                 for (kk in seq_along(NAMES)) {
[17:01:32.630]                   name <- changed[[kk]]
[17:01:32.630]                   NAME <- NAMES[[kk]]
[17:01:32.630]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.630]                     next
[17:01:32.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:32.630]                 }
[17:01:32.630]                 NAMES <- toupper(added)
[17:01:32.630]                 for (kk in seq_along(NAMES)) {
[17:01:32.630]                   name <- added[[kk]]
[17:01:32.630]                   NAME <- NAMES[[kk]]
[17:01:32.630]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.630]                     next
[17:01:32.630]                   args[[name]] <- ""
[17:01:32.630]                 }
[17:01:32.630]                 NAMES <- toupper(removed)
[17:01:32.630]                 for (kk in seq_along(NAMES)) {
[17:01:32.630]                   name <- removed[[kk]]
[17:01:32.630]                   NAME <- NAMES[[kk]]
[17:01:32.630]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.630]                     next
[17:01:32.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:32.630]                 }
[17:01:32.630]                 if (length(args) > 0) 
[17:01:32.630]                   base::do.call(base::Sys.setenv, args = args)
[17:01:32.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:32.630]             }
[17:01:32.630]             else {
[17:01:32.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:32.630]             }
[17:01:32.630]             {
[17:01:32.630]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:32.630]                   0L) {
[17:01:32.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:32.630]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:32.630]                   base::options(opts)
[17:01:32.630]                 }
[17:01:32.630]                 {
[17:01:32.630]                   {
[17:01:32.630]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:32.630]                     NULL
[17:01:32.630]                   }
[17:01:32.630]                   options(future.plan = NULL)
[17:01:32.630]                   if (is.na(NA_character_)) 
[17:01:32.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:32.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:32.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:32.630]                     .init = FALSE)
[17:01:32.630]                 }
[17:01:32.630]             }
[17:01:32.630]         }
[17:01:32.630]     })
[17:01:32.630]     if (FALSE) {
[17:01:32.630]         base::sink(type = "output", split = FALSE)
[17:01:32.630]         if (NA) {
[17:01:32.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:32.630]         }
[17:01:32.630]         else {
[17:01:32.630]             ...future.result["stdout"] <- base::list(NULL)
[17:01:32.630]         }
[17:01:32.630]         base::close(...future.stdout)
[17:01:32.630]         ...future.stdout <- NULL
[17:01:32.630]     }
[17:01:32.630]     ...future.result$conditions <- ...future.conditions
[17:01:32.630]     ...future.result$finished <- base::Sys.time()
[17:01:32.630]     ...future.result
[17:01:32.630] }
[17:01:32.633] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:01:32.633] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:01:32.633] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:01:32.633] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:01:32.634] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:01:32.634] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:01:32.634] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:01:32.634] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:32.634] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:32.635] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:32.635] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:32.635] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:01:32.635] MultisessionFuture started
[17:01:32.636] - Launch lazy future ... done
[17:01:32.636] run() for ‘MultisessionFuture’ ... done
[17:01:32.636] Created future:
[17:01:32.636] MultisessionFuture:
[17:01:32.636] Label: ‘future_mapply-1’
[17:01:32.636] Expression:
[17:01:32.636] {
[17:01:32.636]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:32.636]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:32.636]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:32.636]         on.exit(options(oopts), add = TRUE)
[17:01:32.636]     }
[17:01:32.636]     {
[17:01:32.636]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:32.636]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:32.636]         do.call(mapply, args = args)
[17:01:32.636]     }
[17:01:32.636] }
[17:01:32.636] Lazy evaluation: FALSE
[17:01:32.636] Asynchronous evaluation: TRUE
[17:01:32.636] Local evaluation: TRUE
[17:01:32.636] Environment: R_GlobalEnv
[17:01:32.636] Capture standard output: NA
[17:01:32.636] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:32.636] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:32.636] Packages: <none>
[17:01:32.636] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:32.636] Resolved: FALSE
[17:01:32.636] Value: <not collected>
[17:01:32.636] Conditions captured: <none>
[17:01:32.636] Early signaling: FALSE
[17:01:32.636] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:32.636] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:32.647] Chunk #1 of 2 ... DONE
[17:01:32.648] Chunk #2 of 2 ...
[17:01:32.648]  - Finding globals in '...' for chunk #2 ...
[17:01:32.648] getGlobalsAndPackages() ...
[17:01:32.648] Searching for globals...
[17:01:32.648] 
[17:01:32.648] Searching for globals ... DONE
[17:01:32.649] - globals: [0] <none>
[17:01:32.649] getGlobalsAndPackages() ... DONE
[17:01:32.649]    + additional globals found: [n=0] 
[17:01:32.649]    + additional namespaces needed: [n=0] 
[17:01:32.649]  - Finding globals in '...' for chunk #2 ... DONE
[17:01:32.649]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:32.649]  - seeds: <none>
[17:01:32.649]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.649] getGlobalsAndPackages() ...
[17:01:32.649] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.649] Resolving globals: FALSE
[17:01:32.650] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:01:32.650] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:01:32.651] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:32.651] 
[17:01:32.651] getGlobalsAndPackages() ... DONE
[17:01:32.651] run() for ‘Future’ ...
[17:01:32.651] - state: ‘created’
[17:01:32.651] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:32.665] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:32.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:32.666]   - Field: ‘node’
[17:01:32.666]   - Field: ‘label’
[17:01:32.666]   - Field: ‘local’
[17:01:32.666]   - Field: ‘owner’
[17:01:32.666]   - Field: ‘envir’
[17:01:32.666]   - Field: ‘workers’
[17:01:32.666]   - Field: ‘packages’
[17:01:32.666]   - Field: ‘gc’
[17:01:32.666]   - Field: ‘conditions’
[17:01:32.667]   - Field: ‘persistent’
[17:01:32.667]   - Field: ‘expr’
[17:01:32.667]   - Field: ‘uuid’
[17:01:32.667]   - Field: ‘seed’
[17:01:32.667]   - Field: ‘version’
[17:01:32.667]   - Field: ‘result’
[17:01:32.667]   - Field: ‘asynchronous’
[17:01:32.667]   - Field: ‘calls’
[17:01:32.667]   - Field: ‘globals’
[17:01:32.667]   - Field: ‘stdout’
[17:01:32.668]   - Field: ‘earlySignal’
[17:01:32.668]   - Field: ‘lazy’
[17:01:32.668]   - Field: ‘state’
[17:01:32.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:32.668] - Launch lazy future ...
[17:01:32.668] Packages needed by the future expression (n = 0): <none>
[17:01:32.668] Packages needed by future strategies (n = 0): <none>
[17:01:32.669] {
[17:01:32.669]     {
[17:01:32.669]         {
[17:01:32.669]             ...future.startTime <- base::Sys.time()
[17:01:32.669]             {
[17:01:32.669]                 {
[17:01:32.669]                   {
[17:01:32.669]                     {
[17:01:32.669]                       base::local({
[17:01:32.669]                         has_future <- base::requireNamespace("future", 
[17:01:32.669]                           quietly = TRUE)
[17:01:32.669]                         if (has_future) {
[17:01:32.669]                           ns <- base::getNamespace("future")
[17:01:32.669]                           version <- ns[[".package"]][["version"]]
[17:01:32.669]                           if (is.null(version)) 
[17:01:32.669]                             version <- utils::packageVersion("future")
[17:01:32.669]                         }
[17:01:32.669]                         else {
[17:01:32.669]                           version <- NULL
[17:01:32.669]                         }
[17:01:32.669]                         if (!has_future || version < "1.8.0") {
[17:01:32.669]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:32.669]                             "", base::R.version$version.string), 
[17:01:32.669]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:32.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:32.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:32.669]                               "release", "version")], collapse = " "), 
[17:01:32.669]                             hostname = base::Sys.info()[["nodename"]])
[17:01:32.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:32.669]                             info)
[17:01:32.669]                           info <- base::paste(info, collapse = "; ")
[17:01:32.669]                           if (!has_future) {
[17:01:32.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:32.669]                               info)
[17:01:32.669]                           }
[17:01:32.669]                           else {
[17:01:32.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:32.669]                               info, version)
[17:01:32.669]                           }
[17:01:32.669]                           base::stop(msg)
[17:01:32.669]                         }
[17:01:32.669]                       })
[17:01:32.669]                     }
[17:01:32.669]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:32.669]                     base::options(mc.cores = 1L)
[17:01:32.669]                   }
[17:01:32.669]                   ...future.strategy.old <- future::plan("list")
[17:01:32.669]                   options(future.plan = NULL)
[17:01:32.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:32.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:32.669]                 }
[17:01:32.669]                 ...future.workdir <- getwd()
[17:01:32.669]             }
[17:01:32.669]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:32.669]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:32.669]         }
[17:01:32.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:32.669]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:32.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:32.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:32.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:32.669]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:32.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:32.669]             base::names(...future.oldOptions))
[17:01:32.669]     }
[17:01:32.669]     if (TRUE) {
[17:01:32.669]     }
[17:01:32.669]     else {
[17:01:32.669]         if (NA) {
[17:01:32.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:32.669]                 open = "w")
[17:01:32.669]         }
[17:01:32.669]         else {
[17:01:32.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:32.669]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:32.669]         }
[17:01:32.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:32.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:32.669]             base::sink(type = "output", split = FALSE)
[17:01:32.669]             base::close(...future.stdout)
[17:01:32.669]         }, add = TRUE)
[17:01:32.669]     }
[17:01:32.669]     ...future.frame <- base::sys.nframe()
[17:01:32.669]     ...future.conditions <- base::list()
[17:01:32.669]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:32.669]     if (FALSE) {
[17:01:32.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:32.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:32.669]     }
[17:01:32.669]     ...future.result <- base::tryCatch({
[17:01:32.669]         base::withCallingHandlers({
[17:01:32.669]             ...future.value <- base::withVisible(base::local({
[17:01:32.669]                 ...future.makeSendCondition <- base::local({
[17:01:32.669]                   sendCondition <- NULL
[17:01:32.669]                   function(frame = 1L) {
[17:01:32.669]                     if (is.function(sendCondition)) 
[17:01:32.669]                       return(sendCondition)
[17:01:32.669]                     ns <- getNamespace("parallel")
[17:01:32.669]                     if (exists("sendData", mode = "function", 
[17:01:32.669]                       envir = ns)) {
[17:01:32.669]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:32.669]                         envir = ns)
[17:01:32.669]                       envir <- sys.frame(frame)
[17:01:32.669]                       master <- NULL
[17:01:32.669]                       while (!identical(envir, .GlobalEnv) && 
[17:01:32.669]                         !identical(envir, emptyenv())) {
[17:01:32.669]                         if (exists("master", mode = "list", envir = envir, 
[17:01:32.669]                           inherits = FALSE)) {
[17:01:32.669]                           master <- get("master", mode = "list", 
[17:01:32.669]                             envir = envir, inherits = FALSE)
[17:01:32.669]                           if (inherits(master, c("SOCKnode", 
[17:01:32.669]                             "SOCK0node"))) {
[17:01:32.669]                             sendCondition <<- function(cond) {
[17:01:32.669]                               data <- list(type = "VALUE", value = cond, 
[17:01:32.669]                                 success = TRUE)
[17:01:32.669]                               parallel_sendData(master, data)
[17:01:32.669]                             }
[17:01:32.669]                             return(sendCondition)
[17:01:32.669]                           }
[17:01:32.669]                         }
[17:01:32.669]                         frame <- frame + 1L
[17:01:32.669]                         envir <- sys.frame(frame)
[17:01:32.669]                       }
[17:01:32.669]                     }
[17:01:32.669]                     sendCondition <<- function(cond) NULL
[17:01:32.669]                   }
[17:01:32.669]                 })
[17:01:32.669]                 withCallingHandlers({
[17:01:32.669]                   {
[17:01:32.669]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:32.669]                     if (!identical(...future.globals.maxSize.org, 
[17:01:32.669]                       ...future.globals.maxSize)) {
[17:01:32.669]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:32.669]                       on.exit(options(oopts), add = TRUE)
[17:01:32.669]                     }
[17:01:32.669]                     {
[17:01:32.669]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:32.669]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:01:32.669]                         USE.NAMES = FALSE)
[17:01:32.669]                       do.call(mapply, args = args)
[17:01:32.669]                     }
[17:01:32.669]                   }
[17:01:32.669]                 }, immediateCondition = function(cond) {
[17:01:32.669]                   sendCondition <- ...future.makeSendCondition()
[17:01:32.669]                   sendCondition(cond)
[17:01:32.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.669]                   {
[17:01:32.669]                     inherits <- base::inherits
[17:01:32.669]                     invokeRestart <- base::invokeRestart
[17:01:32.669]                     is.null <- base::is.null
[17:01:32.669]                     muffled <- FALSE
[17:01:32.669]                     if (inherits(cond, "message")) {
[17:01:32.669]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:32.669]                       if (muffled) 
[17:01:32.669]                         invokeRestart("muffleMessage")
[17:01:32.669]                     }
[17:01:32.669]                     else if (inherits(cond, "warning")) {
[17:01:32.669]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:32.669]                       if (muffled) 
[17:01:32.669]                         invokeRestart("muffleWarning")
[17:01:32.669]                     }
[17:01:32.669]                     else if (inherits(cond, "condition")) {
[17:01:32.669]                       if (!is.null(pattern)) {
[17:01:32.669]                         computeRestarts <- base::computeRestarts
[17:01:32.669]                         grepl <- base::grepl
[17:01:32.669]                         restarts <- computeRestarts(cond)
[17:01:32.669]                         for (restart in restarts) {
[17:01:32.669]                           name <- restart$name
[17:01:32.669]                           if (is.null(name)) 
[17:01:32.669]                             next
[17:01:32.669]                           if (!grepl(pattern, name)) 
[17:01:32.669]                             next
[17:01:32.669]                           invokeRestart(restart)
[17:01:32.669]                           muffled <- TRUE
[17:01:32.669]                           break
[17:01:32.669]                         }
[17:01:32.669]                       }
[17:01:32.669]                     }
[17:01:32.669]                     invisible(muffled)
[17:01:32.669]                   }
[17:01:32.669]                   muffleCondition(cond)
[17:01:32.669]                 })
[17:01:32.669]             }))
[17:01:32.669]             future::FutureResult(value = ...future.value$value, 
[17:01:32.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:32.669]                   ...future.rng), globalenv = if (FALSE) 
[17:01:32.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:32.669]                     ...future.globalenv.names))
[17:01:32.669]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:32.669]         }, condition = base::local({
[17:01:32.669]             c <- base::c
[17:01:32.669]             inherits <- base::inherits
[17:01:32.669]             invokeRestart <- base::invokeRestart
[17:01:32.669]             length <- base::length
[17:01:32.669]             list <- base::list
[17:01:32.669]             seq.int <- base::seq.int
[17:01:32.669]             signalCondition <- base::signalCondition
[17:01:32.669]             sys.calls <- base::sys.calls
[17:01:32.669]             `[[` <- base::`[[`
[17:01:32.669]             `+` <- base::`+`
[17:01:32.669]             `<<-` <- base::`<<-`
[17:01:32.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:32.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:32.669]                   3L)]
[17:01:32.669]             }
[17:01:32.669]             function(cond) {
[17:01:32.669]                 is_error <- inherits(cond, "error")
[17:01:32.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:32.669]                   NULL)
[17:01:32.669]                 if (is_error) {
[17:01:32.669]                   sessionInformation <- function() {
[17:01:32.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:32.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:32.669]                       search = base::search(), system = base::Sys.info())
[17:01:32.669]                   }
[17:01:32.669]                   ...future.conditions[[length(...future.conditions) + 
[17:01:32.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:32.669]                     cond$call), session = sessionInformation(), 
[17:01:32.669]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:32.669]                   signalCondition(cond)
[17:01:32.669]                 }
[17:01:32.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:32.669]                 "immediateCondition"))) {
[17:01:32.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:32.669]                   ...future.conditions[[length(...future.conditions) + 
[17:01:32.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:32.669]                   if (TRUE && !signal) {
[17:01:32.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.669]                     {
[17:01:32.669]                       inherits <- base::inherits
[17:01:32.669]                       invokeRestart <- base::invokeRestart
[17:01:32.669]                       is.null <- base::is.null
[17:01:32.669]                       muffled <- FALSE
[17:01:32.669]                       if (inherits(cond, "message")) {
[17:01:32.669]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:32.669]                         if (muffled) 
[17:01:32.669]                           invokeRestart("muffleMessage")
[17:01:32.669]                       }
[17:01:32.669]                       else if (inherits(cond, "warning")) {
[17:01:32.669]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:32.669]                         if (muffled) 
[17:01:32.669]                           invokeRestart("muffleWarning")
[17:01:32.669]                       }
[17:01:32.669]                       else if (inherits(cond, "condition")) {
[17:01:32.669]                         if (!is.null(pattern)) {
[17:01:32.669]                           computeRestarts <- base::computeRestarts
[17:01:32.669]                           grepl <- base::grepl
[17:01:32.669]                           restarts <- computeRestarts(cond)
[17:01:32.669]                           for (restart in restarts) {
[17:01:32.669]                             name <- restart$name
[17:01:32.669]                             if (is.null(name)) 
[17:01:32.669]                               next
[17:01:32.669]                             if (!grepl(pattern, name)) 
[17:01:32.669]                               next
[17:01:32.669]                             invokeRestart(restart)
[17:01:32.669]                             muffled <- TRUE
[17:01:32.669]                             break
[17:01:32.669]                           }
[17:01:32.669]                         }
[17:01:32.669]                       }
[17:01:32.669]                       invisible(muffled)
[17:01:32.669]                     }
[17:01:32.669]                     muffleCondition(cond, pattern = "^muffle")
[17:01:32.669]                   }
[17:01:32.669]                 }
[17:01:32.669]                 else {
[17:01:32.669]                   if (TRUE) {
[17:01:32.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:32.669]                     {
[17:01:32.669]                       inherits <- base::inherits
[17:01:32.669]                       invokeRestart <- base::invokeRestart
[17:01:32.669]                       is.null <- base::is.null
[17:01:32.669]                       muffled <- FALSE
[17:01:32.669]                       if (inherits(cond, "message")) {
[17:01:32.669]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:32.669]                         if (muffled) 
[17:01:32.669]                           invokeRestart("muffleMessage")
[17:01:32.669]                       }
[17:01:32.669]                       else if (inherits(cond, "warning")) {
[17:01:32.669]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:32.669]                         if (muffled) 
[17:01:32.669]                           invokeRestart("muffleWarning")
[17:01:32.669]                       }
[17:01:32.669]                       else if (inherits(cond, "condition")) {
[17:01:32.669]                         if (!is.null(pattern)) {
[17:01:32.669]                           computeRestarts <- base::computeRestarts
[17:01:32.669]                           grepl <- base::grepl
[17:01:32.669]                           restarts <- computeRestarts(cond)
[17:01:32.669]                           for (restart in restarts) {
[17:01:32.669]                             name <- restart$name
[17:01:32.669]                             if (is.null(name)) 
[17:01:32.669]                               next
[17:01:32.669]                             if (!grepl(pattern, name)) 
[17:01:32.669]                               next
[17:01:32.669]                             invokeRestart(restart)
[17:01:32.669]                             muffled <- TRUE
[17:01:32.669]                             break
[17:01:32.669]                           }
[17:01:32.669]                         }
[17:01:32.669]                       }
[17:01:32.669]                       invisible(muffled)
[17:01:32.669]                     }
[17:01:32.669]                     muffleCondition(cond, pattern = "^muffle")
[17:01:32.669]                   }
[17:01:32.669]                 }
[17:01:32.669]             }
[17:01:32.669]         }))
[17:01:32.669]     }, error = function(ex) {
[17:01:32.669]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:32.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:32.669]                 ...future.rng), started = ...future.startTime, 
[17:01:32.669]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:32.669]             version = "1.8"), class = "FutureResult")
[17:01:32.669]     }, finally = {
[17:01:32.669]         if (!identical(...future.workdir, getwd())) 
[17:01:32.669]             setwd(...future.workdir)
[17:01:32.669]         {
[17:01:32.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:32.669]                 ...future.oldOptions$nwarnings <- NULL
[17:01:32.669]             }
[17:01:32.669]             base::options(...future.oldOptions)
[17:01:32.669]             if (.Platform$OS.type == "windows") {
[17:01:32.669]                 old_names <- names(...future.oldEnvVars)
[17:01:32.669]                 envs <- base::Sys.getenv()
[17:01:32.669]                 names <- names(envs)
[17:01:32.669]                 common <- intersect(names, old_names)
[17:01:32.669]                 added <- setdiff(names, old_names)
[17:01:32.669]                 removed <- setdiff(old_names, names)
[17:01:32.669]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:32.669]                   envs[common]]
[17:01:32.669]                 NAMES <- toupper(changed)
[17:01:32.669]                 args <- list()
[17:01:32.669]                 for (kk in seq_along(NAMES)) {
[17:01:32.669]                   name <- changed[[kk]]
[17:01:32.669]                   NAME <- NAMES[[kk]]
[17:01:32.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.669]                     next
[17:01:32.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:32.669]                 }
[17:01:32.669]                 NAMES <- toupper(added)
[17:01:32.669]                 for (kk in seq_along(NAMES)) {
[17:01:32.669]                   name <- added[[kk]]
[17:01:32.669]                   NAME <- NAMES[[kk]]
[17:01:32.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.669]                     next
[17:01:32.669]                   args[[name]] <- ""
[17:01:32.669]                 }
[17:01:32.669]                 NAMES <- toupper(removed)
[17:01:32.669]                 for (kk in seq_along(NAMES)) {
[17:01:32.669]                   name <- removed[[kk]]
[17:01:32.669]                   NAME <- NAMES[[kk]]
[17:01:32.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:32.669]                     next
[17:01:32.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:32.669]                 }
[17:01:32.669]                 if (length(args) > 0) 
[17:01:32.669]                   base::do.call(base::Sys.setenv, args = args)
[17:01:32.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:32.669]             }
[17:01:32.669]             else {
[17:01:32.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:32.669]             }
[17:01:32.669]             {
[17:01:32.669]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:32.669]                   0L) {
[17:01:32.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:32.669]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:32.669]                   base::options(opts)
[17:01:32.669]                 }
[17:01:32.669]                 {
[17:01:32.669]                   {
[17:01:32.669]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:32.669]                     NULL
[17:01:32.669]                   }
[17:01:32.669]                   options(future.plan = NULL)
[17:01:32.669]                   if (is.na(NA_character_)) 
[17:01:32.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:32.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:32.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:32.669]                     .init = FALSE)
[17:01:32.669]                 }
[17:01:32.669]             }
[17:01:32.669]         }
[17:01:32.669]     })
[17:01:32.669]     if (FALSE) {
[17:01:32.669]         base::sink(type = "output", split = FALSE)
[17:01:32.669]         if (NA) {
[17:01:32.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:32.669]         }
[17:01:32.669]         else {
[17:01:32.669]             ...future.result["stdout"] <- base::list(NULL)
[17:01:32.669]         }
[17:01:32.669]         base::close(...future.stdout)
[17:01:32.669]         ...future.stdout <- NULL
[17:01:32.669]     }
[17:01:32.669]     ...future.result$conditions <- ...future.conditions
[17:01:32.669]     ...future.result$finished <- base::Sys.time()
[17:01:32.669]     ...future.result
[17:01:32.669] }
[17:01:32.672] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:01:32.672] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:01:32.672] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:01:32.672] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:01:32.673] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:01:32.673] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:01:32.673] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:01:32.673] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:32.674] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:32.674] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:32.674] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:32.674] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:01:32.675] MultisessionFuture started
[17:01:32.675] - Launch lazy future ... done
[17:01:32.675] run() for ‘MultisessionFuture’ ... done
[17:01:32.675] Created future:
[17:01:32.675] MultisessionFuture:
[17:01:32.675] Label: ‘future_mapply-2’
[17:01:32.675] Expression:
[17:01:32.675] {
[17:01:32.675]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:32.675]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:32.675]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:32.675]         on.exit(options(oopts), add = TRUE)
[17:01:32.675]     }
[17:01:32.675]     {
[17:01:32.675]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:01:32.675]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:01:32.675]         do.call(mapply, args = args)
[17:01:32.675]     }
[17:01:32.675] }
[17:01:32.675] Lazy evaluation: FALSE
[17:01:32.675] Asynchronous evaluation: TRUE
[17:01:32.675] Local evaluation: TRUE
[17:01:32.675] Environment: R_GlobalEnv
[17:01:32.675] Capture standard output: NA
[17:01:32.675] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:32.675] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:32.675] Packages: <none>
[17:01:32.675] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:32.675] Resolved: FALSE
[17:01:32.675] Value: <not collected>
[17:01:32.675] Conditions captured: <none>
[17:01:32.675] Early signaling: FALSE
[17:01:32.675] Owner process: 1ce7c9c6-bb03-f11c-0cc2-7287dd68b9b8
[17:01:32.675] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:32.687] Chunk #2 of 2 ... DONE
[17:01:32.687] Launching 2 futures (chunks) ... DONE
[17:01:32.687] Resolving 2 futures (chunks) ...
[17:01:32.687] resolve() on list ...
[17:01:32.687]  recursive: 0
[17:01:32.688]  length: 2
[17:01:32.688] 
[17:01:32.730] receiveMessageFromWorker() for ClusterFuture ...
[17:01:32.730] - Validating connection of MultisessionFuture
[17:01:32.731] - received message: FutureResult
[17:01:32.731] - Received FutureResult
[17:01:32.731] - Erased future from FutureRegistry
[17:01:32.731] result() for ClusterFuture ...
[17:01:32.731] - result already collected: FutureResult
[17:01:32.731] result() for ClusterFuture ... done
[17:01:32.731] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:32.731] Future #2
[17:01:32.731] result() for ClusterFuture ...
[17:01:32.731] - result already collected: FutureResult
[17:01:32.732] result() for ClusterFuture ... done
[17:01:32.732] result() for ClusterFuture ...
[17:01:32.732] - result already collected: FutureResult
[17:01:32.732] result() for ClusterFuture ... done
[17:01:32.732] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:32.732] - nx: 2
[17:01:32.732] - relay: TRUE
[17:01:32.732] - stdout: TRUE
[17:01:32.732] - signal: TRUE
[17:01:32.732] - resignal: FALSE
[17:01:32.732] - force: TRUE
[17:01:32.732] - relayed: [n=2] FALSE, FALSE
[17:01:32.733] - queued futures: [n=2] FALSE, FALSE
[17:01:32.733]  - until=1
[17:01:32.733]  - relaying element #1
[17:01:32.733] - relayed: [n=2] FALSE, FALSE
[17:01:32.733] - queued futures: [n=2] FALSE, TRUE
[17:01:32.733] signalConditionsASAP(NULL, pos=2) ... done
[17:01:32.733]  length: 1 (resolved future 2)
[17:01:33.182] receiveMessageFromWorker() for ClusterFuture ...
[17:01:33.182] - Validating connection of MultisessionFuture
[17:01:33.182] - received message: FutureResult
[17:01:33.182] - Received FutureResult
[17:01:33.182] - Erased future from FutureRegistry
[17:01:33.182] result() for ClusterFuture ...
[17:01:33.183] - result already collected: FutureResult
[17:01:33.183] result() for ClusterFuture ... done
[17:01:33.183] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:33.183] Future #1
[17:01:33.183] result() for ClusterFuture ...
[17:01:33.183] - result already collected: FutureResult
[17:01:33.183] result() for ClusterFuture ... done
[17:01:33.183] result() for ClusterFuture ...
[17:01:33.183] - result already collected: FutureResult
[17:01:33.183] result() for ClusterFuture ... done
[17:01:33.184] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:33.184] - nx: 2
[17:01:33.184] - relay: TRUE
[17:01:33.184] - stdout: TRUE
[17:01:33.186] - signal: TRUE
[17:01:33.186] - resignal: FALSE
[17:01:33.186] - force: TRUE
[17:01:33.186] - relayed: [n=2] FALSE, FALSE
[17:01:33.186] - queued futures: [n=2] FALSE, TRUE
[17:01:33.186]  - until=1
[17:01:33.186]  - relaying element #1
[17:01:33.187] result() for ClusterFuture ...
[17:01:33.187] - result already collected: FutureResult
[17:01:33.187] result() for ClusterFuture ... done
[17:01:33.187] result() for ClusterFuture ...
[17:01:33.187] - result already collected: FutureResult
[17:01:33.187] result() for ClusterFuture ... done
[17:01:33.187] result() for ClusterFuture ...
[17:01:33.187] - result already collected: FutureResult
[17:01:33.187] result() for ClusterFuture ... done
[17:01:33.187] result() for ClusterFuture ...
[17:01:33.187] - result already collected: FutureResult
[17:01:33.188] result() for ClusterFuture ... done
[17:01:33.188] - relayed: [n=2] TRUE, FALSE
[17:01:33.188] - queued futures: [n=2] TRUE, TRUE
[17:01:33.188] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:33.188]  length: 0 (resolved future 1)
[17:01:33.188] Relaying remaining futures
[17:01:33.188] signalConditionsASAP(NULL, pos=0) ...
[17:01:33.188] - nx: 2
[17:01:33.188] - relay: TRUE
[17:01:33.188] - stdout: TRUE
[17:01:33.188] - signal: TRUE
[17:01:33.188] - resignal: FALSE
[17:01:33.188] - force: TRUE
[17:01:33.189] - relayed: [n=2] TRUE, FALSE
[17:01:33.189] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:33.189]  - relaying element #2
[17:01:33.189] result() for ClusterFuture ...
[17:01:33.189] - result already collected: FutureResult
[17:01:33.189] result() for ClusterFuture ... done
[17:01:33.189] result() for ClusterFuture ...
[17:01:33.189] - result already collected: FutureResult
[17:01:33.189] result() for ClusterFuture ... done
[17:01:33.189] result() for ClusterFuture ...
[17:01:33.189] - result already collected: FutureResult
[17:01:33.190] result() for ClusterFuture ... done
[17:01:33.190] result() for ClusterFuture ...
[17:01:33.190] - result already collected: FutureResult
[17:01:33.190] result() for ClusterFuture ... done
[17:01:33.190] - relayed: [n=2] TRUE, TRUE
[17:01:33.190] - queued futures: [n=2] TRUE, TRUE
[17:01:33.190] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:01:33.190] resolve() on list ... DONE
[17:01:33.190] result() for ClusterFuture ...
[17:01:33.190] - result already collected: FutureResult
[17:01:33.190] result() for ClusterFuture ... done
[17:01:33.190] result() for ClusterFuture ...
[17:01:33.191] - result already collected: FutureResult
[17:01:33.191] result() for ClusterFuture ... done
[17:01:33.191] result() for ClusterFuture ...
[17:01:33.191] - result already collected: FutureResult
[17:01:33.191] result() for ClusterFuture ... done
[17:01:33.191] result() for ClusterFuture ...
[17:01:33.191] - result already collected: FutureResult
[17:01:33.191] result() for ClusterFuture ... done
[17:01:33.191]  - Number of value chunks collected: 2
[17:01:33.191] Resolving 2 futures (chunks) ... DONE
[17:01:33.191] Reducing values from 2 chunks ...
[17:01:33.192]  - Number of values collected after concatenation: 2
[17:01:33.192]  - Number of values expected: 2
[17:01:33.192] Reducing values from 2 chunks ... DONE
[17:01:33.192] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[17:01:33.193] plan(): Setting new future strategy stack:
[17:01:33.193] List of future strategies:
[17:01:33.193] 1. FutureStrategy:
[17:01:33.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:33.193]    - tweaked: FALSE
[17:01:33.193]    - call: future::plan(oplan)
[17:01:33.194] plan(): nbrOfWorkers() = 1
> 
