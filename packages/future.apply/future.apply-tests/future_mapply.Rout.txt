
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:00:27.751] plan(): Setting new future strategy stack:
[17:00:27.751] List of future strategies:
[17:00:27.751] 1. sequential:
[17:00:27.751]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:27.751]    - tweaked: FALSE
[17:00:27.751]    - call: future::plan("sequential")
[17:00:27.766] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[17:00:27.775] plan(): Setting new future strategy stack:
[17:00:27.775] List of future strategies:
[17:00:27.775] 1. sequential:
[17:00:27.775]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:27.775]    - tweaked: FALSE
[17:00:27.775]    - call: plan(sequential)
[17:00:27.786] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[17:00:27.786] future_mapply() ...
[17:00:27.787] Generating random seeds ...
[17:00:27.787] Generating random seed streams for 4 elements ...
[17:00:27.788] Generating random seed streams for 4 elements ... DONE
[17:00:27.788] Generating random seeds ... DONE
[17:00:27.788] Will set RNG state on exit: 10407, 225186124, 229495892, 1624550703, 1511001139, -125291998, 2054632538
[17:00:27.788] Number of chunks: 1
[17:00:27.788] getGlobalsAndPackagesXApply() ...
[17:00:27.789]  - future.globals: TRUE
[17:00:27.789] getGlobalsAndPackages() ...
[17:00:27.789] Searching for globals...
[17:00:27.794] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:00:27.795] Searching for globals ... DONE
[17:00:27.795] Resolving globals: FALSE
[17:00:27.796] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:00:27.796] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:00:27.797] - globals: [1] ‘FUN’
[17:00:27.797] - packages: [1] ‘stats’
[17:00:27.797] getGlobalsAndPackages() ... DONE
[17:00:27.797]  - globals found/used: [n=1] ‘FUN’
[17:00:27.797]  - needed namespaces: [n=1] ‘stats’
[17:00:27.797] Finding globals ... DONE
[17:00:27.797] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:27.797] List of 2
[17:00:27.797]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:00:27.797]  $ MoreArgs     :List of 1
[17:00:27.797]   ..$ min: num 1
[17:00:27.797]  - attr(*, "where")=List of 2
[17:00:27.797]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:27.797]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:27.797]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:27.797]  - attr(*, "resolved")= logi FALSE
[17:00:27.797]  - attr(*, "total_size")= num NA
[17:00:27.802] Packages to be attached in all futures: [n=1] ‘stats’
[17:00:27.803] getGlobalsAndPackagesXApply() ... DONE
[17:00:27.803] Number of futures (= number of chunks): 1
[17:00:27.803] Launching 1 futures (chunks) ...
[17:00:27.806] Chunk #1 of 1 ...
[17:00:27.806]  - Finding globals in '...' for chunk #1 ...
[17:00:27.806] getGlobalsAndPackages() ...
[17:00:27.806] Searching for globals...
[17:00:27.807] 
[17:00:27.807] Searching for globals ... DONE
[17:00:27.807] - globals: [0] <none>
[17:00:27.807] getGlobalsAndPackages() ... DONE
[17:00:27.807]    + additional globals found: [n=0] 
[17:00:27.807]    + additional namespaces needed: [n=0] 
[17:00:27.807]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:27.807]  - seeds: [4] <seeds>
[17:00:27.808]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:27.808] getGlobalsAndPackages() ...
[17:00:27.808] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:27.808] Resolving globals: FALSE
[17:00:27.809] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[17:00:27.809] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[17:00:27.809] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:27.809] - packages: [1] ‘stats’
[17:00:27.809] getGlobalsAndPackages() ... DONE
[17:00:27.810] run() for ‘Future’ ...
[17:00:27.810] - state: ‘created’
[17:00:27.810] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:27.811] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:27.811] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:27.811]   - Field: ‘label’
[17:00:27.811]   - Field: ‘local’
[17:00:27.811]   - Field: ‘owner’
[17:00:27.811]   - Field: ‘envir’
[17:00:27.811]   - Field: ‘packages’
[17:00:27.812]   - Field: ‘gc’
[17:00:27.812]   - Field: ‘conditions’
[17:00:27.812]   - Field: ‘expr’
[17:00:27.812]   - Field: ‘uuid’
[17:00:27.812]   - Field: ‘seed’
[17:00:27.812]   - Field: ‘version’
[17:00:27.812]   - Field: ‘result’
[17:00:27.812]   - Field: ‘asynchronous’
[17:00:27.812]   - Field: ‘calls’
[17:00:27.812]   - Field: ‘globals’
[17:00:27.812]   - Field: ‘stdout’
[17:00:27.813]   - Field: ‘earlySignal’
[17:00:27.813]   - Field: ‘lazy’
[17:00:27.813]   - Field: ‘state’
[17:00:27.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:27.813] - Launch lazy future ...
[17:00:27.814] Packages needed by the future expression (n = 1): ‘stats’
[17:00:27.814] Packages needed by future strategies (n = 0): <none>
[17:00:27.814] {
[17:00:27.814]     {
[17:00:27.814]         {
[17:00:27.814]             ...future.startTime <- base::Sys.time()
[17:00:27.814]             {
[17:00:27.814]                 {
[17:00:27.814]                   {
[17:00:27.814]                     {
[17:00:27.814]                       base::local({
[17:00:27.814]                         has_future <- base::requireNamespace("future", 
[17:00:27.814]                           quietly = TRUE)
[17:00:27.814]                         if (has_future) {
[17:00:27.814]                           ns <- base::getNamespace("future")
[17:00:27.814]                           version <- ns[[".package"]][["version"]]
[17:00:27.814]                           if (is.null(version)) 
[17:00:27.814]                             version <- utils::packageVersion("future")
[17:00:27.814]                         }
[17:00:27.814]                         else {
[17:00:27.814]                           version <- NULL
[17:00:27.814]                         }
[17:00:27.814]                         if (!has_future || version < "1.8.0") {
[17:00:27.814]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:27.814]                             "", base::R.version$version.string), 
[17:00:27.814]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:27.814]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:27.814]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:27.814]                               "release", "version")], collapse = " "), 
[17:00:27.814]                             hostname = base::Sys.info()[["nodename"]])
[17:00:27.814]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:27.814]                             info)
[17:00:27.814]                           info <- base::paste(info, collapse = "; ")
[17:00:27.814]                           if (!has_future) {
[17:00:27.814]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:27.814]                               info)
[17:00:27.814]                           }
[17:00:27.814]                           else {
[17:00:27.814]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:27.814]                               info, version)
[17:00:27.814]                           }
[17:00:27.814]                           base::stop(msg)
[17:00:27.814]                         }
[17:00:27.814]                       })
[17:00:27.814]                     }
[17:00:27.814]                     base::local({
[17:00:27.814]                       for (pkg in "stats") {
[17:00:27.814]                         base::loadNamespace(pkg)
[17:00:27.814]                         base::library(pkg, character.only = TRUE)
[17:00:27.814]                       }
[17:00:27.814]                     })
[17:00:27.814]                   }
[17:00:27.814]                   ...future.strategy.old <- future::plan("list")
[17:00:27.814]                   options(future.plan = NULL)
[17:00:27.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:27.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:27.814]                 }
[17:00:27.814]                 ...future.workdir <- getwd()
[17:00:27.814]             }
[17:00:27.814]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:27.814]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:27.814]         }
[17:00:27.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:27.814]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:27.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:27.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:27.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:27.814]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:27.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:27.814]             base::names(...future.oldOptions))
[17:00:27.814]     }
[17:00:27.814]     if (FALSE) {
[17:00:27.814]     }
[17:00:27.814]     else {
[17:00:27.814]         if (TRUE) {
[17:00:27.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:27.814]                 open = "w")
[17:00:27.814]         }
[17:00:27.814]         else {
[17:00:27.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:27.814]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:27.814]         }
[17:00:27.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:27.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:27.814]             base::sink(type = "output", split = FALSE)
[17:00:27.814]             base::close(...future.stdout)
[17:00:27.814]         }, add = TRUE)
[17:00:27.814]     }
[17:00:27.814]     ...future.frame <- base::sys.nframe()
[17:00:27.814]     ...future.conditions <- base::list()
[17:00:27.814]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:27.814]     if (FALSE) {
[17:00:27.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:27.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:27.814]     }
[17:00:27.814]     ...future.result <- base::tryCatch({
[17:00:27.814]         base::withCallingHandlers({
[17:00:27.814]             ...future.value <- base::withVisible(base::local({
[17:00:27.814]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:27.814]                 if (!identical(...future.globals.maxSize.org, 
[17:00:27.814]                   ...future.globals.maxSize)) {
[17:00:27.814]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:27.814]                   on.exit(options(oopts), add = TRUE)
[17:00:27.814]                 }
[17:00:27.814]                 {
[17:00:27.814]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:27.814]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:27.814]                       envir = globalenv(), inherits = FALSE)
[17:00:27.814]                     ...future.FUN(...)
[17:00:27.814]                   }
[17:00:27.814]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:27.814]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:27.814]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:27.814]                     USE.NAMES = FALSE)
[17:00:27.814]                   do.call(mapply, args = args)
[17:00:27.814]                 }
[17:00:27.814]             }))
[17:00:27.814]             future::FutureResult(value = ...future.value$value, 
[17:00:27.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:27.814]                   ...future.rng), globalenv = if (FALSE) 
[17:00:27.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:27.814]                     ...future.globalenv.names))
[17:00:27.814]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:27.814]         }, condition = base::local({
[17:00:27.814]             c <- base::c
[17:00:27.814]             inherits <- base::inherits
[17:00:27.814]             invokeRestart <- base::invokeRestart
[17:00:27.814]             length <- base::length
[17:00:27.814]             list <- base::list
[17:00:27.814]             seq.int <- base::seq.int
[17:00:27.814]             signalCondition <- base::signalCondition
[17:00:27.814]             sys.calls <- base::sys.calls
[17:00:27.814]             `[[` <- base::`[[`
[17:00:27.814]             `+` <- base::`+`
[17:00:27.814]             `<<-` <- base::`<<-`
[17:00:27.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:27.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:27.814]                   3L)]
[17:00:27.814]             }
[17:00:27.814]             function(cond) {
[17:00:27.814]                 is_error <- inherits(cond, "error")
[17:00:27.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:27.814]                   NULL)
[17:00:27.814]                 if (is_error) {
[17:00:27.814]                   sessionInformation <- function() {
[17:00:27.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:27.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:27.814]                       search = base::search(), system = base::Sys.info())
[17:00:27.814]                   }
[17:00:27.814]                   ...future.conditions[[length(...future.conditions) + 
[17:00:27.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:27.814]                     cond$call), session = sessionInformation(), 
[17:00:27.814]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:27.814]                   signalCondition(cond)
[17:00:27.814]                 }
[17:00:27.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:27.814]                 "immediateCondition"))) {
[17:00:27.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:27.814]                   ...future.conditions[[length(...future.conditions) + 
[17:00:27.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:27.814]                   if (TRUE && !signal) {
[17:00:27.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:27.814]                     {
[17:00:27.814]                       inherits <- base::inherits
[17:00:27.814]                       invokeRestart <- base::invokeRestart
[17:00:27.814]                       is.null <- base::is.null
[17:00:27.814]                       muffled <- FALSE
[17:00:27.814]                       if (inherits(cond, "message")) {
[17:00:27.814]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:27.814]                         if (muffled) 
[17:00:27.814]                           invokeRestart("muffleMessage")
[17:00:27.814]                       }
[17:00:27.814]                       else if (inherits(cond, "warning")) {
[17:00:27.814]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:27.814]                         if (muffled) 
[17:00:27.814]                           invokeRestart("muffleWarning")
[17:00:27.814]                       }
[17:00:27.814]                       else if (inherits(cond, "condition")) {
[17:00:27.814]                         if (!is.null(pattern)) {
[17:00:27.814]                           computeRestarts <- base::computeRestarts
[17:00:27.814]                           grepl <- base::grepl
[17:00:27.814]                           restarts <- computeRestarts(cond)
[17:00:27.814]                           for (restart in restarts) {
[17:00:27.814]                             name <- restart$name
[17:00:27.814]                             if (is.null(name)) 
[17:00:27.814]                               next
[17:00:27.814]                             if (!grepl(pattern, name)) 
[17:00:27.814]                               next
[17:00:27.814]                             invokeRestart(restart)
[17:00:27.814]                             muffled <- TRUE
[17:00:27.814]                             break
[17:00:27.814]                           }
[17:00:27.814]                         }
[17:00:27.814]                       }
[17:00:27.814]                       invisible(muffled)
[17:00:27.814]                     }
[17:00:27.814]                     muffleCondition(cond, pattern = "^muffle")
[17:00:27.814]                   }
[17:00:27.814]                 }
[17:00:27.814]                 else {
[17:00:27.814]                   if (TRUE) {
[17:00:27.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:27.814]                     {
[17:00:27.814]                       inherits <- base::inherits
[17:00:27.814]                       invokeRestart <- base::invokeRestart
[17:00:27.814]                       is.null <- base::is.null
[17:00:27.814]                       muffled <- FALSE
[17:00:27.814]                       if (inherits(cond, "message")) {
[17:00:27.814]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:27.814]                         if (muffled) 
[17:00:27.814]                           invokeRestart("muffleMessage")
[17:00:27.814]                       }
[17:00:27.814]                       else if (inherits(cond, "warning")) {
[17:00:27.814]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:27.814]                         if (muffled) 
[17:00:27.814]                           invokeRestart("muffleWarning")
[17:00:27.814]                       }
[17:00:27.814]                       else if (inherits(cond, "condition")) {
[17:00:27.814]                         if (!is.null(pattern)) {
[17:00:27.814]                           computeRestarts <- base::computeRestarts
[17:00:27.814]                           grepl <- base::grepl
[17:00:27.814]                           restarts <- computeRestarts(cond)
[17:00:27.814]                           for (restart in restarts) {
[17:00:27.814]                             name <- restart$name
[17:00:27.814]                             if (is.null(name)) 
[17:00:27.814]                               next
[17:00:27.814]                             if (!grepl(pattern, name)) 
[17:00:27.814]                               next
[17:00:27.814]                             invokeRestart(restart)
[17:00:27.814]                             muffled <- TRUE
[17:00:27.814]                             break
[17:00:27.814]                           }
[17:00:27.814]                         }
[17:00:27.814]                       }
[17:00:27.814]                       invisible(muffled)
[17:00:27.814]                     }
[17:00:27.814]                     muffleCondition(cond, pattern = "^muffle")
[17:00:27.814]                   }
[17:00:27.814]                 }
[17:00:27.814]             }
[17:00:27.814]         }))
[17:00:27.814]     }, error = function(ex) {
[17:00:27.814]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:27.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:27.814]                 ...future.rng), started = ...future.startTime, 
[17:00:27.814]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:27.814]             version = "1.8"), class = "FutureResult")
[17:00:27.814]     }, finally = {
[17:00:27.814]         if (!identical(...future.workdir, getwd())) 
[17:00:27.814]             setwd(...future.workdir)
[17:00:27.814]         {
[17:00:27.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:27.814]                 ...future.oldOptions$nwarnings <- NULL
[17:00:27.814]             }
[17:00:27.814]             base::options(...future.oldOptions)
[17:00:27.814]             if (.Platform$OS.type == "windows") {
[17:00:27.814]                 old_names <- names(...future.oldEnvVars)
[17:00:27.814]                 envs <- base::Sys.getenv()
[17:00:27.814]                 names <- names(envs)
[17:00:27.814]                 common <- intersect(names, old_names)
[17:00:27.814]                 added <- setdiff(names, old_names)
[17:00:27.814]                 removed <- setdiff(old_names, names)
[17:00:27.814]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:27.814]                   envs[common]]
[17:00:27.814]                 NAMES <- toupper(changed)
[17:00:27.814]                 args <- list()
[17:00:27.814]                 for (kk in seq_along(NAMES)) {
[17:00:27.814]                   name <- changed[[kk]]
[17:00:27.814]                   NAME <- NAMES[[kk]]
[17:00:27.814]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:27.814]                     next
[17:00:27.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:27.814]                 }
[17:00:27.814]                 NAMES <- toupper(added)
[17:00:27.814]                 for (kk in seq_along(NAMES)) {
[17:00:27.814]                   name <- added[[kk]]
[17:00:27.814]                   NAME <- NAMES[[kk]]
[17:00:27.814]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:27.814]                     next
[17:00:27.814]                   args[[name]] <- ""
[17:00:27.814]                 }
[17:00:27.814]                 NAMES <- toupper(removed)
[17:00:27.814]                 for (kk in seq_along(NAMES)) {
[17:00:27.814]                   name <- removed[[kk]]
[17:00:27.814]                   NAME <- NAMES[[kk]]
[17:00:27.814]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:27.814]                     next
[17:00:27.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:27.814]                 }
[17:00:27.814]                 if (length(args) > 0) 
[17:00:27.814]                   base::do.call(base::Sys.setenv, args = args)
[17:00:27.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:27.814]             }
[17:00:27.814]             else {
[17:00:27.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:27.814]             }
[17:00:27.814]             {
[17:00:27.814]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:27.814]                   0L) {
[17:00:27.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:27.814]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:27.814]                   base::options(opts)
[17:00:27.814]                 }
[17:00:27.814]                 {
[17:00:27.814]                   {
[17:00:27.814]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:27.814]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:27.814]                     2054632538L), envir = base::globalenv(), 
[17:00:27.814]                       inherits = FALSE)
[17:00:27.814]                     NULL
[17:00:27.814]                   }
[17:00:27.814]                   options(future.plan = NULL)
[17:00:27.814]                   if (is.na(NA_character_)) 
[17:00:27.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:27.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:27.814]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:27.814]                     .init = FALSE)
[17:00:27.814]                 }
[17:00:27.814]             }
[17:00:27.814]         }
[17:00:27.814]     })
[17:00:27.814]     if (TRUE) {
[17:00:27.814]         base::sink(type = "output", split = FALSE)
[17:00:27.814]         if (TRUE) {
[17:00:27.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:27.814]         }
[17:00:27.814]         else {
[17:00:27.814]             ...future.result["stdout"] <- base::list(NULL)
[17:00:27.814]         }
[17:00:27.814]         base::close(...future.stdout)
[17:00:27.814]         ...future.stdout <- NULL
[17:00:27.814]     }
[17:00:27.814]     ...future.result$conditions <- ...future.conditions
[17:00:27.814]     ...future.result$finished <- base::Sys.time()
[17:00:27.814]     ...future.result
[17:00:27.814] }
[17:00:27.816] assign_globals() ...
[17:00:27.817] List of 5
[17:00:27.817]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:00:27.817]  $ MoreArgs                 :List of 1
[17:00:27.817]   ..$ min: num 1
[17:00:27.817]  $ ...future.elements_ii    :List of 2
[17:00:27.817]   ..$ n  :List of 4
[17:00:27.817]   .. ..$ : int 1
[17:00:27.817]   .. ..$ : int 2
[17:00:27.817]   .. ..$ : int 3
[17:00:27.817]   .. ..$ : int 4
[17:00:27.817]   ..$ max:List of 4
[17:00:27.817]   .. ..$ : int 2
[17:00:27.817]   .. ..$ : int 3
[17:00:27.817]   .. ..$ : int 4
[17:00:27.817]   .. ..$ : int 5
[17:00:27.817]  $ ...future.seeds_ii       :List of 4
[17:00:27.817]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:00:27.817]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:00:27.817]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[17:00:27.817]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[17:00:27.817]  $ ...future.globals.maxSize: NULL
[17:00:27.817]  - attr(*, "where")=List of 5
[17:00:27.817]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:27.817]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:27.817]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:27.817]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:27.817]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:27.817]  - attr(*, "resolved")= logi FALSE
[17:00:27.817]  - attr(*, "total_size")= num 2912
[17:00:27.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:27.817]  - attr(*, "already-done")= logi TRUE
[17:00:27.825] - copied ‘...future.FUN’ to environment
[17:00:27.825] - copied ‘MoreArgs’ to environment
[17:00:27.825] - copied ‘...future.elements_ii’ to environment
[17:00:27.825] - copied ‘...future.seeds_ii’ to environment
[17:00:27.825] - copied ‘...future.globals.maxSize’ to environment
[17:00:27.825] assign_globals() ... done
[17:00:27.826] plan(): Setting new future strategy stack:
[17:00:27.826] List of future strategies:
[17:00:27.826] 1. sequential:
[17:00:27.826]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:27.826]    - tweaked: FALSE
[17:00:27.826]    - call: NULL
[17:00:27.826] plan(): nbrOfWorkers() = 1
[17:00:27.828] plan(): Setting new future strategy stack:
[17:00:27.828] List of future strategies:
[17:00:27.828] 1. sequential:
[17:00:27.828]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:27.828]    - tweaked: FALSE
[17:00:27.828]    - call: plan(sequential)
[17:00:27.828] plan(): nbrOfWorkers() = 1
[17:00:27.828] SequentialFuture started (and completed)
[17:00:27.829] - Launch lazy future ... done
[17:00:27.829] run() for ‘SequentialFuture’ ... done
[17:00:27.829] Created future:
[17:00:27.829] SequentialFuture:
[17:00:27.829] Label: ‘future_mapply-1’
[17:00:27.829] Expression:
[17:00:27.829] {
[17:00:27.829]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:27.829]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:27.829]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:27.829]         on.exit(options(oopts), add = TRUE)
[17:00:27.829]     }
[17:00:27.829]     {
[17:00:27.829]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:27.829]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:27.829]                 inherits = FALSE)
[17:00:27.829]             ...future.FUN(...)
[17:00:27.829]         }
[17:00:27.829]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:27.829]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:27.829]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:27.829]         do.call(mapply, args = args)
[17:00:27.829]     }
[17:00:27.829] }
[17:00:27.829] Lazy evaluation: FALSE
[17:00:27.829] Asynchronous evaluation: FALSE
[17:00:27.829] Local evaluation: TRUE
[17:00:27.829] Environment: R_GlobalEnv
[17:00:27.829] Capture standard output: TRUE
[17:00:27.829] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:27.829] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:27.829] Packages: 1 packages (‘stats’)
[17:00:27.829] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:27.829] Resolved: TRUE
[17:00:27.829] Value: 280 bytes of class ‘list’
[17:00:27.829] Early signaling: FALSE
[17:00:27.829] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:27.829] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:27.831] Chunk #1 of 1 ... DONE
[17:00:27.831] Launching 1 futures (chunks) ... DONE
[17:00:27.831] Resolving 1 futures (chunks) ...
[17:00:27.831] resolve() on list ...
[17:00:27.831]  recursive: 0
[17:00:27.832]  length: 1
[17:00:27.832] 
[17:00:27.832] resolved() for ‘SequentialFuture’ ...
[17:00:27.832] - state: ‘finished’
[17:00:27.832] - run: TRUE
[17:00:27.832] - result: ‘FutureResult’
[17:00:27.832] resolved() for ‘SequentialFuture’ ... done
[17:00:27.832] Future #1
[17:00:27.833] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:27.833] - nx: 1
[17:00:27.833] - relay: TRUE
[17:00:27.833] - stdout: TRUE
[17:00:27.833] - signal: TRUE
[17:00:27.833] - resignal: FALSE
[17:00:27.833] - force: TRUE
[17:00:27.833] - relayed: [n=1] FALSE
[17:00:27.833] - queued futures: [n=1] FALSE
[17:00:27.834]  - until=1
[17:00:27.834]  - relaying element #1
[17:00:27.834] - relayed: [n=1] TRUE
[17:00:27.834] - queued futures: [n=1] TRUE
[17:00:27.834] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:27.834]  length: 0 (resolved future 1)
[17:00:27.834] Relaying remaining futures
[17:00:27.834] signalConditionsASAP(NULL, pos=0) ...
[17:00:27.834] - nx: 1
[17:00:27.835] - relay: TRUE
[17:00:27.835] - stdout: TRUE
[17:00:27.835] - signal: TRUE
[17:00:27.835] - resignal: FALSE
[17:00:27.835] - force: TRUE
[17:00:27.835] - relayed: [n=1] TRUE
[17:00:27.835] - queued futures: [n=1] TRUE
 - flush all
[17:00:27.835] - relayed: [n=1] TRUE
[17:00:27.835] - queued futures: [n=1] TRUE
[17:00:27.835] signalConditionsASAP(NULL, pos=0) ... done
[17:00:27.835] resolve() on list ... DONE
[17:00:27.836]  - Number of value chunks collected: 1
[17:00:27.836] Resolving 1 futures (chunks) ... DONE
[17:00:27.836] Reducing values from 1 chunks ...
[17:00:27.836]  - Number of values collected after concatenation: 4
[17:00:27.836]  - Number of values expected: 4
[17:00:27.836] Reducing values from 1 chunks ... DONE
[17:00:27.836] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:00:27.999] plan(): Setting new future strategy stack:
[17:00:27.999] List of future strategies:
[17:00:27.999] 1. sequential:
[17:00:27.999]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:27.999]    - tweaked: FALSE
[17:00:27.999]    - call: plan(strategy)
[17:00:28.000] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[17:00:28.000] future_mapply() ...
[17:00:28.000] Number of chunks: 1
[17:00:28.000] getGlobalsAndPackagesXApply() ...
[17:00:28.000]  - future.globals: TRUE
[17:00:28.000] getGlobalsAndPackages() ...
[17:00:28.001] Searching for globals...
[17:00:28.001] - globals found: [1] ‘FUN’
[17:00:28.001] Searching for globals ... DONE
[17:00:28.001] Resolving globals: FALSE
[17:00:28.002] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:28.002] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:28.002] - globals: [1] ‘FUN’
[17:00:28.002] 
[17:00:28.002] getGlobalsAndPackages() ... DONE
[17:00:28.002]  - globals found/used: [n=1] ‘FUN’
[17:00:28.002]  - needed namespaces: [n=0] 
[17:00:28.002] Finding globals ... DONE
[17:00:28.003] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.003] List of 2
[17:00:28.003]  $ ...future.FUN:function (x, ...)  
[17:00:28.003]  $ MoreArgs     : NULL
[17:00:28.003]  - attr(*, "where")=List of 2
[17:00:28.003]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.003]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.003]  - attr(*, "resolved")= logi FALSE
[17:00:28.003]  - attr(*, "total_size")= num NA
[17:00:28.005] Packages to be attached in all futures: [n=0] 
[17:00:28.005] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.006] Number of futures (= number of chunks): 1
[17:00:28.006] Launching 1 futures (chunks) ...
[17:00:28.006] Chunk #1 of 1 ...
[17:00:28.006]  - Finding globals in '...' for chunk #1 ...
[17:00:28.006] getGlobalsAndPackages() ...
[17:00:28.006] Searching for globals...
[17:00:28.006] 
[17:00:28.006] Searching for globals ... DONE
[17:00:28.007] - globals: [0] <none>
[17:00:28.007] getGlobalsAndPackages() ... DONE
[17:00:28.007]    + additional globals found: [n=0] 
[17:00:28.007]    + additional namespaces needed: [n=0] 
[17:00:28.007]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.007]  - seeds: <none>
[17:00:28.007]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.007] getGlobalsAndPackages() ...
[17:00:28.007] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.007] Resolving globals: FALSE
[17:00:28.008] The total size of the 5 globals is 504 bytes (504 bytes)
[17:00:28.008] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.008] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.009] 
[17:00:28.009] getGlobalsAndPackages() ... DONE
[17:00:28.009] run() for ‘Future’ ...
[17:00:28.009] - state: ‘created’
[17:00:28.009] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.010] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.010] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.010]   - Field: ‘label’
[17:00:28.010]   - Field: ‘local’
[17:00:28.010]   - Field: ‘owner’
[17:00:28.010]   - Field: ‘envir’
[17:00:28.010]   - Field: ‘packages’
[17:00:28.010]   - Field: ‘gc’
[17:00:28.010]   - Field: ‘conditions’
[17:00:28.010]   - Field: ‘expr’
[17:00:28.010]   - Field: ‘uuid’
[17:00:28.011]   - Field: ‘seed’
[17:00:28.011]   - Field: ‘version’
[17:00:28.011]   - Field: ‘result’
[17:00:28.011]   - Field: ‘asynchronous’
[17:00:28.011]   - Field: ‘calls’
[17:00:28.011]   - Field: ‘globals’
[17:00:28.011]   - Field: ‘stdout’
[17:00:28.011]   - Field: ‘earlySignal’
[17:00:28.011]   - Field: ‘lazy’
[17:00:28.011]   - Field: ‘state’
[17:00:28.011] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.012] - Launch lazy future ...
[17:00:28.012] Packages needed by the future expression (n = 0): <none>
[17:00:28.012] Packages needed by future strategies (n = 0): <none>
[17:00:28.014] {
[17:00:28.014]     {
[17:00:28.014]         {
[17:00:28.014]             ...future.startTime <- base::Sys.time()
[17:00:28.014]             {
[17:00:28.014]                 {
[17:00:28.014]                   {
[17:00:28.014]                     base::local({
[17:00:28.014]                       has_future <- base::requireNamespace("future", 
[17:00:28.014]                         quietly = TRUE)
[17:00:28.014]                       if (has_future) {
[17:00:28.014]                         ns <- base::getNamespace("future")
[17:00:28.014]                         version <- ns[[".package"]][["version"]]
[17:00:28.014]                         if (is.null(version)) 
[17:00:28.014]                           version <- utils::packageVersion("future")
[17:00:28.014]                       }
[17:00:28.014]                       else {
[17:00:28.014]                         version <- NULL
[17:00:28.014]                       }
[17:00:28.014]                       if (!has_future || version < "1.8.0") {
[17:00:28.014]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.014]                           "", base::R.version$version.string), 
[17:00:28.014]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.014]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.014]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.014]                             "release", "version")], collapse = " "), 
[17:00:28.014]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.014]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.014]                           info)
[17:00:28.014]                         info <- base::paste(info, collapse = "; ")
[17:00:28.014]                         if (!has_future) {
[17:00:28.014]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.014]                             info)
[17:00:28.014]                         }
[17:00:28.014]                         else {
[17:00:28.014]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.014]                             info, version)
[17:00:28.014]                         }
[17:00:28.014]                         base::stop(msg)
[17:00:28.014]                       }
[17:00:28.014]                     })
[17:00:28.014]                   }
[17:00:28.014]                   ...future.strategy.old <- future::plan("list")
[17:00:28.014]                   options(future.plan = NULL)
[17:00:28.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.014]                 }
[17:00:28.014]                 ...future.workdir <- getwd()
[17:00:28.014]             }
[17:00:28.014]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.014]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.014]         }
[17:00:28.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.014]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.014]             base::names(...future.oldOptions))
[17:00:28.014]     }
[17:00:28.014]     if (FALSE) {
[17:00:28.014]     }
[17:00:28.014]     else {
[17:00:28.014]         if (TRUE) {
[17:00:28.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.014]                 open = "w")
[17:00:28.014]         }
[17:00:28.014]         else {
[17:00:28.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.014]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.014]         }
[17:00:28.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.014]             base::sink(type = "output", split = FALSE)
[17:00:28.014]             base::close(...future.stdout)
[17:00:28.014]         }, add = TRUE)
[17:00:28.014]     }
[17:00:28.014]     ...future.frame <- base::sys.nframe()
[17:00:28.014]     ...future.conditions <- base::list()
[17:00:28.014]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.014]     if (FALSE) {
[17:00:28.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.014]     }
[17:00:28.014]     ...future.result <- base::tryCatch({
[17:00:28.014]         base::withCallingHandlers({
[17:00:28.014]             ...future.value <- base::withVisible(base::local({
[17:00:28.014]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.014]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.014]                   ...future.globals.maxSize)) {
[17:00:28.014]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.014]                   on.exit(options(oopts), add = TRUE)
[17:00:28.014]                 }
[17:00:28.014]                 {
[17:00:28.014]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.014]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.014]                     USE.NAMES = FALSE)
[17:00:28.014]                   do.call(mapply, args = args)
[17:00:28.014]                 }
[17:00:28.014]             }))
[17:00:28.014]             future::FutureResult(value = ...future.value$value, 
[17:00:28.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.014]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.014]                     ...future.globalenv.names))
[17:00:28.014]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.014]         }, condition = base::local({
[17:00:28.014]             c <- base::c
[17:00:28.014]             inherits <- base::inherits
[17:00:28.014]             invokeRestart <- base::invokeRestart
[17:00:28.014]             length <- base::length
[17:00:28.014]             list <- base::list
[17:00:28.014]             seq.int <- base::seq.int
[17:00:28.014]             signalCondition <- base::signalCondition
[17:00:28.014]             sys.calls <- base::sys.calls
[17:00:28.014]             `[[` <- base::`[[`
[17:00:28.014]             `+` <- base::`+`
[17:00:28.014]             `<<-` <- base::`<<-`
[17:00:28.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.014]                   3L)]
[17:00:28.014]             }
[17:00:28.014]             function(cond) {
[17:00:28.014]                 is_error <- inherits(cond, "error")
[17:00:28.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.014]                   NULL)
[17:00:28.014]                 if (is_error) {
[17:00:28.014]                   sessionInformation <- function() {
[17:00:28.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.014]                       search = base::search(), system = base::Sys.info())
[17:00:28.014]                   }
[17:00:28.014]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.014]                     cond$call), session = sessionInformation(), 
[17:00:28.014]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.014]                   signalCondition(cond)
[17:00:28.014]                 }
[17:00:28.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.014]                 "immediateCondition"))) {
[17:00:28.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.014]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.014]                   if (TRUE && !signal) {
[17:00:28.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.014]                     {
[17:00:28.014]                       inherits <- base::inherits
[17:00:28.014]                       invokeRestart <- base::invokeRestart
[17:00:28.014]                       is.null <- base::is.null
[17:00:28.014]                       muffled <- FALSE
[17:00:28.014]                       if (inherits(cond, "message")) {
[17:00:28.014]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.014]                         if (muffled) 
[17:00:28.014]                           invokeRestart("muffleMessage")
[17:00:28.014]                       }
[17:00:28.014]                       else if (inherits(cond, "warning")) {
[17:00:28.014]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.014]                         if (muffled) 
[17:00:28.014]                           invokeRestart("muffleWarning")
[17:00:28.014]                       }
[17:00:28.014]                       else if (inherits(cond, "condition")) {
[17:00:28.014]                         if (!is.null(pattern)) {
[17:00:28.014]                           computeRestarts <- base::computeRestarts
[17:00:28.014]                           grepl <- base::grepl
[17:00:28.014]                           restarts <- computeRestarts(cond)
[17:00:28.014]                           for (restart in restarts) {
[17:00:28.014]                             name <- restart$name
[17:00:28.014]                             if (is.null(name)) 
[17:00:28.014]                               next
[17:00:28.014]                             if (!grepl(pattern, name)) 
[17:00:28.014]                               next
[17:00:28.014]                             invokeRestart(restart)
[17:00:28.014]                             muffled <- TRUE
[17:00:28.014]                             break
[17:00:28.014]                           }
[17:00:28.014]                         }
[17:00:28.014]                       }
[17:00:28.014]                       invisible(muffled)
[17:00:28.014]                     }
[17:00:28.014]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.014]                   }
[17:00:28.014]                 }
[17:00:28.014]                 else {
[17:00:28.014]                   if (TRUE) {
[17:00:28.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.014]                     {
[17:00:28.014]                       inherits <- base::inherits
[17:00:28.014]                       invokeRestart <- base::invokeRestart
[17:00:28.014]                       is.null <- base::is.null
[17:00:28.014]                       muffled <- FALSE
[17:00:28.014]                       if (inherits(cond, "message")) {
[17:00:28.014]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.014]                         if (muffled) 
[17:00:28.014]                           invokeRestart("muffleMessage")
[17:00:28.014]                       }
[17:00:28.014]                       else if (inherits(cond, "warning")) {
[17:00:28.014]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.014]                         if (muffled) 
[17:00:28.014]                           invokeRestart("muffleWarning")
[17:00:28.014]                       }
[17:00:28.014]                       else if (inherits(cond, "condition")) {
[17:00:28.014]                         if (!is.null(pattern)) {
[17:00:28.014]                           computeRestarts <- base::computeRestarts
[17:00:28.014]                           grepl <- base::grepl
[17:00:28.014]                           restarts <- computeRestarts(cond)
[17:00:28.014]                           for (restart in restarts) {
[17:00:28.014]                             name <- restart$name
[17:00:28.014]                             if (is.null(name)) 
[17:00:28.014]                               next
[17:00:28.014]                             if (!grepl(pattern, name)) 
[17:00:28.014]                               next
[17:00:28.014]                             invokeRestart(restart)
[17:00:28.014]                             muffled <- TRUE
[17:00:28.014]                             break
[17:00:28.014]                           }
[17:00:28.014]                         }
[17:00:28.014]                       }
[17:00:28.014]                       invisible(muffled)
[17:00:28.014]                     }
[17:00:28.014]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.014]                   }
[17:00:28.014]                 }
[17:00:28.014]             }
[17:00:28.014]         }))
[17:00:28.014]     }, error = function(ex) {
[17:00:28.014]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.014]                 ...future.rng), started = ...future.startTime, 
[17:00:28.014]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.014]             version = "1.8"), class = "FutureResult")
[17:00:28.014]     }, finally = {
[17:00:28.014]         if (!identical(...future.workdir, getwd())) 
[17:00:28.014]             setwd(...future.workdir)
[17:00:28.014]         {
[17:00:28.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.014]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.014]             }
[17:00:28.014]             base::options(...future.oldOptions)
[17:00:28.014]             if (.Platform$OS.type == "windows") {
[17:00:28.014]                 old_names <- names(...future.oldEnvVars)
[17:00:28.014]                 envs <- base::Sys.getenv()
[17:00:28.014]                 names <- names(envs)
[17:00:28.014]                 common <- intersect(names, old_names)
[17:00:28.014]                 added <- setdiff(names, old_names)
[17:00:28.014]                 removed <- setdiff(old_names, names)
[17:00:28.014]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.014]                   envs[common]]
[17:00:28.014]                 NAMES <- toupper(changed)
[17:00:28.014]                 args <- list()
[17:00:28.014]                 for (kk in seq_along(NAMES)) {
[17:00:28.014]                   name <- changed[[kk]]
[17:00:28.014]                   NAME <- NAMES[[kk]]
[17:00:28.014]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.014]                     next
[17:00:28.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.014]                 }
[17:00:28.014]                 NAMES <- toupper(added)
[17:00:28.014]                 for (kk in seq_along(NAMES)) {
[17:00:28.014]                   name <- added[[kk]]
[17:00:28.014]                   NAME <- NAMES[[kk]]
[17:00:28.014]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.014]                     next
[17:00:28.014]                   args[[name]] <- ""
[17:00:28.014]                 }
[17:00:28.014]                 NAMES <- toupper(removed)
[17:00:28.014]                 for (kk in seq_along(NAMES)) {
[17:00:28.014]                   name <- removed[[kk]]
[17:00:28.014]                   NAME <- NAMES[[kk]]
[17:00:28.014]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.014]                     next
[17:00:28.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.014]                 }
[17:00:28.014]                 if (length(args) > 0) 
[17:00:28.014]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.014]             }
[17:00:28.014]             else {
[17:00:28.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.014]             }
[17:00:28.014]             {
[17:00:28.014]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.014]                   0L) {
[17:00:28.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.014]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.014]                   base::options(opts)
[17:00:28.014]                 }
[17:00:28.014]                 {
[17:00:28.014]                   {
[17:00:28.014]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.014]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.014]                     2054632538L), envir = base::globalenv(), 
[17:00:28.014]                       inherits = FALSE)
[17:00:28.014]                     NULL
[17:00:28.014]                   }
[17:00:28.014]                   options(future.plan = NULL)
[17:00:28.014]                   if (is.na(NA_character_)) 
[17:00:28.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.014]                     .init = FALSE)
[17:00:28.014]                 }
[17:00:28.014]             }
[17:00:28.014]         }
[17:00:28.014]     })
[17:00:28.014]     if (TRUE) {
[17:00:28.014]         base::sink(type = "output", split = FALSE)
[17:00:28.014]         if (TRUE) {
[17:00:28.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.014]         }
[17:00:28.014]         else {
[17:00:28.014]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.014]         }
[17:00:28.014]         base::close(...future.stdout)
[17:00:28.014]         ...future.stdout <- NULL
[17:00:28.014]     }
[17:00:28.014]     ...future.result$conditions <- ...future.conditions
[17:00:28.014]     ...future.result$finished <- base::Sys.time()
[17:00:28.014]     ...future.result
[17:00:28.014] }
[17:00:28.016] assign_globals() ...
[17:00:28.016] List of 5
[17:00:28.016]  $ ...future.FUN            :function (x, ...)  
[17:00:28.016]  $ MoreArgs                 : NULL
[17:00:28.016]  $ ...future.elements_ii    :List of 2
[17:00:28.016]   ..$ :List of 4
[17:00:28.016]   .. ..$ : int 1
[17:00:28.016]   .. ..$ : int 2
[17:00:28.016]   .. ..$ : int 3
[17:00:28.016]   .. ..$ : int 4
[17:00:28.016]   ..$ :List of 4
[17:00:28.016]   .. ..$ : int 4
[17:00:28.016]   .. ..$ : int 3
[17:00:28.016]   .. ..$ : int 2
[17:00:28.016]   .. ..$ : int 1
[17:00:28.016]  $ ...future.seeds_ii       : NULL
[17:00:28.016]  $ ...future.globals.maxSize: NULL
[17:00:28.016]  - attr(*, "where")=List of 5
[17:00:28.016]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.016]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.016]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.016]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.016]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.016]  - attr(*, "resolved")= logi FALSE
[17:00:28.016]  - attr(*, "total_size")= num 504
[17:00:28.016]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.016]  - attr(*, "already-done")= logi TRUE
[17:00:28.022] - copied ‘...future.FUN’ to environment
[17:00:28.022] - copied ‘MoreArgs’ to environment
[17:00:28.022] - copied ‘...future.elements_ii’ to environment
[17:00:28.022] - copied ‘...future.seeds_ii’ to environment
[17:00:28.023] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.023] assign_globals() ... done
[17:00:28.023] plan(): Setting new future strategy stack:
[17:00:28.023] List of future strategies:
[17:00:28.023] 1. sequential:
[17:00:28.023]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.023]    - tweaked: FALSE
[17:00:28.023]    - call: NULL
[17:00:28.023] plan(): nbrOfWorkers() = 1
[17:00:28.024] plan(): Setting new future strategy stack:
[17:00:28.024] List of future strategies:
[17:00:28.024] 1. sequential:
[17:00:28.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.024]    - tweaked: FALSE
[17:00:28.024]    - call: plan(strategy)
[17:00:28.025] plan(): nbrOfWorkers() = 1
[17:00:28.025] SequentialFuture started (and completed)
[17:00:28.025] - Launch lazy future ... done
[17:00:28.025] run() for ‘SequentialFuture’ ... done
[17:00:28.025] Created future:
[17:00:28.025] SequentialFuture:
[17:00:28.025] Label: ‘future_mapply-1’
[17:00:28.025] Expression:
[17:00:28.025] {
[17:00:28.025]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.025]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.025]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.025]         on.exit(options(oopts), add = TRUE)
[17:00:28.025]     }
[17:00:28.025]     {
[17:00:28.025]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.025]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.025]         do.call(mapply, args = args)
[17:00:28.025]     }
[17:00:28.025] }
[17:00:28.025] Lazy evaluation: FALSE
[17:00:28.025] Asynchronous evaluation: FALSE
[17:00:28.025] Local evaluation: TRUE
[17:00:28.025] Environment: R_GlobalEnv
[17:00:28.025] Capture standard output: TRUE
[17:00:28.025] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.025] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.025] Packages: <none>
[17:00:28.025] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.025] Resolved: TRUE
[17:00:28.025] Value: 240 bytes of class ‘list’
[17:00:28.025] Early signaling: FALSE
[17:00:28.025] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.025] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.026] Chunk #1 of 1 ... DONE
[17:00:28.026] Launching 1 futures (chunks) ... DONE
[17:00:28.026] Resolving 1 futures (chunks) ...
[17:00:28.027] resolve() on list ...
[17:00:28.027]  recursive: 0
[17:00:28.027]  length: 1
[17:00:28.027] 
[17:00:28.027] resolved() for ‘SequentialFuture’ ...
[17:00:28.027] - state: ‘finished’
[17:00:28.027] - run: TRUE
[17:00:28.027] - result: ‘FutureResult’
[17:00:28.027] resolved() for ‘SequentialFuture’ ... done
[17:00:28.027] Future #1
[17:00:28.028] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.028] - nx: 1
[17:00:28.028] - relay: TRUE
[17:00:28.028] - stdout: TRUE
[17:00:28.028] - signal: TRUE
[17:00:28.028] - resignal: FALSE
[17:00:28.028] - force: TRUE
[17:00:28.028] - relayed: [n=1] FALSE
[17:00:28.028] - queued futures: [n=1] FALSE
[17:00:28.028]  - until=1
[17:00:28.028]  - relaying element #1
[17:00:28.029] - relayed: [n=1] TRUE
[17:00:28.029] - queued futures: [n=1] TRUE
[17:00:28.029] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.029]  length: 0 (resolved future 1)
[17:00:28.029] Relaying remaining futures
[17:00:28.029] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.029] - nx: 1
[17:00:28.029] - relay: TRUE
[17:00:28.029] - stdout: TRUE
[17:00:28.029] - signal: TRUE
[17:00:28.029] - resignal: FALSE
[17:00:28.029] - force: TRUE
[17:00:28.030] - relayed: [n=1] TRUE
[17:00:28.030] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.030] - relayed: [n=1] TRUE
[17:00:28.030] - queued futures: [n=1] TRUE
[17:00:28.030] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.030] resolve() on list ... DONE
[17:00:28.030]  - Number of value chunks collected: 1
[17:00:28.030] Resolving 1 futures (chunks) ... DONE
[17:00:28.030] Reducing values from 1 chunks ...
[17:00:28.030]  - Number of values collected after concatenation: 4
[17:00:28.031]  - Number of values expected: 4
[17:00:28.031] Reducing values from 1 chunks ... DONE
[17:00:28.031] future_mapply() ... DONE
[17:00:28.031] future_mapply() ...
[17:00:28.031] Number of chunks: 1
[17:00:28.031] getGlobalsAndPackagesXApply() ...
[17:00:28.031]  - future.globals: TRUE
[17:00:28.031] getGlobalsAndPackages() ...
[17:00:28.031] Searching for globals...
[17:00:28.032] - globals found: [1] ‘FUN’
[17:00:28.032] Searching for globals ... DONE
[17:00:28.032] Resolving globals: FALSE
[17:00:28.032] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:28.033] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:28.033] - globals: [1] ‘FUN’
[17:00:28.033] 
[17:00:28.033] getGlobalsAndPackages() ... DONE
[17:00:28.033]  - globals found/used: [n=1] ‘FUN’
[17:00:28.033]  - needed namespaces: [n=0] 
[17:00:28.033] Finding globals ... DONE
[17:00:28.034] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.034] List of 2
[17:00:28.034]  $ ...future.FUN:function (x, ...)  
[17:00:28.034]  $ MoreArgs     : NULL
[17:00:28.034]  - attr(*, "where")=List of 2
[17:00:28.034]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.034]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.034]  - attr(*, "resolved")= logi FALSE
[17:00:28.034]  - attr(*, "total_size")= num NA
[17:00:28.036] Packages to be attached in all futures: [n=0] 
[17:00:28.036] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.036] Number of futures (= number of chunks): 1
[17:00:28.036] Launching 1 futures (chunks) ...
[17:00:28.037] Chunk #1 of 1 ...
[17:00:28.037]  - Finding globals in '...' for chunk #1 ...
[17:00:28.037] getGlobalsAndPackages() ...
[17:00:28.037] Searching for globals...
[17:00:28.037] 
[17:00:28.037] Searching for globals ... DONE
[17:00:28.037] - globals: [0] <none>
[17:00:28.037] getGlobalsAndPackages() ... DONE
[17:00:28.037]    + additional globals found: [n=0] 
[17:00:28.038]    + additional namespaces needed: [n=0] 
[17:00:28.038]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.038]  - seeds: <none>
[17:00:28.038]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.038] getGlobalsAndPackages() ...
[17:00:28.038] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.038] Resolving globals: FALSE
[17:00:28.040] The total size of the 5 globals is 504 bytes (504 bytes)
[17:00:28.041] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.041] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.041] 
[17:00:28.041] getGlobalsAndPackages() ... DONE
[17:00:28.042] run() for ‘Future’ ...
[17:00:28.042] - state: ‘created’
[17:00:28.042] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.042] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.042] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.042]   - Field: ‘label’
[17:00:28.042]   - Field: ‘local’
[17:00:28.043]   - Field: ‘owner’
[17:00:28.043]   - Field: ‘envir’
[17:00:28.043]   - Field: ‘packages’
[17:00:28.043]   - Field: ‘gc’
[17:00:28.043]   - Field: ‘conditions’
[17:00:28.043]   - Field: ‘expr’
[17:00:28.043]   - Field: ‘uuid’
[17:00:28.043]   - Field: ‘seed’
[17:00:28.043]   - Field: ‘version’
[17:00:28.043]   - Field: ‘result’
[17:00:28.043]   - Field: ‘asynchronous’
[17:00:28.044]   - Field: ‘calls’
[17:00:28.044]   - Field: ‘globals’
[17:00:28.044]   - Field: ‘stdout’
[17:00:28.044]   - Field: ‘earlySignal’
[17:00:28.044]   - Field: ‘lazy’
[17:00:28.044]   - Field: ‘state’
[17:00:28.044] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.044] - Launch lazy future ...
[17:00:28.044] Packages needed by the future expression (n = 0): <none>
[17:00:28.045] Packages needed by future strategies (n = 0): <none>
[17:00:28.045] {
[17:00:28.045]     {
[17:00:28.045]         {
[17:00:28.045]             ...future.startTime <- base::Sys.time()
[17:00:28.045]             {
[17:00:28.045]                 {
[17:00:28.045]                   {
[17:00:28.045]                     base::local({
[17:00:28.045]                       has_future <- base::requireNamespace("future", 
[17:00:28.045]                         quietly = TRUE)
[17:00:28.045]                       if (has_future) {
[17:00:28.045]                         ns <- base::getNamespace("future")
[17:00:28.045]                         version <- ns[[".package"]][["version"]]
[17:00:28.045]                         if (is.null(version)) 
[17:00:28.045]                           version <- utils::packageVersion("future")
[17:00:28.045]                       }
[17:00:28.045]                       else {
[17:00:28.045]                         version <- NULL
[17:00:28.045]                       }
[17:00:28.045]                       if (!has_future || version < "1.8.0") {
[17:00:28.045]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.045]                           "", base::R.version$version.string), 
[17:00:28.045]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.045]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.045]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.045]                             "release", "version")], collapse = " "), 
[17:00:28.045]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.045]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.045]                           info)
[17:00:28.045]                         info <- base::paste(info, collapse = "; ")
[17:00:28.045]                         if (!has_future) {
[17:00:28.045]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.045]                             info)
[17:00:28.045]                         }
[17:00:28.045]                         else {
[17:00:28.045]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.045]                             info, version)
[17:00:28.045]                         }
[17:00:28.045]                         base::stop(msg)
[17:00:28.045]                       }
[17:00:28.045]                     })
[17:00:28.045]                   }
[17:00:28.045]                   ...future.strategy.old <- future::plan("list")
[17:00:28.045]                   options(future.plan = NULL)
[17:00:28.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.045]                 }
[17:00:28.045]                 ...future.workdir <- getwd()
[17:00:28.045]             }
[17:00:28.045]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.045]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.045]         }
[17:00:28.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.045]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.045]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.045]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.045]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.045]             base::names(...future.oldOptions))
[17:00:28.045]     }
[17:00:28.045]     if (FALSE) {
[17:00:28.045]     }
[17:00:28.045]     else {
[17:00:28.045]         if (TRUE) {
[17:00:28.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.045]                 open = "w")
[17:00:28.045]         }
[17:00:28.045]         else {
[17:00:28.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.045]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.045]         }
[17:00:28.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.045]             base::sink(type = "output", split = FALSE)
[17:00:28.045]             base::close(...future.stdout)
[17:00:28.045]         }, add = TRUE)
[17:00:28.045]     }
[17:00:28.045]     ...future.frame <- base::sys.nframe()
[17:00:28.045]     ...future.conditions <- base::list()
[17:00:28.045]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.045]     if (FALSE) {
[17:00:28.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.045]     }
[17:00:28.045]     ...future.result <- base::tryCatch({
[17:00:28.045]         base::withCallingHandlers({
[17:00:28.045]             ...future.value <- base::withVisible(base::local({
[17:00:28.045]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.045]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.045]                   ...future.globals.maxSize)) {
[17:00:28.045]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.045]                   on.exit(options(oopts), add = TRUE)
[17:00:28.045]                 }
[17:00:28.045]                 {
[17:00:28.045]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.045]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.045]                     USE.NAMES = FALSE)
[17:00:28.045]                   do.call(mapply, args = args)
[17:00:28.045]                 }
[17:00:28.045]             }))
[17:00:28.045]             future::FutureResult(value = ...future.value$value, 
[17:00:28.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.045]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.045]                     ...future.globalenv.names))
[17:00:28.045]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.045]         }, condition = base::local({
[17:00:28.045]             c <- base::c
[17:00:28.045]             inherits <- base::inherits
[17:00:28.045]             invokeRestart <- base::invokeRestart
[17:00:28.045]             length <- base::length
[17:00:28.045]             list <- base::list
[17:00:28.045]             seq.int <- base::seq.int
[17:00:28.045]             signalCondition <- base::signalCondition
[17:00:28.045]             sys.calls <- base::sys.calls
[17:00:28.045]             `[[` <- base::`[[`
[17:00:28.045]             `+` <- base::`+`
[17:00:28.045]             `<<-` <- base::`<<-`
[17:00:28.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.045]                   3L)]
[17:00:28.045]             }
[17:00:28.045]             function(cond) {
[17:00:28.045]                 is_error <- inherits(cond, "error")
[17:00:28.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.045]                   NULL)
[17:00:28.045]                 if (is_error) {
[17:00:28.045]                   sessionInformation <- function() {
[17:00:28.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.045]                       search = base::search(), system = base::Sys.info())
[17:00:28.045]                   }
[17:00:28.045]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.045]                     cond$call), session = sessionInformation(), 
[17:00:28.045]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.045]                   signalCondition(cond)
[17:00:28.045]                 }
[17:00:28.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.045]                 "immediateCondition"))) {
[17:00:28.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.045]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.045]                   if (TRUE && !signal) {
[17:00:28.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.045]                     {
[17:00:28.045]                       inherits <- base::inherits
[17:00:28.045]                       invokeRestart <- base::invokeRestart
[17:00:28.045]                       is.null <- base::is.null
[17:00:28.045]                       muffled <- FALSE
[17:00:28.045]                       if (inherits(cond, "message")) {
[17:00:28.045]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.045]                         if (muffled) 
[17:00:28.045]                           invokeRestart("muffleMessage")
[17:00:28.045]                       }
[17:00:28.045]                       else if (inherits(cond, "warning")) {
[17:00:28.045]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.045]                         if (muffled) 
[17:00:28.045]                           invokeRestart("muffleWarning")
[17:00:28.045]                       }
[17:00:28.045]                       else if (inherits(cond, "condition")) {
[17:00:28.045]                         if (!is.null(pattern)) {
[17:00:28.045]                           computeRestarts <- base::computeRestarts
[17:00:28.045]                           grepl <- base::grepl
[17:00:28.045]                           restarts <- computeRestarts(cond)
[17:00:28.045]                           for (restart in restarts) {
[17:00:28.045]                             name <- restart$name
[17:00:28.045]                             if (is.null(name)) 
[17:00:28.045]                               next
[17:00:28.045]                             if (!grepl(pattern, name)) 
[17:00:28.045]                               next
[17:00:28.045]                             invokeRestart(restart)
[17:00:28.045]                             muffled <- TRUE
[17:00:28.045]                             break
[17:00:28.045]                           }
[17:00:28.045]                         }
[17:00:28.045]                       }
[17:00:28.045]                       invisible(muffled)
[17:00:28.045]                     }
[17:00:28.045]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.045]                   }
[17:00:28.045]                 }
[17:00:28.045]                 else {
[17:00:28.045]                   if (TRUE) {
[17:00:28.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.045]                     {
[17:00:28.045]                       inherits <- base::inherits
[17:00:28.045]                       invokeRestart <- base::invokeRestart
[17:00:28.045]                       is.null <- base::is.null
[17:00:28.045]                       muffled <- FALSE
[17:00:28.045]                       if (inherits(cond, "message")) {
[17:00:28.045]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.045]                         if (muffled) 
[17:00:28.045]                           invokeRestart("muffleMessage")
[17:00:28.045]                       }
[17:00:28.045]                       else if (inherits(cond, "warning")) {
[17:00:28.045]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.045]                         if (muffled) 
[17:00:28.045]                           invokeRestart("muffleWarning")
[17:00:28.045]                       }
[17:00:28.045]                       else if (inherits(cond, "condition")) {
[17:00:28.045]                         if (!is.null(pattern)) {
[17:00:28.045]                           computeRestarts <- base::computeRestarts
[17:00:28.045]                           grepl <- base::grepl
[17:00:28.045]                           restarts <- computeRestarts(cond)
[17:00:28.045]                           for (restart in restarts) {
[17:00:28.045]                             name <- restart$name
[17:00:28.045]                             if (is.null(name)) 
[17:00:28.045]                               next
[17:00:28.045]                             if (!grepl(pattern, name)) 
[17:00:28.045]                               next
[17:00:28.045]                             invokeRestart(restart)
[17:00:28.045]                             muffled <- TRUE
[17:00:28.045]                             break
[17:00:28.045]                           }
[17:00:28.045]                         }
[17:00:28.045]                       }
[17:00:28.045]                       invisible(muffled)
[17:00:28.045]                     }
[17:00:28.045]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.045]                   }
[17:00:28.045]                 }
[17:00:28.045]             }
[17:00:28.045]         }))
[17:00:28.045]     }, error = function(ex) {
[17:00:28.045]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.045]                 ...future.rng), started = ...future.startTime, 
[17:00:28.045]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.045]             version = "1.8"), class = "FutureResult")
[17:00:28.045]     }, finally = {
[17:00:28.045]         if (!identical(...future.workdir, getwd())) 
[17:00:28.045]             setwd(...future.workdir)
[17:00:28.045]         {
[17:00:28.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.045]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.045]             }
[17:00:28.045]             base::options(...future.oldOptions)
[17:00:28.045]             if (.Platform$OS.type == "windows") {
[17:00:28.045]                 old_names <- names(...future.oldEnvVars)
[17:00:28.045]                 envs <- base::Sys.getenv()
[17:00:28.045]                 names <- names(envs)
[17:00:28.045]                 common <- intersect(names, old_names)
[17:00:28.045]                 added <- setdiff(names, old_names)
[17:00:28.045]                 removed <- setdiff(old_names, names)
[17:00:28.045]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.045]                   envs[common]]
[17:00:28.045]                 NAMES <- toupper(changed)
[17:00:28.045]                 args <- list()
[17:00:28.045]                 for (kk in seq_along(NAMES)) {
[17:00:28.045]                   name <- changed[[kk]]
[17:00:28.045]                   NAME <- NAMES[[kk]]
[17:00:28.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.045]                     next
[17:00:28.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.045]                 }
[17:00:28.045]                 NAMES <- toupper(added)
[17:00:28.045]                 for (kk in seq_along(NAMES)) {
[17:00:28.045]                   name <- added[[kk]]
[17:00:28.045]                   NAME <- NAMES[[kk]]
[17:00:28.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.045]                     next
[17:00:28.045]                   args[[name]] <- ""
[17:00:28.045]                 }
[17:00:28.045]                 NAMES <- toupper(removed)
[17:00:28.045]                 for (kk in seq_along(NAMES)) {
[17:00:28.045]                   name <- removed[[kk]]
[17:00:28.045]                   NAME <- NAMES[[kk]]
[17:00:28.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.045]                     next
[17:00:28.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.045]                 }
[17:00:28.045]                 if (length(args) > 0) 
[17:00:28.045]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.045]             }
[17:00:28.045]             else {
[17:00:28.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.045]             }
[17:00:28.045]             {
[17:00:28.045]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.045]                   0L) {
[17:00:28.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.045]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.045]                   base::options(opts)
[17:00:28.045]                 }
[17:00:28.045]                 {
[17:00:28.045]                   {
[17:00:28.045]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.045]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.045]                     2054632538L), envir = base::globalenv(), 
[17:00:28.045]                       inherits = FALSE)
[17:00:28.045]                     NULL
[17:00:28.045]                   }
[17:00:28.045]                   options(future.plan = NULL)
[17:00:28.045]                   if (is.na(NA_character_)) 
[17:00:28.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.045]                     .init = FALSE)
[17:00:28.045]                 }
[17:00:28.045]             }
[17:00:28.045]         }
[17:00:28.045]     })
[17:00:28.045]     if (TRUE) {
[17:00:28.045]         base::sink(type = "output", split = FALSE)
[17:00:28.045]         if (TRUE) {
[17:00:28.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.045]         }
[17:00:28.045]         else {
[17:00:28.045]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.045]         }
[17:00:28.045]         base::close(...future.stdout)
[17:00:28.045]         ...future.stdout <- NULL
[17:00:28.045]     }
[17:00:28.045]     ...future.result$conditions <- ...future.conditions
[17:00:28.045]     ...future.result$finished <- base::Sys.time()
[17:00:28.045]     ...future.result
[17:00:28.045] }
[17:00:28.047] assign_globals() ...
[17:00:28.047] List of 5
[17:00:28.047]  $ ...future.FUN            :function (x, ...)  
[17:00:28.047]  $ MoreArgs                 : NULL
[17:00:28.047]  $ ...future.elements_ii    :List of 2
[17:00:28.047]   ..$ :List of 4
[17:00:28.047]   .. ..$ : int 1
[17:00:28.047]   .. ..$ : int 2
[17:00:28.047]   .. ..$ : int 3
[17:00:28.047]   .. ..$ : int 4
[17:00:28.047]   ..$ :List of 4
[17:00:28.047]   .. ..$ : int 4
[17:00:28.047]   .. ..$ : int 3
[17:00:28.047]   .. ..$ : int 2
[17:00:28.047]   .. ..$ : int 1
[17:00:28.047]  $ ...future.seeds_ii       : NULL
[17:00:28.047]  $ ...future.globals.maxSize: NULL
[17:00:28.047]  - attr(*, "where")=List of 5
[17:00:28.047]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.047]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.047]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.047]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.047]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.047]  - attr(*, "resolved")= logi FALSE
[17:00:28.047]  - attr(*, "total_size")= num 504
[17:00:28.047]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.047]  - attr(*, "already-done")= logi TRUE
[17:00:28.053] - copied ‘...future.FUN’ to environment
[17:00:28.053] - copied ‘MoreArgs’ to environment
[17:00:28.054] - copied ‘...future.elements_ii’ to environment
[17:00:28.054] - copied ‘...future.seeds_ii’ to environment
[17:00:28.054] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.054] assign_globals() ... done
[17:00:28.054] plan(): Setting new future strategy stack:
[17:00:28.054] List of future strategies:
[17:00:28.054] 1. sequential:
[17:00:28.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.054]    - tweaked: FALSE
[17:00:28.054]    - call: NULL
[17:00:28.055] plan(): nbrOfWorkers() = 1
[17:00:28.055] plan(): Setting new future strategy stack:
[17:00:28.055] List of future strategies:
[17:00:28.055] 1. sequential:
[17:00:28.055]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.055]    - tweaked: FALSE
[17:00:28.055]    - call: plan(strategy)
[17:00:28.056] plan(): nbrOfWorkers() = 1
[17:00:28.056] SequentialFuture started (and completed)
[17:00:28.056] - Launch lazy future ... done
[17:00:28.056] run() for ‘SequentialFuture’ ... done
[17:00:28.056] Created future:
[17:00:28.057] SequentialFuture:
[17:00:28.057] Label: ‘future_mapply-1’
[17:00:28.057] Expression:
[17:00:28.057] {
[17:00:28.057]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.057]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.057]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.057]         on.exit(options(oopts), add = TRUE)
[17:00:28.057]     }
[17:00:28.057]     {
[17:00:28.057]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.057]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.057]         do.call(mapply, args = args)
[17:00:28.057]     }
[17:00:28.057] }
[17:00:28.057] Lazy evaluation: FALSE
[17:00:28.057] Asynchronous evaluation: FALSE
[17:00:28.057] Local evaluation: TRUE
[17:00:28.057] Environment: R_GlobalEnv
[17:00:28.057] Capture standard output: TRUE
[17:00:28.057] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.057] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.057] Packages: <none>
[17:00:28.057] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.057] Resolved: TRUE
[17:00:28.057] Value: 240 bytes of class ‘list’
[17:00:28.057] Early signaling: FALSE
[17:00:28.057] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.057] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.057] Chunk #1 of 1 ... DONE
[17:00:28.057] Launching 1 futures (chunks) ... DONE
[17:00:28.058] Resolving 1 futures (chunks) ...
[17:00:28.058] resolve() on list ...
[17:00:28.058]  recursive: 0
[17:00:28.058]  length: 1
[17:00:28.058] 
[17:00:28.058] resolved() for ‘SequentialFuture’ ...
[17:00:28.058] - state: ‘finished’
[17:00:28.058] - run: TRUE
[17:00:28.058] - result: ‘FutureResult’
[17:00:28.058] resolved() for ‘SequentialFuture’ ... done
[17:00:28.059] Future #1
[17:00:28.059] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.059] - nx: 1
[17:00:28.059] - relay: TRUE
[17:00:28.059] - stdout: TRUE
[17:00:28.059] - signal: TRUE
[17:00:28.059] - resignal: FALSE
[17:00:28.059] - force: TRUE
[17:00:28.059] - relayed: [n=1] FALSE
[17:00:28.059] - queued futures: [n=1] FALSE
[17:00:28.059]  - until=1
[17:00:28.060]  - relaying element #1
[17:00:28.060] - relayed: [n=1] TRUE
[17:00:28.060] - queued futures: [n=1] TRUE
[17:00:28.060] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.060]  length: 0 (resolved future 1)
[17:00:28.060] Relaying remaining futures
[17:00:28.060] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.060] - nx: 1
[17:00:28.060] - relay: TRUE
[17:00:28.060] - stdout: TRUE
[17:00:28.061] - signal: TRUE
[17:00:28.061] - resignal: FALSE
[17:00:28.061] - force: TRUE
[17:00:28.061] - relayed: [n=1] TRUE
[17:00:28.061] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.061] - relayed: [n=1] TRUE
[17:00:28.061] - queued futures: [n=1] TRUE
[17:00:28.061] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.061] resolve() on list ... DONE
[17:00:28.061]  - Number of value chunks collected: 1
[17:00:28.062] Resolving 1 futures (chunks) ... DONE
[17:00:28.062] Reducing values from 1 chunks ...
[17:00:28.062]  - Number of values collected after concatenation: 4
[17:00:28.062]  - Number of values expected: 4
[17:00:28.062] Reducing values from 1 chunks ... DONE
[17:00:28.062] future_mapply() ... DONE
[17:00:28.062] future_mapply() ...
[17:00:28.062] Number of chunks: 1
[17:00:28.062] getGlobalsAndPackagesXApply() ...
[17:00:28.062]  - future.globals: TRUE
[17:00:28.063] getGlobalsAndPackages() ...
[17:00:28.063] Searching for globals...
[17:00:28.063] - globals found: [1] ‘FUN’
[17:00:28.063] Searching for globals ... DONE
[17:00:28.063] Resolving globals: FALSE
[17:00:28.064] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:28.064] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:28.064] - globals: [1] ‘FUN’
[17:00:28.064] 
[17:00:28.064] getGlobalsAndPackages() ... DONE
[17:00:28.064]  - globals found/used: [n=1] ‘FUN’
[17:00:28.065]  - needed namespaces: [n=0] 
[17:00:28.065] Finding globals ... DONE
[17:00:28.065] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.065] List of 2
[17:00:28.065]  $ ...future.FUN:function (x, ...)  
[17:00:28.065]  $ MoreArgs     : NULL
[17:00:28.065]  - attr(*, "where")=List of 2
[17:00:28.065]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.065]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.065]  - attr(*, "resolved")= logi FALSE
[17:00:28.065]  - attr(*, "total_size")= num NA
[17:00:28.069] Packages to be attached in all futures: [n=0] 
[17:00:28.069] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.069] Number of futures (= number of chunks): 1
[17:00:28.069] Launching 1 futures (chunks) ...
[17:00:28.069] Chunk #1 of 1 ...
[17:00:28.070]  - Finding globals in '...' for chunk #1 ...
[17:00:28.070] getGlobalsAndPackages() ...
[17:00:28.070] Searching for globals...
[17:00:28.070] 
[17:00:28.070] Searching for globals ... DONE
[17:00:28.070] - globals: [0] <none>
[17:00:28.070] getGlobalsAndPackages() ... DONE
[17:00:28.070]    + additional globals found: [n=0] 
[17:00:28.071]    + additional namespaces needed: [n=0] 
[17:00:28.071]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.071]  - seeds: <none>
[17:00:28.071]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.071] getGlobalsAndPackages() ...
[17:00:28.071] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.071] Resolving globals: FALSE
[17:00:28.072] The total size of the 5 globals is 504 bytes (504 bytes)
[17:00:28.072] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.072] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.072] 
[17:00:28.072] getGlobalsAndPackages() ... DONE
[17:00:28.073] run() for ‘Future’ ...
[17:00:28.073] - state: ‘created’
[17:00:28.073] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.073] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.073] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.073]   - Field: ‘label’
[17:00:28.074]   - Field: ‘local’
[17:00:28.074]   - Field: ‘owner’
[17:00:28.074]   - Field: ‘envir’
[17:00:28.074]   - Field: ‘packages’
[17:00:28.074]   - Field: ‘gc’
[17:00:28.074]   - Field: ‘conditions’
[17:00:28.074]   - Field: ‘expr’
[17:00:28.074]   - Field: ‘uuid’
[17:00:28.074]   - Field: ‘seed’
[17:00:28.074]   - Field: ‘version’
[17:00:28.074]   - Field: ‘result’
[17:00:28.075]   - Field: ‘asynchronous’
[17:00:28.075]   - Field: ‘calls’
[17:00:28.075]   - Field: ‘globals’
[17:00:28.075]   - Field: ‘stdout’
[17:00:28.075]   - Field: ‘earlySignal’
[17:00:28.075]   - Field: ‘lazy’
[17:00:28.075]   - Field: ‘state’
[17:00:28.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.075] - Launch lazy future ...
[17:00:28.075] Packages needed by the future expression (n = 0): <none>
[17:00:28.076] Packages needed by future strategies (n = 0): <none>
[17:00:28.076] {
[17:00:28.076]     {
[17:00:28.076]         {
[17:00:28.076]             ...future.startTime <- base::Sys.time()
[17:00:28.076]             {
[17:00:28.076]                 {
[17:00:28.076]                   {
[17:00:28.076]                     base::local({
[17:00:28.076]                       has_future <- base::requireNamespace("future", 
[17:00:28.076]                         quietly = TRUE)
[17:00:28.076]                       if (has_future) {
[17:00:28.076]                         ns <- base::getNamespace("future")
[17:00:28.076]                         version <- ns[[".package"]][["version"]]
[17:00:28.076]                         if (is.null(version)) 
[17:00:28.076]                           version <- utils::packageVersion("future")
[17:00:28.076]                       }
[17:00:28.076]                       else {
[17:00:28.076]                         version <- NULL
[17:00:28.076]                       }
[17:00:28.076]                       if (!has_future || version < "1.8.0") {
[17:00:28.076]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.076]                           "", base::R.version$version.string), 
[17:00:28.076]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.076]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.076]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.076]                             "release", "version")], collapse = " "), 
[17:00:28.076]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.076]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.076]                           info)
[17:00:28.076]                         info <- base::paste(info, collapse = "; ")
[17:00:28.076]                         if (!has_future) {
[17:00:28.076]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.076]                             info)
[17:00:28.076]                         }
[17:00:28.076]                         else {
[17:00:28.076]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.076]                             info, version)
[17:00:28.076]                         }
[17:00:28.076]                         base::stop(msg)
[17:00:28.076]                       }
[17:00:28.076]                     })
[17:00:28.076]                   }
[17:00:28.076]                   ...future.strategy.old <- future::plan("list")
[17:00:28.076]                   options(future.plan = NULL)
[17:00:28.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.076]                 }
[17:00:28.076]                 ...future.workdir <- getwd()
[17:00:28.076]             }
[17:00:28.076]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.076]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.076]         }
[17:00:28.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.076]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.076]             base::names(...future.oldOptions))
[17:00:28.076]     }
[17:00:28.076]     if (FALSE) {
[17:00:28.076]     }
[17:00:28.076]     else {
[17:00:28.076]         if (TRUE) {
[17:00:28.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.076]                 open = "w")
[17:00:28.076]         }
[17:00:28.076]         else {
[17:00:28.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.076]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.076]         }
[17:00:28.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.076]             base::sink(type = "output", split = FALSE)
[17:00:28.076]             base::close(...future.stdout)
[17:00:28.076]         }, add = TRUE)
[17:00:28.076]     }
[17:00:28.076]     ...future.frame <- base::sys.nframe()
[17:00:28.076]     ...future.conditions <- base::list()
[17:00:28.076]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.076]     if (FALSE) {
[17:00:28.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.076]     }
[17:00:28.076]     ...future.result <- base::tryCatch({
[17:00:28.076]         base::withCallingHandlers({
[17:00:28.076]             ...future.value <- base::withVisible(base::local({
[17:00:28.076]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.076]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.076]                   ...future.globals.maxSize)) {
[17:00:28.076]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.076]                   on.exit(options(oopts), add = TRUE)
[17:00:28.076]                 }
[17:00:28.076]                 {
[17:00:28.076]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.076]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.076]                     USE.NAMES = FALSE)
[17:00:28.076]                   do.call(mapply, args = args)
[17:00:28.076]                 }
[17:00:28.076]             }))
[17:00:28.076]             future::FutureResult(value = ...future.value$value, 
[17:00:28.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.076]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.076]                     ...future.globalenv.names))
[17:00:28.076]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.076]         }, condition = base::local({
[17:00:28.076]             c <- base::c
[17:00:28.076]             inherits <- base::inherits
[17:00:28.076]             invokeRestart <- base::invokeRestart
[17:00:28.076]             length <- base::length
[17:00:28.076]             list <- base::list
[17:00:28.076]             seq.int <- base::seq.int
[17:00:28.076]             signalCondition <- base::signalCondition
[17:00:28.076]             sys.calls <- base::sys.calls
[17:00:28.076]             `[[` <- base::`[[`
[17:00:28.076]             `+` <- base::`+`
[17:00:28.076]             `<<-` <- base::`<<-`
[17:00:28.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.076]                   3L)]
[17:00:28.076]             }
[17:00:28.076]             function(cond) {
[17:00:28.076]                 is_error <- inherits(cond, "error")
[17:00:28.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.076]                   NULL)
[17:00:28.076]                 if (is_error) {
[17:00:28.076]                   sessionInformation <- function() {
[17:00:28.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.076]                       search = base::search(), system = base::Sys.info())
[17:00:28.076]                   }
[17:00:28.076]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.076]                     cond$call), session = sessionInformation(), 
[17:00:28.076]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.076]                   signalCondition(cond)
[17:00:28.076]                 }
[17:00:28.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.076]                 "immediateCondition"))) {
[17:00:28.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.076]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.076]                   if (TRUE && !signal) {
[17:00:28.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.076]                     {
[17:00:28.076]                       inherits <- base::inherits
[17:00:28.076]                       invokeRestart <- base::invokeRestart
[17:00:28.076]                       is.null <- base::is.null
[17:00:28.076]                       muffled <- FALSE
[17:00:28.076]                       if (inherits(cond, "message")) {
[17:00:28.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.076]                         if (muffled) 
[17:00:28.076]                           invokeRestart("muffleMessage")
[17:00:28.076]                       }
[17:00:28.076]                       else if (inherits(cond, "warning")) {
[17:00:28.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.076]                         if (muffled) 
[17:00:28.076]                           invokeRestart("muffleWarning")
[17:00:28.076]                       }
[17:00:28.076]                       else if (inherits(cond, "condition")) {
[17:00:28.076]                         if (!is.null(pattern)) {
[17:00:28.076]                           computeRestarts <- base::computeRestarts
[17:00:28.076]                           grepl <- base::grepl
[17:00:28.076]                           restarts <- computeRestarts(cond)
[17:00:28.076]                           for (restart in restarts) {
[17:00:28.076]                             name <- restart$name
[17:00:28.076]                             if (is.null(name)) 
[17:00:28.076]                               next
[17:00:28.076]                             if (!grepl(pattern, name)) 
[17:00:28.076]                               next
[17:00:28.076]                             invokeRestart(restart)
[17:00:28.076]                             muffled <- TRUE
[17:00:28.076]                             break
[17:00:28.076]                           }
[17:00:28.076]                         }
[17:00:28.076]                       }
[17:00:28.076]                       invisible(muffled)
[17:00:28.076]                     }
[17:00:28.076]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.076]                   }
[17:00:28.076]                 }
[17:00:28.076]                 else {
[17:00:28.076]                   if (TRUE) {
[17:00:28.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.076]                     {
[17:00:28.076]                       inherits <- base::inherits
[17:00:28.076]                       invokeRestart <- base::invokeRestart
[17:00:28.076]                       is.null <- base::is.null
[17:00:28.076]                       muffled <- FALSE
[17:00:28.076]                       if (inherits(cond, "message")) {
[17:00:28.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.076]                         if (muffled) 
[17:00:28.076]                           invokeRestart("muffleMessage")
[17:00:28.076]                       }
[17:00:28.076]                       else if (inherits(cond, "warning")) {
[17:00:28.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.076]                         if (muffled) 
[17:00:28.076]                           invokeRestart("muffleWarning")
[17:00:28.076]                       }
[17:00:28.076]                       else if (inherits(cond, "condition")) {
[17:00:28.076]                         if (!is.null(pattern)) {
[17:00:28.076]                           computeRestarts <- base::computeRestarts
[17:00:28.076]                           grepl <- base::grepl
[17:00:28.076]                           restarts <- computeRestarts(cond)
[17:00:28.076]                           for (restart in restarts) {
[17:00:28.076]                             name <- restart$name
[17:00:28.076]                             if (is.null(name)) 
[17:00:28.076]                               next
[17:00:28.076]                             if (!grepl(pattern, name)) 
[17:00:28.076]                               next
[17:00:28.076]                             invokeRestart(restart)
[17:00:28.076]                             muffled <- TRUE
[17:00:28.076]                             break
[17:00:28.076]                           }
[17:00:28.076]                         }
[17:00:28.076]                       }
[17:00:28.076]                       invisible(muffled)
[17:00:28.076]                     }
[17:00:28.076]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.076]                   }
[17:00:28.076]                 }
[17:00:28.076]             }
[17:00:28.076]         }))
[17:00:28.076]     }, error = function(ex) {
[17:00:28.076]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.076]                 ...future.rng), started = ...future.startTime, 
[17:00:28.076]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.076]             version = "1.8"), class = "FutureResult")
[17:00:28.076]     }, finally = {
[17:00:28.076]         if (!identical(...future.workdir, getwd())) 
[17:00:28.076]             setwd(...future.workdir)
[17:00:28.076]         {
[17:00:28.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.076]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.076]             }
[17:00:28.076]             base::options(...future.oldOptions)
[17:00:28.076]             if (.Platform$OS.type == "windows") {
[17:00:28.076]                 old_names <- names(...future.oldEnvVars)
[17:00:28.076]                 envs <- base::Sys.getenv()
[17:00:28.076]                 names <- names(envs)
[17:00:28.076]                 common <- intersect(names, old_names)
[17:00:28.076]                 added <- setdiff(names, old_names)
[17:00:28.076]                 removed <- setdiff(old_names, names)
[17:00:28.076]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.076]                   envs[common]]
[17:00:28.076]                 NAMES <- toupper(changed)
[17:00:28.076]                 args <- list()
[17:00:28.076]                 for (kk in seq_along(NAMES)) {
[17:00:28.076]                   name <- changed[[kk]]
[17:00:28.076]                   NAME <- NAMES[[kk]]
[17:00:28.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.076]                     next
[17:00:28.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.076]                 }
[17:00:28.076]                 NAMES <- toupper(added)
[17:00:28.076]                 for (kk in seq_along(NAMES)) {
[17:00:28.076]                   name <- added[[kk]]
[17:00:28.076]                   NAME <- NAMES[[kk]]
[17:00:28.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.076]                     next
[17:00:28.076]                   args[[name]] <- ""
[17:00:28.076]                 }
[17:00:28.076]                 NAMES <- toupper(removed)
[17:00:28.076]                 for (kk in seq_along(NAMES)) {
[17:00:28.076]                   name <- removed[[kk]]
[17:00:28.076]                   NAME <- NAMES[[kk]]
[17:00:28.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.076]                     next
[17:00:28.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.076]                 }
[17:00:28.076]                 if (length(args) > 0) 
[17:00:28.076]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.076]             }
[17:00:28.076]             else {
[17:00:28.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.076]             }
[17:00:28.076]             {
[17:00:28.076]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.076]                   0L) {
[17:00:28.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.076]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.076]                   base::options(opts)
[17:00:28.076]                 }
[17:00:28.076]                 {
[17:00:28.076]                   {
[17:00:28.076]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.076]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.076]                     2054632538L), envir = base::globalenv(), 
[17:00:28.076]                       inherits = FALSE)
[17:00:28.076]                     NULL
[17:00:28.076]                   }
[17:00:28.076]                   options(future.plan = NULL)
[17:00:28.076]                   if (is.na(NA_character_)) 
[17:00:28.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.076]                     .init = FALSE)
[17:00:28.076]                 }
[17:00:28.076]             }
[17:00:28.076]         }
[17:00:28.076]     })
[17:00:28.076]     if (TRUE) {
[17:00:28.076]         base::sink(type = "output", split = FALSE)
[17:00:28.076]         if (TRUE) {
[17:00:28.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.076]         }
[17:00:28.076]         else {
[17:00:28.076]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.076]         }
[17:00:28.076]         base::close(...future.stdout)
[17:00:28.076]         ...future.stdout <- NULL
[17:00:28.076]     }
[17:00:28.076]     ...future.result$conditions <- ...future.conditions
[17:00:28.076]     ...future.result$finished <- base::Sys.time()
[17:00:28.076]     ...future.result
[17:00:28.076] }
[17:00:28.078] assign_globals() ...
[17:00:28.078] List of 5
[17:00:28.078]  $ ...future.FUN            :function (x, ...)  
[17:00:28.078]  $ MoreArgs                 : NULL
[17:00:28.078]  $ ...future.elements_ii    :List of 2
[17:00:28.078]   ..$ times:List of 4
[17:00:28.078]   .. ..$ : int 1
[17:00:28.078]   .. ..$ : int 2
[17:00:28.078]   .. ..$ : int 3
[17:00:28.078]   .. ..$ : int 4
[17:00:28.078]   ..$ x    :List of 4
[17:00:28.078]   .. ..$ : int 4
[17:00:28.078]   .. ..$ : int 3
[17:00:28.078]   .. ..$ : int 2
[17:00:28.078]   .. ..$ : int 1
[17:00:28.078]  $ ...future.seeds_ii       : NULL
[17:00:28.078]  $ ...future.globals.maxSize: NULL
[17:00:28.078]  - attr(*, "where")=List of 5
[17:00:28.078]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.078]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.078]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.078]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.078]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.078]  - attr(*, "resolved")= logi FALSE
[17:00:28.078]  - attr(*, "total_size")= num 504
[17:00:28.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.078]  - attr(*, "already-done")= logi TRUE
[17:00:28.084] - copied ‘...future.FUN’ to environment
[17:00:28.085] - copied ‘MoreArgs’ to environment
[17:00:28.085] - copied ‘...future.elements_ii’ to environment
[17:00:28.085] - copied ‘...future.seeds_ii’ to environment
[17:00:28.085] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.085] assign_globals() ... done
[17:00:28.085] plan(): Setting new future strategy stack:
[17:00:28.085] List of future strategies:
[17:00:28.085] 1. sequential:
[17:00:28.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.085]    - tweaked: FALSE
[17:00:28.085]    - call: NULL
[17:00:28.086] plan(): nbrOfWorkers() = 1
[17:00:28.087] plan(): Setting new future strategy stack:
[17:00:28.087] List of future strategies:
[17:00:28.087] 1. sequential:
[17:00:28.087]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.087]    - tweaked: FALSE
[17:00:28.087]    - call: plan(strategy)
[17:00:28.087] plan(): nbrOfWorkers() = 1
[17:00:28.087] SequentialFuture started (and completed)
[17:00:28.088] - Launch lazy future ... done
[17:00:28.088] run() for ‘SequentialFuture’ ... done
[17:00:28.088] Created future:
[17:00:28.088] SequentialFuture:
[17:00:28.088] Label: ‘future_mapply-1’
[17:00:28.088] Expression:
[17:00:28.088] {
[17:00:28.088]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.088]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.088]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.088]         on.exit(options(oopts), add = TRUE)
[17:00:28.088]     }
[17:00:28.088]     {
[17:00:28.088]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.088]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.088]         do.call(mapply, args = args)
[17:00:28.088]     }
[17:00:28.088] }
[17:00:28.088] Lazy evaluation: FALSE
[17:00:28.088] Asynchronous evaluation: FALSE
[17:00:28.088] Local evaluation: TRUE
[17:00:28.088] Environment: R_GlobalEnv
[17:00:28.088] Capture standard output: TRUE
[17:00:28.088] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.088] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.088] Packages: <none>
[17:00:28.088] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.088] Resolved: TRUE
[17:00:28.088] Value: 240 bytes of class ‘list’
[17:00:28.088] Early signaling: FALSE
[17:00:28.088] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.088] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.089] Chunk #1 of 1 ... DONE
[17:00:28.089] Launching 1 futures (chunks) ... DONE
[17:00:28.089] Resolving 1 futures (chunks) ...
[17:00:28.089] resolve() on list ...
[17:00:28.089]  recursive: 0
[17:00:28.089]  length: 1
[17:00:28.089] 
[17:00:28.090] resolved() for ‘SequentialFuture’ ...
[17:00:28.090] - state: ‘finished’
[17:00:28.090] - run: TRUE
[17:00:28.090] - result: ‘FutureResult’
[17:00:28.090] resolved() for ‘SequentialFuture’ ... done
[17:00:28.090] Future #1
[17:00:28.090] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.090] - nx: 1
[17:00:28.090] - relay: TRUE
[17:00:28.090] - stdout: TRUE
[17:00:28.091] - signal: TRUE
[17:00:28.091] - resignal: FALSE
[17:00:28.091] - force: TRUE
[17:00:28.091] - relayed: [n=1] FALSE
[17:00:28.091] - queued futures: [n=1] FALSE
[17:00:28.091]  - until=1
[17:00:28.091]  - relaying element #1
[17:00:28.091] - relayed: [n=1] TRUE
[17:00:28.091] - queued futures: [n=1] TRUE
[17:00:28.091] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.092]  length: 0 (resolved future 1)
[17:00:28.092] Relaying remaining futures
[17:00:28.092] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.092] - nx: 1
[17:00:28.092] - relay: TRUE
[17:00:28.092] - stdout: TRUE
[17:00:28.092] - signal: TRUE
[17:00:28.092] - resignal: FALSE
[17:00:28.092] - force: TRUE
[17:00:28.092] - relayed: [n=1] TRUE
[17:00:28.092] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.093] - relayed: [n=1] TRUE
[17:00:28.093] - queued futures: [n=1] TRUE
[17:00:28.093] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.093] resolve() on list ... DONE
[17:00:28.095]  - Number of value chunks collected: 1
[17:00:28.095] Resolving 1 futures (chunks) ... DONE
[17:00:28.095] Reducing values from 1 chunks ...
[17:00:28.095]  - Number of values collected after concatenation: 4
[17:00:28.095]  - Number of values expected: 4
[17:00:28.095] Reducing values from 1 chunks ... DONE
[17:00:28.095] future_mapply() ... DONE
[17:00:28.096] future_mapply() ...
[17:00:28.096] Number of chunks: 1
[17:00:28.096] getGlobalsAndPackagesXApply() ...
[17:00:28.096]  - future.globals: TRUE
[17:00:28.096] getGlobalsAndPackages() ...
[17:00:28.096] Searching for globals...
[17:00:28.097] - globals found: [1] ‘FUN’
[17:00:28.097] Searching for globals ... DONE
[17:00:28.097] Resolving globals: FALSE
[17:00:28.097] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:28.098] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:28.098] - globals: [1] ‘FUN’
[17:00:28.098] 
[17:00:28.098] getGlobalsAndPackages() ... DONE
[17:00:28.098]  - globals found/used: [n=1] ‘FUN’
[17:00:28.098]  - needed namespaces: [n=0] 
[17:00:28.098] Finding globals ... DONE
[17:00:28.098] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.099] List of 2
[17:00:28.099]  $ ...future.FUN:function (x, ...)  
[17:00:28.099]  $ MoreArgs     :List of 1
[17:00:28.099]   ..$ x: num 42
[17:00:28.099]  - attr(*, "where")=List of 2
[17:00:28.099]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.099]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.099]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.099]  - attr(*, "resolved")= logi FALSE
[17:00:28.099]  - attr(*, "total_size")= num NA
[17:00:28.101] Packages to be attached in all futures: [n=0] 
[17:00:28.101] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.102] Number of futures (= number of chunks): 1
[17:00:28.102] Launching 1 futures (chunks) ...
[17:00:28.102] Chunk #1 of 1 ...
[17:00:28.102]  - Finding globals in '...' for chunk #1 ...
[17:00:28.102] getGlobalsAndPackages() ...
[17:00:28.102] Searching for globals...
[17:00:28.103] 
[17:00:28.103] Searching for globals ... DONE
[17:00:28.103] - globals: [0] <none>
[17:00:28.103] getGlobalsAndPackages() ... DONE
[17:00:28.103]    + additional globals found: [n=0] 
[17:00:28.103]    + additional namespaces needed: [n=0] 
[17:00:28.103]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.103]  - seeds: <none>
[17:00:28.103]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.103] getGlobalsAndPackages() ...
[17:00:28.103] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.104] Resolving globals: FALSE
[17:00:28.104] The total size of the 5 globals is 336 bytes (336 bytes)
[17:00:28.104] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 336 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:28.105] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.105] 
[17:00:28.105] getGlobalsAndPackages() ... DONE
[17:00:28.105] run() for ‘Future’ ...
[17:00:28.105] - state: ‘created’
[17:00:28.105] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.106] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.106]   - Field: ‘label’
[17:00:28.106]   - Field: ‘local’
[17:00:28.106]   - Field: ‘owner’
[17:00:28.106]   - Field: ‘envir’
[17:00:28.106]   - Field: ‘packages’
[17:00:28.106]   - Field: ‘gc’
[17:00:28.106]   - Field: ‘conditions’
[17:00:28.106]   - Field: ‘expr’
[17:00:28.107]   - Field: ‘uuid’
[17:00:28.107]   - Field: ‘seed’
[17:00:28.107]   - Field: ‘version’
[17:00:28.107]   - Field: ‘result’
[17:00:28.107]   - Field: ‘asynchronous’
[17:00:28.107]   - Field: ‘calls’
[17:00:28.107]   - Field: ‘globals’
[17:00:28.107]   - Field: ‘stdout’
[17:00:28.107]   - Field: ‘earlySignal’
[17:00:28.107]   - Field: ‘lazy’
[17:00:28.107]   - Field: ‘state’
[17:00:28.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.108] - Launch lazy future ...
[17:00:28.108] Packages needed by the future expression (n = 0): <none>
[17:00:28.108] Packages needed by future strategies (n = 0): <none>
[17:00:28.108] {
[17:00:28.108]     {
[17:00:28.108]         {
[17:00:28.108]             ...future.startTime <- base::Sys.time()
[17:00:28.108]             {
[17:00:28.108]                 {
[17:00:28.108]                   {
[17:00:28.108]                     base::local({
[17:00:28.108]                       has_future <- base::requireNamespace("future", 
[17:00:28.108]                         quietly = TRUE)
[17:00:28.108]                       if (has_future) {
[17:00:28.108]                         ns <- base::getNamespace("future")
[17:00:28.108]                         version <- ns[[".package"]][["version"]]
[17:00:28.108]                         if (is.null(version)) 
[17:00:28.108]                           version <- utils::packageVersion("future")
[17:00:28.108]                       }
[17:00:28.108]                       else {
[17:00:28.108]                         version <- NULL
[17:00:28.108]                       }
[17:00:28.108]                       if (!has_future || version < "1.8.0") {
[17:00:28.108]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.108]                           "", base::R.version$version.string), 
[17:00:28.108]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.108]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.108]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.108]                             "release", "version")], collapse = " "), 
[17:00:28.108]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.108]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.108]                           info)
[17:00:28.108]                         info <- base::paste(info, collapse = "; ")
[17:00:28.108]                         if (!has_future) {
[17:00:28.108]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.108]                             info)
[17:00:28.108]                         }
[17:00:28.108]                         else {
[17:00:28.108]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.108]                             info, version)
[17:00:28.108]                         }
[17:00:28.108]                         base::stop(msg)
[17:00:28.108]                       }
[17:00:28.108]                     })
[17:00:28.108]                   }
[17:00:28.108]                   ...future.strategy.old <- future::plan("list")
[17:00:28.108]                   options(future.plan = NULL)
[17:00:28.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.108]                 }
[17:00:28.108]                 ...future.workdir <- getwd()
[17:00:28.108]             }
[17:00:28.108]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.108]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.108]         }
[17:00:28.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.108]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.108]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.108]             base::names(...future.oldOptions))
[17:00:28.108]     }
[17:00:28.108]     if (FALSE) {
[17:00:28.108]     }
[17:00:28.108]     else {
[17:00:28.108]         if (TRUE) {
[17:00:28.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.108]                 open = "w")
[17:00:28.108]         }
[17:00:28.108]         else {
[17:00:28.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.108]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.108]         }
[17:00:28.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.108]             base::sink(type = "output", split = FALSE)
[17:00:28.108]             base::close(...future.stdout)
[17:00:28.108]         }, add = TRUE)
[17:00:28.108]     }
[17:00:28.108]     ...future.frame <- base::sys.nframe()
[17:00:28.108]     ...future.conditions <- base::list()
[17:00:28.108]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.108]     if (FALSE) {
[17:00:28.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.108]     }
[17:00:28.108]     ...future.result <- base::tryCatch({
[17:00:28.108]         base::withCallingHandlers({
[17:00:28.108]             ...future.value <- base::withVisible(base::local({
[17:00:28.108]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.108]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.108]                   ...future.globals.maxSize)) {
[17:00:28.108]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.108]                   on.exit(options(oopts), add = TRUE)
[17:00:28.108]                 }
[17:00:28.108]                 {
[17:00:28.108]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.108]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.108]                     USE.NAMES = FALSE)
[17:00:28.108]                   do.call(mapply, args = args)
[17:00:28.108]                 }
[17:00:28.108]             }))
[17:00:28.108]             future::FutureResult(value = ...future.value$value, 
[17:00:28.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.108]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.108]                     ...future.globalenv.names))
[17:00:28.108]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.108]         }, condition = base::local({
[17:00:28.108]             c <- base::c
[17:00:28.108]             inherits <- base::inherits
[17:00:28.108]             invokeRestart <- base::invokeRestart
[17:00:28.108]             length <- base::length
[17:00:28.108]             list <- base::list
[17:00:28.108]             seq.int <- base::seq.int
[17:00:28.108]             signalCondition <- base::signalCondition
[17:00:28.108]             sys.calls <- base::sys.calls
[17:00:28.108]             `[[` <- base::`[[`
[17:00:28.108]             `+` <- base::`+`
[17:00:28.108]             `<<-` <- base::`<<-`
[17:00:28.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.108]                   3L)]
[17:00:28.108]             }
[17:00:28.108]             function(cond) {
[17:00:28.108]                 is_error <- inherits(cond, "error")
[17:00:28.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.108]                   NULL)
[17:00:28.108]                 if (is_error) {
[17:00:28.108]                   sessionInformation <- function() {
[17:00:28.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.108]                       search = base::search(), system = base::Sys.info())
[17:00:28.108]                   }
[17:00:28.108]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.108]                     cond$call), session = sessionInformation(), 
[17:00:28.108]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.108]                   signalCondition(cond)
[17:00:28.108]                 }
[17:00:28.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.108]                 "immediateCondition"))) {
[17:00:28.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.108]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.108]                   if (TRUE && !signal) {
[17:00:28.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.108]                     {
[17:00:28.108]                       inherits <- base::inherits
[17:00:28.108]                       invokeRestart <- base::invokeRestart
[17:00:28.108]                       is.null <- base::is.null
[17:00:28.108]                       muffled <- FALSE
[17:00:28.108]                       if (inherits(cond, "message")) {
[17:00:28.108]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.108]                         if (muffled) 
[17:00:28.108]                           invokeRestart("muffleMessage")
[17:00:28.108]                       }
[17:00:28.108]                       else if (inherits(cond, "warning")) {
[17:00:28.108]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.108]                         if (muffled) 
[17:00:28.108]                           invokeRestart("muffleWarning")
[17:00:28.108]                       }
[17:00:28.108]                       else if (inherits(cond, "condition")) {
[17:00:28.108]                         if (!is.null(pattern)) {
[17:00:28.108]                           computeRestarts <- base::computeRestarts
[17:00:28.108]                           grepl <- base::grepl
[17:00:28.108]                           restarts <- computeRestarts(cond)
[17:00:28.108]                           for (restart in restarts) {
[17:00:28.108]                             name <- restart$name
[17:00:28.108]                             if (is.null(name)) 
[17:00:28.108]                               next
[17:00:28.108]                             if (!grepl(pattern, name)) 
[17:00:28.108]                               next
[17:00:28.108]                             invokeRestart(restart)
[17:00:28.108]                             muffled <- TRUE
[17:00:28.108]                             break
[17:00:28.108]                           }
[17:00:28.108]                         }
[17:00:28.108]                       }
[17:00:28.108]                       invisible(muffled)
[17:00:28.108]                     }
[17:00:28.108]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.108]                   }
[17:00:28.108]                 }
[17:00:28.108]                 else {
[17:00:28.108]                   if (TRUE) {
[17:00:28.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.108]                     {
[17:00:28.108]                       inherits <- base::inherits
[17:00:28.108]                       invokeRestart <- base::invokeRestart
[17:00:28.108]                       is.null <- base::is.null
[17:00:28.108]                       muffled <- FALSE
[17:00:28.108]                       if (inherits(cond, "message")) {
[17:00:28.108]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.108]                         if (muffled) 
[17:00:28.108]                           invokeRestart("muffleMessage")
[17:00:28.108]                       }
[17:00:28.108]                       else if (inherits(cond, "warning")) {
[17:00:28.108]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.108]                         if (muffled) 
[17:00:28.108]                           invokeRestart("muffleWarning")
[17:00:28.108]                       }
[17:00:28.108]                       else if (inherits(cond, "condition")) {
[17:00:28.108]                         if (!is.null(pattern)) {
[17:00:28.108]                           computeRestarts <- base::computeRestarts
[17:00:28.108]                           grepl <- base::grepl
[17:00:28.108]                           restarts <- computeRestarts(cond)
[17:00:28.108]                           for (restart in restarts) {
[17:00:28.108]                             name <- restart$name
[17:00:28.108]                             if (is.null(name)) 
[17:00:28.108]                               next
[17:00:28.108]                             if (!grepl(pattern, name)) 
[17:00:28.108]                               next
[17:00:28.108]                             invokeRestart(restart)
[17:00:28.108]                             muffled <- TRUE
[17:00:28.108]                             break
[17:00:28.108]                           }
[17:00:28.108]                         }
[17:00:28.108]                       }
[17:00:28.108]                       invisible(muffled)
[17:00:28.108]                     }
[17:00:28.108]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.108]                   }
[17:00:28.108]                 }
[17:00:28.108]             }
[17:00:28.108]         }))
[17:00:28.108]     }, error = function(ex) {
[17:00:28.108]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.108]                 ...future.rng), started = ...future.startTime, 
[17:00:28.108]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.108]             version = "1.8"), class = "FutureResult")
[17:00:28.108]     }, finally = {
[17:00:28.108]         if (!identical(...future.workdir, getwd())) 
[17:00:28.108]             setwd(...future.workdir)
[17:00:28.108]         {
[17:00:28.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.108]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.108]             }
[17:00:28.108]             base::options(...future.oldOptions)
[17:00:28.108]             if (.Platform$OS.type == "windows") {
[17:00:28.108]                 old_names <- names(...future.oldEnvVars)
[17:00:28.108]                 envs <- base::Sys.getenv()
[17:00:28.108]                 names <- names(envs)
[17:00:28.108]                 common <- intersect(names, old_names)
[17:00:28.108]                 added <- setdiff(names, old_names)
[17:00:28.108]                 removed <- setdiff(old_names, names)
[17:00:28.108]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.108]                   envs[common]]
[17:00:28.108]                 NAMES <- toupper(changed)
[17:00:28.108]                 args <- list()
[17:00:28.108]                 for (kk in seq_along(NAMES)) {
[17:00:28.108]                   name <- changed[[kk]]
[17:00:28.108]                   NAME <- NAMES[[kk]]
[17:00:28.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.108]                     next
[17:00:28.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.108]                 }
[17:00:28.108]                 NAMES <- toupper(added)
[17:00:28.108]                 for (kk in seq_along(NAMES)) {
[17:00:28.108]                   name <- added[[kk]]
[17:00:28.108]                   NAME <- NAMES[[kk]]
[17:00:28.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.108]                     next
[17:00:28.108]                   args[[name]] <- ""
[17:00:28.108]                 }
[17:00:28.108]                 NAMES <- toupper(removed)
[17:00:28.108]                 for (kk in seq_along(NAMES)) {
[17:00:28.108]                   name <- removed[[kk]]
[17:00:28.108]                   NAME <- NAMES[[kk]]
[17:00:28.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.108]                     next
[17:00:28.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.108]                 }
[17:00:28.108]                 if (length(args) > 0) 
[17:00:28.108]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.108]             }
[17:00:28.108]             else {
[17:00:28.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.108]             }
[17:00:28.108]             {
[17:00:28.108]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.108]                   0L) {
[17:00:28.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.108]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.108]                   base::options(opts)
[17:00:28.108]                 }
[17:00:28.108]                 {
[17:00:28.108]                   {
[17:00:28.108]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.108]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.108]                     2054632538L), envir = base::globalenv(), 
[17:00:28.108]                       inherits = FALSE)
[17:00:28.108]                     NULL
[17:00:28.108]                   }
[17:00:28.108]                   options(future.plan = NULL)
[17:00:28.108]                   if (is.na(NA_character_)) 
[17:00:28.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.108]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.108]                     .init = FALSE)
[17:00:28.108]                 }
[17:00:28.108]             }
[17:00:28.108]         }
[17:00:28.108]     })
[17:00:28.108]     if (TRUE) {
[17:00:28.108]         base::sink(type = "output", split = FALSE)
[17:00:28.108]         if (TRUE) {
[17:00:28.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.108]         }
[17:00:28.108]         else {
[17:00:28.108]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.108]         }
[17:00:28.108]         base::close(...future.stdout)
[17:00:28.108]         ...future.stdout <- NULL
[17:00:28.108]     }
[17:00:28.108]     ...future.result$conditions <- ...future.conditions
[17:00:28.108]     ...future.result$finished <- base::Sys.time()
[17:00:28.108]     ...future.result
[17:00:28.108] }
[17:00:28.110] assign_globals() ...
[17:00:28.110] List of 5
[17:00:28.110]  $ ...future.FUN            :function (x, ...)  
[17:00:28.110]  $ MoreArgs                 :List of 1
[17:00:28.110]   ..$ x: num 42
[17:00:28.110]  $ ...future.elements_ii    :List of 1
[17:00:28.110]   ..$ times:List of 4
[17:00:28.110]   .. ..$ : int 1
[17:00:28.110]   .. ..$ : int 2
[17:00:28.110]   .. ..$ : int 3
[17:00:28.110]   .. ..$ : int 4
[17:00:28.110]  $ ...future.seeds_ii       : NULL
[17:00:28.110]  $ ...future.globals.maxSize: NULL
[17:00:28.110]  - attr(*, "where")=List of 5
[17:00:28.110]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.110]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.110]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.110]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.110]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.110]  - attr(*, "resolved")= logi FALSE
[17:00:28.110]  - attr(*, "total_size")= num 336
[17:00:28.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.110]  - attr(*, "already-done")= logi TRUE
[17:00:28.116] - copied ‘...future.FUN’ to environment
[17:00:28.116] - copied ‘MoreArgs’ to environment
[17:00:28.116] - copied ‘...future.elements_ii’ to environment
[17:00:28.116] - copied ‘...future.seeds_ii’ to environment
[17:00:28.116] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.116] assign_globals() ... done
[17:00:28.117] plan(): Setting new future strategy stack:
[17:00:28.117] List of future strategies:
[17:00:28.117] 1. sequential:
[17:00:28.117]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.117]    - tweaked: FALSE
[17:00:28.117]    - call: NULL
[17:00:28.117] plan(): nbrOfWorkers() = 1
[17:00:28.118] plan(): Setting new future strategy stack:
[17:00:28.118] List of future strategies:
[17:00:28.118] 1. sequential:
[17:00:28.118]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.118]    - tweaked: FALSE
[17:00:28.118]    - call: plan(strategy)
[17:00:28.118] plan(): nbrOfWorkers() = 1
[17:00:28.119] SequentialFuture started (and completed)
[17:00:28.119] - Launch lazy future ... done
[17:00:28.119] run() for ‘SequentialFuture’ ... done
[17:00:28.119] Created future:
[17:00:28.119] SequentialFuture:
[17:00:28.119] Label: ‘future_mapply-1’
[17:00:28.119] Expression:
[17:00:28.119] {
[17:00:28.119]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.119]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.119]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.119]         on.exit(options(oopts), add = TRUE)
[17:00:28.119]     }
[17:00:28.119]     {
[17:00:28.119]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.119]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.119]         do.call(mapply, args = args)
[17:00:28.119]     }
[17:00:28.119] }
[17:00:28.119] Lazy evaluation: FALSE
[17:00:28.119] Asynchronous evaluation: FALSE
[17:00:28.119] Local evaluation: TRUE
[17:00:28.119] Environment: R_GlobalEnv
[17:00:28.119] Capture standard output: TRUE
[17:00:28.119] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.119] Globals: 5 objects totaling 336 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.119] Packages: <none>
[17:00:28.119] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.119] Resolved: TRUE
[17:00:28.119] Value: 280 bytes of class ‘list’
[17:00:28.119] Early signaling: FALSE
[17:00:28.119] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.119] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.120] Chunk #1 of 1 ... DONE
[17:00:28.120] Launching 1 futures (chunks) ... DONE
[17:00:28.120] Resolving 1 futures (chunks) ...
[17:00:28.120] resolve() on list ...
[17:00:28.120]  recursive: 0
[17:00:28.122]  length: 1
[17:00:28.122] 
[17:00:28.122] resolved() for ‘SequentialFuture’ ...
[17:00:28.123] - state: ‘finished’
[17:00:28.123] - run: TRUE
[17:00:28.123] - result: ‘FutureResult’
[17:00:28.123] resolved() for ‘SequentialFuture’ ... done
[17:00:28.123] Future #1
[17:00:28.123] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.123] - nx: 1
[17:00:28.123] - relay: TRUE
[17:00:28.123] - stdout: TRUE
[17:00:28.123] - signal: TRUE
[17:00:28.124] - resignal: FALSE
[17:00:28.124] - force: TRUE
[17:00:28.124] - relayed: [n=1] FALSE
[17:00:28.124] - queued futures: [n=1] FALSE
[17:00:28.124]  - until=1
[17:00:28.124]  - relaying element #1
[17:00:28.124] - relayed: [n=1] TRUE
[17:00:28.124] - queued futures: [n=1] TRUE
[17:00:28.124] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.124]  length: 0 (resolved future 1)
[17:00:28.125] Relaying remaining futures
[17:00:28.125] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.125] - nx: 1
[17:00:28.125] - relay: TRUE
[17:00:28.125] - stdout: TRUE
[17:00:28.125] - signal: TRUE
[17:00:28.125] - resignal: FALSE
[17:00:28.125] - force: TRUE
[17:00:28.125] - relayed: [n=1] TRUE
[17:00:28.125] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.125] - relayed: [n=1] TRUE
[17:00:28.126] - queued futures: [n=1] TRUE
[17:00:28.126] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.126] resolve() on list ... DONE
[17:00:28.126]  - Number of value chunks collected: 1
[17:00:28.126] Resolving 1 futures (chunks) ... DONE
[17:00:28.126] Reducing values from 1 chunks ...
[17:00:28.126]  - Number of values collected after concatenation: 4
[17:00:28.126]  - Number of values expected: 4
[17:00:28.126] Reducing values from 1 chunks ... DONE
[17:00:28.126] future_mapply() ... DONE
[17:00:28.127] future_mapply() ...
[17:00:28.127] Number of chunks: 1
[17:00:28.127] getGlobalsAndPackagesXApply() ...
[17:00:28.127]  - future.globals: TRUE
[17:00:28.127] getGlobalsAndPackages() ...
[17:00:28.127] Searching for globals...
[17:00:28.128] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:00:28.128] Searching for globals ... DONE
[17:00:28.129] Resolving globals: FALSE
[17:00:28.129] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:00:28.129] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:00:28.129] - globals: [1] ‘FUN’
[17:00:28.130] 
[17:00:28.130] getGlobalsAndPackages() ... DONE
[17:00:28.130]  - globals found/used: [n=1] ‘FUN’
[17:00:28.130]  - needed namespaces: [n=0] 
[17:00:28.130] Finding globals ... DONE
[17:00:28.130] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.130] List of 2
[17:00:28.130]  $ ...future.FUN:function (x, y)  
[17:00:28.130]  $ MoreArgs     : NULL
[17:00:28.130]  - attr(*, "where")=List of 2
[17:00:28.130]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.130]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.130]  - attr(*, "resolved")= logi FALSE
[17:00:28.130]  - attr(*, "total_size")= num NA
[17:00:28.133] Packages to be attached in all futures: [n=0] 
[17:00:28.133] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.133] Number of futures (= number of chunks): 1
[17:00:28.133] Launching 1 futures (chunks) ...
[17:00:28.133] Chunk #1 of 1 ...
[17:00:28.133]  - Finding globals in '...' for chunk #1 ...
[17:00:28.133] getGlobalsAndPackages() ...
[17:00:28.133] Searching for globals...
[17:00:28.134] 
[17:00:28.134] Searching for globals ... DONE
[17:00:28.134] - globals: [0] <none>
[17:00:28.134] getGlobalsAndPackages() ... DONE
[17:00:28.134]    + additional globals found: [n=0] 
[17:00:28.134]    + additional namespaces needed: [n=0] 
[17:00:28.134]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.134]  - seeds: <none>
[17:00:28.134]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.134] getGlobalsAndPackages() ...
[17:00:28.135] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.135] Resolving globals: FALSE
[17:00:28.135] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[17:00:28.136] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.136] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.136] 
[17:00:28.136] getGlobalsAndPackages() ... DONE
[17:00:28.136] run() for ‘Future’ ...
[17:00:28.136] - state: ‘created’
[17:00:28.136] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.137] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.137]   - Field: ‘label’
[17:00:28.137]   - Field: ‘local’
[17:00:28.137]   - Field: ‘owner’
[17:00:28.137]   - Field: ‘envir’
[17:00:28.137]   - Field: ‘packages’
[17:00:28.137]   - Field: ‘gc’
[17:00:28.138]   - Field: ‘conditions’
[17:00:28.138]   - Field: ‘expr’
[17:00:28.138]   - Field: ‘uuid’
[17:00:28.138]   - Field: ‘seed’
[17:00:28.138]   - Field: ‘version’
[17:00:28.138]   - Field: ‘result’
[17:00:28.138]   - Field: ‘asynchronous’
[17:00:28.138]   - Field: ‘calls’
[17:00:28.138]   - Field: ‘globals’
[17:00:28.138]   - Field: ‘stdout’
[17:00:28.138]   - Field: ‘earlySignal’
[17:00:28.139]   - Field: ‘lazy’
[17:00:28.139]   - Field: ‘state’
[17:00:28.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.139] - Launch lazy future ...
[17:00:28.139] Packages needed by the future expression (n = 0): <none>
[17:00:28.139] Packages needed by future strategies (n = 0): <none>
[17:00:28.140] {
[17:00:28.140]     {
[17:00:28.140]         {
[17:00:28.140]             ...future.startTime <- base::Sys.time()
[17:00:28.140]             {
[17:00:28.140]                 {
[17:00:28.140]                   {
[17:00:28.140]                     base::local({
[17:00:28.140]                       has_future <- base::requireNamespace("future", 
[17:00:28.140]                         quietly = TRUE)
[17:00:28.140]                       if (has_future) {
[17:00:28.140]                         ns <- base::getNamespace("future")
[17:00:28.140]                         version <- ns[[".package"]][["version"]]
[17:00:28.140]                         if (is.null(version)) 
[17:00:28.140]                           version <- utils::packageVersion("future")
[17:00:28.140]                       }
[17:00:28.140]                       else {
[17:00:28.140]                         version <- NULL
[17:00:28.140]                       }
[17:00:28.140]                       if (!has_future || version < "1.8.0") {
[17:00:28.140]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.140]                           "", base::R.version$version.string), 
[17:00:28.140]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.140]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.140]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.140]                             "release", "version")], collapse = " "), 
[17:00:28.140]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.140]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.140]                           info)
[17:00:28.140]                         info <- base::paste(info, collapse = "; ")
[17:00:28.140]                         if (!has_future) {
[17:00:28.140]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.140]                             info)
[17:00:28.140]                         }
[17:00:28.140]                         else {
[17:00:28.140]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.140]                             info, version)
[17:00:28.140]                         }
[17:00:28.140]                         base::stop(msg)
[17:00:28.140]                       }
[17:00:28.140]                     })
[17:00:28.140]                   }
[17:00:28.140]                   ...future.strategy.old <- future::plan("list")
[17:00:28.140]                   options(future.plan = NULL)
[17:00:28.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.140]                 }
[17:00:28.140]                 ...future.workdir <- getwd()
[17:00:28.140]             }
[17:00:28.140]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.140]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.140]         }
[17:00:28.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.140]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.140]             base::names(...future.oldOptions))
[17:00:28.140]     }
[17:00:28.140]     if (FALSE) {
[17:00:28.140]     }
[17:00:28.140]     else {
[17:00:28.140]         if (TRUE) {
[17:00:28.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.140]                 open = "w")
[17:00:28.140]         }
[17:00:28.140]         else {
[17:00:28.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.140]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.140]         }
[17:00:28.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.140]             base::sink(type = "output", split = FALSE)
[17:00:28.140]             base::close(...future.stdout)
[17:00:28.140]         }, add = TRUE)
[17:00:28.140]     }
[17:00:28.140]     ...future.frame <- base::sys.nframe()
[17:00:28.140]     ...future.conditions <- base::list()
[17:00:28.140]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.140]     if (FALSE) {
[17:00:28.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.140]     }
[17:00:28.140]     ...future.result <- base::tryCatch({
[17:00:28.140]         base::withCallingHandlers({
[17:00:28.140]             ...future.value <- base::withVisible(base::local({
[17:00:28.140]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.140]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.140]                   ...future.globals.maxSize)) {
[17:00:28.140]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.140]                   on.exit(options(oopts), add = TRUE)
[17:00:28.140]                 }
[17:00:28.140]                 {
[17:00:28.140]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.140]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.140]                     USE.NAMES = FALSE)
[17:00:28.140]                   do.call(mapply, args = args)
[17:00:28.140]                 }
[17:00:28.140]             }))
[17:00:28.140]             future::FutureResult(value = ...future.value$value, 
[17:00:28.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.140]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.140]                     ...future.globalenv.names))
[17:00:28.140]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.140]         }, condition = base::local({
[17:00:28.140]             c <- base::c
[17:00:28.140]             inherits <- base::inherits
[17:00:28.140]             invokeRestart <- base::invokeRestart
[17:00:28.140]             length <- base::length
[17:00:28.140]             list <- base::list
[17:00:28.140]             seq.int <- base::seq.int
[17:00:28.140]             signalCondition <- base::signalCondition
[17:00:28.140]             sys.calls <- base::sys.calls
[17:00:28.140]             `[[` <- base::`[[`
[17:00:28.140]             `+` <- base::`+`
[17:00:28.140]             `<<-` <- base::`<<-`
[17:00:28.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.140]                   3L)]
[17:00:28.140]             }
[17:00:28.140]             function(cond) {
[17:00:28.140]                 is_error <- inherits(cond, "error")
[17:00:28.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.140]                   NULL)
[17:00:28.140]                 if (is_error) {
[17:00:28.140]                   sessionInformation <- function() {
[17:00:28.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.140]                       search = base::search(), system = base::Sys.info())
[17:00:28.140]                   }
[17:00:28.140]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.140]                     cond$call), session = sessionInformation(), 
[17:00:28.140]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.140]                   signalCondition(cond)
[17:00:28.140]                 }
[17:00:28.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.140]                 "immediateCondition"))) {
[17:00:28.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.140]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.140]                   if (TRUE && !signal) {
[17:00:28.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.140]                     {
[17:00:28.140]                       inherits <- base::inherits
[17:00:28.140]                       invokeRestart <- base::invokeRestart
[17:00:28.140]                       is.null <- base::is.null
[17:00:28.140]                       muffled <- FALSE
[17:00:28.140]                       if (inherits(cond, "message")) {
[17:00:28.140]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.140]                         if (muffled) 
[17:00:28.140]                           invokeRestart("muffleMessage")
[17:00:28.140]                       }
[17:00:28.140]                       else if (inherits(cond, "warning")) {
[17:00:28.140]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.140]                         if (muffled) 
[17:00:28.140]                           invokeRestart("muffleWarning")
[17:00:28.140]                       }
[17:00:28.140]                       else if (inherits(cond, "condition")) {
[17:00:28.140]                         if (!is.null(pattern)) {
[17:00:28.140]                           computeRestarts <- base::computeRestarts
[17:00:28.140]                           grepl <- base::grepl
[17:00:28.140]                           restarts <- computeRestarts(cond)
[17:00:28.140]                           for (restart in restarts) {
[17:00:28.140]                             name <- restart$name
[17:00:28.140]                             if (is.null(name)) 
[17:00:28.140]                               next
[17:00:28.140]                             if (!grepl(pattern, name)) 
[17:00:28.140]                               next
[17:00:28.140]                             invokeRestart(restart)
[17:00:28.140]                             muffled <- TRUE
[17:00:28.140]                             break
[17:00:28.140]                           }
[17:00:28.140]                         }
[17:00:28.140]                       }
[17:00:28.140]                       invisible(muffled)
[17:00:28.140]                     }
[17:00:28.140]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.140]                   }
[17:00:28.140]                 }
[17:00:28.140]                 else {
[17:00:28.140]                   if (TRUE) {
[17:00:28.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.140]                     {
[17:00:28.140]                       inherits <- base::inherits
[17:00:28.140]                       invokeRestart <- base::invokeRestart
[17:00:28.140]                       is.null <- base::is.null
[17:00:28.140]                       muffled <- FALSE
[17:00:28.140]                       if (inherits(cond, "message")) {
[17:00:28.140]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.140]                         if (muffled) 
[17:00:28.140]                           invokeRestart("muffleMessage")
[17:00:28.140]                       }
[17:00:28.140]                       else if (inherits(cond, "warning")) {
[17:00:28.140]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.140]                         if (muffled) 
[17:00:28.140]                           invokeRestart("muffleWarning")
[17:00:28.140]                       }
[17:00:28.140]                       else if (inherits(cond, "condition")) {
[17:00:28.140]                         if (!is.null(pattern)) {
[17:00:28.140]                           computeRestarts <- base::computeRestarts
[17:00:28.140]                           grepl <- base::grepl
[17:00:28.140]                           restarts <- computeRestarts(cond)
[17:00:28.140]                           for (restart in restarts) {
[17:00:28.140]                             name <- restart$name
[17:00:28.140]                             if (is.null(name)) 
[17:00:28.140]                               next
[17:00:28.140]                             if (!grepl(pattern, name)) 
[17:00:28.140]                               next
[17:00:28.140]                             invokeRestart(restart)
[17:00:28.140]                             muffled <- TRUE
[17:00:28.140]                             break
[17:00:28.140]                           }
[17:00:28.140]                         }
[17:00:28.140]                       }
[17:00:28.140]                       invisible(muffled)
[17:00:28.140]                     }
[17:00:28.140]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.140]                   }
[17:00:28.140]                 }
[17:00:28.140]             }
[17:00:28.140]         }))
[17:00:28.140]     }, error = function(ex) {
[17:00:28.140]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.140]                 ...future.rng), started = ...future.startTime, 
[17:00:28.140]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.140]             version = "1.8"), class = "FutureResult")
[17:00:28.140]     }, finally = {
[17:00:28.140]         if (!identical(...future.workdir, getwd())) 
[17:00:28.140]             setwd(...future.workdir)
[17:00:28.140]         {
[17:00:28.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.140]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.140]             }
[17:00:28.140]             base::options(...future.oldOptions)
[17:00:28.140]             if (.Platform$OS.type == "windows") {
[17:00:28.140]                 old_names <- names(...future.oldEnvVars)
[17:00:28.140]                 envs <- base::Sys.getenv()
[17:00:28.140]                 names <- names(envs)
[17:00:28.140]                 common <- intersect(names, old_names)
[17:00:28.140]                 added <- setdiff(names, old_names)
[17:00:28.140]                 removed <- setdiff(old_names, names)
[17:00:28.140]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.140]                   envs[common]]
[17:00:28.140]                 NAMES <- toupper(changed)
[17:00:28.140]                 args <- list()
[17:00:28.140]                 for (kk in seq_along(NAMES)) {
[17:00:28.140]                   name <- changed[[kk]]
[17:00:28.140]                   NAME <- NAMES[[kk]]
[17:00:28.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.140]                     next
[17:00:28.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.140]                 }
[17:00:28.140]                 NAMES <- toupper(added)
[17:00:28.140]                 for (kk in seq_along(NAMES)) {
[17:00:28.140]                   name <- added[[kk]]
[17:00:28.140]                   NAME <- NAMES[[kk]]
[17:00:28.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.140]                     next
[17:00:28.140]                   args[[name]] <- ""
[17:00:28.140]                 }
[17:00:28.140]                 NAMES <- toupper(removed)
[17:00:28.140]                 for (kk in seq_along(NAMES)) {
[17:00:28.140]                   name <- removed[[kk]]
[17:00:28.140]                   NAME <- NAMES[[kk]]
[17:00:28.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.140]                     next
[17:00:28.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.140]                 }
[17:00:28.140]                 if (length(args) > 0) 
[17:00:28.140]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.140]             }
[17:00:28.140]             else {
[17:00:28.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.140]             }
[17:00:28.140]             {
[17:00:28.140]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.140]                   0L) {
[17:00:28.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.140]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.140]                   base::options(opts)
[17:00:28.140]                 }
[17:00:28.140]                 {
[17:00:28.140]                   {
[17:00:28.140]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.140]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.140]                     2054632538L), envir = base::globalenv(), 
[17:00:28.140]                       inherits = FALSE)
[17:00:28.140]                     NULL
[17:00:28.140]                   }
[17:00:28.140]                   options(future.plan = NULL)
[17:00:28.140]                   if (is.na(NA_character_)) 
[17:00:28.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.140]                     .init = FALSE)
[17:00:28.140]                 }
[17:00:28.140]             }
[17:00:28.140]         }
[17:00:28.140]     })
[17:00:28.140]     if (TRUE) {
[17:00:28.140]         base::sink(type = "output", split = FALSE)
[17:00:28.140]         if (TRUE) {
[17:00:28.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.140]         }
[17:00:28.140]         else {
[17:00:28.140]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.140]         }
[17:00:28.140]         base::close(...future.stdout)
[17:00:28.140]         ...future.stdout <- NULL
[17:00:28.140]     }
[17:00:28.140]     ...future.result$conditions <- ...future.conditions
[17:00:28.140]     ...future.result$finished <- base::Sys.time()
[17:00:28.140]     ...future.result
[17:00:28.140] }
[17:00:28.141] assign_globals() ...
[17:00:28.141] List of 5
[17:00:28.141]  $ ...future.FUN            :function (x, y)  
[17:00:28.141]  $ MoreArgs                 : NULL
[17:00:28.141]  $ ...future.elements_ii    :List of 2
[17:00:28.141]   ..$ :List of 3
[17:00:28.141]   .. ..$ a: num 1
[17:00:28.141]   .. ..$ b: num 2
[17:00:28.141]   .. ..$ c: num 3
[17:00:28.141]   ..$ :List of 3
[17:00:28.141]   .. ..$ A: num 10
[17:00:28.141]   .. ..$ B: num 0
[17:00:28.141]   .. ..$ C: num -10
[17:00:28.141]  $ ...future.seeds_ii       : NULL
[17:00:28.141]  $ ...future.globals.maxSize: NULL
[17:00:28.141]  - attr(*, "where")=List of 5
[17:00:28.141]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.141]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.141]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.141]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.141]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.141]  - attr(*, "resolved")= logi FALSE
[17:00:28.141]  - attr(*, "total_size")= num 2312
[17:00:28.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.141]  - attr(*, "already-done")= logi TRUE
[17:00:28.149] - reassign environment for ‘...future.FUN’
[17:00:28.149] - copied ‘...future.FUN’ to environment
[17:00:28.150] - copied ‘MoreArgs’ to environment
[17:00:28.150] - copied ‘...future.elements_ii’ to environment
[17:00:28.150] - copied ‘...future.seeds_ii’ to environment
[17:00:28.150] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.150] assign_globals() ... done
[17:00:28.150] plan(): Setting new future strategy stack:
[17:00:28.150] List of future strategies:
[17:00:28.150] 1. sequential:
[17:00:28.150]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.150]    - tweaked: FALSE
[17:00:28.150]    - call: NULL
[17:00:28.151] plan(): nbrOfWorkers() = 1
[17:00:28.151] plan(): Setting new future strategy stack:
[17:00:28.152] List of future strategies:
[17:00:28.152] 1. sequential:
[17:00:28.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.152]    - tweaked: FALSE
[17:00:28.152]    - call: plan(strategy)
[17:00:28.152] plan(): nbrOfWorkers() = 1
[17:00:28.152] SequentialFuture started (and completed)
[17:00:28.152] - Launch lazy future ... done
[17:00:28.152] run() for ‘SequentialFuture’ ... done
[17:00:28.153] Created future:
[17:00:28.153] SequentialFuture:
[17:00:28.153] Label: ‘future_mapply-1’
[17:00:28.153] Expression:
[17:00:28.153] {
[17:00:28.153]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.153]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.153]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.153]         on.exit(options(oopts), add = TRUE)
[17:00:28.153]     }
[17:00:28.153]     {
[17:00:28.153]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.153]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.153]         do.call(mapply, args = args)
[17:00:28.153]     }
[17:00:28.153] }
[17:00:28.153] Lazy evaluation: FALSE
[17:00:28.153] Asynchronous evaluation: FALSE
[17:00:28.153] Local evaluation: TRUE
[17:00:28.153] Environment: R_GlobalEnv
[17:00:28.153] Capture standard output: TRUE
[17:00:28.153] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.153] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.153] Packages: <none>
[17:00:28.153] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.153] Resolved: TRUE
[17:00:28.153] Value: 200 bytes of class ‘list’
[17:00:28.153] Early signaling: FALSE
[17:00:28.153] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.153] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.153] Chunk #1 of 1 ... DONE
[17:00:28.154] Launching 1 futures (chunks) ... DONE
[17:00:28.154] Resolving 1 futures (chunks) ...
[17:00:28.154] resolve() on list ...
[17:00:28.154]  recursive: 0
[17:00:28.154]  length: 1
[17:00:28.154] 
[17:00:28.154] resolved() for ‘SequentialFuture’ ...
[17:00:28.154] - state: ‘finished’
[17:00:28.154] - run: TRUE
[17:00:28.154] - result: ‘FutureResult’
[17:00:28.154] resolved() for ‘SequentialFuture’ ... done
[17:00:28.155] Future #1
[17:00:28.155] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.155] - nx: 1
[17:00:28.155] - relay: TRUE
[17:00:28.155] - stdout: TRUE
[17:00:28.155] - signal: TRUE
[17:00:28.155] - resignal: FALSE
[17:00:28.155] - force: TRUE
[17:00:28.155] - relayed: [n=1] FALSE
[17:00:28.155] - queued futures: [n=1] FALSE
[17:00:28.156]  - until=1
[17:00:28.156]  - relaying element #1
[17:00:28.156] - relayed: [n=1] TRUE
[17:00:28.156] - queued futures: [n=1] TRUE
[17:00:28.156] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.156]  length: 0 (resolved future 1)
[17:00:28.156] Relaying remaining futures
[17:00:28.156] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.156] - nx: 1
[17:00:28.156] - relay: TRUE
[17:00:28.157] - stdout: TRUE
[17:00:28.157] - signal: TRUE
[17:00:28.157] - resignal: FALSE
[17:00:28.157] - force: TRUE
[17:00:28.157] - relayed: [n=1] TRUE
[17:00:28.157] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.157] - relayed: [n=1] TRUE
[17:00:28.157] - queued futures: [n=1] TRUE
[17:00:28.157] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.157] resolve() on list ... DONE
[17:00:28.157]  - Number of value chunks collected: 1
[17:00:28.158] Resolving 1 futures (chunks) ... DONE
[17:00:28.158] Reducing values from 1 chunks ...
[17:00:28.158]  - Number of values collected after concatenation: 3
[17:00:28.158]  - Number of values expected: 3
[17:00:28.158] Reducing values from 1 chunks ... DONE
[17:00:28.158] future_mapply() ... DONE
- future_.mapply()
[17:00:28.159] future_mapply() ...
[17:00:28.159] Number of chunks: 1
[17:00:28.159] getGlobalsAndPackagesXApply() ...
[17:00:28.159]  - future.globals: TRUE
[17:00:28.159] getGlobalsAndPackages() ...
[17:00:28.159] Searching for globals...
[17:00:28.160] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:00:28.161] Searching for globals ... DONE
[17:00:28.161] Resolving globals: FALSE
[17:00:28.161] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:00:28.161] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:00:28.161] - globals: [1] ‘FUN’
[17:00:28.162] 
[17:00:28.162] getGlobalsAndPackages() ... DONE
[17:00:28.162]  - globals found/used: [n=1] ‘FUN’
[17:00:28.162]  - needed namespaces: [n=0] 
[17:00:28.162] Finding globals ... DONE
[17:00:28.162] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.162] List of 2
[17:00:28.162]  $ ...future.FUN:function (x, y)  
[17:00:28.162]  $ MoreArgs     : list()
[17:00:28.162]  - attr(*, "where")=List of 2
[17:00:28.162]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.162]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.162]  - attr(*, "resolved")= logi FALSE
[17:00:28.162]  - attr(*, "total_size")= num NA
[17:00:28.165] Packages to be attached in all futures: [n=0] 
[17:00:28.165] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.165] Number of futures (= number of chunks): 1
[17:00:28.165] Launching 1 futures (chunks) ...
[17:00:28.165] Chunk #1 of 1 ...
[17:00:28.165]  - Finding globals in '...' for chunk #1 ...
[17:00:28.165] getGlobalsAndPackages() ...
[17:00:28.165] Searching for globals...
[17:00:28.166] 
[17:00:28.166] Searching for globals ... DONE
[17:00:28.166] - globals: [0] <none>
[17:00:28.166] getGlobalsAndPackages() ... DONE
[17:00:28.166]    + additional globals found: [n=0] 
[17:00:28.166]    + additional namespaces needed: [n=0] 
[17:00:28.166]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.166]  - seeds: <none>
[17:00:28.166]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.167] getGlobalsAndPackages() ...
[17:00:28.167] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.167] Resolving globals: FALSE
[17:00:28.167] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[17:00:28.168] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:28.168] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.168] 
[17:00:28.168] getGlobalsAndPackages() ... DONE
[17:00:28.168] run() for ‘Future’ ...
[17:00:28.168] - state: ‘created’
[17:00:28.168] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.169] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.169] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.169]   - Field: ‘label’
[17:00:28.169]   - Field: ‘local’
[17:00:28.169]   - Field: ‘owner’
[17:00:28.169]   - Field: ‘envir’
[17:00:28.169]   - Field: ‘packages’
[17:00:28.169]   - Field: ‘gc’
[17:00:28.170]   - Field: ‘conditions’
[17:00:28.170]   - Field: ‘expr’
[17:00:28.170]   - Field: ‘uuid’
[17:00:28.170]   - Field: ‘seed’
[17:00:28.170]   - Field: ‘version’
[17:00:28.170]   - Field: ‘result’
[17:00:28.170]   - Field: ‘asynchronous’
[17:00:28.170]   - Field: ‘calls’
[17:00:28.170]   - Field: ‘globals’
[17:00:28.170]   - Field: ‘stdout’
[17:00:28.170]   - Field: ‘earlySignal’
[17:00:28.170]   - Field: ‘lazy’
[17:00:28.171]   - Field: ‘state’
[17:00:28.171] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.171] - Launch lazy future ...
[17:00:28.171] Packages needed by the future expression (n = 0): <none>
[17:00:28.171] Packages needed by future strategies (n = 0): <none>
[17:00:28.171] {
[17:00:28.171]     {
[17:00:28.171]         {
[17:00:28.171]             ...future.startTime <- base::Sys.time()
[17:00:28.171]             {
[17:00:28.171]                 {
[17:00:28.171]                   {
[17:00:28.171]                     base::local({
[17:00:28.171]                       has_future <- base::requireNamespace("future", 
[17:00:28.171]                         quietly = TRUE)
[17:00:28.171]                       if (has_future) {
[17:00:28.171]                         ns <- base::getNamespace("future")
[17:00:28.171]                         version <- ns[[".package"]][["version"]]
[17:00:28.171]                         if (is.null(version)) 
[17:00:28.171]                           version <- utils::packageVersion("future")
[17:00:28.171]                       }
[17:00:28.171]                       else {
[17:00:28.171]                         version <- NULL
[17:00:28.171]                       }
[17:00:28.171]                       if (!has_future || version < "1.8.0") {
[17:00:28.171]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.171]                           "", base::R.version$version.string), 
[17:00:28.171]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.171]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.171]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.171]                             "release", "version")], collapse = " "), 
[17:00:28.171]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.171]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.171]                           info)
[17:00:28.171]                         info <- base::paste(info, collapse = "; ")
[17:00:28.171]                         if (!has_future) {
[17:00:28.171]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.171]                             info)
[17:00:28.171]                         }
[17:00:28.171]                         else {
[17:00:28.171]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.171]                             info, version)
[17:00:28.171]                         }
[17:00:28.171]                         base::stop(msg)
[17:00:28.171]                       }
[17:00:28.171]                     })
[17:00:28.171]                   }
[17:00:28.171]                   ...future.strategy.old <- future::plan("list")
[17:00:28.171]                   options(future.plan = NULL)
[17:00:28.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.171]                 }
[17:00:28.171]                 ...future.workdir <- getwd()
[17:00:28.171]             }
[17:00:28.171]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.171]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.171]         }
[17:00:28.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.171]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.171]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.171]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.171]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.171]             base::names(...future.oldOptions))
[17:00:28.171]     }
[17:00:28.171]     if (FALSE) {
[17:00:28.171]     }
[17:00:28.171]     else {
[17:00:28.171]         if (TRUE) {
[17:00:28.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.171]                 open = "w")
[17:00:28.171]         }
[17:00:28.171]         else {
[17:00:28.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.171]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.171]         }
[17:00:28.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.171]             base::sink(type = "output", split = FALSE)
[17:00:28.171]             base::close(...future.stdout)
[17:00:28.171]         }, add = TRUE)
[17:00:28.171]     }
[17:00:28.171]     ...future.frame <- base::sys.nframe()
[17:00:28.171]     ...future.conditions <- base::list()
[17:00:28.171]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.171]     if (FALSE) {
[17:00:28.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.171]     }
[17:00:28.171]     ...future.result <- base::tryCatch({
[17:00:28.171]         base::withCallingHandlers({
[17:00:28.171]             ...future.value <- base::withVisible(base::local({
[17:00:28.171]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.171]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.171]                   ...future.globals.maxSize)) {
[17:00:28.171]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.171]                   on.exit(options(oopts), add = TRUE)
[17:00:28.171]                 }
[17:00:28.171]                 {
[17:00:28.171]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.171]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.171]                     USE.NAMES = FALSE)
[17:00:28.171]                   do.call(mapply, args = args)
[17:00:28.171]                 }
[17:00:28.171]             }))
[17:00:28.171]             future::FutureResult(value = ...future.value$value, 
[17:00:28.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.171]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.171]                     ...future.globalenv.names))
[17:00:28.171]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.171]         }, condition = base::local({
[17:00:28.171]             c <- base::c
[17:00:28.171]             inherits <- base::inherits
[17:00:28.171]             invokeRestart <- base::invokeRestart
[17:00:28.171]             length <- base::length
[17:00:28.171]             list <- base::list
[17:00:28.171]             seq.int <- base::seq.int
[17:00:28.171]             signalCondition <- base::signalCondition
[17:00:28.171]             sys.calls <- base::sys.calls
[17:00:28.171]             `[[` <- base::`[[`
[17:00:28.171]             `+` <- base::`+`
[17:00:28.171]             `<<-` <- base::`<<-`
[17:00:28.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.171]                   3L)]
[17:00:28.171]             }
[17:00:28.171]             function(cond) {
[17:00:28.171]                 is_error <- inherits(cond, "error")
[17:00:28.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.171]                   NULL)
[17:00:28.171]                 if (is_error) {
[17:00:28.171]                   sessionInformation <- function() {
[17:00:28.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.171]                       search = base::search(), system = base::Sys.info())
[17:00:28.171]                   }
[17:00:28.171]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.171]                     cond$call), session = sessionInformation(), 
[17:00:28.171]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.171]                   signalCondition(cond)
[17:00:28.171]                 }
[17:00:28.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.171]                 "immediateCondition"))) {
[17:00:28.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.171]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.171]                   if (TRUE && !signal) {
[17:00:28.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.171]                     {
[17:00:28.171]                       inherits <- base::inherits
[17:00:28.171]                       invokeRestart <- base::invokeRestart
[17:00:28.171]                       is.null <- base::is.null
[17:00:28.171]                       muffled <- FALSE
[17:00:28.171]                       if (inherits(cond, "message")) {
[17:00:28.171]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.171]                         if (muffled) 
[17:00:28.171]                           invokeRestart("muffleMessage")
[17:00:28.171]                       }
[17:00:28.171]                       else if (inherits(cond, "warning")) {
[17:00:28.171]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.171]                         if (muffled) 
[17:00:28.171]                           invokeRestart("muffleWarning")
[17:00:28.171]                       }
[17:00:28.171]                       else if (inherits(cond, "condition")) {
[17:00:28.171]                         if (!is.null(pattern)) {
[17:00:28.171]                           computeRestarts <- base::computeRestarts
[17:00:28.171]                           grepl <- base::grepl
[17:00:28.171]                           restarts <- computeRestarts(cond)
[17:00:28.171]                           for (restart in restarts) {
[17:00:28.171]                             name <- restart$name
[17:00:28.171]                             if (is.null(name)) 
[17:00:28.171]                               next
[17:00:28.171]                             if (!grepl(pattern, name)) 
[17:00:28.171]                               next
[17:00:28.171]                             invokeRestart(restart)
[17:00:28.171]                             muffled <- TRUE
[17:00:28.171]                             break
[17:00:28.171]                           }
[17:00:28.171]                         }
[17:00:28.171]                       }
[17:00:28.171]                       invisible(muffled)
[17:00:28.171]                     }
[17:00:28.171]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.171]                   }
[17:00:28.171]                 }
[17:00:28.171]                 else {
[17:00:28.171]                   if (TRUE) {
[17:00:28.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.171]                     {
[17:00:28.171]                       inherits <- base::inherits
[17:00:28.171]                       invokeRestart <- base::invokeRestart
[17:00:28.171]                       is.null <- base::is.null
[17:00:28.171]                       muffled <- FALSE
[17:00:28.171]                       if (inherits(cond, "message")) {
[17:00:28.171]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.171]                         if (muffled) 
[17:00:28.171]                           invokeRestart("muffleMessage")
[17:00:28.171]                       }
[17:00:28.171]                       else if (inherits(cond, "warning")) {
[17:00:28.171]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.171]                         if (muffled) 
[17:00:28.171]                           invokeRestart("muffleWarning")
[17:00:28.171]                       }
[17:00:28.171]                       else if (inherits(cond, "condition")) {
[17:00:28.171]                         if (!is.null(pattern)) {
[17:00:28.171]                           computeRestarts <- base::computeRestarts
[17:00:28.171]                           grepl <- base::grepl
[17:00:28.171]                           restarts <- computeRestarts(cond)
[17:00:28.171]                           for (restart in restarts) {
[17:00:28.171]                             name <- restart$name
[17:00:28.171]                             if (is.null(name)) 
[17:00:28.171]                               next
[17:00:28.171]                             if (!grepl(pattern, name)) 
[17:00:28.171]                               next
[17:00:28.171]                             invokeRestart(restart)
[17:00:28.171]                             muffled <- TRUE
[17:00:28.171]                             break
[17:00:28.171]                           }
[17:00:28.171]                         }
[17:00:28.171]                       }
[17:00:28.171]                       invisible(muffled)
[17:00:28.171]                     }
[17:00:28.171]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.171]                   }
[17:00:28.171]                 }
[17:00:28.171]             }
[17:00:28.171]         }))
[17:00:28.171]     }, error = function(ex) {
[17:00:28.171]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.171]                 ...future.rng), started = ...future.startTime, 
[17:00:28.171]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.171]             version = "1.8"), class = "FutureResult")
[17:00:28.171]     }, finally = {
[17:00:28.171]         if (!identical(...future.workdir, getwd())) 
[17:00:28.171]             setwd(...future.workdir)
[17:00:28.171]         {
[17:00:28.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.171]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.171]             }
[17:00:28.171]             base::options(...future.oldOptions)
[17:00:28.171]             if (.Platform$OS.type == "windows") {
[17:00:28.171]                 old_names <- names(...future.oldEnvVars)
[17:00:28.171]                 envs <- base::Sys.getenv()
[17:00:28.171]                 names <- names(envs)
[17:00:28.171]                 common <- intersect(names, old_names)
[17:00:28.171]                 added <- setdiff(names, old_names)
[17:00:28.171]                 removed <- setdiff(old_names, names)
[17:00:28.171]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.171]                   envs[common]]
[17:00:28.171]                 NAMES <- toupper(changed)
[17:00:28.171]                 args <- list()
[17:00:28.171]                 for (kk in seq_along(NAMES)) {
[17:00:28.171]                   name <- changed[[kk]]
[17:00:28.171]                   NAME <- NAMES[[kk]]
[17:00:28.171]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.171]                     next
[17:00:28.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.171]                 }
[17:00:28.171]                 NAMES <- toupper(added)
[17:00:28.171]                 for (kk in seq_along(NAMES)) {
[17:00:28.171]                   name <- added[[kk]]
[17:00:28.171]                   NAME <- NAMES[[kk]]
[17:00:28.171]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.171]                     next
[17:00:28.171]                   args[[name]] <- ""
[17:00:28.171]                 }
[17:00:28.171]                 NAMES <- toupper(removed)
[17:00:28.171]                 for (kk in seq_along(NAMES)) {
[17:00:28.171]                   name <- removed[[kk]]
[17:00:28.171]                   NAME <- NAMES[[kk]]
[17:00:28.171]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.171]                     next
[17:00:28.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.171]                 }
[17:00:28.171]                 if (length(args) > 0) 
[17:00:28.171]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.171]             }
[17:00:28.171]             else {
[17:00:28.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.171]             }
[17:00:28.171]             {
[17:00:28.171]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.171]                   0L) {
[17:00:28.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.171]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.171]                   base::options(opts)
[17:00:28.171]                 }
[17:00:28.171]                 {
[17:00:28.171]                   {
[17:00:28.171]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.171]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.171]                     2054632538L), envir = base::globalenv(), 
[17:00:28.171]                       inherits = FALSE)
[17:00:28.171]                     NULL
[17:00:28.171]                   }
[17:00:28.171]                   options(future.plan = NULL)
[17:00:28.171]                   if (is.na(NA_character_)) 
[17:00:28.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.171]                     .init = FALSE)
[17:00:28.171]                 }
[17:00:28.171]             }
[17:00:28.171]         }
[17:00:28.171]     })
[17:00:28.171]     if (TRUE) {
[17:00:28.171]         base::sink(type = "output", split = FALSE)
[17:00:28.171]         if (TRUE) {
[17:00:28.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.171]         }
[17:00:28.171]         else {
[17:00:28.171]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.171]         }
[17:00:28.171]         base::close(...future.stdout)
[17:00:28.171]         ...future.stdout <- NULL
[17:00:28.171]     }
[17:00:28.171]     ...future.result$conditions <- ...future.conditions
[17:00:28.171]     ...future.result$finished <- base::Sys.time()
[17:00:28.171]     ...future.result
[17:00:28.171] }
[17:00:28.173] assign_globals() ...
[17:00:28.173] List of 5
[17:00:28.173]  $ ...future.FUN            :function (x, y)  
[17:00:28.173]  $ MoreArgs                 : list()
[17:00:28.173]  $ ...future.elements_ii    :List of 2
[17:00:28.173]   ..$ :List of 3
[17:00:28.173]   .. ..$ a: num 1
[17:00:28.173]   .. ..$ b: num 2
[17:00:28.173]   .. ..$ c: num 3
[17:00:28.173]   ..$ :List of 3
[17:00:28.173]   .. ..$ A: num 10
[17:00:28.173]   .. ..$ B: num 0
[17:00:28.173]   .. ..$ C: num -10
[17:00:28.173]  $ ...future.seeds_ii       : NULL
[17:00:28.173]  $ ...future.globals.maxSize: NULL
[17:00:28.173]  - attr(*, "where")=List of 5
[17:00:28.173]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.173]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.173]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.173]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.173]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.173]  - attr(*, "resolved")= logi FALSE
[17:00:28.173]  - attr(*, "total_size")= num 2312
[17:00:28.173]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.173]  - attr(*, "already-done")= logi TRUE
[17:00:28.181] - reassign environment for ‘...future.FUN’
[17:00:28.181] - copied ‘...future.FUN’ to environment
[17:00:28.182] - copied ‘MoreArgs’ to environment
[17:00:28.182] - copied ‘...future.elements_ii’ to environment
[17:00:28.182] - copied ‘...future.seeds_ii’ to environment
[17:00:28.182] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.182] assign_globals() ... done
[17:00:28.182] plan(): Setting new future strategy stack:
[17:00:28.182] List of future strategies:
[17:00:28.182] 1. sequential:
[17:00:28.182]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.182]    - tweaked: FALSE
[17:00:28.182]    - call: NULL
[17:00:28.183] plan(): nbrOfWorkers() = 1
[17:00:28.184] plan(): Setting new future strategy stack:
[17:00:28.184] List of future strategies:
[17:00:28.184] 1. sequential:
[17:00:28.184]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.184]    - tweaked: FALSE
[17:00:28.184]    - call: plan(strategy)
[17:00:28.184] plan(): nbrOfWorkers() = 1
[17:00:28.184] SequentialFuture started (and completed)
[17:00:28.184] - Launch lazy future ... done
[17:00:28.185] run() for ‘SequentialFuture’ ... done
[17:00:28.185] Created future:
[17:00:28.185] SequentialFuture:
[17:00:28.185] Label: ‘future_.mapply-1’
[17:00:28.185] Expression:
[17:00:28.185] {
[17:00:28.185]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.185]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.185]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.185]         on.exit(options(oopts), add = TRUE)
[17:00:28.185]     }
[17:00:28.185]     {
[17:00:28.185]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.185]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.185]         do.call(mapply, args = args)
[17:00:28.185]     }
[17:00:28.185] }
[17:00:28.185] Lazy evaluation: FALSE
[17:00:28.185] Asynchronous evaluation: FALSE
[17:00:28.185] Local evaluation: TRUE
[17:00:28.185] Environment: R_GlobalEnv
[17:00:28.185] Capture standard output: TRUE
[17:00:28.185] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.185] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.185] Packages: <none>
[17:00:28.185] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.185] Resolved: TRUE
[17:00:28.185] Value: 200 bytes of class ‘list’
[17:00:28.185] Early signaling: FALSE
[17:00:28.185] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.185] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.186] Chunk #1 of 1 ... DONE
[17:00:28.186] Launching 1 futures (chunks) ... DONE
[17:00:28.186] Resolving 1 futures (chunks) ...
[17:00:28.186] resolve() on list ...
[17:00:28.186]  recursive: 0
[17:00:28.186]  length: 1
[17:00:28.186] 
[17:00:28.186] resolved() for ‘SequentialFuture’ ...
[17:00:28.186] - state: ‘finished’
[17:00:28.186] - run: TRUE
[17:00:28.187] - result: ‘FutureResult’
[17:00:28.187] resolved() for ‘SequentialFuture’ ... done
[17:00:28.187] Future #1
[17:00:28.187] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.187] - nx: 1
[17:00:28.187] - relay: TRUE
[17:00:28.187] - stdout: TRUE
[17:00:28.187] - signal: TRUE
[17:00:28.187] - resignal: FALSE
[17:00:28.187] - force: TRUE
[17:00:28.187] - relayed: [n=1] FALSE
[17:00:28.188] - queued futures: [n=1] FALSE
[17:00:28.188]  - until=1
[17:00:28.188]  - relaying element #1
[17:00:28.188] - relayed: [n=1] TRUE
[17:00:28.188] - queued futures: [n=1] TRUE
[17:00:28.188] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.188]  length: 0 (resolved future 1)
[17:00:28.188] Relaying remaining futures
[17:00:28.188] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.188] - nx: 1
[17:00:28.189] - relay: TRUE
[17:00:28.189] - stdout: TRUE
[17:00:28.189] - signal: TRUE
[17:00:28.189] - resignal: FALSE
[17:00:28.189] - force: TRUE
[17:00:28.189] - relayed: [n=1] TRUE
[17:00:28.189] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.189] - relayed: [n=1] TRUE
[17:00:28.189] - queued futures: [n=1] TRUE
[17:00:28.189] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.189] resolve() on list ... DONE
[17:00:28.190]  - Number of value chunks collected: 1
[17:00:28.190] Resolving 1 futures (chunks) ... DONE
[17:00:28.190] Reducing values from 1 chunks ...
[17:00:28.190]  - Number of values collected after concatenation: 3
[17:00:28.190]  - Number of values expected: 3
[17:00:28.190] Reducing values from 1 chunks ... DONE
[17:00:28.190] future_mapply() ... DONE
[17:00:28.190] future_mapply() ...
[17:00:28.192] Number of chunks: 5
[17:00:28.192] getGlobalsAndPackagesXApply() ...
[17:00:28.192]  - future.globals: TRUE
[17:00:28.192] getGlobalsAndPackages() ...
[17:00:28.193] Searching for globals...
[17:00:28.194] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:28.194] Searching for globals ... DONE
[17:00:28.194] Resolving globals: FALSE
[17:00:28.194] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:28.195] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:28.195] - globals: [1] ‘FUN’
[17:00:28.195] 
[17:00:28.195] getGlobalsAndPackages() ... DONE
[17:00:28.195]  - globals found/used: [n=1] ‘FUN’
[17:00:28.195]  - needed namespaces: [n=0] 
[17:00:28.195] Finding globals ... DONE
[17:00:28.195] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.196] List of 2
[17:00:28.196]  $ ...future.FUN:function (C, k)  
[17:00:28.196]  $ MoreArgs     : NULL
[17:00:28.196]  - attr(*, "where")=List of 2
[17:00:28.196]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.196]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.196]  - attr(*, "resolved")= logi FALSE
[17:00:28.196]  - attr(*, "total_size")= num NA
[17:00:28.198] Packages to be attached in all futures: [n=0] 
[17:00:28.198] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.198] Number of futures (= number of chunks): 5
[17:00:28.198] Launching 5 futures (chunks) ...
[17:00:28.198] Chunk #1 of 5 ...
[17:00:28.198]  - Finding globals in '...' for chunk #1 ...
[17:00:28.199] getGlobalsAndPackages() ...
[17:00:28.199] Searching for globals...
[17:00:28.201] 
[17:00:28.201] Searching for globals ... DONE
[17:00:28.201] - globals: [0] <none>
[17:00:28.201] getGlobalsAndPackages() ... DONE
[17:00:28.201]    + additional globals found: [n=0] 
[17:00:28.201]    + additional namespaces needed: [n=0] 
[17:00:28.201]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.201]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:28.202]  - seeds: <none>
[17:00:28.202]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.202] getGlobalsAndPackages() ...
[17:00:28.202] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.202] Resolving globals: FALSE
[17:00:28.202] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:28.203] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.203] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.203] 
[17:00:28.203] getGlobalsAndPackages() ... DONE
[17:00:28.204] run() for ‘Future’ ...
[17:00:28.204] - state: ‘created’
[17:00:28.204] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.204] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.204]   - Field: ‘label’
[17:00:28.204]   - Field: ‘local’
[17:00:28.205]   - Field: ‘owner’
[17:00:28.205]   - Field: ‘envir’
[17:00:28.205]   - Field: ‘packages’
[17:00:28.205]   - Field: ‘gc’
[17:00:28.205]   - Field: ‘conditions’
[17:00:28.205]   - Field: ‘expr’
[17:00:28.205]   - Field: ‘uuid’
[17:00:28.205]   - Field: ‘seed’
[17:00:28.205]   - Field: ‘version’
[17:00:28.205]   - Field: ‘result’
[17:00:28.205]   - Field: ‘asynchronous’
[17:00:28.206]   - Field: ‘calls’
[17:00:28.206]   - Field: ‘globals’
[17:00:28.206]   - Field: ‘stdout’
[17:00:28.206]   - Field: ‘earlySignal’
[17:00:28.206]   - Field: ‘lazy’
[17:00:28.206]   - Field: ‘state’
[17:00:28.206] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.206] - Launch lazy future ...
[17:00:28.206] Packages needed by the future expression (n = 0): <none>
[17:00:28.206] Packages needed by future strategies (n = 0): <none>
[17:00:28.207] {
[17:00:28.207]     {
[17:00:28.207]         {
[17:00:28.207]             ...future.startTime <- base::Sys.time()
[17:00:28.207]             {
[17:00:28.207]                 {
[17:00:28.207]                   {
[17:00:28.207]                     base::local({
[17:00:28.207]                       has_future <- base::requireNamespace("future", 
[17:00:28.207]                         quietly = TRUE)
[17:00:28.207]                       if (has_future) {
[17:00:28.207]                         ns <- base::getNamespace("future")
[17:00:28.207]                         version <- ns[[".package"]][["version"]]
[17:00:28.207]                         if (is.null(version)) 
[17:00:28.207]                           version <- utils::packageVersion("future")
[17:00:28.207]                       }
[17:00:28.207]                       else {
[17:00:28.207]                         version <- NULL
[17:00:28.207]                       }
[17:00:28.207]                       if (!has_future || version < "1.8.0") {
[17:00:28.207]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.207]                           "", base::R.version$version.string), 
[17:00:28.207]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.207]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.207]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.207]                             "release", "version")], collapse = " "), 
[17:00:28.207]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.207]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.207]                           info)
[17:00:28.207]                         info <- base::paste(info, collapse = "; ")
[17:00:28.207]                         if (!has_future) {
[17:00:28.207]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.207]                             info)
[17:00:28.207]                         }
[17:00:28.207]                         else {
[17:00:28.207]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.207]                             info, version)
[17:00:28.207]                         }
[17:00:28.207]                         base::stop(msg)
[17:00:28.207]                       }
[17:00:28.207]                     })
[17:00:28.207]                   }
[17:00:28.207]                   ...future.strategy.old <- future::plan("list")
[17:00:28.207]                   options(future.plan = NULL)
[17:00:28.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.207]                 }
[17:00:28.207]                 ...future.workdir <- getwd()
[17:00:28.207]             }
[17:00:28.207]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.207]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.207]         }
[17:00:28.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.207]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:28.207]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.207]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.207]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.207]             base::names(...future.oldOptions))
[17:00:28.207]     }
[17:00:28.207]     if (FALSE) {
[17:00:28.207]     }
[17:00:28.207]     else {
[17:00:28.207]         if (TRUE) {
[17:00:28.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.207]                 open = "w")
[17:00:28.207]         }
[17:00:28.207]         else {
[17:00:28.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.207]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.207]         }
[17:00:28.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.207]             base::sink(type = "output", split = FALSE)
[17:00:28.207]             base::close(...future.stdout)
[17:00:28.207]         }, add = TRUE)
[17:00:28.207]     }
[17:00:28.207]     ...future.frame <- base::sys.nframe()
[17:00:28.207]     ...future.conditions <- base::list()
[17:00:28.207]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.207]     if (FALSE) {
[17:00:28.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.207]     }
[17:00:28.207]     ...future.result <- base::tryCatch({
[17:00:28.207]         base::withCallingHandlers({
[17:00:28.207]             ...future.value <- base::withVisible(base::local({
[17:00:28.207]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.207]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.207]                   ...future.globals.maxSize)) {
[17:00:28.207]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.207]                   on.exit(options(oopts), add = TRUE)
[17:00:28.207]                 }
[17:00:28.207]                 {
[17:00:28.207]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.207]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.207]                     USE.NAMES = FALSE)
[17:00:28.207]                   do.call(mapply, args = args)
[17:00:28.207]                 }
[17:00:28.207]             }))
[17:00:28.207]             future::FutureResult(value = ...future.value$value, 
[17:00:28.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.207]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.207]                     ...future.globalenv.names))
[17:00:28.207]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.207]         }, condition = base::local({
[17:00:28.207]             c <- base::c
[17:00:28.207]             inherits <- base::inherits
[17:00:28.207]             invokeRestart <- base::invokeRestart
[17:00:28.207]             length <- base::length
[17:00:28.207]             list <- base::list
[17:00:28.207]             seq.int <- base::seq.int
[17:00:28.207]             signalCondition <- base::signalCondition
[17:00:28.207]             sys.calls <- base::sys.calls
[17:00:28.207]             `[[` <- base::`[[`
[17:00:28.207]             `+` <- base::`+`
[17:00:28.207]             `<<-` <- base::`<<-`
[17:00:28.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.207]                   3L)]
[17:00:28.207]             }
[17:00:28.207]             function(cond) {
[17:00:28.207]                 is_error <- inherits(cond, "error")
[17:00:28.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.207]                   NULL)
[17:00:28.207]                 if (is_error) {
[17:00:28.207]                   sessionInformation <- function() {
[17:00:28.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.207]                       search = base::search(), system = base::Sys.info())
[17:00:28.207]                   }
[17:00:28.207]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.207]                     cond$call), session = sessionInformation(), 
[17:00:28.207]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.207]                   signalCondition(cond)
[17:00:28.207]                 }
[17:00:28.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.207]                 "immediateCondition"))) {
[17:00:28.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.207]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.207]                   if (TRUE && !signal) {
[17:00:28.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.207]                     {
[17:00:28.207]                       inherits <- base::inherits
[17:00:28.207]                       invokeRestart <- base::invokeRestart
[17:00:28.207]                       is.null <- base::is.null
[17:00:28.207]                       muffled <- FALSE
[17:00:28.207]                       if (inherits(cond, "message")) {
[17:00:28.207]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.207]                         if (muffled) 
[17:00:28.207]                           invokeRestart("muffleMessage")
[17:00:28.207]                       }
[17:00:28.207]                       else if (inherits(cond, "warning")) {
[17:00:28.207]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.207]                         if (muffled) 
[17:00:28.207]                           invokeRestart("muffleWarning")
[17:00:28.207]                       }
[17:00:28.207]                       else if (inherits(cond, "condition")) {
[17:00:28.207]                         if (!is.null(pattern)) {
[17:00:28.207]                           computeRestarts <- base::computeRestarts
[17:00:28.207]                           grepl <- base::grepl
[17:00:28.207]                           restarts <- computeRestarts(cond)
[17:00:28.207]                           for (restart in restarts) {
[17:00:28.207]                             name <- restart$name
[17:00:28.207]                             if (is.null(name)) 
[17:00:28.207]                               next
[17:00:28.207]                             if (!grepl(pattern, name)) 
[17:00:28.207]                               next
[17:00:28.207]                             invokeRestart(restart)
[17:00:28.207]                             muffled <- TRUE
[17:00:28.207]                             break
[17:00:28.207]                           }
[17:00:28.207]                         }
[17:00:28.207]                       }
[17:00:28.207]                       invisible(muffled)
[17:00:28.207]                     }
[17:00:28.207]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.207]                   }
[17:00:28.207]                 }
[17:00:28.207]                 else {
[17:00:28.207]                   if (TRUE) {
[17:00:28.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.207]                     {
[17:00:28.207]                       inherits <- base::inherits
[17:00:28.207]                       invokeRestart <- base::invokeRestart
[17:00:28.207]                       is.null <- base::is.null
[17:00:28.207]                       muffled <- FALSE
[17:00:28.207]                       if (inherits(cond, "message")) {
[17:00:28.207]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.207]                         if (muffled) 
[17:00:28.207]                           invokeRestart("muffleMessage")
[17:00:28.207]                       }
[17:00:28.207]                       else if (inherits(cond, "warning")) {
[17:00:28.207]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.207]                         if (muffled) 
[17:00:28.207]                           invokeRestart("muffleWarning")
[17:00:28.207]                       }
[17:00:28.207]                       else if (inherits(cond, "condition")) {
[17:00:28.207]                         if (!is.null(pattern)) {
[17:00:28.207]                           computeRestarts <- base::computeRestarts
[17:00:28.207]                           grepl <- base::grepl
[17:00:28.207]                           restarts <- computeRestarts(cond)
[17:00:28.207]                           for (restart in restarts) {
[17:00:28.207]                             name <- restart$name
[17:00:28.207]                             if (is.null(name)) 
[17:00:28.207]                               next
[17:00:28.207]                             if (!grepl(pattern, name)) 
[17:00:28.207]                               next
[17:00:28.207]                             invokeRestart(restart)
[17:00:28.207]                             muffled <- TRUE
[17:00:28.207]                             break
[17:00:28.207]                           }
[17:00:28.207]                         }
[17:00:28.207]                       }
[17:00:28.207]                       invisible(muffled)
[17:00:28.207]                     }
[17:00:28.207]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.207]                   }
[17:00:28.207]                 }
[17:00:28.207]             }
[17:00:28.207]         }))
[17:00:28.207]     }, error = function(ex) {
[17:00:28.207]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.207]                 ...future.rng), started = ...future.startTime, 
[17:00:28.207]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.207]             version = "1.8"), class = "FutureResult")
[17:00:28.207]     }, finally = {
[17:00:28.207]         if (!identical(...future.workdir, getwd())) 
[17:00:28.207]             setwd(...future.workdir)
[17:00:28.207]         {
[17:00:28.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.207]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.207]             }
[17:00:28.207]             base::options(...future.oldOptions)
[17:00:28.207]             if (.Platform$OS.type == "windows") {
[17:00:28.207]                 old_names <- names(...future.oldEnvVars)
[17:00:28.207]                 envs <- base::Sys.getenv()
[17:00:28.207]                 names <- names(envs)
[17:00:28.207]                 common <- intersect(names, old_names)
[17:00:28.207]                 added <- setdiff(names, old_names)
[17:00:28.207]                 removed <- setdiff(old_names, names)
[17:00:28.207]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.207]                   envs[common]]
[17:00:28.207]                 NAMES <- toupper(changed)
[17:00:28.207]                 args <- list()
[17:00:28.207]                 for (kk in seq_along(NAMES)) {
[17:00:28.207]                   name <- changed[[kk]]
[17:00:28.207]                   NAME <- NAMES[[kk]]
[17:00:28.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.207]                     next
[17:00:28.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.207]                 }
[17:00:28.207]                 NAMES <- toupper(added)
[17:00:28.207]                 for (kk in seq_along(NAMES)) {
[17:00:28.207]                   name <- added[[kk]]
[17:00:28.207]                   NAME <- NAMES[[kk]]
[17:00:28.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.207]                     next
[17:00:28.207]                   args[[name]] <- ""
[17:00:28.207]                 }
[17:00:28.207]                 NAMES <- toupper(removed)
[17:00:28.207]                 for (kk in seq_along(NAMES)) {
[17:00:28.207]                   name <- removed[[kk]]
[17:00:28.207]                   NAME <- NAMES[[kk]]
[17:00:28.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.207]                     next
[17:00:28.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.207]                 }
[17:00:28.207]                 if (length(args) > 0) 
[17:00:28.207]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.207]             }
[17:00:28.207]             else {
[17:00:28.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.207]             }
[17:00:28.207]             {
[17:00:28.207]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.207]                   0L) {
[17:00:28.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.207]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.207]                   base::options(opts)
[17:00:28.207]                 }
[17:00:28.207]                 {
[17:00:28.207]                   {
[17:00:28.207]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.207]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.207]                     2054632538L), envir = base::globalenv(), 
[17:00:28.207]                       inherits = FALSE)
[17:00:28.207]                     NULL
[17:00:28.207]                   }
[17:00:28.207]                   options(future.plan = NULL)
[17:00:28.207]                   if (is.na(NA_character_)) 
[17:00:28.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.207]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.207]                     .init = FALSE)
[17:00:28.207]                 }
[17:00:28.207]             }
[17:00:28.207]         }
[17:00:28.207]     })
[17:00:28.207]     if (TRUE) {
[17:00:28.207]         base::sink(type = "output", split = FALSE)
[17:00:28.207]         if (TRUE) {
[17:00:28.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.207]         }
[17:00:28.207]         else {
[17:00:28.207]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.207]         }
[17:00:28.207]         base::close(...future.stdout)
[17:00:28.207]         ...future.stdout <- NULL
[17:00:28.207]     }
[17:00:28.207]     ...future.result$conditions <- ...future.conditions
[17:00:28.207]     ...future.result$finished <- base::Sys.time()
[17:00:28.207]     ...future.result
[17:00:28.207] }
[17:00:28.209] assign_globals() ...
[17:00:28.209] List of 5
[17:00:28.209]  $ ...future.FUN            :function (C, k)  
[17:00:28.209]  $ MoreArgs                 : NULL
[17:00:28.209]  $ ...future.elements_ii    :List of 2
[17:00:28.209]   ..$ :List of 1
[17:00:28.209]   .. ..$ : chr "A"
[17:00:28.209]   ..$ :List of 1
[17:00:28.209]   .. ..$ : int 5
[17:00:28.209]  $ ...future.seeds_ii       : NULL
[17:00:28.209]  $ ...future.globals.maxSize: NULL
[17:00:28.209]  - attr(*, "where")=List of 5
[17:00:28.209]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.209]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.209]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.209]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.209]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.209]  - attr(*, "resolved")= logi FALSE
[17:00:28.209]  - attr(*, "total_size")= num 3488
[17:00:28.209]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.209]  - attr(*, "already-done")= logi TRUE
[17:00:28.214] - reassign environment for ‘...future.FUN’
[17:00:28.214] - copied ‘...future.FUN’ to environment
[17:00:28.214] - copied ‘MoreArgs’ to environment
[17:00:28.214] - copied ‘...future.elements_ii’ to environment
[17:00:28.214] - copied ‘...future.seeds_ii’ to environment
[17:00:28.214] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.214] assign_globals() ... done
[17:00:28.215] plan(): Setting new future strategy stack:
[17:00:28.215] List of future strategies:
[17:00:28.215] 1. sequential:
[17:00:28.215]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.215]    - tweaked: FALSE
[17:00:28.215]    - call: NULL
[17:00:28.215] plan(): nbrOfWorkers() = 1
[17:00:28.216] plan(): Setting new future strategy stack:
[17:00:28.216] List of future strategies:
[17:00:28.216] 1. sequential:
[17:00:28.216]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.216]    - tweaked: FALSE
[17:00:28.216]    - call: plan(strategy)
[17:00:28.216] plan(): nbrOfWorkers() = 1
[17:00:28.217] SequentialFuture started (and completed)
[17:00:28.217] - Launch lazy future ... done
[17:00:28.217] run() for ‘SequentialFuture’ ... done
[17:00:28.217] Created future:
[17:00:28.217] SequentialFuture:
[17:00:28.217] Label: ‘future_mapply-1’
[17:00:28.217] Expression:
[17:00:28.217] {
[17:00:28.217]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.217]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.217]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.217]         on.exit(options(oopts), add = TRUE)
[17:00:28.217]     }
[17:00:28.217]     {
[17:00:28.217]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.217]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.217]         do.call(mapply, args = args)
[17:00:28.217]     }
[17:00:28.217] }
[17:00:28.217] Lazy evaluation: FALSE
[17:00:28.217] Asynchronous evaluation: FALSE
[17:00:28.217] Local evaluation: TRUE
[17:00:28.217] Environment: R_GlobalEnv
[17:00:28.217] Capture standard output: TRUE
[17:00:28.217] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.217] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.217] Packages: <none>
[17:00:28.217] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.217] Resolved: TRUE
[17:00:28.217] Value: 112 bytes of class ‘list’
[17:00:28.217] Early signaling: FALSE
[17:00:28.217] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.217] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.218] Chunk #1 of 5 ... DONE
[17:00:28.218] Chunk #2 of 5 ...
[17:00:28.218]  - Finding globals in '...' for chunk #2 ...
[17:00:28.218] getGlobalsAndPackages() ...
[17:00:28.218] Searching for globals...
[17:00:28.219] 
[17:00:28.219] Searching for globals ... DONE
[17:00:28.219] - globals: [0] <none>
[17:00:28.219] getGlobalsAndPackages() ... DONE
[17:00:28.219]    + additional globals found: [n=0] 
[17:00:28.219]    + additional namespaces needed: [n=0] 
[17:00:28.219]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:28.219]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:28.220]  - seeds: <none>
[17:00:28.220]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.220] getGlobalsAndPackages() ...
[17:00:28.220] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.220] Resolving globals: FALSE
[17:00:28.220] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:28.221] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.221] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.221] 
[17:00:28.221] getGlobalsAndPackages() ... DONE
[17:00:28.221] run() for ‘Future’ ...
[17:00:28.222] - state: ‘created’
[17:00:28.222] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.222] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.222] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.222]   - Field: ‘label’
[17:00:28.222]   - Field: ‘local’
[17:00:28.222]   - Field: ‘owner’
[17:00:28.222]   - Field: ‘envir’
[17:00:28.223]   - Field: ‘packages’
[17:00:28.223]   - Field: ‘gc’
[17:00:28.223]   - Field: ‘conditions’
[17:00:28.223]   - Field: ‘expr’
[17:00:28.223]   - Field: ‘uuid’
[17:00:28.223]   - Field: ‘seed’
[17:00:28.223]   - Field: ‘version’
[17:00:28.223]   - Field: ‘result’
[17:00:28.223]   - Field: ‘asynchronous’
[17:00:28.223]   - Field: ‘calls’
[17:00:28.224]   - Field: ‘globals’
[17:00:28.224]   - Field: ‘stdout’
[17:00:28.224]   - Field: ‘earlySignal’
[17:00:28.224]   - Field: ‘lazy’
[17:00:28.224]   - Field: ‘state’
[17:00:28.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.224] - Launch lazy future ...
[17:00:28.224] Packages needed by the future expression (n = 0): <none>
[17:00:28.224] Packages needed by future strategies (n = 0): <none>
[17:00:28.225] {
[17:00:28.225]     {
[17:00:28.225]         {
[17:00:28.225]             ...future.startTime <- base::Sys.time()
[17:00:28.225]             {
[17:00:28.225]                 {
[17:00:28.225]                   {
[17:00:28.225]                     base::local({
[17:00:28.225]                       has_future <- base::requireNamespace("future", 
[17:00:28.225]                         quietly = TRUE)
[17:00:28.225]                       if (has_future) {
[17:00:28.225]                         ns <- base::getNamespace("future")
[17:00:28.225]                         version <- ns[[".package"]][["version"]]
[17:00:28.225]                         if (is.null(version)) 
[17:00:28.225]                           version <- utils::packageVersion("future")
[17:00:28.225]                       }
[17:00:28.225]                       else {
[17:00:28.225]                         version <- NULL
[17:00:28.225]                       }
[17:00:28.225]                       if (!has_future || version < "1.8.0") {
[17:00:28.225]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.225]                           "", base::R.version$version.string), 
[17:00:28.225]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.225]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.225]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.225]                             "release", "version")], collapse = " "), 
[17:00:28.225]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.225]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.225]                           info)
[17:00:28.225]                         info <- base::paste(info, collapse = "; ")
[17:00:28.225]                         if (!has_future) {
[17:00:28.225]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.225]                             info)
[17:00:28.225]                         }
[17:00:28.225]                         else {
[17:00:28.225]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.225]                             info, version)
[17:00:28.225]                         }
[17:00:28.225]                         base::stop(msg)
[17:00:28.225]                       }
[17:00:28.225]                     })
[17:00:28.225]                   }
[17:00:28.225]                   ...future.strategy.old <- future::plan("list")
[17:00:28.225]                   options(future.plan = NULL)
[17:00:28.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.225]                 }
[17:00:28.225]                 ...future.workdir <- getwd()
[17:00:28.225]             }
[17:00:28.225]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.225]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.225]         }
[17:00:28.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.225]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:28.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.225]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.225]             base::names(...future.oldOptions))
[17:00:28.225]     }
[17:00:28.225]     if (FALSE) {
[17:00:28.225]     }
[17:00:28.225]     else {
[17:00:28.225]         if (TRUE) {
[17:00:28.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.225]                 open = "w")
[17:00:28.225]         }
[17:00:28.225]         else {
[17:00:28.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.225]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.225]         }
[17:00:28.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.225]             base::sink(type = "output", split = FALSE)
[17:00:28.225]             base::close(...future.stdout)
[17:00:28.225]         }, add = TRUE)
[17:00:28.225]     }
[17:00:28.225]     ...future.frame <- base::sys.nframe()
[17:00:28.225]     ...future.conditions <- base::list()
[17:00:28.225]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.225]     if (FALSE) {
[17:00:28.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.225]     }
[17:00:28.225]     ...future.result <- base::tryCatch({
[17:00:28.225]         base::withCallingHandlers({
[17:00:28.225]             ...future.value <- base::withVisible(base::local({
[17:00:28.225]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.225]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.225]                   ...future.globals.maxSize)) {
[17:00:28.225]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.225]                   on.exit(options(oopts), add = TRUE)
[17:00:28.225]                 }
[17:00:28.225]                 {
[17:00:28.225]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.225]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.225]                     USE.NAMES = FALSE)
[17:00:28.225]                   do.call(mapply, args = args)
[17:00:28.225]                 }
[17:00:28.225]             }))
[17:00:28.225]             future::FutureResult(value = ...future.value$value, 
[17:00:28.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.225]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.225]                     ...future.globalenv.names))
[17:00:28.225]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.225]         }, condition = base::local({
[17:00:28.225]             c <- base::c
[17:00:28.225]             inherits <- base::inherits
[17:00:28.225]             invokeRestart <- base::invokeRestart
[17:00:28.225]             length <- base::length
[17:00:28.225]             list <- base::list
[17:00:28.225]             seq.int <- base::seq.int
[17:00:28.225]             signalCondition <- base::signalCondition
[17:00:28.225]             sys.calls <- base::sys.calls
[17:00:28.225]             `[[` <- base::`[[`
[17:00:28.225]             `+` <- base::`+`
[17:00:28.225]             `<<-` <- base::`<<-`
[17:00:28.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.225]                   3L)]
[17:00:28.225]             }
[17:00:28.225]             function(cond) {
[17:00:28.225]                 is_error <- inherits(cond, "error")
[17:00:28.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.225]                   NULL)
[17:00:28.225]                 if (is_error) {
[17:00:28.225]                   sessionInformation <- function() {
[17:00:28.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.225]                       search = base::search(), system = base::Sys.info())
[17:00:28.225]                   }
[17:00:28.225]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.225]                     cond$call), session = sessionInformation(), 
[17:00:28.225]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.225]                   signalCondition(cond)
[17:00:28.225]                 }
[17:00:28.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.225]                 "immediateCondition"))) {
[17:00:28.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.225]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.225]                   if (TRUE && !signal) {
[17:00:28.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.225]                     {
[17:00:28.225]                       inherits <- base::inherits
[17:00:28.225]                       invokeRestart <- base::invokeRestart
[17:00:28.225]                       is.null <- base::is.null
[17:00:28.225]                       muffled <- FALSE
[17:00:28.225]                       if (inherits(cond, "message")) {
[17:00:28.225]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.225]                         if (muffled) 
[17:00:28.225]                           invokeRestart("muffleMessage")
[17:00:28.225]                       }
[17:00:28.225]                       else if (inherits(cond, "warning")) {
[17:00:28.225]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.225]                         if (muffled) 
[17:00:28.225]                           invokeRestart("muffleWarning")
[17:00:28.225]                       }
[17:00:28.225]                       else if (inherits(cond, "condition")) {
[17:00:28.225]                         if (!is.null(pattern)) {
[17:00:28.225]                           computeRestarts <- base::computeRestarts
[17:00:28.225]                           grepl <- base::grepl
[17:00:28.225]                           restarts <- computeRestarts(cond)
[17:00:28.225]                           for (restart in restarts) {
[17:00:28.225]                             name <- restart$name
[17:00:28.225]                             if (is.null(name)) 
[17:00:28.225]                               next
[17:00:28.225]                             if (!grepl(pattern, name)) 
[17:00:28.225]                               next
[17:00:28.225]                             invokeRestart(restart)
[17:00:28.225]                             muffled <- TRUE
[17:00:28.225]                             break
[17:00:28.225]                           }
[17:00:28.225]                         }
[17:00:28.225]                       }
[17:00:28.225]                       invisible(muffled)
[17:00:28.225]                     }
[17:00:28.225]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.225]                   }
[17:00:28.225]                 }
[17:00:28.225]                 else {
[17:00:28.225]                   if (TRUE) {
[17:00:28.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.225]                     {
[17:00:28.225]                       inherits <- base::inherits
[17:00:28.225]                       invokeRestart <- base::invokeRestart
[17:00:28.225]                       is.null <- base::is.null
[17:00:28.225]                       muffled <- FALSE
[17:00:28.225]                       if (inherits(cond, "message")) {
[17:00:28.225]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.225]                         if (muffled) 
[17:00:28.225]                           invokeRestart("muffleMessage")
[17:00:28.225]                       }
[17:00:28.225]                       else if (inherits(cond, "warning")) {
[17:00:28.225]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.225]                         if (muffled) 
[17:00:28.225]                           invokeRestart("muffleWarning")
[17:00:28.225]                       }
[17:00:28.225]                       else if (inherits(cond, "condition")) {
[17:00:28.225]                         if (!is.null(pattern)) {
[17:00:28.225]                           computeRestarts <- base::computeRestarts
[17:00:28.225]                           grepl <- base::grepl
[17:00:28.225]                           restarts <- computeRestarts(cond)
[17:00:28.225]                           for (restart in restarts) {
[17:00:28.225]                             name <- restart$name
[17:00:28.225]                             if (is.null(name)) 
[17:00:28.225]                               next
[17:00:28.225]                             if (!grepl(pattern, name)) 
[17:00:28.225]                               next
[17:00:28.225]                             invokeRestart(restart)
[17:00:28.225]                             muffled <- TRUE
[17:00:28.225]                             break
[17:00:28.225]                           }
[17:00:28.225]                         }
[17:00:28.225]                       }
[17:00:28.225]                       invisible(muffled)
[17:00:28.225]                     }
[17:00:28.225]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.225]                   }
[17:00:28.225]                 }
[17:00:28.225]             }
[17:00:28.225]         }))
[17:00:28.225]     }, error = function(ex) {
[17:00:28.225]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.225]                 ...future.rng), started = ...future.startTime, 
[17:00:28.225]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.225]             version = "1.8"), class = "FutureResult")
[17:00:28.225]     }, finally = {
[17:00:28.225]         if (!identical(...future.workdir, getwd())) 
[17:00:28.225]             setwd(...future.workdir)
[17:00:28.225]         {
[17:00:28.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.225]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.225]             }
[17:00:28.225]             base::options(...future.oldOptions)
[17:00:28.225]             if (.Platform$OS.type == "windows") {
[17:00:28.225]                 old_names <- names(...future.oldEnvVars)
[17:00:28.225]                 envs <- base::Sys.getenv()
[17:00:28.225]                 names <- names(envs)
[17:00:28.225]                 common <- intersect(names, old_names)
[17:00:28.225]                 added <- setdiff(names, old_names)
[17:00:28.225]                 removed <- setdiff(old_names, names)
[17:00:28.225]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.225]                   envs[common]]
[17:00:28.225]                 NAMES <- toupper(changed)
[17:00:28.225]                 args <- list()
[17:00:28.225]                 for (kk in seq_along(NAMES)) {
[17:00:28.225]                   name <- changed[[kk]]
[17:00:28.225]                   NAME <- NAMES[[kk]]
[17:00:28.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.225]                     next
[17:00:28.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.225]                 }
[17:00:28.225]                 NAMES <- toupper(added)
[17:00:28.225]                 for (kk in seq_along(NAMES)) {
[17:00:28.225]                   name <- added[[kk]]
[17:00:28.225]                   NAME <- NAMES[[kk]]
[17:00:28.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.225]                     next
[17:00:28.225]                   args[[name]] <- ""
[17:00:28.225]                 }
[17:00:28.225]                 NAMES <- toupper(removed)
[17:00:28.225]                 for (kk in seq_along(NAMES)) {
[17:00:28.225]                   name <- removed[[kk]]
[17:00:28.225]                   NAME <- NAMES[[kk]]
[17:00:28.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.225]                     next
[17:00:28.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.225]                 }
[17:00:28.225]                 if (length(args) > 0) 
[17:00:28.225]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.225]             }
[17:00:28.225]             else {
[17:00:28.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.225]             }
[17:00:28.225]             {
[17:00:28.225]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.225]                   0L) {
[17:00:28.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.225]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.225]                   base::options(opts)
[17:00:28.225]                 }
[17:00:28.225]                 {
[17:00:28.225]                   {
[17:00:28.225]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.225]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.225]                     2054632538L), envir = base::globalenv(), 
[17:00:28.225]                       inherits = FALSE)
[17:00:28.225]                     NULL
[17:00:28.225]                   }
[17:00:28.225]                   options(future.plan = NULL)
[17:00:28.225]                   if (is.na(NA_character_)) 
[17:00:28.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.225]                     .init = FALSE)
[17:00:28.225]                 }
[17:00:28.225]             }
[17:00:28.225]         }
[17:00:28.225]     })
[17:00:28.225]     if (TRUE) {
[17:00:28.225]         base::sink(type = "output", split = FALSE)
[17:00:28.225]         if (TRUE) {
[17:00:28.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.225]         }
[17:00:28.225]         else {
[17:00:28.225]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.225]         }
[17:00:28.225]         base::close(...future.stdout)
[17:00:28.225]         ...future.stdout <- NULL
[17:00:28.225]     }
[17:00:28.225]     ...future.result$conditions <- ...future.conditions
[17:00:28.225]     ...future.result$finished <- base::Sys.time()
[17:00:28.225]     ...future.result
[17:00:28.225] }
[17:00:28.229] assign_globals() ...
[17:00:28.229] List of 5
[17:00:28.229]  $ ...future.FUN            :function (C, k)  
[17:00:28.229]  $ MoreArgs                 : NULL
[17:00:28.229]  $ ...future.elements_ii    :List of 2
[17:00:28.229]   ..$ :List of 1
[17:00:28.229]   .. ..$ : chr "B"
[17:00:28.229]   ..$ :List of 1
[17:00:28.229]   .. ..$ : int 4
[17:00:28.229]  $ ...future.seeds_ii       : NULL
[17:00:28.229]  $ ...future.globals.maxSize: NULL
[17:00:28.229]  - attr(*, "where")=List of 5
[17:00:28.229]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.229]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.229]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.229]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.229]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.229]  - attr(*, "resolved")= logi FALSE
[17:00:28.229]  - attr(*, "total_size")= num 3488
[17:00:28.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.229]  - attr(*, "already-done")= logi TRUE
[17:00:28.234] - reassign environment for ‘...future.FUN’
[17:00:28.234] - copied ‘...future.FUN’ to environment
[17:00:28.234] - copied ‘MoreArgs’ to environment
[17:00:28.234] - copied ‘...future.elements_ii’ to environment
[17:00:28.234] - copied ‘...future.seeds_ii’ to environment
[17:00:28.234] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.234] assign_globals() ... done
[17:00:28.235] plan(): Setting new future strategy stack:
[17:00:28.235] List of future strategies:
[17:00:28.235] 1. sequential:
[17:00:28.235]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.235]    - tweaked: FALSE
[17:00:28.235]    - call: NULL
[17:00:28.235] plan(): nbrOfWorkers() = 1
[17:00:28.236] plan(): Setting new future strategy stack:
[17:00:28.236] List of future strategies:
[17:00:28.236] 1. sequential:
[17:00:28.236]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.236]    - tweaked: FALSE
[17:00:28.236]    - call: plan(strategy)
[17:00:28.237] plan(): nbrOfWorkers() = 1
[17:00:28.237] SequentialFuture started (and completed)
[17:00:28.237] - Launch lazy future ... done
[17:00:28.237] run() for ‘SequentialFuture’ ... done
[17:00:28.237] Created future:
[17:00:28.237] SequentialFuture:
[17:00:28.237] Label: ‘future_mapply-2’
[17:00:28.237] Expression:
[17:00:28.237] {
[17:00:28.237]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.237]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.237]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.237]         on.exit(options(oopts), add = TRUE)
[17:00:28.237]     }
[17:00:28.237]     {
[17:00:28.237]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.237]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.237]         do.call(mapply, args = args)
[17:00:28.237]     }
[17:00:28.237] }
[17:00:28.237] Lazy evaluation: FALSE
[17:00:28.237] Asynchronous evaluation: FALSE
[17:00:28.237] Local evaluation: TRUE
[17:00:28.237] Environment: R_GlobalEnv
[17:00:28.237] Capture standard output: TRUE
[17:00:28.237] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.237] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.237] Packages: <none>
[17:00:28.237] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.237] Resolved: TRUE
[17:00:28.237] Value: 112 bytes of class ‘list’
[17:00:28.237] Early signaling: FALSE
[17:00:28.237] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.237] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.238] Chunk #2 of 5 ... DONE
[17:00:28.238] Chunk #3 of 5 ...
[17:00:28.238]  - Finding globals in '...' for chunk #3 ...
[17:00:28.238] getGlobalsAndPackages() ...
[17:00:28.238] Searching for globals...
[17:00:28.239] 
[17:00:28.239] Searching for globals ... DONE
[17:00:28.239] - globals: [0] <none>
[17:00:28.239] getGlobalsAndPackages() ... DONE
[17:00:28.239]    + additional globals found: [n=0] 
[17:00:28.239]    + additional namespaces needed: [n=0] 
[17:00:28.239]  - Finding globals in '...' for chunk #3 ... DONE
[17:00:28.239]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:28.239]  - seeds: <none>
[17:00:28.240]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.240] getGlobalsAndPackages() ...
[17:00:28.240] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.240] Resolving globals: FALSE
[17:00:28.240] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:28.241] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.241] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.241] 
[17:00:28.241] getGlobalsAndPackages() ... DONE
[17:00:28.241] run() for ‘Future’ ...
[17:00:28.241] - state: ‘created’
[17:00:28.242] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.242] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.242]   - Field: ‘label’
[17:00:28.242]   - Field: ‘local’
[17:00:28.242]   - Field: ‘owner’
[17:00:28.242]   - Field: ‘envir’
[17:00:28.242]   - Field: ‘packages’
[17:00:28.243]   - Field: ‘gc’
[17:00:28.243]   - Field: ‘conditions’
[17:00:28.243]   - Field: ‘expr’
[17:00:28.243]   - Field: ‘uuid’
[17:00:28.243]   - Field: ‘seed’
[17:00:28.243]   - Field: ‘version’
[17:00:28.243]   - Field: ‘result’
[17:00:28.243]   - Field: ‘asynchronous’
[17:00:28.243]   - Field: ‘calls’
[17:00:28.243]   - Field: ‘globals’
[17:00:28.243]   - Field: ‘stdout’
[17:00:28.244]   - Field: ‘earlySignal’
[17:00:28.244]   - Field: ‘lazy’
[17:00:28.244]   - Field: ‘state’
[17:00:28.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.244] - Launch lazy future ...
[17:00:28.244] Packages needed by the future expression (n = 0): <none>
[17:00:28.244] Packages needed by future strategies (n = 0): <none>
[17:00:28.245] {
[17:00:28.245]     {
[17:00:28.245]         {
[17:00:28.245]             ...future.startTime <- base::Sys.time()
[17:00:28.245]             {
[17:00:28.245]                 {
[17:00:28.245]                   {
[17:00:28.245]                     base::local({
[17:00:28.245]                       has_future <- base::requireNamespace("future", 
[17:00:28.245]                         quietly = TRUE)
[17:00:28.245]                       if (has_future) {
[17:00:28.245]                         ns <- base::getNamespace("future")
[17:00:28.245]                         version <- ns[[".package"]][["version"]]
[17:00:28.245]                         if (is.null(version)) 
[17:00:28.245]                           version <- utils::packageVersion("future")
[17:00:28.245]                       }
[17:00:28.245]                       else {
[17:00:28.245]                         version <- NULL
[17:00:28.245]                       }
[17:00:28.245]                       if (!has_future || version < "1.8.0") {
[17:00:28.245]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.245]                           "", base::R.version$version.string), 
[17:00:28.245]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.245]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.245]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.245]                             "release", "version")], collapse = " "), 
[17:00:28.245]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.245]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.245]                           info)
[17:00:28.245]                         info <- base::paste(info, collapse = "; ")
[17:00:28.245]                         if (!has_future) {
[17:00:28.245]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.245]                             info)
[17:00:28.245]                         }
[17:00:28.245]                         else {
[17:00:28.245]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.245]                             info, version)
[17:00:28.245]                         }
[17:00:28.245]                         base::stop(msg)
[17:00:28.245]                       }
[17:00:28.245]                     })
[17:00:28.245]                   }
[17:00:28.245]                   ...future.strategy.old <- future::plan("list")
[17:00:28.245]                   options(future.plan = NULL)
[17:00:28.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.245]                 }
[17:00:28.245]                 ...future.workdir <- getwd()
[17:00:28.245]             }
[17:00:28.245]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.245]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.245]         }
[17:00:28.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.245]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:28.245]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.245]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.245]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.245]             base::names(...future.oldOptions))
[17:00:28.245]     }
[17:00:28.245]     if (FALSE) {
[17:00:28.245]     }
[17:00:28.245]     else {
[17:00:28.245]         if (TRUE) {
[17:00:28.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.245]                 open = "w")
[17:00:28.245]         }
[17:00:28.245]         else {
[17:00:28.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.245]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.245]         }
[17:00:28.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.245]             base::sink(type = "output", split = FALSE)
[17:00:28.245]             base::close(...future.stdout)
[17:00:28.245]         }, add = TRUE)
[17:00:28.245]     }
[17:00:28.245]     ...future.frame <- base::sys.nframe()
[17:00:28.245]     ...future.conditions <- base::list()
[17:00:28.245]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.245]     if (FALSE) {
[17:00:28.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.245]     }
[17:00:28.245]     ...future.result <- base::tryCatch({
[17:00:28.245]         base::withCallingHandlers({
[17:00:28.245]             ...future.value <- base::withVisible(base::local({
[17:00:28.245]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.245]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.245]                   ...future.globals.maxSize)) {
[17:00:28.245]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.245]                   on.exit(options(oopts), add = TRUE)
[17:00:28.245]                 }
[17:00:28.245]                 {
[17:00:28.245]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.245]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.245]                     USE.NAMES = FALSE)
[17:00:28.245]                   do.call(mapply, args = args)
[17:00:28.245]                 }
[17:00:28.245]             }))
[17:00:28.245]             future::FutureResult(value = ...future.value$value, 
[17:00:28.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.245]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.245]                     ...future.globalenv.names))
[17:00:28.245]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.245]         }, condition = base::local({
[17:00:28.245]             c <- base::c
[17:00:28.245]             inherits <- base::inherits
[17:00:28.245]             invokeRestart <- base::invokeRestart
[17:00:28.245]             length <- base::length
[17:00:28.245]             list <- base::list
[17:00:28.245]             seq.int <- base::seq.int
[17:00:28.245]             signalCondition <- base::signalCondition
[17:00:28.245]             sys.calls <- base::sys.calls
[17:00:28.245]             `[[` <- base::`[[`
[17:00:28.245]             `+` <- base::`+`
[17:00:28.245]             `<<-` <- base::`<<-`
[17:00:28.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.245]                   3L)]
[17:00:28.245]             }
[17:00:28.245]             function(cond) {
[17:00:28.245]                 is_error <- inherits(cond, "error")
[17:00:28.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.245]                   NULL)
[17:00:28.245]                 if (is_error) {
[17:00:28.245]                   sessionInformation <- function() {
[17:00:28.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.245]                       search = base::search(), system = base::Sys.info())
[17:00:28.245]                   }
[17:00:28.245]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.245]                     cond$call), session = sessionInformation(), 
[17:00:28.245]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.245]                   signalCondition(cond)
[17:00:28.245]                 }
[17:00:28.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.245]                 "immediateCondition"))) {
[17:00:28.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.245]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.245]                   if (TRUE && !signal) {
[17:00:28.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.245]                     {
[17:00:28.245]                       inherits <- base::inherits
[17:00:28.245]                       invokeRestart <- base::invokeRestart
[17:00:28.245]                       is.null <- base::is.null
[17:00:28.245]                       muffled <- FALSE
[17:00:28.245]                       if (inherits(cond, "message")) {
[17:00:28.245]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.245]                         if (muffled) 
[17:00:28.245]                           invokeRestart("muffleMessage")
[17:00:28.245]                       }
[17:00:28.245]                       else if (inherits(cond, "warning")) {
[17:00:28.245]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.245]                         if (muffled) 
[17:00:28.245]                           invokeRestart("muffleWarning")
[17:00:28.245]                       }
[17:00:28.245]                       else if (inherits(cond, "condition")) {
[17:00:28.245]                         if (!is.null(pattern)) {
[17:00:28.245]                           computeRestarts <- base::computeRestarts
[17:00:28.245]                           grepl <- base::grepl
[17:00:28.245]                           restarts <- computeRestarts(cond)
[17:00:28.245]                           for (restart in restarts) {
[17:00:28.245]                             name <- restart$name
[17:00:28.245]                             if (is.null(name)) 
[17:00:28.245]                               next
[17:00:28.245]                             if (!grepl(pattern, name)) 
[17:00:28.245]                               next
[17:00:28.245]                             invokeRestart(restart)
[17:00:28.245]                             muffled <- TRUE
[17:00:28.245]                             break
[17:00:28.245]                           }
[17:00:28.245]                         }
[17:00:28.245]                       }
[17:00:28.245]                       invisible(muffled)
[17:00:28.245]                     }
[17:00:28.245]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.245]                   }
[17:00:28.245]                 }
[17:00:28.245]                 else {
[17:00:28.245]                   if (TRUE) {
[17:00:28.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.245]                     {
[17:00:28.245]                       inherits <- base::inherits
[17:00:28.245]                       invokeRestart <- base::invokeRestart
[17:00:28.245]                       is.null <- base::is.null
[17:00:28.245]                       muffled <- FALSE
[17:00:28.245]                       if (inherits(cond, "message")) {
[17:00:28.245]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.245]                         if (muffled) 
[17:00:28.245]                           invokeRestart("muffleMessage")
[17:00:28.245]                       }
[17:00:28.245]                       else if (inherits(cond, "warning")) {
[17:00:28.245]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.245]                         if (muffled) 
[17:00:28.245]                           invokeRestart("muffleWarning")
[17:00:28.245]                       }
[17:00:28.245]                       else if (inherits(cond, "condition")) {
[17:00:28.245]                         if (!is.null(pattern)) {
[17:00:28.245]                           computeRestarts <- base::computeRestarts
[17:00:28.245]                           grepl <- base::grepl
[17:00:28.245]                           restarts <- computeRestarts(cond)
[17:00:28.245]                           for (restart in restarts) {
[17:00:28.245]                             name <- restart$name
[17:00:28.245]                             if (is.null(name)) 
[17:00:28.245]                               next
[17:00:28.245]                             if (!grepl(pattern, name)) 
[17:00:28.245]                               next
[17:00:28.245]                             invokeRestart(restart)
[17:00:28.245]                             muffled <- TRUE
[17:00:28.245]                             break
[17:00:28.245]                           }
[17:00:28.245]                         }
[17:00:28.245]                       }
[17:00:28.245]                       invisible(muffled)
[17:00:28.245]                     }
[17:00:28.245]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.245]                   }
[17:00:28.245]                 }
[17:00:28.245]             }
[17:00:28.245]         }))
[17:00:28.245]     }, error = function(ex) {
[17:00:28.245]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.245]                 ...future.rng), started = ...future.startTime, 
[17:00:28.245]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.245]             version = "1.8"), class = "FutureResult")
[17:00:28.245]     }, finally = {
[17:00:28.245]         if (!identical(...future.workdir, getwd())) 
[17:00:28.245]             setwd(...future.workdir)
[17:00:28.245]         {
[17:00:28.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.245]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.245]             }
[17:00:28.245]             base::options(...future.oldOptions)
[17:00:28.245]             if (.Platform$OS.type == "windows") {
[17:00:28.245]                 old_names <- names(...future.oldEnvVars)
[17:00:28.245]                 envs <- base::Sys.getenv()
[17:00:28.245]                 names <- names(envs)
[17:00:28.245]                 common <- intersect(names, old_names)
[17:00:28.245]                 added <- setdiff(names, old_names)
[17:00:28.245]                 removed <- setdiff(old_names, names)
[17:00:28.245]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.245]                   envs[common]]
[17:00:28.245]                 NAMES <- toupper(changed)
[17:00:28.245]                 args <- list()
[17:00:28.245]                 for (kk in seq_along(NAMES)) {
[17:00:28.245]                   name <- changed[[kk]]
[17:00:28.245]                   NAME <- NAMES[[kk]]
[17:00:28.245]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.245]                     next
[17:00:28.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.245]                 }
[17:00:28.245]                 NAMES <- toupper(added)
[17:00:28.245]                 for (kk in seq_along(NAMES)) {
[17:00:28.245]                   name <- added[[kk]]
[17:00:28.245]                   NAME <- NAMES[[kk]]
[17:00:28.245]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.245]                     next
[17:00:28.245]                   args[[name]] <- ""
[17:00:28.245]                 }
[17:00:28.245]                 NAMES <- toupper(removed)
[17:00:28.245]                 for (kk in seq_along(NAMES)) {
[17:00:28.245]                   name <- removed[[kk]]
[17:00:28.245]                   NAME <- NAMES[[kk]]
[17:00:28.245]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.245]                     next
[17:00:28.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.245]                 }
[17:00:28.245]                 if (length(args) > 0) 
[17:00:28.245]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.245]             }
[17:00:28.245]             else {
[17:00:28.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.245]             }
[17:00:28.245]             {
[17:00:28.245]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.245]                   0L) {
[17:00:28.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.245]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.245]                   base::options(opts)
[17:00:28.245]                 }
[17:00:28.245]                 {
[17:00:28.245]                   {
[17:00:28.245]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.245]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.245]                     2054632538L), envir = base::globalenv(), 
[17:00:28.245]                       inherits = FALSE)
[17:00:28.245]                     NULL
[17:00:28.245]                   }
[17:00:28.245]                   options(future.plan = NULL)
[17:00:28.245]                   if (is.na(NA_character_)) 
[17:00:28.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.245]                     .init = FALSE)
[17:00:28.245]                 }
[17:00:28.245]             }
[17:00:28.245]         }
[17:00:28.245]     })
[17:00:28.245]     if (TRUE) {
[17:00:28.245]         base::sink(type = "output", split = FALSE)
[17:00:28.245]         if (TRUE) {
[17:00:28.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.245]         }
[17:00:28.245]         else {
[17:00:28.245]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.245]         }
[17:00:28.245]         base::close(...future.stdout)
[17:00:28.245]         ...future.stdout <- NULL
[17:00:28.245]     }
[17:00:28.245]     ...future.result$conditions <- ...future.conditions
[17:00:28.245]     ...future.result$finished <- base::Sys.time()
[17:00:28.245]     ...future.result
[17:00:28.245] }
[17:00:28.246] assign_globals() ...
[17:00:28.246] List of 5
[17:00:28.246]  $ ...future.FUN            :function (C, k)  
[17:00:28.246]  $ MoreArgs                 : NULL
[17:00:28.246]  $ ...future.elements_ii    :List of 2
[17:00:28.246]   ..$ :List of 1
[17:00:28.246]   .. ..$ : chr "C"
[17:00:28.246]   ..$ :List of 1
[17:00:28.246]   .. ..$ : int 3
[17:00:28.246]  $ ...future.seeds_ii       : NULL
[17:00:28.246]  $ ...future.globals.maxSize: NULL
[17:00:28.246]  - attr(*, "where")=List of 5
[17:00:28.246]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.246]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.246]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.246]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.246]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.246]  - attr(*, "resolved")= logi FALSE
[17:00:28.246]  - attr(*, "total_size")= num 3488
[17:00:28.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.246]  - attr(*, "already-done")= logi TRUE
[17:00:28.251] - reassign environment for ‘...future.FUN’
[17:00:28.251] - copied ‘...future.FUN’ to environment
[17:00:28.251] - copied ‘MoreArgs’ to environment
[17:00:28.251] - copied ‘...future.elements_ii’ to environment
[17:00:28.252] - copied ‘...future.seeds_ii’ to environment
[17:00:28.254] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.254] assign_globals() ... done
[17:00:28.254] plan(): Setting new future strategy stack:
[17:00:28.254] List of future strategies:
[17:00:28.254] 1. sequential:
[17:00:28.254]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.254]    - tweaked: FALSE
[17:00:28.254]    - call: NULL
[17:00:28.254] plan(): nbrOfWorkers() = 1
[17:00:28.255] plan(): Setting new future strategy stack:
[17:00:28.255] List of future strategies:
[17:00:28.255] 1. sequential:
[17:00:28.255]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.255]    - tweaked: FALSE
[17:00:28.255]    - call: plan(strategy)
[17:00:28.256] plan(): nbrOfWorkers() = 1
[17:00:28.256] SequentialFuture started (and completed)
[17:00:28.256] - Launch lazy future ... done
[17:00:28.256] run() for ‘SequentialFuture’ ... done
[17:00:28.256] Created future:
[17:00:28.256] SequentialFuture:
[17:00:28.256] Label: ‘future_mapply-3’
[17:00:28.256] Expression:
[17:00:28.256] {
[17:00:28.256]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.256]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.256]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.256]         on.exit(options(oopts), add = TRUE)
[17:00:28.256]     }
[17:00:28.256]     {
[17:00:28.256]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.256]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.256]         do.call(mapply, args = args)
[17:00:28.256]     }
[17:00:28.256] }
[17:00:28.256] Lazy evaluation: FALSE
[17:00:28.256] Asynchronous evaluation: FALSE
[17:00:28.256] Local evaluation: TRUE
[17:00:28.256] Environment: R_GlobalEnv
[17:00:28.256] Capture standard output: TRUE
[17:00:28.256] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.256] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.256] Packages: <none>
[17:00:28.256] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.256] Resolved: TRUE
[17:00:28.256] Value: 112 bytes of class ‘list’
[17:00:28.256] Early signaling: FALSE
[17:00:28.256] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.256] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.257] Chunk #3 of 5 ... DONE
[17:00:28.257] Chunk #4 of 5 ...
[17:00:28.257]  - Finding globals in '...' for chunk #4 ...
[17:00:28.258] getGlobalsAndPackages() ...
[17:00:28.258] Searching for globals...
[17:00:28.258] 
[17:00:28.258] Searching for globals ... DONE
[17:00:28.258] - globals: [0] <none>
[17:00:28.258] getGlobalsAndPackages() ... DONE
[17:00:28.258]    + additional globals found: [n=0] 
[17:00:28.258]    + additional namespaces needed: [n=0] 
[17:00:28.259]  - Finding globals in '...' for chunk #4 ... DONE
[17:00:28.259]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:28.259]  - seeds: <none>
[17:00:28.259]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.259] getGlobalsAndPackages() ...
[17:00:28.259] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.259] Resolving globals: FALSE
[17:00:28.260] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:28.260] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.260] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.260] 
[17:00:28.260] getGlobalsAndPackages() ... DONE
[17:00:28.261] run() for ‘Future’ ...
[17:00:28.261] - state: ‘created’
[17:00:28.261] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.261] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.261]   - Field: ‘label’
[17:00:28.261]   - Field: ‘local’
[17:00:28.262]   - Field: ‘owner’
[17:00:28.262]   - Field: ‘envir’
[17:00:28.262]   - Field: ‘packages’
[17:00:28.262]   - Field: ‘gc’
[17:00:28.262]   - Field: ‘conditions’
[17:00:28.262]   - Field: ‘expr’
[17:00:28.262]   - Field: ‘uuid’
[17:00:28.262]   - Field: ‘seed’
[17:00:28.262]   - Field: ‘version’
[17:00:28.262]   - Field: ‘result’
[17:00:28.262]   - Field: ‘asynchronous’
[17:00:28.263]   - Field: ‘calls’
[17:00:28.263]   - Field: ‘globals’
[17:00:28.263]   - Field: ‘stdout’
[17:00:28.263]   - Field: ‘earlySignal’
[17:00:28.263]   - Field: ‘lazy’
[17:00:28.263]   - Field: ‘state’
[17:00:28.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.263] - Launch lazy future ...
[17:00:28.263] Packages needed by the future expression (n = 0): <none>
[17:00:28.263] Packages needed by future strategies (n = 0): <none>
[17:00:28.264] {
[17:00:28.264]     {
[17:00:28.264]         {
[17:00:28.264]             ...future.startTime <- base::Sys.time()
[17:00:28.264]             {
[17:00:28.264]                 {
[17:00:28.264]                   {
[17:00:28.264]                     base::local({
[17:00:28.264]                       has_future <- base::requireNamespace("future", 
[17:00:28.264]                         quietly = TRUE)
[17:00:28.264]                       if (has_future) {
[17:00:28.264]                         ns <- base::getNamespace("future")
[17:00:28.264]                         version <- ns[[".package"]][["version"]]
[17:00:28.264]                         if (is.null(version)) 
[17:00:28.264]                           version <- utils::packageVersion("future")
[17:00:28.264]                       }
[17:00:28.264]                       else {
[17:00:28.264]                         version <- NULL
[17:00:28.264]                       }
[17:00:28.264]                       if (!has_future || version < "1.8.0") {
[17:00:28.264]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.264]                           "", base::R.version$version.string), 
[17:00:28.264]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.264]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.264]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.264]                             "release", "version")], collapse = " "), 
[17:00:28.264]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.264]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.264]                           info)
[17:00:28.264]                         info <- base::paste(info, collapse = "; ")
[17:00:28.264]                         if (!has_future) {
[17:00:28.264]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.264]                             info)
[17:00:28.264]                         }
[17:00:28.264]                         else {
[17:00:28.264]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.264]                             info, version)
[17:00:28.264]                         }
[17:00:28.264]                         base::stop(msg)
[17:00:28.264]                       }
[17:00:28.264]                     })
[17:00:28.264]                   }
[17:00:28.264]                   ...future.strategy.old <- future::plan("list")
[17:00:28.264]                   options(future.plan = NULL)
[17:00:28.264]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.264]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.264]                 }
[17:00:28.264]                 ...future.workdir <- getwd()
[17:00:28.264]             }
[17:00:28.264]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.264]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.264]         }
[17:00:28.264]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.264]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:28.264]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.264]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.264]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.264]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.264]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.264]             base::names(...future.oldOptions))
[17:00:28.264]     }
[17:00:28.264]     if (FALSE) {
[17:00:28.264]     }
[17:00:28.264]     else {
[17:00:28.264]         if (TRUE) {
[17:00:28.264]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.264]                 open = "w")
[17:00:28.264]         }
[17:00:28.264]         else {
[17:00:28.264]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.264]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.264]         }
[17:00:28.264]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.264]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.264]             base::sink(type = "output", split = FALSE)
[17:00:28.264]             base::close(...future.stdout)
[17:00:28.264]         }, add = TRUE)
[17:00:28.264]     }
[17:00:28.264]     ...future.frame <- base::sys.nframe()
[17:00:28.264]     ...future.conditions <- base::list()
[17:00:28.264]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.264]     if (FALSE) {
[17:00:28.264]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.264]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.264]     }
[17:00:28.264]     ...future.result <- base::tryCatch({
[17:00:28.264]         base::withCallingHandlers({
[17:00:28.264]             ...future.value <- base::withVisible(base::local({
[17:00:28.264]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.264]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.264]                   ...future.globals.maxSize)) {
[17:00:28.264]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.264]                   on.exit(options(oopts), add = TRUE)
[17:00:28.264]                 }
[17:00:28.264]                 {
[17:00:28.264]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.264]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.264]                     USE.NAMES = FALSE)
[17:00:28.264]                   do.call(mapply, args = args)
[17:00:28.264]                 }
[17:00:28.264]             }))
[17:00:28.264]             future::FutureResult(value = ...future.value$value, 
[17:00:28.264]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.264]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.264]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.264]                     ...future.globalenv.names))
[17:00:28.264]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.264]         }, condition = base::local({
[17:00:28.264]             c <- base::c
[17:00:28.264]             inherits <- base::inherits
[17:00:28.264]             invokeRestart <- base::invokeRestart
[17:00:28.264]             length <- base::length
[17:00:28.264]             list <- base::list
[17:00:28.264]             seq.int <- base::seq.int
[17:00:28.264]             signalCondition <- base::signalCondition
[17:00:28.264]             sys.calls <- base::sys.calls
[17:00:28.264]             `[[` <- base::`[[`
[17:00:28.264]             `+` <- base::`+`
[17:00:28.264]             `<<-` <- base::`<<-`
[17:00:28.264]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.264]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.264]                   3L)]
[17:00:28.264]             }
[17:00:28.264]             function(cond) {
[17:00:28.264]                 is_error <- inherits(cond, "error")
[17:00:28.264]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.264]                   NULL)
[17:00:28.264]                 if (is_error) {
[17:00:28.264]                   sessionInformation <- function() {
[17:00:28.264]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.264]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.264]                       search = base::search(), system = base::Sys.info())
[17:00:28.264]                   }
[17:00:28.264]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.264]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.264]                     cond$call), session = sessionInformation(), 
[17:00:28.264]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.264]                   signalCondition(cond)
[17:00:28.264]                 }
[17:00:28.264]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.264]                 "immediateCondition"))) {
[17:00:28.264]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.264]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.264]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.264]                   if (TRUE && !signal) {
[17:00:28.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.264]                     {
[17:00:28.264]                       inherits <- base::inherits
[17:00:28.264]                       invokeRestart <- base::invokeRestart
[17:00:28.264]                       is.null <- base::is.null
[17:00:28.264]                       muffled <- FALSE
[17:00:28.264]                       if (inherits(cond, "message")) {
[17:00:28.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.264]                         if (muffled) 
[17:00:28.264]                           invokeRestart("muffleMessage")
[17:00:28.264]                       }
[17:00:28.264]                       else if (inherits(cond, "warning")) {
[17:00:28.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.264]                         if (muffled) 
[17:00:28.264]                           invokeRestart("muffleWarning")
[17:00:28.264]                       }
[17:00:28.264]                       else if (inherits(cond, "condition")) {
[17:00:28.264]                         if (!is.null(pattern)) {
[17:00:28.264]                           computeRestarts <- base::computeRestarts
[17:00:28.264]                           grepl <- base::grepl
[17:00:28.264]                           restarts <- computeRestarts(cond)
[17:00:28.264]                           for (restart in restarts) {
[17:00:28.264]                             name <- restart$name
[17:00:28.264]                             if (is.null(name)) 
[17:00:28.264]                               next
[17:00:28.264]                             if (!grepl(pattern, name)) 
[17:00:28.264]                               next
[17:00:28.264]                             invokeRestart(restart)
[17:00:28.264]                             muffled <- TRUE
[17:00:28.264]                             break
[17:00:28.264]                           }
[17:00:28.264]                         }
[17:00:28.264]                       }
[17:00:28.264]                       invisible(muffled)
[17:00:28.264]                     }
[17:00:28.264]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.264]                   }
[17:00:28.264]                 }
[17:00:28.264]                 else {
[17:00:28.264]                   if (TRUE) {
[17:00:28.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.264]                     {
[17:00:28.264]                       inherits <- base::inherits
[17:00:28.264]                       invokeRestart <- base::invokeRestart
[17:00:28.264]                       is.null <- base::is.null
[17:00:28.264]                       muffled <- FALSE
[17:00:28.264]                       if (inherits(cond, "message")) {
[17:00:28.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.264]                         if (muffled) 
[17:00:28.264]                           invokeRestart("muffleMessage")
[17:00:28.264]                       }
[17:00:28.264]                       else if (inherits(cond, "warning")) {
[17:00:28.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.264]                         if (muffled) 
[17:00:28.264]                           invokeRestart("muffleWarning")
[17:00:28.264]                       }
[17:00:28.264]                       else if (inherits(cond, "condition")) {
[17:00:28.264]                         if (!is.null(pattern)) {
[17:00:28.264]                           computeRestarts <- base::computeRestarts
[17:00:28.264]                           grepl <- base::grepl
[17:00:28.264]                           restarts <- computeRestarts(cond)
[17:00:28.264]                           for (restart in restarts) {
[17:00:28.264]                             name <- restart$name
[17:00:28.264]                             if (is.null(name)) 
[17:00:28.264]                               next
[17:00:28.264]                             if (!grepl(pattern, name)) 
[17:00:28.264]                               next
[17:00:28.264]                             invokeRestart(restart)
[17:00:28.264]                             muffled <- TRUE
[17:00:28.264]                             break
[17:00:28.264]                           }
[17:00:28.264]                         }
[17:00:28.264]                       }
[17:00:28.264]                       invisible(muffled)
[17:00:28.264]                     }
[17:00:28.264]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.264]                   }
[17:00:28.264]                 }
[17:00:28.264]             }
[17:00:28.264]         }))
[17:00:28.264]     }, error = function(ex) {
[17:00:28.264]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.264]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.264]                 ...future.rng), started = ...future.startTime, 
[17:00:28.264]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.264]             version = "1.8"), class = "FutureResult")
[17:00:28.264]     }, finally = {
[17:00:28.264]         if (!identical(...future.workdir, getwd())) 
[17:00:28.264]             setwd(...future.workdir)
[17:00:28.264]         {
[17:00:28.264]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.264]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.264]             }
[17:00:28.264]             base::options(...future.oldOptions)
[17:00:28.264]             if (.Platform$OS.type == "windows") {
[17:00:28.264]                 old_names <- names(...future.oldEnvVars)
[17:00:28.264]                 envs <- base::Sys.getenv()
[17:00:28.264]                 names <- names(envs)
[17:00:28.264]                 common <- intersect(names, old_names)
[17:00:28.264]                 added <- setdiff(names, old_names)
[17:00:28.264]                 removed <- setdiff(old_names, names)
[17:00:28.264]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.264]                   envs[common]]
[17:00:28.264]                 NAMES <- toupper(changed)
[17:00:28.264]                 args <- list()
[17:00:28.264]                 for (kk in seq_along(NAMES)) {
[17:00:28.264]                   name <- changed[[kk]]
[17:00:28.264]                   NAME <- NAMES[[kk]]
[17:00:28.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.264]                     next
[17:00:28.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.264]                 }
[17:00:28.264]                 NAMES <- toupper(added)
[17:00:28.264]                 for (kk in seq_along(NAMES)) {
[17:00:28.264]                   name <- added[[kk]]
[17:00:28.264]                   NAME <- NAMES[[kk]]
[17:00:28.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.264]                     next
[17:00:28.264]                   args[[name]] <- ""
[17:00:28.264]                 }
[17:00:28.264]                 NAMES <- toupper(removed)
[17:00:28.264]                 for (kk in seq_along(NAMES)) {
[17:00:28.264]                   name <- removed[[kk]]
[17:00:28.264]                   NAME <- NAMES[[kk]]
[17:00:28.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.264]                     next
[17:00:28.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.264]                 }
[17:00:28.264]                 if (length(args) > 0) 
[17:00:28.264]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.264]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.264]             }
[17:00:28.264]             else {
[17:00:28.264]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.264]             }
[17:00:28.264]             {
[17:00:28.264]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.264]                   0L) {
[17:00:28.264]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.264]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.264]                   base::options(opts)
[17:00:28.264]                 }
[17:00:28.264]                 {
[17:00:28.264]                   {
[17:00:28.264]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.264]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.264]                     2054632538L), envir = base::globalenv(), 
[17:00:28.264]                       inherits = FALSE)
[17:00:28.264]                     NULL
[17:00:28.264]                   }
[17:00:28.264]                   options(future.plan = NULL)
[17:00:28.264]                   if (is.na(NA_character_)) 
[17:00:28.264]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.264]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.264]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.264]                     .init = FALSE)
[17:00:28.264]                 }
[17:00:28.264]             }
[17:00:28.264]         }
[17:00:28.264]     })
[17:00:28.264]     if (TRUE) {
[17:00:28.264]         base::sink(type = "output", split = FALSE)
[17:00:28.264]         if (TRUE) {
[17:00:28.264]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.264]         }
[17:00:28.264]         else {
[17:00:28.264]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.264]         }
[17:00:28.264]         base::close(...future.stdout)
[17:00:28.264]         ...future.stdout <- NULL
[17:00:28.264]     }
[17:00:28.264]     ...future.result$conditions <- ...future.conditions
[17:00:28.264]     ...future.result$finished <- base::Sys.time()
[17:00:28.264]     ...future.result
[17:00:28.264] }
[17:00:28.266] assign_globals() ...
[17:00:28.266] List of 5
[17:00:28.266]  $ ...future.FUN            :function (C, k)  
[17:00:28.266]  $ MoreArgs                 : NULL
[17:00:28.266]  $ ...future.elements_ii    :List of 2
[17:00:28.266]   ..$ :List of 1
[17:00:28.266]   .. ..$ : chr "D"
[17:00:28.266]   ..$ :List of 1
[17:00:28.266]   .. ..$ : int 2
[17:00:28.266]  $ ...future.seeds_ii       : NULL
[17:00:28.266]  $ ...future.globals.maxSize: NULL
[17:00:28.266]  - attr(*, "where")=List of 5
[17:00:28.266]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.266]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.266]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.266]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.266]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.266]  - attr(*, "resolved")= logi FALSE
[17:00:28.266]  - attr(*, "total_size")= num 3488
[17:00:28.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.266]  - attr(*, "already-done")= logi TRUE
[17:00:28.270] - reassign environment for ‘...future.FUN’
[17:00:28.271] - copied ‘...future.FUN’ to environment
[17:00:28.271] - copied ‘MoreArgs’ to environment
[17:00:28.271] - copied ‘...future.elements_ii’ to environment
[17:00:28.271] - copied ‘...future.seeds_ii’ to environment
[17:00:28.271] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.271] assign_globals() ... done
[17:00:28.271] plan(): Setting new future strategy stack:
[17:00:28.271] List of future strategies:
[17:00:28.271] 1. sequential:
[17:00:28.271]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.271]    - tweaked: FALSE
[17:00:28.271]    - call: NULL
[17:00:28.272] plan(): nbrOfWorkers() = 1
[17:00:28.273] plan(): Setting new future strategy stack:
[17:00:28.273] List of future strategies:
[17:00:28.273] 1. sequential:
[17:00:28.273]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.273]    - tweaked: FALSE
[17:00:28.273]    - call: plan(strategy)
[17:00:28.273] plan(): nbrOfWorkers() = 1
[17:00:28.273] SequentialFuture started (and completed)
[17:00:28.273] - Launch lazy future ... done
[17:00:28.273] run() for ‘SequentialFuture’ ... done
[17:00:28.274] Created future:
[17:00:28.274] SequentialFuture:
[17:00:28.274] Label: ‘future_mapply-4’
[17:00:28.274] Expression:
[17:00:28.274] {
[17:00:28.274]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.274]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.274]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.274]         on.exit(options(oopts), add = TRUE)
[17:00:28.274]     }
[17:00:28.274]     {
[17:00:28.274]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.274]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.274]         do.call(mapply, args = args)
[17:00:28.274]     }
[17:00:28.274] }
[17:00:28.274] Lazy evaluation: FALSE
[17:00:28.274] Asynchronous evaluation: FALSE
[17:00:28.274] Local evaluation: TRUE
[17:00:28.274] Environment: R_GlobalEnv
[17:00:28.274] Capture standard output: TRUE
[17:00:28.274] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.274] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.274] Packages: <none>
[17:00:28.274] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.274] Resolved: TRUE
[17:00:28.274] Value: 112 bytes of class ‘list’
[17:00:28.274] Early signaling: FALSE
[17:00:28.274] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.274] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.274] Chunk #4 of 5 ... DONE
[17:00:28.275] Chunk #5 of 5 ...
[17:00:28.275]  - Finding globals in '...' for chunk #5 ...
[17:00:28.275] getGlobalsAndPackages() ...
[17:00:28.275] Searching for globals...
[17:00:28.275] 
[17:00:28.275] Searching for globals ... DONE
[17:00:28.275] - globals: [0] <none>
[17:00:28.276] getGlobalsAndPackages() ... DONE
[17:00:28.276]    + additional globals found: [n=0] 
[17:00:28.276]    + additional namespaces needed: [n=0] 
[17:00:28.276]  - Finding globals in '...' for chunk #5 ... DONE
[17:00:28.276]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:28.276]  - seeds: <none>
[17:00:28.276]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.276] getGlobalsAndPackages() ...
[17:00:28.276] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.276] Resolving globals: FALSE
[17:00:28.277] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:28.277] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.308] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.308] 
[17:00:28.308] getGlobalsAndPackages() ... DONE
[17:00:28.308] run() for ‘Future’ ...
[17:00:28.309] - state: ‘created’
[17:00:28.309] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.309] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.309] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.309]   - Field: ‘label’
[17:00:28.309]   - Field: ‘local’
[17:00:28.310]   - Field: ‘owner’
[17:00:28.310]   - Field: ‘envir’
[17:00:28.310]   - Field: ‘packages’
[17:00:28.310]   - Field: ‘gc’
[17:00:28.310]   - Field: ‘conditions’
[17:00:28.310]   - Field: ‘expr’
[17:00:28.310]   - Field: ‘uuid’
[17:00:28.310]   - Field: ‘seed’
[17:00:28.310]   - Field: ‘version’
[17:00:28.310]   - Field: ‘result’
[17:00:28.311]   - Field: ‘asynchronous’
[17:00:28.311]   - Field: ‘calls’
[17:00:28.311]   - Field: ‘globals’
[17:00:28.311]   - Field: ‘stdout’
[17:00:28.311]   - Field: ‘earlySignal’
[17:00:28.311]   - Field: ‘lazy’
[17:00:28.311]   - Field: ‘state’
[17:00:28.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.311] - Launch lazy future ...
[17:00:28.311] Packages needed by the future expression (n = 0): <none>
[17:00:28.312] Packages needed by future strategies (n = 0): <none>
[17:00:28.312] {
[17:00:28.312]     {
[17:00:28.312]         {
[17:00:28.312]             ...future.startTime <- base::Sys.time()
[17:00:28.312]             {
[17:00:28.312]                 {
[17:00:28.312]                   {
[17:00:28.312]                     base::local({
[17:00:28.312]                       has_future <- base::requireNamespace("future", 
[17:00:28.312]                         quietly = TRUE)
[17:00:28.312]                       if (has_future) {
[17:00:28.312]                         ns <- base::getNamespace("future")
[17:00:28.312]                         version <- ns[[".package"]][["version"]]
[17:00:28.312]                         if (is.null(version)) 
[17:00:28.312]                           version <- utils::packageVersion("future")
[17:00:28.312]                       }
[17:00:28.312]                       else {
[17:00:28.312]                         version <- NULL
[17:00:28.312]                       }
[17:00:28.312]                       if (!has_future || version < "1.8.0") {
[17:00:28.312]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.312]                           "", base::R.version$version.string), 
[17:00:28.312]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.312]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.312]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.312]                             "release", "version")], collapse = " "), 
[17:00:28.312]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.312]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.312]                           info)
[17:00:28.312]                         info <- base::paste(info, collapse = "; ")
[17:00:28.312]                         if (!has_future) {
[17:00:28.312]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.312]                             info)
[17:00:28.312]                         }
[17:00:28.312]                         else {
[17:00:28.312]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.312]                             info, version)
[17:00:28.312]                         }
[17:00:28.312]                         base::stop(msg)
[17:00:28.312]                       }
[17:00:28.312]                     })
[17:00:28.312]                   }
[17:00:28.312]                   ...future.strategy.old <- future::plan("list")
[17:00:28.312]                   options(future.plan = NULL)
[17:00:28.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.312]                 }
[17:00:28.312]                 ...future.workdir <- getwd()
[17:00:28.312]             }
[17:00:28.312]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.312]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.312]         }
[17:00:28.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.312]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:28.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.312]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.312]             base::names(...future.oldOptions))
[17:00:28.312]     }
[17:00:28.312]     if (FALSE) {
[17:00:28.312]     }
[17:00:28.312]     else {
[17:00:28.312]         if (TRUE) {
[17:00:28.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.312]                 open = "w")
[17:00:28.312]         }
[17:00:28.312]         else {
[17:00:28.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.312]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.312]         }
[17:00:28.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.312]             base::sink(type = "output", split = FALSE)
[17:00:28.312]             base::close(...future.stdout)
[17:00:28.312]         }, add = TRUE)
[17:00:28.312]     }
[17:00:28.312]     ...future.frame <- base::sys.nframe()
[17:00:28.312]     ...future.conditions <- base::list()
[17:00:28.312]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.312]     if (FALSE) {
[17:00:28.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.312]     }
[17:00:28.312]     ...future.result <- base::tryCatch({
[17:00:28.312]         base::withCallingHandlers({
[17:00:28.312]             ...future.value <- base::withVisible(base::local({
[17:00:28.312]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.312]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.312]                   ...future.globals.maxSize)) {
[17:00:28.312]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.312]                   on.exit(options(oopts), add = TRUE)
[17:00:28.312]                 }
[17:00:28.312]                 {
[17:00:28.312]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.312]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.312]                     USE.NAMES = FALSE)
[17:00:28.312]                   do.call(mapply, args = args)
[17:00:28.312]                 }
[17:00:28.312]             }))
[17:00:28.312]             future::FutureResult(value = ...future.value$value, 
[17:00:28.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.312]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.312]                     ...future.globalenv.names))
[17:00:28.312]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.312]         }, condition = base::local({
[17:00:28.312]             c <- base::c
[17:00:28.312]             inherits <- base::inherits
[17:00:28.312]             invokeRestart <- base::invokeRestart
[17:00:28.312]             length <- base::length
[17:00:28.312]             list <- base::list
[17:00:28.312]             seq.int <- base::seq.int
[17:00:28.312]             signalCondition <- base::signalCondition
[17:00:28.312]             sys.calls <- base::sys.calls
[17:00:28.312]             `[[` <- base::`[[`
[17:00:28.312]             `+` <- base::`+`
[17:00:28.312]             `<<-` <- base::`<<-`
[17:00:28.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.312]                   3L)]
[17:00:28.312]             }
[17:00:28.312]             function(cond) {
[17:00:28.312]                 is_error <- inherits(cond, "error")
[17:00:28.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.312]                   NULL)
[17:00:28.312]                 if (is_error) {
[17:00:28.312]                   sessionInformation <- function() {
[17:00:28.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.312]                       search = base::search(), system = base::Sys.info())
[17:00:28.312]                   }
[17:00:28.312]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.312]                     cond$call), session = sessionInformation(), 
[17:00:28.312]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.312]                   signalCondition(cond)
[17:00:28.312]                 }
[17:00:28.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.312]                 "immediateCondition"))) {
[17:00:28.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.312]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.312]                   if (TRUE && !signal) {
[17:00:28.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.312]                     {
[17:00:28.312]                       inherits <- base::inherits
[17:00:28.312]                       invokeRestart <- base::invokeRestart
[17:00:28.312]                       is.null <- base::is.null
[17:00:28.312]                       muffled <- FALSE
[17:00:28.312]                       if (inherits(cond, "message")) {
[17:00:28.312]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.312]                         if (muffled) 
[17:00:28.312]                           invokeRestart("muffleMessage")
[17:00:28.312]                       }
[17:00:28.312]                       else if (inherits(cond, "warning")) {
[17:00:28.312]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.312]                         if (muffled) 
[17:00:28.312]                           invokeRestart("muffleWarning")
[17:00:28.312]                       }
[17:00:28.312]                       else if (inherits(cond, "condition")) {
[17:00:28.312]                         if (!is.null(pattern)) {
[17:00:28.312]                           computeRestarts <- base::computeRestarts
[17:00:28.312]                           grepl <- base::grepl
[17:00:28.312]                           restarts <- computeRestarts(cond)
[17:00:28.312]                           for (restart in restarts) {
[17:00:28.312]                             name <- restart$name
[17:00:28.312]                             if (is.null(name)) 
[17:00:28.312]                               next
[17:00:28.312]                             if (!grepl(pattern, name)) 
[17:00:28.312]                               next
[17:00:28.312]                             invokeRestart(restart)
[17:00:28.312]                             muffled <- TRUE
[17:00:28.312]                             break
[17:00:28.312]                           }
[17:00:28.312]                         }
[17:00:28.312]                       }
[17:00:28.312]                       invisible(muffled)
[17:00:28.312]                     }
[17:00:28.312]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.312]                   }
[17:00:28.312]                 }
[17:00:28.312]                 else {
[17:00:28.312]                   if (TRUE) {
[17:00:28.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.312]                     {
[17:00:28.312]                       inherits <- base::inherits
[17:00:28.312]                       invokeRestart <- base::invokeRestart
[17:00:28.312]                       is.null <- base::is.null
[17:00:28.312]                       muffled <- FALSE
[17:00:28.312]                       if (inherits(cond, "message")) {
[17:00:28.312]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.312]                         if (muffled) 
[17:00:28.312]                           invokeRestart("muffleMessage")
[17:00:28.312]                       }
[17:00:28.312]                       else if (inherits(cond, "warning")) {
[17:00:28.312]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.312]                         if (muffled) 
[17:00:28.312]                           invokeRestart("muffleWarning")
[17:00:28.312]                       }
[17:00:28.312]                       else if (inherits(cond, "condition")) {
[17:00:28.312]                         if (!is.null(pattern)) {
[17:00:28.312]                           computeRestarts <- base::computeRestarts
[17:00:28.312]                           grepl <- base::grepl
[17:00:28.312]                           restarts <- computeRestarts(cond)
[17:00:28.312]                           for (restart in restarts) {
[17:00:28.312]                             name <- restart$name
[17:00:28.312]                             if (is.null(name)) 
[17:00:28.312]                               next
[17:00:28.312]                             if (!grepl(pattern, name)) 
[17:00:28.312]                               next
[17:00:28.312]                             invokeRestart(restart)
[17:00:28.312]                             muffled <- TRUE
[17:00:28.312]                             break
[17:00:28.312]                           }
[17:00:28.312]                         }
[17:00:28.312]                       }
[17:00:28.312]                       invisible(muffled)
[17:00:28.312]                     }
[17:00:28.312]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.312]                   }
[17:00:28.312]                 }
[17:00:28.312]             }
[17:00:28.312]         }))
[17:00:28.312]     }, error = function(ex) {
[17:00:28.312]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.312]                 ...future.rng), started = ...future.startTime, 
[17:00:28.312]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.312]             version = "1.8"), class = "FutureResult")
[17:00:28.312]     }, finally = {
[17:00:28.312]         if (!identical(...future.workdir, getwd())) 
[17:00:28.312]             setwd(...future.workdir)
[17:00:28.312]         {
[17:00:28.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.312]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.312]             }
[17:00:28.312]             base::options(...future.oldOptions)
[17:00:28.312]             if (.Platform$OS.type == "windows") {
[17:00:28.312]                 old_names <- names(...future.oldEnvVars)
[17:00:28.312]                 envs <- base::Sys.getenv()
[17:00:28.312]                 names <- names(envs)
[17:00:28.312]                 common <- intersect(names, old_names)
[17:00:28.312]                 added <- setdiff(names, old_names)
[17:00:28.312]                 removed <- setdiff(old_names, names)
[17:00:28.312]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.312]                   envs[common]]
[17:00:28.312]                 NAMES <- toupper(changed)
[17:00:28.312]                 args <- list()
[17:00:28.312]                 for (kk in seq_along(NAMES)) {
[17:00:28.312]                   name <- changed[[kk]]
[17:00:28.312]                   NAME <- NAMES[[kk]]
[17:00:28.312]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.312]                     next
[17:00:28.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.312]                 }
[17:00:28.312]                 NAMES <- toupper(added)
[17:00:28.312]                 for (kk in seq_along(NAMES)) {
[17:00:28.312]                   name <- added[[kk]]
[17:00:28.312]                   NAME <- NAMES[[kk]]
[17:00:28.312]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.312]                     next
[17:00:28.312]                   args[[name]] <- ""
[17:00:28.312]                 }
[17:00:28.312]                 NAMES <- toupper(removed)
[17:00:28.312]                 for (kk in seq_along(NAMES)) {
[17:00:28.312]                   name <- removed[[kk]]
[17:00:28.312]                   NAME <- NAMES[[kk]]
[17:00:28.312]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.312]                     next
[17:00:28.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.312]                 }
[17:00:28.312]                 if (length(args) > 0) 
[17:00:28.312]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.312]             }
[17:00:28.312]             else {
[17:00:28.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.312]             }
[17:00:28.312]             {
[17:00:28.312]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.312]                   0L) {
[17:00:28.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.312]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.312]                   base::options(opts)
[17:00:28.312]                 }
[17:00:28.312]                 {
[17:00:28.312]                   {
[17:00:28.312]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.312]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.312]                     2054632538L), envir = base::globalenv(), 
[17:00:28.312]                       inherits = FALSE)
[17:00:28.312]                     NULL
[17:00:28.312]                   }
[17:00:28.312]                   options(future.plan = NULL)
[17:00:28.312]                   if (is.na(NA_character_)) 
[17:00:28.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.312]                     .init = FALSE)
[17:00:28.312]                 }
[17:00:28.312]             }
[17:00:28.312]         }
[17:00:28.312]     })
[17:00:28.312]     if (TRUE) {
[17:00:28.312]         base::sink(type = "output", split = FALSE)
[17:00:28.312]         if (TRUE) {
[17:00:28.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.312]         }
[17:00:28.312]         else {
[17:00:28.312]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.312]         }
[17:00:28.312]         base::close(...future.stdout)
[17:00:28.312]         ...future.stdout <- NULL
[17:00:28.312]     }
[17:00:28.312]     ...future.result$conditions <- ...future.conditions
[17:00:28.312]     ...future.result$finished <- base::Sys.time()
[17:00:28.312]     ...future.result
[17:00:28.312] }
[17:00:28.314] assign_globals() ...
[17:00:28.314] List of 5
[17:00:28.314]  $ ...future.FUN            :function (C, k)  
[17:00:28.314]  $ MoreArgs                 : NULL
[17:00:28.314]  $ ...future.elements_ii    :List of 2
[17:00:28.314]   ..$ :List of 1
[17:00:28.314]   .. ..$ : chr "E"
[17:00:28.314]   ..$ :List of 1
[17:00:28.314]   .. ..$ : int 1
[17:00:28.314]  $ ...future.seeds_ii       : NULL
[17:00:28.314]  $ ...future.globals.maxSize: NULL
[17:00:28.314]  - attr(*, "where")=List of 5
[17:00:28.314]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.314]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.314]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.314]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.314]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.314]  - attr(*, "resolved")= logi FALSE
[17:00:28.314]  - attr(*, "total_size")= num 3488
[17:00:28.314]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.314]  - attr(*, "already-done")= logi TRUE
[17:00:28.319] - reassign environment for ‘...future.FUN’
[17:00:28.319] - copied ‘...future.FUN’ to environment
[17:00:28.319] - copied ‘MoreArgs’ to environment
[17:00:28.319] - copied ‘...future.elements_ii’ to environment
[17:00:28.319] - copied ‘...future.seeds_ii’ to environment
[17:00:28.319] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.319] assign_globals() ... done
[17:00:28.320] plan(): Setting new future strategy stack:
[17:00:28.320] List of future strategies:
[17:00:28.320] 1. sequential:
[17:00:28.320]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.320]    - tweaked: FALSE
[17:00:28.320]    - call: NULL
[17:00:28.320] plan(): nbrOfWorkers() = 1
[17:00:28.321] plan(): Setting new future strategy stack:
[17:00:28.321] List of future strategies:
[17:00:28.321] 1. sequential:
[17:00:28.321]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.321]    - tweaked: FALSE
[17:00:28.321]    - call: plan(strategy)
[17:00:28.322] plan(): nbrOfWorkers() = 1
[17:00:28.322] SequentialFuture started (and completed)
[17:00:28.322] - Launch lazy future ... done
[17:00:28.322] run() for ‘SequentialFuture’ ... done
[17:00:28.322] Created future:
[17:00:28.322] SequentialFuture:
[17:00:28.322] Label: ‘future_mapply-5’
[17:00:28.322] Expression:
[17:00:28.322] {
[17:00:28.322]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.322]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.322]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.322]         on.exit(options(oopts), add = TRUE)
[17:00:28.322]     }
[17:00:28.322]     {
[17:00:28.322]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.322]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.322]         do.call(mapply, args = args)
[17:00:28.322]     }
[17:00:28.322] }
[17:00:28.322] Lazy evaluation: FALSE
[17:00:28.322] Asynchronous evaluation: FALSE
[17:00:28.322] Local evaluation: TRUE
[17:00:28.322] Environment: R_GlobalEnv
[17:00:28.322] Capture standard output: TRUE
[17:00:28.322] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.322] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.322] Packages: <none>
[17:00:28.322] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.322] Resolved: TRUE
[17:00:28.322] Value: 112 bytes of class ‘list’
[17:00:28.322] Early signaling: FALSE
[17:00:28.322] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.322] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.323] Chunk #5 of 5 ... DONE
[17:00:28.323] Launching 5 futures (chunks) ... DONE
[17:00:28.323] Resolving 5 futures (chunks) ...
[17:00:28.323] resolve() on list ...
[17:00:28.323]  recursive: 0
[17:00:28.323]  length: 5
[17:00:28.324] 
[17:00:28.324] resolved() for ‘SequentialFuture’ ...
[17:00:28.324] - state: ‘finished’
[17:00:28.324] - run: TRUE
[17:00:28.324] - result: ‘FutureResult’
[17:00:28.324] resolved() for ‘SequentialFuture’ ... done
[17:00:28.324] Future #1
[17:00:28.324] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.324] - nx: 5
[17:00:28.324] - relay: TRUE
[17:00:28.325] - stdout: TRUE
[17:00:28.325] - signal: TRUE
[17:00:28.325] - resignal: FALSE
[17:00:28.325] - force: TRUE
[17:00:28.325] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:00:28.325] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:00:28.325]  - until=1
[17:00:28.325]  - relaying element #1
[17:00:28.325] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:28.325] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:28.326] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.326]  length: 4 (resolved future 1)
[17:00:28.326] resolved() for ‘SequentialFuture’ ...
[17:00:28.326] - state: ‘finished’
[17:00:28.326] - run: TRUE
[17:00:28.326] - result: ‘FutureResult’
[17:00:28.326] resolved() for ‘SequentialFuture’ ... done
[17:00:28.326] Future #2
[17:00:28.326] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:00:28.326] - nx: 5
[17:00:28.327] - relay: TRUE
[17:00:28.327] - stdout: TRUE
[17:00:28.327] - signal: TRUE
[17:00:28.327] - resignal: FALSE
[17:00:28.327] - force: TRUE
[17:00:28.327] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:28.327] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:28.327]  - until=2
[17:00:28.327]  - relaying element #2
[17:00:28.327] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:28.328] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:28.328] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:00:28.328]  length: 3 (resolved future 2)
[17:00:28.328] resolved() for ‘SequentialFuture’ ...
[17:00:28.328] - state: ‘finished’
[17:00:28.328] - run: TRUE
[17:00:28.328] - result: ‘FutureResult’
[17:00:28.328] resolved() for ‘SequentialFuture’ ... done
[17:00:28.328] Future #3
[17:00:28.328] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:00:28.329] - nx: 5
[17:00:28.329] - relay: TRUE
[17:00:28.329] - stdout: TRUE
[17:00:28.329] - signal: TRUE
[17:00:28.329] - resignal: FALSE
[17:00:28.329] - force: TRUE
[17:00:28.329] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:28.329] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:28.329]  - until=3
[17:00:28.329]  - relaying element #3
[17:00:28.329] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:28.330] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:28.330] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:00:28.330]  length: 2 (resolved future 3)
[17:00:28.330] resolved() for ‘SequentialFuture’ ...
[17:00:28.330] - state: ‘finished’
[17:00:28.330] - run: TRUE
[17:00:28.330] - result: ‘FutureResult’
[17:00:28.330] resolved() for ‘SequentialFuture’ ... done
[17:00:28.330] Future #4
[17:00:28.330] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:00:28.331] - nx: 5
[17:00:28.331] - relay: TRUE
[17:00:28.331] - stdout: TRUE
[17:00:28.331] - signal: TRUE
[17:00:28.331] - resignal: FALSE
[17:00:28.331] - force: TRUE
[17:00:28.331] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:28.331] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:28.331]  - until=4
[17:00:28.331]  - relaying element #4
[17:00:28.332] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:28.332] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:28.332] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:00:28.332]  length: 1 (resolved future 4)
[17:00:28.332] resolved() for ‘SequentialFuture’ ...
[17:00:28.332] - state: ‘finished’
[17:00:28.332] - run: TRUE
[17:00:28.332] - result: ‘FutureResult’
[17:00:28.332] resolved() for ‘SequentialFuture’ ... done
[17:00:28.332] Future #5
[17:00:28.333] signalConditionsASAP(SequentialFuture, pos=5) ...
[17:00:28.333] - nx: 5
[17:00:28.333] - relay: TRUE
[17:00:28.333] - stdout: TRUE
[17:00:28.333] - signal: TRUE
[17:00:28.333] - resignal: FALSE
[17:00:28.333] - force: TRUE
[17:00:28.333] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:28.333] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:28.333]  - until=5
[17:00:28.333]  - relaying element #5
[17:00:28.334] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:28.334] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:28.336] signalConditionsASAP(SequentialFuture, pos=5) ... done
[17:00:28.336]  length: 0 (resolved future 5)
[17:00:28.336] Relaying remaining futures
[17:00:28.336] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.336] - nx: 5
[17:00:28.336] - relay: TRUE
[17:00:28.336] - stdout: TRUE
[17:00:28.336] - signal: TRUE
[17:00:28.336] - resignal: FALSE
[17:00:28.337] - force: TRUE
[17:00:28.337] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:28.337] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[17:00:28.337] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:28.337] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:28.337] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.337] resolve() on list ... DONE
[17:00:28.338]  - Number of value chunks collected: 5
[17:00:28.338] Resolving 5 futures (chunks) ... DONE
[17:00:28.338] Reducing values from 5 chunks ...
[17:00:28.338]  - Number of values collected after concatenation: 5
[17:00:28.338]  - Number of values expected: 5
[17:00:28.338] Reducing values from 5 chunks ... DONE
[17:00:28.338] future_mapply() ... DONE
[17:00:28.339] future_mapply() ...
[17:00:28.339] Number of chunks: 1
[17:00:28.339] getGlobalsAndPackagesXApply() ...
[17:00:28.339]  - future.globals: TRUE
[17:00:28.339] getGlobalsAndPackages() ...
[17:00:28.339] Searching for globals...
[17:00:28.341] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:28.341] Searching for globals ... DONE
[17:00:28.341] Resolving globals: FALSE
[17:00:28.341] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:28.342] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:28.342] - globals: [1] ‘FUN’
[17:00:28.342] 
[17:00:28.342] getGlobalsAndPackages() ... DONE
[17:00:28.342]  - globals found/used: [n=1] ‘FUN’
[17:00:28.342]  - needed namespaces: [n=0] 
[17:00:28.342] Finding globals ... DONE
[17:00:28.342] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.343] List of 2
[17:00:28.343]  $ ...future.FUN:function (C, k)  
[17:00:28.343]  $ MoreArgs     : list()
[17:00:28.343]  - attr(*, "where")=List of 2
[17:00:28.343]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.343]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.343]  - attr(*, "resolved")= logi FALSE
[17:00:28.343]  - attr(*, "total_size")= num NA
[17:00:28.345] Packages to be attached in all futures: [n=0] 
[17:00:28.345] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.345] Number of futures (= number of chunks): 1
[17:00:28.346] Launching 1 futures (chunks) ...
[17:00:28.346] Chunk #1 of 1 ...
[17:00:28.346]  - Finding globals in '...' for chunk #1 ...
[17:00:28.346] getGlobalsAndPackages() ...
[17:00:28.346] Searching for globals...
[17:00:28.346] 
[17:00:28.346] Searching for globals ... DONE
[17:00:28.346] - globals: [0] <none>
[17:00:28.347] getGlobalsAndPackages() ... DONE
[17:00:28.347]    + additional globals found: [n=0] 
[17:00:28.347]    + additional namespaces needed: [n=0] 
[17:00:28.347]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.347]  - seeds: <none>
[17:00:28.347]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.347] getGlobalsAndPackages() ...
[17:00:28.347] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.347] Resolving globals: FALSE
[17:00:28.348] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[17:00:28.348] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:28.348] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.349] 
[17:00:28.349] getGlobalsAndPackages() ... DONE
[17:00:28.349] run() for ‘Future’ ...
[17:00:28.349] - state: ‘created’
[17:00:28.349] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.349] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.350] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.350]   - Field: ‘label’
[17:00:28.350]   - Field: ‘local’
[17:00:28.350]   - Field: ‘owner’
[17:00:28.350]   - Field: ‘envir’
[17:00:28.350]   - Field: ‘packages’
[17:00:28.350]   - Field: ‘gc’
[17:00:28.350]   - Field: ‘conditions’
[17:00:28.350]   - Field: ‘expr’
[17:00:28.350]   - Field: ‘uuid’
[17:00:28.351]   - Field: ‘seed’
[17:00:28.351]   - Field: ‘version’
[17:00:28.351]   - Field: ‘result’
[17:00:28.351]   - Field: ‘asynchronous’
[17:00:28.351]   - Field: ‘calls’
[17:00:28.351]   - Field: ‘globals’
[17:00:28.351]   - Field: ‘stdout’
[17:00:28.351]   - Field: ‘earlySignal’
[17:00:28.351]   - Field: ‘lazy’
[17:00:28.351]   - Field: ‘state’
[17:00:28.351] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.352] - Launch lazy future ...
[17:00:28.352] Packages needed by the future expression (n = 0): <none>
[17:00:28.352] Packages needed by future strategies (n = 0): <none>
[17:00:28.352] {
[17:00:28.352]     {
[17:00:28.352]         {
[17:00:28.352]             ...future.startTime <- base::Sys.time()
[17:00:28.352]             {
[17:00:28.352]                 {
[17:00:28.352]                   {
[17:00:28.352]                     base::local({
[17:00:28.352]                       has_future <- base::requireNamespace("future", 
[17:00:28.352]                         quietly = TRUE)
[17:00:28.352]                       if (has_future) {
[17:00:28.352]                         ns <- base::getNamespace("future")
[17:00:28.352]                         version <- ns[[".package"]][["version"]]
[17:00:28.352]                         if (is.null(version)) 
[17:00:28.352]                           version <- utils::packageVersion("future")
[17:00:28.352]                       }
[17:00:28.352]                       else {
[17:00:28.352]                         version <- NULL
[17:00:28.352]                       }
[17:00:28.352]                       if (!has_future || version < "1.8.0") {
[17:00:28.352]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.352]                           "", base::R.version$version.string), 
[17:00:28.352]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.352]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.352]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.352]                             "release", "version")], collapse = " "), 
[17:00:28.352]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.352]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.352]                           info)
[17:00:28.352]                         info <- base::paste(info, collapse = "; ")
[17:00:28.352]                         if (!has_future) {
[17:00:28.352]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.352]                             info)
[17:00:28.352]                         }
[17:00:28.352]                         else {
[17:00:28.352]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.352]                             info, version)
[17:00:28.352]                         }
[17:00:28.352]                         base::stop(msg)
[17:00:28.352]                       }
[17:00:28.352]                     })
[17:00:28.352]                   }
[17:00:28.352]                   ...future.strategy.old <- future::plan("list")
[17:00:28.352]                   options(future.plan = NULL)
[17:00:28.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.352]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.352]                 }
[17:00:28.352]                 ...future.workdir <- getwd()
[17:00:28.352]             }
[17:00:28.352]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.352]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.352]         }
[17:00:28.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.352]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.352]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.352]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.352]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.352]             base::names(...future.oldOptions))
[17:00:28.352]     }
[17:00:28.352]     if (FALSE) {
[17:00:28.352]     }
[17:00:28.352]     else {
[17:00:28.352]         if (TRUE) {
[17:00:28.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.352]                 open = "w")
[17:00:28.352]         }
[17:00:28.352]         else {
[17:00:28.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.352]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.352]         }
[17:00:28.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.352]             base::sink(type = "output", split = FALSE)
[17:00:28.352]             base::close(...future.stdout)
[17:00:28.352]         }, add = TRUE)
[17:00:28.352]     }
[17:00:28.352]     ...future.frame <- base::sys.nframe()
[17:00:28.352]     ...future.conditions <- base::list()
[17:00:28.352]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.352]     if (FALSE) {
[17:00:28.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.352]     }
[17:00:28.352]     ...future.result <- base::tryCatch({
[17:00:28.352]         base::withCallingHandlers({
[17:00:28.352]             ...future.value <- base::withVisible(base::local({
[17:00:28.352]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.352]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.352]                   ...future.globals.maxSize)) {
[17:00:28.352]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.352]                   on.exit(options(oopts), add = TRUE)
[17:00:28.352]                 }
[17:00:28.352]                 {
[17:00:28.352]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.352]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.352]                     USE.NAMES = FALSE)
[17:00:28.352]                   do.call(mapply, args = args)
[17:00:28.352]                 }
[17:00:28.352]             }))
[17:00:28.352]             future::FutureResult(value = ...future.value$value, 
[17:00:28.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.352]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.352]                     ...future.globalenv.names))
[17:00:28.352]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.352]         }, condition = base::local({
[17:00:28.352]             c <- base::c
[17:00:28.352]             inherits <- base::inherits
[17:00:28.352]             invokeRestart <- base::invokeRestart
[17:00:28.352]             length <- base::length
[17:00:28.352]             list <- base::list
[17:00:28.352]             seq.int <- base::seq.int
[17:00:28.352]             signalCondition <- base::signalCondition
[17:00:28.352]             sys.calls <- base::sys.calls
[17:00:28.352]             `[[` <- base::`[[`
[17:00:28.352]             `+` <- base::`+`
[17:00:28.352]             `<<-` <- base::`<<-`
[17:00:28.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.352]                   3L)]
[17:00:28.352]             }
[17:00:28.352]             function(cond) {
[17:00:28.352]                 is_error <- inherits(cond, "error")
[17:00:28.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.352]                   NULL)
[17:00:28.352]                 if (is_error) {
[17:00:28.352]                   sessionInformation <- function() {
[17:00:28.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.352]                       search = base::search(), system = base::Sys.info())
[17:00:28.352]                   }
[17:00:28.352]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.352]                     cond$call), session = sessionInformation(), 
[17:00:28.352]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.352]                   signalCondition(cond)
[17:00:28.352]                 }
[17:00:28.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.352]                 "immediateCondition"))) {
[17:00:28.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.352]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.352]                   if (TRUE && !signal) {
[17:00:28.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.352]                     {
[17:00:28.352]                       inherits <- base::inherits
[17:00:28.352]                       invokeRestart <- base::invokeRestart
[17:00:28.352]                       is.null <- base::is.null
[17:00:28.352]                       muffled <- FALSE
[17:00:28.352]                       if (inherits(cond, "message")) {
[17:00:28.352]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.352]                         if (muffled) 
[17:00:28.352]                           invokeRestart("muffleMessage")
[17:00:28.352]                       }
[17:00:28.352]                       else if (inherits(cond, "warning")) {
[17:00:28.352]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.352]                         if (muffled) 
[17:00:28.352]                           invokeRestart("muffleWarning")
[17:00:28.352]                       }
[17:00:28.352]                       else if (inherits(cond, "condition")) {
[17:00:28.352]                         if (!is.null(pattern)) {
[17:00:28.352]                           computeRestarts <- base::computeRestarts
[17:00:28.352]                           grepl <- base::grepl
[17:00:28.352]                           restarts <- computeRestarts(cond)
[17:00:28.352]                           for (restart in restarts) {
[17:00:28.352]                             name <- restart$name
[17:00:28.352]                             if (is.null(name)) 
[17:00:28.352]                               next
[17:00:28.352]                             if (!grepl(pattern, name)) 
[17:00:28.352]                               next
[17:00:28.352]                             invokeRestart(restart)
[17:00:28.352]                             muffled <- TRUE
[17:00:28.352]                             break
[17:00:28.352]                           }
[17:00:28.352]                         }
[17:00:28.352]                       }
[17:00:28.352]                       invisible(muffled)
[17:00:28.352]                     }
[17:00:28.352]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.352]                   }
[17:00:28.352]                 }
[17:00:28.352]                 else {
[17:00:28.352]                   if (TRUE) {
[17:00:28.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.352]                     {
[17:00:28.352]                       inherits <- base::inherits
[17:00:28.352]                       invokeRestart <- base::invokeRestart
[17:00:28.352]                       is.null <- base::is.null
[17:00:28.352]                       muffled <- FALSE
[17:00:28.352]                       if (inherits(cond, "message")) {
[17:00:28.352]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.352]                         if (muffled) 
[17:00:28.352]                           invokeRestart("muffleMessage")
[17:00:28.352]                       }
[17:00:28.352]                       else if (inherits(cond, "warning")) {
[17:00:28.352]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.352]                         if (muffled) 
[17:00:28.352]                           invokeRestart("muffleWarning")
[17:00:28.352]                       }
[17:00:28.352]                       else if (inherits(cond, "condition")) {
[17:00:28.352]                         if (!is.null(pattern)) {
[17:00:28.352]                           computeRestarts <- base::computeRestarts
[17:00:28.352]                           grepl <- base::grepl
[17:00:28.352]                           restarts <- computeRestarts(cond)
[17:00:28.352]                           for (restart in restarts) {
[17:00:28.352]                             name <- restart$name
[17:00:28.352]                             if (is.null(name)) 
[17:00:28.352]                               next
[17:00:28.352]                             if (!grepl(pattern, name)) 
[17:00:28.352]                               next
[17:00:28.352]                             invokeRestart(restart)
[17:00:28.352]                             muffled <- TRUE
[17:00:28.352]                             break
[17:00:28.352]                           }
[17:00:28.352]                         }
[17:00:28.352]                       }
[17:00:28.352]                       invisible(muffled)
[17:00:28.352]                     }
[17:00:28.352]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.352]                   }
[17:00:28.352]                 }
[17:00:28.352]             }
[17:00:28.352]         }))
[17:00:28.352]     }, error = function(ex) {
[17:00:28.352]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.352]                 ...future.rng), started = ...future.startTime, 
[17:00:28.352]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.352]             version = "1.8"), class = "FutureResult")
[17:00:28.352]     }, finally = {
[17:00:28.352]         if (!identical(...future.workdir, getwd())) 
[17:00:28.352]             setwd(...future.workdir)
[17:00:28.352]         {
[17:00:28.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.352]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.352]             }
[17:00:28.352]             base::options(...future.oldOptions)
[17:00:28.352]             if (.Platform$OS.type == "windows") {
[17:00:28.352]                 old_names <- names(...future.oldEnvVars)
[17:00:28.352]                 envs <- base::Sys.getenv()
[17:00:28.352]                 names <- names(envs)
[17:00:28.352]                 common <- intersect(names, old_names)
[17:00:28.352]                 added <- setdiff(names, old_names)
[17:00:28.352]                 removed <- setdiff(old_names, names)
[17:00:28.352]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.352]                   envs[common]]
[17:00:28.352]                 NAMES <- toupper(changed)
[17:00:28.352]                 args <- list()
[17:00:28.352]                 for (kk in seq_along(NAMES)) {
[17:00:28.352]                   name <- changed[[kk]]
[17:00:28.352]                   NAME <- NAMES[[kk]]
[17:00:28.352]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.352]                     next
[17:00:28.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.352]                 }
[17:00:28.352]                 NAMES <- toupper(added)
[17:00:28.352]                 for (kk in seq_along(NAMES)) {
[17:00:28.352]                   name <- added[[kk]]
[17:00:28.352]                   NAME <- NAMES[[kk]]
[17:00:28.352]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.352]                     next
[17:00:28.352]                   args[[name]] <- ""
[17:00:28.352]                 }
[17:00:28.352]                 NAMES <- toupper(removed)
[17:00:28.352]                 for (kk in seq_along(NAMES)) {
[17:00:28.352]                   name <- removed[[kk]]
[17:00:28.352]                   NAME <- NAMES[[kk]]
[17:00:28.352]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.352]                     next
[17:00:28.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.352]                 }
[17:00:28.352]                 if (length(args) > 0) 
[17:00:28.352]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.352]             }
[17:00:28.352]             else {
[17:00:28.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.352]             }
[17:00:28.352]             {
[17:00:28.352]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.352]                   0L) {
[17:00:28.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.352]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.352]                   base::options(opts)
[17:00:28.352]                 }
[17:00:28.352]                 {
[17:00:28.352]                   {
[17:00:28.352]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.352]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.352]                     2054632538L), envir = base::globalenv(), 
[17:00:28.352]                       inherits = FALSE)
[17:00:28.352]                     NULL
[17:00:28.352]                   }
[17:00:28.352]                   options(future.plan = NULL)
[17:00:28.352]                   if (is.na(NA_character_)) 
[17:00:28.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.352]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.352]                     .init = FALSE)
[17:00:28.352]                 }
[17:00:28.352]             }
[17:00:28.352]         }
[17:00:28.352]     })
[17:00:28.352]     if (TRUE) {
[17:00:28.352]         base::sink(type = "output", split = FALSE)
[17:00:28.352]         if (TRUE) {
[17:00:28.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.352]         }
[17:00:28.352]         else {
[17:00:28.352]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.352]         }
[17:00:28.352]         base::close(...future.stdout)
[17:00:28.352]         ...future.stdout <- NULL
[17:00:28.352]     }
[17:00:28.352]     ...future.result$conditions <- ...future.conditions
[17:00:28.352]     ...future.result$finished <- base::Sys.time()
[17:00:28.352]     ...future.result
[17:00:28.352] }
[17:00:28.354] assign_globals() ...
[17:00:28.354] List of 5
[17:00:28.354]  $ ...future.FUN            :function (C, k)  
[17:00:28.354]  $ MoreArgs                 : list()
[17:00:28.354]  $ ...future.elements_ii    :List of 2
[17:00:28.354]   ..$ :List of 5
[17:00:28.354]   .. ..$ : chr "A"
[17:00:28.354]   .. ..$ : chr "B"
[17:00:28.354]   .. ..$ : chr "C"
[17:00:28.354]   .. ..$ : chr "D"
[17:00:28.354]   .. ..$ : chr "E"
[17:00:28.354]   ..$ :List of 5
[17:00:28.354]   .. ..$ : int 5
[17:00:28.354]   .. ..$ : int 4
[17:00:28.354]   .. ..$ : int 3
[17:00:28.354]   .. ..$ : int 2
[17:00:28.354]   .. ..$ : int 1
[17:00:28.354]  $ ...future.seeds_ii       : NULL
[17:00:28.354]  $ ...future.globals.maxSize: NULL
[17:00:28.354]  - attr(*, "where")=List of 5
[17:00:28.354]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.354]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.354]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.354]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.354]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.354]  - attr(*, "resolved")= logi FALSE
[17:00:28.354]  - attr(*, "total_size")= num 4160
[17:00:28.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.354]  - attr(*, "already-done")= logi TRUE
[17:00:28.361] - reassign environment for ‘...future.FUN’
[17:00:28.361] - copied ‘...future.FUN’ to environment
[17:00:28.361] - copied ‘MoreArgs’ to environment
[17:00:28.362] - copied ‘...future.elements_ii’ to environment
[17:00:28.363] - copied ‘...future.seeds_ii’ to environment
[17:00:28.363] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.364] assign_globals() ... done
[17:00:28.364] plan(): Setting new future strategy stack:
[17:00:28.364] List of future strategies:
[17:00:28.364] 1. sequential:
[17:00:28.364]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.364]    - tweaked: FALSE
[17:00:28.364]    - call: NULL
[17:00:28.365] plan(): nbrOfWorkers() = 1
[17:00:28.366] plan(): Setting new future strategy stack:
[17:00:28.366] List of future strategies:
[17:00:28.366] 1. sequential:
[17:00:28.366]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.366]    - tweaked: FALSE
[17:00:28.366]    - call: plan(strategy)
[17:00:28.366] plan(): nbrOfWorkers() = 1
[17:00:28.366] SequentialFuture started (and completed)
[17:00:28.366] - Launch lazy future ... done
[17:00:28.367] run() for ‘SequentialFuture’ ... done
[17:00:28.367] Created future:
[17:00:28.367] SequentialFuture:
[17:00:28.367] Label: ‘future_.mapply-1’
[17:00:28.367] Expression:
[17:00:28.367] {
[17:00:28.367]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.367]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.367]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.367]         on.exit(options(oopts), add = TRUE)
[17:00:28.367]     }
[17:00:28.367]     {
[17:00:28.367]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.367]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.367]         do.call(mapply, args = args)
[17:00:28.367]     }
[17:00:28.367] }
[17:00:28.367] Lazy evaluation: FALSE
[17:00:28.367] Asynchronous evaluation: FALSE
[17:00:28.367] Local evaluation: TRUE
[17:00:28.367] Environment: R_GlobalEnv
[17:00:28.367] Capture standard output: TRUE
[17:00:28.367] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.367] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.367] Packages: <none>
[17:00:28.367] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.367] Resolved: TRUE
[17:00:28.367] Value: 560 bytes of class ‘list’
[17:00:28.367] Early signaling: FALSE
[17:00:28.367] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.367] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.368] Chunk #1 of 1 ... DONE
[17:00:28.368] Launching 1 futures (chunks) ... DONE
[17:00:28.368] Resolving 1 futures (chunks) ...
[17:00:28.368] resolve() on list ...
[17:00:28.368]  recursive: 0
[17:00:28.368]  length: 1
[17:00:28.368] 
[17:00:28.368] resolved() for ‘SequentialFuture’ ...
[17:00:28.368] - state: ‘finished’
[17:00:28.369] - run: TRUE
[17:00:28.369] - result: ‘FutureResult’
[17:00:28.369] resolved() for ‘SequentialFuture’ ... done
[17:00:28.369] Future #1
[17:00:28.369] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.369] - nx: 1
[17:00:28.369] - relay: TRUE
[17:00:28.369] - stdout: TRUE
[17:00:28.369] - signal: TRUE
[17:00:28.369] - resignal: FALSE
[17:00:28.370] - force: TRUE
[17:00:28.370] - relayed: [n=1] FALSE
[17:00:28.370] - queued futures: [n=1] FALSE
[17:00:28.370]  - until=1
[17:00:28.370]  - relaying element #1
[17:00:28.370] - relayed: [n=1] TRUE
[17:00:28.370] - queued futures: [n=1] TRUE
[17:00:28.370] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.370]  length: 0 (resolved future 1)
[17:00:28.370] Relaying remaining futures
[17:00:28.371] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.371] - nx: 1
[17:00:28.371] - relay: TRUE
[17:00:28.371] - stdout: TRUE
[17:00:28.371] - signal: TRUE
[17:00:28.371] - resignal: FALSE
[17:00:28.371] - force: TRUE
[17:00:28.371] - relayed: [n=1] TRUE
[17:00:28.371] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.371] - relayed: [n=1] TRUE
[17:00:28.371] - queued futures: [n=1] TRUE
[17:00:28.372] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.372] resolve() on list ... DONE
[17:00:28.372]  - Number of value chunks collected: 1
[17:00:28.372] Resolving 1 futures (chunks) ... DONE
[17:00:28.372] Reducing values from 1 chunks ...
[17:00:28.372]  - Number of values collected after concatenation: 5
[17:00:28.372]  - Number of values expected: 5
[17:00:28.372] Reducing values from 1 chunks ... DONE
[17:00:28.372] future_mapply() ... DONE
[17:00:28.372] future_mapply() ...
[17:00:28.373] Number of chunks: 3
[17:00:28.373] Index remapping (attribute 'ordering'): [n = 5] 3, 4, 1, 5, 2
[17:00:28.373] getGlobalsAndPackagesXApply() ...
[17:00:28.373]  - future.globals: TRUE
[17:00:28.373] getGlobalsAndPackages() ...
[17:00:28.373] Searching for globals...
[17:00:28.375] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:28.375] Searching for globals ... DONE
[17:00:28.375] Resolving globals: FALSE
[17:00:28.375] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:28.376] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:28.376] - globals: [1] ‘FUN’
[17:00:28.376] 
[17:00:28.376] getGlobalsAndPackages() ... DONE
[17:00:28.376]  - globals found/used: [n=1] ‘FUN’
[17:00:28.376]  - needed namespaces: [n=0] 
[17:00:28.376] Finding globals ... DONE
[17:00:28.376] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.376] List of 2
[17:00:28.376]  $ ...future.FUN:function (C, k)  
[17:00:28.376]  $ MoreArgs     : NULL
[17:00:28.376]  - attr(*, "where")=List of 2
[17:00:28.376]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.376]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.376]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.376]  - attr(*, "resolved")= logi FALSE
[17:00:28.376]  - attr(*, "total_size")= num NA
[17:00:28.379] Packages to be attached in all futures: [n=0] 
[17:00:28.379] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.379] Number of futures (= number of chunks): 3
[17:00:28.379] Launching 3 futures (chunks) ...
[17:00:28.379] Chunk #1 of 3 ...
[17:00:28.380]  - Finding globals in '...' for chunk #1 ...
[17:00:28.380] getGlobalsAndPackages() ...
[17:00:28.380] Searching for globals...
[17:00:28.380] 
[17:00:28.380] Searching for globals ... DONE
[17:00:28.380] - globals: [0] <none>
[17:00:28.380] getGlobalsAndPackages() ... DONE
[17:00:28.380]    + additional globals found: [n=0] 
[17:00:28.381]    + additional namespaces needed: [n=0] 
[17:00:28.381]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.381]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:00:28.381]  - seeds: <none>
[17:00:28.381]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.381] getGlobalsAndPackages() ...
[17:00:28.381] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.381] Resolving globals: FALSE
[17:00:28.382] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:28.382] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.382] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.382] 
[17:00:28.383] getGlobalsAndPackages() ... DONE
[17:00:28.383] run() for ‘Future’ ...
[17:00:28.383] - state: ‘created’
[17:00:28.383] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.383] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.383] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.384]   - Field: ‘label’
[17:00:28.384]   - Field: ‘local’
[17:00:28.384]   - Field: ‘owner’
[17:00:28.384]   - Field: ‘envir’
[17:00:28.384]   - Field: ‘packages’
[17:00:28.384]   - Field: ‘gc’
[17:00:28.384]   - Field: ‘conditions’
[17:00:28.384]   - Field: ‘expr’
[17:00:28.384]   - Field: ‘uuid’
[17:00:28.384]   - Field: ‘seed’
[17:00:28.385]   - Field: ‘version’
[17:00:28.385]   - Field: ‘result’
[17:00:28.385]   - Field: ‘asynchronous’
[17:00:28.385]   - Field: ‘calls’
[17:00:28.385]   - Field: ‘globals’
[17:00:28.385]   - Field: ‘stdout’
[17:00:28.385]   - Field: ‘earlySignal’
[17:00:28.385]   - Field: ‘lazy’
[17:00:28.385]   - Field: ‘state’
[17:00:28.385] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.385] - Launch lazy future ...
[17:00:28.386] Packages needed by the future expression (n = 0): <none>
[17:00:28.386] Packages needed by future strategies (n = 0): <none>
[17:00:28.386] {
[17:00:28.386]     {
[17:00:28.386]         {
[17:00:28.386]             ...future.startTime <- base::Sys.time()
[17:00:28.386]             {
[17:00:28.386]                 {
[17:00:28.386]                   {
[17:00:28.386]                     base::local({
[17:00:28.386]                       has_future <- base::requireNamespace("future", 
[17:00:28.386]                         quietly = TRUE)
[17:00:28.386]                       if (has_future) {
[17:00:28.386]                         ns <- base::getNamespace("future")
[17:00:28.386]                         version <- ns[[".package"]][["version"]]
[17:00:28.386]                         if (is.null(version)) 
[17:00:28.386]                           version <- utils::packageVersion("future")
[17:00:28.386]                       }
[17:00:28.386]                       else {
[17:00:28.386]                         version <- NULL
[17:00:28.386]                       }
[17:00:28.386]                       if (!has_future || version < "1.8.0") {
[17:00:28.386]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.386]                           "", base::R.version$version.string), 
[17:00:28.386]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.386]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.386]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.386]                             "release", "version")], collapse = " "), 
[17:00:28.386]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.386]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.386]                           info)
[17:00:28.386]                         info <- base::paste(info, collapse = "; ")
[17:00:28.386]                         if (!has_future) {
[17:00:28.386]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.386]                             info)
[17:00:28.386]                         }
[17:00:28.386]                         else {
[17:00:28.386]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.386]                             info, version)
[17:00:28.386]                         }
[17:00:28.386]                         base::stop(msg)
[17:00:28.386]                       }
[17:00:28.386]                     })
[17:00:28.386]                   }
[17:00:28.386]                   ...future.strategy.old <- future::plan("list")
[17:00:28.386]                   options(future.plan = NULL)
[17:00:28.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.386]                 }
[17:00:28.386]                 ...future.workdir <- getwd()
[17:00:28.386]             }
[17:00:28.386]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.386]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.386]         }
[17:00:28.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.386]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:00:28.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.386]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.386]             base::names(...future.oldOptions))
[17:00:28.386]     }
[17:00:28.386]     if (FALSE) {
[17:00:28.386]     }
[17:00:28.386]     else {
[17:00:28.386]         if (TRUE) {
[17:00:28.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.386]                 open = "w")
[17:00:28.386]         }
[17:00:28.386]         else {
[17:00:28.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.386]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.386]         }
[17:00:28.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.386]             base::sink(type = "output", split = FALSE)
[17:00:28.386]             base::close(...future.stdout)
[17:00:28.386]         }, add = TRUE)
[17:00:28.386]     }
[17:00:28.386]     ...future.frame <- base::sys.nframe()
[17:00:28.386]     ...future.conditions <- base::list()
[17:00:28.386]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.386]     if (FALSE) {
[17:00:28.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.386]     }
[17:00:28.386]     ...future.result <- base::tryCatch({
[17:00:28.386]         base::withCallingHandlers({
[17:00:28.386]             ...future.value <- base::withVisible(base::local({
[17:00:28.386]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.386]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.386]                   ...future.globals.maxSize)) {
[17:00:28.386]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.386]                   on.exit(options(oopts), add = TRUE)
[17:00:28.386]                 }
[17:00:28.386]                 {
[17:00:28.386]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.386]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.386]                     USE.NAMES = FALSE)
[17:00:28.386]                   do.call(mapply, args = args)
[17:00:28.386]                 }
[17:00:28.386]             }))
[17:00:28.386]             future::FutureResult(value = ...future.value$value, 
[17:00:28.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.386]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.386]                     ...future.globalenv.names))
[17:00:28.386]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.386]         }, condition = base::local({
[17:00:28.386]             c <- base::c
[17:00:28.386]             inherits <- base::inherits
[17:00:28.386]             invokeRestart <- base::invokeRestart
[17:00:28.386]             length <- base::length
[17:00:28.386]             list <- base::list
[17:00:28.386]             seq.int <- base::seq.int
[17:00:28.386]             signalCondition <- base::signalCondition
[17:00:28.386]             sys.calls <- base::sys.calls
[17:00:28.386]             `[[` <- base::`[[`
[17:00:28.386]             `+` <- base::`+`
[17:00:28.386]             `<<-` <- base::`<<-`
[17:00:28.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.386]                   3L)]
[17:00:28.386]             }
[17:00:28.386]             function(cond) {
[17:00:28.386]                 is_error <- inherits(cond, "error")
[17:00:28.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.386]                   NULL)
[17:00:28.386]                 if (is_error) {
[17:00:28.386]                   sessionInformation <- function() {
[17:00:28.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.386]                       search = base::search(), system = base::Sys.info())
[17:00:28.386]                   }
[17:00:28.386]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.386]                     cond$call), session = sessionInformation(), 
[17:00:28.386]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.386]                   signalCondition(cond)
[17:00:28.386]                 }
[17:00:28.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.386]                 "immediateCondition"))) {
[17:00:28.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.386]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.386]                   if (TRUE && !signal) {
[17:00:28.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.386]                     {
[17:00:28.386]                       inherits <- base::inherits
[17:00:28.386]                       invokeRestart <- base::invokeRestart
[17:00:28.386]                       is.null <- base::is.null
[17:00:28.386]                       muffled <- FALSE
[17:00:28.386]                       if (inherits(cond, "message")) {
[17:00:28.386]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.386]                         if (muffled) 
[17:00:28.386]                           invokeRestart("muffleMessage")
[17:00:28.386]                       }
[17:00:28.386]                       else if (inherits(cond, "warning")) {
[17:00:28.386]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.386]                         if (muffled) 
[17:00:28.386]                           invokeRestart("muffleWarning")
[17:00:28.386]                       }
[17:00:28.386]                       else if (inherits(cond, "condition")) {
[17:00:28.386]                         if (!is.null(pattern)) {
[17:00:28.386]                           computeRestarts <- base::computeRestarts
[17:00:28.386]                           grepl <- base::grepl
[17:00:28.386]                           restarts <- computeRestarts(cond)
[17:00:28.386]                           for (restart in restarts) {
[17:00:28.386]                             name <- restart$name
[17:00:28.386]                             if (is.null(name)) 
[17:00:28.386]                               next
[17:00:28.386]                             if (!grepl(pattern, name)) 
[17:00:28.386]                               next
[17:00:28.386]                             invokeRestart(restart)
[17:00:28.386]                             muffled <- TRUE
[17:00:28.386]                             break
[17:00:28.386]                           }
[17:00:28.386]                         }
[17:00:28.386]                       }
[17:00:28.386]                       invisible(muffled)
[17:00:28.386]                     }
[17:00:28.386]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.386]                   }
[17:00:28.386]                 }
[17:00:28.386]                 else {
[17:00:28.386]                   if (TRUE) {
[17:00:28.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.386]                     {
[17:00:28.386]                       inherits <- base::inherits
[17:00:28.386]                       invokeRestart <- base::invokeRestart
[17:00:28.386]                       is.null <- base::is.null
[17:00:28.386]                       muffled <- FALSE
[17:00:28.386]                       if (inherits(cond, "message")) {
[17:00:28.386]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.386]                         if (muffled) 
[17:00:28.386]                           invokeRestart("muffleMessage")
[17:00:28.386]                       }
[17:00:28.386]                       else if (inherits(cond, "warning")) {
[17:00:28.386]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.386]                         if (muffled) 
[17:00:28.386]                           invokeRestart("muffleWarning")
[17:00:28.386]                       }
[17:00:28.386]                       else if (inherits(cond, "condition")) {
[17:00:28.386]                         if (!is.null(pattern)) {
[17:00:28.386]                           computeRestarts <- base::computeRestarts
[17:00:28.386]                           grepl <- base::grepl
[17:00:28.386]                           restarts <- computeRestarts(cond)
[17:00:28.386]                           for (restart in restarts) {
[17:00:28.386]                             name <- restart$name
[17:00:28.386]                             if (is.null(name)) 
[17:00:28.386]                               next
[17:00:28.386]                             if (!grepl(pattern, name)) 
[17:00:28.386]                               next
[17:00:28.386]                             invokeRestart(restart)
[17:00:28.386]                             muffled <- TRUE
[17:00:28.386]                             break
[17:00:28.386]                           }
[17:00:28.386]                         }
[17:00:28.386]                       }
[17:00:28.386]                       invisible(muffled)
[17:00:28.386]                     }
[17:00:28.386]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.386]                   }
[17:00:28.386]                 }
[17:00:28.386]             }
[17:00:28.386]         }))
[17:00:28.386]     }, error = function(ex) {
[17:00:28.386]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.386]                 ...future.rng), started = ...future.startTime, 
[17:00:28.386]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.386]             version = "1.8"), class = "FutureResult")
[17:00:28.386]     }, finally = {
[17:00:28.386]         if (!identical(...future.workdir, getwd())) 
[17:00:28.386]             setwd(...future.workdir)
[17:00:28.386]         {
[17:00:28.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.386]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.386]             }
[17:00:28.386]             base::options(...future.oldOptions)
[17:00:28.386]             if (.Platform$OS.type == "windows") {
[17:00:28.386]                 old_names <- names(...future.oldEnvVars)
[17:00:28.386]                 envs <- base::Sys.getenv()
[17:00:28.386]                 names <- names(envs)
[17:00:28.386]                 common <- intersect(names, old_names)
[17:00:28.386]                 added <- setdiff(names, old_names)
[17:00:28.386]                 removed <- setdiff(old_names, names)
[17:00:28.386]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.386]                   envs[common]]
[17:00:28.386]                 NAMES <- toupper(changed)
[17:00:28.386]                 args <- list()
[17:00:28.386]                 for (kk in seq_along(NAMES)) {
[17:00:28.386]                   name <- changed[[kk]]
[17:00:28.386]                   NAME <- NAMES[[kk]]
[17:00:28.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.386]                     next
[17:00:28.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.386]                 }
[17:00:28.386]                 NAMES <- toupper(added)
[17:00:28.386]                 for (kk in seq_along(NAMES)) {
[17:00:28.386]                   name <- added[[kk]]
[17:00:28.386]                   NAME <- NAMES[[kk]]
[17:00:28.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.386]                     next
[17:00:28.386]                   args[[name]] <- ""
[17:00:28.386]                 }
[17:00:28.386]                 NAMES <- toupper(removed)
[17:00:28.386]                 for (kk in seq_along(NAMES)) {
[17:00:28.386]                   name <- removed[[kk]]
[17:00:28.386]                   NAME <- NAMES[[kk]]
[17:00:28.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.386]                     next
[17:00:28.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.386]                 }
[17:00:28.386]                 if (length(args) > 0) 
[17:00:28.386]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.386]             }
[17:00:28.386]             else {
[17:00:28.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.386]             }
[17:00:28.386]             {
[17:00:28.386]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.386]                   0L) {
[17:00:28.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.386]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.386]                   base::options(opts)
[17:00:28.386]                 }
[17:00:28.386]                 {
[17:00:28.386]                   {
[17:00:28.386]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.386]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.386]                     2054632538L), envir = base::globalenv(), 
[17:00:28.386]                       inherits = FALSE)
[17:00:28.386]                     NULL
[17:00:28.386]                   }
[17:00:28.386]                   options(future.plan = NULL)
[17:00:28.386]                   if (is.na(NA_character_)) 
[17:00:28.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.386]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.386]                     .init = FALSE)
[17:00:28.386]                 }
[17:00:28.386]             }
[17:00:28.386]         }
[17:00:28.386]     })
[17:00:28.386]     if (TRUE) {
[17:00:28.386]         base::sink(type = "output", split = FALSE)
[17:00:28.386]         if (TRUE) {
[17:00:28.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.386]         }
[17:00:28.386]         else {
[17:00:28.386]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.386]         }
[17:00:28.386]         base::close(...future.stdout)
[17:00:28.386]         ...future.stdout <- NULL
[17:00:28.386]     }
[17:00:28.386]     ...future.result$conditions <- ...future.conditions
[17:00:28.386]     ...future.result$finished <- base::Sys.time()
[17:00:28.386]     ...future.result
[17:00:28.386] }
[17:00:28.388] assign_globals() ...
[17:00:28.388] List of 5
[17:00:28.388]  $ ...future.FUN            :function (C, k)  
[17:00:28.388]  $ MoreArgs                 : NULL
[17:00:28.388]  $ ...future.elements_ii    :List of 2
[17:00:28.388]   ..$ :List of 2
[17:00:28.388]   .. ..$ : chr "C"
[17:00:28.388]   .. ..$ : chr "D"
[17:00:28.388]   ..$ :List of 2
[17:00:28.388]   .. ..$ : int 3
[17:00:28.388]   .. ..$ : int 2
[17:00:28.388]  $ ...future.seeds_ii       : NULL
[17:00:28.388]  $ ...future.globals.maxSize: NULL
[17:00:28.388]  - attr(*, "where")=List of 5
[17:00:28.388]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.388]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.388]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.388]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.388]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.388]  - attr(*, "resolved")= logi FALSE
[17:00:28.388]  - attr(*, "total_size")= num 3656
[17:00:28.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.388]  - attr(*, "already-done")= logi TRUE
[17:00:28.396] - reassign environment for ‘...future.FUN’
[17:00:28.396] - copied ‘...future.FUN’ to environment
[17:00:28.396] - copied ‘MoreArgs’ to environment
[17:00:28.396] - copied ‘...future.elements_ii’ to environment
[17:00:28.396] - copied ‘...future.seeds_ii’ to environment
[17:00:28.396] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.396] assign_globals() ... done
[17:00:28.396] plan(): Setting new future strategy stack:
[17:00:28.396] List of future strategies:
[17:00:28.396] 1. sequential:
[17:00:28.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.396]    - tweaked: FALSE
[17:00:28.396]    - call: NULL
[17:00:28.397] plan(): nbrOfWorkers() = 1
[17:00:28.398] plan(): Setting new future strategy stack:
[17:00:28.398] List of future strategies:
[17:00:28.398] 1. sequential:
[17:00:28.398]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.398]    - tweaked: FALSE
[17:00:28.398]    - call: plan(strategy)
[17:00:28.398] plan(): nbrOfWorkers() = 1
[17:00:28.398] SequentialFuture started (and completed)
[17:00:28.398] - Launch lazy future ... done
[17:00:28.399] run() for ‘SequentialFuture’ ... done
[17:00:28.399] Created future:
[17:00:28.399] SequentialFuture:
[17:00:28.399] Label: ‘future_mapply-1’
[17:00:28.399] Expression:
[17:00:28.399] {
[17:00:28.399]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.399]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.399]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.399]         on.exit(options(oopts), add = TRUE)
[17:00:28.399]     }
[17:00:28.399]     {
[17:00:28.399]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.399]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.399]         do.call(mapply, args = args)
[17:00:28.399]     }
[17:00:28.399] }
[17:00:28.399] Lazy evaluation: FALSE
[17:00:28.399] Asynchronous evaluation: FALSE
[17:00:28.399] Local evaluation: TRUE
[17:00:28.399] Environment: R_GlobalEnv
[17:00:28.399] Capture standard output: TRUE
[17:00:28.399] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.399] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.399] Packages: <none>
[17:00:28.399] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.399] Resolved: TRUE
[17:00:28.399] Value: 224 bytes of class ‘list’
[17:00:28.399] Early signaling: FALSE
[17:00:28.399] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.399] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.400] Chunk #1 of 3 ... DONE
[17:00:28.400] Chunk #2 of 3 ...
[17:00:28.400]  - Finding globals in '...' for chunk #2 ...
[17:00:28.400] getGlobalsAndPackages() ...
[17:00:28.400] Searching for globals...
[17:00:28.400] 
[17:00:28.401] Searching for globals ... DONE
[17:00:28.401] - globals: [0] <none>
[17:00:28.401] getGlobalsAndPackages() ... DONE
[17:00:28.401]    + additional globals found: [n=0] 
[17:00:28.401]    + additional namespaces needed: [n=0] 
[17:00:28.401]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:28.401]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:00:28.401]  - seeds: <none>
[17:00:28.401]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.401] getGlobalsAndPackages() ...
[17:00:28.401] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.402] Resolving globals: FALSE
[17:00:28.402] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:28.402] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.403] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.403] 
[17:00:28.403] getGlobalsAndPackages() ... DONE
[17:00:28.403] run() for ‘Future’ ...
[17:00:28.403] - state: ‘created’
[17:00:28.403] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.403] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.404]   - Field: ‘label’
[17:00:28.404]   - Field: ‘local’
[17:00:28.404]   - Field: ‘owner’
[17:00:28.404]   - Field: ‘envir’
[17:00:28.404]   - Field: ‘packages’
[17:00:28.404]   - Field: ‘gc’
[17:00:28.404]   - Field: ‘conditions’
[17:00:28.404]   - Field: ‘expr’
[17:00:28.404]   - Field: ‘uuid’
[17:00:28.405]   - Field: ‘seed’
[17:00:28.405]   - Field: ‘version’
[17:00:28.405]   - Field: ‘result’
[17:00:28.405]   - Field: ‘asynchronous’
[17:00:28.405]   - Field: ‘calls’
[17:00:28.405]   - Field: ‘globals’
[17:00:28.405]   - Field: ‘stdout’
[17:00:28.405]   - Field: ‘earlySignal’
[17:00:28.405]   - Field: ‘lazy’
[17:00:28.405]   - Field: ‘state’
[17:00:28.405] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.406] - Launch lazy future ...
[17:00:28.406] Packages needed by the future expression (n = 0): <none>
[17:00:28.406] Packages needed by future strategies (n = 0): <none>
[17:00:28.406] {
[17:00:28.406]     {
[17:00:28.406]         {
[17:00:28.406]             ...future.startTime <- base::Sys.time()
[17:00:28.406]             {
[17:00:28.406]                 {
[17:00:28.406]                   {
[17:00:28.406]                     base::local({
[17:00:28.406]                       has_future <- base::requireNamespace("future", 
[17:00:28.406]                         quietly = TRUE)
[17:00:28.406]                       if (has_future) {
[17:00:28.406]                         ns <- base::getNamespace("future")
[17:00:28.406]                         version <- ns[[".package"]][["version"]]
[17:00:28.406]                         if (is.null(version)) 
[17:00:28.406]                           version <- utils::packageVersion("future")
[17:00:28.406]                       }
[17:00:28.406]                       else {
[17:00:28.406]                         version <- NULL
[17:00:28.406]                       }
[17:00:28.406]                       if (!has_future || version < "1.8.0") {
[17:00:28.406]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.406]                           "", base::R.version$version.string), 
[17:00:28.406]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.406]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.406]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.406]                             "release", "version")], collapse = " "), 
[17:00:28.406]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.406]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.406]                           info)
[17:00:28.406]                         info <- base::paste(info, collapse = "; ")
[17:00:28.406]                         if (!has_future) {
[17:00:28.406]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.406]                             info)
[17:00:28.406]                         }
[17:00:28.406]                         else {
[17:00:28.406]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.406]                             info, version)
[17:00:28.406]                         }
[17:00:28.406]                         base::stop(msg)
[17:00:28.406]                       }
[17:00:28.406]                     })
[17:00:28.406]                   }
[17:00:28.406]                   ...future.strategy.old <- future::plan("list")
[17:00:28.406]                   options(future.plan = NULL)
[17:00:28.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.406]                 }
[17:00:28.406]                 ...future.workdir <- getwd()
[17:00:28.406]             }
[17:00:28.406]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.406]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.406]         }
[17:00:28.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.406]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:00:28.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.406]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.406]             base::names(...future.oldOptions))
[17:00:28.406]     }
[17:00:28.406]     if (FALSE) {
[17:00:28.406]     }
[17:00:28.406]     else {
[17:00:28.406]         if (TRUE) {
[17:00:28.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.406]                 open = "w")
[17:00:28.406]         }
[17:00:28.406]         else {
[17:00:28.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.406]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.406]         }
[17:00:28.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.406]             base::sink(type = "output", split = FALSE)
[17:00:28.406]             base::close(...future.stdout)
[17:00:28.406]         }, add = TRUE)
[17:00:28.406]     }
[17:00:28.406]     ...future.frame <- base::sys.nframe()
[17:00:28.406]     ...future.conditions <- base::list()
[17:00:28.406]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.406]     if (FALSE) {
[17:00:28.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.406]     }
[17:00:28.406]     ...future.result <- base::tryCatch({
[17:00:28.406]         base::withCallingHandlers({
[17:00:28.406]             ...future.value <- base::withVisible(base::local({
[17:00:28.406]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.406]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.406]                   ...future.globals.maxSize)) {
[17:00:28.406]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.406]                   on.exit(options(oopts), add = TRUE)
[17:00:28.406]                 }
[17:00:28.406]                 {
[17:00:28.406]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.406]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.406]                     USE.NAMES = FALSE)
[17:00:28.406]                   do.call(mapply, args = args)
[17:00:28.406]                 }
[17:00:28.406]             }))
[17:00:28.406]             future::FutureResult(value = ...future.value$value, 
[17:00:28.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.406]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.406]                     ...future.globalenv.names))
[17:00:28.406]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.406]         }, condition = base::local({
[17:00:28.406]             c <- base::c
[17:00:28.406]             inherits <- base::inherits
[17:00:28.406]             invokeRestart <- base::invokeRestart
[17:00:28.406]             length <- base::length
[17:00:28.406]             list <- base::list
[17:00:28.406]             seq.int <- base::seq.int
[17:00:28.406]             signalCondition <- base::signalCondition
[17:00:28.406]             sys.calls <- base::sys.calls
[17:00:28.406]             `[[` <- base::`[[`
[17:00:28.406]             `+` <- base::`+`
[17:00:28.406]             `<<-` <- base::`<<-`
[17:00:28.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.406]                   3L)]
[17:00:28.406]             }
[17:00:28.406]             function(cond) {
[17:00:28.406]                 is_error <- inherits(cond, "error")
[17:00:28.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.406]                   NULL)
[17:00:28.406]                 if (is_error) {
[17:00:28.406]                   sessionInformation <- function() {
[17:00:28.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.406]                       search = base::search(), system = base::Sys.info())
[17:00:28.406]                   }
[17:00:28.406]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.406]                     cond$call), session = sessionInformation(), 
[17:00:28.406]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.406]                   signalCondition(cond)
[17:00:28.406]                 }
[17:00:28.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.406]                 "immediateCondition"))) {
[17:00:28.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.406]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.406]                   if (TRUE && !signal) {
[17:00:28.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.406]                     {
[17:00:28.406]                       inherits <- base::inherits
[17:00:28.406]                       invokeRestart <- base::invokeRestart
[17:00:28.406]                       is.null <- base::is.null
[17:00:28.406]                       muffled <- FALSE
[17:00:28.406]                       if (inherits(cond, "message")) {
[17:00:28.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.406]                         if (muffled) 
[17:00:28.406]                           invokeRestart("muffleMessage")
[17:00:28.406]                       }
[17:00:28.406]                       else if (inherits(cond, "warning")) {
[17:00:28.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.406]                         if (muffled) 
[17:00:28.406]                           invokeRestart("muffleWarning")
[17:00:28.406]                       }
[17:00:28.406]                       else if (inherits(cond, "condition")) {
[17:00:28.406]                         if (!is.null(pattern)) {
[17:00:28.406]                           computeRestarts <- base::computeRestarts
[17:00:28.406]                           grepl <- base::grepl
[17:00:28.406]                           restarts <- computeRestarts(cond)
[17:00:28.406]                           for (restart in restarts) {
[17:00:28.406]                             name <- restart$name
[17:00:28.406]                             if (is.null(name)) 
[17:00:28.406]                               next
[17:00:28.406]                             if (!grepl(pattern, name)) 
[17:00:28.406]                               next
[17:00:28.406]                             invokeRestart(restart)
[17:00:28.406]                             muffled <- TRUE
[17:00:28.406]                             break
[17:00:28.406]                           }
[17:00:28.406]                         }
[17:00:28.406]                       }
[17:00:28.406]                       invisible(muffled)
[17:00:28.406]                     }
[17:00:28.406]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.406]                   }
[17:00:28.406]                 }
[17:00:28.406]                 else {
[17:00:28.406]                   if (TRUE) {
[17:00:28.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.406]                     {
[17:00:28.406]                       inherits <- base::inherits
[17:00:28.406]                       invokeRestart <- base::invokeRestart
[17:00:28.406]                       is.null <- base::is.null
[17:00:28.406]                       muffled <- FALSE
[17:00:28.406]                       if (inherits(cond, "message")) {
[17:00:28.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.406]                         if (muffled) 
[17:00:28.406]                           invokeRestart("muffleMessage")
[17:00:28.406]                       }
[17:00:28.406]                       else if (inherits(cond, "warning")) {
[17:00:28.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.406]                         if (muffled) 
[17:00:28.406]                           invokeRestart("muffleWarning")
[17:00:28.406]                       }
[17:00:28.406]                       else if (inherits(cond, "condition")) {
[17:00:28.406]                         if (!is.null(pattern)) {
[17:00:28.406]                           computeRestarts <- base::computeRestarts
[17:00:28.406]                           grepl <- base::grepl
[17:00:28.406]                           restarts <- computeRestarts(cond)
[17:00:28.406]                           for (restart in restarts) {
[17:00:28.406]                             name <- restart$name
[17:00:28.406]                             if (is.null(name)) 
[17:00:28.406]                               next
[17:00:28.406]                             if (!grepl(pattern, name)) 
[17:00:28.406]                               next
[17:00:28.406]                             invokeRestart(restart)
[17:00:28.406]                             muffled <- TRUE
[17:00:28.406]                             break
[17:00:28.406]                           }
[17:00:28.406]                         }
[17:00:28.406]                       }
[17:00:28.406]                       invisible(muffled)
[17:00:28.406]                     }
[17:00:28.406]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.406]                   }
[17:00:28.406]                 }
[17:00:28.406]             }
[17:00:28.406]         }))
[17:00:28.406]     }, error = function(ex) {
[17:00:28.406]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.406]                 ...future.rng), started = ...future.startTime, 
[17:00:28.406]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.406]             version = "1.8"), class = "FutureResult")
[17:00:28.406]     }, finally = {
[17:00:28.406]         if (!identical(...future.workdir, getwd())) 
[17:00:28.406]             setwd(...future.workdir)
[17:00:28.406]         {
[17:00:28.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.406]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.406]             }
[17:00:28.406]             base::options(...future.oldOptions)
[17:00:28.406]             if (.Platform$OS.type == "windows") {
[17:00:28.406]                 old_names <- names(...future.oldEnvVars)
[17:00:28.406]                 envs <- base::Sys.getenv()
[17:00:28.406]                 names <- names(envs)
[17:00:28.406]                 common <- intersect(names, old_names)
[17:00:28.406]                 added <- setdiff(names, old_names)
[17:00:28.406]                 removed <- setdiff(old_names, names)
[17:00:28.406]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.406]                   envs[common]]
[17:00:28.406]                 NAMES <- toupper(changed)
[17:00:28.406]                 args <- list()
[17:00:28.406]                 for (kk in seq_along(NAMES)) {
[17:00:28.406]                   name <- changed[[kk]]
[17:00:28.406]                   NAME <- NAMES[[kk]]
[17:00:28.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.406]                     next
[17:00:28.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.406]                 }
[17:00:28.406]                 NAMES <- toupper(added)
[17:00:28.406]                 for (kk in seq_along(NAMES)) {
[17:00:28.406]                   name <- added[[kk]]
[17:00:28.406]                   NAME <- NAMES[[kk]]
[17:00:28.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.406]                     next
[17:00:28.406]                   args[[name]] <- ""
[17:00:28.406]                 }
[17:00:28.406]                 NAMES <- toupper(removed)
[17:00:28.406]                 for (kk in seq_along(NAMES)) {
[17:00:28.406]                   name <- removed[[kk]]
[17:00:28.406]                   NAME <- NAMES[[kk]]
[17:00:28.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.406]                     next
[17:00:28.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.406]                 }
[17:00:28.406]                 if (length(args) > 0) 
[17:00:28.406]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.406]             }
[17:00:28.406]             else {
[17:00:28.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.406]             }
[17:00:28.406]             {
[17:00:28.406]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.406]                   0L) {
[17:00:28.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.406]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.406]                   base::options(opts)
[17:00:28.406]                 }
[17:00:28.406]                 {
[17:00:28.406]                   {
[17:00:28.406]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.406]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.406]                     2054632538L), envir = base::globalenv(), 
[17:00:28.406]                       inherits = FALSE)
[17:00:28.406]                     NULL
[17:00:28.406]                   }
[17:00:28.406]                   options(future.plan = NULL)
[17:00:28.406]                   if (is.na(NA_character_)) 
[17:00:28.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.406]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.406]                     .init = FALSE)
[17:00:28.406]                 }
[17:00:28.406]             }
[17:00:28.406]         }
[17:00:28.406]     })
[17:00:28.406]     if (TRUE) {
[17:00:28.406]         base::sink(type = "output", split = FALSE)
[17:00:28.406]         if (TRUE) {
[17:00:28.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.406]         }
[17:00:28.406]         else {
[17:00:28.406]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.406]         }
[17:00:28.406]         base::close(...future.stdout)
[17:00:28.406]         ...future.stdout <- NULL
[17:00:28.406]     }
[17:00:28.406]     ...future.result$conditions <- ...future.conditions
[17:00:28.406]     ...future.result$finished <- base::Sys.time()
[17:00:28.406]     ...future.result
[17:00:28.406] }
[17:00:28.408] assign_globals() ...
[17:00:28.408] List of 5
[17:00:28.408]  $ ...future.FUN            :function (C, k)  
[17:00:28.408]  $ MoreArgs                 : NULL
[17:00:28.408]  $ ...future.elements_ii    :List of 2
[17:00:28.408]   ..$ :List of 1
[17:00:28.408]   .. ..$ : chr "A"
[17:00:28.408]   ..$ :List of 1
[17:00:28.408]   .. ..$ : int 5
[17:00:28.408]  $ ...future.seeds_ii       : NULL
[17:00:28.408]  $ ...future.globals.maxSize: NULL
[17:00:28.408]  - attr(*, "where")=List of 5
[17:00:28.408]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.408]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.408]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.408]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.408]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.408]  - attr(*, "resolved")= logi FALSE
[17:00:28.408]  - attr(*, "total_size")= num 3488
[17:00:28.408]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.408]  - attr(*, "already-done")= logi TRUE
[17:00:28.413] - reassign environment for ‘...future.FUN’
[17:00:28.413] - copied ‘...future.FUN’ to environment
[17:00:28.413] - copied ‘MoreArgs’ to environment
[17:00:28.413] - copied ‘...future.elements_ii’ to environment
[17:00:28.413] - copied ‘...future.seeds_ii’ to environment
[17:00:28.413] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.414] assign_globals() ... done
[17:00:28.414] plan(): Setting new future strategy stack:
[17:00:28.414] List of future strategies:
[17:00:28.414] 1. sequential:
[17:00:28.414]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.414]    - tweaked: FALSE
[17:00:28.414]    - call: NULL
[17:00:28.414] plan(): nbrOfWorkers() = 1
[17:00:28.415] plan(): Setting new future strategy stack:
[17:00:28.415] List of future strategies:
[17:00:28.415] 1. sequential:
[17:00:28.415]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.415]    - tweaked: FALSE
[17:00:28.415]    - call: plan(strategy)
[17:00:28.416] plan(): nbrOfWorkers() = 1
[17:00:28.416] SequentialFuture started (and completed)
[17:00:28.416] - Launch lazy future ... done
[17:00:28.416] run() for ‘SequentialFuture’ ... done
[17:00:28.416] Created future:
[17:00:28.416] SequentialFuture:
[17:00:28.416] Label: ‘future_mapply-2’
[17:00:28.416] Expression:
[17:00:28.416] {
[17:00:28.416]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.416]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.416]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.416]         on.exit(options(oopts), add = TRUE)
[17:00:28.416]     }
[17:00:28.416]     {
[17:00:28.416]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.416]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.416]         do.call(mapply, args = args)
[17:00:28.416]     }
[17:00:28.416] }
[17:00:28.416] Lazy evaluation: FALSE
[17:00:28.416] Asynchronous evaluation: FALSE
[17:00:28.416] Local evaluation: TRUE
[17:00:28.416] Environment: R_GlobalEnv
[17:00:28.416] Capture standard output: TRUE
[17:00:28.416] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.416] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.416] Packages: <none>
[17:00:28.416] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.416] Resolved: TRUE
[17:00:28.416] Value: 112 bytes of class ‘list’
[17:00:28.416] Early signaling: FALSE
[17:00:28.416] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.416] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.417] Chunk #2 of 3 ... DONE
[17:00:28.417] Chunk #3 of 3 ...
[17:00:28.419]  - Finding globals in '...' for chunk #3 ...
[17:00:28.419] getGlobalsAndPackages() ...
[17:00:28.419] Searching for globals...
[17:00:28.420] 
[17:00:28.420] Searching for globals ... DONE
[17:00:28.420] - globals: [0] <none>
[17:00:28.420] getGlobalsAndPackages() ... DONE
[17:00:28.420]    + additional globals found: [n=0] 
[17:00:28.420]    + additional namespaces needed: [n=0] 
[17:00:28.420]  - Finding globals in '...' for chunk #3 ... DONE
[17:00:28.421]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:00:28.421]  - seeds: <none>
[17:00:28.421]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.421] getGlobalsAndPackages() ...
[17:00:28.421] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.421] Resolving globals: FALSE
[17:00:28.422] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:28.422] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.422] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.422] 
[17:00:28.422] getGlobalsAndPackages() ... DONE
[17:00:28.423] run() for ‘Future’ ...
[17:00:28.423] - state: ‘created’
[17:00:28.423] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.423] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.423] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.423]   - Field: ‘label’
[17:00:28.424]   - Field: ‘local’
[17:00:28.424]   - Field: ‘owner’
[17:00:28.424]   - Field: ‘envir’
[17:00:28.424]   - Field: ‘packages’
[17:00:28.424]   - Field: ‘gc’
[17:00:28.424]   - Field: ‘conditions’
[17:00:28.424]   - Field: ‘expr’
[17:00:28.424]   - Field: ‘uuid’
[17:00:28.424]   - Field: ‘seed’
[17:00:28.424]   - Field: ‘version’
[17:00:28.424]   - Field: ‘result’
[17:00:28.425]   - Field: ‘asynchronous’
[17:00:28.425]   - Field: ‘calls’
[17:00:28.425]   - Field: ‘globals’
[17:00:28.425]   - Field: ‘stdout’
[17:00:28.425]   - Field: ‘earlySignal’
[17:00:28.425]   - Field: ‘lazy’
[17:00:28.425]   - Field: ‘state’
[17:00:28.425] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.425] - Launch lazy future ...
[17:00:28.425] Packages needed by the future expression (n = 0): <none>
[17:00:28.426] Packages needed by future strategies (n = 0): <none>
[17:00:28.426] {
[17:00:28.426]     {
[17:00:28.426]         {
[17:00:28.426]             ...future.startTime <- base::Sys.time()
[17:00:28.426]             {
[17:00:28.426]                 {
[17:00:28.426]                   {
[17:00:28.426]                     base::local({
[17:00:28.426]                       has_future <- base::requireNamespace("future", 
[17:00:28.426]                         quietly = TRUE)
[17:00:28.426]                       if (has_future) {
[17:00:28.426]                         ns <- base::getNamespace("future")
[17:00:28.426]                         version <- ns[[".package"]][["version"]]
[17:00:28.426]                         if (is.null(version)) 
[17:00:28.426]                           version <- utils::packageVersion("future")
[17:00:28.426]                       }
[17:00:28.426]                       else {
[17:00:28.426]                         version <- NULL
[17:00:28.426]                       }
[17:00:28.426]                       if (!has_future || version < "1.8.0") {
[17:00:28.426]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.426]                           "", base::R.version$version.string), 
[17:00:28.426]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.426]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.426]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.426]                             "release", "version")], collapse = " "), 
[17:00:28.426]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.426]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.426]                           info)
[17:00:28.426]                         info <- base::paste(info, collapse = "; ")
[17:00:28.426]                         if (!has_future) {
[17:00:28.426]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.426]                             info)
[17:00:28.426]                         }
[17:00:28.426]                         else {
[17:00:28.426]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.426]                             info, version)
[17:00:28.426]                         }
[17:00:28.426]                         base::stop(msg)
[17:00:28.426]                       }
[17:00:28.426]                     })
[17:00:28.426]                   }
[17:00:28.426]                   ...future.strategy.old <- future::plan("list")
[17:00:28.426]                   options(future.plan = NULL)
[17:00:28.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.426]                 }
[17:00:28.426]                 ...future.workdir <- getwd()
[17:00:28.426]             }
[17:00:28.426]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.426]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.426]         }
[17:00:28.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.426]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:00:28.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.426]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.426]             base::names(...future.oldOptions))
[17:00:28.426]     }
[17:00:28.426]     if (FALSE) {
[17:00:28.426]     }
[17:00:28.426]     else {
[17:00:28.426]         if (TRUE) {
[17:00:28.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.426]                 open = "w")
[17:00:28.426]         }
[17:00:28.426]         else {
[17:00:28.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.426]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.426]         }
[17:00:28.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.426]             base::sink(type = "output", split = FALSE)
[17:00:28.426]             base::close(...future.stdout)
[17:00:28.426]         }, add = TRUE)
[17:00:28.426]     }
[17:00:28.426]     ...future.frame <- base::sys.nframe()
[17:00:28.426]     ...future.conditions <- base::list()
[17:00:28.426]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.426]     if (FALSE) {
[17:00:28.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.426]     }
[17:00:28.426]     ...future.result <- base::tryCatch({
[17:00:28.426]         base::withCallingHandlers({
[17:00:28.426]             ...future.value <- base::withVisible(base::local({
[17:00:28.426]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.426]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.426]                   ...future.globals.maxSize)) {
[17:00:28.426]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.426]                   on.exit(options(oopts), add = TRUE)
[17:00:28.426]                 }
[17:00:28.426]                 {
[17:00:28.426]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.426]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.426]                     USE.NAMES = FALSE)
[17:00:28.426]                   do.call(mapply, args = args)
[17:00:28.426]                 }
[17:00:28.426]             }))
[17:00:28.426]             future::FutureResult(value = ...future.value$value, 
[17:00:28.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.426]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.426]                     ...future.globalenv.names))
[17:00:28.426]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.426]         }, condition = base::local({
[17:00:28.426]             c <- base::c
[17:00:28.426]             inherits <- base::inherits
[17:00:28.426]             invokeRestart <- base::invokeRestart
[17:00:28.426]             length <- base::length
[17:00:28.426]             list <- base::list
[17:00:28.426]             seq.int <- base::seq.int
[17:00:28.426]             signalCondition <- base::signalCondition
[17:00:28.426]             sys.calls <- base::sys.calls
[17:00:28.426]             `[[` <- base::`[[`
[17:00:28.426]             `+` <- base::`+`
[17:00:28.426]             `<<-` <- base::`<<-`
[17:00:28.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.426]                   3L)]
[17:00:28.426]             }
[17:00:28.426]             function(cond) {
[17:00:28.426]                 is_error <- inherits(cond, "error")
[17:00:28.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.426]                   NULL)
[17:00:28.426]                 if (is_error) {
[17:00:28.426]                   sessionInformation <- function() {
[17:00:28.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.426]                       search = base::search(), system = base::Sys.info())
[17:00:28.426]                   }
[17:00:28.426]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.426]                     cond$call), session = sessionInformation(), 
[17:00:28.426]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.426]                   signalCondition(cond)
[17:00:28.426]                 }
[17:00:28.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.426]                 "immediateCondition"))) {
[17:00:28.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.426]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.426]                   if (TRUE && !signal) {
[17:00:28.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.426]                     {
[17:00:28.426]                       inherits <- base::inherits
[17:00:28.426]                       invokeRestart <- base::invokeRestart
[17:00:28.426]                       is.null <- base::is.null
[17:00:28.426]                       muffled <- FALSE
[17:00:28.426]                       if (inherits(cond, "message")) {
[17:00:28.426]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.426]                         if (muffled) 
[17:00:28.426]                           invokeRestart("muffleMessage")
[17:00:28.426]                       }
[17:00:28.426]                       else if (inherits(cond, "warning")) {
[17:00:28.426]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.426]                         if (muffled) 
[17:00:28.426]                           invokeRestart("muffleWarning")
[17:00:28.426]                       }
[17:00:28.426]                       else if (inherits(cond, "condition")) {
[17:00:28.426]                         if (!is.null(pattern)) {
[17:00:28.426]                           computeRestarts <- base::computeRestarts
[17:00:28.426]                           grepl <- base::grepl
[17:00:28.426]                           restarts <- computeRestarts(cond)
[17:00:28.426]                           for (restart in restarts) {
[17:00:28.426]                             name <- restart$name
[17:00:28.426]                             if (is.null(name)) 
[17:00:28.426]                               next
[17:00:28.426]                             if (!grepl(pattern, name)) 
[17:00:28.426]                               next
[17:00:28.426]                             invokeRestart(restart)
[17:00:28.426]                             muffled <- TRUE
[17:00:28.426]                             break
[17:00:28.426]                           }
[17:00:28.426]                         }
[17:00:28.426]                       }
[17:00:28.426]                       invisible(muffled)
[17:00:28.426]                     }
[17:00:28.426]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.426]                   }
[17:00:28.426]                 }
[17:00:28.426]                 else {
[17:00:28.426]                   if (TRUE) {
[17:00:28.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.426]                     {
[17:00:28.426]                       inherits <- base::inherits
[17:00:28.426]                       invokeRestart <- base::invokeRestart
[17:00:28.426]                       is.null <- base::is.null
[17:00:28.426]                       muffled <- FALSE
[17:00:28.426]                       if (inherits(cond, "message")) {
[17:00:28.426]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.426]                         if (muffled) 
[17:00:28.426]                           invokeRestart("muffleMessage")
[17:00:28.426]                       }
[17:00:28.426]                       else if (inherits(cond, "warning")) {
[17:00:28.426]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.426]                         if (muffled) 
[17:00:28.426]                           invokeRestart("muffleWarning")
[17:00:28.426]                       }
[17:00:28.426]                       else if (inherits(cond, "condition")) {
[17:00:28.426]                         if (!is.null(pattern)) {
[17:00:28.426]                           computeRestarts <- base::computeRestarts
[17:00:28.426]                           grepl <- base::grepl
[17:00:28.426]                           restarts <- computeRestarts(cond)
[17:00:28.426]                           for (restart in restarts) {
[17:00:28.426]                             name <- restart$name
[17:00:28.426]                             if (is.null(name)) 
[17:00:28.426]                               next
[17:00:28.426]                             if (!grepl(pattern, name)) 
[17:00:28.426]                               next
[17:00:28.426]                             invokeRestart(restart)
[17:00:28.426]                             muffled <- TRUE
[17:00:28.426]                             break
[17:00:28.426]                           }
[17:00:28.426]                         }
[17:00:28.426]                       }
[17:00:28.426]                       invisible(muffled)
[17:00:28.426]                     }
[17:00:28.426]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.426]                   }
[17:00:28.426]                 }
[17:00:28.426]             }
[17:00:28.426]         }))
[17:00:28.426]     }, error = function(ex) {
[17:00:28.426]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.426]                 ...future.rng), started = ...future.startTime, 
[17:00:28.426]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.426]             version = "1.8"), class = "FutureResult")
[17:00:28.426]     }, finally = {
[17:00:28.426]         if (!identical(...future.workdir, getwd())) 
[17:00:28.426]             setwd(...future.workdir)
[17:00:28.426]         {
[17:00:28.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.426]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.426]             }
[17:00:28.426]             base::options(...future.oldOptions)
[17:00:28.426]             if (.Platform$OS.type == "windows") {
[17:00:28.426]                 old_names <- names(...future.oldEnvVars)
[17:00:28.426]                 envs <- base::Sys.getenv()
[17:00:28.426]                 names <- names(envs)
[17:00:28.426]                 common <- intersect(names, old_names)
[17:00:28.426]                 added <- setdiff(names, old_names)
[17:00:28.426]                 removed <- setdiff(old_names, names)
[17:00:28.426]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.426]                   envs[common]]
[17:00:28.426]                 NAMES <- toupper(changed)
[17:00:28.426]                 args <- list()
[17:00:28.426]                 for (kk in seq_along(NAMES)) {
[17:00:28.426]                   name <- changed[[kk]]
[17:00:28.426]                   NAME <- NAMES[[kk]]
[17:00:28.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.426]                     next
[17:00:28.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.426]                 }
[17:00:28.426]                 NAMES <- toupper(added)
[17:00:28.426]                 for (kk in seq_along(NAMES)) {
[17:00:28.426]                   name <- added[[kk]]
[17:00:28.426]                   NAME <- NAMES[[kk]]
[17:00:28.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.426]                     next
[17:00:28.426]                   args[[name]] <- ""
[17:00:28.426]                 }
[17:00:28.426]                 NAMES <- toupper(removed)
[17:00:28.426]                 for (kk in seq_along(NAMES)) {
[17:00:28.426]                   name <- removed[[kk]]
[17:00:28.426]                   NAME <- NAMES[[kk]]
[17:00:28.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.426]                     next
[17:00:28.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.426]                 }
[17:00:28.426]                 if (length(args) > 0) 
[17:00:28.426]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.426]             }
[17:00:28.426]             else {
[17:00:28.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.426]             }
[17:00:28.426]             {
[17:00:28.426]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.426]                   0L) {
[17:00:28.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.426]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.426]                   base::options(opts)
[17:00:28.426]                 }
[17:00:28.426]                 {
[17:00:28.426]                   {
[17:00:28.426]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.426]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.426]                     2054632538L), envir = base::globalenv(), 
[17:00:28.426]                       inherits = FALSE)
[17:00:28.426]                     NULL
[17:00:28.426]                   }
[17:00:28.426]                   options(future.plan = NULL)
[17:00:28.426]                   if (is.na(NA_character_)) 
[17:00:28.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.426]                     .init = FALSE)
[17:00:28.426]                 }
[17:00:28.426]             }
[17:00:28.426]         }
[17:00:28.426]     })
[17:00:28.426]     if (TRUE) {
[17:00:28.426]         base::sink(type = "output", split = FALSE)
[17:00:28.426]         if (TRUE) {
[17:00:28.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.426]         }
[17:00:28.426]         else {
[17:00:28.426]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.426]         }
[17:00:28.426]         base::close(...future.stdout)
[17:00:28.426]         ...future.stdout <- NULL
[17:00:28.426]     }
[17:00:28.426]     ...future.result$conditions <- ...future.conditions
[17:00:28.426]     ...future.result$finished <- base::Sys.time()
[17:00:28.426]     ...future.result
[17:00:28.426] }
[17:00:28.428] assign_globals() ...
[17:00:28.428] List of 5
[17:00:28.428]  $ ...future.FUN            :function (C, k)  
[17:00:28.428]  $ MoreArgs                 : NULL
[17:00:28.428]  $ ...future.elements_ii    :List of 2
[17:00:28.428]   ..$ :List of 2
[17:00:28.428]   .. ..$ : chr "E"
[17:00:28.428]   .. ..$ : chr "B"
[17:00:28.428]   ..$ :List of 2
[17:00:28.428]   .. ..$ : int 1
[17:00:28.428]   .. ..$ : int 4
[17:00:28.428]  $ ...future.seeds_ii       : NULL
[17:00:28.428]  $ ...future.globals.maxSize: NULL
[17:00:28.428]  - attr(*, "where")=List of 5
[17:00:28.428]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.428]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.428]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.428]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.428]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.428]  - attr(*, "resolved")= logi FALSE
[17:00:28.428]  - attr(*, "total_size")= num 3656
[17:00:28.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.428]  - attr(*, "already-done")= logi TRUE
[17:00:28.433] - reassign environment for ‘...future.FUN’
[17:00:28.434] - copied ‘...future.FUN’ to environment
[17:00:28.434] - copied ‘MoreArgs’ to environment
[17:00:28.434] - copied ‘...future.elements_ii’ to environment
[17:00:28.434] - copied ‘...future.seeds_ii’ to environment
[17:00:28.434] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.434] assign_globals() ... done
[17:00:28.435] plan(): Setting new future strategy stack:
[17:00:28.435] List of future strategies:
[17:00:28.435] 1. sequential:
[17:00:28.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.435]    - tweaked: FALSE
[17:00:28.435]    - call: NULL
[17:00:28.436] plan(): nbrOfWorkers() = 1
[17:00:28.436] plan(): Setting new future strategy stack:
[17:00:28.436] List of future strategies:
[17:00:28.436] 1. sequential:
[17:00:28.436]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.436]    - tweaked: FALSE
[17:00:28.436]    - call: plan(strategy)
[17:00:28.437] plan(): nbrOfWorkers() = 1
[17:00:28.437] SequentialFuture started (and completed)
[17:00:28.437] - Launch lazy future ... done
[17:00:28.437] run() for ‘SequentialFuture’ ... done
[17:00:28.437] Created future:
[17:00:28.437] SequentialFuture:
[17:00:28.437] Label: ‘future_mapply-3’
[17:00:28.437] Expression:
[17:00:28.437] {
[17:00:28.437]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.437]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.437]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.437]         on.exit(options(oopts), add = TRUE)
[17:00:28.437]     }
[17:00:28.437]     {
[17:00:28.437]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.437]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.437]         do.call(mapply, args = args)
[17:00:28.437]     }
[17:00:28.437] }
[17:00:28.437] Lazy evaluation: FALSE
[17:00:28.437] Asynchronous evaluation: FALSE
[17:00:28.437] Local evaluation: TRUE
[17:00:28.437] Environment: R_GlobalEnv
[17:00:28.437] Capture standard output: TRUE
[17:00:28.437] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.437] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.437] Packages: <none>
[17:00:28.437] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.437] Resolved: TRUE
[17:00:28.437] Value: 224 bytes of class ‘list’
[17:00:28.437] Early signaling: FALSE
[17:00:28.437] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.437] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.438] Chunk #3 of 3 ... DONE
[17:00:28.438] Launching 3 futures (chunks) ... DONE
[17:00:28.439] Resolving 3 futures (chunks) ...
[17:00:28.439] resolve() on list ...
[17:00:28.439]  recursive: 0
[17:00:28.439]  length: 3
[17:00:28.439] 
[17:00:28.439] resolved() for ‘SequentialFuture’ ...
[17:00:28.439] - state: ‘finished’
[17:00:28.439] - run: TRUE
[17:00:28.439] - result: ‘FutureResult’
[17:00:28.439] resolved() for ‘SequentialFuture’ ... done
[17:00:28.440] Future #1
[17:00:28.440] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.440] - nx: 3
[17:00:28.440] - relay: TRUE
[17:00:28.440] - stdout: TRUE
[17:00:28.440] - signal: TRUE
[17:00:28.440] - resignal: FALSE
[17:00:28.440] - force: TRUE
[17:00:28.440] - relayed: [n=3] FALSE, FALSE, FALSE
[17:00:28.440] - queued futures: [n=3] FALSE, FALSE, FALSE
[17:00:28.440]  - until=1
[17:00:28.441]  - relaying element #1
[17:00:28.441] - relayed: [n=3] TRUE, FALSE, FALSE
[17:00:28.441] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:00:28.441] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.441]  length: 2 (resolved future 1)
[17:00:28.441] resolved() for ‘SequentialFuture’ ...
[17:00:28.441] - state: ‘finished’
[17:00:28.441] - run: TRUE
[17:00:28.441] - result: ‘FutureResult’
[17:00:28.441] resolved() for ‘SequentialFuture’ ... done
[17:00:28.442] Future #2
[17:00:28.442] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:00:28.442] - nx: 3
[17:00:28.442] - relay: TRUE
[17:00:28.442] - stdout: TRUE
[17:00:28.442] - signal: TRUE
[17:00:28.442] - resignal: FALSE
[17:00:28.442] - force: TRUE
[17:00:28.442] - relayed: [n=3] TRUE, FALSE, FALSE
[17:00:28.442] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:00:28.442]  - until=2
[17:00:28.443]  - relaying element #2
[17:00:28.443] - relayed: [n=3] TRUE, TRUE, FALSE
[17:00:28.443] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:00:28.443] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:00:28.443]  length: 1 (resolved future 2)
[17:00:28.443] resolved() for ‘SequentialFuture’ ...
[17:00:28.443] - state: ‘finished’
[17:00:28.443] - run: TRUE
[17:00:28.443] - result: ‘FutureResult’
[17:00:28.444] resolved() for ‘SequentialFuture’ ... done
[17:00:28.444] Future #3
[17:00:28.444] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:00:28.444] - nx: 3
[17:00:28.444] - relay: TRUE
[17:00:28.444] - stdout: TRUE
[17:00:28.444] - signal: TRUE
[17:00:28.444] - resignal: FALSE
[17:00:28.444] - force: TRUE
[17:00:28.444] - relayed: [n=3] TRUE, TRUE, FALSE
[17:00:28.444] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:00:28.445]  - until=3
[17:00:28.445]  - relaying element #3
[17:00:28.445] - relayed: [n=3] TRUE, TRUE, TRUE
[17:00:28.445] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:00:28.445] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:00:28.445]  length: 0 (resolved future 3)
[17:00:28.445] Relaying remaining futures
[17:00:28.447] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.447] - nx: 3
[17:00:28.447] - relay: TRUE
[17:00:28.447] - stdout: TRUE
[17:00:28.447] - signal: TRUE
[17:00:28.447] - resignal: FALSE
[17:00:28.448] - force: TRUE
[17:00:28.448] - relayed: [n=3] TRUE, TRUE, TRUE
[17:00:28.448] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[17:00:28.448] - relayed: [n=3] TRUE, TRUE, TRUE
[17:00:28.448] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:00:28.448] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.448] resolve() on list ... DONE
[17:00:28.449]  - Number of value chunks collected: 3
[17:00:28.449] Resolving 3 futures (chunks) ... DONE
[17:00:28.449] Reducing values from 3 chunks ...
[17:00:28.449]  - Number of values collected after concatenation: 5
[17:00:28.449]  - Number of values expected: 5
[17:00:28.449] Reverse index remapping (attribute 'ordering'): [n = 5] 3, 5, 1, 2, 4
[17:00:28.449] Reducing values from 3 chunks ... DONE
[17:00:28.449] future_mapply() ... DONE
[17:00:28.450] future_mapply() ...
[17:00:28.450] Number of chunks: 1
[17:00:28.450] getGlobalsAndPackagesXApply() ...
[17:00:28.450]  - future.globals: TRUE
[17:00:28.450] getGlobalsAndPackages() ...
[17:00:28.450] Searching for globals...
[17:00:28.451] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:28.452] Searching for globals ... DONE
[17:00:28.452] Resolving globals: FALSE
[17:00:28.452] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:28.452] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:28.452] - globals: [1] ‘FUN’
[17:00:28.453] 
[17:00:28.453] getGlobalsAndPackages() ... DONE
[17:00:28.453]  - globals found/used: [n=1] ‘FUN’
[17:00:28.453]  - needed namespaces: [n=0] 
[17:00:28.453] Finding globals ... DONE
[17:00:28.453] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.453] List of 2
[17:00:28.453]  $ ...future.FUN:function (C, k)  
[17:00:28.453]  $ MoreArgs     : list()
[17:00:28.453]  - attr(*, "where")=List of 2
[17:00:28.453]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.453]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.453]  - attr(*, "resolved")= logi FALSE
[17:00:28.453]  - attr(*, "total_size")= num NA
[17:00:28.456] Packages to be attached in all futures: [n=0] 
[17:00:28.456] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.456] Number of futures (= number of chunks): 1
[17:00:28.456] Launching 1 futures (chunks) ...
[17:00:28.456] Chunk #1 of 1 ...
[17:00:28.456]  - Finding globals in '...' for chunk #1 ...
[17:00:28.456] getGlobalsAndPackages() ...
[17:00:28.456] Searching for globals...
[17:00:28.457] 
[17:00:28.457] Searching for globals ... DONE
[17:00:28.457] - globals: [0] <none>
[17:00:28.457] getGlobalsAndPackages() ... DONE
[17:00:28.457]    + additional globals found: [n=0] 
[17:00:28.457]    + additional namespaces needed: [n=0] 
[17:00:28.457]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.457]  - seeds: <none>
[17:00:28.458]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.458] getGlobalsAndPackages() ...
[17:00:28.458] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.458] Resolving globals: FALSE
[17:00:28.458] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[17:00:28.459] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:28.459] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.459] 
[17:00:28.459] getGlobalsAndPackages() ... DONE
[17:00:28.459] run() for ‘Future’ ...
[17:00:28.459] - state: ‘created’
[17:00:28.460] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.460] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.460]   - Field: ‘label’
[17:00:28.460]   - Field: ‘local’
[17:00:28.460]   - Field: ‘owner’
[17:00:28.460]   - Field: ‘envir’
[17:00:28.461]   - Field: ‘packages’
[17:00:28.461]   - Field: ‘gc’
[17:00:28.461]   - Field: ‘conditions’
[17:00:28.461]   - Field: ‘expr’
[17:00:28.461]   - Field: ‘uuid’
[17:00:28.461]   - Field: ‘seed’
[17:00:28.461]   - Field: ‘version’
[17:00:28.461]   - Field: ‘result’
[17:00:28.461]   - Field: ‘asynchronous’
[17:00:28.461]   - Field: ‘calls’
[17:00:28.461]   - Field: ‘globals’
[17:00:28.462]   - Field: ‘stdout’
[17:00:28.462]   - Field: ‘earlySignal’
[17:00:28.462]   - Field: ‘lazy’
[17:00:28.462]   - Field: ‘state’
[17:00:28.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.462] - Launch lazy future ...
[17:00:28.462] Packages needed by the future expression (n = 0): <none>
[17:00:28.462] Packages needed by future strategies (n = 0): <none>
[17:00:28.463] {
[17:00:28.463]     {
[17:00:28.463]         {
[17:00:28.463]             ...future.startTime <- base::Sys.time()
[17:00:28.463]             {
[17:00:28.463]                 {
[17:00:28.463]                   {
[17:00:28.463]                     base::local({
[17:00:28.463]                       has_future <- base::requireNamespace("future", 
[17:00:28.463]                         quietly = TRUE)
[17:00:28.463]                       if (has_future) {
[17:00:28.463]                         ns <- base::getNamespace("future")
[17:00:28.463]                         version <- ns[[".package"]][["version"]]
[17:00:28.463]                         if (is.null(version)) 
[17:00:28.463]                           version <- utils::packageVersion("future")
[17:00:28.463]                       }
[17:00:28.463]                       else {
[17:00:28.463]                         version <- NULL
[17:00:28.463]                       }
[17:00:28.463]                       if (!has_future || version < "1.8.0") {
[17:00:28.463]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.463]                           "", base::R.version$version.string), 
[17:00:28.463]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.463]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.463]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.463]                             "release", "version")], collapse = " "), 
[17:00:28.463]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.463]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.463]                           info)
[17:00:28.463]                         info <- base::paste(info, collapse = "; ")
[17:00:28.463]                         if (!has_future) {
[17:00:28.463]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.463]                             info)
[17:00:28.463]                         }
[17:00:28.463]                         else {
[17:00:28.463]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.463]                             info, version)
[17:00:28.463]                         }
[17:00:28.463]                         base::stop(msg)
[17:00:28.463]                       }
[17:00:28.463]                     })
[17:00:28.463]                   }
[17:00:28.463]                   ...future.strategy.old <- future::plan("list")
[17:00:28.463]                   options(future.plan = NULL)
[17:00:28.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.463]                 }
[17:00:28.463]                 ...future.workdir <- getwd()
[17:00:28.463]             }
[17:00:28.463]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.463]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.463]         }
[17:00:28.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.463]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.463]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.463]             base::names(...future.oldOptions))
[17:00:28.463]     }
[17:00:28.463]     if (FALSE) {
[17:00:28.463]     }
[17:00:28.463]     else {
[17:00:28.463]         if (TRUE) {
[17:00:28.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.463]                 open = "w")
[17:00:28.463]         }
[17:00:28.463]         else {
[17:00:28.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.463]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.463]         }
[17:00:28.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.463]             base::sink(type = "output", split = FALSE)
[17:00:28.463]             base::close(...future.stdout)
[17:00:28.463]         }, add = TRUE)
[17:00:28.463]     }
[17:00:28.463]     ...future.frame <- base::sys.nframe()
[17:00:28.463]     ...future.conditions <- base::list()
[17:00:28.463]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.463]     if (FALSE) {
[17:00:28.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.463]     }
[17:00:28.463]     ...future.result <- base::tryCatch({
[17:00:28.463]         base::withCallingHandlers({
[17:00:28.463]             ...future.value <- base::withVisible(base::local({
[17:00:28.463]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.463]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.463]                   ...future.globals.maxSize)) {
[17:00:28.463]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.463]                   on.exit(options(oopts), add = TRUE)
[17:00:28.463]                 }
[17:00:28.463]                 {
[17:00:28.463]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.463]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.463]                     USE.NAMES = FALSE)
[17:00:28.463]                   do.call(mapply, args = args)
[17:00:28.463]                 }
[17:00:28.463]             }))
[17:00:28.463]             future::FutureResult(value = ...future.value$value, 
[17:00:28.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.463]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.463]                     ...future.globalenv.names))
[17:00:28.463]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.463]         }, condition = base::local({
[17:00:28.463]             c <- base::c
[17:00:28.463]             inherits <- base::inherits
[17:00:28.463]             invokeRestart <- base::invokeRestart
[17:00:28.463]             length <- base::length
[17:00:28.463]             list <- base::list
[17:00:28.463]             seq.int <- base::seq.int
[17:00:28.463]             signalCondition <- base::signalCondition
[17:00:28.463]             sys.calls <- base::sys.calls
[17:00:28.463]             `[[` <- base::`[[`
[17:00:28.463]             `+` <- base::`+`
[17:00:28.463]             `<<-` <- base::`<<-`
[17:00:28.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.463]                   3L)]
[17:00:28.463]             }
[17:00:28.463]             function(cond) {
[17:00:28.463]                 is_error <- inherits(cond, "error")
[17:00:28.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.463]                   NULL)
[17:00:28.463]                 if (is_error) {
[17:00:28.463]                   sessionInformation <- function() {
[17:00:28.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.463]                       search = base::search(), system = base::Sys.info())
[17:00:28.463]                   }
[17:00:28.463]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.463]                     cond$call), session = sessionInformation(), 
[17:00:28.463]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.463]                   signalCondition(cond)
[17:00:28.463]                 }
[17:00:28.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.463]                 "immediateCondition"))) {
[17:00:28.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.463]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.463]                   if (TRUE && !signal) {
[17:00:28.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.463]                     {
[17:00:28.463]                       inherits <- base::inherits
[17:00:28.463]                       invokeRestart <- base::invokeRestart
[17:00:28.463]                       is.null <- base::is.null
[17:00:28.463]                       muffled <- FALSE
[17:00:28.463]                       if (inherits(cond, "message")) {
[17:00:28.463]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.463]                         if (muffled) 
[17:00:28.463]                           invokeRestart("muffleMessage")
[17:00:28.463]                       }
[17:00:28.463]                       else if (inherits(cond, "warning")) {
[17:00:28.463]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.463]                         if (muffled) 
[17:00:28.463]                           invokeRestart("muffleWarning")
[17:00:28.463]                       }
[17:00:28.463]                       else if (inherits(cond, "condition")) {
[17:00:28.463]                         if (!is.null(pattern)) {
[17:00:28.463]                           computeRestarts <- base::computeRestarts
[17:00:28.463]                           grepl <- base::grepl
[17:00:28.463]                           restarts <- computeRestarts(cond)
[17:00:28.463]                           for (restart in restarts) {
[17:00:28.463]                             name <- restart$name
[17:00:28.463]                             if (is.null(name)) 
[17:00:28.463]                               next
[17:00:28.463]                             if (!grepl(pattern, name)) 
[17:00:28.463]                               next
[17:00:28.463]                             invokeRestart(restart)
[17:00:28.463]                             muffled <- TRUE
[17:00:28.463]                             break
[17:00:28.463]                           }
[17:00:28.463]                         }
[17:00:28.463]                       }
[17:00:28.463]                       invisible(muffled)
[17:00:28.463]                     }
[17:00:28.463]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.463]                   }
[17:00:28.463]                 }
[17:00:28.463]                 else {
[17:00:28.463]                   if (TRUE) {
[17:00:28.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.463]                     {
[17:00:28.463]                       inherits <- base::inherits
[17:00:28.463]                       invokeRestart <- base::invokeRestart
[17:00:28.463]                       is.null <- base::is.null
[17:00:28.463]                       muffled <- FALSE
[17:00:28.463]                       if (inherits(cond, "message")) {
[17:00:28.463]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.463]                         if (muffled) 
[17:00:28.463]                           invokeRestart("muffleMessage")
[17:00:28.463]                       }
[17:00:28.463]                       else if (inherits(cond, "warning")) {
[17:00:28.463]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.463]                         if (muffled) 
[17:00:28.463]                           invokeRestart("muffleWarning")
[17:00:28.463]                       }
[17:00:28.463]                       else if (inherits(cond, "condition")) {
[17:00:28.463]                         if (!is.null(pattern)) {
[17:00:28.463]                           computeRestarts <- base::computeRestarts
[17:00:28.463]                           grepl <- base::grepl
[17:00:28.463]                           restarts <- computeRestarts(cond)
[17:00:28.463]                           for (restart in restarts) {
[17:00:28.463]                             name <- restart$name
[17:00:28.463]                             if (is.null(name)) 
[17:00:28.463]                               next
[17:00:28.463]                             if (!grepl(pattern, name)) 
[17:00:28.463]                               next
[17:00:28.463]                             invokeRestart(restart)
[17:00:28.463]                             muffled <- TRUE
[17:00:28.463]                             break
[17:00:28.463]                           }
[17:00:28.463]                         }
[17:00:28.463]                       }
[17:00:28.463]                       invisible(muffled)
[17:00:28.463]                     }
[17:00:28.463]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.463]                   }
[17:00:28.463]                 }
[17:00:28.463]             }
[17:00:28.463]         }))
[17:00:28.463]     }, error = function(ex) {
[17:00:28.463]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.463]                 ...future.rng), started = ...future.startTime, 
[17:00:28.463]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.463]             version = "1.8"), class = "FutureResult")
[17:00:28.463]     }, finally = {
[17:00:28.463]         if (!identical(...future.workdir, getwd())) 
[17:00:28.463]             setwd(...future.workdir)
[17:00:28.463]         {
[17:00:28.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.463]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.463]             }
[17:00:28.463]             base::options(...future.oldOptions)
[17:00:28.463]             if (.Platform$OS.type == "windows") {
[17:00:28.463]                 old_names <- names(...future.oldEnvVars)
[17:00:28.463]                 envs <- base::Sys.getenv()
[17:00:28.463]                 names <- names(envs)
[17:00:28.463]                 common <- intersect(names, old_names)
[17:00:28.463]                 added <- setdiff(names, old_names)
[17:00:28.463]                 removed <- setdiff(old_names, names)
[17:00:28.463]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.463]                   envs[common]]
[17:00:28.463]                 NAMES <- toupper(changed)
[17:00:28.463]                 args <- list()
[17:00:28.463]                 for (kk in seq_along(NAMES)) {
[17:00:28.463]                   name <- changed[[kk]]
[17:00:28.463]                   NAME <- NAMES[[kk]]
[17:00:28.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.463]                     next
[17:00:28.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.463]                 }
[17:00:28.463]                 NAMES <- toupper(added)
[17:00:28.463]                 for (kk in seq_along(NAMES)) {
[17:00:28.463]                   name <- added[[kk]]
[17:00:28.463]                   NAME <- NAMES[[kk]]
[17:00:28.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.463]                     next
[17:00:28.463]                   args[[name]] <- ""
[17:00:28.463]                 }
[17:00:28.463]                 NAMES <- toupper(removed)
[17:00:28.463]                 for (kk in seq_along(NAMES)) {
[17:00:28.463]                   name <- removed[[kk]]
[17:00:28.463]                   NAME <- NAMES[[kk]]
[17:00:28.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.463]                     next
[17:00:28.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.463]                 }
[17:00:28.463]                 if (length(args) > 0) 
[17:00:28.463]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.463]             }
[17:00:28.463]             else {
[17:00:28.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.463]             }
[17:00:28.463]             {
[17:00:28.463]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.463]                   0L) {
[17:00:28.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.463]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.463]                   base::options(opts)
[17:00:28.463]                 }
[17:00:28.463]                 {
[17:00:28.463]                   {
[17:00:28.463]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.463]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.463]                     2054632538L), envir = base::globalenv(), 
[17:00:28.463]                       inherits = FALSE)
[17:00:28.463]                     NULL
[17:00:28.463]                   }
[17:00:28.463]                   options(future.plan = NULL)
[17:00:28.463]                   if (is.na(NA_character_)) 
[17:00:28.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.463]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.463]                     .init = FALSE)
[17:00:28.463]                 }
[17:00:28.463]             }
[17:00:28.463]         }
[17:00:28.463]     })
[17:00:28.463]     if (TRUE) {
[17:00:28.463]         base::sink(type = "output", split = FALSE)
[17:00:28.463]         if (TRUE) {
[17:00:28.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.463]         }
[17:00:28.463]         else {
[17:00:28.463]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.463]         }
[17:00:28.463]         base::close(...future.stdout)
[17:00:28.463]         ...future.stdout <- NULL
[17:00:28.463]     }
[17:00:28.463]     ...future.result$conditions <- ...future.conditions
[17:00:28.463]     ...future.result$finished <- base::Sys.time()
[17:00:28.463]     ...future.result
[17:00:28.463] }
[17:00:28.464] assign_globals() ...
[17:00:28.465] List of 5
[17:00:28.465]  $ ...future.FUN            :function (C, k)  
[17:00:28.465]  $ MoreArgs                 : list()
[17:00:28.465]  $ ...future.elements_ii    :List of 2
[17:00:28.465]   ..$ :List of 5
[17:00:28.465]   .. ..$ : chr "A"
[17:00:28.465]   .. ..$ : chr "B"
[17:00:28.465]   .. ..$ : chr "C"
[17:00:28.465]   .. ..$ : chr "D"
[17:00:28.465]   .. ..$ : chr "E"
[17:00:28.465]   ..$ :List of 5
[17:00:28.465]   .. ..$ : int 5
[17:00:28.465]   .. ..$ : int 4
[17:00:28.465]   .. ..$ : int 3
[17:00:28.465]   .. ..$ : int 2
[17:00:28.465]   .. ..$ : int 1
[17:00:28.465]  $ ...future.seeds_ii       : NULL
[17:00:28.465]  $ ...future.globals.maxSize: NULL
[17:00:28.465]  - attr(*, "where")=List of 5
[17:00:28.465]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.465]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.465]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.465]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.465]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.465]  - attr(*, "resolved")= logi FALSE
[17:00:28.465]  - attr(*, "total_size")= num 4160
[17:00:28.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.465]  - attr(*, "already-done")= logi TRUE
[17:00:28.473] - reassign environment for ‘...future.FUN’
[17:00:28.473] - copied ‘...future.FUN’ to environment
[17:00:28.474] - copied ‘MoreArgs’ to environment
[17:00:28.474] - copied ‘...future.elements_ii’ to environment
[17:00:28.474] - copied ‘...future.seeds_ii’ to environment
[17:00:28.474] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.474] assign_globals() ... done
[17:00:28.474] plan(): Setting new future strategy stack:
[17:00:28.474] List of future strategies:
[17:00:28.474] 1. sequential:
[17:00:28.474]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.474]    - tweaked: FALSE
[17:00:28.474]    - call: NULL
[17:00:28.475] plan(): nbrOfWorkers() = 1
[17:00:28.476] plan(): Setting new future strategy stack:
[17:00:28.476] List of future strategies:
[17:00:28.476] 1. sequential:
[17:00:28.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.476]    - tweaked: FALSE
[17:00:28.476]    - call: plan(strategy)
[17:00:28.477] plan(): nbrOfWorkers() = 1
[17:00:28.477] SequentialFuture started (and completed)
[17:00:28.477] - Launch lazy future ... done
[17:00:28.477] run() for ‘SequentialFuture’ ... done
[17:00:28.477] Created future:
[17:00:28.477] SequentialFuture:
[17:00:28.477] Label: ‘future_.mapply-1’
[17:00:28.477] Expression:
[17:00:28.477] {
[17:00:28.477]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.477]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.477]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.477]         on.exit(options(oopts), add = TRUE)
[17:00:28.477]     }
[17:00:28.477]     {
[17:00:28.477]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.477]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.477]         do.call(mapply, args = args)
[17:00:28.477]     }
[17:00:28.477] }
[17:00:28.477] Lazy evaluation: FALSE
[17:00:28.477] Asynchronous evaluation: FALSE
[17:00:28.477] Local evaluation: TRUE
[17:00:28.477] Environment: R_GlobalEnv
[17:00:28.477] Capture standard output: TRUE
[17:00:28.477] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.477] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.477] Packages: <none>
[17:00:28.477] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.477] Resolved: TRUE
[17:00:28.477] Value: 560 bytes of class ‘list’
[17:00:28.477] Early signaling: FALSE
[17:00:28.477] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.477] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.478] Chunk #1 of 1 ... DONE
[17:00:28.478] Launching 1 futures (chunks) ... DONE
[17:00:28.478] Resolving 1 futures (chunks) ...
[17:00:28.478] resolve() on list ...
[17:00:28.479]  recursive: 0
[17:00:28.479]  length: 1
[17:00:28.479] 
[17:00:28.479] resolved() for ‘SequentialFuture’ ...
[17:00:28.479] - state: ‘finished’
[17:00:28.479] - run: TRUE
[17:00:28.479] - result: ‘FutureResult’
[17:00:28.479] resolved() for ‘SequentialFuture’ ... done
[17:00:28.479] Future #1
[17:00:28.479] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.480] - nx: 1
[17:00:28.480] - relay: TRUE
[17:00:28.480] - stdout: TRUE
[17:00:28.480] - signal: TRUE
[17:00:28.480] - resignal: FALSE
[17:00:28.480] - force: TRUE
[17:00:28.480] - relayed: [n=1] FALSE
[17:00:28.480] - queued futures: [n=1] FALSE
[17:00:28.480]  - until=1
[17:00:28.480]  - relaying element #1
[17:00:28.481] - relayed: [n=1] TRUE
[17:00:28.481] - queued futures: [n=1] TRUE
[17:00:28.481] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.481]  length: 0 (resolved future 1)
[17:00:28.481] Relaying remaining futures
[17:00:28.481] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.481] - nx: 1
[17:00:28.481] - relay: TRUE
[17:00:28.481] - stdout: TRUE
[17:00:28.481] - signal: TRUE
[17:00:28.481] - resignal: FALSE
[17:00:28.481] - force: TRUE
[17:00:28.482] - relayed: [n=1] TRUE
[17:00:28.482] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.482] - relayed: [n=1] TRUE
[17:00:28.482] - queued futures: [n=1] TRUE
[17:00:28.482] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.482] resolve() on list ... DONE
[17:00:28.482]  - Number of value chunks collected: 1
[17:00:28.482] Resolving 1 futures (chunks) ... DONE
[17:00:28.482] Reducing values from 1 chunks ...
[17:00:28.482]  - Number of values collected after concatenation: 5
[17:00:28.483]  - Number of values expected: 5
[17:00:28.483] Reducing values from 1 chunks ... DONE
[17:00:28.483] future_mapply() ... DONE
[17:00:28.483] future_mapply() ...
[17:00:28.483] Number of chunks: 2
[17:00:28.484] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:00:28.484] getGlobalsAndPackagesXApply() ...
[17:00:28.484]  - future.globals: TRUE
[17:00:28.484] getGlobalsAndPackages() ...
[17:00:28.484] Searching for globals...
[17:00:28.485] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:28.485] Searching for globals ... DONE
[17:00:28.485] Resolving globals: FALSE
[17:00:28.486] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:28.486] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:28.486] - globals: [1] ‘FUN’
[17:00:28.486] 
[17:00:28.486] getGlobalsAndPackages() ... DONE
[17:00:28.486]  - globals found/used: [n=1] ‘FUN’
[17:00:28.487]  - needed namespaces: [n=0] 
[17:00:28.487] Finding globals ... DONE
[17:00:28.487] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.487] List of 2
[17:00:28.487]  $ ...future.FUN:function (C, k)  
[17:00:28.487]  $ MoreArgs     : NULL
[17:00:28.487]  - attr(*, "where")=List of 2
[17:00:28.487]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.487]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.487]  - attr(*, "resolved")= logi FALSE
[17:00:28.487]  - attr(*, "total_size")= num NA
[17:00:28.489] Packages to be attached in all futures: [n=0] 
[17:00:28.489] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.490] Number of futures (= number of chunks): 2
[17:00:28.490] Launching 2 futures (chunks) ...
[17:00:28.490] Chunk #1 of 2 ...
[17:00:28.490]  - Finding globals in '...' for chunk #1 ...
[17:00:28.490] getGlobalsAndPackages() ...
[17:00:28.490] Searching for globals...
[17:00:28.490] 
[17:00:28.491] Searching for globals ... DONE
[17:00:28.491] - globals: [0] <none>
[17:00:28.491] getGlobalsAndPackages() ... DONE
[17:00:28.491]    + additional globals found: [n=0] 
[17:00:28.491]    + additional namespaces needed: [n=0] 
[17:00:28.491]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.491]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:28.491]  - seeds: <none>
[17:00:28.491]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.491] getGlobalsAndPackages() ...
[17:00:28.491] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.492] Resolving globals: FALSE
[17:00:28.492] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:28.492] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.493] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.493] 
[17:00:28.493] getGlobalsAndPackages() ... DONE
[17:00:28.493] run() for ‘Future’ ...
[17:00:28.493] - state: ‘created’
[17:00:28.493] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.494] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.494] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.494]   - Field: ‘label’
[17:00:28.494]   - Field: ‘local’
[17:00:28.494]   - Field: ‘owner’
[17:00:28.494]   - Field: ‘envir’
[17:00:28.494]   - Field: ‘packages’
[17:00:28.494]   - Field: ‘gc’
[17:00:28.494]   - Field: ‘conditions’
[17:00:28.495]   - Field: ‘expr’
[17:00:28.495]   - Field: ‘uuid’
[17:00:28.495]   - Field: ‘seed’
[17:00:28.495]   - Field: ‘version’
[17:00:28.495]   - Field: ‘result’
[17:00:28.495]   - Field: ‘asynchronous’
[17:00:28.495]   - Field: ‘calls’
[17:00:28.495]   - Field: ‘globals’
[17:00:28.495]   - Field: ‘stdout’
[17:00:28.495]   - Field: ‘earlySignal’
[17:00:28.495]   - Field: ‘lazy’
[17:00:28.496]   - Field: ‘state’
[17:00:28.496] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.496] - Launch lazy future ...
[17:00:28.496] Packages needed by the future expression (n = 0): <none>
[17:00:28.496] Packages needed by future strategies (n = 0): <none>
[17:00:28.496] {
[17:00:28.496]     {
[17:00:28.496]         {
[17:00:28.496]             ...future.startTime <- base::Sys.time()
[17:00:28.496]             {
[17:00:28.496]                 {
[17:00:28.496]                   {
[17:00:28.496]                     base::local({
[17:00:28.496]                       has_future <- base::requireNamespace("future", 
[17:00:28.496]                         quietly = TRUE)
[17:00:28.496]                       if (has_future) {
[17:00:28.496]                         ns <- base::getNamespace("future")
[17:00:28.496]                         version <- ns[[".package"]][["version"]]
[17:00:28.496]                         if (is.null(version)) 
[17:00:28.496]                           version <- utils::packageVersion("future")
[17:00:28.496]                       }
[17:00:28.496]                       else {
[17:00:28.496]                         version <- NULL
[17:00:28.496]                       }
[17:00:28.496]                       if (!has_future || version < "1.8.0") {
[17:00:28.496]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.496]                           "", base::R.version$version.string), 
[17:00:28.496]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.496]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.496]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.496]                             "release", "version")], collapse = " "), 
[17:00:28.496]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.496]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.496]                           info)
[17:00:28.496]                         info <- base::paste(info, collapse = "; ")
[17:00:28.496]                         if (!has_future) {
[17:00:28.496]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.496]                             info)
[17:00:28.496]                         }
[17:00:28.496]                         else {
[17:00:28.496]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.496]                             info, version)
[17:00:28.496]                         }
[17:00:28.496]                         base::stop(msg)
[17:00:28.496]                       }
[17:00:28.496]                     })
[17:00:28.496]                   }
[17:00:28.496]                   ...future.strategy.old <- future::plan("list")
[17:00:28.496]                   options(future.plan = NULL)
[17:00:28.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.496]                 }
[17:00:28.496]                 ...future.workdir <- getwd()
[17:00:28.496]             }
[17:00:28.496]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.496]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.496]         }
[17:00:28.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.496]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:28.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.496]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.496]             base::names(...future.oldOptions))
[17:00:28.496]     }
[17:00:28.496]     if (FALSE) {
[17:00:28.496]     }
[17:00:28.496]     else {
[17:00:28.496]         if (TRUE) {
[17:00:28.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.496]                 open = "w")
[17:00:28.496]         }
[17:00:28.496]         else {
[17:00:28.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.496]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.496]         }
[17:00:28.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.496]             base::sink(type = "output", split = FALSE)
[17:00:28.496]             base::close(...future.stdout)
[17:00:28.496]         }, add = TRUE)
[17:00:28.496]     }
[17:00:28.496]     ...future.frame <- base::sys.nframe()
[17:00:28.496]     ...future.conditions <- base::list()
[17:00:28.496]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.496]     if (FALSE) {
[17:00:28.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.496]     }
[17:00:28.496]     ...future.result <- base::tryCatch({
[17:00:28.496]         base::withCallingHandlers({
[17:00:28.496]             ...future.value <- base::withVisible(base::local({
[17:00:28.496]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.496]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.496]                   ...future.globals.maxSize)) {
[17:00:28.496]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.496]                   on.exit(options(oopts), add = TRUE)
[17:00:28.496]                 }
[17:00:28.496]                 {
[17:00:28.496]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.496]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.496]                     USE.NAMES = FALSE)
[17:00:28.496]                   do.call(mapply, args = args)
[17:00:28.496]                 }
[17:00:28.496]             }))
[17:00:28.496]             future::FutureResult(value = ...future.value$value, 
[17:00:28.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.496]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.496]                     ...future.globalenv.names))
[17:00:28.496]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.496]         }, condition = base::local({
[17:00:28.496]             c <- base::c
[17:00:28.496]             inherits <- base::inherits
[17:00:28.496]             invokeRestart <- base::invokeRestart
[17:00:28.496]             length <- base::length
[17:00:28.496]             list <- base::list
[17:00:28.496]             seq.int <- base::seq.int
[17:00:28.496]             signalCondition <- base::signalCondition
[17:00:28.496]             sys.calls <- base::sys.calls
[17:00:28.496]             `[[` <- base::`[[`
[17:00:28.496]             `+` <- base::`+`
[17:00:28.496]             `<<-` <- base::`<<-`
[17:00:28.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.496]                   3L)]
[17:00:28.496]             }
[17:00:28.496]             function(cond) {
[17:00:28.496]                 is_error <- inherits(cond, "error")
[17:00:28.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.496]                   NULL)
[17:00:28.496]                 if (is_error) {
[17:00:28.496]                   sessionInformation <- function() {
[17:00:28.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.496]                       search = base::search(), system = base::Sys.info())
[17:00:28.496]                   }
[17:00:28.496]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.496]                     cond$call), session = sessionInformation(), 
[17:00:28.496]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.496]                   signalCondition(cond)
[17:00:28.496]                 }
[17:00:28.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.496]                 "immediateCondition"))) {
[17:00:28.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.496]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.496]                   if (TRUE && !signal) {
[17:00:28.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.496]                     {
[17:00:28.496]                       inherits <- base::inherits
[17:00:28.496]                       invokeRestart <- base::invokeRestart
[17:00:28.496]                       is.null <- base::is.null
[17:00:28.496]                       muffled <- FALSE
[17:00:28.496]                       if (inherits(cond, "message")) {
[17:00:28.496]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.496]                         if (muffled) 
[17:00:28.496]                           invokeRestart("muffleMessage")
[17:00:28.496]                       }
[17:00:28.496]                       else if (inherits(cond, "warning")) {
[17:00:28.496]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.496]                         if (muffled) 
[17:00:28.496]                           invokeRestart("muffleWarning")
[17:00:28.496]                       }
[17:00:28.496]                       else if (inherits(cond, "condition")) {
[17:00:28.496]                         if (!is.null(pattern)) {
[17:00:28.496]                           computeRestarts <- base::computeRestarts
[17:00:28.496]                           grepl <- base::grepl
[17:00:28.496]                           restarts <- computeRestarts(cond)
[17:00:28.496]                           for (restart in restarts) {
[17:00:28.496]                             name <- restart$name
[17:00:28.496]                             if (is.null(name)) 
[17:00:28.496]                               next
[17:00:28.496]                             if (!grepl(pattern, name)) 
[17:00:28.496]                               next
[17:00:28.496]                             invokeRestart(restart)
[17:00:28.496]                             muffled <- TRUE
[17:00:28.496]                             break
[17:00:28.496]                           }
[17:00:28.496]                         }
[17:00:28.496]                       }
[17:00:28.496]                       invisible(muffled)
[17:00:28.496]                     }
[17:00:28.496]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.496]                   }
[17:00:28.496]                 }
[17:00:28.496]                 else {
[17:00:28.496]                   if (TRUE) {
[17:00:28.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.496]                     {
[17:00:28.496]                       inherits <- base::inherits
[17:00:28.496]                       invokeRestart <- base::invokeRestart
[17:00:28.496]                       is.null <- base::is.null
[17:00:28.496]                       muffled <- FALSE
[17:00:28.496]                       if (inherits(cond, "message")) {
[17:00:28.496]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.496]                         if (muffled) 
[17:00:28.496]                           invokeRestart("muffleMessage")
[17:00:28.496]                       }
[17:00:28.496]                       else if (inherits(cond, "warning")) {
[17:00:28.496]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.496]                         if (muffled) 
[17:00:28.496]                           invokeRestart("muffleWarning")
[17:00:28.496]                       }
[17:00:28.496]                       else if (inherits(cond, "condition")) {
[17:00:28.496]                         if (!is.null(pattern)) {
[17:00:28.496]                           computeRestarts <- base::computeRestarts
[17:00:28.496]                           grepl <- base::grepl
[17:00:28.496]                           restarts <- computeRestarts(cond)
[17:00:28.496]                           for (restart in restarts) {
[17:00:28.496]                             name <- restart$name
[17:00:28.496]                             if (is.null(name)) 
[17:00:28.496]                               next
[17:00:28.496]                             if (!grepl(pattern, name)) 
[17:00:28.496]                               next
[17:00:28.496]                             invokeRestart(restart)
[17:00:28.496]                             muffled <- TRUE
[17:00:28.496]                             break
[17:00:28.496]                           }
[17:00:28.496]                         }
[17:00:28.496]                       }
[17:00:28.496]                       invisible(muffled)
[17:00:28.496]                     }
[17:00:28.496]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.496]                   }
[17:00:28.496]                 }
[17:00:28.496]             }
[17:00:28.496]         }))
[17:00:28.496]     }, error = function(ex) {
[17:00:28.496]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.496]                 ...future.rng), started = ...future.startTime, 
[17:00:28.496]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.496]             version = "1.8"), class = "FutureResult")
[17:00:28.496]     }, finally = {
[17:00:28.496]         if (!identical(...future.workdir, getwd())) 
[17:00:28.496]             setwd(...future.workdir)
[17:00:28.496]         {
[17:00:28.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.496]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.496]             }
[17:00:28.496]             base::options(...future.oldOptions)
[17:00:28.496]             if (.Platform$OS.type == "windows") {
[17:00:28.496]                 old_names <- names(...future.oldEnvVars)
[17:00:28.496]                 envs <- base::Sys.getenv()
[17:00:28.496]                 names <- names(envs)
[17:00:28.496]                 common <- intersect(names, old_names)
[17:00:28.496]                 added <- setdiff(names, old_names)
[17:00:28.496]                 removed <- setdiff(old_names, names)
[17:00:28.496]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.496]                   envs[common]]
[17:00:28.496]                 NAMES <- toupper(changed)
[17:00:28.496]                 args <- list()
[17:00:28.496]                 for (kk in seq_along(NAMES)) {
[17:00:28.496]                   name <- changed[[kk]]
[17:00:28.496]                   NAME <- NAMES[[kk]]
[17:00:28.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.496]                     next
[17:00:28.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.496]                 }
[17:00:28.496]                 NAMES <- toupper(added)
[17:00:28.496]                 for (kk in seq_along(NAMES)) {
[17:00:28.496]                   name <- added[[kk]]
[17:00:28.496]                   NAME <- NAMES[[kk]]
[17:00:28.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.496]                     next
[17:00:28.496]                   args[[name]] <- ""
[17:00:28.496]                 }
[17:00:28.496]                 NAMES <- toupper(removed)
[17:00:28.496]                 for (kk in seq_along(NAMES)) {
[17:00:28.496]                   name <- removed[[kk]]
[17:00:28.496]                   NAME <- NAMES[[kk]]
[17:00:28.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.496]                     next
[17:00:28.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.496]                 }
[17:00:28.496]                 if (length(args) > 0) 
[17:00:28.496]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.496]             }
[17:00:28.496]             else {
[17:00:28.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.496]             }
[17:00:28.496]             {
[17:00:28.496]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.496]                   0L) {
[17:00:28.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.496]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.496]                   base::options(opts)
[17:00:28.496]                 }
[17:00:28.496]                 {
[17:00:28.496]                   {
[17:00:28.496]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.496]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.496]                     2054632538L), envir = base::globalenv(), 
[17:00:28.496]                       inherits = FALSE)
[17:00:28.496]                     NULL
[17:00:28.496]                   }
[17:00:28.496]                   options(future.plan = NULL)
[17:00:28.496]                   if (is.na(NA_character_)) 
[17:00:28.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.496]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.496]                     .init = FALSE)
[17:00:28.496]                 }
[17:00:28.496]             }
[17:00:28.496]         }
[17:00:28.496]     })
[17:00:28.496]     if (TRUE) {
[17:00:28.496]         base::sink(type = "output", split = FALSE)
[17:00:28.496]         if (TRUE) {
[17:00:28.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.496]         }
[17:00:28.496]         else {
[17:00:28.496]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.496]         }
[17:00:28.496]         base::close(...future.stdout)
[17:00:28.496]         ...future.stdout <- NULL
[17:00:28.496]     }
[17:00:28.496]     ...future.result$conditions <- ...future.conditions
[17:00:28.496]     ...future.result$finished <- base::Sys.time()
[17:00:28.496]     ...future.result
[17:00:28.496] }
[17:00:28.498] assign_globals() ...
[17:00:28.498] List of 5
[17:00:28.498]  $ ...future.FUN            :function (C, k)  
[17:00:28.498]  $ MoreArgs                 : NULL
[17:00:28.498]  $ ...future.elements_ii    :List of 2
[17:00:28.498]   ..$ :List of 2
[17:00:28.498]   .. ..$ : chr "E"
[17:00:28.498]   .. ..$ : chr "D"
[17:00:28.498]   ..$ :List of 2
[17:00:28.498]   .. ..$ : int 1
[17:00:28.498]   .. ..$ : int 2
[17:00:28.498]  $ ...future.seeds_ii       : NULL
[17:00:28.498]  $ ...future.globals.maxSize: NULL
[17:00:28.498]  - attr(*, "where")=List of 5
[17:00:28.498]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.498]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.498]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.498]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.498]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.498]  - attr(*, "resolved")= logi FALSE
[17:00:28.498]  - attr(*, "total_size")= num 3656
[17:00:28.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.498]  - attr(*, "already-done")= logi TRUE
[17:00:28.506] - reassign environment for ‘...future.FUN’
[17:00:28.506] - copied ‘...future.FUN’ to environment
[17:00:28.506] - copied ‘MoreArgs’ to environment
[17:00:28.506] - copied ‘...future.elements_ii’ to environment
[17:00:28.506] - copied ‘...future.seeds_ii’ to environment
[17:00:28.506] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.506] assign_globals() ... done
[17:00:28.506] plan(): Setting new future strategy stack:
[17:00:28.506] List of future strategies:
[17:00:28.506] 1. sequential:
[17:00:28.506]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.506]    - tweaked: FALSE
[17:00:28.506]    - call: NULL
[17:00:28.507] plan(): nbrOfWorkers() = 1
[17:00:28.508] plan(): Setting new future strategy stack:
[17:00:28.508] List of future strategies:
[17:00:28.508] 1. sequential:
[17:00:28.508]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.508]    - tweaked: FALSE
[17:00:28.508]    - call: plan(strategy)
[17:00:28.508] plan(): nbrOfWorkers() = 1
[17:00:28.508] SequentialFuture started (and completed)
[17:00:28.509] - Launch lazy future ... done
[17:00:28.509] run() for ‘SequentialFuture’ ... done
[17:00:28.509] Created future:
[17:00:28.509] SequentialFuture:
[17:00:28.509] Label: ‘future_mapply-1’
[17:00:28.509] Expression:
[17:00:28.509] {
[17:00:28.509]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.509]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.509]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.509]         on.exit(options(oopts), add = TRUE)
[17:00:28.509]     }
[17:00:28.509]     {
[17:00:28.509]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.509]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.509]         do.call(mapply, args = args)
[17:00:28.509]     }
[17:00:28.509] }
[17:00:28.509] Lazy evaluation: FALSE
[17:00:28.509] Asynchronous evaluation: FALSE
[17:00:28.509] Local evaluation: TRUE
[17:00:28.509] Environment: R_GlobalEnv
[17:00:28.509] Capture standard output: TRUE
[17:00:28.509] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.509] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.509] Packages: <none>
[17:00:28.509] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.509] Resolved: TRUE
[17:00:28.509] Value: 224 bytes of class ‘list’
[17:00:28.509] Early signaling: FALSE
[17:00:28.509] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.509] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.510] Chunk #1 of 2 ... DONE
[17:00:28.510] Chunk #2 of 2 ...
[17:00:28.510]  - Finding globals in '...' for chunk #2 ...
[17:00:28.510] getGlobalsAndPackages() ...
[17:00:28.510] Searching for globals...
[17:00:28.510] 
[17:00:28.511] Searching for globals ... DONE
[17:00:28.511] - globals: [0] <none>
[17:00:28.511] getGlobalsAndPackages() ... DONE
[17:00:28.511]    + additional globals found: [n=0] 
[17:00:28.511]    + additional namespaces needed: [n=0] 
[17:00:28.511]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:28.511]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:28.511]  - seeds: <none>
[17:00:28.511]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.511] getGlobalsAndPackages() ...
[17:00:28.511] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.512] Resolving globals: FALSE
[17:00:28.512] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:00:28.512] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.513] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.513] 
[17:00:28.513] getGlobalsAndPackages() ... DONE
[17:00:28.513] run() for ‘Future’ ...
[17:00:28.513] - state: ‘created’
[17:00:28.513] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.514] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.514] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.514]   - Field: ‘label’
[17:00:28.514]   - Field: ‘local’
[17:00:28.514]   - Field: ‘owner’
[17:00:28.514]   - Field: ‘envir’
[17:00:28.514]   - Field: ‘packages’
[17:00:28.514]   - Field: ‘gc’
[17:00:28.514]   - Field: ‘conditions’
[17:00:28.514]   - Field: ‘expr’
[17:00:28.515]   - Field: ‘uuid’
[17:00:28.515]   - Field: ‘seed’
[17:00:28.515]   - Field: ‘version’
[17:00:28.515]   - Field: ‘result’
[17:00:28.515]   - Field: ‘asynchronous’
[17:00:28.515]   - Field: ‘calls’
[17:00:28.515]   - Field: ‘globals’
[17:00:28.515]   - Field: ‘stdout’
[17:00:28.515]   - Field: ‘earlySignal’
[17:00:28.515]   - Field: ‘lazy’
[17:00:28.515]   - Field: ‘state’
[17:00:28.516] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.516] - Launch lazy future ...
[17:00:28.516] Packages needed by the future expression (n = 0): <none>
[17:00:28.516] Packages needed by future strategies (n = 0): <none>
[17:00:28.516] {
[17:00:28.516]     {
[17:00:28.516]         {
[17:00:28.516]             ...future.startTime <- base::Sys.time()
[17:00:28.516]             {
[17:00:28.516]                 {
[17:00:28.516]                   {
[17:00:28.516]                     base::local({
[17:00:28.516]                       has_future <- base::requireNamespace("future", 
[17:00:28.516]                         quietly = TRUE)
[17:00:28.516]                       if (has_future) {
[17:00:28.516]                         ns <- base::getNamespace("future")
[17:00:28.516]                         version <- ns[[".package"]][["version"]]
[17:00:28.516]                         if (is.null(version)) 
[17:00:28.516]                           version <- utils::packageVersion("future")
[17:00:28.516]                       }
[17:00:28.516]                       else {
[17:00:28.516]                         version <- NULL
[17:00:28.516]                       }
[17:00:28.516]                       if (!has_future || version < "1.8.0") {
[17:00:28.516]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.516]                           "", base::R.version$version.string), 
[17:00:28.516]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.516]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.516]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.516]                             "release", "version")], collapse = " "), 
[17:00:28.516]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.516]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.516]                           info)
[17:00:28.516]                         info <- base::paste(info, collapse = "; ")
[17:00:28.516]                         if (!has_future) {
[17:00:28.516]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.516]                             info)
[17:00:28.516]                         }
[17:00:28.516]                         else {
[17:00:28.516]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.516]                             info, version)
[17:00:28.516]                         }
[17:00:28.516]                         base::stop(msg)
[17:00:28.516]                       }
[17:00:28.516]                     })
[17:00:28.516]                   }
[17:00:28.516]                   ...future.strategy.old <- future::plan("list")
[17:00:28.516]                   options(future.plan = NULL)
[17:00:28.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.516]                 }
[17:00:28.516]                 ...future.workdir <- getwd()
[17:00:28.516]             }
[17:00:28.516]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.516]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.516]         }
[17:00:28.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.516]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:28.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.516]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.516]             base::names(...future.oldOptions))
[17:00:28.516]     }
[17:00:28.516]     if (FALSE) {
[17:00:28.516]     }
[17:00:28.516]     else {
[17:00:28.516]         if (TRUE) {
[17:00:28.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.516]                 open = "w")
[17:00:28.516]         }
[17:00:28.516]         else {
[17:00:28.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.516]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.516]         }
[17:00:28.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.516]             base::sink(type = "output", split = FALSE)
[17:00:28.516]             base::close(...future.stdout)
[17:00:28.516]         }, add = TRUE)
[17:00:28.516]     }
[17:00:28.516]     ...future.frame <- base::sys.nframe()
[17:00:28.516]     ...future.conditions <- base::list()
[17:00:28.516]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.516]     if (FALSE) {
[17:00:28.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.516]     }
[17:00:28.516]     ...future.result <- base::tryCatch({
[17:00:28.516]         base::withCallingHandlers({
[17:00:28.516]             ...future.value <- base::withVisible(base::local({
[17:00:28.516]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.516]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.516]                   ...future.globals.maxSize)) {
[17:00:28.516]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.516]                   on.exit(options(oopts), add = TRUE)
[17:00:28.516]                 }
[17:00:28.516]                 {
[17:00:28.516]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.516]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.516]                     USE.NAMES = FALSE)
[17:00:28.516]                   do.call(mapply, args = args)
[17:00:28.516]                 }
[17:00:28.516]             }))
[17:00:28.516]             future::FutureResult(value = ...future.value$value, 
[17:00:28.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.516]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.516]                     ...future.globalenv.names))
[17:00:28.516]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.516]         }, condition = base::local({
[17:00:28.516]             c <- base::c
[17:00:28.516]             inherits <- base::inherits
[17:00:28.516]             invokeRestart <- base::invokeRestart
[17:00:28.516]             length <- base::length
[17:00:28.516]             list <- base::list
[17:00:28.516]             seq.int <- base::seq.int
[17:00:28.516]             signalCondition <- base::signalCondition
[17:00:28.516]             sys.calls <- base::sys.calls
[17:00:28.516]             `[[` <- base::`[[`
[17:00:28.516]             `+` <- base::`+`
[17:00:28.516]             `<<-` <- base::`<<-`
[17:00:28.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.516]                   3L)]
[17:00:28.516]             }
[17:00:28.516]             function(cond) {
[17:00:28.516]                 is_error <- inherits(cond, "error")
[17:00:28.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.516]                   NULL)
[17:00:28.516]                 if (is_error) {
[17:00:28.516]                   sessionInformation <- function() {
[17:00:28.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.516]                       search = base::search(), system = base::Sys.info())
[17:00:28.516]                   }
[17:00:28.516]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.516]                     cond$call), session = sessionInformation(), 
[17:00:28.516]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.516]                   signalCondition(cond)
[17:00:28.516]                 }
[17:00:28.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.516]                 "immediateCondition"))) {
[17:00:28.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.516]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.516]                   if (TRUE && !signal) {
[17:00:28.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.516]                     {
[17:00:28.516]                       inherits <- base::inherits
[17:00:28.516]                       invokeRestart <- base::invokeRestart
[17:00:28.516]                       is.null <- base::is.null
[17:00:28.516]                       muffled <- FALSE
[17:00:28.516]                       if (inherits(cond, "message")) {
[17:00:28.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.516]                         if (muffled) 
[17:00:28.516]                           invokeRestart("muffleMessage")
[17:00:28.516]                       }
[17:00:28.516]                       else if (inherits(cond, "warning")) {
[17:00:28.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.516]                         if (muffled) 
[17:00:28.516]                           invokeRestart("muffleWarning")
[17:00:28.516]                       }
[17:00:28.516]                       else if (inherits(cond, "condition")) {
[17:00:28.516]                         if (!is.null(pattern)) {
[17:00:28.516]                           computeRestarts <- base::computeRestarts
[17:00:28.516]                           grepl <- base::grepl
[17:00:28.516]                           restarts <- computeRestarts(cond)
[17:00:28.516]                           for (restart in restarts) {
[17:00:28.516]                             name <- restart$name
[17:00:28.516]                             if (is.null(name)) 
[17:00:28.516]                               next
[17:00:28.516]                             if (!grepl(pattern, name)) 
[17:00:28.516]                               next
[17:00:28.516]                             invokeRestart(restart)
[17:00:28.516]                             muffled <- TRUE
[17:00:28.516]                             break
[17:00:28.516]                           }
[17:00:28.516]                         }
[17:00:28.516]                       }
[17:00:28.516]                       invisible(muffled)
[17:00:28.516]                     }
[17:00:28.516]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.516]                   }
[17:00:28.516]                 }
[17:00:28.516]                 else {
[17:00:28.516]                   if (TRUE) {
[17:00:28.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.516]                     {
[17:00:28.516]                       inherits <- base::inherits
[17:00:28.516]                       invokeRestart <- base::invokeRestart
[17:00:28.516]                       is.null <- base::is.null
[17:00:28.516]                       muffled <- FALSE
[17:00:28.516]                       if (inherits(cond, "message")) {
[17:00:28.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.516]                         if (muffled) 
[17:00:28.516]                           invokeRestart("muffleMessage")
[17:00:28.516]                       }
[17:00:28.516]                       else if (inherits(cond, "warning")) {
[17:00:28.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.516]                         if (muffled) 
[17:00:28.516]                           invokeRestart("muffleWarning")
[17:00:28.516]                       }
[17:00:28.516]                       else if (inherits(cond, "condition")) {
[17:00:28.516]                         if (!is.null(pattern)) {
[17:00:28.516]                           computeRestarts <- base::computeRestarts
[17:00:28.516]                           grepl <- base::grepl
[17:00:28.516]                           restarts <- computeRestarts(cond)
[17:00:28.516]                           for (restart in restarts) {
[17:00:28.516]                             name <- restart$name
[17:00:28.516]                             if (is.null(name)) 
[17:00:28.516]                               next
[17:00:28.516]                             if (!grepl(pattern, name)) 
[17:00:28.516]                               next
[17:00:28.516]                             invokeRestart(restart)
[17:00:28.516]                             muffled <- TRUE
[17:00:28.516]                             break
[17:00:28.516]                           }
[17:00:28.516]                         }
[17:00:28.516]                       }
[17:00:28.516]                       invisible(muffled)
[17:00:28.516]                     }
[17:00:28.516]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.516]                   }
[17:00:28.516]                 }
[17:00:28.516]             }
[17:00:28.516]         }))
[17:00:28.516]     }, error = function(ex) {
[17:00:28.516]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.516]                 ...future.rng), started = ...future.startTime, 
[17:00:28.516]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.516]             version = "1.8"), class = "FutureResult")
[17:00:28.516]     }, finally = {
[17:00:28.516]         if (!identical(...future.workdir, getwd())) 
[17:00:28.516]             setwd(...future.workdir)
[17:00:28.516]         {
[17:00:28.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.516]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.516]             }
[17:00:28.516]             base::options(...future.oldOptions)
[17:00:28.516]             if (.Platform$OS.type == "windows") {
[17:00:28.516]                 old_names <- names(...future.oldEnvVars)
[17:00:28.516]                 envs <- base::Sys.getenv()
[17:00:28.516]                 names <- names(envs)
[17:00:28.516]                 common <- intersect(names, old_names)
[17:00:28.516]                 added <- setdiff(names, old_names)
[17:00:28.516]                 removed <- setdiff(old_names, names)
[17:00:28.516]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.516]                   envs[common]]
[17:00:28.516]                 NAMES <- toupper(changed)
[17:00:28.516]                 args <- list()
[17:00:28.516]                 for (kk in seq_along(NAMES)) {
[17:00:28.516]                   name <- changed[[kk]]
[17:00:28.516]                   NAME <- NAMES[[kk]]
[17:00:28.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.516]                     next
[17:00:28.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.516]                 }
[17:00:28.516]                 NAMES <- toupper(added)
[17:00:28.516]                 for (kk in seq_along(NAMES)) {
[17:00:28.516]                   name <- added[[kk]]
[17:00:28.516]                   NAME <- NAMES[[kk]]
[17:00:28.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.516]                     next
[17:00:28.516]                   args[[name]] <- ""
[17:00:28.516]                 }
[17:00:28.516]                 NAMES <- toupper(removed)
[17:00:28.516]                 for (kk in seq_along(NAMES)) {
[17:00:28.516]                   name <- removed[[kk]]
[17:00:28.516]                   NAME <- NAMES[[kk]]
[17:00:28.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.516]                     next
[17:00:28.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.516]                 }
[17:00:28.516]                 if (length(args) > 0) 
[17:00:28.516]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.516]             }
[17:00:28.516]             else {
[17:00:28.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.516]             }
[17:00:28.516]             {
[17:00:28.516]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.516]                   0L) {
[17:00:28.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.516]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.516]                   base::options(opts)
[17:00:28.516]                 }
[17:00:28.516]                 {
[17:00:28.516]                   {
[17:00:28.516]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.516]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.516]                     2054632538L), envir = base::globalenv(), 
[17:00:28.516]                       inherits = FALSE)
[17:00:28.516]                     NULL
[17:00:28.516]                   }
[17:00:28.516]                   options(future.plan = NULL)
[17:00:28.516]                   if (is.na(NA_character_)) 
[17:00:28.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.516]                     .init = FALSE)
[17:00:28.516]                 }
[17:00:28.516]             }
[17:00:28.516]         }
[17:00:28.516]     })
[17:00:28.516]     if (TRUE) {
[17:00:28.516]         base::sink(type = "output", split = FALSE)
[17:00:28.516]         if (TRUE) {
[17:00:28.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.516]         }
[17:00:28.516]         else {
[17:00:28.516]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.516]         }
[17:00:28.516]         base::close(...future.stdout)
[17:00:28.516]         ...future.stdout <- NULL
[17:00:28.516]     }
[17:00:28.516]     ...future.result$conditions <- ...future.conditions
[17:00:28.516]     ...future.result$finished <- base::Sys.time()
[17:00:28.516]     ...future.result
[17:00:28.516] }
[17:00:28.518] assign_globals() ...
[17:00:28.518] List of 5
[17:00:28.518]  $ ...future.FUN            :function (C, k)  
[17:00:28.518]  $ MoreArgs                 : NULL
[17:00:28.518]  $ ...future.elements_ii    :List of 2
[17:00:28.518]   ..$ :List of 3
[17:00:28.518]   .. ..$ : chr "C"
[17:00:28.518]   .. ..$ : chr "B"
[17:00:28.518]   .. ..$ : chr "A"
[17:00:28.518]   ..$ :List of 3
[17:00:28.518]   .. ..$ : int 3
[17:00:28.518]   .. ..$ : int 4
[17:00:28.518]   .. ..$ : int 5
[17:00:28.518]  $ ...future.seeds_ii       : NULL
[17:00:28.518]  $ ...future.globals.maxSize: NULL
[17:00:28.518]  - attr(*, "where")=List of 5
[17:00:28.518]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.518]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.518]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.518]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.518]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.518]  - attr(*, "resolved")= logi FALSE
[17:00:28.518]  - attr(*, "total_size")= num 3824
[17:00:28.518]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.518]  - attr(*, "already-done")= logi TRUE
[17:00:28.524] - reassign environment for ‘...future.FUN’
[17:00:28.524] - copied ‘...future.FUN’ to environment
[17:00:28.524] - copied ‘MoreArgs’ to environment
[17:00:28.524] - copied ‘...future.elements_ii’ to environment
[17:00:28.524] - copied ‘...future.seeds_ii’ to environment
[17:00:28.524] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.525] assign_globals() ... done
[17:00:28.525] plan(): Setting new future strategy stack:
[17:00:28.527] List of future strategies:
[17:00:28.527] 1. sequential:
[17:00:28.527]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.527]    - tweaked: FALSE
[17:00:28.527]    - call: NULL
[17:00:28.527] plan(): nbrOfWorkers() = 1
[17:00:28.528] plan(): Setting new future strategy stack:
[17:00:28.528] List of future strategies:
[17:00:28.528] 1. sequential:
[17:00:28.528]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.528]    - tweaked: FALSE
[17:00:28.528]    - call: plan(strategy)
[17:00:28.528] plan(): nbrOfWorkers() = 1
[17:00:28.529] SequentialFuture started (and completed)
[17:00:28.529] - Launch lazy future ... done
[17:00:28.529] run() for ‘SequentialFuture’ ... done
[17:00:28.529] Created future:
[17:00:28.529] SequentialFuture:
[17:00:28.529] Label: ‘future_mapply-2’
[17:00:28.529] Expression:
[17:00:28.529] {
[17:00:28.529]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.529]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.529]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.529]         on.exit(options(oopts), add = TRUE)
[17:00:28.529]     }
[17:00:28.529]     {
[17:00:28.529]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.529]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.529]         do.call(mapply, args = args)
[17:00:28.529]     }
[17:00:28.529] }
[17:00:28.529] Lazy evaluation: FALSE
[17:00:28.529] Asynchronous evaluation: FALSE
[17:00:28.529] Local evaluation: TRUE
[17:00:28.529] Environment: R_GlobalEnv
[17:00:28.529] Capture standard output: TRUE
[17:00:28.529] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.529] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.529] Packages: <none>
[17:00:28.529] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.529] Resolved: TRUE
[17:00:28.529] Value: 336 bytes of class ‘list’
[17:00:28.529] Early signaling: FALSE
[17:00:28.529] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.529] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.530] Chunk #2 of 2 ... DONE
[17:00:28.530] Launching 2 futures (chunks) ... DONE
[17:00:28.530] Resolving 2 futures (chunks) ...
[17:00:28.530] resolve() on list ...
[17:00:28.530]  recursive: 0
[17:00:28.530]  length: 2
[17:00:28.531] 
[17:00:28.531] resolved() for ‘SequentialFuture’ ...
[17:00:28.531] - state: ‘finished’
[17:00:28.531] - run: TRUE
[17:00:28.531] - result: ‘FutureResult’
[17:00:28.531] resolved() for ‘SequentialFuture’ ... done
[17:00:28.531] Future #1
[17:00:28.531] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.531] - nx: 2
[17:00:28.531] - relay: TRUE
[17:00:28.532] - stdout: TRUE
[17:00:28.532] - signal: TRUE
[17:00:28.532] - resignal: FALSE
[17:00:28.532] - force: TRUE
[17:00:28.532] - relayed: [n=2] FALSE, FALSE
[17:00:28.532] - queued futures: [n=2] FALSE, FALSE
[17:00:28.532]  - until=1
[17:00:28.532]  - relaying element #1
[17:00:28.532] - relayed: [n=2] TRUE, FALSE
[17:00:28.532] - queued futures: [n=2] TRUE, FALSE
[17:00:28.533] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.533]  length: 1 (resolved future 1)
[17:00:28.533] resolved() for ‘SequentialFuture’ ...
[17:00:28.533] - state: ‘finished’
[17:00:28.533] - run: TRUE
[17:00:28.533] - result: ‘FutureResult’
[17:00:28.533] resolved() for ‘SequentialFuture’ ... done
[17:00:28.533] Future #2
[17:00:28.533] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:00:28.533] - nx: 2
[17:00:28.534] - relay: TRUE
[17:00:28.534] - stdout: TRUE
[17:00:28.534] - signal: TRUE
[17:00:28.534] - resignal: FALSE
[17:00:28.534] - force: TRUE
[17:00:28.534] - relayed: [n=2] TRUE, FALSE
[17:00:28.534] - queued futures: [n=2] TRUE, FALSE
[17:00:28.534]  - until=2
[17:00:28.534]  - relaying element #2
[17:00:28.534] - relayed: [n=2] TRUE, TRUE
[17:00:28.534] - queued futures: [n=2] TRUE, TRUE
[17:00:28.535] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:00:28.535]  length: 0 (resolved future 2)
[17:00:28.535] Relaying remaining futures
[17:00:28.535] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.535] - nx: 2
[17:00:28.535] - relay: TRUE
[17:00:28.535] - stdout: TRUE
[17:00:28.535] - signal: TRUE
[17:00:28.535] - resignal: FALSE
[17:00:28.535] - force: TRUE
[17:00:28.535] - relayed: [n=2] TRUE, TRUE
[17:00:28.535] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:28.536] - relayed: [n=2] TRUE, TRUE
[17:00:28.536] - queued futures: [n=2] TRUE, TRUE
[17:00:28.536] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.536] resolve() on list ... DONE
[17:00:28.536]  - Number of value chunks collected: 2
[17:00:28.536] Resolving 2 futures (chunks) ... DONE
[17:00:28.536] Reducing values from 2 chunks ...
[17:00:28.536]  - Number of values collected after concatenation: 5
[17:00:28.536]  - Number of values expected: 5
[17:00:28.537] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:00:28.537] Reducing values from 2 chunks ... DONE
[17:00:28.537] future_mapply() ... DONE
[17:00:28.537] future_mapply() ...
[17:00:28.537] Number of chunks: 1
[17:00:28.537] getGlobalsAndPackagesXApply() ...
[17:00:28.537]  - future.globals: TRUE
[17:00:28.537] getGlobalsAndPackages() ...
[17:00:28.538] Searching for globals...
[17:00:28.539] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:28.539] Searching for globals ... DONE
[17:00:28.539] Resolving globals: FALSE
[17:00:28.539] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:28.540] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:28.540] - globals: [1] ‘FUN’
[17:00:28.540] 
[17:00:28.540] getGlobalsAndPackages() ... DONE
[17:00:28.540]  - globals found/used: [n=1] ‘FUN’
[17:00:28.540]  - needed namespaces: [n=0] 
[17:00:28.540] Finding globals ... DONE
[17:00:28.541] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.541] List of 2
[17:00:28.541]  $ ...future.FUN:function (C, k)  
[17:00:28.541]  $ MoreArgs     : list()
[17:00:28.541]  - attr(*, "where")=List of 2
[17:00:28.541]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.541]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.541]  - attr(*, "resolved")= logi FALSE
[17:00:28.541]  - attr(*, "total_size")= num NA
[17:00:28.543] Packages to be attached in all futures: [n=0] 
[17:00:28.543] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.543] Number of futures (= number of chunks): 1
[17:00:28.544] Launching 1 futures (chunks) ...
[17:00:28.544] Chunk #1 of 1 ...
[17:00:28.544]  - Finding globals in '...' for chunk #1 ...
[17:00:28.544] getGlobalsAndPackages() ...
[17:00:28.544] Searching for globals...
[17:00:28.544] 
[17:00:28.544] Searching for globals ... DONE
[17:00:28.545] - globals: [0] <none>
[17:00:28.545] getGlobalsAndPackages() ... DONE
[17:00:28.545]    + additional globals found: [n=0] 
[17:00:28.545]    + additional namespaces needed: [n=0] 
[17:00:28.545]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.545]  - seeds: <none>
[17:00:28.545]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.545] getGlobalsAndPackages() ...
[17:00:28.545] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.545] Resolving globals: FALSE
[17:00:28.546] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[17:00:28.546] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:28.546] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.547] 
[17:00:28.547] getGlobalsAndPackages() ... DONE
[17:00:28.547] run() for ‘Future’ ...
[17:00:28.547] - state: ‘created’
[17:00:28.547] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.547] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.548]   - Field: ‘label’
[17:00:28.548]   - Field: ‘local’
[17:00:28.548]   - Field: ‘owner’
[17:00:28.548]   - Field: ‘envir’
[17:00:28.548]   - Field: ‘packages’
[17:00:28.548]   - Field: ‘gc’
[17:00:28.548]   - Field: ‘conditions’
[17:00:28.548]   - Field: ‘expr’
[17:00:28.548]   - Field: ‘uuid’
[17:00:28.549]   - Field: ‘seed’
[17:00:28.549]   - Field: ‘version’
[17:00:28.549]   - Field: ‘result’
[17:00:28.549]   - Field: ‘asynchronous’
[17:00:28.549]   - Field: ‘calls’
[17:00:28.549]   - Field: ‘globals’
[17:00:28.549]   - Field: ‘stdout’
[17:00:28.549]   - Field: ‘earlySignal’
[17:00:28.549]   - Field: ‘lazy’
[17:00:28.549]   - Field: ‘state’
[17:00:28.549] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.550] - Launch lazy future ...
[17:00:28.550] Packages needed by the future expression (n = 0): <none>
[17:00:28.550] Packages needed by future strategies (n = 0): <none>
[17:00:28.552] {
[17:00:28.552]     {
[17:00:28.552]         {
[17:00:28.552]             ...future.startTime <- base::Sys.time()
[17:00:28.552]             {
[17:00:28.552]                 {
[17:00:28.552]                   {
[17:00:28.552]                     base::local({
[17:00:28.552]                       has_future <- base::requireNamespace("future", 
[17:00:28.552]                         quietly = TRUE)
[17:00:28.552]                       if (has_future) {
[17:00:28.552]                         ns <- base::getNamespace("future")
[17:00:28.552]                         version <- ns[[".package"]][["version"]]
[17:00:28.552]                         if (is.null(version)) 
[17:00:28.552]                           version <- utils::packageVersion("future")
[17:00:28.552]                       }
[17:00:28.552]                       else {
[17:00:28.552]                         version <- NULL
[17:00:28.552]                       }
[17:00:28.552]                       if (!has_future || version < "1.8.0") {
[17:00:28.552]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.552]                           "", base::R.version$version.string), 
[17:00:28.552]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.552]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.552]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.552]                             "release", "version")], collapse = " "), 
[17:00:28.552]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.552]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.552]                           info)
[17:00:28.552]                         info <- base::paste(info, collapse = "; ")
[17:00:28.552]                         if (!has_future) {
[17:00:28.552]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.552]                             info)
[17:00:28.552]                         }
[17:00:28.552]                         else {
[17:00:28.552]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.552]                             info, version)
[17:00:28.552]                         }
[17:00:28.552]                         base::stop(msg)
[17:00:28.552]                       }
[17:00:28.552]                     })
[17:00:28.552]                   }
[17:00:28.552]                   ...future.strategy.old <- future::plan("list")
[17:00:28.552]                   options(future.plan = NULL)
[17:00:28.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.552]                 }
[17:00:28.552]                 ...future.workdir <- getwd()
[17:00:28.552]             }
[17:00:28.552]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.552]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.552]         }
[17:00:28.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.552]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.552]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.552]             base::names(...future.oldOptions))
[17:00:28.552]     }
[17:00:28.552]     if (FALSE) {
[17:00:28.552]     }
[17:00:28.552]     else {
[17:00:28.552]         if (TRUE) {
[17:00:28.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.552]                 open = "w")
[17:00:28.552]         }
[17:00:28.552]         else {
[17:00:28.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.552]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.552]         }
[17:00:28.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.552]             base::sink(type = "output", split = FALSE)
[17:00:28.552]             base::close(...future.stdout)
[17:00:28.552]         }, add = TRUE)
[17:00:28.552]     }
[17:00:28.552]     ...future.frame <- base::sys.nframe()
[17:00:28.552]     ...future.conditions <- base::list()
[17:00:28.552]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.552]     if (FALSE) {
[17:00:28.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.552]     }
[17:00:28.552]     ...future.result <- base::tryCatch({
[17:00:28.552]         base::withCallingHandlers({
[17:00:28.552]             ...future.value <- base::withVisible(base::local({
[17:00:28.552]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.552]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.552]                   ...future.globals.maxSize)) {
[17:00:28.552]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.552]                   on.exit(options(oopts), add = TRUE)
[17:00:28.552]                 }
[17:00:28.552]                 {
[17:00:28.552]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.552]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.552]                     USE.NAMES = FALSE)
[17:00:28.552]                   do.call(mapply, args = args)
[17:00:28.552]                 }
[17:00:28.552]             }))
[17:00:28.552]             future::FutureResult(value = ...future.value$value, 
[17:00:28.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.552]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.552]                     ...future.globalenv.names))
[17:00:28.552]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.552]         }, condition = base::local({
[17:00:28.552]             c <- base::c
[17:00:28.552]             inherits <- base::inherits
[17:00:28.552]             invokeRestart <- base::invokeRestart
[17:00:28.552]             length <- base::length
[17:00:28.552]             list <- base::list
[17:00:28.552]             seq.int <- base::seq.int
[17:00:28.552]             signalCondition <- base::signalCondition
[17:00:28.552]             sys.calls <- base::sys.calls
[17:00:28.552]             `[[` <- base::`[[`
[17:00:28.552]             `+` <- base::`+`
[17:00:28.552]             `<<-` <- base::`<<-`
[17:00:28.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.552]                   3L)]
[17:00:28.552]             }
[17:00:28.552]             function(cond) {
[17:00:28.552]                 is_error <- inherits(cond, "error")
[17:00:28.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.552]                   NULL)
[17:00:28.552]                 if (is_error) {
[17:00:28.552]                   sessionInformation <- function() {
[17:00:28.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.552]                       search = base::search(), system = base::Sys.info())
[17:00:28.552]                   }
[17:00:28.552]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.552]                     cond$call), session = sessionInformation(), 
[17:00:28.552]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.552]                   signalCondition(cond)
[17:00:28.552]                 }
[17:00:28.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.552]                 "immediateCondition"))) {
[17:00:28.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.552]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.552]                   if (TRUE && !signal) {
[17:00:28.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.552]                     {
[17:00:28.552]                       inherits <- base::inherits
[17:00:28.552]                       invokeRestart <- base::invokeRestart
[17:00:28.552]                       is.null <- base::is.null
[17:00:28.552]                       muffled <- FALSE
[17:00:28.552]                       if (inherits(cond, "message")) {
[17:00:28.552]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.552]                         if (muffled) 
[17:00:28.552]                           invokeRestart("muffleMessage")
[17:00:28.552]                       }
[17:00:28.552]                       else if (inherits(cond, "warning")) {
[17:00:28.552]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.552]                         if (muffled) 
[17:00:28.552]                           invokeRestart("muffleWarning")
[17:00:28.552]                       }
[17:00:28.552]                       else if (inherits(cond, "condition")) {
[17:00:28.552]                         if (!is.null(pattern)) {
[17:00:28.552]                           computeRestarts <- base::computeRestarts
[17:00:28.552]                           grepl <- base::grepl
[17:00:28.552]                           restarts <- computeRestarts(cond)
[17:00:28.552]                           for (restart in restarts) {
[17:00:28.552]                             name <- restart$name
[17:00:28.552]                             if (is.null(name)) 
[17:00:28.552]                               next
[17:00:28.552]                             if (!grepl(pattern, name)) 
[17:00:28.552]                               next
[17:00:28.552]                             invokeRestart(restart)
[17:00:28.552]                             muffled <- TRUE
[17:00:28.552]                             break
[17:00:28.552]                           }
[17:00:28.552]                         }
[17:00:28.552]                       }
[17:00:28.552]                       invisible(muffled)
[17:00:28.552]                     }
[17:00:28.552]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.552]                   }
[17:00:28.552]                 }
[17:00:28.552]                 else {
[17:00:28.552]                   if (TRUE) {
[17:00:28.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.552]                     {
[17:00:28.552]                       inherits <- base::inherits
[17:00:28.552]                       invokeRestart <- base::invokeRestart
[17:00:28.552]                       is.null <- base::is.null
[17:00:28.552]                       muffled <- FALSE
[17:00:28.552]                       if (inherits(cond, "message")) {
[17:00:28.552]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.552]                         if (muffled) 
[17:00:28.552]                           invokeRestart("muffleMessage")
[17:00:28.552]                       }
[17:00:28.552]                       else if (inherits(cond, "warning")) {
[17:00:28.552]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.552]                         if (muffled) 
[17:00:28.552]                           invokeRestart("muffleWarning")
[17:00:28.552]                       }
[17:00:28.552]                       else if (inherits(cond, "condition")) {
[17:00:28.552]                         if (!is.null(pattern)) {
[17:00:28.552]                           computeRestarts <- base::computeRestarts
[17:00:28.552]                           grepl <- base::grepl
[17:00:28.552]                           restarts <- computeRestarts(cond)
[17:00:28.552]                           for (restart in restarts) {
[17:00:28.552]                             name <- restart$name
[17:00:28.552]                             if (is.null(name)) 
[17:00:28.552]                               next
[17:00:28.552]                             if (!grepl(pattern, name)) 
[17:00:28.552]                               next
[17:00:28.552]                             invokeRestart(restart)
[17:00:28.552]                             muffled <- TRUE
[17:00:28.552]                             break
[17:00:28.552]                           }
[17:00:28.552]                         }
[17:00:28.552]                       }
[17:00:28.552]                       invisible(muffled)
[17:00:28.552]                     }
[17:00:28.552]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.552]                   }
[17:00:28.552]                 }
[17:00:28.552]             }
[17:00:28.552]         }))
[17:00:28.552]     }, error = function(ex) {
[17:00:28.552]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.552]                 ...future.rng), started = ...future.startTime, 
[17:00:28.552]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.552]             version = "1.8"), class = "FutureResult")
[17:00:28.552]     }, finally = {
[17:00:28.552]         if (!identical(...future.workdir, getwd())) 
[17:00:28.552]             setwd(...future.workdir)
[17:00:28.552]         {
[17:00:28.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.552]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.552]             }
[17:00:28.552]             base::options(...future.oldOptions)
[17:00:28.552]             if (.Platform$OS.type == "windows") {
[17:00:28.552]                 old_names <- names(...future.oldEnvVars)
[17:00:28.552]                 envs <- base::Sys.getenv()
[17:00:28.552]                 names <- names(envs)
[17:00:28.552]                 common <- intersect(names, old_names)
[17:00:28.552]                 added <- setdiff(names, old_names)
[17:00:28.552]                 removed <- setdiff(old_names, names)
[17:00:28.552]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.552]                   envs[common]]
[17:00:28.552]                 NAMES <- toupper(changed)
[17:00:28.552]                 args <- list()
[17:00:28.552]                 for (kk in seq_along(NAMES)) {
[17:00:28.552]                   name <- changed[[kk]]
[17:00:28.552]                   NAME <- NAMES[[kk]]
[17:00:28.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.552]                     next
[17:00:28.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.552]                 }
[17:00:28.552]                 NAMES <- toupper(added)
[17:00:28.552]                 for (kk in seq_along(NAMES)) {
[17:00:28.552]                   name <- added[[kk]]
[17:00:28.552]                   NAME <- NAMES[[kk]]
[17:00:28.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.552]                     next
[17:00:28.552]                   args[[name]] <- ""
[17:00:28.552]                 }
[17:00:28.552]                 NAMES <- toupper(removed)
[17:00:28.552]                 for (kk in seq_along(NAMES)) {
[17:00:28.552]                   name <- removed[[kk]]
[17:00:28.552]                   NAME <- NAMES[[kk]]
[17:00:28.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.552]                     next
[17:00:28.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.552]                 }
[17:00:28.552]                 if (length(args) > 0) 
[17:00:28.552]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.552]             }
[17:00:28.552]             else {
[17:00:28.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.552]             }
[17:00:28.552]             {
[17:00:28.552]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.552]                   0L) {
[17:00:28.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.552]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.552]                   base::options(opts)
[17:00:28.552]                 }
[17:00:28.552]                 {
[17:00:28.552]                   {
[17:00:28.552]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.552]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.552]                     2054632538L), envir = base::globalenv(), 
[17:00:28.552]                       inherits = FALSE)
[17:00:28.552]                     NULL
[17:00:28.552]                   }
[17:00:28.552]                   options(future.plan = NULL)
[17:00:28.552]                   if (is.na(NA_character_)) 
[17:00:28.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.552]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.552]                     .init = FALSE)
[17:00:28.552]                 }
[17:00:28.552]             }
[17:00:28.552]         }
[17:00:28.552]     })
[17:00:28.552]     if (TRUE) {
[17:00:28.552]         base::sink(type = "output", split = FALSE)
[17:00:28.552]         if (TRUE) {
[17:00:28.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.552]         }
[17:00:28.552]         else {
[17:00:28.552]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.552]         }
[17:00:28.552]         base::close(...future.stdout)
[17:00:28.552]         ...future.stdout <- NULL
[17:00:28.552]     }
[17:00:28.552]     ...future.result$conditions <- ...future.conditions
[17:00:28.552]     ...future.result$finished <- base::Sys.time()
[17:00:28.552]     ...future.result
[17:00:28.552] }
[17:00:28.554] assign_globals() ...
[17:00:28.554] List of 5
[17:00:28.554]  $ ...future.FUN            :function (C, k)  
[17:00:28.554]  $ MoreArgs                 : list()
[17:00:28.554]  $ ...future.elements_ii    :List of 2
[17:00:28.554]   ..$ :List of 5
[17:00:28.554]   .. ..$ : chr "A"
[17:00:28.554]   .. ..$ : chr "B"
[17:00:28.554]   .. ..$ : chr "C"
[17:00:28.554]   .. ..$ : chr "D"
[17:00:28.554]   .. ..$ : chr "E"
[17:00:28.554]   ..$ :List of 5
[17:00:28.554]   .. ..$ : int 5
[17:00:28.554]   .. ..$ : int 4
[17:00:28.554]   .. ..$ : int 3
[17:00:28.554]   .. ..$ : int 2
[17:00:28.554]   .. ..$ : int 1
[17:00:28.554]  $ ...future.seeds_ii       : NULL
[17:00:28.554]  $ ...future.globals.maxSize: NULL
[17:00:28.554]  - attr(*, "where")=List of 5
[17:00:28.554]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.554]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.554]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.554]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.554]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.554]  - attr(*, "resolved")= logi FALSE
[17:00:28.554]  - attr(*, "total_size")= num 4160
[17:00:28.554]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.554]  - attr(*, "already-done")= logi TRUE
[17:00:28.561] - reassign environment for ‘...future.FUN’
[17:00:28.561] - copied ‘...future.FUN’ to environment
[17:00:28.561] - copied ‘MoreArgs’ to environment
[17:00:28.562] - copied ‘...future.elements_ii’ to environment
[17:00:28.562] - copied ‘...future.seeds_ii’ to environment
[17:00:28.562] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.562] assign_globals() ... done
[17:00:28.562] plan(): Setting new future strategy stack:
[17:00:28.562] List of future strategies:
[17:00:28.562] 1. sequential:
[17:00:28.562]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.562]    - tweaked: FALSE
[17:00:28.562]    - call: NULL
[17:00:28.563] plan(): nbrOfWorkers() = 1
[17:00:28.563] plan(): Setting new future strategy stack:
[17:00:28.564] List of future strategies:
[17:00:28.564] 1. sequential:
[17:00:28.564]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.564]    - tweaked: FALSE
[17:00:28.564]    - call: plan(strategy)
[17:00:28.564] plan(): nbrOfWorkers() = 1
[17:00:28.564] SequentialFuture started (and completed)
[17:00:28.564] - Launch lazy future ... done
[17:00:28.564] run() for ‘SequentialFuture’ ... done
[17:00:28.564] Created future:
[17:00:28.565] SequentialFuture:
[17:00:28.565] Label: ‘future_.mapply-1’
[17:00:28.565] Expression:
[17:00:28.565] {
[17:00:28.565]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.565]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.565]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.565]         on.exit(options(oopts), add = TRUE)
[17:00:28.565]     }
[17:00:28.565]     {
[17:00:28.565]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.565]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.565]         do.call(mapply, args = args)
[17:00:28.565]     }
[17:00:28.565] }
[17:00:28.565] Lazy evaluation: FALSE
[17:00:28.565] Asynchronous evaluation: FALSE
[17:00:28.565] Local evaluation: TRUE
[17:00:28.565] Environment: R_GlobalEnv
[17:00:28.565] Capture standard output: TRUE
[17:00:28.565] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.565] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.565] Packages: <none>
[17:00:28.565] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.565] Resolved: TRUE
[17:00:28.565] Value: 560 bytes of class ‘list’
[17:00:28.565] Early signaling: FALSE
[17:00:28.565] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.565] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.565] Chunk #1 of 1 ... DONE
[17:00:28.566] Launching 1 futures (chunks) ... DONE
[17:00:28.566] Resolving 1 futures (chunks) ...
[17:00:28.566] resolve() on list ...
[17:00:28.566]  recursive: 0
[17:00:28.566]  length: 1
[17:00:28.566] 
[17:00:28.566] resolved() for ‘SequentialFuture’ ...
[17:00:28.566] - state: ‘finished’
[17:00:28.566] - run: TRUE
[17:00:28.566] - result: ‘FutureResult’
[17:00:28.566] resolved() for ‘SequentialFuture’ ... done
[17:00:28.567] Future #1
[17:00:28.567] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.567] - nx: 1
[17:00:28.567] - relay: TRUE
[17:00:28.567] - stdout: TRUE
[17:00:28.567] - signal: TRUE
[17:00:28.567] - resignal: FALSE
[17:00:28.567] - force: TRUE
[17:00:28.567] - relayed: [n=1] FALSE
[17:00:28.567] - queued futures: [n=1] FALSE
[17:00:28.568]  - until=1
[17:00:28.568]  - relaying element #1
[17:00:28.568] - relayed: [n=1] TRUE
[17:00:28.568] - queued futures: [n=1] TRUE
[17:00:28.568] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.568]  length: 0 (resolved future 1)
[17:00:28.568] Relaying remaining futures
[17:00:28.568] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.568] - nx: 1
[17:00:28.568] - relay: TRUE
[17:00:28.569] - stdout: TRUE
[17:00:28.569] - signal: TRUE
[17:00:28.569] - resignal: FALSE
[17:00:28.569] - force: TRUE
[17:00:28.569] - relayed: [n=1] TRUE
[17:00:28.569] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.569] - relayed: [n=1] TRUE
[17:00:28.569] - queued futures: [n=1] TRUE
[17:00:28.569] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.569] resolve() on list ... DONE
[17:00:28.569]  - Number of value chunks collected: 1
[17:00:28.570] Resolving 1 futures (chunks) ... DONE
[17:00:28.570] Reducing values from 1 chunks ...
[17:00:28.570]  - Number of values collected after concatenation: 5
[17:00:28.570]  - Number of values expected: 5
[17:00:28.570] Reducing values from 1 chunks ... DONE
[17:00:28.570] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[17:00:28.571] future_mapply() ...
[17:00:28.571] Number of chunks: 1
[17:00:28.571] getGlobalsAndPackagesXApply() ...
[17:00:28.571]  - future.globals: TRUE
[17:00:28.571] getGlobalsAndPackages() ...
[17:00:28.571] Searching for globals...
[17:00:28.572] - globals found: [1] ‘FUN’
[17:00:28.572] Searching for globals ... DONE
[17:00:28.572] Resolving globals: FALSE
[17:00:28.573] The total size of the 1 globals is 848 bytes (848 bytes)
[17:00:28.573] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:00:28.573] - globals: [1] ‘FUN’
[17:00:28.573] 
[17:00:28.573] getGlobalsAndPackages() ... DONE
[17:00:28.573]  - globals found/used: [n=1] ‘FUN’
[17:00:28.573]  - needed namespaces: [n=0] 
[17:00:28.574] Finding globals ... DONE
[17:00:28.574] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.574] List of 2
[17:00:28.574]  $ ...future.FUN:function (x)  
[17:00:28.574]  $ MoreArgs     : NULL
[17:00:28.574]  - attr(*, "where")=List of 2
[17:00:28.574]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.574]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.574]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.574]  - attr(*, "resolved")= logi FALSE
[17:00:28.574]  - attr(*, "total_size")= num NA
[17:00:28.578] Packages to be attached in all futures: [n=0] 
[17:00:28.578] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.578] Number of futures (= number of chunks): 1
[17:00:28.578] Launching 1 futures (chunks) ...
[17:00:28.579] Chunk #1 of 1 ...
[17:00:28.579]  - Finding globals in '...' for chunk #1 ...
[17:00:28.579] getGlobalsAndPackages() ...
[17:00:28.579] Searching for globals...
[17:00:28.579] 
[17:00:28.579] Searching for globals ... DONE
[17:00:28.580] - globals: [0] <none>
[17:00:28.580] getGlobalsAndPackages() ... DONE
[17:00:28.580]    + additional globals found: [n=0] 
[17:00:28.580]    + additional namespaces needed: [n=0] 
[17:00:28.580]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.580]  - seeds: <none>
[17:00:28.580]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.580] getGlobalsAndPackages() ...
[17:00:28.580] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.580] Resolving globals: FALSE
[17:00:28.581] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:00:28.581] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.582] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.582] 
[17:00:28.582] getGlobalsAndPackages() ... DONE
[17:00:28.582] run() for ‘Future’ ...
[17:00:28.582] - state: ‘created’
[17:00:28.582] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.583] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.583]   - Field: ‘label’
[17:00:28.583]   - Field: ‘local’
[17:00:28.583]   - Field: ‘owner’
[17:00:28.583]   - Field: ‘envir’
[17:00:28.583]   - Field: ‘packages’
[17:00:28.583]   - Field: ‘gc’
[17:00:28.583]   - Field: ‘conditions’
[17:00:28.584]   - Field: ‘expr’
[17:00:28.584]   - Field: ‘uuid’
[17:00:28.584]   - Field: ‘seed’
[17:00:28.584]   - Field: ‘version’
[17:00:28.584]   - Field: ‘result’
[17:00:28.584]   - Field: ‘asynchronous’
[17:00:28.584]   - Field: ‘calls’
[17:00:28.584]   - Field: ‘globals’
[17:00:28.584]   - Field: ‘stdout’
[17:00:28.584]   - Field: ‘earlySignal’
[17:00:28.584]   - Field: ‘lazy’
[17:00:28.585]   - Field: ‘state’
[17:00:28.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.585] - Launch lazy future ...
[17:00:28.585] Packages needed by the future expression (n = 0): <none>
[17:00:28.585] Packages needed by future strategies (n = 0): <none>
[17:00:28.586] {
[17:00:28.586]     {
[17:00:28.586]         {
[17:00:28.586]             ...future.startTime <- base::Sys.time()
[17:00:28.586]             {
[17:00:28.586]                 {
[17:00:28.586]                   {
[17:00:28.586]                     base::local({
[17:00:28.586]                       has_future <- base::requireNamespace("future", 
[17:00:28.586]                         quietly = TRUE)
[17:00:28.586]                       if (has_future) {
[17:00:28.586]                         ns <- base::getNamespace("future")
[17:00:28.586]                         version <- ns[[".package"]][["version"]]
[17:00:28.586]                         if (is.null(version)) 
[17:00:28.586]                           version <- utils::packageVersion("future")
[17:00:28.586]                       }
[17:00:28.586]                       else {
[17:00:28.586]                         version <- NULL
[17:00:28.586]                       }
[17:00:28.586]                       if (!has_future || version < "1.8.0") {
[17:00:28.586]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.586]                           "", base::R.version$version.string), 
[17:00:28.586]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.586]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.586]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.586]                             "release", "version")], collapse = " "), 
[17:00:28.586]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.586]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.586]                           info)
[17:00:28.586]                         info <- base::paste(info, collapse = "; ")
[17:00:28.586]                         if (!has_future) {
[17:00:28.586]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.586]                             info)
[17:00:28.586]                         }
[17:00:28.586]                         else {
[17:00:28.586]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.586]                             info, version)
[17:00:28.586]                         }
[17:00:28.586]                         base::stop(msg)
[17:00:28.586]                       }
[17:00:28.586]                     })
[17:00:28.586]                   }
[17:00:28.586]                   ...future.strategy.old <- future::plan("list")
[17:00:28.586]                   options(future.plan = NULL)
[17:00:28.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.586]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.586]                 }
[17:00:28.586]                 ...future.workdir <- getwd()
[17:00:28.586]             }
[17:00:28.586]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.586]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.586]         }
[17:00:28.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.586]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.586]             base::names(...future.oldOptions))
[17:00:28.586]     }
[17:00:28.586]     if (FALSE) {
[17:00:28.586]     }
[17:00:28.586]     else {
[17:00:28.586]         if (TRUE) {
[17:00:28.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.586]                 open = "w")
[17:00:28.586]         }
[17:00:28.586]         else {
[17:00:28.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.586]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.586]         }
[17:00:28.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.586]             base::sink(type = "output", split = FALSE)
[17:00:28.586]             base::close(...future.stdout)
[17:00:28.586]         }, add = TRUE)
[17:00:28.586]     }
[17:00:28.586]     ...future.frame <- base::sys.nframe()
[17:00:28.586]     ...future.conditions <- base::list()
[17:00:28.586]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.586]     if (FALSE) {
[17:00:28.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.586]     }
[17:00:28.586]     ...future.result <- base::tryCatch({
[17:00:28.586]         base::withCallingHandlers({
[17:00:28.586]             ...future.value <- base::withVisible(base::local({
[17:00:28.586]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.586]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.586]                   ...future.globals.maxSize)) {
[17:00:28.586]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.586]                   on.exit(options(oopts), add = TRUE)
[17:00:28.586]                 }
[17:00:28.586]                 {
[17:00:28.586]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.586]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.586]                     USE.NAMES = FALSE)
[17:00:28.586]                   do.call(mapply, args = args)
[17:00:28.586]                 }
[17:00:28.586]             }))
[17:00:28.586]             future::FutureResult(value = ...future.value$value, 
[17:00:28.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.586]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.586]                     ...future.globalenv.names))
[17:00:28.586]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.586]         }, condition = base::local({
[17:00:28.586]             c <- base::c
[17:00:28.586]             inherits <- base::inherits
[17:00:28.586]             invokeRestart <- base::invokeRestart
[17:00:28.586]             length <- base::length
[17:00:28.586]             list <- base::list
[17:00:28.586]             seq.int <- base::seq.int
[17:00:28.586]             signalCondition <- base::signalCondition
[17:00:28.586]             sys.calls <- base::sys.calls
[17:00:28.586]             `[[` <- base::`[[`
[17:00:28.586]             `+` <- base::`+`
[17:00:28.586]             `<<-` <- base::`<<-`
[17:00:28.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.586]                   3L)]
[17:00:28.586]             }
[17:00:28.586]             function(cond) {
[17:00:28.586]                 is_error <- inherits(cond, "error")
[17:00:28.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.586]                   NULL)
[17:00:28.586]                 if (is_error) {
[17:00:28.586]                   sessionInformation <- function() {
[17:00:28.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.586]                       search = base::search(), system = base::Sys.info())
[17:00:28.586]                   }
[17:00:28.586]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.586]                     cond$call), session = sessionInformation(), 
[17:00:28.586]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.586]                   signalCondition(cond)
[17:00:28.586]                 }
[17:00:28.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.586]                 "immediateCondition"))) {
[17:00:28.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.586]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.586]                   if (TRUE && !signal) {
[17:00:28.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.586]                     {
[17:00:28.586]                       inherits <- base::inherits
[17:00:28.586]                       invokeRestart <- base::invokeRestart
[17:00:28.586]                       is.null <- base::is.null
[17:00:28.586]                       muffled <- FALSE
[17:00:28.586]                       if (inherits(cond, "message")) {
[17:00:28.586]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.586]                         if (muffled) 
[17:00:28.586]                           invokeRestart("muffleMessage")
[17:00:28.586]                       }
[17:00:28.586]                       else if (inherits(cond, "warning")) {
[17:00:28.586]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.586]                         if (muffled) 
[17:00:28.586]                           invokeRestart("muffleWarning")
[17:00:28.586]                       }
[17:00:28.586]                       else if (inherits(cond, "condition")) {
[17:00:28.586]                         if (!is.null(pattern)) {
[17:00:28.586]                           computeRestarts <- base::computeRestarts
[17:00:28.586]                           grepl <- base::grepl
[17:00:28.586]                           restarts <- computeRestarts(cond)
[17:00:28.586]                           for (restart in restarts) {
[17:00:28.586]                             name <- restart$name
[17:00:28.586]                             if (is.null(name)) 
[17:00:28.586]                               next
[17:00:28.586]                             if (!grepl(pattern, name)) 
[17:00:28.586]                               next
[17:00:28.586]                             invokeRestart(restart)
[17:00:28.586]                             muffled <- TRUE
[17:00:28.586]                             break
[17:00:28.586]                           }
[17:00:28.586]                         }
[17:00:28.586]                       }
[17:00:28.586]                       invisible(muffled)
[17:00:28.586]                     }
[17:00:28.586]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.586]                   }
[17:00:28.586]                 }
[17:00:28.586]                 else {
[17:00:28.586]                   if (TRUE) {
[17:00:28.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.586]                     {
[17:00:28.586]                       inherits <- base::inherits
[17:00:28.586]                       invokeRestart <- base::invokeRestart
[17:00:28.586]                       is.null <- base::is.null
[17:00:28.586]                       muffled <- FALSE
[17:00:28.586]                       if (inherits(cond, "message")) {
[17:00:28.586]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.586]                         if (muffled) 
[17:00:28.586]                           invokeRestart("muffleMessage")
[17:00:28.586]                       }
[17:00:28.586]                       else if (inherits(cond, "warning")) {
[17:00:28.586]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.586]                         if (muffled) 
[17:00:28.586]                           invokeRestart("muffleWarning")
[17:00:28.586]                       }
[17:00:28.586]                       else if (inherits(cond, "condition")) {
[17:00:28.586]                         if (!is.null(pattern)) {
[17:00:28.586]                           computeRestarts <- base::computeRestarts
[17:00:28.586]                           grepl <- base::grepl
[17:00:28.586]                           restarts <- computeRestarts(cond)
[17:00:28.586]                           for (restart in restarts) {
[17:00:28.586]                             name <- restart$name
[17:00:28.586]                             if (is.null(name)) 
[17:00:28.586]                               next
[17:00:28.586]                             if (!grepl(pattern, name)) 
[17:00:28.586]                               next
[17:00:28.586]                             invokeRestart(restart)
[17:00:28.586]                             muffled <- TRUE
[17:00:28.586]                             break
[17:00:28.586]                           }
[17:00:28.586]                         }
[17:00:28.586]                       }
[17:00:28.586]                       invisible(muffled)
[17:00:28.586]                     }
[17:00:28.586]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.586]                   }
[17:00:28.586]                 }
[17:00:28.586]             }
[17:00:28.586]         }))
[17:00:28.586]     }, error = function(ex) {
[17:00:28.586]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.586]                 ...future.rng), started = ...future.startTime, 
[17:00:28.586]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.586]             version = "1.8"), class = "FutureResult")
[17:00:28.586]     }, finally = {
[17:00:28.586]         if (!identical(...future.workdir, getwd())) 
[17:00:28.586]             setwd(...future.workdir)
[17:00:28.586]         {
[17:00:28.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.586]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.586]             }
[17:00:28.586]             base::options(...future.oldOptions)
[17:00:28.586]             if (.Platform$OS.type == "windows") {
[17:00:28.586]                 old_names <- names(...future.oldEnvVars)
[17:00:28.586]                 envs <- base::Sys.getenv()
[17:00:28.586]                 names <- names(envs)
[17:00:28.586]                 common <- intersect(names, old_names)
[17:00:28.586]                 added <- setdiff(names, old_names)
[17:00:28.586]                 removed <- setdiff(old_names, names)
[17:00:28.586]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.586]                   envs[common]]
[17:00:28.586]                 NAMES <- toupper(changed)
[17:00:28.586]                 args <- list()
[17:00:28.586]                 for (kk in seq_along(NAMES)) {
[17:00:28.586]                   name <- changed[[kk]]
[17:00:28.586]                   NAME <- NAMES[[kk]]
[17:00:28.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.586]                     next
[17:00:28.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.586]                 }
[17:00:28.586]                 NAMES <- toupper(added)
[17:00:28.586]                 for (kk in seq_along(NAMES)) {
[17:00:28.586]                   name <- added[[kk]]
[17:00:28.586]                   NAME <- NAMES[[kk]]
[17:00:28.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.586]                     next
[17:00:28.586]                   args[[name]] <- ""
[17:00:28.586]                 }
[17:00:28.586]                 NAMES <- toupper(removed)
[17:00:28.586]                 for (kk in seq_along(NAMES)) {
[17:00:28.586]                   name <- removed[[kk]]
[17:00:28.586]                   NAME <- NAMES[[kk]]
[17:00:28.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.586]                     next
[17:00:28.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.586]                 }
[17:00:28.586]                 if (length(args) > 0) 
[17:00:28.586]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.586]             }
[17:00:28.586]             else {
[17:00:28.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.586]             }
[17:00:28.586]             {
[17:00:28.586]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.586]                   0L) {
[17:00:28.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.586]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.586]                   base::options(opts)
[17:00:28.586]                 }
[17:00:28.586]                 {
[17:00:28.586]                   {
[17:00:28.586]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.586]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.586]                     2054632538L), envir = base::globalenv(), 
[17:00:28.586]                       inherits = FALSE)
[17:00:28.586]                     NULL
[17:00:28.586]                   }
[17:00:28.586]                   options(future.plan = NULL)
[17:00:28.586]                   if (is.na(NA_character_)) 
[17:00:28.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.586]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.586]                     .init = FALSE)
[17:00:28.586]                 }
[17:00:28.586]             }
[17:00:28.586]         }
[17:00:28.586]     })
[17:00:28.586]     if (TRUE) {
[17:00:28.586]         base::sink(type = "output", split = FALSE)
[17:00:28.586]         if (TRUE) {
[17:00:28.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.586]         }
[17:00:28.586]         else {
[17:00:28.586]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.586]         }
[17:00:28.586]         base::close(...future.stdout)
[17:00:28.586]         ...future.stdout <- NULL
[17:00:28.586]     }
[17:00:28.586]     ...future.result$conditions <- ...future.conditions
[17:00:28.586]     ...future.result$finished <- base::Sys.time()
[17:00:28.586]     ...future.result
[17:00:28.586] }
[17:00:28.587] assign_globals() ...
[17:00:28.587] List of 5
[17:00:28.587]  $ ...future.FUN            :function (x)  
[17:00:28.587]  $ MoreArgs                 : NULL
[17:00:28.587]  $ ...future.elements_ii    :List of 1
[17:00:28.587]   ..$ :List of 1
[17:00:28.587]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:00:28.587]  $ ...future.seeds_ii       : NULL
[17:00:28.587]  $ ...future.globals.maxSize: NULL
[17:00:28.587]  - attr(*, "where")=List of 5
[17:00:28.587]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.587]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.587]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.587]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.587]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.587]  - attr(*, "resolved")= logi FALSE
[17:00:28.587]  - attr(*, "total_size")= num 1128
[17:00:28.587]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.587]  - attr(*, "already-done")= logi TRUE
[17:00:28.592] - copied ‘...future.FUN’ to environment
[17:00:28.592] - copied ‘MoreArgs’ to environment
[17:00:28.592] - copied ‘...future.elements_ii’ to environment
[17:00:28.593] - copied ‘...future.seeds_ii’ to environment
[17:00:28.593] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.593] assign_globals() ... done
[17:00:28.593] plan(): Setting new future strategy stack:
[17:00:28.593] List of future strategies:
[17:00:28.593] 1. sequential:
[17:00:28.593]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.593]    - tweaked: FALSE
[17:00:28.593]    - call: NULL
[17:00:28.594] plan(): nbrOfWorkers() = 1
[17:00:28.594] plan(): Setting new future strategy stack:
[17:00:28.594] List of future strategies:
[17:00:28.594] 1. sequential:
[17:00:28.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.594]    - tweaked: FALSE
[17:00:28.594]    - call: plan(strategy)
[17:00:28.595] plan(): nbrOfWorkers() = 1
[17:00:28.595] SequentialFuture started (and completed)
[17:00:28.595] - Launch lazy future ... done
[17:00:28.595] run() for ‘SequentialFuture’ ... done
[17:00:28.595] Created future:
[17:00:28.595] SequentialFuture:
[17:00:28.595] Label: ‘future_mapply-1’
[17:00:28.595] Expression:
[17:00:28.595] {
[17:00:28.595]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.595]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.595]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.595]         on.exit(options(oopts), add = TRUE)
[17:00:28.595]     }
[17:00:28.595]     {
[17:00:28.595]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.595]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.595]         do.call(mapply, args = args)
[17:00:28.595]     }
[17:00:28.595] }
[17:00:28.595] Lazy evaluation: FALSE
[17:00:28.595] Asynchronous evaluation: FALSE
[17:00:28.595] Local evaluation: TRUE
[17:00:28.595] Environment: R_GlobalEnv
[17:00:28.595] Capture standard output: TRUE
[17:00:28.595] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.595] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.595] Packages: <none>
[17:00:28.595] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.595] Resolved: TRUE
[17:00:28.595] Value: 280 bytes of class ‘list’
[17:00:28.595] Early signaling: FALSE
[17:00:28.595] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.595] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.596] Chunk #1 of 1 ... DONE
[17:00:28.596] Launching 1 futures (chunks) ... DONE
[17:00:28.597] Resolving 1 futures (chunks) ...
[17:00:28.597] resolve() on list ...
[17:00:28.597]  recursive: 0
[17:00:28.597]  length: 1
[17:00:28.597] 
[17:00:28.597] resolved() for ‘SequentialFuture’ ...
[17:00:28.597] - state: ‘finished’
[17:00:28.597] - run: TRUE
[17:00:28.597] - result: ‘FutureResult’
[17:00:28.597] resolved() for ‘SequentialFuture’ ... done
[17:00:28.598] Future #1
[17:00:28.598] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.598] - nx: 1
[17:00:28.598] - relay: TRUE
[17:00:28.598] - stdout: TRUE
[17:00:28.598] - signal: TRUE
[17:00:28.598] - resignal: FALSE
[17:00:28.598] - force: TRUE
[17:00:28.598] - relayed: [n=1] FALSE
[17:00:28.598] - queued futures: [n=1] FALSE
[17:00:28.598]  - until=1
[17:00:28.599]  - relaying element #1
[17:00:28.599] - relayed: [n=1] TRUE
[17:00:28.599] - queued futures: [n=1] TRUE
[17:00:28.599] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.599]  length: 0 (resolved future 1)
[17:00:28.599] Relaying remaining futures
[17:00:28.599] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.599] - nx: 1
[17:00:28.599] - relay: TRUE
[17:00:28.600] - stdout: TRUE
[17:00:28.600] - signal: TRUE
[17:00:28.600] - resignal: FALSE
[17:00:28.600] - force: TRUE
[17:00:28.600] - relayed: [n=1] TRUE
[17:00:28.600] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.600] - relayed: [n=1] TRUE
[17:00:28.600] - queued futures: [n=1] TRUE
[17:00:28.600] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.600] resolve() on list ... DONE
[17:00:28.601]  - Number of value chunks collected: 1
[17:00:28.601] Resolving 1 futures (chunks) ... DONE
[17:00:28.601] Reducing values from 1 chunks ...
[17:00:28.601]  - Number of values collected after concatenation: 1
[17:00:28.601]  - Number of values expected: 1
[17:00:28.601] Reducing values from 1 chunks ... DONE
[17:00:28.601] future_mapply() ... DONE
[17:00:28.601] future_mapply() ...
[17:00:28.601] Number of chunks: 1
[17:00:28.601] getGlobalsAndPackagesXApply() ...
[17:00:28.602]  - future.globals: TRUE
[17:00:28.602] getGlobalsAndPackages() ...
[17:00:28.602] Searching for globals...
[17:00:28.603] - globals found: [1] ‘FUN’
[17:00:28.603] Searching for globals ... DONE
[17:00:28.603] Resolving globals: FALSE
[17:00:28.603] The total size of the 1 globals is 848 bytes (848 bytes)
[17:00:28.605] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:00:28.606] - globals: [1] ‘FUN’
[17:00:28.606] 
[17:00:28.606] getGlobalsAndPackages() ... DONE
[17:00:28.606]  - globals found/used: [n=1] ‘FUN’
[17:00:28.606]  - needed namespaces: [n=0] 
[17:00:28.606] Finding globals ... DONE
[17:00:28.606] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.607] List of 2
[17:00:28.607]  $ ...future.FUN:function (x)  
[17:00:28.607]  $ MoreArgs     : list()
[17:00:28.607]  - attr(*, "where")=List of 2
[17:00:28.607]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.607]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.607]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.607]  - attr(*, "resolved")= logi FALSE
[17:00:28.607]  - attr(*, "total_size")= num NA
[17:00:28.609] Packages to be attached in all futures: [n=0] 
[17:00:28.609] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.609] Number of futures (= number of chunks): 1
[17:00:28.610] Launching 1 futures (chunks) ...
[17:00:28.610] Chunk #1 of 1 ...
[17:00:28.610]  - Finding globals in '...' for chunk #1 ...
[17:00:28.610] getGlobalsAndPackages() ...
[17:00:28.610] Searching for globals...
[17:00:28.610] 
[17:00:28.610] Searching for globals ... DONE
[17:00:28.610] - globals: [0] <none>
[17:00:28.611] getGlobalsAndPackages() ... DONE
[17:00:28.611]    + additional globals found: [n=0] 
[17:00:28.611]    + additional namespaces needed: [n=0] 
[17:00:28.611]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.611]  - seeds: <none>
[17:00:28.611]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.611] getGlobalsAndPackages() ...
[17:00:28.611] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.611] Resolving globals: FALSE
[17:00:28.612] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:00:28.612] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:28.612] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.612] 
[17:00:28.612] getGlobalsAndPackages() ... DONE
[17:00:28.613] run() for ‘Future’ ...
[17:00:28.613] - state: ‘created’
[17:00:28.613] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.613] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.613] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.613]   - Field: ‘label’
[17:00:28.614]   - Field: ‘local’
[17:00:28.614]   - Field: ‘owner’
[17:00:28.614]   - Field: ‘envir’
[17:00:28.614]   - Field: ‘packages’
[17:00:28.614]   - Field: ‘gc’
[17:00:28.614]   - Field: ‘conditions’
[17:00:28.614]   - Field: ‘expr’
[17:00:28.614]   - Field: ‘uuid’
[17:00:28.614]   - Field: ‘seed’
[17:00:28.614]   - Field: ‘version’
[17:00:28.614]   - Field: ‘result’
[17:00:28.615]   - Field: ‘asynchronous’
[17:00:28.615]   - Field: ‘calls’
[17:00:28.615]   - Field: ‘globals’
[17:00:28.615]   - Field: ‘stdout’
[17:00:28.615]   - Field: ‘earlySignal’
[17:00:28.615]   - Field: ‘lazy’
[17:00:28.615]   - Field: ‘state’
[17:00:28.615] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.615] - Launch lazy future ...
[17:00:28.615] Packages needed by the future expression (n = 0): <none>
[17:00:28.616] Packages needed by future strategies (n = 0): <none>
[17:00:28.616] {
[17:00:28.616]     {
[17:00:28.616]         {
[17:00:28.616]             ...future.startTime <- base::Sys.time()
[17:00:28.616]             {
[17:00:28.616]                 {
[17:00:28.616]                   {
[17:00:28.616]                     base::local({
[17:00:28.616]                       has_future <- base::requireNamespace("future", 
[17:00:28.616]                         quietly = TRUE)
[17:00:28.616]                       if (has_future) {
[17:00:28.616]                         ns <- base::getNamespace("future")
[17:00:28.616]                         version <- ns[[".package"]][["version"]]
[17:00:28.616]                         if (is.null(version)) 
[17:00:28.616]                           version <- utils::packageVersion("future")
[17:00:28.616]                       }
[17:00:28.616]                       else {
[17:00:28.616]                         version <- NULL
[17:00:28.616]                       }
[17:00:28.616]                       if (!has_future || version < "1.8.0") {
[17:00:28.616]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.616]                           "", base::R.version$version.string), 
[17:00:28.616]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.616]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.616]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.616]                             "release", "version")], collapse = " "), 
[17:00:28.616]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.616]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.616]                           info)
[17:00:28.616]                         info <- base::paste(info, collapse = "; ")
[17:00:28.616]                         if (!has_future) {
[17:00:28.616]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.616]                             info)
[17:00:28.616]                         }
[17:00:28.616]                         else {
[17:00:28.616]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.616]                             info, version)
[17:00:28.616]                         }
[17:00:28.616]                         base::stop(msg)
[17:00:28.616]                       }
[17:00:28.616]                     })
[17:00:28.616]                   }
[17:00:28.616]                   ...future.strategy.old <- future::plan("list")
[17:00:28.616]                   options(future.plan = NULL)
[17:00:28.616]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.616]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.616]                 }
[17:00:28.616]                 ...future.workdir <- getwd()
[17:00:28.616]             }
[17:00:28.616]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.616]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.616]         }
[17:00:28.616]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.616]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.616]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.616]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.616]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.616]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.616]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.616]             base::names(...future.oldOptions))
[17:00:28.616]     }
[17:00:28.616]     if (FALSE) {
[17:00:28.616]     }
[17:00:28.616]     else {
[17:00:28.616]         if (TRUE) {
[17:00:28.616]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.616]                 open = "w")
[17:00:28.616]         }
[17:00:28.616]         else {
[17:00:28.616]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.616]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.616]         }
[17:00:28.616]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.616]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.616]             base::sink(type = "output", split = FALSE)
[17:00:28.616]             base::close(...future.stdout)
[17:00:28.616]         }, add = TRUE)
[17:00:28.616]     }
[17:00:28.616]     ...future.frame <- base::sys.nframe()
[17:00:28.616]     ...future.conditions <- base::list()
[17:00:28.616]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.616]     if (FALSE) {
[17:00:28.616]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.616]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.616]     }
[17:00:28.616]     ...future.result <- base::tryCatch({
[17:00:28.616]         base::withCallingHandlers({
[17:00:28.616]             ...future.value <- base::withVisible(base::local({
[17:00:28.616]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.616]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.616]                   ...future.globals.maxSize)) {
[17:00:28.616]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.616]                   on.exit(options(oopts), add = TRUE)
[17:00:28.616]                 }
[17:00:28.616]                 {
[17:00:28.616]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.616]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.616]                     USE.NAMES = FALSE)
[17:00:28.616]                   do.call(mapply, args = args)
[17:00:28.616]                 }
[17:00:28.616]             }))
[17:00:28.616]             future::FutureResult(value = ...future.value$value, 
[17:00:28.616]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.616]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.616]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.616]                     ...future.globalenv.names))
[17:00:28.616]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.616]         }, condition = base::local({
[17:00:28.616]             c <- base::c
[17:00:28.616]             inherits <- base::inherits
[17:00:28.616]             invokeRestart <- base::invokeRestart
[17:00:28.616]             length <- base::length
[17:00:28.616]             list <- base::list
[17:00:28.616]             seq.int <- base::seq.int
[17:00:28.616]             signalCondition <- base::signalCondition
[17:00:28.616]             sys.calls <- base::sys.calls
[17:00:28.616]             `[[` <- base::`[[`
[17:00:28.616]             `+` <- base::`+`
[17:00:28.616]             `<<-` <- base::`<<-`
[17:00:28.616]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.616]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.616]                   3L)]
[17:00:28.616]             }
[17:00:28.616]             function(cond) {
[17:00:28.616]                 is_error <- inherits(cond, "error")
[17:00:28.616]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.616]                   NULL)
[17:00:28.616]                 if (is_error) {
[17:00:28.616]                   sessionInformation <- function() {
[17:00:28.616]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.616]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.616]                       search = base::search(), system = base::Sys.info())
[17:00:28.616]                   }
[17:00:28.616]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.616]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.616]                     cond$call), session = sessionInformation(), 
[17:00:28.616]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.616]                   signalCondition(cond)
[17:00:28.616]                 }
[17:00:28.616]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.616]                 "immediateCondition"))) {
[17:00:28.616]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.616]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.616]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.616]                   if (TRUE && !signal) {
[17:00:28.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.616]                     {
[17:00:28.616]                       inherits <- base::inherits
[17:00:28.616]                       invokeRestart <- base::invokeRestart
[17:00:28.616]                       is.null <- base::is.null
[17:00:28.616]                       muffled <- FALSE
[17:00:28.616]                       if (inherits(cond, "message")) {
[17:00:28.616]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.616]                         if (muffled) 
[17:00:28.616]                           invokeRestart("muffleMessage")
[17:00:28.616]                       }
[17:00:28.616]                       else if (inherits(cond, "warning")) {
[17:00:28.616]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.616]                         if (muffled) 
[17:00:28.616]                           invokeRestart("muffleWarning")
[17:00:28.616]                       }
[17:00:28.616]                       else if (inherits(cond, "condition")) {
[17:00:28.616]                         if (!is.null(pattern)) {
[17:00:28.616]                           computeRestarts <- base::computeRestarts
[17:00:28.616]                           grepl <- base::grepl
[17:00:28.616]                           restarts <- computeRestarts(cond)
[17:00:28.616]                           for (restart in restarts) {
[17:00:28.616]                             name <- restart$name
[17:00:28.616]                             if (is.null(name)) 
[17:00:28.616]                               next
[17:00:28.616]                             if (!grepl(pattern, name)) 
[17:00:28.616]                               next
[17:00:28.616]                             invokeRestart(restart)
[17:00:28.616]                             muffled <- TRUE
[17:00:28.616]                             break
[17:00:28.616]                           }
[17:00:28.616]                         }
[17:00:28.616]                       }
[17:00:28.616]                       invisible(muffled)
[17:00:28.616]                     }
[17:00:28.616]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.616]                   }
[17:00:28.616]                 }
[17:00:28.616]                 else {
[17:00:28.616]                   if (TRUE) {
[17:00:28.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.616]                     {
[17:00:28.616]                       inherits <- base::inherits
[17:00:28.616]                       invokeRestart <- base::invokeRestart
[17:00:28.616]                       is.null <- base::is.null
[17:00:28.616]                       muffled <- FALSE
[17:00:28.616]                       if (inherits(cond, "message")) {
[17:00:28.616]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.616]                         if (muffled) 
[17:00:28.616]                           invokeRestart("muffleMessage")
[17:00:28.616]                       }
[17:00:28.616]                       else if (inherits(cond, "warning")) {
[17:00:28.616]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.616]                         if (muffled) 
[17:00:28.616]                           invokeRestart("muffleWarning")
[17:00:28.616]                       }
[17:00:28.616]                       else if (inherits(cond, "condition")) {
[17:00:28.616]                         if (!is.null(pattern)) {
[17:00:28.616]                           computeRestarts <- base::computeRestarts
[17:00:28.616]                           grepl <- base::grepl
[17:00:28.616]                           restarts <- computeRestarts(cond)
[17:00:28.616]                           for (restart in restarts) {
[17:00:28.616]                             name <- restart$name
[17:00:28.616]                             if (is.null(name)) 
[17:00:28.616]                               next
[17:00:28.616]                             if (!grepl(pattern, name)) 
[17:00:28.616]                               next
[17:00:28.616]                             invokeRestart(restart)
[17:00:28.616]                             muffled <- TRUE
[17:00:28.616]                             break
[17:00:28.616]                           }
[17:00:28.616]                         }
[17:00:28.616]                       }
[17:00:28.616]                       invisible(muffled)
[17:00:28.616]                     }
[17:00:28.616]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.616]                   }
[17:00:28.616]                 }
[17:00:28.616]             }
[17:00:28.616]         }))
[17:00:28.616]     }, error = function(ex) {
[17:00:28.616]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.616]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.616]                 ...future.rng), started = ...future.startTime, 
[17:00:28.616]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.616]             version = "1.8"), class = "FutureResult")
[17:00:28.616]     }, finally = {
[17:00:28.616]         if (!identical(...future.workdir, getwd())) 
[17:00:28.616]             setwd(...future.workdir)
[17:00:28.616]         {
[17:00:28.616]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.616]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.616]             }
[17:00:28.616]             base::options(...future.oldOptions)
[17:00:28.616]             if (.Platform$OS.type == "windows") {
[17:00:28.616]                 old_names <- names(...future.oldEnvVars)
[17:00:28.616]                 envs <- base::Sys.getenv()
[17:00:28.616]                 names <- names(envs)
[17:00:28.616]                 common <- intersect(names, old_names)
[17:00:28.616]                 added <- setdiff(names, old_names)
[17:00:28.616]                 removed <- setdiff(old_names, names)
[17:00:28.616]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.616]                   envs[common]]
[17:00:28.616]                 NAMES <- toupper(changed)
[17:00:28.616]                 args <- list()
[17:00:28.616]                 for (kk in seq_along(NAMES)) {
[17:00:28.616]                   name <- changed[[kk]]
[17:00:28.616]                   NAME <- NAMES[[kk]]
[17:00:28.616]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.616]                     next
[17:00:28.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.616]                 }
[17:00:28.616]                 NAMES <- toupper(added)
[17:00:28.616]                 for (kk in seq_along(NAMES)) {
[17:00:28.616]                   name <- added[[kk]]
[17:00:28.616]                   NAME <- NAMES[[kk]]
[17:00:28.616]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.616]                     next
[17:00:28.616]                   args[[name]] <- ""
[17:00:28.616]                 }
[17:00:28.616]                 NAMES <- toupper(removed)
[17:00:28.616]                 for (kk in seq_along(NAMES)) {
[17:00:28.616]                   name <- removed[[kk]]
[17:00:28.616]                   NAME <- NAMES[[kk]]
[17:00:28.616]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.616]                     next
[17:00:28.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.616]                 }
[17:00:28.616]                 if (length(args) > 0) 
[17:00:28.616]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.616]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.616]             }
[17:00:28.616]             else {
[17:00:28.616]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.616]             }
[17:00:28.616]             {
[17:00:28.616]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.616]                   0L) {
[17:00:28.616]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.616]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.616]                   base::options(opts)
[17:00:28.616]                 }
[17:00:28.616]                 {
[17:00:28.616]                   {
[17:00:28.616]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.616]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.616]                     2054632538L), envir = base::globalenv(), 
[17:00:28.616]                       inherits = FALSE)
[17:00:28.616]                     NULL
[17:00:28.616]                   }
[17:00:28.616]                   options(future.plan = NULL)
[17:00:28.616]                   if (is.na(NA_character_)) 
[17:00:28.616]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.616]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.616]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.616]                     .init = FALSE)
[17:00:28.616]                 }
[17:00:28.616]             }
[17:00:28.616]         }
[17:00:28.616]     })
[17:00:28.616]     if (TRUE) {
[17:00:28.616]         base::sink(type = "output", split = FALSE)
[17:00:28.616]         if (TRUE) {
[17:00:28.616]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.616]         }
[17:00:28.616]         else {
[17:00:28.616]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.616]         }
[17:00:28.616]         base::close(...future.stdout)
[17:00:28.616]         ...future.stdout <- NULL
[17:00:28.616]     }
[17:00:28.616]     ...future.result$conditions <- ...future.conditions
[17:00:28.616]     ...future.result$finished <- base::Sys.time()
[17:00:28.616]     ...future.result
[17:00:28.616] }
[17:00:28.618] assign_globals() ...
[17:00:28.618] List of 5
[17:00:28.618]  $ ...future.FUN            :function (x)  
[17:00:28.618]  $ MoreArgs                 : list()
[17:00:28.618]  $ ...future.elements_ii    :List of 1
[17:00:28.618]   ..$ :List of 1
[17:00:28.618]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:00:28.618]  $ ...future.seeds_ii       : NULL
[17:00:28.618]  $ ...future.globals.maxSize: NULL
[17:00:28.618]  - attr(*, "where")=List of 5
[17:00:28.618]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.618]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.618]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.618]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.618]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.618]  - attr(*, "resolved")= logi FALSE
[17:00:28.618]  - attr(*, "total_size")= num 1128
[17:00:28.618]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.618]  - attr(*, "already-done")= logi TRUE
[17:00:28.622] - copied ‘...future.FUN’ to environment
[17:00:28.622] - copied ‘MoreArgs’ to environment
[17:00:28.622] - copied ‘...future.elements_ii’ to environment
[17:00:28.623] - copied ‘...future.seeds_ii’ to environment
[17:00:28.623] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.623] assign_globals() ... done
[17:00:28.623] plan(): Setting new future strategy stack:
[17:00:28.623] List of future strategies:
[17:00:28.623] 1. sequential:
[17:00:28.623]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.623]    - tweaked: FALSE
[17:00:28.623]    - call: NULL
[17:00:28.624] plan(): nbrOfWorkers() = 1
[17:00:28.624] plan(): Setting new future strategy stack:
[17:00:28.624] List of future strategies:
[17:00:28.624] 1. sequential:
[17:00:28.624]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.624]    - tweaked: FALSE
[17:00:28.624]    - call: plan(strategy)
[17:00:28.625] plan(): nbrOfWorkers() = 1
[17:00:28.625] SequentialFuture started (and completed)
[17:00:28.625] - Launch lazy future ... done
[17:00:28.625] run() for ‘SequentialFuture’ ... done
[17:00:28.625] Created future:
[17:00:28.625] SequentialFuture:
[17:00:28.625] Label: ‘future_.mapply-1’
[17:00:28.625] Expression:
[17:00:28.625] {
[17:00:28.625]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.625]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.625]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.625]         on.exit(options(oopts), add = TRUE)
[17:00:28.625]     }
[17:00:28.625]     {
[17:00:28.625]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.625]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.625]         do.call(mapply, args = args)
[17:00:28.625]     }
[17:00:28.625] }
[17:00:28.625] Lazy evaluation: FALSE
[17:00:28.625] Asynchronous evaluation: FALSE
[17:00:28.625] Local evaluation: TRUE
[17:00:28.625] Environment: R_GlobalEnv
[17:00:28.625] Capture standard output: TRUE
[17:00:28.625] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.625] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.625] Packages: <none>
[17:00:28.625] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.625] Resolved: TRUE
[17:00:28.625] Value: 280 bytes of class ‘list’
[17:00:28.625] Early signaling: FALSE
[17:00:28.625] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.625] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.626] Chunk #1 of 1 ... DONE
[17:00:28.626] Launching 1 futures (chunks) ... DONE
[17:00:28.627] Resolving 1 futures (chunks) ...
[17:00:28.627] resolve() on list ...
[17:00:28.627]  recursive: 0
[17:00:28.627]  length: 1
[17:00:28.627] 
[17:00:28.627] resolved() for ‘SequentialFuture’ ...
[17:00:28.627] - state: ‘finished’
[17:00:28.627] - run: TRUE
[17:00:28.627] - result: ‘FutureResult’
[17:00:28.627] resolved() for ‘SequentialFuture’ ... done
[17:00:28.627] Future #1
[17:00:28.628] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.628] - nx: 1
[17:00:28.628] - relay: TRUE
[17:00:28.628] - stdout: TRUE
[17:00:28.628] - signal: TRUE
[17:00:28.628] - resignal: FALSE
[17:00:28.628] - force: TRUE
[17:00:28.628] - relayed: [n=1] FALSE
[17:00:28.628] - queued futures: [n=1] FALSE
[17:00:28.628]  - until=1
[17:00:28.629]  - relaying element #1
[17:00:28.629] - relayed: [n=1] TRUE
[17:00:28.629] - queued futures: [n=1] TRUE
[17:00:28.629] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.629]  length: 0 (resolved future 1)
[17:00:28.629] Relaying remaining futures
[17:00:28.629] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.629] - nx: 1
[17:00:28.629] - relay: TRUE
[17:00:28.631] - stdout: TRUE
[17:00:28.631] - signal: TRUE
[17:00:28.632] - resignal: FALSE
[17:00:28.632] - force: TRUE
[17:00:28.632] - relayed: [n=1] TRUE
[17:00:28.632] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.632] - relayed: [n=1] TRUE
[17:00:28.632] - queued futures: [n=1] TRUE
[17:00:28.632] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.632] resolve() on list ... DONE
[17:00:28.633]  - Number of value chunks collected: 1
[17:00:28.633] Resolving 1 futures (chunks) ... DONE
[17:00:28.633] Reducing values from 1 chunks ...
[17:00:28.633]  - Number of values collected after concatenation: 1
[17:00:28.633]  - Number of values expected: 1
[17:00:28.633] Reducing values from 1 chunks ... DONE
[17:00:28.633] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[17:00:28.633] future_mapply() ...
[17:00:28.634] Number of chunks: 1
[17:00:28.634] getGlobalsAndPackagesXApply() ...
[17:00:28.634]  - future.globals: TRUE
[17:00:28.634] getGlobalsAndPackages() ...
[17:00:28.634] Searching for globals...
[17:00:28.635] - globals found: [1] ‘FUN’
[17:00:28.635] Searching for globals ... DONE
[17:00:28.635] Resolving globals: FALSE
[17:00:28.636] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:00:28.636] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:00:28.636] - globals: [1] ‘FUN’
[17:00:28.636] 
[17:00:28.636] getGlobalsAndPackages() ... DONE
[17:00:28.636]  - globals found/used: [n=1] ‘FUN’
[17:00:28.636]  - needed namespaces: [n=0] 
[17:00:28.637] Finding globals ... DONE
[17:00:28.637] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.637] List of 2
[17:00:28.637]  $ ...future.FUN:function (x, y)  
[17:00:28.637]  $ MoreArgs     :List of 1
[17:00:28.637]   ..$ y: int [1:2] 3 4
[17:00:28.637]  - attr(*, "where")=List of 2
[17:00:28.637]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.637]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.637]  - attr(*, "resolved")= logi FALSE
[17:00:28.637]  - attr(*, "total_size")= num NA
[17:00:28.640] Packages to be attached in all futures: [n=0] 
[17:00:28.640] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.640] Number of futures (= number of chunks): 1
[17:00:28.640] Launching 1 futures (chunks) ...
[17:00:28.640] Chunk #1 of 1 ...
[17:00:28.640]  - Finding globals in '...' for chunk #1 ...
[17:00:28.640] getGlobalsAndPackages() ...
[17:00:28.641] Searching for globals...
[17:00:28.641] 
[17:00:28.641] Searching for globals ... DONE
[17:00:28.641] - globals: [0] <none>
[17:00:28.641] getGlobalsAndPackages() ... DONE
[17:00:28.641]    + additional globals found: [n=0] 
[17:00:28.641]    + additional namespaces needed: [n=0] 
[17:00:28.641]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.642]  - seeds: <none>
[17:00:28.642]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.642] getGlobalsAndPackages() ...
[17:00:28.642] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.642] Resolving globals: FALSE
[17:00:28.642] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[17:00:28.643] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:28.643] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.643] 
[17:00:28.643] getGlobalsAndPackages() ... DONE
[17:00:28.643] run() for ‘Future’ ...
[17:00:28.644] - state: ‘created’
[17:00:28.644] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.644] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.644] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.644]   - Field: ‘label’
[17:00:28.644]   - Field: ‘local’
[17:00:28.644]   - Field: ‘owner’
[17:00:28.644]   - Field: ‘envir’
[17:00:28.645]   - Field: ‘packages’
[17:00:28.645]   - Field: ‘gc’
[17:00:28.645]   - Field: ‘conditions’
[17:00:28.645]   - Field: ‘expr’
[17:00:28.645]   - Field: ‘uuid’
[17:00:28.645]   - Field: ‘seed’
[17:00:28.645]   - Field: ‘version’
[17:00:28.645]   - Field: ‘result’
[17:00:28.645]   - Field: ‘asynchronous’
[17:00:28.645]   - Field: ‘calls’
[17:00:28.645]   - Field: ‘globals’
[17:00:28.646]   - Field: ‘stdout’
[17:00:28.646]   - Field: ‘earlySignal’
[17:00:28.646]   - Field: ‘lazy’
[17:00:28.646]   - Field: ‘state’
[17:00:28.646] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.646] - Launch lazy future ...
[17:00:28.646] Packages needed by the future expression (n = 0): <none>
[17:00:28.646] Packages needed by future strategies (n = 0): <none>
[17:00:28.647] {
[17:00:28.647]     {
[17:00:28.647]         {
[17:00:28.647]             ...future.startTime <- base::Sys.time()
[17:00:28.647]             {
[17:00:28.647]                 {
[17:00:28.647]                   {
[17:00:28.647]                     base::local({
[17:00:28.647]                       has_future <- base::requireNamespace("future", 
[17:00:28.647]                         quietly = TRUE)
[17:00:28.647]                       if (has_future) {
[17:00:28.647]                         ns <- base::getNamespace("future")
[17:00:28.647]                         version <- ns[[".package"]][["version"]]
[17:00:28.647]                         if (is.null(version)) 
[17:00:28.647]                           version <- utils::packageVersion("future")
[17:00:28.647]                       }
[17:00:28.647]                       else {
[17:00:28.647]                         version <- NULL
[17:00:28.647]                       }
[17:00:28.647]                       if (!has_future || version < "1.8.0") {
[17:00:28.647]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.647]                           "", base::R.version$version.string), 
[17:00:28.647]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.647]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.647]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.647]                             "release", "version")], collapse = " "), 
[17:00:28.647]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.647]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.647]                           info)
[17:00:28.647]                         info <- base::paste(info, collapse = "; ")
[17:00:28.647]                         if (!has_future) {
[17:00:28.647]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.647]                             info)
[17:00:28.647]                         }
[17:00:28.647]                         else {
[17:00:28.647]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.647]                             info, version)
[17:00:28.647]                         }
[17:00:28.647]                         base::stop(msg)
[17:00:28.647]                       }
[17:00:28.647]                     })
[17:00:28.647]                   }
[17:00:28.647]                   ...future.strategy.old <- future::plan("list")
[17:00:28.647]                   options(future.plan = NULL)
[17:00:28.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.647]                 }
[17:00:28.647]                 ...future.workdir <- getwd()
[17:00:28.647]             }
[17:00:28.647]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.647]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.647]         }
[17:00:28.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.647]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.647]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.647]             base::names(...future.oldOptions))
[17:00:28.647]     }
[17:00:28.647]     if (FALSE) {
[17:00:28.647]     }
[17:00:28.647]     else {
[17:00:28.647]         if (TRUE) {
[17:00:28.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.647]                 open = "w")
[17:00:28.647]         }
[17:00:28.647]         else {
[17:00:28.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.647]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.647]         }
[17:00:28.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.647]             base::sink(type = "output", split = FALSE)
[17:00:28.647]             base::close(...future.stdout)
[17:00:28.647]         }, add = TRUE)
[17:00:28.647]     }
[17:00:28.647]     ...future.frame <- base::sys.nframe()
[17:00:28.647]     ...future.conditions <- base::list()
[17:00:28.647]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.647]     if (FALSE) {
[17:00:28.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.647]     }
[17:00:28.647]     ...future.result <- base::tryCatch({
[17:00:28.647]         base::withCallingHandlers({
[17:00:28.647]             ...future.value <- base::withVisible(base::local({
[17:00:28.647]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.647]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.647]                   ...future.globals.maxSize)) {
[17:00:28.647]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.647]                   on.exit(options(oopts), add = TRUE)
[17:00:28.647]                 }
[17:00:28.647]                 {
[17:00:28.647]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.647]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.647]                     USE.NAMES = FALSE)
[17:00:28.647]                   do.call(mapply, args = args)
[17:00:28.647]                 }
[17:00:28.647]             }))
[17:00:28.647]             future::FutureResult(value = ...future.value$value, 
[17:00:28.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.647]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.647]                     ...future.globalenv.names))
[17:00:28.647]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.647]         }, condition = base::local({
[17:00:28.647]             c <- base::c
[17:00:28.647]             inherits <- base::inherits
[17:00:28.647]             invokeRestart <- base::invokeRestart
[17:00:28.647]             length <- base::length
[17:00:28.647]             list <- base::list
[17:00:28.647]             seq.int <- base::seq.int
[17:00:28.647]             signalCondition <- base::signalCondition
[17:00:28.647]             sys.calls <- base::sys.calls
[17:00:28.647]             `[[` <- base::`[[`
[17:00:28.647]             `+` <- base::`+`
[17:00:28.647]             `<<-` <- base::`<<-`
[17:00:28.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.647]                   3L)]
[17:00:28.647]             }
[17:00:28.647]             function(cond) {
[17:00:28.647]                 is_error <- inherits(cond, "error")
[17:00:28.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.647]                   NULL)
[17:00:28.647]                 if (is_error) {
[17:00:28.647]                   sessionInformation <- function() {
[17:00:28.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.647]                       search = base::search(), system = base::Sys.info())
[17:00:28.647]                   }
[17:00:28.647]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.647]                     cond$call), session = sessionInformation(), 
[17:00:28.647]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.647]                   signalCondition(cond)
[17:00:28.647]                 }
[17:00:28.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.647]                 "immediateCondition"))) {
[17:00:28.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.647]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.647]                   if (TRUE && !signal) {
[17:00:28.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.647]                     {
[17:00:28.647]                       inherits <- base::inherits
[17:00:28.647]                       invokeRestart <- base::invokeRestart
[17:00:28.647]                       is.null <- base::is.null
[17:00:28.647]                       muffled <- FALSE
[17:00:28.647]                       if (inherits(cond, "message")) {
[17:00:28.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.647]                         if (muffled) 
[17:00:28.647]                           invokeRestart("muffleMessage")
[17:00:28.647]                       }
[17:00:28.647]                       else if (inherits(cond, "warning")) {
[17:00:28.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.647]                         if (muffled) 
[17:00:28.647]                           invokeRestart("muffleWarning")
[17:00:28.647]                       }
[17:00:28.647]                       else if (inherits(cond, "condition")) {
[17:00:28.647]                         if (!is.null(pattern)) {
[17:00:28.647]                           computeRestarts <- base::computeRestarts
[17:00:28.647]                           grepl <- base::grepl
[17:00:28.647]                           restarts <- computeRestarts(cond)
[17:00:28.647]                           for (restart in restarts) {
[17:00:28.647]                             name <- restart$name
[17:00:28.647]                             if (is.null(name)) 
[17:00:28.647]                               next
[17:00:28.647]                             if (!grepl(pattern, name)) 
[17:00:28.647]                               next
[17:00:28.647]                             invokeRestart(restart)
[17:00:28.647]                             muffled <- TRUE
[17:00:28.647]                             break
[17:00:28.647]                           }
[17:00:28.647]                         }
[17:00:28.647]                       }
[17:00:28.647]                       invisible(muffled)
[17:00:28.647]                     }
[17:00:28.647]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.647]                   }
[17:00:28.647]                 }
[17:00:28.647]                 else {
[17:00:28.647]                   if (TRUE) {
[17:00:28.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.647]                     {
[17:00:28.647]                       inherits <- base::inherits
[17:00:28.647]                       invokeRestart <- base::invokeRestart
[17:00:28.647]                       is.null <- base::is.null
[17:00:28.647]                       muffled <- FALSE
[17:00:28.647]                       if (inherits(cond, "message")) {
[17:00:28.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.647]                         if (muffled) 
[17:00:28.647]                           invokeRestart("muffleMessage")
[17:00:28.647]                       }
[17:00:28.647]                       else if (inherits(cond, "warning")) {
[17:00:28.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.647]                         if (muffled) 
[17:00:28.647]                           invokeRestart("muffleWarning")
[17:00:28.647]                       }
[17:00:28.647]                       else if (inherits(cond, "condition")) {
[17:00:28.647]                         if (!is.null(pattern)) {
[17:00:28.647]                           computeRestarts <- base::computeRestarts
[17:00:28.647]                           grepl <- base::grepl
[17:00:28.647]                           restarts <- computeRestarts(cond)
[17:00:28.647]                           for (restart in restarts) {
[17:00:28.647]                             name <- restart$name
[17:00:28.647]                             if (is.null(name)) 
[17:00:28.647]                               next
[17:00:28.647]                             if (!grepl(pattern, name)) 
[17:00:28.647]                               next
[17:00:28.647]                             invokeRestart(restart)
[17:00:28.647]                             muffled <- TRUE
[17:00:28.647]                             break
[17:00:28.647]                           }
[17:00:28.647]                         }
[17:00:28.647]                       }
[17:00:28.647]                       invisible(muffled)
[17:00:28.647]                     }
[17:00:28.647]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.647]                   }
[17:00:28.647]                 }
[17:00:28.647]             }
[17:00:28.647]         }))
[17:00:28.647]     }, error = function(ex) {
[17:00:28.647]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.647]                 ...future.rng), started = ...future.startTime, 
[17:00:28.647]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.647]             version = "1.8"), class = "FutureResult")
[17:00:28.647]     }, finally = {
[17:00:28.647]         if (!identical(...future.workdir, getwd())) 
[17:00:28.647]             setwd(...future.workdir)
[17:00:28.647]         {
[17:00:28.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.647]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.647]             }
[17:00:28.647]             base::options(...future.oldOptions)
[17:00:28.647]             if (.Platform$OS.type == "windows") {
[17:00:28.647]                 old_names <- names(...future.oldEnvVars)
[17:00:28.647]                 envs <- base::Sys.getenv()
[17:00:28.647]                 names <- names(envs)
[17:00:28.647]                 common <- intersect(names, old_names)
[17:00:28.647]                 added <- setdiff(names, old_names)
[17:00:28.647]                 removed <- setdiff(old_names, names)
[17:00:28.647]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.647]                   envs[common]]
[17:00:28.647]                 NAMES <- toupper(changed)
[17:00:28.647]                 args <- list()
[17:00:28.647]                 for (kk in seq_along(NAMES)) {
[17:00:28.647]                   name <- changed[[kk]]
[17:00:28.647]                   NAME <- NAMES[[kk]]
[17:00:28.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.647]                     next
[17:00:28.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.647]                 }
[17:00:28.647]                 NAMES <- toupper(added)
[17:00:28.647]                 for (kk in seq_along(NAMES)) {
[17:00:28.647]                   name <- added[[kk]]
[17:00:28.647]                   NAME <- NAMES[[kk]]
[17:00:28.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.647]                     next
[17:00:28.647]                   args[[name]] <- ""
[17:00:28.647]                 }
[17:00:28.647]                 NAMES <- toupper(removed)
[17:00:28.647]                 for (kk in seq_along(NAMES)) {
[17:00:28.647]                   name <- removed[[kk]]
[17:00:28.647]                   NAME <- NAMES[[kk]]
[17:00:28.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.647]                     next
[17:00:28.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.647]                 }
[17:00:28.647]                 if (length(args) > 0) 
[17:00:28.647]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.647]             }
[17:00:28.647]             else {
[17:00:28.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.647]             }
[17:00:28.647]             {
[17:00:28.647]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.647]                   0L) {
[17:00:28.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.647]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.647]                   base::options(opts)
[17:00:28.647]                 }
[17:00:28.647]                 {
[17:00:28.647]                   {
[17:00:28.647]                     base::assign(".Random.seed", c(10407L, 225186124L, 
[17:00:28.647]                     229495892L, 1624550703L, 1511001139L, -125291998L, 
[17:00:28.647]                     2054632538L), envir = base::globalenv(), 
[17:00:28.647]                       inherits = FALSE)
[17:00:28.647]                     NULL
[17:00:28.647]                   }
[17:00:28.647]                   options(future.plan = NULL)
[17:00:28.647]                   if (is.na(NA_character_)) 
[17:00:28.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.647]                     .init = FALSE)
[17:00:28.647]                 }
[17:00:28.647]             }
[17:00:28.647]         }
[17:00:28.647]     })
[17:00:28.647]     if (TRUE) {
[17:00:28.647]         base::sink(type = "output", split = FALSE)
[17:00:28.647]         if (TRUE) {
[17:00:28.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.647]         }
[17:00:28.647]         else {
[17:00:28.647]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.647]         }
[17:00:28.647]         base::close(...future.stdout)
[17:00:28.647]         ...future.stdout <- NULL
[17:00:28.647]     }
[17:00:28.647]     ...future.result$conditions <- ...future.conditions
[17:00:28.647]     ...future.result$finished <- base::Sys.time()
[17:00:28.647]     ...future.result
[17:00:28.647] }
[17:00:28.648] assign_globals() ...
[17:00:28.649] List of 5
[17:00:28.649]  $ ...future.FUN            :function (x, y)  
[17:00:28.649]  $ MoreArgs                 :List of 1
[17:00:28.649]   ..$ y: int [1:2] 3 4
[17:00:28.649]  $ ...future.elements_ii    :List of 1
[17:00:28.649]   ..$ x:List of 2
[17:00:28.649]   .. ..$ : int 1
[17:00:28.649]   .. ..$ : int 2
[17:00:28.649]  $ ...future.seeds_ii       : NULL
[17:00:28.649]  $ ...future.globals.maxSize: NULL
[17:00:28.649]  - attr(*, "where")=List of 5
[17:00:28.649]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.649]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.649]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.649]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.649]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.649]  - attr(*, "resolved")= logi FALSE
[17:00:28.649]  - attr(*, "total_size")= num 1872
[17:00:28.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.649]  - attr(*, "already-done")= logi TRUE
[17:00:28.654] - reassign environment for ‘...future.FUN’
[17:00:28.654] - copied ‘...future.FUN’ to environment
[17:00:28.654] - copied ‘MoreArgs’ to environment
[17:00:28.654] - copied ‘...future.elements_ii’ to environment
[17:00:28.654] - copied ‘...future.seeds_ii’ to environment
[17:00:28.654] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.654] assign_globals() ... done
[17:00:28.654] plan(): Setting new future strategy stack:
[17:00:28.655] List of future strategies:
[17:00:28.655] 1. sequential:
[17:00:28.655]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.655]    - tweaked: FALSE
[17:00:28.655]    - call: NULL
[17:00:28.655] plan(): nbrOfWorkers() = 1
[17:00:28.658] plan(): Setting new future strategy stack:
[17:00:28.658] List of future strategies:
[17:00:28.658] 1. sequential:
[17:00:28.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.658]    - tweaked: FALSE
[17:00:28.658]    - call: plan(strategy)
[17:00:28.658] plan(): nbrOfWorkers() = 1
[17:00:28.659] SequentialFuture started (and completed)
[17:00:28.659] - Launch lazy future ... done
[17:00:28.659] run() for ‘SequentialFuture’ ... done
[17:00:28.659] Created future:
[17:00:28.659] SequentialFuture:
[17:00:28.659] Label: ‘future_mapply-1’
[17:00:28.659] Expression:
[17:00:28.659] {
[17:00:28.659]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.659]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.659]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.659]         on.exit(options(oopts), add = TRUE)
[17:00:28.659]     }
[17:00:28.659]     {
[17:00:28.659]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.659]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.659]         do.call(mapply, args = args)
[17:00:28.659]     }
[17:00:28.659] }
[17:00:28.659] Lazy evaluation: FALSE
[17:00:28.659] Asynchronous evaluation: FALSE
[17:00:28.659] Local evaluation: TRUE
[17:00:28.659] Environment: R_GlobalEnv
[17:00:28.659] Capture standard output: TRUE
[17:00:28.659] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.659] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.659] Packages: <none>
[17:00:28.659] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.659] Resolved: TRUE
[17:00:28.659] Value: 112 bytes of class ‘list’
[17:00:28.659] Early signaling: FALSE
[17:00:28.659] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.659] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.660] Chunk #1 of 1 ... DONE
[17:00:28.660] Launching 1 futures (chunks) ... DONE
[17:00:28.660] Resolving 1 futures (chunks) ...
[17:00:28.660] resolve() on list ...
[17:00:28.660]  recursive: 0
[17:00:28.660]  length: 1
[17:00:28.661] 
[17:00:28.661] resolved() for ‘SequentialFuture’ ...
[17:00:28.661] - state: ‘finished’
[17:00:28.661] - run: TRUE
[17:00:28.661] - result: ‘FutureResult’
[17:00:28.661] resolved() for ‘SequentialFuture’ ... done
[17:00:28.661] Future #1
[17:00:28.661] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.661] - nx: 1
[17:00:28.661] - relay: TRUE
[17:00:28.662] - stdout: TRUE
[17:00:28.662] - signal: TRUE
[17:00:28.662] - resignal: FALSE
[17:00:28.662] - force: TRUE
[17:00:28.662] - relayed: [n=1] FALSE
[17:00:28.662] - queued futures: [n=1] FALSE
[17:00:28.662]  - until=1
[17:00:28.662]  - relaying element #1
[17:00:28.662] - relayed: [n=1] TRUE
[17:00:28.662] - queued futures: [n=1] TRUE
[17:00:28.663] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.663]  length: 0 (resolved future 1)
[17:00:28.663] Relaying remaining futures
[17:00:28.663] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.663] - nx: 1
[17:00:28.663] - relay: TRUE
[17:00:28.663] - stdout: TRUE
[17:00:28.663] - signal: TRUE
[17:00:28.663] - resignal: FALSE
[17:00:28.663] - force: TRUE
[17:00:28.663] - relayed: [n=1] TRUE
[17:00:28.664] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.664] - relayed: [n=1] TRUE
[17:00:28.664] - queued futures: [n=1] TRUE
[17:00:28.664] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.664] resolve() on list ... DONE
[17:00:28.664]  - Number of value chunks collected: 1
[17:00:28.664] Resolving 1 futures (chunks) ... DONE
[17:00:28.664] Reducing values from 1 chunks ...
[17:00:28.664]  - Number of values collected after concatenation: 2
[17:00:28.664]  - Number of values expected: 2
[17:00:28.665] Reducing values from 1 chunks ... DONE
[17:00:28.665] future_mapply() ... DONE
[17:00:28.665] future_mapply() ...
[17:00:28.665] Generating random seeds ...
[17:00:28.665] Generating random seed streams for 2 elements ...
[17:00:28.665] Generating random seed streams for 2 elements ... DONE
[17:00:28.665] Generating random seeds ... DONE
[17:00:28.665] Will set RNG state on exit: 10407, 1624550703, -922435925, 962809165, 2054632538, 1051373140, 1348729052
[17:00:28.665] Number of chunks: 1
[17:00:28.666] getGlobalsAndPackagesXApply() ...
[17:00:28.666]  - future.globals: TRUE
[17:00:28.666] getGlobalsAndPackages() ...
[17:00:28.666] Searching for globals...
[17:00:28.667] - globals found: [1] ‘FUN’
[17:00:28.667] Searching for globals ... DONE
[17:00:28.667] Resolving globals: FALSE
[17:00:28.667] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:00:28.668] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:00:28.668] - globals: [1] ‘FUN’
[17:00:28.668] 
[17:00:28.668] getGlobalsAndPackages() ... DONE
[17:00:28.668]  - globals found/used: [n=1] ‘FUN’
[17:00:28.668]  - needed namespaces: [n=0] 
[17:00:28.668] Finding globals ... DONE
[17:00:28.669] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.669] List of 2
[17:00:28.669]  $ ...future.FUN:function (x, y)  
[17:00:28.669]  $ MoreArgs     :List of 1
[17:00:28.669]   ..$ y: int [1:2] 3 4
[17:00:28.669]  - attr(*, "where")=List of 2
[17:00:28.669]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.669]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.669]  - attr(*, "resolved")= logi FALSE
[17:00:28.669]  - attr(*, "total_size")= num NA
[17:00:28.672] Packages to be attached in all futures: [n=0] 
[17:00:28.672] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.672] Number of futures (= number of chunks): 1
[17:00:28.672] Launching 1 futures (chunks) ...
[17:00:28.672] Chunk #1 of 1 ...
[17:00:28.672]  - Finding globals in '...' for chunk #1 ...
[17:00:28.672] getGlobalsAndPackages() ...
[17:00:28.672] Searching for globals...
[17:00:28.673] 
[17:00:28.673] Searching for globals ... DONE
[17:00:28.673] - globals: [0] <none>
[17:00:28.673] getGlobalsAndPackages() ... DONE
[17:00:28.673]    + additional globals found: [n=0] 
[17:00:28.673]    + additional namespaces needed: [n=0] 
[17:00:28.673]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.673]  - seeds: [2] <seeds>
[17:00:28.673]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.674] getGlobalsAndPackages() ...
[17:00:28.674] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.674] Resolving globals: FALSE
[17:00:28.674] The total size of the 5 globals is 1.98 KiB (2032 bytes)
[17:00:28.675] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (160 bytes of class ‘list’) and ‘...future.elements_ii’ (112 bytes of class ‘list’)
[17:00:28.675] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.675] 
[17:00:28.675] getGlobalsAndPackages() ... DONE
[17:00:28.675] run() for ‘Future’ ...
[17:00:28.675] - state: ‘created’
[17:00:28.676] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.676] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.676]   - Field: ‘label’
[17:00:28.676]   - Field: ‘local’
[17:00:28.676]   - Field: ‘owner’
[17:00:28.676]   - Field: ‘envir’
[17:00:28.676]   - Field: ‘packages’
[17:00:28.677]   - Field: ‘gc’
[17:00:28.677]   - Field: ‘conditions’
[17:00:28.677]   - Field: ‘expr’
[17:00:28.677]   - Field: ‘uuid’
[17:00:28.677]   - Field: ‘seed’
[17:00:28.677]   - Field: ‘version’
[17:00:28.677]   - Field: ‘result’
[17:00:28.677]   - Field: ‘asynchronous’
[17:00:28.677]   - Field: ‘calls’
[17:00:28.677]   - Field: ‘globals’
[17:00:28.677]   - Field: ‘stdout’
[17:00:28.678]   - Field: ‘earlySignal’
[17:00:28.678]   - Field: ‘lazy’
[17:00:28.678]   - Field: ‘state’
[17:00:28.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.678] - Launch lazy future ...
[17:00:28.678] Packages needed by the future expression (n = 0): <none>
[17:00:28.678] Packages needed by future strategies (n = 0): <none>
[17:00:28.679] {
[17:00:28.679]     {
[17:00:28.679]         {
[17:00:28.679]             ...future.startTime <- base::Sys.time()
[17:00:28.679]             {
[17:00:28.679]                 {
[17:00:28.679]                   {
[17:00:28.679]                     base::local({
[17:00:28.679]                       has_future <- base::requireNamespace("future", 
[17:00:28.679]                         quietly = TRUE)
[17:00:28.679]                       if (has_future) {
[17:00:28.679]                         ns <- base::getNamespace("future")
[17:00:28.679]                         version <- ns[[".package"]][["version"]]
[17:00:28.679]                         if (is.null(version)) 
[17:00:28.679]                           version <- utils::packageVersion("future")
[17:00:28.679]                       }
[17:00:28.679]                       else {
[17:00:28.679]                         version <- NULL
[17:00:28.679]                       }
[17:00:28.679]                       if (!has_future || version < "1.8.0") {
[17:00:28.679]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.679]                           "", base::R.version$version.string), 
[17:00:28.679]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.679]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.679]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.679]                             "release", "version")], collapse = " "), 
[17:00:28.679]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.679]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.679]                           info)
[17:00:28.679]                         info <- base::paste(info, collapse = "; ")
[17:00:28.679]                         if (!has_future) {
[17:00:28.679]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.679]                             info)
[17:00:28.679]                         }
[17:00:28.679]                         else {
[17:00:28.679]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.679]                             info, version)
[17:00:28.679]                         }
[17:00:28.679]                         base::stop(msg)
[17:00:28.679]                       }
[17:00:28.679]                     })
[17:00:28.679]                   }
[17:00:28.679]                   ...future.strategy.old <- future::plan("list")
[17:00:28.679]                   options(future.plan = NULL)
[17:00:28.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.679]                 }
[17:00:28.679]                 ...future.workdir <- getwd()
[17:00:28.679]             }
[17:00:28.679]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.679]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.679]         }
[17:00:28.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.679]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.679]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.679]             base::names(...future.oldOptions))
[17:00:28.679]     }
[17:00:28.679]     if (FALSE) {
[17:00:28.679]     }
[17:00:28.679]     else {
[17:00:28.679]         if (TRUE) {
[17:00:28.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.679]                 open = "w")
[17:00:28.679]         }
[17:00:28.679]         else {
[17:00:28.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.679]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.679]         }
[17:00:28.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.679]             base::sink(type = "output", split = FALSE)
[17:00:28.679]             base::close(...future.stdout)
[17:00:28.679]         }, add = TRUE)
[17:00:28.679]     }
[17:00:28.679]     ...future.frame <- base::sys.nframe()
[17:00:28.679]     ...future.conditions <- base::list()
[17:00:28.679]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.679]     if (FALSE) {
[17:00:28.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.679]     }
[17:00:28.679]     ...future.result <- base::tryCatch({
[17:00:28.679]         base::withCallingHandlers({
[17:00:28.679]             ...future.value <- base::withVisible(base::local({
[17:00:28.679]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.679]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.679]                   ...future.globals.maxSize)) {
[17:00:28.679]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.679]                   on.exit(options(oopts), add = TRUE)
[17:00:28.679]                 }
[17:00:28.679]                 {
[17:00:28.679]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:28.679]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:28.679]                       envir = globalenv(), inherits = FALSE)
[17:00:28.679]                     ...future.FUN(...)
[17:00:28.679]                   }
[17:00:28.679]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:28.679]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:28.679]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.679]                     USE.NAMES = FALSE)
[17:00:28.679]                   do.call(mapply, args = args)
[17:00:28.679]                 }
[17:00:28.679]             }))
[17:00:28.679]             future::FutureResult(value = ...future.value$value, 
[17:00:28.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.679]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.679]                     ...future.globalenv.names))
[17:00:28.679]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.679]         }, condition = base::local({
[17:00:28.679]             c <- base::c
[17:00:28.679]             inherits <- base::inherits
[17:00:28.679]             invokeRestart <- base::invokeRestart
[17:00:28.679]             length <- base::length
[17:00:28.679]             list <- base::list
[17:00:28.679]             seq.int <- base::seq.int
[17:00:28.679]             signalCondition <- base::signalCondition
[17:00:28.679]             sys.calls <- base::sys.calls
[17:00:28.679]             `[[` <- base::`[[`
[17:00:28.679]             `+` <- base::`+`
[17:00:28.679]             `<<-` <- base::`<<-`
[17:00:28.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.679]                   3L)]
[17:00:28.679]             }
[17:00:28.679]             function(cond) {
[17:00:28.679]                 is_error <- inherits(cond, "error")
[17:00:28.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.679]                   NULL)
[17:00:28.679]                 if (is_error) {
[17:00:28.679]                   sessionInformation <- function() {
[17:00:28.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.679]                       search = base::search(), system = base::Sys.info())
[17:00:28.679]                   }
[17:00:28.679]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.679]                     cond$call), session = sessionInformation(), 
[17:00:28.679]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.679]                   signalCondition(cond)
[17:00:28.679]                 }
[17:00:28.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.679]                 "immediateCondition"))) {
[17:00:28.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.679]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.679]                   if (TRUE && !signal) {
[17:00:28.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.679]                     {
[17:00:28.679]                       inherits <- base::inherits
[17:00:28.679]                       invokeRestart <- base::invokeRestart
[17:00:28.679]                       is.null <- base::is.null
[17:00:28.679]                       muffled <- FALSE
[17:00:28.679]                       if (inherits(cond, "message")) {
[17:00:28.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.679]                         if (muffled) 
[17:00:28.679]                           invokeRestart("muffleMessage")
[17:00:28.679]                       }
[17:00:28.679]                       else if (inherits(cond, "warning")) {
[17:00:28.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.679]                         if (muffled) 
[17:00:28.679]                           invokeRestart("muffleWarning")
[17:00:28.679]                       }
[17:00:28.679]                       else if (inherits(cond, "condition")) {
[17:00:28.679]                         if (!is.null(pattern)) {
[17:00:28.679]                           computeRestarts <- base::computeRestarts
[17:00:28.679]                           grepl <- base::grepl
[17:00:28.679]                           restarts <- computeRestarts(cond)
[17:00:28.679]                           for (restart in restarts) {
[17:00:28.679]                             name <- restart$name
[17:00:28.679]                             if (is.null(name)) 
[17:00:28.679]                               next
[17:00:28.679]                             if (!grepl(pattern, name)) 
[17:00:28.679]                               next
[17:00:28.679]                             invokeRestart(restart)
[17:00:28.679]                             muffled <- TRUE
[17:00:28.679]                             break
[17:00:28.679]                           }
[17:00:28.679]                         }
[17:00:28.679]                       }
[17:00:28.679]                       invisible(muffled)
[17:00:28.679]                     }
[17:00:28.679]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.679]                   }
[17:00:28.679]                 }
[17:00:28.679]                 else {
[17:00:28.679]                   if (TRUE) {
[17:00:28.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.679]                     {
[17:00:28.679]                       inherits <- base::inherits
[17:00:28.679]                       invokeRestart <- base::invokeRestart
[17:00:28.679]                       is.null <- base::is.null
[17:00:28.679]                       muffled <- FALSE
[17:00:28.679]                       if (inherits(cond, "message")) {
[17:00:28.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.679]                         if (muffled) 
[17:00:28.679]                           invokeRestart("muffleMessage")
[17:00:28.679]                       }
[17:00:28.679]                       else if (inherits(cond, "warning")) {
[17:00:28.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.679]                         if (muffled) 
[17:00:28.679]                           invokeRestart("muffleWarning")
[17:00:28.679]                       }
[17:00:28.679]                       else if (inherits(cond, "condition")) {
[17:00:28.679]                         if (!is.null(pattern)) {
[17:00:28.679]                           computeRestarts <- base::computeRestarts
[17:00:28.679]                           grepl <- base::grepl
[17:00:28.679]                           restarts <- computeRestarts(cond)
[17:00:28.679]                           for (restart in restarts) {
[17:00:28.679]                             name <- restart$name
[17:00:28.679]                             if (is.null(name)) 
[17:00:28.679]                               next
[17:00:28.679]                             if (!grepl(pattern, name)) 
[17:00:28.679]                               next
[17:00:28.679]                             invokeRestart(restart)
[17:00:28.679]                             muffled <- TRUE
[17:00:28.679]                             break
[17:00:28.679]                           }
[17:00:28.679]                         }
[17:00:28.679]                       }
[17:00:28.679]                       invisible(muffled)
[17:00:28.679]                     }
[17:00:28.679]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.679]                   }
[17:00:28.679]                 }
[17:00:28.679]             }
[17:00:28.679]         }))
[17:00:28.679]     }, error = function(ex) {
[17:00:28.679]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.679]                 ...future.rng), started = ...future.startTime, 
[17:00:28.679]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.679]             version = "1.8"), class = "FutureResult")
[17:00:28.679]     }, finally = {
[17:00:28.679]         if (!identical(...future.workdir, getwd())) 
[17:00:28.679]             setwd(...future.workdir)
[17:00:28.679]         {
[17:00:28.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.679]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.679]             }
[17:00:28.679]             base::options(...future.oldOptions)
[17:00:28.679]             if (.Platform$OS.type == "windows") {
[17:00:28.679]                 old_names <- names(...future.oldEnvVars)
[17:00:28.679]                 envs <- base::Sys.getenv()
[17:00:28.679]                 names <- names(envs)
[17:00:28.679]                 common <- intersect(names, old_names)
[17:00:28.679]                 added <- setdiff(names, old_names)
[17:00:28.679]                 removed <- setdiff(old_names, names)
[17:00:28.679]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.679]                   envs[common]]
[17:00:28.679]                 NAMES <- toupper(changed)
[17:00:28.679]                 args <- list()
[17:00:28.679]                 for (kk in seq_along(NAMES)) {
[17:00:28.679]                   name <- changed[[kk]]
[17:00:28.679]                   NAME <- NAMES[[kk]]
[17:00:28.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.679]                     next
[17:00:28.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.679]                 }
[17:00:28.679]                 NAMES <- toupper(added)
[17:00:28.679]                 for (kk in seq_along(NAMES)) {
[17:00:28.679]                   name <- added[[kk]]
[17:00:28.679]                   NAME <- NAMES[[kk]]
[17:00:28.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.679]                     next
[17:00:28.679]                   args[[name]] <- ""
[17:00:28.679]                 }
[17:00:28.679]                 NAMES <- toupper(removed)
[17:00:28.679]                 for (kk in seq_along(NAMES)) {
[17:00:28.679]                   name <- removed[[kk]]
[17:00:28.679]                   NAME <- NAMES[[kk]]
[17:00:28.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.679]                     next
[17:00:28.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.679]                 }
[17:00:28.679]                 if (length(args) > 0) 
[17:00:28.679]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.679]             }
[17:00:28.679]             else {
[17:00:28.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.679]             }
[17:00:28.679]             {
[17:00:28.679]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.679]                   0L) {
[17:00:28.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.679]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.679]                   base::options(opts)
[17:00:28.679]                 }
[17:00:28.679]                 {
[17:00:28.679]                   {
[17:00:28.679]                     base::assign(".Random.seed", c(10407L, 1624550703L, 
[17:00:28.679]                     -922435925L, 962809165L, 2054632538L, 1051373140L, 
[17:00:28.679]                     1348729052L), envir = base::globalenv(), 
[17:00:28.679]                       inherits = FALSE)
[17:00:28.679]                     NULL
[17:00:28.679]                   }
[17:00:28.679]                   options(future.plan = NULL)
[17:00:28.679]                   if (is.na(NA_character_)) 
[17:00:28.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.679]                     .init = FALSE)
[17:00:28.679]                 }
[17:00:28.679]             }
[17:00:28.679]         }
[17:00:28.679]     })
[17:00:28.679]     if (TRUE) {
[17:00:28.679]         base::sink(type = "output", split = FALSE)
[17:00:28.679]         if (TRUE) {
[17:00:28.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.679]         }
[17:00:28.679]         else {
[17:00:28.679]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.679]         }
[17:00:28.679]         base::close(...future.stdout)
[17:00:28.679]         ...future.stdout <- NULL
[17:00:28.679]     }
[17:00:28.679]     ...future.result$conditions <- ...future.conditions
[17:00:28.679]     ...future.result$finished <- base::Sys.time()
[17:00:28.679]     ...future.result
[17:00:28.679] }
[17:00:28.680] assign_globals() ...
[17:00:28.681] List of 5
[17:00:28.681]  $ ...future.FUN            :function (x, y)  
[17:00:28.681]  $ MoreArgs                 :List of 1
[17:00:28.681]   ..$ y: int [1:2] 3 4
[17:00:28.681]  $ ...future.elements_ii    :List of 1
[17:00:28.681]   ..$ x:List of 2
[17:00:28.681]   .. ..$ : int 1
[17:00:28.681]   .. ..$ : int 2
[17:00:28.681]  $ ...future.seeds_ii       :List of 2
[17:00:28.681]   ..$ : int [1:7] 10407 -441019825 1808425666 1737969349 -624091456 -1582509761 599443008
[17:00:28.681]   ..$ : int [1:7] 10407 1767093870 1948523446 1629573483 584281933 -1028438563 126877827
[17:00:28.681]  $ ...future.globals.maxSize: NULL
[17:00:28.681]  - attr(*, "where")=List of 5
[17:00:28.681]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.681]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.681]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.681]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.681]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.681]  - attr(*, "resolved")= logi FALSE
[17:00:28.681]  - attr(*, "total_size")= num 2032
[17:00:28.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.681]  - attr(*, "already-done")= logi TRUE
[17:00:28.689] - reassign environment for ‘...future.FUN’
[17:00:28.689] - copied ‘...future.FUN’ to environment
[17:00:28.689] - copied ‘MoreArgs’ to environment
[17:00:28.689] - copied ‘...future.elements_ii’ to environment
[17:00:28.689] - copied ‘...future.seeds_ii’ to environment
[17:00:28.689] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.689] assign_globals() ... done
[17:00:28.689] plan(): Setting new future strategy stack:
[17:00:28.690] List of future strategies:
[17:00:28.690] 1. sequential:
[17:00:28.690]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.690]    - tweaked: FALSE
[17:00:28.690]    - call: NULL
[17:00:28.690] plan(): nbrOfWorkers() = 1
[17:00:28.691] plan(): Setting new future strategy stack:
[17:00:28.691] List of future strategies:
[17:00:28.691] 1. sequential:
[17:00:28.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.691]    - tweaked: FALSE
[17:00:28.691]    - call: plan(strategy)
[17:00:28.691] plan(): nbrOfWorkers() = 1
[17:00:28.692] SequentialFuture started (and completed)
[17:00:28.692] - Launch lazy future ... done
[17:00:28.692] run() for ‘SequentialFuture’ ... done
[17:00:28.692] Created future:
[17:00:28.692] SequentialFuture:
[17:00:28.692] Label: ‘future_mapply-1’
[17:00:28.692] Expression:
[17:00:28.692] {
[17:00:28.692]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.692]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.692]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.692]         on.exit(options(oopts), add = TRUE)
[17:00:28.692]     }
[17:00:28.692]     {
[17:00:28.692]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:28.692]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:28.692]                 inherits = FALSE)
[17:00:28.692]             ...future.FUN(...)
[17:00:28.692]         }
[17:00:28.692]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:28.692]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:28.692]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.692]         do.call(mapply, args = args)
[17:00:28.692]     }
[17:00:28.692] }
[17:00:28.692] Lazy evaluation: FALSE
[17:00:28.692] Asynchronous evaluation: FALSE
[17:00:28.692] Local evaluation: TRUE
[17:00:28.692] Environment: R_GlobalEnv
[17:00:28.692] Capture standard output: TRUE
[17:00:28.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.692] Globals: 5 objects totaling 1.98 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.692] Packages: <none>
[17:00:28.692] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:28.692] Resolved: TRUE
[17:00:28.692] Value: 112 bytes of class ‘list’
[17:00:28.692] Early signaling: FALSE
[17:00:28.692] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.692] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.693] Chunk #1 of 1 ... DONE
[17:00:28.693] Launching 1 futures (chunks) ... DONE
[17:00:28.693] Resolving 1 futures (chunks) ...
[17:00:28.693] resolve() on list ...
[17:00:28.693]  recursive: 0
[17:00:28.693]  length: 1
[17:00:28.693] 
[17:00:28.693] resolved() for ‘SequentialFuture’ ...
[17:00:28.694] - state: ‘finished’
[17:00:28.694] - run: TRUE
[17:00:28.694] - result: ‘FutureResult’
[17:00:28.694] resolved() for ‘SequentialFuture’ ... done
[17:00:28.694] Future #1
[17:00:28.694] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.694] - nx: 1
[17:00:28.694] - relay: TRUE
[17:00:28.694] - stdout: TRUE
[17:00:28.694] - signal: TRUE
[17:00:28.695] - resignal: FALSE
[17:00:28.695] - force: TRUE
[17:00:28.695] - relayed: [n=1] FALSE
[17:00:28.695] - queued futures: [n=1] FALSE
[17:00:28.695]  - until=1
[17:00:28.695]  - relaying element #1
[17:00:28.695] - relayed: [n=1] TRUE
[17:00:28.695] - queued futures: [n=1] TRUE
[17:00:28.695] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.695]  length: 0 (resolved future 1)
[17:00:28.696] Relaying remaining futures
[17:00:28.696] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.696] - nx: 1
[17:00:28.696] - relay: TRUE
[17:00:28.696] - stdout: TRUE
[17:00:28.696] - signal: TRUE
[17:00:28.696] - resignal: FALSE
[17:00:28.696] - force: TRUE
[17:00:28.696] - relayed: [n=1] TRUE
[17:00:28.696] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.696] - relayed: [n=1] TRUE
[17:00:28.697] - queued futures: [n=1] TRUE
[17:00:28.697] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.697] resolve() on list ... DONE
[17:00:28.697]  - Number of value chunks collected: 1
[17:00:28.697] Resolving 1 futures (chunks) ... DONE
[17:00:28.697] Reducing values from 1 chunks ...
[17:00:28.697]  - Number of values collected after concatenation: 2
[17:00:28.697]  - Number of values expected: 2
[17:00:28.697] Reducing values from 1 chunks ... DONE
[17:00:28.697] future_mapply() ... DONE
[17:00:28.698] future_mapply() ...
[17:00:28.698] Number of chunks: 1
[17:00:28.698] getGlobalsAndPackagesXApply() ...
[17:00:28.698]  - future.globals: TRUE
[17:00:28.698] getGlobalsAndPackages() ...
[17:00:28.698] Searching for globals...
[17:00:28.699] - globals found: [1] ‘FUN’
[17:00:28.699] Searching for globals ... DONE
[17:00:28.699] Resolving globals: FALSE
[17:00:28.700] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:00:28.700] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:00:28.700] - globals: [1] ‘FUN’
[17:00:28.700] 
[17:00:28.700] getGlobalsAndPackages() ... DONE
[17:00:28.700]  - globals found/used: [n=1] ‘FUN’
[17:00:28.700]  - needed namespaces: [n=0] 
[17:00:28.701] Finding globals ... DONE
[17:00:28.701] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.701] List of 2
[17:00:28.701]  $ ...future.FUN:function (x, y)  
[17:00:28.701]  $ MoreArgs     :List of 1
[17:00:28.701]   ..$ y: int [1:2] 3 4
[17:00:28.701]  - attr(*, "where")=List of 2
[17:00:28.701]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.701]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.701]  - attr(*, "resolved")= logi FALSE
[17:00:28.701]  - attr(*, "total_size")= num NA
[17:00:28.704] Packages to be attached in all futures: [n=0] 
[17:00:28.704] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.704] Number of futures (= number of chunks): 1
[17:00:28.704] Launching 1 futures (chunks) ...
[17:00:28.704] Chunk #1 of 1 ...
[17:00:28.704]  - Finding globals in '...' for chunk #1 ...
[17:00:28.704] getGlobalsAndPackages() ...
[17:00:28.704] Searching for globals...
[17:00:28.705] 
[17:00:28.705] Searching for globals ... DONE
[17:00:28.705] - globals: [0] <none>
[17:00:28.705] getGlobalsAndPackages() ... DONE
[17:00:28.705]    + additional globals found: [n=0] 
[17:00:28.705]    + additional namespaces needed: [n=0] 
[17:00:28.705]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.705]  - seeds: <none>
[17:00:28.705]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.705] getGlobalsAndPackages() ...
[17:00:28.706] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.706] Resolving globals: FALSE
[17:00:28.708] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[17:00:28.709] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:28.709] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.709] 
[17:00:28.709] getGlobalsAndPackages() ... DONE
[17:00:28.709] run() for ‘Future’ ...
[17:00:28.710] - state: ‘created’
[17:00:28.710] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.710] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.710]   - Field: ‘label’
[17:00:28.710]   - Field: ‘local’
[17:00:28.711]   - Field: ‘owner’
[17:00:28.711]   - Field: ‘envir’
[17:00:28.711]   - Field: ‘packages’
[17:00:28.711]   - Field: ‘gc’
[17:00:28.711]   - Field: ‘conditions’
[17:00:28.711]   - Field: ‘expr’
[17:00:28.711]   - Field: ‘uuid’
[17:00:28.711]   - Field: ‘seed’
[17:00:28.711]   - Field: ‘version’
[17:00:28.711]   - Field: ‘result’
[17:00:28.712]   - Field: ‘asynchronous’
[17:00:28.712]   - Field: ‘calls’
[17:00:28.712]   - Field: ‘globals’
[17:00:28.712]   - Field: ‘stdout’
[17:00:28.712]   - Field: ‘earlySignal’
[17:00:28.712]   - Field: ‘lazy’
[17:00:28.712]   - Field: ‘state’
[17:00:28.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.712] - Launch lazy future ...
[17:00:28.712] Packages needed by the future expression (n = 0): <none>
[17:00:28.713] Packages needed by future strategies (n = 0): <none>
[17:00:28.713] {
[17:00:28.713]     {
[17:00:28.713]         {
[17:00:28.713]             ...future.startTime <- base::Sys.time()
[17:00:28.713]             {
[17:00:28.713]                 {
[17:00:28.713]                   {
[17:00:28.713]                     base::local({
[17:00:28.713]                       has_future <- base::requireNamespace("future", 
[17:00:28.713]                         quietly = TRUE)
[17:00:28.713]                       if (has_future) {
[17:00:28.713]                         ns <- base::getNamespace("future")
[17:00:28.713]                         version <- ns[[".package"]][["version"]]
[17:00:28.713]                         if (is.null(version)) 
[17:00:28.713]                           version <- utils::packageVersion("future")
[17:00:28.713]                       }
[17:00:28.713]                       else {
[17:00:28.713]                         version <- NULL
[17:00:28.713]                       }
[17:00:28.713]                       if (!has_future || version < "1.8.0") {
[17:00:28.713]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.713]                           "", base::R.version$version.string), 
[17:00:28.713]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.713]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.713]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.713]                             "release", "version")], collapse = " "), 
[17:00:28.713]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.713]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.713]                           info)
[17:00:28.713]                         info <- base::paste(info, collapse = "; ")
[17:00:28.713]                         if (!has_future) {
[17:00:28.713]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.713]                             info)
[17:00:28.713]                         }
[17:00:28.713]                         else {
[17:00:28.713]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.713]                             info, version)
[17:00:28.713]                         }
[17:00:28.713]                         base::stop(msg)
[17:00:28.713]                       }
[17:00:28.713]                     })
[17:00:28.713]                   }
[17:00:28.713]                   ...future.strategy.old <- future::plan("list")
[17:00:28.713]                   options(future.plan = NULL)
[17:00:28.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.713]                 }
[17:00:28.713]                 ...future.workdir <- getwd()
[17:00:28.713]             }
[17:00:28.713]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.713]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.713]         }
[17:00:28.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.713]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.713]             base::names(...future.oldOptions))
[17:00:28.713]     }
[17:00:28.713]     if (FALSE) {
[17:00:28.713]     }
[17:00:28.713]     else {
[17:00:28.713]         if (TRUE) {
[17:00:28.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.713]                 open = "w")
[17:00:28.713]         }
[17:00:28.713]         else {
[17:00:28.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.713]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.713]         }
[17:00:28.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.713]             base::sink(type = "output", split = FALSE)
[17:00:28.713]             base::close(...future.stdout)
[17:00:28.713]         }, add = TRUE)
[17:00:28.713]     }
[17:00:28.713]     ...future.frame <- base::sys.nframe()
[17:00:28.713]     ...future.conditions <- base::list()
[17:00:28.713]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.713]     if (FALSE) {
[17:00:28.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.713]     }
[17:00:28.713]     ...future.result <- base::tryCatch({
[17:00:28.713]         base::withCallingHandlers({
[17:00:28.713]             ...future.value <- base::withVisible(base::local({
[17:00:28.713]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.713]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.713]                   ...future.globals.maxSize)) {
[17:00:28.713]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.713]                   on.exit(options(oopts), add = TRUE)
[17:00:28.713]                 }
[17:00:28.713]                 {
[17:00:28.713]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.713]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.713]                     USE.NAMES = FALSE)
[17:00:28.713]                   do.call(mapply, args = args)
[17:00:28.713]                 }
[17:00:28.713]             }))
[17:00:28.713]             future::FutureResult(value = ...future.value$value, 
[17:00:28.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.713]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.713]                     ...future.globalenv.names))
[17:00:28.713]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.713]         }, condition = base::local({
[17:00:28.713]             c <- base::c
[17:00:28.713]             inherits <- base::inherits
[17:00:28.713]             invokeRestart <- base::invokeRestart
[17:00:28.713]             length <- base::length
[17:00:28.713]             list <- base::list
[17:00:28.713]             seq.int <- base::seq.int
[17:00:28.713]             signalCondition <- base::signalCondition
[17:00:28.713]             sys.calls <- base::sys.calls
[17:00:28.713]             `[[` <- base::`[[`
[17:00:28.713]             `+` <- base::`+`
[17:00:28.713]             `<<-` <- base::`<<-`
[17:00:28.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.713]                   3L)]
[17:00:28.713]             }
[17:00:28.713]             function(cond) {
[17:00:28.713]                 is_error <- inherits(cond, "error")
[17:00:28.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.713]                   NULL)
[17:00:28.713]                 if (is_error) {
[17:00:28.713]                   sessionInformation <- function() {
[17:00:28.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.713]                       search = base::search(), system = base::Sys.info())
[17:00:28.713]                   }
[17:00:28.713]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.713]                     cond$call), session = sessionInformation(), 
[17:00:28.713]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.713]                   signalCondition(cond)
[17:00:28.713]                 }
[17:00:28.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.713]                 "immediateCondition"))) {
[17:00:28.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.713]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.713]                   if (TRUE && !signal) {
[17:00:28.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.713]                     {
[17:00:28.713]                       inherits <- base::inherits
[17:00:28.713]                       invokeRestart <- base::invokeRestart
[17:00:28.713]                       is.null <- base::is.null
[17:00:28.713]                       muffled <- FALSE
[17:00:28.713]                       if (inherits(cond, "message")) {
[17:00:28.713]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.713]                         if (muffled) 
[17:00:28.713]                           invokeRestart("muffleMessage")
[17:00:28.713]                       }
[17:00:28.713]                       else if (inherits(cond, "warning")) {
[17:00:28.713]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.713]                         if (muffled) 
[17:00:28.713]                           invokeRestart("muffleWarning")
[17:00:28.713]                       }
[17:00:28.713]                       else if (inherits(cond, "condition")) {
[17:00:28.713]                         if (!is.null(pattern)) {
[17:00:28.713]                           computeRestarts <- base::computeRestarts
[17:00:28.713]                           grepl <- base::grepl
[17:00:28.713]                           restarts <- computeRestarts(cond)
[17:00:28.713]                           for (restart in restarts) {
[17:00:28.713]                             name <- restart$name
[17:00:28.713]                             if (is.null(name)) 
[17:00:28.713]                               next
[17:00:28.713]                             if (!grepl(pattern, name)) 
[17:00:28.713]                               next
[17:00:28.713]                             invokeRestart(restart)
[17:00:28.713]                             muffled <- TRUE
[17:00:28.713]                             break
[17:00:28.713]                           }
[17:00:28.713]                         }
[17:00:28.713]                       }
[17:00:28.713]                       invisible(muffled)
[17:00:28.713]                     }
[17:00:28.713]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.713]                   }
[17:00:28.713]                 }
[17:00:28.713]                 else {
[17:00:28.713]                   if (TRUE) {
[17:00:28.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.713]                     {
[17:00:28.713]                       inherits <- base::inherits
[17:00:28.713]                       invokeRestart <- base::invokeRestart
[17:00:28.713]                       is.null <- base::is.null
[17:00:28.713]                       muffled <- FALSE
[17:00:28.713]                       if (inherits(cond, "message")) {
[17:00:28.713]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.713]                         if (muffled) 
[17:00:28.713]                           invokeRestart("muffleMessage")
[17:00:28.713]                       }
[17:00:28.713]                       else if (inherits(cond, "warning")) {
[17:00:28.713]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.713]                         if (muffled) 
[17:00:28.713]                           invokeRestart("muffleWarning")
[17:00:28.713]                       }
[17:00:28.713]                       else if (inherits(cond, "condition")) {
[17:00:28.713]                         if (!is.null(pattern)) {
[17:00:28.713]                           computeRestarts <- base::computeRestarts
[17:00:28.713]                           grepl <- base::grepl
[17:00:28.713]                           restarts <- computeRestarts(cond)
[17:00:28.713]                           for (restart in restarts) {
[17:00:28.713]                             name <- restart$name
[17:00:28.713]                             if (is.null(name)) 
[17:00:28.713]                               next
[17:00:28.713]                             if (!grepl(pattern, name)) 
[17:00:28.713]                               next
[17:00:28.713]                             invokeRestart(restart)
[17:00:28.713]                             muffled <- TRUE
[17:00:28.713]                             break
[17:00:28.713]                           }
[17:00:28.713]                         }
[17:00:28.713]                       }
[17:00:28.713]                       invisible(muffled)
[17:00:28.713]                     }
[17:00:28.713]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.713]                   }
[17:00:28.713]                 }
[17:00:28.713]             }
[17:00:28.713]         }))
[17:00:28.713]     }, error = function(ex) {
[17:00:28.713]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.713]                 ...future.rng), started = ...future.startTime, 
[17:00:28.713]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.713]             version = "1.8"), class = "FutureResult")
[17:00:28.713]     }, finally = {
[17:00:28.713]         if (!identical(...future.workdir, getwd())) 
[17:00:28.713]             setwd(...future.workdir)
[17:00:28.713]         {
[17:00:28.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.713]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.713]             }
[17:00:28.713]             base::options(...future.oldOptions)
[17:00:28.713]             if (.Platform$OS.type == "windows") {
[17:00:28.713]                 old_names <- names(...future.oldEnvVars)
[17:00:28.713]                 envs <- base::Sys.getenv()
[17:00:28.713]                 names <- names(envs)
[17:00:28.713]                 common <- intersect(names, old_names)
[17:00:28.713]                 added <- setdiff(names, old_names)
[17:00:28.713]                 removed <- setdiff(old_names, names)
[17:00:28.713]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.713]                   envs[common]]
[17:00:28.713]                 NAMES <- toupper(changed)
[17:00:28.713]                 args <- list()
[17:00:28.713]                 for (kk in seq_along(NAMES)) {
[17:00:28.713]                   name <- changed[[kk]]
[17:00:28.713]                   NAME <- NAMES[[kk]]
[17:00:28.713]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.713]                     next
[17:00:28.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.713]                 }
[17:00:28.713]                 NAMES <- toupper(added)
[17:00:28.713]                 for (kk in seq_along(NAMES)) {
[17:00:28.713]                   name <- added[[kk]]
[17:00:28.713]                   NAME <- NAMES[[kk]]
[17:00:28.713]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.713]                     next
[17:00:28.713]                   args[[name]] <- ""
[17:00:28.713]                 }
[17:00:28.713]                 NAMES <- toupper(removed)
[17:00:28.713]                 for (kk in seq_along(NAMES)) {
[17:00:28.713]                   name <- removed[[kk]]
[17:00:28.713]                   NAME <- NAMES[[kk]]
[17:00:28.713]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.713]                     next
[17:00:28.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.713]                 }
[17:00:28.713]                 if (length(args) > 0) 
[17:00:28.713]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.713]             }
[17:00:28.713]             else {
[17:00:28.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.713]             }
[17:00:28.713]             {
[17:00:28.713]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.713]                   0L) {
[17:00:28.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.713]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.713]                   base::options(opts)
[17:00:28.713]                 }
[17:00:28.713]                 {
[17:00:28.713]                   {
[17:00:28.713]                     base::assign(".Random.seed", c(10407L, 1624550703L, 
[17:00:28.713]                     -922435925L, 962809165L, 2054632538L, 1051373140L, 
[17:00:28.713]                     1348729052L), envir = base::globalenv(), 
[17:00:28.713]                       inherits = FALSE)
[17:00:28.713]                     NULL
[17:00:28.713]                   }
[17:00:28.713]                   options(future.plan = NULL)
[17:00:28.713]                   if (is.na(NA_character_)) 
[17:00:28.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.713]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.713]                     .init = FALSE)
[17:00:28.713]                 }
[17:00:28.713]             }
[17:00:28.713]         }
[17:00:28.713]     })
[17:00:28.713]     if (TRUE) {
[17:00:28.713]         base::sink(type = "output", split = FALSE)
[17:00:28.713]         if (TRUE) {
[17:00:28.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.713]         }
[17:00:28.713]         else {
[17:00:28.713]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.713]         }
[17:00:28.713]         base::close(...future.stdout)
[17:00:28.713]         ...future.stdout <- NULL
[17:00:28.713]     }
[17:00:28.713]     ...future.result$conditions <- ...future.conditions
[17:00:28.713]     ...future.result$finished <- base::Sys.time()
[17:00:28.713]     ...future.result
[17:00:28.713] }
[17:00:28.715] assign_globals() ...
[17:00:28.715] List of 5
[17:00:28.715]  $ ...future.FUN            :function (x, y)  
[17:00:28.715]  $ MoreArgs                 :List of 1
[17:00:28.715]   ..$ y: int [1:2] 3 4
[17:00:28.715]  $ ...future.elements_ii    :List of 1
[17:00:28.715]   ..$ x:List of 2
[17:00:28.715]   .. ..$ : int 1
[17:00:28.715]   .. ..$ : int 2
[17:00:28.715]  $ ...future.seeds_ii       : NULL
[17:00:28.715]  $ ...future.globals.maxSize: NULL
[17:00:28.715]  - attr(*, "where")=List of 5
[17:00:28.715]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.715]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.715]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.715]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.715]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.715]  - attr(*, "resolved")= logi FALSE
[17:00:28.715]  - attr(*, "total_size")= num 1872
[17:00:28.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.715]  - attr(*, "already-done")= logi TRUE
[17:00:28.720] - reassign environment for ‘...future.FUN’
[17:00:28.720] - copied ‘...future.FUN’ to environment
[17:00:28.720] - copied ‘MoreArgs’ to environment
[17:00:28.720] - copied ‘...future.elements_ii’ to environment
[17:00:28.720] - copied ‘...future.seeds_ii’ to environment
[17:00:28.721] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.721] assign_globals() ... done
[17:00:28.721] plan(): Setting new future strategy stack:
[17:00:28.721] List of future strategies:
[17:00:28.721] 1. sequential:
[17:00:28.721]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.721]    - tweaked: FALSE
[17:00:28.721]    - call: NULL
[17:00:28.721] plan(): nbrOfWorkers() = 1
[17:00:28.722] plan(): Setting new future strategy stack:
[17:00:28.722] List of future strategies:
[17:00:28.722] 1. sequential:
[17:00:28.722]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.722]    - tweaked: FALSE
[17:00:28.722]    - call: plan(strategy)
[17:00:28.723] plan(): nbrOfWorkers() = 1
[17:00:28.723] SequentialFuture started (and completed)
[17:00:28.723] - Launch lazy future ... done
[17:00:28.723] run() for ‘SequentialFuture’ ... done
[17:00:28.723] Created future:
[17:00:28.723] SequentialFuture:
[17:00:28.723] Label: ‘future_.mapply-1’
[17:00:28.723] Expression:
[17:00:28.723] {
[17:00:28.723]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.723]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.723]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.723]         on.exit(options(oopts), add = TRUE)
[17:00:28.723]     }
[17:00:28.723]     {
[17:00:28.723]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.723]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.723]         do.call(mapply, args = args)
[17:00:28.723]     }
[17:00:28.723] }
[17:00:28.723] Lazy evaluation: FALSE
[17:00:28.723] Asynchronous evaluation: FALSE
[17:00:28.723] Local evaluation: TRUE
[17:00:28.723] Environment: R_GlobalEnv
[17:00:28.723] Capture standard output: TRUE
[17:00:28.723] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.723] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.723] Packages: <none>
[17:00:28.723] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.723] Resolved: TRUE
[17:00:28.723] Value: 112 bytes of class ‘list’
[17:00:28.723] Early signaling: FALSE
[17:00:28.723] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.723] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.724] Chunk #1 of 1 ... DONE
[17:00:28.724] Launching 1 futures (chunks) ... DONE
[17:00:28.725] Resolving 1 futures (chunks) ...
[17:00:28.725] resolve() on list ...
[17:00:28.725]  recursive: 0
[17:00:28.725]  length: 1
[17:00:28.725] 
[17:00:28.725] resolved() for ‘SequentialFuture’ ...
[17:00:28.725] - state: ‘finished’
[17:00:28.725] - run: TRUE
[17:00:28.725] - result: ‘FutureResult’
[17:00:28.725] resolved() for ‘SequentialFuture’ ... done
[17:00:28.725] Future #1
[17:00:28.726] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.726] - nx: 1
[17:00:28.726] - relay: TRUE
[17:00:28.726] - stdout: TRUE
[17:00:28.726] - signal: TRUE
[17:00:28.726] - resignal: FALSE
[17:00:28.726] - force: TRUE
[17:00:28.726] - relayed: [n=1] FALSE
[17:00:28.726] - queued futures: [n=1] FALSE
[17:00:28.726]  - until=1
[17:00:28.726]  - relaying element #1
[17:00:28.727] - relayed: [n=1] TRUE
[17:00:28.727] - queued futures: [n=1] TRUE
[17:00:28.727] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.727]  length: 0 (resolved future 1)
[17:00:28.727] Relaying remaining futures
[17:00:28.727] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.727] - nx: 1
[17:00:28.727] - relay: TRUE
[17:00:28.727] - stdout: TRUE
[17:00:28.728] - signal: TRUE
[17:00:28.728] - resignal: FALSE
[17:00:28.728] - force: TRUE
[17:00:28.728] - relayed: [n=1] TRUE
[17:00:28.728] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.728] - relayed: [n=1] TRUE
[17:00:28.728] - queued futures: [n=1] TRUE
[17:00:28.728] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.728] resolve() on list ... DONE
[17:00:28.728]  - Number of value chunks collected: 1
[17:00:28.729] Resolving 1 futures (chunks) ... DONE
[17:00:28.729] Reducing values from 1 chunks ...
[17:00:28.729]  - Number of values collected after concatenation: 2
[17:00:28.729]  - Number of values expected: 2
[17:00:28.729] Reducing values from 1 chunks ... DONE
[17:00:28.729] future_mapply() ... DONE
- Recycle arguments to same length ...
[17:00:28.729] future_mapply() ...
[17:00:28.729] Number of chunks: 1
[17:00:28.729] getGlobalsAndPackagesXApply() ...
[17:00:28.730]  - future.globals: TRUE
[17:00:28.730] getGlobalsAndPackages() ...
[17:00:28.730] Searching for globals...
[17:00:28.730] - globals found: [1] ‘FUN’
[17:00:28.730] Searching for globals ... DONE
[17:00:28.731] Resolving globals: FALSE
[17:00:28.731] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:28.731] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:28.731] - globals: [1] ‘FUN’
[17:00:28.731] 
[17:00:28.732] getGlobalsAndPackages() ... DONE
[17:00:28.732]  - globals found/used: [n=1] ‘FUN’
[17:00:28.732]  - needed namespaces: [n=0] 
[17:00:28.732] Finding globals ... DONE
[17:00:28.732] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.734] List of 2
[17:00:28.734]  $ ...future.FUN:function (x, ...)  
[17:00:28.734]  $ MoreArgs     : NULL
[17:00:28.734]  - attr(*, "where")=List of 2
[17:00:28.734]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.734]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.734]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.734]  - attr(*, "resolved")= logi FALSE
[17:00:28.734]  - attr(*, "total_size")= num NA
[17:00:28.737] Packages to be attached in all futures: [n=0] 
[17:00:28.737] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.737] Number of futures (= number of chunks): 1
[17:00:28.737] Launching 1 futures (chunks) ...
[17:00:28.737] Chunk #1 of 1 ...
[17:00:28.738]  - Finding globals in '...' for chunk #1 ...
[17:00:28.738] getGlobalsAndPackages() ...
[17:00:28.738] Searching for globals...
[17:00:28.738] 
[17:00:28.738] Searching for globals ... DONE
[17:00:28.738] - globals: [0] <none>
[17:00:28.738] getGlobalsAndPackages() ... DONE
[17:00:28.738]    + additional globals found: [n=0] 
[17:00:28.739]    + additional namespaces needed: [n=0] 
[17:00:28.739]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.739]  - seeds: <none>
[17:00:28.739]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.739] getGlobalsAndPackages() ...
[17:00:28.739] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.739] Resolving globals: FALSE
[17:00:28.740] The total size of the 5 globals is 504 bytes (504 bytes)
[17:00:28.740] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.740] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.740] 
[17:00:28.740] getGlobalsAndPackages() ... DONE
[17:00:28.741] run() for ‘Future’ ...
[17:00:28.741] - state: ‘created’
[17:00:28.741] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.741] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.741] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.741]   - Field: ‘label’
[17:00:28.742]   - Field: ‘local’
[17:00:28.742]   - Field: ‘owner’
[17:00:28.742]   - Field: ‘envir’
[17:00:28.742]   - Field: ‘packages’
[17:00:28.742]   - Field: ‘gc’
[17:00:28.742]   - Field: ‘conditions’
[17:00:28.742]   - Field: ‘expr’
[17:00:28.742]   - Field: ‘uuid’
[17:00:28.742]   - Field: ‘seed’
[17:00:28.742]   - Field: ‘version’
[17:00:28.742]   - Field: ‘result’
[17:00:28.743]   - Field: ‘asynchronous’
[17:00:28.743]   - Field: ‘calls’
[17:00:28.743]   - Field: ‘globals’
[17:00:28.743]   - Field: ‘stdout’
[17:00:28.743]   - Field: ‘earlySignal’
[17:00:28.743]   - Field: ‘lazy’
[17:00:28.743]   - Field: ‘state’
[17:00:28.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.743] - Launch lazy future ...
[17:00:28.743] Packages needed by the future expression (n = 0): <none>
[17:00:28.744] Packages needed by future strategies (n = 0): <none>
[17:00:28.744] {
[17:00:28.744]     {
[17:00:28.744]         {
[17:00:28.744]             ...future.startTime <- base::Sys.time()
[17:00:28.744]             {
[17:00:28.744]                 {
[17:00:28.744]                   {
[17:00:28.744]                     base::local({
[17:00:28.744]                       has_future <- base::requireNamespace("future", 
[17:00:28.744]                         quietly = TRUE)
[17:00:28.744]                       if (has_future) {
[17:00:28.744]                         ns <- base::getNamespace("future")
[17:00:28.744]                         version <- ns[[".package"]][["version"]]
[17:00:28.744]                         if (is.null(version)) 
[17:00:28.744]                           version <- utils::packageVersion("future")
[17:00:28.744]                       }
[17:00:28.744]                       else {
[17:00:28.744]                         version <- NULL
[17:00:28.744]                       }
[17:00:28.744]                       if (!has_future || version < "1.8.0") {
[17:00:28.744]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.744]                           "", base::R.version$version.string), 
[17:00:28.744]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.744]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.744]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.744]                             "release", "version")], collapse = " "), 
[17:00:28.744]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.744]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.744]                           info)
[17:00:28.744]                         info <- base::paste(info, collapse = "; ")
[17:00:28.744]                         if (!has_future) {
[17:00:28.744]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.744]                             info)
[17:00:28.744]                         }
[17:00:28.744]                         else {
[17:00:28.744]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.744]                             info, version)
[17:00:28.744]                         }
[17:00:28.744]                         base::stop(msg)
[17:00:28.744]                       }
[17:00:28.744]                     })
[17:00:28.744]                   }
[17:00:28.744]                   ...future.strategy.old <- future::plan("list")
[17:00:28.744]                   options(future.plan = NULL)
[17:00:28.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.744]                 }
[17:00:28.744]                 ...future.workdir <- getwd()
[17:00:28.744]             }
[17:00:28.744]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.744]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.744]         }
[17:00:28.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.744]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.744]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.744]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.744]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.744]             base::names(...future.oldOptions))
[17:00:28.744]     }
[17:00:28.744]     if (FALSE) {
[17:00:28.744]     }
[17:00:28.744]     else {
[17:00:28.744]         if (TRUE) {
[17:00:28.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.744]                 open = "w")
[17:00:28.744]         }
[17:00:28.744]         else {
[17:00:28.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.744]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.744]         }
[17:00:28.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.744]             base::sink(type = "output", split = FALSE)
[17:00:28.744]             base::close(...future.stdout)
[17:00:28.744]         }, add = TRUE)
[17:00:28.744]     }
[17:00:28.744]     ...future.frame <- base::sys.nframe()
[17:00:28.744]     ...future.conditions <- base::list()
[17:00:28.744]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.744]     if (FALSE) {
[17:00:28.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.744]     }
[17:00:28.744]     ...future.result <- base::tryCatch({
[17:00:28.744]         base::withCallingHandlers({
[17:00:28.744]             ...future.value <- base::withVisible(base::local({
[17:00:28.744]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.744]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.744]                   ...future.globals.maxSize)) {
[17:00:28.744]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.744]                   on.exit(options(oopts), add = TRUE)
[17:00:28.744]                 }
[17:00:28.744]                 {
[17:00:28.744]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.744]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.744]                     USE.NAMES = FALSE)
[17:00:28.744]                   do.call(mapply, args = args)
[17:00:28.744]                 }
[17:00:28.744]             }))
[17:00:28.744]             future::FutureResult(value = ...future.value$value, 
[17:00:28.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.744]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.744]                     ...future.globalenv.names))
[17:00:28.744]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.744]         }, condition = base::local({
[17:00:28.744]             c <- base::c
[17:00:28.744]             inherits <- base::inherits
[17:00:28.744]             invokeRestart <- base::invokeRestart
[17:00:28.744]             length <- base::length
[17:00:28.744]             list <- base::list
[17:00:28.744]             seq.int <- base::seq.int
[17:00:28.744]             signalCondition <- base::signalCondition
[17:00:28.744]             sys.calls <- base::sys.calls
[17:00:28.744]             `[[` <- base::`[[`
[17:00:28.744]             `+` <- base::`+`
[17:00:28.744]             `<<-` <- base::`<<-`
[17:00:28.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.744]                   3L)]
[17:00:28.744]             }
[17:00:28.744]             function(cond) {
[17:00:28.744]                 is_error <- inherits(cond, "error")
[17:00:28.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.744]                   NULL)
[17:00:28.744]                 if (is_error) {
[17:00:28.744]                   sessionInformation <- function() {
[17:00:28.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.744]                       search = base::search(), system = base::Sys.info())
[17:00:28.744]                   }
[17:00:28.744]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.744]                     cond$call), session = sessionInformation(), 
[17:00:28.744]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.744]                   signalCondition(cond)
[17:00:28.744]                 }
[17:00:28.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.744]                 "immediateCondition"))) {
[17:00:28.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.744]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.744]                   if (TRUE && !signal) {
[17:00:28.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.744]                     {
[17:00:28.744]                       inherits <- base::inherits
[17:00:28.744]                       invokeRestart <- base::invokeRestart
[17:00:28.744]                       is.null <- base::is.null
[17:00:28.744]                       muffled <- FALSE
[17:00:28.744]                       if (inherits(cond, "message")) {
[17:00:28.744]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.744]                         if (muffled) 
[17:00:28.744]                           invokeRestart("muffleMessage")
[17:00:28.744]                       }
[17:00:28.744]                       else if (inherits(cond, "warning")) {
[17:00:28.744]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.744]                         if (muffled) 
[17:00:28.744]                           invokeRestart("muffleWarning")
[17:00:28.744]                       }
[17:00:28.744]                       else if (inherits(cond, "condition")) {
[17:00:28.744]                         if (!is.null(pattern)) {
[17:00:28.744]                           computeRestarts <- base::computeRestarts
[17:00:28.744]                           grepl <- base::grepl
[17:00:28.744]                           restarts <- computeRestarts(cond)
[17:00:28.744]                           for (restart in restarts) {
[17:00:28.744]                             name <- restart$name
[17:00:28.744]                             if (is.null(name)) 
[17:00:28.744]                               next
[17:00:28.744]                             if (!grepl(pattern, name)) 
[17:00:28.744]                               next
[17:00:28.744]                             invokeRestart(restart)
[17:00:28.744]                             muffled <- TRUE
[17:00:28.744]                             break
[17:00:28.744]                           }
[17:00:28.744]                         }
[17:00:28.744]                       }
[17:00:28.744]                       invisible(muffled)
[17:00:28.744]                     }
[17:00:28.744]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.744]                   }
[17:00:28.744]                 }
[17:00:28.744]                 else {
[17:00:28.744]                   if (TRUE) {
[17:00:28.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.744]                     {
[17:00:28.744]                       inherits <- base::inherits
[17:00:28.744]                       invokeRestart <- base::invokeRestart
[17:00:28.744]                       is.null <- base::is.null
[17:00:28.744]                       muffled <- FALSE
[17:00:28.744]                       if (inherits(cond, "message")) {
[17:00:28.744]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.744]                         if (muffled) 
[17:00:28.744]                           invokeRestart("muffleMessage")
[17:00:28.744]                       }
[17:00:28.744]                       else if (inherits(cond, "warning")) {
[17:00:28.744]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.744]                         if (muffled) 
[17:00:28.744]                           invokeRestart("muffleWarning")
[17:00:28.744]                       }
[17:00:28.744]                       else if (inherits(cond, "condition")) {
[17:00:28.744]                         if (!is.null(pattern)) {
[17:00:28.744]                           computeRestarts <- base::computeRestarts
[17:00:28.744]                           grepl <- base::grepl
[17:00:28.744]                           restarts <- computeRestarts(cond)
[17:00:28.744]                           for (restart in restarts) {
[17:00:28.744]                             name <- restart$name
[17:00:28.744]                             if (is.null(name)) 
[17:00:28.744]                               next
[17:00:28.744]                             if (!grepl(pattern, name)) 
[17:00:28.744]                               next
[17:00:28.744]                             invokeRestart(restart)
[17:00:28.744]                             muffled <- TRUE
[17:00:28.744]                             break
[17:00:28.744]                           }
[17:00:28.744]                         }
[17:00:28.744]                       }
[17:00:28.744]                       invisible(muffled)
[17:00:28.744]                     }
[17:00:28.744]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.744]                   }
[17:00:28.744]                 }
[17:00:28.744]             }
[17:00:28.744]         }))
[17:00:28.744]     }, error = function(ex) {
[17:00:28.744]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.744]                 ...future.rng), started = ...future.startTime, 
[17:00:28.744]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.744]             version = "1.8"), class = "FutureResult")
[17:00:28.744]     }, finally = {
[17:00:28.744]         if (!identical(...future.workdir, getwd())) 
[17:00:28.744]             setwd(...future.workdir)
[17:00:28.744]         {
[17:00:28.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.744]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.744]             }
[17:00:28.744]             base::options(...future.oldOptions)
[17:00:28.744]             if (.Platform$OS.type == "windows") {
[17:00:28.744]                 old_names <- names(...future.oldEnvVars)
[17:00:28.744]                 envs <- base::Sys.getenv()
[17:00:28.744]                 names <- names(envs)
[17:00:28.744]                 common <- intersect(names, old_names)
[17:00:28.744]                 added <- setdiff(names, old_names)
[17:00:28.744]                 removed <- setdiff(old_names, names)
[17:00:28.744]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.744]                   envs[common]]
[17:00:28.744]                 NAMES <- toupper(changed)
[17:00:28.744]                 args <- list()
[17:00:28.744]                 for (kk in seq_along(NAMES)) {
[17:00:28.744]                   name <- changed[[kk]]
[17:00:28.744]                   NAME <- NAMES[[kk]]
[17:00:28.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.744]                     next
[17:00:28.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.744]                 }
[17:00:28.744]                 NAMES <- toupper(added)
[17:00:28.744]                 for (kk in seq_along(NAMES)) {
[17:00:28.744]                   name <- added[[kk]]
[17:00:28.744]                   NAME <- NAMES[[kk]]
[17:00:28.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.744]                     next
[17:00:28.744]                   args[[name]] <- ""
[17:00:28.744]                 }
[17:00:28.744]                 NAMES <- toupper(removed)
[17:00:28.744]                 for (kk in seq_along(NAMES)) {
[17:00:28.744]                   name <- removed[[kk]]
[17:00:28.744]                   NAME <- NAMES[[kk]]
[17:00:28.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.744]                     next
[17:00:28.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.744]                 }
[17:00:28.744]                 if (length(args) > 0) 
[17:00:28.744]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.744]             }
[17:00:28.744]             else {
[17:00:28.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.744]             }
[17:00:28.744]             {
[17:00:28.744]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.744]                   0L) {
[17:00:28.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.744]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.744]                   base::options(opts)
[17:00:28.744]                 }
[17:00:28.744]                 {
[17:00:28.744]                   {
[17:00:28.744]                     base::assign(".Random.seed", c(10407L, 1624550703L, 
[17:00:28.744]                     -922435925L, 962809165L, 2054632538L, 1051373140L, 
[17:00:28.744]                     1348729052L), envir = base::globalenv(), 
[17:00:28.744]                       inherits = FALSE)
[17:00:28.744]                     NULL
[17:00:28.744]                   }
[17:00:28.744]                   options(future.plan = NULL)
[17:00:28.744]                   if (is.na(NA_character_)) 
[17:00:28.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.744]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.744]                     .init = FALSE)
[17:00:28.744]                 }
[17:00:28.744]             }
[17:00:28.744]         }
[17:00:28.744]     })
[17:00:28.744]     if (TRUE) {
[17:00:28.744]         base::sink(type = "output", split = FALSE)
[17:00:28.744]         if (TRUE) {
[17:00:28.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.744]         }
[17:00:28.744]         else {
[17:00:28.744]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.744]         }
[17:00:28.744]         base::close(...future.stdout)
[17:00:28.744]         ...future.stdout <- NULL
[17:00:28.744]     }
[17:00:28.744]     ...future.result$conditions <- ...future.conditions
[17:00:28.744]     ...future.result$finished <- base::Sys.time()
[17:00:28.744]     ...future.result
[17:00:28.744] }
[17:00:28.746] assign_globals() ...
[17:00:28.746] List of 5
[17:00:28.746]  $ ...future.FUN            :function (x, ...)  
[17:00:28.746]  $ MoreArgs                 : NULL
[17:00:28.746]  $ ...future.elements_ii    :List of 2
[17:00:28.746]   ..$ :List of 4
[17:00:28.746]   .. ..$ : int 1
[17:00:28.746]   .. ..$ : int 2
[17:00:28.746]   .. ..$ : int 3
[17:00:28.746]   .. ..$ : int 4
[17:00:28.746]   ..$ :List of 4
[17:00:28.746]   .. ..$ : int 2
[17:00:28.746]   .. ..$ : int 1
[17:00:28.746]   .. ..$ : int 2
[17:00:28.746]   .. ..$ : int 1
[17:00:28.746]  $ ...future.seeds_ii       : NULL
[17:00:28.746]  $ ...future.globals.maxSize: NULL
[17:00:28.746]  - attr(*, "where")=List of 5
[17:00:28.746]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.746]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.746]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.746]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.746]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.746]  - attr(*, "resolved")= logi FALSE
[17:00:28.746]  - attr(*, "total_size")= num 504
[17:00:28.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.746]  - attr(*, "already-done")= logi TRUE
[17:00:28.752] - copied ‘...future.FUN’ to environment
[17:00:28.753] - copied ‘MoreArgs’ to environment
[17:00:28.753] - copied ‘...future.elements_ii’ to environment
[17:00:28.753] - copied ‘...future.seeds_ii’ to environment
[17:00:28.753] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.753] assign_globals() ... done
[17:00:28.753] plan(): Setting new future strategy stack:
[17:00:28.753] List of future strategies:
[17:00:28.753] 1. sequential:
[17:00:28.753]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.753]    - tweaked: FALSE
[17:00:28.753]    - call: NULL
[17:00:28.754] plan(): nbrOfWorkers() = 1
[17:00:28.755] plan(): Setting new future strategy stack:
[17:00:28.755] List of future strategies:
[17:00:28.755] 1. sequential:
[17:00:28.755]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.755]    - tweaked: FALSE
[17:00:28.755]    - call: plan(strategy)
[17:00:28.755] plan(): nbrOfWorkers() = 1
[17:00:28.755] SequentialFuture started (and completed)
[17:00:28.755] - Launch lazy future ... done
[17:00:28.756] run() for ‘SequentialFuture’ ... done
[17:00:28.756] Created future:
[17:00:28.756] SequentialFuture:
[17:00:28.756] Label: ‘future_mapply-1’
[17:00:28.756] Expression:
[17:00:28.756] {
[17:00:28.756]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.756]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.756]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.756]         on.exit(options(oopts), add = TRUE)
[17:00:28.756]     }
[17:00:28.756]     {
[17:00:28.756]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.756]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.756]         do.call(mapply, args = args)
[17:00:28.756]     }
[17:00:28.756] }
[17:00:28.756] Lazy evaluation: FALSE
[17:00:28.756] Asynchronous evaluation: FALSE
[17:00:28.756] Local evaluation: TRUE
[17:00:28.756] Environment: R_GlobalEnv
[17:00:28.756] Capture standard output: TRUE
[17:00:28.756] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.756] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.756] Packages: <none>
[17:00:28.756] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.756] Resolved: TRUE
[17:00:28.756] Value: 224 bytes of class ‘list’
[17:00:28.756] Early signaling: FALSE
[17:00:28.756] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.756] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.757] Chunk #1 of 1 ... DONE
[17:00:28.757] Launching 1 futures (chunks) ... DONE
[17:00:28.757] Resolving 1 futures (chunks) ...
[17:00:28.757] resolve() on list ...
[17:00:28.757]  recursive: 0
[17:00:28.757]  length: 1
[17:00:28.757] 
[17:00:28.757] resolved() for ‘SequentialFuture’ ...
[17:00:28.760] - state: ‘finished’
[17:00:28.760] - run: TRUE
[17:00:28.760] - result: ‘FutureResult’
[17:00:28.760] resolved() for ‘SequentialFuture’ ... done
[17:00:28.760] Future #1
[17:00:28.760] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.760] - nx: 1
[17:00:28.760] - relay: TRUE
[17:00:28.761] - stdout: TRUE
[17:00:28.761] - signal: TRUE
[17:00:28.761] - resignal: FALSE
[17:00:28.761] - force: TRUE
[17:00:28.761] - relayed: [n=1] FALSE
[17:00:28.761] - queued futures: [n=1] FALSE
[17:00:28.761]  - until=1
[17:00:28.761]  - relaying element #1
[17:00:28.762] - relayed: [n=1] TRUE
[17:00:28.762] - queued futures: [n=1] TRUE
[17:00:28.762] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.762]  length: 0 (resolved future 1)
[17:00:28.762] Relaying remaining futures
[17:00:28.762] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.762] - nx: 1
[17:00:28.762] - relay: TRUE
[17:00:28.762] - stdout: TRUE
[17:00:28.762] - signal: TRUE
[17:00:28.762] - resignal: FALSE
[17:00:28.763] - force: TRUE
[17:00:28.763] - relayed: [n=1] TRUE
[17:00:28.763] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.763] - relayed: [n=1] TRUE
[17:00:28.763] - queued futures: [n=1] TRUE
[17:00:28.763] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.763] resolve() on list ... DONE
[17:00:28.763]  - Number of value chunks collected: 1
[17:00:28.763] Resolving 1 futures (chunks) ... DONE
[17:00:28.764] Reducing values from 1 chunks ...
[17:00:28.764]  - Number of values collected after concatenation: 4
[17:00:28.764]  - Number of values expected: 4
[17:00:28.764] Reducing values from 1 chunks ... DONE
[17:00:28.764] future_mapply() ... DONE
- Parallel RNG ...
[17:00:28.764] future_mapply() ...
[17:00:28.764] Generating random seeds ...
[17:00:28.764] Generating random seed streams for 4 elements ...
[17:00:28.764] Generating random seed streams for 4 elements ... DONE
[17:00:28.765] Generating random seeds ... DONE
[17:00:28.765] Will set RNG state on exit: 10407, 962809165, 1305900897, -1142338729, 1348729052, -1360049442, -746281512
[17:00:28.765] Number of chunks: 1
[17:00:28.765] getGlobalsAndPackagesXApply() ...
[17:00:28.765]  - future.globals: TRUE
[17:00:28.765] getGlobalsAndPackages() ...
[17:00:28.765] Searching for globals...
[17:00:28.766] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:00:28.767] Searching for globals ... DONE
[17:00:28.767] Resolving globals: FALSE
[17:00:28.767] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:00:28.768] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:00:28.768] - globals: [1] ‘FUN’
[17:00:28.768] - packages: [1] ‘stats’
[17:00:28.768] getGlobalsAndPackages() ... DONE
[17:00:28.768]  - globals found/used: [n=1] ‘FUN’
[17:00:28.768]  - needed namespaces: [n=1] ‘stats’
[17:00:28.768] Finding globals ... DONE
[17:00:28.768] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.768] List of 2
[17:00:28.768]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:00:28.768]  $ MoreArgs     :List of 1
[17:00:28.768]   ..$ min: num 1
[17:00:28.768]  - attr(*, "where")=List of 2
[17:00:28.768]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.768]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.768]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.768]  - attr(*, "resolved")= logi FALSE
[17:00:28.768]  - attr(*, "total_size")= num NA
[17:00:28.771] Packages to be attached in all futures: [n=1] ‘stats’
[17:00:28.771] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.772] Number of futures (= number of chunks): 1
[17:00:28.772] Launching 1 futures (chunks) ...
[17:00:28.772] Chunk #1 of 1 ...
[17:00:28.772]  - Finding globals in '...' for chunk #1 ...
[17:00:28.772] getGlobalsAndPackages() ...
[17:00:28.772] Searching for globals...
[17:00:28.772] 
[17:00:28.773] Searching for globals ... DONE
[17:00:28.773] - globals: [0] <none>
[17:00:28.773] getGlobalsAndPackages() ... DONE
[17:00:28.773]    + additional globals found: [n=0] 
[17:00:28.773]    + additional namespaces needed: [n=0] 
[17:00:28.773]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.773]  - seeds: [4] <seeds>
[17:00:28.773]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.773] getGlobalsAndPackages() ...
[17:00:28.773] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.773] Resolving globals: FALSE
[17:00:28.774] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[17:00:28.774] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[17:00:28.775] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.775] - packages: [1] ‘stats’
[17:00:28.775] getGlobalsAndPackages() ... DONE
[17:00:28.775] run() for ‘Future’ ...
[17:00:28.775] - state: ‘created’
[17:00:28.775] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.776] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.776]   - Field: ‘label’
[17:00:28.776]   - Field: ‘local’
[17:00:28.776]   - Field: ‘owner’
[17:00:28.776]   - Field: ‘envir’
[17:00:28.776]   - Field: ‘packages’
[17:00:28.776]   - Field: ‘gc’
[17:00:28.777]   - Field: ‘conditions’
[17:00:28.777]   - Field: ‘expr’
[17:00:28.777]   - Field: ‘uuid’
[17:00:28.777]   - Field: ‘seed’
[17:00:28.777]   - Field: ‘version’
[17:00:28.777]   - Field: ‘result’
[17:00:28.777]   - Field: ‘asynchronous’
[17:00:28.777]   - Field: ‘calls’
[17:00:28.777]   - Field: ‘globals’
[17:00:28.777]   - Field: ‘stdout’
[17:00:28.777]   - Field: ‘earlySignal’
[17:00:28.778]   - Field: ‘lazy’
[17:00:28.778]   - Field: ‘state’
[17:00:28.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.778] - Launch lazy future ...
[17:00:28.778] Packages needed by the future expression (n = 1): ‘stats’
[17:00:28.778] Packages needed by future strategies (n = 0): <none>
[17:00:28.779] {
[17:00:28.779]     {
[17:00:28.779]         {
[17:00:28.779]             ...future.startTime <- base::Sys.time()
[17:00:28.779]             {
[17:00:28.779]                 {
[17:00:28.779]                   {
[17:00:28.779]                     {
[17:00:28.779]                       base::local({
[17:00:28.779]                         has_future <- base::requireNamespace("future", 
[17:00:28.779]                           quietly = TRUE)
[17:00:28.779]                         if (has_future) {
[17:00:28.779]                           ns <- base::getNamespace("future")
[17:00:28.779]                           version <- ns[[".package"]][["version"]]
[17:00:28.779]                           if (is.null(version)) 
[17:00:28.779]                             version <- utils::packageVersion("future")
[17:00:28.779]                         }
[17:00:28.779]                         else {
[17:00:28.779]                           version <- NULL
[17:00:28.779]                         }
[17:00:28.779]                         if (!has_future || version < "1.8.0") {
[17:00:28.779]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.779]                             "", base::R.version$version.string), 
[17:00:28.779]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:28.779]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.779]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.779]                               "release", "version")], collapse = " "), 
[17:00:28.779]                             hostname = base::Sys.info()[["nodename"]])
[17:00:28.779]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.779]                             info)
[17:00:28.779]                           info <- base::paste(info, collapse = "; ")
[17:00:28.779]                           if (!has_future) {
[17:00:28.779]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.779]                               info)
[17:00:28.779]                           }
[17:00:28.779]                           else {
[17:00:28.779]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.779]                               info, version)
[17:00:28.779]                           }
[17:00:28.779]                           base::stop(msg)
[17:00:28.779]                         }
[17:00:28.779]                       })
[17:00:28.779]                     }
[17:00:28.779]                     base::local({
[17:00:28.779]                       for (pkg in "stats") {
[17:00:28.779]                         base::loadNamespace(pkg)
[17:00:28.779]                         base::library(pkg, character.only = TRUE)
[17:00:28.779]                       }
[17:00:28.779]                     })
[17:00:28.779]                   }
[17:00:28.779]                   ...future.strategy.old <- future::plan("list")
[17:00:28.779]                   options(future.plan = NULL)
[17:00:28.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.779]                 }
[17:00:28.779]                 ...future.workdir <- getwd()
[17:00:28.779]             }
[17:00:28.779]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.779]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.779]         }
[17:00:28.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.779]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.779]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.779]             base::names(...future.oldOptions))
[17:00:28.779]     }
[17:00:28.779]     if (FALSE) {
[17:00:28.779]     }
[17:00:28.779]     else {
[17:00:28.779]         if (TRUE) {
[17:00:28.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.779]                 open = "w")
[17:00:28.779]         }
[17:00:28.779]         else {
[17:00:28.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.779]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.779]         }
[17:00:28.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.779]             base::sink(type = "output", split = FALSE)
[17:00:28.779]             base::close(...future.stdout)
[17:00:28.779]         }, add = TRUE)
[17:00:28.779]     }
[17:00:28.779]     ...future.frame <- base::sys.nframe()
[17:00:28.779]     ...future.conditions <- base::list()
[17:00:28.779]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.779]     if (FALSE) {
[17:00:28.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.779]     }
[17:00:28.779]     ...future.result <- base::tryCatch({
[17:00:28.779]         base::withCallingHandlers({
[17:00:28.779]             ...future.value <- base::withVisible(base::local({
[17:00:28.779]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.779]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.779]                   ...future.globals.maxSize)) {
[17:00:28.779]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.779]                   on.exit(options(oopts), add = TRUE)
[17:00:28.779]                 }
[17:00:28.779]                 {
[17:00:28.779]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:28.779]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:28.779]                       envir = globalenv(), inherits = FALSE)
[17:00:28.779]                     ...future.FUN(...)
[17:00:28.779]                   }
[17:00:28.779]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:28.779]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:28.779]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.779]                     USE.NAMES = FALSE)
[17:00:28.779]                   do.call(mapply, args = args)
[17:00:28.779]                 }
[17:00:28.779]             }))
[17:00:28.779]             future::FutureResult(value = ...future.value$value, 
[17:00:28.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.779]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.779]                     ...future.globalenv.names))
[17:00:28.779]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.779]         }, condition = base::local({
[17:00:28.779]             c <- base::c
[17:00:28.779]             inherits <- base::inherits
[17:00:28.779]             invokeRestart <- base::invokeRestart
[17:00:28.779]             length <- base::length
[17:00:28.779]             list <- base::list
[17:00:28.779]             seq.int <- base::seq.int
[17:00:28.779]             signalCondition <- base::signalCondition
[17:00:28.779]             sys.calls <- base::sys.calls
[17:00:28.779]             `[[` <- base::`[[`
[17:00:28.779]             `+` <- base::`+`
[17:00:28.779]             `<<-` <- base::`<<-`
[17:00:28.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.779]                   3L)]
[17:00:28.779]             }
[17:00:28.779]             function(cond) {
[17:00:28.779]                 is_error <- inherits(cond, "error")
[17:00:28.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.779]                   NULL)
[17:00:28.779]                 if (is_error) {
[17:00:28.779]                   sessionInformation <- function() {
[17:00:28.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.779]                       search = base::search(), system = base::Sys.info())
[17:00:28.779]                   }
[17:00:28.779]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.779]                     cond$call), session = sessionInformation(), 
[17:00:28.779]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.779]                   signalCondition(cond)
[17:00:28.779]                 }
[17:00:28.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.779]                 "immediateCondition"))) {
[17:00:28.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.779]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.779]                   if (TRUE && !signal) {
[17:00:28.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.779]                     {
[17:00:28.779]                       inherits <- base::inherits
[17:00:28.779]                       invokeRestart <- base::invokeRestart
[17:00:28.779]                       is.null <- base::is.null
[17:00:28.779]                       muffled <- FALSE
[17:00:28.779]                       if (inherits(cond, "message")) {
[17:00:28.779]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.779]                         if (muffled) 
[17:00:28.779]                           invokeRestart("muffleMessage")
[17:00:28.779]                       }
[17:00:28.779]                       else if (inherits(cond, "warning")) {
[17:00:28.779]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.779]                         if (muffled) 
[17:00:28.779]                           invokeRestart("muffleWarning")
[17:00:28.779]                       }
[17:00:28.779]                       else if (inherits(cond, "condition")) {
[17:00:28.779]                         if (!is.null(pattern)) {
[17:00:28.779]                           computeRestarts <- base::computeRestarts
[17:00:28.779]                           grepl <- base::grepl
[17:00:28.779]                           restarts <- computeRestarts(cond)
[17:00:28.779]                           for (restart in restarts) {
[17:00:28.779]                             name <- restart$name
[17:00:28.779]                             if (is.null(name)) 
[17:00:28.779]                               next
[17:00:28.779]                             if (!grepl(pattern, name)) 
[17:00:28.779]                               next
[17:00:28.779]                             invokeRestart(restart)
[17:00:28.779]                             muffled <- TRUE
[17:00:28.779]                             break
[17:00:28.779]                           }
[17:00:28.779]                         }
[17:00:28.779]                       }
[17:00:28.779]                       invisible(muffled)
[17:00:28.779]                     }
[17:00:28.779]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.779]                   }
[17:00:28.779]                 }
[17:00:28.779]                 else {
[17:00:28.779]                   if (TRUE) {
[17:00:28.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.779]                     {
[17:00:28.779]                       inherits <- base::inherits
[17:00:28.779]                       invokeRestart <- base::invokeRestart
[17:00:28.779]                       is.null <- base::is.null
[17:00:28.779]                       muffled <- FALSE
[17:00:28.779]                       if (inherits(cond, "message")) {
[17:00:28.779]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.779]                         if (muffled) 
[17:00:28.779]                           invokeRestart("muffleMessage")
[17:00:28.779]                       }
[17:00:28.779]                       else if (inherits(cond, "warning")) {
[17:00:28.779]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.779]                         if (muffled) 
[17:00:28.779]                           invokeRestart("muffleWarning")
[17:00:28.779]                       }
[17:00:28.779]                       else if (inherits(cond, "condition")) {
[17:00:28.779]                         if (!is.null(pattern)) {
[17:00:28.779]                           computeRestarts <- base::computeRestarts
[17:00:28.779]                           grepl <- base::grepl
[17:00:28.779]                           restarts <- computeRestarts(cond)
[17:00:28.779]                           for (restart in restarts) {
[17:00:28.779]                             name <- restart$name
[17:00:28.779]                             if (is.null(name)) 
[17:00:28.779]                               next
[17:00:28.779]                             if (!grepl(pattern, name)) 
[17:00:28.779]                               next
[17:00:28.779]                             invokeRestart(restart)
[17:00:28.779]                             muffled <- TRUE
[17:00:28.779]                             break
[17:00:28.779]                           }
[17:00:28.779]                         }
[17:00:28.779]                       }
[17:00:28.779]                       invisible(muffled)
[17:00:28.779]                     }
[17:00:28.779]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.779]                   }
[17:00:28.779]                 }
[17:00:28.779]             }
[17:00:28.779]         }))
[17:00:28.779]     }, error = function(ex) {
[17:00:28.779]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.779]                 ...future.rng), started = ...future.startTime, 
[17:00:28.779]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.779]             version = "1.8"), class = "FutureResult")
[17:00:28.779]     }, finally = {
[17:00:28.779]         if (!identical(...future.workdir, getwd())) 
[17:00:28.779]             setwd(...future.workdir)
[17:00:28.779]         {
[17:00:28.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.779]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.779]             }
[17:00:28.779]             base::options(...future.oldOptions)
[17:00:28.779]             if (.Platform$OS.type == "windows") {
[17:00:28.779]                 old_names <- names(...future.oldEnvVars)
[17:00:28.779]                 envs <- base::Sys.getenv()
[17:00:28.779]                 names <- names(envs)
[17:00:28.779]                 common <- intersect(names, old_names)
[17:00:28.779]                 added <- setdiff(names, old_names)
[17:00:28.779]                 removed <- setdiff(old_names, names)
[17:00:28.779]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.779]                   envs[common]]
[17:00:28.779]                 NAMES <- toupper(changed)
[17:00:28.779]                 args <- list()
[17:00:28.779]                 for (kk in seq_along(NAMES)) {
[17:00:28.779]                   name <- changed[[kk]]
[17:00:28.779]                   NAME <- NAMES[[kk]]
[17:00:28.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.779]                     next
[17:00:28.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.779]                 }
[17:00:28.779]                 NAMES <- toupper(added)
[17:00:28.779]                 for (kk in seq_along(NAMES)) {
[17:00:28.779]                   name <- added[[kk]]
[17:00:28.779]                   NAME <- NAMES[[kk]]
[17:00:28.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.779]                     next
[17:00:28.779]                   args[[name]] <- ""
[17:00:28.779]                 }
[17:00:28.779]                 NAMES <- toupper(removed)
[17:00:28.779]                 for (kk in seq_along(NAMES)) {
[17:00:28.779]                   name <- removed[[kk]]
[17:00:28.779]                   NAME <- NAMES[[kk]]
[17:00:28.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.779]                     next
[17:00:28.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.779]                 }
[17:00:28.779]                 if (length(args) > 0) 
[17:00:28.779]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.779]             }
[17:00:28.779]             else {
[17:00:28.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.779]             }
[17:00:28.779]             {
[17:00:28.779]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.779]                   0L) {
[17:00:28.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.779]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.779]                   base::options(opts)
[17:00:28.779]                 }
[17:00:28.779]                 {
[17:00:28.779]                   {
[17:00:28.779]                     base::assign(".Random.seed", c(10407L, 962809165L, 
[17:00:28.779]                     1305900897L, -1142338729L, 1348729052L, -1360049442L, 
[17:00:28.779]                     -746281512L), envir = base::globalenv(), 
[17:00:28.779]                       inherits = FALSE)
[17:00:28.779]                     NULL
[17:00:28.779]                   }
[17:00:28.779]                   options(future.plan = NULL)
[17:00:28.779]                   if (is.na(NA_character_)) 
[17:00:28.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.779]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.779]                     .init = FALSE)
[17:00:28.779]                 }
[17:00:28.779]             }
[17:00:28.779]         }
[17:00:28.779]     })
[17:00:28.779]     if (TRUE) {
[17:00:28.779]         base::sink(type = "output", split = FALSE)
[17:00:28.779]         if (TRUE) {
[17:00:28.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.779]         }
[17:00:28.779]         else {
[17:00:28.779]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.779]         }
[17:00:28.779]         base::close(...future.stdout)
[17:00:28.779]         ...future.stdout <- NULL
[17:00:28.779]     }
[17:00:28.779]     ...future.result$conditions <- ...future.conditions
[17:00:28.779]     ...future.result$finished <- base::Sys.time()
[17:00:28.779]     ...future.result
[17:00:28.779] }
[17:00:28.780] assign_globals() ...
[17:00:28.781] List of 5
[17:00:28.781]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:00:28.781]  $ MoreArgs                 :List of 1
[17:00:28.781]   ..$ min: num 1
[17:00:28.781]  $ ...future.elements_ii    :List of 2
[17:00:28.781]   ..$ n  :List of 4
[17:00:28.781]   .. ..$ : int 1
[17:00:28.781]   .. ..$ : int 2
[17:00:28.781]   .. ..$ : int 3
[17:00:28.781]   .. ..$ : int 4
[17:00:28.781]   ..$ max:List of 4
[17:00:28.781]   .. ..$ : int 2
[17:00:28.781]   .. ..$ : int 3
[17:00:28.781]   .. ..$ : int 4
[17:00:28.781]   .. ..$ : int 5
[17:00:28.781]  $ ...future.seeds_ii       :List of 4
[17:00:28.781]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:00:28.781]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:00:28.781]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[17:00:28.781]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[17:00:28.781]  $ ...future.globals.maxSize: NULL
[17:00:28.781]  - attr(*, "where")=List of 5
[17:00:28.781]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.781]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.781]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.781]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.781]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.781]  - attr(*, "resolved")= logi FALSE
[17:00:28.781]  - attr(*, "total_size")= num 2912
[17:00:28.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.781]  - attr(*, "already-done")= logi TRUE
[17:00:28.792] - copied ‘...future.FUN’ to environment
[17:00:28.792] - copied ‘MoreArgs’ to environment
[17:00:28.792] - copied ‘...future.elements_ii’ to environment
[17:00:28.792] - copied ‘...future.seeds_ii’ to environment
[17:00:28.792] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.792] assign_globals() ... done
[17:00:28.793] plan(): Setting new future strategy stack:
[17:00:28.793] List of future strategies:
[17:00:28.793] 1. sequential:
[17:00:28.793]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.793]    - tweaked: FALSE
[17:00:28.793]    - call: NULL
[17:00:28.793] plan(): nbrOfWorkers() = 1
[17:00:28.794] plan(): Setting new future strategy stack:
[17:00:28.794] List of future strategies:
[17:00:28.794] 1. sequential:
[17:00:28.794]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.794]    - tweaked: FALSE
[17:00:28.794]    - call: plan(strategy)
[17:00:28.795] plan(): nbrOfWorkers() = 1
[17:00:28.795] SequentialFuture started (and completed)
[17:00:28.795] - Launch lazy future ... done
[17:00:28.795] run() for ‘SequentialFuture’ ... done
[17:00:28.795] Created future:
[17:00:28.795] SequentialFuture:
[17:00:28.795] Label: ‘future_mapply-1’
[17:00:28.795] Expression:
[17:00:28.795] {
[17:00:28.795]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.795]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.795]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.795]         on.exit(options(oopts), add = TRUE)
[17:00:28.795]     }
[17:00:28.795]     {
[17:00:28.795]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:28.795]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:28.795]                 inherits = FALSE)
[17:00:28.795]             ...future.FUN(...)
[17:00:28.795]         }
[17:00:28.795]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:28.795]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:28.795]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.795]         do.call(mapply, args = args)
[17:00:28.795]     }
[17:00:28.795] }
[17:00:28.795] Lazy evaluation: FALSE
[17:00:28.795] Asynchronous evaluation: FALSE
[17:00:28.795] Local evaluation: TRUE
[17:00:28.795] Environment: R_GlobalEnv
[17:00:28.795] Capture standard output: TRUE
[17:00:28.795] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.795] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.795] Packages: 1 packages (‘stats’)
[17:00:28.795] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:28.795] Resolved: TRUE
[17:00:28.795] Value: 280 bytes of class ‘list’
[17:00:28.795] Early signaling: FALSE
[17:00:28.795] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.795] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.796] Chunk #1 of 1 ... DONE
[17:00:28.796] Launching 1 futures (chunks) ... DONE
[17:00:28.797] Resolving 1 futures (chunks) ...
[17:00:28.797] resolve() on list ...
[17:00:28.797]  recursive: 0
[17:00:28.797]  length: 1
[17:00:28.797] 
[17:00:28.797] resolved() for ‘SequentialFuture’ ...
[17:00:28.797] - state: ‘finished’
[17:00:28.797] - run: TRUE
[17:00:28.797] - result: ‘FutureResult’
[17:00:28.797] resolved() for ‘SequentialFuture’ ... done
[17:00:28.797] Future #1
[17:00:28.798] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.798] - nx: 1
[17:00:28.798] - relay: TRUE
[17:00:28.798] - stdout: TRUE
[17:00:28.798] - signal: TRUE
[17:00:28.798] - resignal: FALSE
[17:00:28.798] - force: TRUE
[17:00:28.798] - relayed: [n=1] FALSE
[17:00:28.798] - queued futures: [n=1] FALSE
[17:00:28.798]  - until=1
[17:00:28.798]  - relaying element #1
[17:00:28.799] - relayed: [n=1] TRUE
[17:00:28.799] - queued futures: [n=1] TRUE
[17:00:28.799] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.799]  length: 0 (resolved future 1)
[17:00:28.799] Relaying remaining futures
[17:00:28.799] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.799] - nx: 1
[17:00:28.799] - relay: TRUE
[17:00:28.799] - stdout: TRUE
[17:00:28.800] - signal: TRUE
[17:00:28.800] - resignal: FALSE
[17:00:28.800] - force: TRUE
[17:00:28.800] - relayed: [n=1] TRUE
[17:00:28.800] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.800] - relayed: [n=1] TRUE
[17:00:28.800] - queued futures: [n=1] TRUE
[17:00:28.800] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.800] resolve() on list ... DONE
[17:00:28.800]  - Number of value chunks collected: 1
[17:00:28.800] Resolving 1 futures (chunks) ... DONE
[17:00:28.801] Reducing values from 1 chunks ...
[17:00:28.801]  - Number of values collected after concatenation: 4
[17:00:28.801]  - Number of values expected: 4
[17:00:28.801] Reducing values from 1 chunks ... DONE
[17:00:28.801] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[17:00:28.803] future_mapply() ...
[17:00:28.803] Number of chunks: 1
[17:00:28.804] getGlobalsAndPackagesXApply() ...
[17:00:28.804]  - future.globals: TRUE
[17:00:28.804] getGlobalsAndPackages() ...
[17:00:28.804] Searching for globals...
[17:00:28.805] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:00:28.805] Searching for globals ... DONE
[17:00:28.805] Resolving globals: FALSE
[17:00:28.806] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[17:00:28.806] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[17:00:28.806] - globals: [1] ‘FUN’
[17:00:28.806] - packages: [1] ‘stats’
[17:00:28.806] getGlobalsAndPackages() ... DONE
[17:00:28.806]  - globals found/used: [n=1] ‘FUN’
[17:00:28.806]  - needed namespaces: [n=1] ‘stats’
[17:00:28.807] Finding globals ... DONE
[17:00:28.807] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.807] List of 2
[17:00:28.807]  $ ...future.FUN:function (x, w, ...)  
[17:00:28.807]  $ MoreArgs     : NULL
[17:00:28.807]  - attr(*, "where")=List of 2
[17:00:28.807]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.807]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.807]  - attr(*, "resolved")= logi FALSE
[17:00:28.807]  - attr(*, "total_size")= num NA
[17:00:28.812] Packages to be attached in all futures: [n=1] ‘stats’
[17:00:28.812] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.812] Number of futures (= number of chunks): 1
[17:00:28.812] Launching 1 futures (chunks) ...
[17:00:28.812] Chunk #1 of 1 ...
[17:00:28.812]  - Finding globals in '...' for chunk #1 ...
[17:00:28.812] getGlobalsAndPackages() ...
[17:00:28.812] Searching for globals...
[17:00:28.813] 
[17:00:28.813] Searching for globals ... DONE
[17:00:28.813] - globals: [0] <none>
[17:00:28.813] getGlobalsAndPackages() ... DONE
[17:00:28.813]    + additional globals found: [n=0] 
[17:00:28.813]    + additional namespaces needed: [n=0] 
[17:00:28.813]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.813]  - seeds: <none>
[17:00:28.813]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.814] getGlobalsAndPackages() ...
[17:00:28.814] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.814] Resolving globals: FALSE
[17:00:28.814] The total size of the 5 globals is 3.10 KiB (3176 bytes)
[17:00:28.815] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (1.72 KiB of class ‘list’), ‘...future.FUN’ (1.38 KiB of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.815] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.815] - packages: [1] ‘stats’
[17:00:28.815] getGlobalsAndPackages() ... DONE
[17:00:28.815] run() for ‘Future’ ...
[17:00:28.816] - state: ‘created’
[17:00:28.816] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.816] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.816] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.816]   - Field: ‘label’
[17:00:28.816]   - Field: ‘local’
[17:00:28.816]   - Field: ‘owner’
[17:00:28.817]   - Field: ‘envir’
[17:00:28.817]   - Field: ‘packages’
[17:00:28.817]   - Field: ‘gc’
[17:00:28.817]   - Field: ‘conditions’
[17:00:28.817]   - Field: ‘expr’
[17:00:28.817]   - Field: ‘uuid’
[17:00:28.817]   - Field: ‘seed’
[17:00:28.817]   - Field: ‘version’
[17:00:28.817]   - Field: ‘result’
[17:00:28.817]   - Field: ‘asynchronous’
[17:00:28.817]   - Field: ‘calls’
[17:00:28.817]   - Field: ‘globals’
[17:00:28.818]   - Field: ‘stdout’
[17:00:28.818]   - Field: ‘earlySignal’
[17:00:28.818]   - Field: ‘lazy’
[17:00:28.818]   - Field: ‘state’
[17:00:28.818] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.818] - Launch lazy future ...
[17:00:28.818] Packages needed by the future expression (n = 1): ‘stats’
[17:00:28.818] Packages needed by future strategies (n = 0): <none>
[17:00:28.819] {
[17:00:28.819]     {
[17:00:28.819]         {
[17:00:28.819]             ...future.startTime <- base::Sys.time()
[17:00:28.819]             {
[17:00:28.819]                 {
[17:00:28.819]                   {
[17:00:28.819]                     {
[17:00:28.819]                       base::local({
[17:00:28.819]                         has_future <- base::requireNamespace("future", 
[17:00:28.819]                           quietly = TRUE)
[17:00:28.819]                         if (has_future) {
[17:00:28.819]                           ns <- base::getNamespace("future")
[17:00:28.819]                           version <- ns[[".package"]][["version"]]
[17:00:28.819]                           if (is.null(version)) 
[17:00:28.819]                             version <- utils::packageVersion("future")
[17:00:28.819]                         }
[17:00:28.819]                         else {
[17:00:28.819]                           version <- NULL
[17:00:28.819]                         }
[17:00:28.819]                         if (!has_future || version < "1.8.0") {
[17:00:28.819]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.819]                             "", base::R.version$version.string), 
[17:00:28.819]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:28.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.819]                               "release", "version")], collapse = " "), 
[17:00:28.819]                             hostname = base::Sys.info()[["nodename"]])
[17:00:28.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.819]                             info)
[17:00:28.819]                           info <- base::paste(info, collapse = "; ")
[17:00:28.819]                           if (!has_future) {
[17:00:28.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.819]                               info)
[17:00:28.819]                           }
[17:00:28.819]                           else {
[17:00:28.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.819]                               info, version)
[17:00:28.819]                           }
[17:00:28.819]                           base::stop(msg)
[17:00:28.819]                         }
[17:00:28.819]                       })
[17:00:28.819]                     }
[17:00:28.819]                     base::local({
[17:00:28.819]                       for (pkg in "stats") {
[17:00:28.819]                         base::loadNamespace(pkg)
[17:00:28.819]                         base::library(pkg, character.only = TRUE)
[17:00:28.819]                       }
[17:00:28.819]                     })
[17:00:28.819]                   }
[17:00:28.819]                   ...future.strategy.old <- future::plan("list")
[17:00:28.819]                   options(future.plan = NULL)
[17:00:28.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.819]                 }
[17:00:28.819]                 ...future.workdir <- getwd()
[17:00:28.819]             }
[17:00:28.819]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.819]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.819]         }
[17:00:28.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.819]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.819]             base::names(...future.oldOptions))
[17:00:28.819]     }
[17:00:28.819]     if (FALSE) {
[17:00:28.819]     }
[17:00:28.819]     else {
[17:00:28.819]         if (TRUE) {
[17:00:28.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.819]                 open = "w")
[17:00:28.819]         }
[17:00:28.819]         else {
[17:00:28.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.819]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.819]         }
[17:00:28.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.819]             base::sink(type = "output", split = FALSE)
[17:00:28.819]             base::close(...future.stdout)
[17:00:28.819]         }, add = TRUE)
[17:00:28.819]     }
[17:00:28.819]     ...future.frame <- base::sys.nframe()
[17:00:28.819]     ...future.conditions <- base::list()
[17:00:28.819]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.819]     if (FALSE) {
[17:00:28.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.819]     }
[17:00:28.819]     ...future.result <- base::tryCatch({
[17:00:28.819]         base::withCallingHandlers({
[17:00:28.819]             ...future.value <- base::withVisible(base::local({
[17:00:28.819]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.819]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.819]                   ...future.globals.maxSize)) {
[17:00:28.819]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.819]                   on.exit(options(oopts), add = TRUE)
[17:00:28.819]                 }
[17:00:28.819]                 {
[17:00:28.819]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.819]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.819]                     USE.NAMES = FALSE)
[17:00:28.819]                   do.call(mapply, args = args)
[17:00:28.819]                 }
[17:00:28.819]             }))
[17:00:28.819]             future::FutureResult(value = ...future.value$value, 
[17:00:28.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.819]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.819]                     ...future.globalenv.names))
[17:00:28.819]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.819]         }, condition = base::local({
[17:00:28.819]             c <- base::c
[17:00:28.819]             inherits <- base::inherits
[17:00:28.819]             invokeRestart <- base::invokeRestart
[17:00:28.819]             length <- base::length
[17:00:28.819]             list <- base::list
[17:00:28.819]             seq.int <- base::seq.int
[17:00:28.819]             signalCondition <- base::signalCondition
[17:00:28.819]             sys.calls <- base::sys.calls
[17:00:28.819]             `[[` <- base::`[[`
[17:00:28.819]             `+` <- base::`+`
[17:00:28.819]             `<<-` <- base::`<<-`
[17:00:28.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.819]                   3L)]
[17:00:28.819]             }
[17:00:28.819]             function(cond) {
[17:00:28.819]                 is_error <- inherits(cond, "error")
[17:00:28.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.819]                   NULL)
[17:00:28.819]                 if (is_error) {
[17:00:28.819]                   sessionInformation <- function() {
[17:00:28.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.819]                       search = base::search(), system = base::Sys.info())
[17:00:28.819]                   }
[17:00:28.819]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.819]                     cond$call), session = sessionInformation(), 
[17:00:28.819]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.819]                   signalCondition(cond)
[17:00:28.819]                 }
[17:00:28.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.819]                 "immediateCondition"))) {
[17:00:28.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.819]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.819]                   if (TRUE && !signal) {
[17:00:28.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.819]                     {
[17:00:28.819]                       inherits <- base::inherits
[17:00:28.819]                       invokeRestart <- base::invokeRestart
[17:00:28.819]                       is.null <- base::is.null
[17:00:28.819]                       muffled <- FALSE
[17:00:28.819]                       if (inherits(cond, "message")) {
[17:00:28.819]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.819]                         if (muffled) 
[17:00:28.819]                           invokeRestart("muffleMessage")
[17:00:28.819]                       }
[17:00:28.819]                       else if (inherits(cond, "warning")) {
[17:00:28.819]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.819]                         if (muffled) 
[17:00:28.819]                           invokeRestart("muffleWarning")
[17:00:28.819]                       }
[17:00:28.819]                       else if (inherits(cond, "condition")) {
[17:00:28.819]                         if (!is.null(pattern)) {
[17:00:28.819]                           computeRestarts <- base::computeRestarts
[17:00:28.819]                           grepl <- base::grepl
[17:00:28.819]                           restarts <- computeRestarts(cond)
[17:00:28.819]                           for (restart in restarts) {
[17:00:28.819]                             name <- restart$name
[17:00:28.819]                             if (is.null(name)) 
[17:00:28.819]                               next
[17:00:28.819]                             if (!grepl(pattern, name)) 
[17:00:28.819]                               next
[17:00:28.819]                             invokeRestart(restart)
[17:00:28.819]                             muffled <- TRUE
[17:00:28.819]                             break
[17:00:28.819]                           }
[17:00:28.819]                         }
[17:00:28.819]                       }
[17:00:28.819]                       invisible(muffled)
[17:00:28.819]                     }
[17:00:28.819]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.819]                   }
[17:00:28.819]                 }
[17:00:28.819]                 else {
[17:00:28.819]                   if (TRUE) {
[17:00:28.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.819]                     {
[17:00:28.819]                       inherits <- base::inherits
[17:00:28.819]                       invokeRestart <- base::invokeRestart
[17:00:28.819]                       is.null <- base::is.null
[17:00:28.819]                       muffled <- FALSE
[17:00:28.819]                       if (inherits(cond, "message")) {
[17:00:28.819]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.819]                         if (muffled) 
[17:00:28.819]                           invokeRestart("muffleMessage")
[17:00:28.819]                       }
[17:00:28.819]                       else if (inherits(cond, "warning")) {
[17:00:28.819]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.819]                         if (muffled) 
[17:00:28.819]                           invokeRestart("muffleWarning")
[17:00:28.819]                       }
[17:00:28.819]                       else if (inherits(cond, "condition")) {
[17:00:28.819]                         if (!is.null(pattern)) {
[17:00:28.819]                           computeRestarts <- base::computeRestarts
[17:00:28.819]                           grepl <- base::grepl
[17:00:28.819]                           restarts <- computeRestarts(cond)
[17:00:28.819]                           for (restart in restarts) {
[17:00:28.819]                             name <- restart$name
[17:00:28.819]                             if (is.null(name)) 
[17:00:28.819]                               next
[17:00:28.819]                             if (!grepl(pattern, name)) 
[17:00:28.819]                               next
[17:00:28.819]                             invokeRestart(restart)
[17:00:28.819]                             muffled <- TRUE
[17:00:28.819]                             break
[17:00:28.819]                           }
[17:00:28.819]                         }
[17:00:28.819]                       }
[17:00:28.819]                       invisible(muffled)
[17:00:28.819]                     }
[17:00:28.819]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.819]                   }
[17:00:28.819]                 }
[17:00:28.819]             }
[17:00:28.819]         }))
[17:00:28.819]     }, error = function(ex) {
[17:00:28.819]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.819]                 ...future.rng), started = ...future.startTime, 
[17:00:28.819]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.819]             version = "1.8"), class = "FutureResult")
[17:00:28.819]     }, finally = {
[17:00:28.819]         if (!identical(...future.workdir, getwd())) 
[17:00:28.819]             setwd(...future.workdir)
[17:00:28.819]         {
[17:00:28.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.819]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.819]             }
[17:00:28.819]             base::options(...future.oldOptions)
[17:00:28.819]             if (.Platform$OS.type == "windows") {
[17:00:28.819]                 old_names <- names(...future.oldEnvVars)
[17:00:28.819]                 envs <- base::Sys.getenv()
[17:00:28.819]                 names <- names(envs)
[17:00:28.819]                 common <- intersect(names, old_names)
[17:00:28.819]                 added <- setdiff(names, old_names)
[17:00:28.819]                 removed <- setdiff(old_names, names)
[17:00:28.819]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.819]                   envs[common]]
[17:00:28.819]                 NAMES <- toupper(changed)
[17:00:28.819]                 args <- list()
[17:00:28.819]                 for (kk in seq_along(NAMES)) {
[17:00:28.819]                   name <- changed[[kk]]
[17:00:28.819]                   NAME <- NAMES[[kk]]
[17:00:28.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.819]                     next
[17:00:28.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.819]                 }
[17:00:28.819]                 NAMES <- toupper(added)
[17:00:28.819]                 for (kk in seq_along(NAMES)) {
[17:00:28.819]                   name <- added[[kk]]
[17:00:28.819]                   NAME <- NAMES[[kk]]
[17:00:28.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.819]                     next
[17:00:28.819]                   args[[name]] <- ""
[17:00:28.819]                 }
[17:00:28.819]                 NAMES <- toupper(removed)
[17:00:28.819]                 for (kk in seq_along(NAMES)) {
[17:00:28.819]                   name <- removed[[kk]]
[17:00:28.819]                   NAME <- NAMES[[kk]]
[17:00:28.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.819]                     next
[17:00:28.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.819]                 }
[17:00:28.819]                 if (length(args) > 0) 
[17:00:28.819]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.819]             }
[17:00:28.819]             else {
[17:00:28.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.819]             }
[17:00:28.819]             {
[17:00:28.819]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.819]                   0L) {
[17:00:28.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.819]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.819]                   base::options(opts)
[17:00:28.819]                 }
[17:00:28.819]                 {
[17:00:28.819]                   {
[17:00:28.819]                     base::assign(".Random.seed", c(10407L, 1305085903L, 
[17:00:28.819]                     -195045362L, -1944143463L, -360490793L, 417788527L, 
[17:00:28.819]                     -96650886L), envir = base::globalenv(), inherits = FALSE)
[17:00:28.819]                     NULL
[17:00:28.819]                   }
[17:00:28.819]                   options(future.plan = NULL)
[17:00:28.819]                   if (is.na(NA_character_)) 
[17:00:28.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.819]                     .init = FALSE)
[17:00:28.819]                 }
[17:00:28.819]             }
[17:00:28.819]         }
[17:00:28.819]     })
[17:00:28.819]     if (TRUE) {
[17:00:28.819]         base::sink(type = "output", split = FALSE)
[17:00:28.819]         if (TRUE) {
[17:00:28.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.819]         }
[17:00:28.819]         else {
[17:00:28.819]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.819]         }
[17:00:28.819]         base::close(...future.stdout)
[17:00:28.819]         ...future.stdout <- NULL
[17:00:28.819]     }
[17:00:28.819]     ...future.result$conditions <- ...future.conditions
[17:00:28.819]     ...future.result$finished <- base::Sys.time()
[17:00:28.819]     ...future.result
[17:00:28.819] }
[17:00:28.821] assign_globals() ...
[17:00:28.821] List of 5
[17:00:28.821]  $ ...future.FUN            :function (x, w, ...)  
[17:00:28.821]  $ MoreArgs                 : NULL
[17:00:28.821]  $ ...future.elements_ii    :List of 2
[17:00:28.821]   ..$ :List of 5
[17:00:28.821]   .. ..$ : num [1:10] 0.864 0.841 0.25 0.153 0.355 ...
[17:00:28.821]   .. ..$ : num [1:10] 0.676 0.858 0.763 0.267 0.781 ...
[17:00:28.821]   .. ..$ : num [1:10] 0.484 0.701 0.406 0.638 0.489 ...
[17:00:28.821]   .. ..$ : num [1:10] 0.6149 0.0488 0.6028 0.4649 0.9403 ...
[17:00:28.821]   .. ..$ : num [1:10] 0.182 0.387 0.546 0.263 0.463 ...
[17:00:28.821]   ..$ :List of 5
[17:00:28.821]   .. ..$ : num [1:10] 6 8 7 4 4 6 4 5 6 5
[17:00:28.821]   .. ..$ : num [1:10] 8 7 6 10 11 7 4 5 5 6
[17:00:28.821]   .. ..$ : num [1:10] 5 4 6 4 7 4 7 4 6 5
[17:00:28.821]   .. ..$ : num [1:10] 5 5 8 7 5 2 5 5 7 3
[17:00:28.821]   .. ..$ : num [1:10] 9 6 8 8 9 7 4 5 8 6
[17:00:28.821]  $ ...future.seeds_ii       : NULL
[17:00:28.821]  $ ...future.globals.maxSize: NULL
[17:00:28.821]  - attr(*, "where")=List of 5
[17:00:28.821]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.821]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.821]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.821]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.821]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.821]  - attr(*, "resolved")= logi FALSE
[17:00:28.821]  - attr(*, "total_size")= num 3176
[17:00:28.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.821]  - attr(*, "already-done")= logi TRUE
[17:00:28.828] - copied ‘...future.FUN’ to environment
[17:00:28.829] - copied ‘MoreArgs’ to environment
[17:00:28.829] - copied ‘...future.elements_ii’ to environment
[17:00:28.829] - copied ‘...future.seeds_ii’ to environment
[17:00:28.829] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.829] assign_globals() ... done
[17:00:28.829] plan(): Setting new future strategy stack:
[17:00:28.829] List of future strategies:
[17:00:28.829] 1. sequential:
[17:00:28.829]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.829]    - tweaked: FALSE
[17:00:28.829]    - call: NULL
[17:00:28.830] plan(): nbrOfWorkers() = 1
[17:00:28.831] plan(): Setting new future strategy stack:
[17:00:28.831] List of future strategies:
[17:00:28.831] 1. sequential:
[17:00:28.831]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.831]    - tweaked: FALSE
[17:00:28.831]    - call: plan(strategy)
[17:00:28.831] plan(): nbrOfWorkers() = 1
[17:00:28.832] SequentialFuture started (and completed)
[17:00:28.832] - Launch lazy future ... done
[17:00:28.832] run() for ‘SequentialFuture’ ... done
[17:00:28.832] Created future:
[17:00:28.832] SequentialFuture:
[17:00:28.832] Label: ‘future_Map-1’
[17:00:28.832] Expression:
[17:00:28.832] {
[17:00:28.832]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.832]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.832]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.832]         on.exit(options(oopts), add = TRUE)
[17:00:28.832]     }
[17:00:28.832]     {
[17:00:28.832]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.832]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.832]         do.call(mapply, args = args)
[17:00:28.832]     }
[17:00:28.832] }
[17:00:28.832] Lazy evaluation: FALSE
[17:00:28.832] Asynchronous evaluation: FALSE
[17:00:28.832] Local evaluation: TRUE
[17:00:28.832] Environment: R_GlobalEnv
[17:00:28.832] Capture standard output: TRUE
[17:00:28.832] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.832] Globals: 5 objects totaling 3.10 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.832] Packages: 1 packages (‘stats’)
[17:00:28.832] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.832] Resolved: TRUE
[17:00:28.832] Value: 280 bytes of class ‘list’
[17:00:28.832] Early signaling: FALSE
[17:00:28.832] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.832] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.836] Chunk #1 of 1 ... DONE
[17:00:28.836] Launching 1 futures (chunks) ... DONE
[17:00:28.836] Resolving 1 futures (chunks) ...
[17:00:28.836] resolve() on list ...
[17:00:28.836]  recursive: 0
[17:00:28.836]  length: 1
[17:00:28.836] 
[17:00:28.836] resolved() for ‘SequentialFuture’ ...
[17:00:28.837] - state: ‘finished’
[17:00:28.837] - run: TRUE
[17:00:28.837] - result: ‘FutureResult’
[17:00:28.837] resolved() for ‘SequentialFuture’ ... done
[17:00:28.837] Future #1
[17:00:28.837] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.837] - nx: 1
[17:00:28.837] - relay: TRUE
[17:00:28.837] - stdout: TRUE
[17:00:28.838] - signal: TRUE
[17:00:28.838] - resignal: FALSE
[17:00:28.838] - force: TRUE
[17:00:28.838] - relayed: [n=1] FALSE
[17:00:28.838] - queued futures: [n=1] FALSE
[17:00:28.838]  - until=1
[17:00:28.838]  - relaying element #1
[17:00:28.838] - relayed: [n=1] TRUE
[17:00:28.838] - queued futures: [n=1] TRUE
[17:00:28.838] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.839]  length: 0 (resolved future 1)
[17:00:28.839] Relaying remaining futures
[17:00:28.839] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.839] - nx: 1
[17:00:28.839] - relay: TRUE
[17:00:28.839] - stdout: TRUE
[17:00:28.839] - signal: TRUE
[17:00:28.839] - resignal: FALSE
[17:00:28.839] - force: TRUE
[17:00:28.839] - relayed: [n=1] TRUE
[17:00:28.839] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.840] - relayed: [n=1] TRUE
[17:00:28.840] - queued futures: [n=1] TRUE
[17:00:28.840] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.840] resolve() on list ... DONE
[17:00:28.840]  - Number of value chunks collected: 1
[17:00:28.840] Resolving 1 futures (chunks) ... DONE
[17:00:28.840] Reducing values from 1 chunks ...
[17:00:28.840]  - Number of values collected after concatenation: 5
[17:00:28.840]  - Number of values expected: 5
[17:00:28.840] Reducing values from 1 chunks ... DONE
[17:00:28.841] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[17:00:28.842] future_mapply() ...
[17:00:28.842] Number of chunks: 1
[17:00:28.843] getGlobalsAndPackagesXApply() ...
[17:00:28.843]  - future.globals: TRUE
[17:00:28.843] getGlobalsAndPackages() ...
[17:00:28.843] Searching for globals...
[17:00:28.844] - globals found: [1] ‘FUN’
[17:00:28.844] Searching for globals ... DONE
[17:00:28.844] Resolving globals: FALSE
[17:00:28.844] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:28.844] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:28.844] - globals: [1] ‘FUN’
[17:00:28.845] 
[17:00:28.845] getGlobalsAndPackages() ... DONE
[17:00:28.845]  - globals found/used: [n=1] ‘FUN’
[17:00:28.845]  - needed namespaces: [n=0] 
[17:00:28.845] Finding globals ... DONE
[17:00:28.845] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.845] List of 2
[17:00:28.845]  $ ...future.FUN:function (e1, e2)  
[17:00:28.845]  $ MoreArgs     : NULL
[17:00:28.845]  - attr(*, "where")=List of 2
[17:00:28.845]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.845]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.845]  - attr(*, "resolved")= logi FALSE
[17:00:28.845]  - attr(*, "total_size")= num NA
[17:00:28.848] Packages to be attached in all futures: [n=0] 
[17:00:28.848] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.848] Number of futures (= number of chunks): 1
[17:00:28.848] Launching 1 futures (chunks) ...
[17:00:28.848] Chunk #1 of 1 ...
[17:00:28.848]  - Finding globals in '...' for chunk #1 ...
[17:00:28.849] getGlobalsAndPackages() ...
[17:00:28.849] Searching for globals...
[17:00:28.849] 
[17:00:28.849] Searching for globals ... DONE
[17:00:28.849] - globals: [0] <none>
[17:00:28.849] getGlobalsAndPackages() ... DONE
[17:00:28.849]    + additional globals found: [n=0] 
[17:00:28.849]    + additional namespaces needed: [n=0] 
[17:00:28.850]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.850]  - seeds: <none>
[17:00:28.850]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.850] getGlobalsAndPackages() ...
[17:00:28.850] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.850] Resolving globals: FALSE
[17:00:28.851] The total size of the 5 globals is 392 bytes (392 bytes)
[17:00:28.851] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 392 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (336 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.851] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.851] 
[17:00:28.851] getGlobalsAndPackages() ... DONE
[17:00:28.852] run() for ‘Future’ ...
[17:00:28.852] - state: ‘created’
[17:00:28.852] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.852] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.852]   - Field: ‘label’
[17:00:28.853]   - Field: ‘local’
[17:00:28.853]   - Field: ‘owner’
[17:00:28.853]   - Field: ‘envir’
[17:00:28.853]   - Field: ‘packages’
[17:00:28.853]   - Field: ‘gc’
[17:00:28.853]   - Field: ‘conditions’
[17:00:28.853]   - Field: ‘expr’
[17:00:28.853]   - Field: ‘uuid’
[17:00:28.853]   - Field: ‘seed’
[17:00:28.853]   - Field: ‘version’
[17:00:28.853]   - Field: ‘result’
[17:00:28.854]   - Field: ‘asynchronous’
[17:00:28.854]   - Field: ‘calls’
[17:00:28.854]   - Field: ‘globals’
[17:00:28.854]   - Field: ‘stdout’
[17:00:28.854]   - Field: ‘earlySignal’
[17:00:28.854]   - Field: ‘lazy’
[17:00:28.854]   - Field: ‘state’
[17:00:28.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.854] - Launch lazy future ...
[17:00:28.855] Packages needed by the future expression (n = 0): <none>
[17:00:28.855] Packages needed by future strategies (n = 0): <none>
[17:00:28.855] {
[17:00:28.855]     {
[17:00:28.855]         {
[17:00:28.855]             ...future.startTime <- base::Sys.time()
[17:00:28.855]             {
[17:00:28.855]                 {
[17:00:28.855]                   {
[17:00:28.855]                     base::local({
[17:00:28.855]                       has_future <- base::requireNamespace("future", 
[17:00:28.855]                         quietly = TRUE)
[17:00:28.855]                       if (has_future) {
[17:00:28.855]                         ns <- base::getNamespace("future")
[17:00:28.855]                         version <- ns[[".package"]][["version"]]
[17:00:28.855]                         if (is.null(version)) 
[17:00:28.855]                           version <- utils::packageVersion("future")
[17:00:28.855]                       }
[17:00:28.855]                       else {
[17:00:28.855]                         version <- NULL
[17:00:28.855]                       }
[17:00:28.855]                       if (!has_future || version < "1.8.0") {
[17:00:28.855]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.855]                           "", base::R.version$version.string), 
[17:00:28.855]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.855]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.855]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.855]                             "release", "version")], collapse = " "), 
[17:00:28.855]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.855]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.855]                           info)
[17:00:28.855]                         info <- base::paste(info, collapse = "; ")
[17:00:28.855]                         if (!has_future) {
[17:00:28.855]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.855]                             info)
[17:00:28.855]                         }
[17:00:28.855]                         else {
[17:00:28.855]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.855]                             info, version)
[17:00:28.855]                         }
[17:00:28.855]                         base::stop(msg)
[17:00:28.855]                       }
[17:00:28.855]                     })
[17:00:28.855]                   }
[17:00:28.855]                   ...future.strategy.old <- future::plan("list")
[17:00:28.855]                   options(future.plan = NULL)
[17:00:28.855]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.855]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.855]                 }
[17:00:28.855]                 ...future.workdir <- getwd()
[17:00:28.855]             }
[17:00:28.855]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.855]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.855]         }
[17:00:28.855]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.855]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.855]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.855]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.855]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.855]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.855]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.855]             base::names(...future.oldOptions))
[17:00:28.855]     }
[17:00:28.855]     if (FALSE) {
[17:00:28.855]     }
[17:00:28.855]     else {
[17:00:28.855]         if (TRUE) {
[17:00:28.855]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.855]                 open = "w")
[17:00:28.855]         }
[17:00:28.855]         else {
[17:00:28.855]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.855]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.855]         }
[17:00:28.855]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.855]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.855]             base::sink(type = "output", split = FALSE)
[17:00:28.855]             base::close(...future.stdout)
[17:00:28.855]         }, add = TRUE)
[17:00:28.855]     }
[17:00:28.855]     ...future.frame <- base::sys.nframe()
[17:00:28.855]     ...future.conditions <- base::list()
[17:00:28.855]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.855]     if (FALSE) {
[17:00:28.855]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.855]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.855]     }
[17:00:28.855]     ...future.result <- base::tryCatch({
[17:00:28.855]         base::withCallingHandlers({
[17:00:28.855]             ...future.value <- base::withVisible(base::local({
[17:00:28.855]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.855]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.855]                   ...future.globals.maxSize)) {
[17:00:28.855]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.855]                   on.exit(options(oopts), add = TRUE)
[17:00:28.855]                 }
[17:00:28.855]                 {
[17:00:28.855]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.855]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.855]                     USE.NAMES = FALSE)
[17:00:28.855]                   do.call(mapply, args = args)
[17:00:28.855]                 }
[17:00:28.855]             }))
[17:00:28.855]             future::FutureResult(value = ...future.value$value, 
[17:00:28.855]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.855]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.855]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.855]                     ...future.globalenv.names))
[17:00:28.855]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.855]         }, condition = base::local({
[17:00:28.855]             c <- base::c
[17:00:28.855]             inherits <- base::inherits
[17:00:28.855]             invokeRestart <- base::invokeRestart
[17:00:28.855]             length <- base::length
[17:00:28.855]             list <- base::list
[17:00:28.855]             seq.int <- base::seq.int
[17:00:28.855]             signalCondition <- base::signalCondition
[17:00:28.855]             sys.calls <- base::sys.calls
[17:00:28.855]             `[[` <- base::`[[`
[17:00:28.855]             `+` <- base::`+`
[17:00:28.855]             `<<-` <- base::`<<-`
[17:00:28.855]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.855]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.855]                   3L)]
[17:00:28.855]             }
[17:00:28.855]             function(cond) {
[17:00:28.855]                 is_error <- inherits(cond, "error")
[17:00:28.855]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.855]                   NULL)
[17:00:28.855]                 if (is_error) {
[17:00:28.855]                   sessionInformation <- function() {
[17:00:28.855]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.855]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.855]                       search = base::search(), system = base::Sys.info())
[17:00:28.855]                   }
[17:00:28.855]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.855]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.855]                     cond$call), session = sessionInformation(), 
[17:00:28.855]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.855]                   signalCondition(cond)
[17:00:28.855]                 }
[17:00:28.855]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.855]                 "immediateCondition"))) {
[17:00:28.855]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.855]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.855]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.855]                   if (TRUE && !signal) {
[17:00:28.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.855]                     {
[17:00:28.855]                       inherits <- base::inherits
[17:00:28.855]                       invokeRestart <- base::invokeRestart
[17:00:28.855]                       is.null <- base::is.null
[17:00:28.855]                       muffled <- FALSE
[17:00:28.855]                       if (inherits(cond, "message")) {
[17:00:28.855]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.855]                         if (muffled) 
[17:00:28.855]                           invokeRestart("muffleMessage")
[17:00:28.855]                       }
[17:00:28.855]                       else if (inherits(cond, "warning")) {
[17:00:28.855]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.855]                         if (muffled) 
[17:00:28.855]                           invokeRestart("muffleWarning")
[17:00:28.855]                       }
[17:00:28.855]                       else if (inherits(cond, "condition")) {
[17:00:28.855]                         if (!is.null(pattern)) {
[17:00:28.855]                           computeRestarts <- base::computeRestarts
[17:00:28.855]                           grepl <- base::grepl
[17:00:28.855]                           restarts <- computeRestarts(cond)
[17:00:28.855]                           for (restart in restarts) {
[17:00:28.855]                             name <- restart$name
[17:00:28.855]                             if (is.null(name)) 
[17:00:28.855]                               next
[17:00:28.855]                             if (!grepl(pattern, name)) 
[17:00:28.855]                               next
[17:00:28.855]                             invokeRestart(restart)
[17:00:28.855]                             muffled <- TRUE
[17:00:28.855]                             break
[17:00:28.855]                           }
[17:00:28.855]                         }
[17:00:28.855]                       }
[17:00:28.855]                       invisible(muffled)
[17:00:28.855]                     }
[17:00:28.855]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.855]                   }
[17:00:28.855]                 }
[17:00:28.855]                 else {
[17:00:28.855]                   if (TRUE) {
[17:00:28.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.855]                     {
[17:00:28.855]                       inherits <- base::inherits
[17:00:28.855]                       invokeRestart <- base::invokeRestart
[17:00:28.855]                       is.null <- base::is.null
[17:00:28.855]                       muffled <- FALSE
[17:00:28.855]                       if (inherits(cond, "message")) {
[17:00:28.855]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.855]                         if (muffled) 
[17:00:28.855]                           invokeRestart("muffleMessage")
[17:00:28.855]                       }
[17:00:28.855]                       else if (inherits(cond, "warning")) {
[17:00:28.855]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.855]                         if (muffled) 
[17:00:28.855]                           invokeRestart("muffleWarning")
[17:00:28.855]                       }
[17:00:28.855]                       else if (inherits(cond, "condition")) {
[17:00:28.855]                         if (!is.null(pattern)) {
[17:00:28.855]                           computeRestarts <- base::computeRestarts
[17:00:28.855]                           grepl <- base::grepl
[17:00:28.855]                           restarts <- computeRestarts(cond)
[17:00:28.855]                           for (restart in restarts) {
[17:00:28.855]                             name <- restart$name
[17:00:28.855]                             if (is.null(name)) 
[17:00:28.855]                               next
[17:00:28.855]                             if (!grepl(pattern, name)) 
[17:00:28.855]                               next
[17:00:28.855]                             invokeRestart(restart)
[17:00:28.855]                             muffled <- TRUE
[17:00:28.855]                             break
[17:00:28.855]                           }
[17:00:28.855]                         }
[17:00:28.855]                       }
[17:00:28.855]                       invisible(muffled)
[17:00:28.855]                     }
[17:00:28.855]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.855]                   }
[17:00:28.855]                 }
[17:00:28.855]             }
[17:00:28.855]         }))
[17:00:28.855]     }, error = function(ex) {
[17:00:28.855]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.855]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.855]                 ...future.rng), started = ...future.startTime, 
[17:00:28.855]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.855]             version = "1.8"), class = "FutureResult")
[17:00:28.855]     }, finally = {
[17:00:28.855]         if (!identical(...future.workdir, getwd())) 
[17:00:28.855]             setwd(...future.workdir)
[17:00:28.855]         {
[17:00:28.855]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.855]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.855]             }
[17:00:28.855]             base::options(...future.oldOptions)
[17:00:28.855]             if (.Platform$OS.type == "windows") {
[17:00:28.855]                 old_names <- names(...future.oldEnvVars)
[17:00:28.855]                 envs <- base::Sys.getenv()
[17:00:28.855]                 names <- names(envs)
[17:00:28.855]                 common <- intersect(names, old_names)
[17:00:28.855]                 added <- setdiff(names, old_names)
[17:00:28.855]                 removed <- setdiff(old_names, names)
[17:00:28.855]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.855]                   envs[common]]
[17:00:28.855]                 NAMES <- toupper(changed)
[17:00:28.855]                 args <- list()
[17:00:28.855]                 for (kk in seq_along(NAMES)) {
[17:00:28.855]                   name <- changed[[kk]]
[17:00:28.855]                   NAME <- NAMES[[kk]]
[17:00:28.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.855]                     next
[17:00:28.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.855]                 }
[17:00:28.855]                 NAMES <- toupper(added)
[17:00:28.855]                 for (kk in seq_along(NAMES)) {
[17:00:28.855]                   name <- added[[kk]]
[17:00:28.855]                   NAME <- NAMES[[kk]]
[17:00:28.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.855]                     next
[17:00:28.855]                   args[[name]] <- ""
[17:00:28.855]                 }
[17:00:28.855]                 NAMES <- toupper(removed)
[17:00:28.855]                 for (kk in seq_along(NAMES)) {
[17:00:28.855]                   name <- removed[[kk]]
[17:00:28.855]                   NAME <- NAMES[[kk]]
[17:00:28.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.855]                     next
[17:00:28.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.855]                 }
[17:00:28.855]                 if (length(args) > 0) 
[17:00:28.855]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.855]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.855]             }
[17:00:28.855]             else {
[17:00:28.855]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.855]             }
[17:00:28.855]             {
[17:00:28.855]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.855]                   0L) {
[17:00:28.855]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.855]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.855]                   base::options(opts)
[17:00:28.855]                 }
[17:00:28.855]                 {
[17:00:28.855]                   {
[17:00:28.855]                     base::assign(".Random.seed", c(10407L, 1305085903L, 
[17:00:28.855]                     -195045362L, -1944143463L, -360490793L, 417788527L, 
[17:00:28.855]                     -96650886L), envir = base::globalenv(), inherits = FALSE)
[17:00:28.855]                     NULL
[17:00:28.855]                   }
[17:00:28.855]                   options(future.plan = NULL)
[17:00:28.855]                   if (is.na(NA_character_)) 
[17:00:28.855]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.855]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.855]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.855]                     .init = FALSE)
[17:00:28.855]                 }
[17:00:28.855]             }
[17:00:28.855]         }
[17:00:28.855]     })
[17:00:28.855]     if (TRUE) {
[17:00:28.855]         base::sink(type = "output", split = FALSE)
[17:00:28.855]         if (TRUE) {
[17:00:28.855]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.855]         }
[17:00:28.855]         else {
[17:00:28.855]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.855]         }
[17:00:28.855]         base::close(...future.stdout)
[17:00:28.855]         ...future.stdout <- NULL
[17:00:28.855]     }
[17:00:28.855]     ...future.result$conditions <- ...future.conditions
[17:00:28.855]     ...future.result$finished <- base::Sys.time()
[17:00:28.855]     ...future.result
[17:00:28.855] }
[17:00:28.857] assign_globals() ...
[17:00:28.857] List of 5
[17:00:28.857]  $ ...future.FUN            :function (e1, e2)  
[17:00:28.857]  $ MoreArgs                 : NULL
[17:00:28.857]  $ ...future.elements_ii    :List of 2
[17:00:28.857]   ..$ :List of 3
[17:00:28.857]   .. ..$ : num 1
[17:00:28.857]   .. ..$ : num 1
[17:00:28.857]   .. ..$ : num 1
[17:00:28.857]   ..$ :List of 3
[17:00:28.857]   .. ..$ : int 1
[17:00:28.857]   .. ..$ : int 2
[17:00:28.857]   .. ..$ : int 3
[17:00:28.857]  $ ...future.seeds_ii       : NULL
[17:00:28.857]  $ ...future.globals.maxSize: NULL
[17:00:28.857]  - attr(*, "where")=List of 5
[17:00:28.857]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.857]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.857]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.857]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.857]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.857]  - attr(*, "resolved")= logi FALSE
[17:00:28.857]  - attr(*, "total_size")= num 392
[17:00:28.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.857]  - attr(*, "already-done")= logi TRUE
[17:00:28.869] - copied ‘...future.FUN’ to environment
[17:00:28.869] - copied ‘MoreArgs’ to environment
[17:00:28.869] - copied ‘...future.elements_ii’ to environment
[17:00:28.869] - copied ‘...future.seeds_ii’ to environment
[17:00:28.869] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.869] assign_globals() ... done
[17:00:28.869] plan(): Setting new future strategy stack:
[17:00:28.870] List of future strategies:
[17:00:28.870] 1. sequential:
[17:00:28.870]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.870]    - tweaked: FALSE
[17:00:28.870]    - call: NULL
[17:00:28.870] plan(): nbrOfWorkers() = 1
[17:00:28.871] plan(): Setting new future strategy stack:
[17:00:28.871] List of future strategies:
[17:00:28.871] 1. sequential:
[17:00:28.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.871]    - tweaked: FALSE
[17:00:28.871]    - call: plan(strategy)
[17:00:28.871] plan(): nbrOfWorkers() = 1
[17:00:28.872] SequentialFuture started (and completed)
[17:00:28.872] - Launch lazy future ... done
[17:00:28.872] run() for ‘SequentialFuture’ ... done
[17:00:28.872] Created future:
[17:00:28.872] SequentialFuture:
[17:00:28.872] Label: ‘future_Map-1’
[17:00:28.872] Expression:
[17:00:28.872] {
[17:00:28.872]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.872]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.872]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.872]         on.exit(options(oopts), add = TRUE)
[17:00:28.872]     }
[17:00:28.872]     {
[17:00:28.872]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.872]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.872]         do.call(mapply, args = args)
[17:00:28.872]     }
[17:00:28.872] }
[17:00:28.872] Lazy evaluation: FALSE
[17:00:28.872] Asynchronous evaluation: FALSE
[17:00:28.872] Local evaluation: TRUE
[17:00:28.872] Environment: R_GlobalEnv
[17:00:28.872] Capture standard output: TRUE
[17:00:28.872] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.872] Globals: 5 objects totaling 392 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.872] Packages: <none>
[17:00:28.872] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.872] Resolved: TRUE
[17:00:28.872] Value: 168 bytes of class ‘list’
[17:00:28.872] Early signaling: FALSE
[17:00:28.872] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.872] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.873] Chunk #1 of 1 ... DONE
[17:00:28.873] Launching 1 futures (chunks) ... DONE
[17:00:28.873] Resolving 1 futures (chunks) ...
[17:00:28.873] resolve() on list ...
[17:00:28.873]  recursive: 0
[17:00:28.873]  length: 1
[17:00:28.874] 
[17:00:28.874] resolved() for ‘SequentialFuture’ ...
[17:00:28.874] - state: ‘finished’
[17:00:28.874] - run: TRUE
[17:00:28.874] - result: ‘FutureResult’
[17:00:28.874] resolved() for ‘SequentialFuture’ ... done
[17:00:28.874] Future #1
[17:00:28.874] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.874] - nx: 1
[17:00:28.874] - relay: TRUE
[17:00:28.875] - stdout: TRUE
[17:00:28.875] - signal: TRUE
[17:00:28.875] - resignal: FALSE
[17:00:28.875] - force: TRUE
[17:00:28.875] - relayed: [n=1] FALSE
[17:00:28.875] - queued futures: [n=1] FALSE
[17:00:28.875]  - until=1
[17:00:28.875]  - relaying element #1
[17:00:28.875] - relayed: [n=1] TRUE
[17:00:28.875] - queued futures: [n=1] TRUE
[17:00:28.876] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.876]  length: 0 (resolved future 1)
[17:00:28.876] Relaying remaining futures
[17:00:28.876] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.876] - nx: 1
[17:00:28.876] - relay: TRUE
[17:00:28.876] - stdout: TRUE
[17:00:28.876] - signal: TRUE
[17:00:28.876] - resignal: FALSE
[17:00:28.876] - force: TRUE
[17:00:28.876] - relayed: [n=1] TRUE
[17:00:28.876] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.877] - relayed: [n=1] TRUE
[17:00:28.877] - queued futures: [n=1] TRUE
[17:00:28.877] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.877] resolve() on list ... DONE
[17:00:28.877]  - Number of value chunks collected: 1
[17:00:28.877] Resolving 1 futures (chunks) ... DONE
[17:00:28.877] Reducing values from 1 chunks ...
[17:00:28.877]  - Number of values collected after concatenation: 3
[17:00:28.877]  - Number of values expected: 3
[17:00:28.877] Reducing values from 1 chunks ... DONE
[17:00:28.878] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[17:00:28.878] future_mapply() ...
[17:00:28.878] Number of chunks: 1
[17:00:28.878] getGlobalsAndPackagesXApply() ...
[17:00:28.878]  - future.globals: TRUE
[17:00:28.878] getGlobalsAndPackages() ...
[17:00:28.879] Searching for globals...
[17:00:28.880] - globals found: [1] ‘FUN’
[17:00:28.880] Searching for globals ... DONE
[17:00:28.880] Resolving globals: FALSE
[17:00:28.880] The total size of the 1 globals is 848 bytes (848 bytes)
[17:00:28.880] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:00:28.880] - globals: [1] ‘FUN’
[17:00:28.881] 
[17:00:28.881] getGlobalsAndPackages() ... DONE
[17:00:28.881]  - globals found/used: [n=1] ‘FUN’
[17:00:28.881]  - needed namespaces: [n=0] 
[17:00:28.881] Finding globals ... DONE
[17:00:28.881] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.881] List of 2
[17:00:28.881]  $ ...future.FUN:function (x)  
[17:00:28.881]  $ MoreArgs     : NULL
[17:00:28.881]  - attr(*, "where")=List of 2
[17:00:28.881]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.881]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.881]  - attr(*, "resolved")= logi FALSE
[17:00:28.881]  - attr(*, "total_size")= num NA
[17:00:28.884] Packages to be attached in all futures: [n=0] 
[17:00:28.884] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.884] Number of futures (= number of chunks): 1
[17:00:28.884] Launching 1 futures (chunks) ...
[17:00:28.884] Chunk #1 of 1 ...
[17:00:28.884]  - Finding globals in '...' for chunk #1 ...
[17:00:28.884] getGlobalsAndPackages() ...
[17:00:28.885] Searching for globals...
[17:00:28.885] 
[17:00:28.885] Searching for globals ... DONE
[17:00:28.885] - globals: [0] <none>
[17:00:28.885] getGlobalsAndPackages() ... DONE
[17:00:28.885]    + additional globals found: [n=0] 
[17:00:28.885]    + additional namespaces needed: [n=0] 
[17:00:28.885]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.885]  - seeds: <none>
[17:00:28.886]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.886] getGlobalsAndPackages() ...
[17:00:28.886] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.886] Resolving globals: FALSE
[17:00:28.886] The total size of the 5 globals is 960 bytes (960 bytes)
[17:00:28.887] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 960 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.887] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.889] 
[17:00:28.889] getGlobalsAndPackages() ... DONE
[17:00:28.889] run() for ‘Future’ ...
[17:00:28.889] - state: ‘created’
[17:00:28.890] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:00:28.890] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.890] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:00:28.890]   - Field: ‘label’
[17:00:28.890]   - Field: ‘local’
[17:00:28.890]   - Field: ‘owner’
[17:00:28.891]   - Field: ‘envir’
[17:00:28.891]   - Field: ‘packages’
[17:00:28.891]   - Field: ‘gc’
[17:00:28.891]   - Field: ‘conditions’
[17:00:28.891]   - Field: ‘expr’
[17:00:28.891]   - Field: ‘uuid’
[17:00:28.891]   - Field: ‘seed’
[17:00:28.891]   - Field: ‘version’
[17:00:28.891]   - Field: ‘result’
[17:00:28.892]   - Field: ‘asynchronous’
[17:00:28.892]   - Field: ‘calls’
[17:00:28.892]   - Field: ‘globals’
[17:00:28.892]   - Field: ‘stdout’
[17:00:28.892]   - Field: ‘earlySignal’
[17:00:28.892]   - Field: ‘lazy’
[17:00:28.892]   - Field: ‘state’
[17:00:28.892] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:00:28.892] - Launch lazy future ...
[17:00:28.893] Packages needed by the future expression (n = 0): <none>
[17:00:28.893] Packages needed by future strategies (n = 0): <none>
[17:00:28.893] {
[17:00:28.893]     {
[17:00:28.893]         {
[17:00:28.893]             ...future.startTime <- base::Sys.time()
[17:00:28.893]             {
[17:00:28.893]                 {
[17:00:28.893]                   {
[17:00:28.893]                     base::local({
[17:00:28.893]                       has_future <- base::requireNamespace("future", 
[17:00:28.893]                         quietly = TRUE)
[17:00:28.893]                       if (has_future) {
[17:00:28.893]                         ns <- base::getNamespace("future")
[17:00:28.893]                         version <- ns[[".package"]][["version"]]
[17:00:28.893]                         if (is.null(version)) 
[17:00:28.893]                           version <- utils::packageVersion("future")
[17:00:28.893]                       }
[17:00:28.893]                       else {
[17:00:28.893]                         version <- NULL
[17:00:28.893]                       }
[17:00:28.893]                       if (!has_future || version < "1.8.0") {
[17:00:28.893]                         info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.893]                           "", base::R.version$version.string), 
[17:00:28.893]                           platform = base::sprintf("%s (%s-bit)", 
[17:00:28.893]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.893]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.893]                             "release", "version")], collapse = " "), 
[17:00:28.893]                           hostname = base::Sys.info()[["nodename"]])
[17:00:28.893]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.893]                           info)
[17:00:28.893]                         info <- base::paste(info, collapse = "; ")
[17:00:28.893]                         if (!has_future) {
[17:00:28.893]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.893]                             info)
[17:00:28.893]                         }
[17:00:28.893]                         else {
[17:00:28.893]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.893]                             info, version)
[17:00:28.893]                         }
[17:00:28.893]                         base::stop(msg)
[17:00:28.893]                       }
[17:00:28.893]                     })
[17:00:28.893]                   }
[17:00:28.893]                   ...future.strategy.old <- future::plan("list")
[17:00:28.893]                   options(future.plan = NULL)
[17:00:28.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.893]                 }
[17:00:28.893]                 ...future.workdir <- getwd()
[17:00:28.893]             }
[17:00:28.893]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.893]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.893]         }
[17:00:28.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:28.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.893]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.893]             base::names(...future.oldOptions))
[17:00:28.893]     }
[17:00:28.893]     if (FALSE) {
[17:00:28.893]     }
[17:00:28.893]     else {
[17:00:28.893]         if (TRUE) {
[17:00:28.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.893]                 open = "w")
[17:00:28.893]         }
[17:00:28.893]         else {
[17:00:28.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.893]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.893]         }
[17:00:28.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.893]             base::sink(type = "output", split = FALSE)
[17:00:28.893]             base::close(...future.stdout)
[17:00:28.893]         }, add = TRUE)
[17:00:28.893]     }
[17:00:28.893]     ...future.frame <- base::sys.nframe()
[17:00:28.893]     ...future.conditions <- base::list()
[17:00:28.893]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.893]     if (FALSE) {
[17:00:28.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.893]     }
[17:00:28.893]     ...future.result <- base::tryCatch({
[17:00:28.893]         base::withCallingHandlers({
[17:00:28.893]             ...future.value <- base::withVisible(base::local({
[17:00:28.893]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.893]                 if (!identical(...future.globals.maxSize.org, 
[17:00:28.893]                   ...future.globals.maxSize)) {
[17:00:28.893]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.893]                   on.exit(options(oopts), add = TRUE)
[17:00:28.893]                 }
[17:00:28.893]                 {
[17:00:28.893]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.893]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.893]                     USE.NAMES = FALSE)
[17:00:28.893]                   do.call(mapply, args = args)
[17:00:28.893]                 }
[17:00:28.893]             }))
[17:00:28.893]             future::FutureResult(value = ...future.value$value, 
[17:00:28.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.893]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.893]                     ...future.globalenv.names))
[17:00:28.893]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.893]         }, condition = base::local({
[17:00:28.893]             c <- base::c
[17:00:28.893]             inherits <- base::inherits
[17:00:28.893]             invokeRestart <- base::invokeRestart
[17:00:28.893]             length <- base::length
[17:00:28.893]             list <- base::list
[17:00:28.893]             seq.int <- base::seq.int
[17:00:28.893]             signalCondition <- base::signalCondition
[17:00:28.893]             sys.calls <- base::sys.calls
[17:00:28.893]             `[[` <- base::`[[`
[17:00:28.893]             `+` <- base::`+`
[17:00:28.893]             `<<-` <- base::`<<-`
[17:00:28.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.893]                   3L)]
[17:00:28.893]             }
[17:00:28.893]             function(cond) {
[17:00:28.893]                 is_error <- inherits(cond, "error")
[17:00:28.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.893]                   NULL)
[17:00:28.893]                 if (is_error) {
[17:00:28.893]                   sessionInformation <- function() {
[17:00:28.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.893]                       search = base::search(), system = base::Sys.info())
[17:00:28.893]                   }
[17:00:28.893]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.893]                     cond$call), session = sessionInformation(), 
[17:00:28.893]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.893]                   signalCondition(cond)
[17:00:28.893]                 }
[17:00:28.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.893]                 "immediateCondition"))) {
[17:00:28.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.893]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.893]                   if (TRUE && !signal) {
[17:00:28.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.893]                     {
[17:00:28.893]                       inherits <- base::inherits
[17:00:28.893]                       invokeRestart <- base::invokeRestart
[17:00:28.893]                       is.null <- base::is.null
[17:00:28.893]                       muffled <- FALSE
[17:00:28.893]                       if (inherits(cond, "message")) {
[17:00:28.893]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.893]                         if (muffled) 
[17:00:28.893]                           invokeRestart("muffleMessage")
[17:00:28.893]                       }
[17:00:28.893]                       else if (inherits(cond, "warning")) {
[17:00:28.893]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.893]                         if (muffled) 
[17:00:28.893]                           invokeRestart("muffleWarning")
[17:00:28.893]                       }
[17:00:28.893]                       else if (inherits(cond, "condition")) {
[17:00:28.893]                         if (!is.null(pattern)) {
[17:00:28.893]                           computeRestarts <- base::computeRestarts
[17:00:28.893]                           grepl <- base::grepl
[17:00:28.893]                           restarts <- computeRestarts(cond)
[17:00:28.893]                           for (restart in restarts) {
[17:00:28.893]                             name <- restart$name
[17:00:28.893]                             if (is.null(name)) 
[17:00:28.893]                               next
[17:00:28.893]                             if (!grepl(pattern, name)) 
[17:00:28.893]                               next
[17:00:28.893]                             invokeRestart(restart)
[17:00:28.893]                             muffled <- TRUE
[17:00:28.893]                             break
[17:00:28.893]                           }
[17:00:28.893]                         }
[17:00:28.893]                       }
[17:00:28.893]                       invisible(muffled)
[17:00:28.893]                     }
[17:00:28.893]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.893]                   }
[17:00:28.893]                 }
[17:00:28.893]                 else {
[17:00:28.893]                   if (TRUE) {
[17:00:28.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.893]                     {
[17:00:28.893]                       inherits <- base::inherits
[17:00:28.893]                       invokeRestart <- base::invokeRestart
[17:00:28.893]                       is.null <- base::is.null
[17:00:28.893]                       muffled <- FALSE
[17:00:28.893]                       if (inherits(cond, "message")) {
[17:00:28.893]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.893]                         if (muffled) 
[17:00:28.893]                           invokeRestart("muffleMessage")
[17:00:28.893]                       }
[17:00:28.893]                       else if (inherits(cond, "warning")) {
[17:00:28.893]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.893]                         if (muffled) 
[17:00:28.893]                           invokeRestart("muffleWarning")
[17:00:28.893]                       }
[17:00:28.893]                       else if (inherits(cond, "condition")) {
[17:00:28.893]                         if (!is.null(pattern)) {
[17:00:28.893]                           computeRestarts <- base::computeRestarts
[17:00:28.893]                           grepl <- base::grepl
[17:00:28.893]                           restarts <- computeRestarts(cond)
[17:00:28.893]                           for (restart in restarts) {
[17:00:28.893]                             name <- restart$name
[17:00:28.893]                             if (is.null(name)) 
[17:00:28.893]                               next
[17:00:28.893]                             if (!grepl(pattern, name)) 
[17:00:28.893]                               next
[17:00:28.893]                             invokeRestart(restart)
[17:00:28.893]                             muffled <- TRUE
[17:00:28.893]                             break
[17:00:28.893]                           }
[17:00:28.893]                         }
[17:00:28.893]                       }
[17:00:28.893]                       invisible(muffled)
[17:00:28.893]                     }
[17:00:28.893]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.893]                   }
[17:00:28.893]                 }
[17:00:28.893]             }
[17:00:28.893]         }))
[17:00:28.893]     }, error = function(ex) {
[17:00:28.893]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.893]                 ...future.rng), started = ...future.startTime, 
[17:00:28.893]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.893]             version = "1.8"), class = "FutureResult")
[17:00:28.893]     }, finally = {
[17:00:28.893]         if (!identical(...future.workdir, getwd())) 
[17:00:28.893]             setwd(...future.workdir)
[17:00:28.893]         {
[17:00:28.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.893]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.893]             }
[17:00:28.893]             base::options(...future.oldOptions)
[17:00:28.893]             if (.Platform$OS.type == "windows") {
[17:00:28.893]                 old_names <- names(...future.oldEnvVars)
[17:00:28.893]                 envs <- base::Sys.getenv()
[17:00:28.893]                 names <- names(envs)
[17:00:28.893]                 common <- intersect(names, old_names)
[17:00:28.893]                 added <- setdiff(names, old_names)
[17:00:28.893]                 removed <- setdiff(old_names, names)
[17:00:28.893]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.893]                   envs[common]]
[17:00:28.893]                 NAMES <- toupper(changed)
[17:00:28.893]                 args <- list()
[17:00:28.893]                 for (kk in seq_along(NAMES)) {
[17:00:28.893]                   name <- changed[[kk]]
[17:00:28.893]                   NAME <- NAMES[[kk]]
[17:00:28.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.893]                     next
[17:00:28.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.893]                 }
[17:00:28.893]                 NAMES <- toupper(added)
[17:00:28.893]                 for (kk in seq_along(NAMES)) {
[17:00:28.893]                   name <- added[[kk]]
[17:00:28.893]                   NAME <- NAMES[[kk]]
[17:00:28.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.893]                     next
[17:00:28.893]                   args[[name]] <- ""
[17:00:28.893]                 }
[17:00:28.893]                 NAMES <- toupper(removed)
[17:00:28.893]                 for (kk in seq_along(NAMES)) {
[17:00:28.893]                   name <- removed[[kk]]
[17:00:28.893]                   NAME <- NAMES[[kk]]
[17:00:28.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.893]                     next
[17:00:28.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.893]                 }
[17:00:28.893]                 if (length(args) > 0) 
[17:00:28.893]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.893]             }
[17:00:28.893]             else {
[17:00:28.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.893]             }
[17:00:28.893]             {
[17:00:28.893]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.893]                   0L) {
[17:00:28.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.893]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.893]                   base::options(opts)
[17:00:28.893]                 }
[17:00:28.893]                 {
[17:00:28.893]                   {
[17:00:28.893]                     base::assign(".Random.seed", c(10407L, 1305085903L, 
[17:00:28.893]                     -195045362L, -1944143463L, -360490793L, 417788527L, 
[17:00:28.893]                     -96650886L), envir = base::globalenv(), inherits = FALSE)
[17:00:28.893]                     NULL
[17:00:28.893]                   }
[17:00:28.893]                   options(future.plan = NULL)
[17:00:28.893]                   if (is.na(NA_character_)) 
[17:00:28.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.893]                     .init = FALSE)
[17:00:28.893]                 }
[17:00:28.893]             }
[17:00:28.893]         }
[17:00:28.893]     })
[17:00:28.893]     if (TRUE) {
[17:00:28.893]         base::sink(type = "output", split = FALSE)
[17:00:28.893]         if (TRUE) {
[17:00:28.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.893]         }
[17:00:28.893]         else {
[17:00:28.893]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.893]         }
[17:00:28.893]         base::close(...future.stdout)
[17:00:28.893]         ...future.stdout <- NULL
[17:00:28.893]     }
[17:00:28.893]     ...future.result$conditions <- ...future.conditions
[17:00:28.893]     ...future.result$finished <- base::Sys.time()
[17:00:28.893]     ...future.result
[17:00:28.893] }
[17:00:28.895] assign_globals() ...
[17:00:28.895] List of 5
[17:00:28.895]  $ ...future.FUN            :function (x)  
[17:00:28.895]  $ MoreArgs                 : NULL
[17:00:28.895]  $ ...future.elements_ii    :List of 1
[17:00:28.895]   ..$ :List of 2
[17:00:28.895]   .. ..$ a: num 0
[17:00:28.895]   .. ..$ b: num 0
[17:00:28.895]  $ ...future.seeds_ii       : NULL
[17:00:28.895]  $ ...future.globals.maxSize: NULL
[17:00:28.895]  - attr(*, "where")=List of 5
[17:00:28.895]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.895]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.895]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.895]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.895]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.895]  - attr(*, "resolved")= logi FALSE
[17:00:28.895]  - attr(*, "total_size")= num 960
[17:00:28.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.895]  - attr(*, "already-done")= logi TRUE
[17:00:28.900] - copied ‘...future.FUN’ to environment
[17:00:28.900] - copied ‘MoreArgs’ to environment
[17:00:28.900] - copied ‘...future.elements_ii’ to environment
[17:00:28.900] - copied ‘...future.seeds_ii’ to environment
[17:00:28.900] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.900] assign_globals() ... done
[17:00:28.900] plan(): Setting new future strategy stack:
[17:00:28.901] List of future strategies:
[17:00:28.901] 1. sequential:
[17:00:28.901]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.901]    - tweaked: FALSE
[17:00:28.901]    - call: NULL
[17:00:28.901] plan(): nbrOfWorkers() = 1
[17:00:28.902] plan(): Setting new future strategy stack:
[17:00:28.902] List of future strategies:
[17:00:28.902] 1. sequential:
[17:00:28.902]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.902]    - tweaked: FALSE
[17:00:28.902]    - call: plan(strategy)
[17:00:28.902] plan(): nbrOfWorkers() = 1
[17:00:28.902] SequentialFuture started (and completed)
[17:00:28.903] - Launch lazy future ... done
[17:00:28.903] run() for ‘SequentialFuture’ ... done
[17:00:28.903] Created future:
[17:00:28.903] SequentialFuture:
[17:00:28.903] Label: ‘future_mapply-1’
[17:00:28.903] Expression:
[17:00:28.903] {
[17:00:28.903]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.903]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.903]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.903]         on.exit(options(oopts), add = TRUE)
[17:00:28.903]     }
[17:00:28.903]     {
[17:00:28.903]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.903]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.903]         do.call(mapply, args = args)
[17:00:28.903]     }
[17:00:28.903] }
[17:00:28.903] Lazy evaluation: FALSE
[17:00:28.903] Asynchronous evaluation: FALSE
[17:00:28.903] Local evaluation: TRUE
[17:00:28.903] Environment: R_GlobalEnv
[17:00:28.903] Capture standard output: TRUE
[17:00:28.903] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.903] Globals: 5 objects totaling 960 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.903] Packages: <none>
[17:00:28.903] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.903] Resolved: TRUE
[17:00:28.903] Value: 112 bytes of class ‘list’
[17:00:28.903] Early signaling: FALSE
[17:00:28.903] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.903] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:00:28.904] Chunk #1 of 1 ... DONE
[17:00:28.904] Launching 1 futures (chunks) ... DONE
[17:00:28.904] Resolving 1 futures (chunks) ...
[17:00:28.904] resolve() on list ...
[17:00:28.904]  recursive: 0
[17:00:28.904]  length: 1
[17:00:28.904] 
[17:00:28.904] resolved() for ‘SequentialFuture’ ...
[17:00:28.904] - state: ‘finished’
[17:00:28.905] - run: TRUE
[17:00:28.905] - result: ‘FutureResult’
[17:00:28.905] resolved() for ‘SequentialFuture’ ... done
[17:00:28.905] Future #1
[17:00:28.905] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:00:28.905] - nx: 1
[17:00:28.905] - relay: TRUE
[17:00:28.905] - stdout: TRUE
[17:00:28.905] - signal: TRUE
[17:00:28.905] - resignal: FALSE
[17:00:28.906] - force: TRUE
[17:00:28.906] - relayed: [n=1] FALSE
[17:00:28.906] - queued futures: [n=1] FALSE
[17:00:28.906]  - until=1
[17:00:28.906]  - relaying element #1
[17:00:28.906] - relayed: [n=1] TRUE
[17:00:28.906] - queued futures: [n=1] TRUE
[17:00:28.906] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:00:28.906]  length: 0 (resolved future 1)
[17:00:28.906] Relaying remaining futures
[17:00:28.907] signalConditionsASAP(NULL, pos=0) ...
[17:00:28.907] - nx: 1
[17:00:28.907] - relay: TRUE
[17:00:28.907] - stdout: TRUE
[17:00:28.907] - signal: TRUE
[17:00:28.907] - resignal: FALSE
[17:00:28.907] - force: TRUE
[17:00:28.907] - relayed: [n=1] TRUE
[17:00:28.907] - queued futures: [n=1] TRUE
 - flush all
[17:00:28.907] - relayed: [n=1] TRUE
[17:00:28.908] - queued futures: [n=1] TRUE
[17:00:28.908] signalConditionsASAP(NULL, pos=0) ... done
[17:00:28.908] resolve() on list ... DONE
[17:00:28.908]  - Number of value chunks collected: 1
[17:00:28.908] Resolving 1 futures (chunks) ... DONE
[17:00:28.908] Reducing values from 1 chunks ...
[17:00:28.908]  - Number of values collected after concatenation: 2
[17:00:28.908]  - Number of values expected: 2
[17:00:28.908] Reducing values from 1 chunks ... DONE
[17:00:28.908] future_mapply() ... DONE
[17:00:28.909] plan(): Setting new future strategy stack:
[17:00:28.909] List of future strategies:
[17:00:28.909] 1. sequential:
[17:00:28.909]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.909]    - tweaked: FALSE
[17:00:28.909]    - call: plan(sequential)
[17:00:28.909] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:00:28.910] plan(): Setting new future strategy stack:
[17:00:28.910] List of future strategies:
[17:00:28.910] 1. multicore:
[17:00:28.910]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:28.910]    - tweaked: FALSE
[17:00:28.910]    - call: plan(strategy)
[17:00:28.914] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[17:00:28.914] future_mapply() ...
[17:00:28.918] Number of chunks: 2
[17:00:28.918] getGlobalsAndPackagesXApply() ...
[17:00:28.918]  - future.globals: TRUE
[17:00:28.918] getGlobalsAndPackages() ...
[17:00:28.918] Searching for globals...
[17:00:28.919] - globals found: [1] ‘FUN’
[17:00:28.920] Searching for globals ... DONE
[17:00:28.921] Resolving globals: FALSE
[17:00:28.921] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:28.921] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:28.921] - globals: [1] ‘FUN’
[17:00:28.922] 
[17:00:28.922] getGlobalsAndPackages() ... DONE
[17:00:28.922]  - globals found/used: [n=1] ‘FUN’
[17:00:28.922]  - needed namespaces: [n=0] 
[17:00:28.922] Finding globals ... DONE
[17:00:28.922] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:28.922] List of 2
[17:00:28.922]  $ ...future.FUN:function (x, ...)  
[17:00:28.922]  $ MoreArgs     : NULL
[17:00:28.922]  - attr(*, "where")=List of 2
[17:00:28.922]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:28.922]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:28.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.922]  - attr(*, "resolved")= logi FALSE
[17:00:28.922]  - attr(*, "total_size")= num NA
[17:00:28.925] Packages to be attached in all futures: [n=0] 
[17:00:28.925] getGlobalsAndPackagesXApply() ... DONE
[17:00:28.926] Number of futures (= number of chunks): 2
[17:00:28.926] Launching 2 futures (chunks) ...
[17:00:28.926] Chunk #1 of 2 ...
[17:00:28.926]  - Finding globals in '...' for chunk #1 ...
[17:00:28.926] getGlobalsAndPackages() ...
[17:00:28.926] Searching for globals...
[17:00:28.926] 
[17:00:28.926] Searching for globals ... DONE
[17:00:28.927] - globals: [0] <none>
[17:00:28.927] getGlobalsAndPackages() ... DONE
[17:00:28.927]    + additional globals found: [n=0] 
[17:00:28.927]    + additional namespaces needed: [n=0] 
[17:00:28.927]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:28.927]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:28.927]  - seeds: <none>
[17:00:28.927]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.927] getGlobalsAndPackages() ...
[17:00:28.927] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.928] Resolving globals: FALSE
[17:00:28.928] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:28.928] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.929] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.929] 
[17:00:28.929] getGlobalsAndPackages() ... DONE
[17:00:28.929] run() for ‘Future’ ...
[17:00:28.929] - state: ‘created’
[17:00:28.929] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:28.933] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:28.933] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:28.934]   - Field: ‘label’
[17:00:28.934]   - Field: ‘local’
[17:00:28.934]   - Field: ‘owner’
[17:00:28.934]   - Field: ‘envir’
[17:00:28.934]   - Field: ‘workers’
[17:00:28.934]   - Field: ‘packages’
[17:00:28.934]   - Field: ‘gc’
[17:00:28.934]   - Field: ‘job’
[17:00:28.934]   - Field: ‘conditions’
[17:00:28.934]   - Field: ‘expr’
[17:00:28.934]   - Field: ‘uuid’
[17:00:28.935]   - Field: ‘seed’
[17:00:28.935]   - Field: ‘version’
[17:00:28.935]   - Field: ‘result’
[17:00:28.935]   - Field: ‘asynchronous’
[17:00:28.935]   - Field: ‘calls’
[17:00:28.935]   - Field: ‘globals’
[17:00:28.935]   - Field: ‘stdout’
[17:00:28.935]   - Field: ‘earlySignal’
[17:00:28.935]   - Field: ‘lazy’
[17:00:28.936]   - Field: ‘state’
[17:00:28.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:28.936] - Launch lazy future ...
[17:00:28.937] Packages needed by the future expression (n = 0): <none>
[17:00:28.937] Packages needed by future strategies (n = 0): <none>
[17:00:28.937] {
[17:00:28.937]     {
[17:00:28.937]         {
[17:00:28.937]             ...future.startTime <- base::Sys.time()
[17:00:28.937]             {
[17:00:28.937]                 {
[17:00:28.937]                   {
[17:00:28.937]                     {
[17:00:28.937]                       base::local({
[17:00:28.937]                         has_future <- base::requireNamespace("future", 
[17:00:28.937]                           quietly = TRUE)
[17:00:28.937]                         if (has_future) {
[17:00:28.937]                           ns <- base::getNamespace("future")
[17:00:28.937]                           version <- ns[[".package"]][["version"]]
[17:00:28.937]                           if (is.null(version)) 
[17:00:28.937]                             version <- utils::packageVersion("future")
[17:00:28.937]                         }
[17:00:28.937]                         else {
[17:00:28.937]                           version <- NULL
[17:00:28.937]                         }
[17:00:28.937]                         if (!has_future || version < "1.8.0") {
[17:00:28.937]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.937]                             "", base::R.version$version.string), 
[17:00:28.937]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:28.937]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.937]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.937]                               "release", "version")], collapse = " "), 
[17:00:28.937]                             hostname = base::Sys.info()[["nodename"]])
[17:00:28.937]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.937]                             info)
[17:00:28.937]                           info <- base::paste(info, collapse = "; ")
[17:00:28.937]                           if (!has_future) {
[17:00:28.937]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.937]                               info)
[17:00:28.937]                           }
[17:00:28.937]                           else {
[17:00:28.937]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.937]                               info, version)
[17:00:28.937]                           }
[17:00:28.937]                           base::stop(msg)
[17:00:28.937]                         }
[17:00:28.937]                       })
[17:00:28.937]                     }
[17:00:28.937]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:28.937]                     base::options(mc.cores = 1L)
[17:00:28.937]                   }
[17:00:28.937]                   ...future.strategy.old <- future::plan("list")
[17:00:28.937]                   options(future.plan = NULL)
[17:00:28.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.937]                 }
[17:00:28.937]                 ...future.workdir <- getwd()
[17:00:28.937]             }
[17:00:28.937]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.937]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.937]         }
[17:00:28.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.937]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:28.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.937]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.937]             base::names(...future.oldOptions))
[17:00:28.937]     }
[17:00:28.937]     if (FALSE) {
[17:00:28.937]     }
[17:00:28.937]     else {
[17:00:28.937]         if (TRUE) {
[17:00:28.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.937]                 open = "w")
[17:00:28.937]         }
[17:00:28.937]         else {
[17:00:28.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.937]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.937]         }
[17:00:28.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.937]             base::sink(type = "output", split = FALSE)
[17:00:28.937]             base::close(...future.stdout)
[17:00:28.937]         }, add = TRUE)
[17:00:28.937]     }
[17:00:28.937]     ...future.frame <- base::sys.nframe()
[17:00:28.937]     ...future.conditions <- base::list()
[17:00:28.937]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.937]     if (FALSE) {
[17:00:28.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.937]     }
[17:00:28.937]     ...future.result <- base::tryCatch({
[17:00:28.937]         base::withCallingHandlers({
[17:00:28.937]             ...future.value <- base::withVisible(base::local({
[17:00:28.937]                 withCallingHandlers({
[17:00:28.937]                   {
[17:00:28.937]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.937]                     if (!identical(...future.globals.maxSize.org, 
[17:00:28.937]                       ...future.globals.maxSize)) {
[17:00:28.937]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.937]                       on.exit(options(oopts), add = TRUE)
[17:00:28.937]                     }
[17:00:28.937]                     {
[17:00:28.937]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.937]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.937]                         USE.NAMES = FALSE)
[17:00:28.937]                       do.call(mapply, args = args)
[17:00:28.937]                     }
[17:00:28.937]                   }
[17:00:28.937]                 }, immediateCondition = function(cond) {
[17:00:28.937]                   save_rds <- function (object, pathname, ...) 
[17:00:28.937]                   {
[17:00:28.937]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:28.937]                     if (file_test("-f", pathname_tmp)) {
[17:00:28.937]                       fi_tmp <- file.info(pathname_tmp)
[17:00:28.937]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:28.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:28.937]                         fi_tmp[["mtime"]])
[17:00:28.937]                     }
[17:00:28.937]                     tryCatch({
[17:00:28.937]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:28.937]                     }, error = function(ex) {
[17:00:28.937]                       msg <- conditionMessage(ex)
[17:00:28.937]                       fi_tmp <- file.info(pathname_tmp)
[17:00:28.937]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:28.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:28.937]                         fi_tmp[["mtime"]], msg)
[17:00:28.937]                       ex$message <- msg
[17:00:28.937]                       stop(ex)
[17:00:28.937]                     })
[17:00:28.937]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:28.937]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:28.937]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:28.937]                       fi_tmp <- file.info(pathname_tmp)
[17:00:28.937]                       fi <- file.info(pathname)
[17:00:28.937]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:28.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:28.937]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:28.937]                         fi[["size"]], fi[["mtime"]])
[17:00:28.937]                       stop(msg)
[17:00:28.937]                     }
[17:00:28.937]                     invisible(pathname)
[17:00:28.937]                   }
[17:00:28.937]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:28.937]                     rootPath = tempdir()) 
[17:00:28.937]                   {
[17:00:28.937]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:28.937]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:28.937]                       tmpdir = path, fileext = ".rds")
[17:00:28.937]                     save_rds(obj, file)
[17:00:28.937]                   }
[17:00:28.937]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:28.937]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.937]                   {
[17:00:28.937]                     inherits <- base::inherits
[17:00:28.937]                     invokeRestart <- base::invokeRestart
[17:00:28.937]                     is.null <- base::is.null
[17:00:28.937]                     muffled <- FALSE
[17:00:28.937]                     if (inherits(cond, "message")) {
[17:00:28.937]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:28.937]                       if (muffled) 
[17:00:28.937]                         invokeRestart("muffleMessage")
[17:00:28.937]                     }
[17:00:28.937]                     else if (inherits(cond, "warning")) {
[17:00:28.937]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:28.937]                       if (muffled) 
[17:00:28.937]                         invokeRestart("muffleWarning")
[17:00:28.937]                     }
[17:00:28.937]                     else if (inherits(cond, "condition")) {
[17:00:28.937]                       if (!is.null(pattern)) {
[17:00:28.937]                         computeRestarts <- base::computeRestarts
[17:00:28.937]                         grepl <- base::grepl
[17:00:28.937]                         restarts <- computeRestarts(cond)
[17:00:28.937]                         for (restart in restarts) {
[17:00:28.937]                           name <- restart$name
[17:00:28.937]                           if (is.null(name)) 
[17:00:28.937]                             next
[17:00:28.937]                           if (!grepl(pattern, name)) 
[17:00:28.937]                             next
[17:00:28.937]                           invokeRestart(restart)
[17:00:28.937]                           muffled <- TRUE
[17:00:28.937]                           break
[17:00:28.937]                         }
[17:00:28.937]                       }
[17:00:28.937]                     }
[17:00:28.937]                     invisible(muffled)
[17:00:28.937]                   }
[17:00:28.937]                   muffleCondition(cond)
[17:00:28.937]                 })
[17:00:28.937]             }))
[17:00:28.937]             future::FutureResult(value = ...future.value$value, 
[17:00:28.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.937]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.937]                     ...future.globalenv.names))
[17:00:28.937]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.937]         }, condition = base::local({
[17:00:28.937]             c <- base::c
[17:00:28.937]             inherits <- base::inherits
[17:00:28.937]             invokeRestart <- base::invokeRestart
[17:00:28.937]             length <- base::length
[17:00:28.937]             list <- base::list
[17:00:28.937]             seq.int <- base::seq.int
[17:00:28.937]             signalCondition <- base::signalCondition
[17:00:28.937]             sys.calls <- base::sys.calls
[17:00:28.937]             `[[` <- base::`[[`
[17:00:28.937]             `+` <- base::`+`
[17:00:28.937]             `<<-` <- base::`<<-`
[17:00:28.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.937]                   3L)]
[17:00:28.937]             }
[17:00:28.937]             function(cond) {
[17:00:28.937]                 is_error <- inherits(cond, "error")
[17:00:28.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.937]                   NULL)
[17:00:28.937]                 if (is_error) {
[17:00:28.937]                   sessionInformation <- function() {
[17:00:28.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.937]                       search = base::search(), system = base::Sys.info())
[17:00:28.937]                   }
[17:00:28.937]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.937]                     cond$call), session = sessionInformation(), 
[17:00:28.937]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.937]                   signalCondition(cond)
[17:00:28.937]                 }
[17:00:28.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.937]                 "immediateCondition"))) {
[17:00:28.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.937]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.937]                   if (TRUE && !signal) {
[17:00:28.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.937]                     {
[17:00:28.937]                       inherits <- base::inherits
[17:00:28.937]                       invokeRestart <- base::invokeRestart
[17:00:28.937]                       is.null <- base::is.null
[17:00:28.937]                       muffled <- FALSE
[17:00:28.937]                       if (inherits(cond, "message")) {
[17:00:28.937]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.937]                         if (muffled) 
[17:00:28.937]                           invokeRestart("muffleMessage")
[17:00:28.937]                       }
[17:00:28.937]                       else if (inherits(cond, "warning")) {
[17:00:28.937]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.937]                         if (muffled) 
[17:00:28.937]                           invokeRestart("muffleWarning")
[17:00:28.937]                       }
[17:00:28.937]                       else if (inherits(cond, "condition")) {
[17:00:28.937]                         if (!is.null(pattern)) {
[17:00:28.937]                           computeRestarts <- base::computeRestarts
[17:00:28.937]                           grepl <- base::grepl
[17:00:28.937]                           restarts <- computeRestarts(cond)
[17:00:28.937]                           for (restart in restarts) {
[17:00:28.937]                             name <- restart$name
[17:00:28.937]                             if (is.null(name)) 
[17:00:28.937]                               next
[17:00:28.937]                             if (!grepl(pattern, name)) 
[17:00:28.937]                               next
[17:00:28.937]                             invokeRestart(restart)
[17:00:28.937]                             muffled <- TRUE
[17:00:28.937]                             break
[17:00:28.937]                           }
[17:00:28.937]                         }
[17:00:28.937]                       }
[17:00:28.937]                       invisible(muffled)
[17:00:28.937]                     }
[17:00:28.937]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.937]                   }
[17:00:28.937]                 }
[17:00:28.937]                 else {
[17:00:28.937]                   if (TRUE) {
[17:00:28.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.937]                     {
[17:00:28.937]                       inherits <- base::inherits
[17:00:28.937]                       invokeRestart <- base::invokeRestart
[17:00:28.937]                       is.null <- base::is.null
[17:00:28.937]                       muffled <- FALSE
[17:00:28.937]                       if (inherits(cond, "message")) {
[17:00:28.937]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.937]                         if (muffled) 
[17:00:28.937]                           invokeRestart("muffleMessage")
[17:00:28.937]                       }
[17:00:28.937]                       else if (inherits(cond, "warning")) {
[17:00:28.937]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.937]                         if (muffled) 
[17:00:28.937]                           invokeRestart("muffleWarning")
[17:00:28.937]                       }
[17:00:28.937]                       else if (inherits(cond, "condition")) {
[17:00:28.937]                         if (!is.null(pattern)) {
[17:00:28.937]                           computeRestarts <- base::computeRestarts
[17:00:28.937]                           grepl <- base::grepl
[17:00:28.937]                           restarts <- computeRestarts(cond)
[17:00:28.937]                           for (restart in restarts) {
[17:00:28.937]                             name <- restart$name
[17:00:28.937]                             if (is.null(name)) 
[17:00:28.937]                               next
[17:00:28.937]                             if (!grepl(pattern, name)) 
[17:00:28.937]                               next
[17:00:28.937]                             invokeRestart(restart)
[17:00:28.937]                             muffled <- TRUE
[17:00:28.937]                             break
[17:00:28.937]                           }
[17:00:28.937]                         }
[17:00:28.937]                       }
[17:00:28.937]                       invisible(muffled)
[17:00:28.937]                     }
[17:00:28.937]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.937]                   }
[17:00:28.937]                 }
[17:00:28.937]             }
[17:00:28.937]         }))
[17:00:28.937]     }, error = function(ex) {
[17:00:28.937]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.937]                 ...future.rng), started = ...future.startTime, 
[17:00:28.937]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.937]             version = "1.8"), class = "FutureResult")
[17:00:28.937]     }, finally = {
[17:00:28.937]         if (!identical(...future.workdir, getwd())) 
[17:00:28.937]             setwd(...future.workdir)
[17:00:28.937]         {
[17:00:28.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.937]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.937]             }
[17:00:28.937]             base::options(...future.oldOptions)
[17:00:28.937]             if (.Platform$OS.type == "windows") {
[17:00:28.937]                 old_names <- names(...future.oldEnvVars)
[17:00:28.937]                 envs <- base::Sys.getenv()
[17:00:28.937]                 names <- names(envs)
[17:00:28.937]                 common <- intersect(names, old_names)
[17:00:28.937]                 added <- setdiff(names, old_names)
[17:00:28.937]                 removed <- setdiff(old_names, names)
[17:00:28.937]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.937]                   envs[common]]
[17:00:28.937]                 NAMES <- toupper(changed)
[17:00:28.937]                 args <- list()
[17:00:28.937]                 for (kk in seq_along(NAMES)) {
[17:00:28.937]                   name <- changed[[kk]]
[17:00:28.937]                   NAME <- NAMES[[kk]]
[17:00:28.937]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.937]                     next
[17:00:28.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.937]                 }
[17:00:28.937]                 NAMES <- toupper(added)
[17:00:28.937]                 for (kk in seq_along(NAMES)) {
[17:00:28.937]                   name <- added[[kk]]
[17:00:28.937]                   NAME <- NAMES[[kk]]
[17:00:28.937]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.937]                     next
[17:00:28.937]                   args[[name]] <- ""
[17:00:28.937]                 }
[17:00:28.937]                 NAMES <- toupper(removed)
[17:00:28.937]                 for (kk in seq_along(NAMES)) {
[17:00:28.937]                   name <- removed[[kk]]
[17:00:28.937]                   NAME <- NAMES[[kk]]
[17:00:28.937]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.937]                     next
[17:00:28.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.937]                 }
[17:00:28.937]                 if (length(args) > 0) 
[17:00:28.937]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.937]             }
[17:00:28.937]             else {
[17:00:28.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.937]             }
[17:00:28.937]             {
[17:00:28.937]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.937]                   0L) {
[17:00:28.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.937]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.937]                   base::options(opts)
[17:00:28.937]                 }
[17:00:28.937]                 {
[17:00:28.937]                   {
[17:00:28.937]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:28.937]                     NULL
[17:00:28.937]                   }
[17:00:28.937]                   options(future.plan = NULL)
[17:00:28.937]                   if (is.na(NA_character_)) 
[17:00:28.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.937]                     .init = FALSE)
[17:00:28.937]                 }
[17:00:28.937]             }
[17:00:28.937]         }
[17:00:28.937]     })
[17:00:28.937]     if (TRUE) {
[17:00:28.937]         base::sink(type = "output", split = FALSE)
[17:00:28.937]         if (TRUE) {
[17:00:28.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.937]         }
[17:00:28.937]         else {
[17:00:28.937]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.937]         }
[17:00:28.937]         base::close(...future.stdout)
[17:00:28.937]         ...future.stdout <- NULL
[17:00:28.937]     }
[17:00:28.937]     ...future.result$conditions <- ...future.conditions
[17:00:28.937]     ...future.result$finished <- base::Sys.time()
[17:00:28.937]     ...future.result
[17:00:28.937] }
[17:00:28.940] assign_globals() ...
[17:00:28.940] List of 5
[17:00:28.940]  $ ...future.FUN            :function (x, ...)  
[17:00:28.940]  $ MoreArgs                 : NULL
[17:00:28.940]  $ ...future.elements_ii    :List of 2
[17:00:28.940]   ..$ :List of 2
[17:00:28.940]   .. ..$ : int 1
[17:00:28.940]   .. ..$ : int 2
[17:00:28.940]   ..$ :List of 2
[17:00:28.940]   .. ..$ : int 4
[17:00:28.940]   .. ..$ : int 3
[17:00:28.940]  $ ...future.seeds_ii       : NULL
[17:00:28.940]  $ ...future.globals.maxSize: NULL
[17:00:28.940]  - attr(*, "where")=List of 5
[17:00:28.940]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.940]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.940]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.940]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.940]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.940]  - attr(*, "resolved")= logi FALSE
[17:00:28.940]  - attr(*, "total_size")= num 280
[17:00:28.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.940]  - attr(*, "already-done")= logi TRUE
[17:00:28.945] - copied ‘...future.FUN’ to environment
[17:00:28.945] - copied ‘MoreArgs’ to environment
[17:00:28.945] - copied ‘...future.elements_ii’ to environment
[17:00:28.946] - copied ‘...future.seeds_ii’ to environment
[17:00:28.946] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.946] assign_globals() ... done
[17:00:28.946] requestCore(): workers = 2
[17:00:28.949] MulticoreFuture started
[17:00:28.949] - Launch lazy future ... done
[17:00:28.950] plan(): Setting new future strategy stack:
[17:00:28.950] run() for ‘MulticoreFuture’ ... done
[17:00:28.950] Created future:
[17:00:28.950] List of future strategies:
[17:00:28.950] 1. sequential:
[17:00:28.950]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:28.950]    - tweaked: FALSE
[17:00:28.950]    - call: NULL
[17:00:28.951] plan(): nbrOfWorkers() = 1
[17:00:28.953] plan(): Setting new future strategy stack:
[17:00:28.953] List of future strategies:
[17:00:28.953] 1. multicore:
[17:00:28.953]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:28.953]    - tweaked: FALSE
[17:00:28.953]    - call: plan(strategy)
[17:00:28.950] MulticoreFuture:
[17:00:28.950] Label: ‘future_mapply-1’
[17:00:28.950] Expression:
[17:00:28.950] {
[17:00:28.950]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.950]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:28.950]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.950]         on.exit(options(oopts), add = TRUE)
[17:00:28.950]     }
[17:00:28.950]     {
[17:00:28.950]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.950]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:28.950]         do.call(mapply, args = args)
[17:00:28.950]     }
[17:00:28.950] }
[17:00:28.950] Lazy evaluation: FALSE
[17:00:28.950] Asynchronous evaluation: TRUE
[17:00:28.950] Local evaluation: TRUE
[17:00:28.950] Environment: R_GlobalEnv
[17:00:28.950] Capture standard output: TRUE
[17:00:28.950] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:28.950] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:28.950] Packages: <none>
[17:00:28.950] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:28.950] Resolved: FALSE
[17:00:28.950] Value: <not collected>
[17:00:28.950] Conditions captured: <none>
[17:00:28.950] Early signaling: FALSE
[17:00:28.950] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:28.950] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:28.965] Chunk #1 of 2 ... DONE
[17:00:28.965] plan(): nbrOfWorkers() = 2
[17:00:28.965] Chunk #2 of 2 ...
[17:00:28.965]  - Finding globals in '...' for chunk #2 ...
[17:00:28.965] getGlobalsAndPackages() ...
[17:00:28.965] Searching for globals...
[17:00:28.969] 
[17:00:28.969] Searching for globals ... DONE
[17:00:28.970] - globals: [0] <none>
[17:00:28.970] getGlobalsAndPackages() ... DONE
[17:00:28.970]    + additional globals found: [n=0] 
[17:00:28.970]    + additional namespaces needed: [n=0] 
[17:00:28.971]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:28.971]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:28.971]  - seeds: <none>
[17:00:28.972]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.972] getGlobalsAndPackages() ...
[17:00:28.972] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.973] Resolving globals: FALSE
[17:00:28.974] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:28.975] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:28.975] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:28.975] 
[17:00:28.975] getGlobalsAndPackages() ... DONE
[17:00:28.976] run() for ‘Future’ ...
[17:00:28.976] - state: ‘created’
[17:00:28.977] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:28.981] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:28.982] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:28.982]   - Field: ‘label’
[17:00:28.982]   - Field: ‘local’
[17:00:28.982]   - Field: ‘owner’
[17:00:28.982]   - Field: ‘envir’
[17:00:28.982]   - Field: ‘workers’
[17:00:28.983]   - Field: ‘packages’
[17:00:28.983]   - Field: ‘gc’
[17:00:28.983]   - Field: ‘job’
[17:00:28.983]   - Field: ‘conditions’
[17:00:28.983]   - Field: ‘expr’
[17:00:28.983]   - Field: ‘uuid’
[17:00:28.983]   - Field: ‘seed’
[17:00:28.984]   - Field: ‘version’
[17:00:28.984]   - Field: ‘result’
[17:00:28.984]   - Field: ‘asynchronous’
[17:00:28.984]   - Field: ‘calls’
[17:00:28.984]   - Field: ‘globals’
[17:00:28.984]   - Field: ‘stdout’
[17:00:28.985]   - Field: ‘earlySignal’
[17:00:28.985]   - Field: ‘lazy’
[17:00:28.985]   - Field: ‘state’
[17:00:28.985] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:28.985] - Launch lazy future ...
[17:00:28.986] Packages needed by the future expression (n = 0): <none>
[17:00:28.986] Packages needed by future strategies (n = 0): <none>
[17:00:28.986] {
[17:00:28.986]     {
[17:00:28.986]         {
[17:00:28.986]             ...future.startTime <- base::Sys.time()
[17:00:28.986]             {
[17:00:28.986]                 {
[17:00:28.986]                   {
[17:00:28.986]                     {
[17:00:28.986]                       base::local({
[17:00:28.986]                         has_future <- base::requireNamespace("future", 
[17:00:28.986]                           quietly = TRUE)
[17:00:28.986]                         if (has_future) {
[17:00:28.986]                           ns <- base::getNamespace("future")
[17:00:28.986]                           version <- ns[[".package"]][["version"]]
[17:00:28.986]                           if (is.null(version)) 
[17:00:28.986]                             version <- utils::packageVersion("future")
[17:00:28.986]                         }
[17:00:28.986]                         else {
[17:00:28.986]                           version <- NULL
[17:00:28.986]                         }
[17:00:28.986]                         if (!has_future || version < "1.8.0") {
[17:00:28.986]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:28.986]                             "", base::R.version$version.string), 
[17:00:28.986]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:28.986]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:28.986]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:28.986]                               "release", "version")], collapse = " "), 
[17:00:28.986]                             hostname = base::Sys.info()[["nodename"]])
[17:00:28.986]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:28.986]                             info)
[17:00:28.986]                           info <- base::paste(info, collapse = "; ")
[17:00:28.986]                           if (!has_future) {
[17:00:28.986]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:28.986]                               info)
[17:00:28.986]                           }
[17:00:28.986]                           else {
[17:00:28.986]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:28.986]                               info, version)
[17:00:28.986]                           }
[17:00:28.986]                           base::stop(msg)
[17:00:28.986]                         }
[17:00:28.986]                       })
[17:00:28.986]                     }
[17:00:28.986]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:28.986]                     base::options(mc.cores = 1L)
[17:00:28.986]                   }
[17:00:28.986]                   ...future.strategy.old <- future::plan("list")
[17:00:28.986]                   options(future.plan = NULL)
[17:00:28.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:28.986]                 }
[17:00:28.986]                 ...future.workdir <- getwd()
[17:00:28.986]             }
[17:00:28.986]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:28.986]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:28.986]         }
[17:00:28.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:28.986]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:28.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:28.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:28.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:28.986]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:28.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:28.986]             base::names(...future.oldOptions))
[17:00:28.986]     }
[17:00:28.986]     if (FALSE) {
[17:00:28.986]     }
[17:00:28.986]     else {
[17:00:28.986]         if (TRUE) {
[17:00:28.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:28.986]                 open = "w")
[17:00:28.986]         }
[17:00:28.986]         else {
[17:00:28.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:28.986]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:28.986]         }
[17:00:28.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:28.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:28.986]             base::sink(type = "output", split = FALSE)
[17:00:28.986]             base::close(...future.stdout)
[17:00:28.986]         }, add = TRUE)
[17:00:28.986]     }
[17:00:28.986]     ...future.frame <- base::sys.nframe()
[17:00:28.986]     ...future.conditions <- base::list()
[17:00:28.986]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:28.986]     if (FALSE) {
[17:00:28.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:28.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:28.986]     }
[17:00:28.986]     ...future.result <- base::tryCatch({
[17:00:28.986]         base::withCallingHandlers({
[17:00:28.986]             ...future.value <- base::withVisible(base::local({
[17:00:28.986]                 withCallingHandlers({
[17:00:28.986]                   {
[17:00:28.986]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:28.986]                     if (!identical(...future.globals.maxSize.org, 
[17:00:28.986]                       ...future.globals.maxSize)) {
[17:00:28.986]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:28.986]                       on.exit(options(oopts), add = TRUE)
[17:00:28.986]                     }
[17:00:28.986]                     {
[17:00:28.986]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:28.986]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:28.986]                         USE.NAMES = FALSE)
[17:00:28.986]                       do.call(mapply, args = args)
[17:00:28.986]                     }
[17:00:28.986]                   }
[17:00:28.986]                 }, immediateCondition = function(cond) {
[17:00:28.986]                   save_rds <- function (object, pathname, ...) 
[17:00:28.986]                   {
[17:00:28.986]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:28.986]                     if (file_test("-f", pathname_tmp)) {
[17:00:28.986]                       fi_tmp <- file.info(pathname_tmp)
[17:00:28.986]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:28.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:28.986]                         fi_tmp[["mtime"]])
[17:00:28.986]                     }
[17:00:28.986]                     tryCatch({
[17:00:28.986]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:28.986]                     }, error = function(ex) {
[17:00:28.986]                       msg <- conditionMessage(ex)
[17:00:28.986]                       fi_tmp <- file.info(pathname_tmp)
[17:00:28.986]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:28.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:28.986]                         fi_tmp[["mtime"]], msg)
[17:00:28.986]                       ex$message <- msg
[17:00:28.986]                       stop(ex)
[17:00:28.986]                     })
[17:00:28.986]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:28.986]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:28.986]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:28.986]                       fi_tmp <- file.info(pathname_tmp)
[17:00:28.986]                       fi <- file.info(pathname)
[17:00:28.986]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:28.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:28.986]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:28.986]                         fi[["size"]], fi[["mtime"]])
[17:00:28.986]                       stop(msg)
[17:00:28.986]                     }
[17:00:28.986]                     invisible(pathname)
[17:00:28.986]                   }
[17:00:28.986]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:28.986]                     rootPath = tempdir()) 
[17:00:28.986]                   {
[17:00:28.986]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:28.986]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:28.986]                       tmpdir = path, fileext = ".rds")
[17:00:28.986]                     save_rds(obj, file)
[17:00:28.986]                   }
[17:00:28.986]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:28.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.986]                   {
[17:00:28.986]                     inherits <- base::inherits
[17:00:28.986]                     invokeRestart <- base::invokeRestart
[17:00:28.986]                     is.null <- base::is.null
[17:00:28.986]                     muffled <- FALSE
[17:00:28.986]                     if (inherits(cond, "message")) {
[17:00:28.986]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:28.986]                       if (muffled) 
[17:00:28.986]                         invokeRestart("muffleMessage")
[17:00:28.986]                     }
[17:00:28.986]                     else if (inherits(cond, "warning")) {
[17:00:28.986]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:28.986]                       if (muffled) 
[17:00:28.986]                         invokeRestart("muffleWarning")
[17:00:28.986]                     }
[17:00:28.986]                     else if (inherits(cond, "condition")) {
[17:00:28.986]                       if (!is.null(pattern)) {
[17:00:28.986]                         computeRestarts <- base::computeRestarts
[17:00:28.986]                         grepl <- base::grepl
[17:00:28.986]                         restarts <- computeRestarts(cond)
[17:00:28.986]                         for (restart in restarts) {
[17:00:28.986]                           name <- restart$name
[17:00:28.986]                           if (is.null(name)) 
[17:00:28.986]                             next
[17:00:28.986]                           if (!grepl(pattern, name)) 
[17:00:28.986]                             next
[17:00:28.986]                           invokeRestart(restart)
[17:00:28.986]                           muffled <- TRUE
[17:00:28.986]                           break
[17:00:28.986]                         }
[17:00:28.986]                       }
[17:00:28.986]                     }
[17:00:28.986]                     invisible(muffled)
[17:00:28.986]                   }
[17:00:28.986]                   muffleCondition(cond)
[17:00:28.986]                 })
[17:00:28.986]             }))
[17:00:28.986]             future::FutureResult(value = ...future.value$value, 
[17:00:28.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.986]                   ...future.rng), globalenv = if (FALSE) 
[17:00:28.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:28.986]                     ...future.globalenv.names))
[17:00:28.986]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:28.986]         }, condition = base::local({
[17:00:28.986]             c <- base::c
[17:00:28.986]             inherits <- base::inherits
[17:00:28.986]             invokeRestart <- base::invokeRestart
[17:00:28.986]             length <- base::length
[17:00:28.986]             list <- base::list
[17:00:28.986]             seq.int <- base::seq.int
[17:00:28.986]             signalCondition <- base::signalCondition
[17:00:28.986]             sys.calls <- base::sys.calls
[17:00:28.986]             `[[` <- base::`[[`
[17:00:28.986]             `+` <- base::`+`
[17:00:28.986]             `<<-` <- base::`<<-`
[17:00:28.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:28.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:28.986]                   3L)]
[17:00:28.986]             }
[17:00:28.986]             function(cond) {
[17:00:28.986]                 is_error <- inherits(cond, "error")
[17:00:28.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:28.986]                   NULL)
[17:00:28.986]                 if (is_error) {
[17:00:28.986]                   sessionInformation <- function() {
[17:00:28.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:28.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:28.986]                       search = base::search(), system = base::Sys.info())
[17:00:28.986]                   }
[17:00:28.986]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:28.986]                     cond$call), session = sessionInformation(), 
[17:00:28.986]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:28.986]                   signalCondition(cond)
[17:00:28.986]                 }
[17:00:28.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:28.986]                 "immediateCondition"))) {
[17:00:28.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:28.986]                   ...future.conditions[[length(...future.conditions) + 
[17:00:28.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:28.986]                   if (TRUE && !signal) {
[17:00:28.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.986]                     {
[17:00:28.986]                       inherits <- base::inherits
[17:00:28.986]                       invokeRestart <- base::invokeRestart
[17:00:28.986]                       is.null <- base::is.null
[17:00:28.986]                       muffled <- FALSE
[17:00:28.986]                       if (inherits(cond, "message")) {
[17:00:28.986]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.986]                         if (muffled) 
[17:00:28.986]                           invokeRestart("muffleMessage")
[17:00:28.986]                       }
[17:00:28.986]                       else if (inherits(cond, "warning")) {
[17:00:28.986]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.986]                         if (muffled) 
[17:00:28.986]                           invokeRestart("muffleWarning")
[17:00:28.986]                       }
[17:00:28.986]                       else if (inherits(cond, "condition")) {
[17:00:28.986]                         if (!is.null(pattern)) {
[17:00:28.986]                           computeRestarts <- base::computeRestarts
[17:00:28.986]                           grepl <- base::grepl
[17:00:28.986]                           restarts <- computeRestarts(cond)
[17:00:28.986]                           for (restart in restarts) {
[17:00:28.986]                             name <- restart$name
[17:00:28.986]                             if (is.null(name)) 
[17:00:28.986]                               next
[17:00:28.986]                             if (!grepl(pattern, name)) 
[17:00:28.986]                               next
[17:00:28.986]                             invokeRestart(restart)
[17:00:28.986]                             muffled <- TRUE
[17:00:28.986]                             break
[17:00:28.986]                           }
[17:00:28.986]                         }
[17:00:28.986]                       }
[17:00:28.986]                       invisible(muffled)
[17:00:28.986]                     }
[17:00:28.986]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.986]                   }
[17:00:28.986]                 }
[17:00:28.986]                 else {
[17:00:28.986]                   if (TRUE) {
[17:00:28.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:28.986]                     {
[17:00:28.986]                       inherits <- base::inherits
[17:00:28.986]                       invokeRestart <- base::invokeRestart
[17:00:28.986]                       is.null <- base::is.null
[17:00:28.986]                       muffled <- FALSE
[17:00:28.986]                       if (inherits(cond, "message")) {
[17:00:28.986]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:28.986]                         if (muffled) 
[17:00:28.986]                           invokeRestart("muffleMessage")
[17:00:28.986]                       }
[17:00:28.986]                       else if (inherits(cond, "warning")) {
[17:00:28.986]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:28.986]                         if (muffled) 
[17:00:28.986]                           invokeRestart("muffleWarning")
[17:00:28.986]                       }
[17:00:28.986]                       else if (inherits(cond, "condition")) {
[17:00:28.986]                         if (!is.null(pattern)) {
[17:00:28.986]                           computeRestarts <- base::computeRestarts
[17:00:28.986]                           grepl <- base::grepl
[17:00:28.986]                           restarts <- computeRestarts(cond)
[17:00:28.986]                           for (restart in restarts) {
[17:00:28.986]                             name <- restart$name
[17:00:28.986]                             if (is.null(name)) 
[17:00:28.986]                               next
[17:00:28.986]                             if (!grepl(pattern, name)) 
[17:00:28.986]                               next
[17:00:28.986]                             invokeRestart(restart)
[17:00:28.986]                             muffled <- TRUE
[17:00:28.986]                             break
[17:00:28.986]                           }
[17:00:28.986]                         }
[17:00:28.986]                       }
[17:00:28.986]                       invisible(muffled)
[17:00:28.986]                     }
[17:00:28.986]                     muffleCondition(cond, pattern = "^muffle")
[17:00:28.986]                   }
[17:00:28.986]                 }
[17:00:28.986]             }
[17:00:28.986]         }))
[17:00:28.986]     }, error = function(ex) {
[17:00:28.986]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:28.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:28.986]                 ...future.rng), started = ...future.startTime, 
[17:00:28.986]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:28.986]             version = "1.8"), class = "FutureResult")
[17:00:28.986]     }, finally = {
[17:00:28.986]         if (!identical(...future.workdir, getwd())) 
[17:00:28.986]             setwd(...future.workdir)
[17:00:28.986]         {
[17:00:28.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:28.986]                 ...future.oldOptions$nwarnings <- NULL
[17:00:28.986]             }
[17:00:28.986]             base::options(...future.oldOptions)
[17:00:28.986]             if (.Platform$OS.type == "windows") {
[17:00:28.986]                 old_names <- names(...future.oldEnvVars)
[17:00:28.986]                 envs <- base::Sys.getenv()
[17:00:28.986]                 names <- names(envs)
[17:00:28.986]                 common <- intersect(names, old_names)
[17:00:28.986]                 added <- setdiff(names, old_names)
[17:00:28.986]                 removed <- setdiff(old_names, names)
[17:00:28.986]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:28.986]                   envs[common]]
[17:00:28.986]                 NAMES <- toupper(changed)
[17:00:28.986]                 args <- list()
[17:00:28.986]                 for (kk in seq_along(NAMES)) {
[17:00:28.986]                   name <- changed[[kk]]
[17:00:28.986]                   NAME <- NAMES[[kk]]
[17:00:28.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.986]                     next
[17:00:28.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.986]                 }
[17:00:28.986]                 NAMES <- toupper(added)
[17:00:28.986]                 for (kk in seq_along(NAMES)) {
[17:00:28.986]                   name <- added[[kk]]
[17:00:28.986]                   NAME <- NAMES[[kk]]
[17:00:28.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.986]                     next
[17:00:28.986]                   args[[name]] <- ""
[17:00:28.986]                 }
[17:00:28.986]                 NAMES <- toupper(removed)
[17:00:28.986]                 for (kk in seq_along(NAMES)) {
[17:00:28.986]                   name <- removed[[kk]]
[17:00:28.986]                   NAME <- NAMES[[kk]]
[17:00:28.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:28.986]                     next
[17:00:28.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:28.986]                 }
[17:00:28.986]                 if (length(args) > 0) 
[17:00:28.986]                   base::do.call(base::Sys.setenv, args = args)
[17:00:28.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:28.986]             }
[17:00:28.986]             else {
[17:00:28.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:28.986]             }
[17:00:28.986]             {
[17:00:28.986]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:28.986]                   0L) {
[17:00:28.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:28.986]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:28.986]                   base::options(opts)
[17:00:28.986]                 }
[17:00:28.986]                 {
[17:00:28.986]                   {
[17:00:28.986]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:28.986]                     NULL
[17:00:28.986]                   }
[17:00:28.986]                   options(future.plan = NULL)
[17:00:28.986]                   if (is.na(NA_character_)) 
[17:00:28.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:28.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:28.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:28.986]                     .init = FALSE)
[17:00:28.986]                 }
[17:00:28.986]             }
[17:00:28.986]         }
[17:00:28.986]     })
[17:00:28.986]     if (TRUE) {
[17:00:28.986]         base::sink(type = "output", split = FALSE)
[17:00:28.986]         if (TRUE) {
[17:00:28.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:28.986]         }
[17:00:28.986]         else {
[17:00:28.986]             ...future.result["stdout"] <- base::list(NULL)
[17:00:28.986]         }
[17:00:28.986]         base::close(...future.stdout)
[17:00:28.986]         ...future.stdout <- NULL
[17:00:28.986]     }
[17:00:28.986]     ...future.result$conditions <- ...future.conditions
[17:00:28.986]     ...future.result$finished <- base::Sys.time()
[17:00:28.986]     ...future.result
[17:00:28.986] }
[17:00:28.989] assign_globals() ...
[17:00:28.989] List of 5
[17:00:28.989]  $ ...future.FUN            :function (x, ...)  
[17:00:28.989]  $ MoreArgs                 : NULL
[17:00:28.989]  $ ...future.elements_ii    :List of 2
[17:00:28.989]   ..$ :List of 2
[17:00:28.989]   .. ..$ : int 3
[17:00:28.989]   .. ..$ : int 4
[17:00:28.989]   ..$ :List of 2
[17:00:28.989]   .. ..$ : int 2
[17:00:28.989]   .. ..$ : int 1
[17:00:28.989]  $ ...future.seeds_ii       : NULL
[17:00:28.989]  $ ...future.globals.maxSize: NULL
[17:00:28.989]  - attr(*, "where")=List of 5
[17:00:28.989]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:28.989]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:28.989]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:28.989]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:28.989]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:28.989]  - attr(*, "resolved")= logi FALSE
[17:00:28.989]  - attr(*, "total_size")= num 280
[17:00:28.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:28.989]  - attr(*, "already-done")= logi TRUE
[17:00:28.996] - copied ‘...future.FUN’ to environment
[17:00:28.996] - copied ‘MoreArgs’ to environment
[17:00:28.996] - copied ‘...future.elements_ii’ to environment
[17:00:28.996] - copied ‘...future.seeds_ii’ to environment
[17:00:28.997] - copied ‘...future.globals.maxSize’ to environment
[17:00:28.997] assign_globals() ... done
[17:00:28.997] requestCore(): workers = 2
[17:00:29.002] MulticoreFuture started
[17:00:29.002] - Launch lazy future ... done
[17:00:29.003] run() for ‘MulticoreFuture’ ... done
[17:00:29.003] Created future:
[17:00:29.003] plan(): Setting new future strategy stack:
[17:00:29.003] List of future strategies:
[17:00:29.003] 1. sequential:
[17:00:29.003]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.003]    - tweaked: FALSE
[17:00:29.003]    - call: NULL
[17:00:29.004] plan(): nbrOfWorkers() = 1
[17:00:29.007] plan(): Setting new future strategy stack:
[17:00:29.007] List of future strategies:
[17:00:29.007] 1. multicore:
[17:00:29.007]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.007]    - tweaked: FALSE
[17:00:29.007]    - call: plan(strategy)
[17:00:29.012] plan(): nbrOfWorkers() = 2
[17:00:29.003] MulticoreFuture:
[17:00:29.003] Label: ‘future_mapply-2’
[17:00:29.003] Expression:
[17:00:29.003] {
[17:00:29.003]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.003]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.003]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.003]         on.exit(options(oopts), add = TRUE)
[17:00:29.003]     }
[17:00:29.003]     {
[17:00:29.003]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.003]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.003]         do.call(mapply, args = args)
[17:00:29.003]     }
[17:00:29.003] }
[17:00:29.003] Lazy evaluation: FALSE
[17:00:29.003] Asynchronous evaluation: TRUE
[17:00:29.003] Local evaluation: TRUE
[17:00:29.003] Environment: R_GlobalEnv
[17:00:29.003] Capture standard output: TRUE
[17:00:29.003] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.003] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.003] Packages: <none>
[17:00:29.003] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.003] Resolved: TRUE
[17:00:29.003] Value: <not collected>
[17:00:29.003] Conditions captured: <none>
[17:00:29.003] Early signaling: FALSE
[17:00:29.003] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.003] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.013] Chunk #2 of 2 ... DONE
[17:00:29.013] Launching 2 futures (chunks) ... DONE
[17:00:29.013] Resolving 2 futures (chunks) ...
[17:00:29.013] resolve() on list ...
[17:00:29.014]  recursive: 0
[17:00:29.014]  length: 2
[17:00:29.014] 
[17:00:29.014] Future #1
[17:00:29.015] result() for MulticoreFuture ...
[17:00:29.017] result() for MulticoreFuture ...
[17:00:29.017] result() for MulticoreFuture ... done
[17:00:29.017] result() for MulticoreFuture ... done
[17:00:29.017] result() for MulticoreFuture ...
[17:00:29.017] result() for MulticoreFuture ... done
[17:00:29.018] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:29.018] - nx: 2
[17:00:29.018] - relay: TRUE
[17:00:29.018] - stdout: TRUE
[17:00:29.018] - signal: TRUE
[17:00:29.018] - resignal: FALSE
[17:00:29.018] - force: TRUE
[17:00:29.019] - relayed: [n=2] FALSE, FALSE
[17:00:29.019] - queued futures: [n=2] FALSE, FALSE
[17:00:29.019]  - until=1
[17:00:29.019]  - relaying element #1
[17:00:29.019] result() for MulticoreFuture ...
[17:00:29.019] result() for MulticoreFuture ... done
[17:00:29.023] result() for MulticoreFuture ...
[17:00:29.024] result() for MulticoreFuture ... done
[17:00:29.024] result() for MulticoreFuture ...
[17:00:29.024] result() for MulticoreFuture ... done
[17:00:29.025] result() for MulticoreFuture ...
[17:00:29.025] result() for MulticoreFuture ... done
[17:00:29.025] - relayed: [n=2] TRUE, FALSE
[17:00:29.026] - queued futures: [n=2] TRUE, FALSE
[17:00:29.026] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:29.027]  length: 1 (resolved future 1)
[17:00:29.027] Future #2
[17:00:29.027] result() for MulticoreFuture ...
[17:00:29.028] result() for MulticoreFuture ...
[17:00:29.029] result() for MulticoreFuture ... done
[17:00:29.029] result() for MulticoreFuture ... done
[17:00:29.029] result() for MulticoreFuture ...
[17:00:29.029] result() for MulticoreFuture ... done
[17:00:29.030] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:29.030] - nx: 2
[17:00:29.030] - relay: TRUE
[17:00:29.030] - stdout: TRUE
[17:00:29.030] - signal: TRUE
[17:00:29.030] - resignal: FALSE
[17:00:29.030] - force: TRUE
[17:00:29.031] - relayed: [n=2] TRUE, FALSE
[17:00:29.031] - queued futures: [n=2] TRUE, FALSE
[17:00:29.031]  - until=2
[17:00:29.031]  - relaying element #2
[17:00:29.031] result() for MulticoreFuture ...
[17:00:29.031] result() for MulticoreFuture ... done
[17:00:29.031] result() for MulticoreFuture ...
[17:00:29.032] result() for MulticoreFuture ... done
[17:00:29.032] result() for MulticoreFuture ...
[17:00:29.032] result() for MulticoreFuture ... done
[17:00:29.032] result() for MulticoreFuture ...
[17:00:29.032] result() for MulticoreFuture ... done
[17:00:29.032] - relayed: [n=2] TRUE, TRUE
[17:00:29.032] - queued futures: [n=2] TRUE, TRUE
[17:00:29.032] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:29.033]  length: 0 (resolved future 2)
[17:00:29.033] Relaying remaining futures
[17:00:29.033] signalConditionsASAP(NULL, pos=0) ...
[17:00:29.033] - nx: 2
[17:00:29.033] - relay: TRUE
[17:00:29.033] - stdout: TRUE
[17:00:29.033] - signal: TRUE
[17:00:29.033] - resignal: FALSE
[17:00:29.033] - force: TRUE
[17:00:29.033] - relayed: [n=2] TRUE, TRUE
[17:00:29.033] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:29.034] - relayed: [n=2] TRUE, TRUE
[17:00:29.034] - queued futures: [n=2] TRUE, TRUE
[17:00:29.034] signalConditionsASAP(NULL, pos=0) ... done
[17:00:29.034] resolve() on list ... DONE
[17:00:29.034] result() for MulticoreFuture ...
[17:00:29.034] result() for MulticoreFuture ... done
[17:00:29.034] result() for MulticoreFuture ...
[17:00:29.035] result() for MulticoreFuture ... done
[17:00:29.035] result() for MulticoreFuture ...
[17:00:29.035] result() for MulticoreFuture ... done
[17:00:29.035] result() for MulticoreFuture ...
[17:00:29.035] result() for MulticoreFuture ... done
[17:00:29.035]  - Number of value chunks collected: 2
[17:00:29.035] Resolving 2 futures (chunks) ... DONE
[17:00:29.035] Reducing values from 2 chunks ...
[17:00:29.035]  - Number of values collected after concatenation: 4
[17:00:29.036]  - Number of values expected: 4
[17:00:29.036] Reducing values from 2 chunks ... DONE
[17:00:29.036] future_mapply() ... DONE
[17:00:29.036] future_mapply() ...
[17:00:29.040] Number of chunks: 2
[17:00:29.040] getGlobalsAndPackagesXApply() ...
[17:00:29.041]  - future.globals: TRUE
[17:00:29.041] getGlobalsAndPackages() ...
[17:00:29.041] Searching for globals...
[17:00:29.041] - globals found: [1] ‘FUN’
[17:00:29.042] Searching for globals ... DONE
[17:00:29.042] Resolving globals: FALSE
[17:00:29.042] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:29.042] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:29.042] - globals: [1] ‘FUN’
[17:00:29.043] 
[17:00:29.043] getGlobalsAndPackages() ... DONE
[17:00:29.043]  - globals found/used: [n=1] ‘FUN’
[17:00:29.043]  - needed namespaces: [n=0] 
[17:00:29.043] Finding globals ... DONE
[17:00:29.043] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:29.043] List of 2
[17:00:29.043]  $ ...future.FUN:function (x, ...)  
[17:00:29.043]  $ MoreArgs     : NULL
[17:00:29.043]  - attr(*, "where")=List of 2
[17:00:29.043]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:29.043]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:29.043]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.043]  - attr(*, "resolved")= logi FALSE
[17:00:29.043]  - attr(*, "total_size")= num NA
[17:00:29.046] Packages to be attached in all futures: [n=0] 
[17:00:29.046] getGlobalsAndPackagesXApply() ... DONE
[17:00:29.046] Number of futures (= number of chunks): 2
[17:00:29.046] Launching 2 futures (chunks) ...
[17:00:29.047] Chunk #1 of 2 ...
[17:00:29.047]  - Finding globals in '...' for chunk #1 ...
[17:00:29.047] getGlobalsAndPackages() ...
[17:00:29.047] Searching for globals...
[17:00:29.047] 
[17:00:29.047] Searching for globals ... DONE
[17:00:29.048] - globals: [0] <none>
[17:00:29.048] getGlobalsAndPackages() ... DONE
[17:00:29.048]    + additional globals found: [n=0] 
[17:00:29.048]    + additional namespaces needed: [n=0] 
[17:00:29.048]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:29.048]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.048]  - seeds: <none>
[17:00:29.048]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.048] getGlobalsAndPackages() ...
[17:00:29.048] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.049] Resolving globals: FALSE
[17:00:29.049] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:29.050] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.050] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.050] 
[17:00:29.050] getGlobalsAndPackages() ... DONE
[17:00:29.050] run() for ‘Future’ ...
[17:00:29.050] - state: ‘created’
[17:00:29.050] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.054] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.054]   - Field: ‘label’
[17:00:29.054]   - Field: ‘local’
[17:00:29.055]   - Field: ‘owner’
[17:00:29.055]   - Field: ‘envir’
[17:00:29.055]   - Field: ‘workers’
[17:00:29.055]   - Field: ‘packages’
[17:00:29.055]   - Field: ‘gc’
[17:00:29.055]   - Field: ‘job’
[17:00:29.055]   - Field: ‘conditions’
[17:00:29.055]   - Field: ‘expr’
[17:00:29.055]   - Field: ‘uuid’
[17:00:29.055]   - Field: ‘seed’
[17:00:29.056]   - Field: ‘version’
[17:00:29.056]   - Field: ‘result’
[17:00:29.056]   - Field: ‘asynchronous’
[17:00:29.056]   - Field: ‘calls’
[17:00:29.056]   - Field: ‘globals’
[17:00:29.056]   - Field: ‘stdout’
[17:00:29.056]   - Field: ‘earlySignal’
[17:00:29.056]   - Field: ‘lazy’
[17:00:29.056]   - Field: ‘state’
[17:00:29.056] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.057] - Launch lazy future ...
[17:00:29.057] Packages needed by the future expression (n = 0): <none>
[17:00:29.057] Packages needed by future strategies (n = 0): <none>
[17:00:29.059] {
[17:00:29.059]     {
[17:00:29.059]         {
[17:00:29.059]             ...future.startTime <- base::Sys.time()
[17:00:29.059]             {
[17:00:29.059]                 {
[17:00:29.059]                   {
[17:00:29.059]                     {
[17:00:29.059]                       base::local({
[17:00:29.059]                         has_future <- base::requireNamespace("future", 
[17:00:29.059]                           quietly = TRUE)
[17:00:29.059]                         if (has_future) {
[17:00:29.059]                           ns <- base::getNamespace("future")
[17:00:29.059]                           version <- ns[[".package"]][["version"]]
[17:00:29.059]                           if (is.null(version)) 
[17:00:29.059]                             version <- utils::packageVersion("future")
[17:00:29.059]                         }
[17:00:29.059]                         else {
[17:00:29.059]                           version <- NULL
[17:00:29.059]                         }
[17:00:29.059]                         if (!has_future || version < "1.8.0") {
[17:00:29.059]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.059]                             "", base::R.version$version.string), 
[17:00:29.059]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.059]                               "release", "version")], collapse = " "), 
[17:00:29.059]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.059]                             info)
[17:00:29.059]                           info <- base::paste(info, collapse = "; ")
[17:00:29.059]                           if (!has_future) {
[17:00:29.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.059]                               info)
[17:00:29.059]                           }
[17:00:29.059]                           else {
[17:00:29.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.059]                               info, version)
[17:00:29.059]                           }
[17:00:29.059]                           base::stop(msg)
[17:00:29.059]                         }
[17:00:29.059]                       })
[17:00:29.059]                     }
[17:00:29.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.059]                     base::options(mc.cores = 1L)
[17:00:29.059]                   }
[17:00:29.059]                   ...future.strategy.old <- future::plan("list")
[17:00:29.059]                   options(future.plan = NULL)
[17:00:29.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.059]                 }
[17:00:29.059]                 ...future.workdir <- getwd()
[17:00:29.059]             }
[17:00:29.059]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.059]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.059]         }
[17:00:29.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.059]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.059]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.059]             base::names(...future.oldOptions))
[17:00:29.059]     }
[17:00:29.059]     if (FALSE) {
[17:00:29.059]     }
[17:00:29.059]     else {
[17:00:29.059]         if (TRUE) {
[17:00:29.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.059]                 open = "w")
[17:00:29.059]         }
[17:00:29.059]         else {
[17:00:29.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.059]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.059]         }
[17:00:29.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.059]             base::sink(type = "output", split = FALSE)
[17:00:29.059]             base::close(...future.stdout)
[17:00:29.059]         }, add = TRUE)
[17:00:29.059]     }
[17:00:29.059]     ...future.frame <- base::sys.nframe()
[17:00:29.059]     ...future.conditions <- base::list()
[17:00:29.059]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.059]     if (FALSE) {
[17:00:29.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.059]     }
[17:00:29.059]     ...future.result <- base::tryCatch({
[17:00:29.059]         base::withCallingHandlers({
[17:00:29.059]             ...future.value <- base::withVisible(base::local({
[17:00:29.059]                 withCallingHandlers({
[17:00:29.059]                   {
[17:00:29.059]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.059]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.059]                       ...future.globals.maxSize)) {
[17:00:29.059]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.059]                       on.exit(options(oopts), add = TRUE)
[17:00:29.059]                     }
[17:00:29.059]                     {
[17:00:29.059]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.059]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.059]                         USE.NAMES = FALSE)
[17:00:29.059]                       do.call(mapply, args = args)
[17:00:29.059]                     }
[17:00:29.059]                   }
[17:00:29.059]                 }, immediateCondition = function(cond) {
[17:00:29.059]                   save_rds <- function (object, pathname, ...) 
[17:00:29.059]                   {
[17:00:29.059]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.059]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.059]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.059]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.059]                         fi_tmp[["mtime"]])
[17:00:29.059]                     }
[17:00:29.059]                     tryCatch({
[17:00:29.059]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.059]                     }, error = function(ex) {
[17:00:29.059]                       msg <- conditionMessage(ex)
[17:00:29.059]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.059]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.059]                         fi_tmp[["mtime"]], msg)
[17:00:29.059]                       ex$message <- msg
[17:00:29.059]                       stop(ex)
[17:00:29.059]                     })
[17:00:29.059]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.059]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.059]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.059]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.059]                       fi <- file.info(pathname)
[17:00:29.059]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.059]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.059]                         fi[["size"]], fi[["mtime"]])
[17:00:29.059]                       stop(msg)
[17:00:29.059]                     }
[17:00:29.059]                     invisible(pathname)
[17:00:29.059]                   }
[17:00:29.059]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.059]                     rootPath = tempdir()) 
[17:00:29.059]                   {
[17:00:29.059]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.059]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.059]                       tmpdir = path, fileext = ".rds")
[17:00:29.059]                     save_rds(obj, file)
[17:00:29.059]                   }
[17:00:29.059]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.059]                   {
[17:00:29.059]                     inherits <- base::inherits
[17:00:29.059]                     invokeRestart <- base::invokeRestart
[17:00:29.059]                     is.null <- base::is.null
[17:00:29.059]                     muffled <- FALSE
[17:00:29.059]                     if (inherits(cond, "message")) {
[17:00:29.059]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.059]                       if (muffled) 
[17:00:29.059]                         invokeRestart("muffleMessage")
[17:00:29.059]                     }
[17:00:29.059]                     else if (inherits(cond, "warning")) {
[17:00:29.059]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.059]                       if (muffled) 
[17:00:29.059]                         invokeRestart("muffleWarning")
[17:00:29.059]                     }
[17:00:29.059]                     else if (inherits(cond, "condition")) {
[17:00:29.059]                       if (!is.null(pattern)) {
[17:00:29.059]                         computeRestarts <- base::computeRestarts
[17:00:29.059]                         grepl <- base::grepl
[17:00:29.059]                         restarts <- computeRestarts(cond)
[17:00:29.059]                         for (restart in restarts) {
[17:00:29.059]                           name <- restart$name
[17:00:29.059]                           if (is.null(name)) 
[17:00:29.059]                             next
[17:00:29.059]                           if (!grepl(pattern, name)) 
[17:00:29.059]                             next
[17:00:29.059]                           invokeRestart(restart)
[17:00:29.059]                           muffled <- TRUE
[17:00:29.059]                           break
[17:00:29.059]                         }
[17:00:29.059]                       }
[17:00:29.059]                     }
[17:00:29.059]                     invisible(muffled)
[17:00:29.059]                   }
[17:00:29.059]                   muffleCondition(cond)
[17:00:29.059]                 })
[17:00:29.059]             }))
[17:00:29.059]             future::FutureResult(value = ...future.value$value, 
[17:00:29.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.059]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.059]                     ...future.globalenv.names))
[17:00:29.059]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.059]         }, condition = base::local({
[17:00:29.059]             c <- base::c
[17:00:29.059]             inherits <- base::inherits
[17:00:29.059]             invokeRestart <- base::invokeRestart
[17:00:29.059]             length <- base::length
[17:00:29.059]             list <- base::list
[17:00:29.059]             seq.int <- base::seq.int
[17:00:29.059]             signalCondition <- base::signalCondition
[17:00:29.059]             sys.calls <- base::sys.calls
[17:00:29.059]             `[[` <- base::`[[`
[17:00:29.059]             `+` <- base::`+`
[17:00:29.059]             `<<-` <- base::`<<-`
[17:00:29.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.059]                   3L)]
[17:00:29.059]             }
[17:00:29.059]             function(cond) {
[17:00:29.059]                 is_error <- inherits(cond, "error")
[17:00:29.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.059]                   NULL)
[17:00:29.059]                 if (is_error) {
[17:00:29.059]                   sessionInformation <- function() {
[17:00:29.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.059]                       search = base::search(), system = base::Sys.info())
[17:00:29.059]                   }
[17:00:29.059]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.059]                     cond$call), session = sessionInformation(), 
[17:00:29.059]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.059]                   signalCondition(cond)
[17:00:29.059]                 }
[17:00:29.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.059]                 "immediateCondition"))) {
[17:00:29.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.059]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.059]                   if (TRUE && !signal) {
[17:00:29.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.059]                     {
[17:00:29.059]                       inherits <- base::inherits
[17:00:29.059]                       invokeRestart <- base::invokeRestart
[17:00:29.059]                       is.null <- base::is.null
[17:00:29.059]                       muffled <- FALSE
[17:00:29.059]                       if (inherits(cond, "message")) {
[17:00:29.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.059]                         if (muffled) 
[17:00:29.059]                           invokeRestart("muffleMessage")
[17:00:29.059]                       }
[17:00:29.059]                       else if (inherits(cond, "warning")) {
[17:00:29.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.059]                         if (muffled) 
[17:00:29.059]                           invokeRestart("muffleWarning")
[17:00:29.059]                       }
[17:00:29.059]                       else if (inherits(cond, "condition")) {
[17:00:29.059]                         if (!is.null(pattern)) {
[17:00:29.059]                           computeRestarts <- base::computeRestarts
[17:00:29.059]                           grepl <- base::grepl
[17:00:29.059]                           restarts <- computeRestarts(cond)
[17:00:29.059]                           for (restart in restarts) {
[17:00:29.059]                             name <- restart$name
[17:00:29.059]                             if (is.null(name)) 
[17:00:29.059]                               next
[17:00:29.059]                             if (!grepl(pattern, name)) 
[17:00:29.059]                               next
[17:00:29.059]                             invokeRestart(restart)
[17:00:29.059]                             muffled <- TRUE
[17:00:29.059]                             break
[17:00:29.059]                           }
[17:00:29.059]                         }
[17:00:29.059]                       }
[17:00:29.059]                       invisible(muffled)
[17:00:29.059]                     }
[17:00:29.059]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.059]                   }
[17:00:29.059]                 }
[17:00:29.059]                 else {
[17:00:29.059]                   if (TRUE) {
[17:00:29.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.059]                     {
[17:00:29.059]                       inherits <- base::inherits
[17:00:29.059]                       invokeRestart <- base::invokeRestart
[17:00:29.059]                       is.null <- base::is.null
[17:00:29.059]                       muffled <- FALSE
[17:00:29.059]                       if (inherits(cond, "message")) {
[17:00:29.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.059]                         if (muffled) 
[17:00:29.059]                           invokeRestart("muffleMessage")
[17:00:29.059]                       }
[17:00:29.059]                       else if (inherits(cond, "warning")) {
[17:00:29.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.059]                         if (muffled) 
[17:00:29.059]                           invokeRestart("muffleWarning")
[17:00:29.059]                       }
[17:00:29.059]                       else if (inherits(cond, "condition")) {
[17:00:29.059]                         if (!is.null(pattern)) {
[17:00:29.059]                           computeRestarts <- base::computeRestarts
[17:00:29.059]                           grepl <- base::grepl
[17:00:29.059]                           restarts <- computeRestarts(cond)
[17:00:29.059]                           for (restart in restarts) {
[17:00:29.059]                             name <- restart$name
[17:00:29.059]                             if (is.null(name)) 
[17:00:29.059]                               next
[17:00:29.059]                             if (!grepl(pattern, name)) 
[17:00:29.059]                               next
[17:00:29.059]                             invokeRestart(restart)
[17:00:29.059]                             muffled <- TRUE
[17:00:29.059]                             break
[17:00:29.059]                           }
[17:00:29.059]                         }
[17:00:29.059]                       }
[17:00:29.059]                       invisible(muffled)
[17:00:29.059]                     }
[17:00:29.059]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.059]                   }
[17:00:29.059]                 }
[17:00:29.059]             }
[17:00:29.059]         }))
[17:00:29.059]     }, error = function(ex) {
[17:00:29.059]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.059]                 ...future.rng), started = ...future.startTime, 
[17:00:29.059]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.059]             version = "1.8"), class = "FutureResult")
[17:00:29.059]     }, finally = {
[17:00:29.059]         if (!identical(...future.workdir, getwd())) 
[17:00:29.059]             setwd(...future.workdir)
[17:00:29.059]         {
[17:00:29.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.059]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.059]             }
[17:00:29.059]             base::options(...future.oldOptions)
[17:00:29.059]             if (.Platform$OS.type == "windows") {
[17:00:29.059]                 old_names <- names(...future.oldEnvVars)
[17:00:29.059]                 envs <- base::Sys.getenv()
[17:00:29.059]                 names <- names(envs)
[17:00:29.059]                 common <- intersect(names, old_names)
[17:00:29.059]                 added <- setdiff(names, old_names)
[17:00:29.059]                 removed <- setdiff(old_names, names)
[17:00:29.059]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.059]                   envs[common]]
[17:00:29.059]                 NAMES <- toupper(changed)
[17:00:29.059]                 args <- list()
[17:00:29.059]                 for (kk in seq_along(NAMES)) {
[17:00:29.059]                   name <- changed[[kk]]
[17:00:29.059]                   NAME <- NAMES[[kk]]
[17:00:29.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.059]                     next
[17:00:29.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.059]                 }
[17:00:29.059]                 NAMES <- toupper(added)
[17:00:29.059]                 for (kk in seq_along(NAMES)) {
[17:00:29.059]                   name <- added[[kk]]
[17:00:29.059]                   NAME <- NAMES[[kk]]
[17:00:29.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.059]                     next
[17:00:29.059]                   args[[name]] <- ""
[17:00:29.059]                 }
[17:00:29.059]                 NAMES <- toupper(removed)
[17:00:29.059]                 for (kk in seq_along(NAMES)) {
[17:00:29.059]                   name <- removed[[kk]]
[17:00:29.059]                   NAME <- NAMES[[kk]]
[17:00:29.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.059]                     next
[17:00:29.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.059]                 }
[17:00:29.059]                 if (length(args) > 0) 
[17:00:29.059]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.059]             }
[17:00:29.059]             else {
[17:00:29.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.059]             }
[17:00:29.059]             {
[17:00:29.059]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.059]                   0L) {
[17:00:29.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.059]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.059]                   base::options(opts)
[17:00:29.059]                 }
[17:00:29.059]                 {
[17:00:29.059]                   {
[17:00:29.059]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.059]                     NULL
[17:00:29.059]                   }
[17:00:29.059]                   options(future.plan = NULL)
[17:00:29.059]                   if (is.na(NA_character_)) 
[17:00:29.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.059]                     .init = FALSE)
[17:00:29.059]                 }
[17:00:29.059]             }
[17:00:29.059]         }
[17:00:29.059]     })
[17:00:29.059]     if (TRUE) {
[17:00:29.059]         base::sink(type = "output", split = FALSE)
[17:00:29.059]         if (TRUE) {
[17:00:29.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.059]         }
[17:00:29.059]         else {
[17:00:29.059]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.059]         }
[17:00:29.059]         base::close(...future.stdout)
[17:00:29.059]         ...future.stdout <- NULL
[17:00:29.059]     }
[17:00:29.059]     ...future.result$conditions <- ...future.conditions
[17:00:29.059]     ...future.result$finished <- base::Sys.time()
[17:00:29.059]     ...future.result
[17:00:29.059] }
[17:00:29.062] assign_globals() ...
[17:00:29.062] List of 5
[17:00:29.062]  $ ...future.FUN            :function (x, ...)  
[17:00:29.062]  $ MoreArgs                 : NULL
[17:00:29.062]  $ ...future.elements_ii    :List of 2
[17:00:29.062]   ..$ :List of 2
[17:00:29.062]   .. ..$ : int 1
[17:00:29.062]   .. ..$ : int 2
[17:00:29.062]   ..$ :List of 2
[17:00:29.062]   .. ..$ : int 4
[17:00:29.062]   .. ..$ : int 3
[17:00:29.062]  $ ...future.seeds_ii       : NULL
[17:00:29.062]  $ ...future.globals.maxSize: NULL
[17:00:29.062]  - attr(*, "where")=List of 5
[17:00:29.062]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.062]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.062]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.062]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.062]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.062]  - attr(*, "resolved")= logi FALSE
[17:00:29.062]  - attr(*, "total_size")= num 280
[17:00:29.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.062]  - attr(*, "already-done")= logi TRUE
[17:00:29.068] - copied ‘...future.FUN’ to environment
[17:00:29.068] - copied ‘MoreArgs’ to environment
[17:00:29.068] - copied ‘...future.elements_ii’ to environment
[17:00:29.068] - copied ‘...future.seeds_ii’ to environment
[17:00:29.069] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.069] assign_globals() ... done
[17:00:29.069] requestCore(): workers = 2
[17:00:29.071] MulticoreFuture started
[17:00:29.071] - Launch lazy future ... done
[17:00:29.072] run() for ‘MulticoreFuture’ ... done
[17:00:29.072] Created future:
[17:00:29.072] plan(): Setting new future strategy stack:
[17:00:29.072] List of future strategies:
[17:00:29.072] 1. sequential:
[17:00:29.072]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.072]    - tweaked: FALSE
[17:00:29.072]    - call: NULL
[17:00:29.073] plan(): nbrOfWorkers() = 1
[17:00:29.076] plan(): Setting new future strategy stack:
[17:00:29.076] List of future strategies:
[17:00:29.076] 1. multicore:
[17:00:29.076]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.076]    - tweaked: FALSE
[17:00:29.076]    - call: plan(strategy)
[17:00:29.081] plan(): nbrOfWorkers() = 2
[17:00:29.072] MulticoreFuture:
[17:00:29.072] Label: ‘future_mapply-1’
[17:00:29.072] Expression:
[17:00:29.072] {
[17:00:29.072]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.072]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.072]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.072]         on.exit(options(oopts), add = TRUE)
[17:00:29.072]     }
[17:00:29.072]     {
[17:00:29.072]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.072]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.072]         do.call(mapply, args = args)
[17:00:29.072]     }
[17:00:29.072] }
[17:00:29.072] Lazy evaluation: FALSE
[17:00:29.072] Asynchronous evaluation: TRUE
[17:00:29.072] Local evaluation: TRUE
[17:00:29.072] Environment: R_GlobalEnv
[17:00:29.072] Capture standard output: TRUE
[17:00:29.072] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.072] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.072] Packages: <none>
[17:00:29.072] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.072] Resolved: TRUE
[17:00:29.072] Value: <not collected>
[17:00:29.072] Conditions captured: <none>
[17:00:29.072] Early signaling: FALSE
[17:00:29.072] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.072] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.083] Chunk #1 of 2 ... DONE
[17:00:29.083] Chunk #2 of 2 ...
[17:00:29.083]  - Finding globals in '...' for chunk #2 ...
[17:00:29.083] getGlobalsAndPackages() ...
[17:00:29.083] Searching for globals...
[17:00:29.084] 
[17:00:29.084] Searching for globals ... DONE
[17:00:29.084] - globals: [0] <none>
[17:00:29.084] getGlobalsAndPackages() ... DONE
[17:00:29.084]    + additional globals found: [n=0] 
[17:00:29.085]    + additional namespaces needed: [n=0] 
[17:00:29.085]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:29.085]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.085]  - seeds: <none>
[17:00:29.085]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.085] getGlobalsAndPackages() ...
[17:00:29.085] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.086] Resolving globals: FALSE
[17:00:29.086] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:29.087] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.087] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.088] 
[17:00:29.088] getGlobalsAndPackages() ... DONE
[17:00:29.088] run() for ‘Future’ ...
[17:00:29.088] - state: ‘created’
[17:00:29.089] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.093] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.093] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.093]   - Field: ‘label’
[17:00:29.094]   - Field: ‘local’
[17:00:29.094]   - Field: ‘owner’
[17:00:29.094]   - Field: ‘envir’
[17:00:29.094]   - Field: ‘workers’
[17:00:29.094]   - Field: ‘packages’
[17:00:29.094]   - Field: ‘gc’
[17:00:29.094]   - Field: ‘job’
[17:00:29.095]   - Field: ‘conditions’
[17:00:29.095]   - Field: ‘expr’
[17:00:29.095]   - Field: ‘uuid’
[17:00:29.095]   - Field: ‘seed’
[17:00:29.095]   - Field: ‘version’
[17:00:29.095]   - Field: ‘result’
[17:00:29.095]   - Field: ‘asynchronous’
[17:00:29.096]   - Field: ‘calls’
[17:00:29.096]   - Field: ‘globals’
[17:00:29.096]   - Field: ‘stdout’
[17:00:29.096]   - Field: ‘earlySignal’
[17:00:29.096]   - Field: ‘lazy’
[17:00:29.096]   - Field: ‘state’
[17:00:29.097] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.097] - Launch lazy future ...
[17:00:29.097] Packages needed by the future expression (n = 0): <none>
[17:00:29.097] Packages needed by future strategies (n = 0): <none>
[17:00:29.098] {
[17:00:29.098]     {
[17:00:29.098]         {
[17:00:29.098]             ...future.startTime <- base::Sys.time()
[17:00:29.098]             {
[17:00:29.098]                 {
[17:00:29.098]                   {
[17:00:29.098]                     {
[17:00:29.098]                       base::local({
[17:00:29.098]                         has_future <- base::requireNamespace("future", 
[17:00:29.098]                           quietly = TRUE)
[17:00:29.098]                         if (has_future) {
[17:00:29.098]                           ns <- base::getNamespace("future")
[17:00:29.098]                           version <- ns[[".package"]][["version"]]
[17:00:29.098]                           if (is.null(version)) 
[17:00:29.098]                             version <- utils::packageVersion("future")
[17:00:29.098]                         }
[17:00:29.098]                         else {
[17:00:29.098]                           version <- NULL
[17:00:29.098]                         }
[17:00:29.098]                         if (!has_future || version < "1.8.0") {
[17:00:29.098]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.098]                             "", base::R.version$version.string), 
[17:00:29.098]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.098]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.098]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.098]                               "release", "version")], collapse = " "), 
[17:00:29.098]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.098]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.098]                             info)
[17:00:29.098]                           info <- base::paste(info, collapse = "; ")
[17:00:29.098]                           if (!has_future) {
[17:00:29.098]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.098]                               info)
[17:00:29.098]                           }
[17:00:29.098]                           else {
[17:00:29.098]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.098]                               info, version)
[17:00:29.098]                           }
[17:00:29.098]                           base::stop(msg)
[17:00:29.098]                         }
[17:00:29.098]                       })
[17:00:29.098]                     }
[17:00:29.098]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.098]                     base::options(mc.cores = 1L)
[17:00:29.098]                   }
[17:00:29.098]                   ...future.strategy.old <- future::plan("list")
[17:00:29.098]                   options(future.plan = NULL)
[17:00:29.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.098]                 }
[17:00:29.098]                 ...future.workdir <- getwd()
[17:00:29.098]             }
[17:00:29.098]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.098]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.098]         }
[17:00:29.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.098]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.098]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.098]             base::names(...future.oldOptions))
[17:00:29.098]     }
[17:00:29.098]     if (FALSE) {
[17:00:29.098]     }
[17:00:29.098]     else {
[17:00:29.098]         if (TRUE) {
[17:00:29.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.098]                 open = "w")
[17:00:29.098]         }
[17:00:29.098]         else {
[17:00:29.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.098]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.098]         }
[17:00:29.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.098]             base::sink(type = "output", split = FALSE)
[17:00:29.098]             base::close(...future.stdout)
[17:00:29.098]         }, add = TRUE)
[17:00:29.098]     }
[17:00:29.098]     ...future.frame <- base::sys.nframe()
[17:00:29.098]     ...future.conditions <- base::list()
[17:00:29.098]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.098]     if (FALSE) {
[17:00:29.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.098]     }
[17:00:29.098]     ...future.result <- base::tryCatch({
[17:00:29.098]         base::withCallingHandlers({
[17:00:29.098]             ...future.value <- base::withVisible(base::local({
[17:00:29.098]                 withCallingHandlers({
[17:00:29.098]                   {
[17:00:29.098]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.098]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.098]                       ...future.globals.maxSize)) {
[17:00:29.098]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.098]                       on.exit(options(oopts), add = TRUE)
[17:00:29.098]                     }
[17:00:29.098]                     {
[17:00:29.098]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.098]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.098]                         USE.NAMES = FALSE)
[17:00:29.098]                       do.call(mapply, args = args)
[17:00:29.098]                     }
[17:00:29.098]                   }
[17:00:29.098]                 }, immediateCondition = function(cond) {
[17:00:29.098]                   save_rds <- function (object, pathname, ...) 
[17:00:29.098]                   {
[17:00:29.098]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.098]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.098]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.098]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.098]                         fi_tmp[["mtime"]])
[17:00:29.098]                     }
[17:00:29.098]                     tryCatch({
[17:00:29.098]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.098]                     }, error = function(ex) {
[17:00:29.098]                       msg <- conditionMessage(ex)
[17:00:29.098]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.098]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.098]                         fi_tmp[["mtime"]], msg)
[17:00:29.098]                       ex$message <- msg
[17:00:29.098]                       stop(ex)
[17:00:29.098]                     })
[17:00:29.098]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.098]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.098]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.098]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.098]                       fi <- file.info(pathname)
[17:00:29.098]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.098]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.098]                         fi[["size"]], fi[["mtime"]])
[17:00:29.098]                       stop(msg)
[17:00:29.098]                     }
[17:00:29.098]                     invisible(pathname)
[17:00:29.098]                   }
[17:00:29.098]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.098]                     rootPath = tempdir()) 
[17:00:29.098]                   {
[17:00:29.098]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.098]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.098]                       tmpdir = path, fileext = ".rds")
[17:00:29.098]                     save_rds(obj, file)
[17:00:29.098]                   }
[17:00:29.098]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.098]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.098]                   {
[17:00:29.098]                     inherits <- base::inherits
[17:00:29.098]                     invokeRestart <- base::invokeRestart
[17:00:29.098]                     is.null <- base::is.null
[17:00:29.098]                     muffled <- FALSE
[17:00:29.098]                     if (inherits(cond, "message")) {
[17:00:29.098]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.098]                       if (muffled) 
[17:00:29.098]                         invokeRestart("muffleMessage")
[17:00:29.098]                     }
[17:00:29.098]                     else if (inherits(cond, "warning")) {
[17:00:29.098]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.098]                       if (muffled) 
[17:00:29.098]                         invokeRestart("muffleWarning")
[17:00:29.098]                     }
[17:00:29.098]                     else if (inherits(cond, "condition")) {
[17:00:29.098]                       if (!is.null(pattern)) {
[17:00:29.098]                         computeRestarts <- base::computeRestarts
[17:00:29.098]                         grepl <- base::grepl
[17:00:29.098]                         restarts <- computeRestarts(cond)
[17:00:29.098]                         for (restart in restarts) {
[17:00:29.098]                           name <- restart$name
[17:00:29.098]                           if (is.null(name)) 
[17:00:29.098]                             next
[17:00:29.098]                           if (!grepl(pattern, name)) 
[17:00:29.098]                             next
[17:00:29.098]                           invokeRestart(restart)
[17:00:29.098]                           muffled <- TRUE
[17:00:29.098]                           break
[17:00:29.098]                         }
[17:00:29.098]                       }
[17:00:29.098]                     }
[17:00:29.098]                     invisible(muffled)
[17:00:29.098]                   }
[17:00:29.098]                   muffleCondition(cond)
[17:00:29.098]                 })
[17:00:29.098]             }))
[17:00:29.098]             future::FutureResult(value = ...future.value$value, 
[17:00:29.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.098]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.098]                     ...future.globalenv.names))
[17:00:29.098]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.098]         }, condition = base::local({
[17:00:29.098]             c <- base::c
[17:00:29.098]             inherits <- base::inherits
[17:00:29.098]             invokeRestart <- base::invokeRestart
[17:00:29.098]             length <- base::length
[17:00:29.098]             list <- base::list
[17:00:29.098]             seq.int <- base::seq.int
[17:00:29.098]             signalCondition <- base::signalCondition
[17:00:29.098]             sys.calls <- base::sys.calls
[17:00:29.098]             `[[` <- base::`[[`
[17:00:29.098]             `+` <- base::`+`
[17:00:29.098]             `<<-` <- base::`<<-`
[17:00:29.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.098]                   3L)]
[17:00:29.098]             }
[17:00:29.098]             function(cond) {
[17:00:29.098]                 is_error <- inherits(cond, "error")
[17:00:29.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.098]                   NULL)
[17:00:29.098]                 if (is_error) {
[17:00:29.098]                   sessionInformation <- function() {
[17:00:29.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.098]                       search = base::search(), system = base::Sys.info())
[17:00:29.098]                   }
[17:00:29.098]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.098]                     cond$call), session = sessionInformation(), 
[17:00:29.098]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.098]                   signalCondition(cond)
[17:00:29.098]                 }
[17:00:29.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.098]                 "immediateCondition"))) {
[17:00:29.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.098]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.098]                   if (TRUE && !signal) {
[17:00:29.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.098]                     {
[17:00:29.098]                       inherits <- base::inherits
[17:00:29.098]                       invokeRestart <- base::invokeRestart
[17:00:29.098]                       is.null <- base::is.null
[17:00:29.098]                       muffled <- FALSE
[17:00:29.098]                       if (inherits(cond, "message")) {
[17:00:29.098]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.098]                         if (muffled) 
[17:00:29.098]                           invokeRestart("muffleMessage")
[17:00:29.098]                       }
[17:00:29.098]                       else if (inherits(cond, "warning")) {
[17:00:29.098]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.098]                         if (muffled) 
[17:00:29.098]                           invokeRestart("muffleWarning")
[17:00:29.098]                       }
[17:00:29.098]                       else if (inherits(cond, "condition")) {
[17:00:29.098]                         if (!is.null(pattern)) {
[17:00:29.098]                           computeRestarts <- base::computeRestarts
[17:00:29.098]                           grepl <- base::grepl
[17:00:29.098]                           restarts <- computeRestarts(cond)
[17:00:29.098]                           for (restart in restarts) {
[17:00:29.098]                             name <- restart$name
[17:00:29.098]                             if (is.null(name)) 
[17:00:29.098]                               next
[17:00:29.098]                             if (!grepl(pattern, name)) 
[17:00:29.098]                               next
[17:00:29.098]                             invokeRestart(restart)
[17:00:29.098]                             muffled <- TRUE
[17:00:29.098]                             break
[17:00:29.098]                           }
[17:00:29.098]                         }
[17:00:29.098]                       }
[17:00:29.098]                       invisible(muffled)
[17:00:29.098]                     }
[17:00:29.098]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.098]                   }
[17:00:29.098]                 }
[17:00:29.098]                 else {
[17:00:29.098]                   if (TRUE) {
[17:00:29.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.098]                     {
[17:00:29.098]                       inherits <- base::inherits
[17:00:29.098]                       invokeRestart <- base::invokeRestart
[17:00:29.098]                       is.null <- base::is.null
[17:00:29.098]                       muffled <- FALSE
[17:00:29.098]                       if (inherits(cond, "message")) {
[17:00:29.098]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.098]                         if (muffled) 
[17:00:29.098]                           invokeRestart("muffleMessage")
[17:00:29.098]                       }
[17:00:29.098]                       else if (inherits(cond, "warning")) {
[17:00:29.098]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.098]                         if (muffled) 
[17:00:29.098]                           invokeRestart("muffleWarning")
[17:00:29.098]                       }
[17:00:29.098]                       else if (inherits(cond, "condition")) {
[17:00:29.098]                         if (!is.null(pattern)) {
[17:00:29.098]                           computeRestarts <- base::computeRestarts
[17:00:29.098]                           grepl <- base::grepl
[17:00:29.098]                           restarts <- computeRestarts(cond)
[17:00:29.098]                           for (restart in restarts) {
[17:00:29.098]                             name <- restart$name
[17:00:29.098]                             if (is.null(name)) 
[17:00:29.098]                               next
[17:00:29.098]                             if (!grepl(pattern, name)) 
[17:00:29.098]                               next
[17:00:29.098]                             invokeRestart(restart)
[17:00:29.098]                             muffled <- TRUE
[17:00:29.098]                             break
[17:00:29.098]                           }
[17:00:29.098]                         }
[17:00:29.098]                       }
[17:00:29.098]                       invisible(muffled)
[17:00:29.098]                     }
[17:00:29.098]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.098]                   }
[17:00:29.098]                 }
[17:00:29.098]             }
[17:00:29.098]         }))
[17:00:29.098]     }, error = function(ex) {
[17:00:29.098]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.098]                 ...future.rng), started = ...future.startTime, 
[17:00:29.098]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.098]             version = "1.8"), class = "FutureResult")
[17:00:29.098]     }, finally = {
[17:00:29.098]         if (!identical(...future.workdir, getwd())) 
[17:00:29.098]             setwd(...future.workdir)
[17:00:29.098]         {
[17:00:29.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.098]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.098]             }
[17:00:29.098]             base::options(...future.oldOptions)
[17:00:29.098]             if (.Platform$OS.type == "windows") {
[17:00:29.098]                 old_names <- names(...future.oldEnvVars)
[17:00:29.098]                 envs <- base::Sys.getenv()
[17:00:29.098]                 names <- names(envs)
[17:00:29.098]                 common <- intersect(names, old_names)
[17:00:29.098]                 added <- setdiff(names, old_names)
[17:00:29.098]                 removed <- setdiff(old_names, names)
[17:00:29.098]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.098]                   envs[common]]
[17:00:29.098]                 NAMES <- toupper(changed)
[17:00:29.098]                 args <- list()
[17:00:29.098]                 for (kk in seq_along(NAMES)) {
[17:00:29.098]                   name <- changed[[kk]]
[17:00:29.098]                   NAME <- NAMES[[kk]]
[17:00:29.098]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.098]                     next
[17:00:29.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.098]                 }
[17:00:29.098]                 NAMES <- toupper(added)
[17:00:29.098]                 for (kk in seq_along(NAMES)) {
[17:00:29.098]                   name <- added[[kk]]
[17:00:29.098]                   NAME <- NAMES[[kk]]
[17:00:29.098]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.098]                     next
[17:00:29.098]                   args[[name]] <- ""
[17:00:29.098]                 }
[17:00:29.098]                 NAMES <- toupper(removed)
[17:00:29.098]                 for (kk in seq_along(NAMES)) {
[17:00:29.098]                   name <- removed[[kk]]
[17:00:29.098]                   NAME <- NAMES[[kk]]
[17:00:29.098]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.098]                     next
[17:00:29.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.098]                 }
[17:00:29.098]                 if (length(args) > 0) 
[17:00:29.098]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.098]             }
[17:00:29.098]             else {
[17:00:29.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.098]             }
[17:00:29.098]             {
[17:00:29.098]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.098]                   0L) {
[17:00:29.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.098]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.098]                   base::options(opts)
[17:00:29.098]                 }
[17:00:29.098]                 {
[17:00:29.098]                   {
[17:00:29.098]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.098]                     NULL
[17:00:29.098]                   }
[17:00:29.098]                   options(future.plan = NULL)
[17:00:29.098]                   if (is.na(NA_character_)) 
[17:00:29.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.098]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.098]                     .init = FALSE)
[17:00:29.098]                 }
[17:00:29.098]             }
[17:00:29.098]         }
[17:00:29.098]     })
[17:00:29.098]     if (TRUE) {
[17:00:29.098]         base::sink(type = "output", split = FALSE)
[17:00:29.098]         if (TRUE) {
[17:00:29.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.098]         }
[17:00:29.098]         else {
[17:00:29.098]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.098]         }
[17:00:29.098]         base::close(...future.stdout)
[17:00:29.098]         ...future.stdout <- NULL
[17:00:29.098]     }
[17:00:29.098]     ...future.result$conditions <- ...future.conditions
[17:00:29.098]     ...future.result$finished <- base::Sys.time()
[17:00:29.098]     ...future.result
[17:00:29.098] }
[17:00:29.102] assign_globals() ...
[17:00:29.102] List of 5
[17:00:29.102]  $ ...future.FUN            :function (x, ...)  
[17:00:29.102]  $ MoreArgs                 : NULL
[17:00:29.102]  $ ...future.elements_ii    :List of 2
[17:00:29.102]   ..$ :List of 2
[17:00:29.102]   .. ..$ : int 3
[17:00:29.102]   .. ..$ : int 4
[17:00:29.102]   ..$ :List of 2
[17:00:29.102]   .. ..$ : int 2
[17:00:29.102]   .. ..$ : int 1
[17:00:29.102]  $ ...future.seeds_ii       : NULL
[17:00:29.102]  $ ...future.globals.maxSize: NULL
[17:00:29.102]  - attr(*, "where")=List of 5
[17:00:29.102]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.102]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.102]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.102]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.102]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.102]  - attr(*, "resolved")= logi FALSE
[17:00:29.102]  - attr(*, "total_size")= num 280
[17:00:29.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.102]  - attr(*, "already-done")= logi TRUE
[17:00:29.115] - copied ‘...future.FUN’ to environment
[17:00:29.115] - copied ‘MoreArgs’ to environment
[17:00:29.115] - copied ‘...future.elements_ii’ to environment
[17:00:29.116] - copied ‘...future.seeds_ii’ to environment
[17:00:29.116] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.116] assign_globals() ... done
[17:00:29.116] requestCore(): workers = 2
[17:00:29.118] MulticoreFuture started
[17:00:29.119] - Launch lazy future ... done
[17:00:29.119] run() for ‘MulticoreFuture’ ... done
[17:00:29.120] plan(): Setting new future strategy stack:
[17:00:29.120] Created future:
[17:00:29.120] List of future strategies:
[17:00:29.120] 1. sequential:
[17:00:29.120]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.120]    - tweaked: FALSE
[17:00:29.120]    - call: NULL
[17:00:29.121] plan(): nbrOfWorkers() = 1
[17:00:29.124] plan(): Setting new future strategy stack:
[17:00:29.124] List of future strategies:
[17:00:29.124] 1. multicore:
[17:00:29.124]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.124]    - tweaked: FALSE
[17:00:29.124]    - call: plan(strategy)
[17:00:29.130] plan(): nbrOfWorkers() = 2
[17:00:29.120] MulticoreFuture:
[17:00:29.120] Label: ‘future_mapply-2’
[17:00:29.120] Expression:
[17:00:29.120] {
[17:00:29.120]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.120]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.120]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.120]         on.exit(options(oopts), add = TRUE)
[17:00:29.120]     }
[17:00:29.120]     {
[17:00:29.120]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.120]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.120]         do.call(mapply, args = args)
[17:00:29.120]     }
[17:00:29.120] }
[17:00:29.120] Lazy evaluation: FALSE
[17:00:29.120] Asynchronous evaluation: TRUE
[17:00:29.120] Local evaluation: TRUE
[17:00:29.120] Environment: R_GlobalEnv
[17:00:29.120] Capture standard output: TRUE
[17:00:29.120] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.120] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.120] Packages: <none>
[17:00:29.120] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.120] Resolved: TRUE
[17:00:29.120] Value: <not collected>
[17:00:29.120] Conditions captured: <none>
[17:00:29.120] Early signaling: FALSE
[17:00:29.120] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.120] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.131] Chunk #2 of 2 ... DONE
[17:00:29.132] Launching 2 futures (chunks) ... DONE
[17:00:29.132] Resolving 2 futures (chunks) ...
[17:00:29.132] resolve() on list ...
[17:00:29.132]  recursive: 0
[17:00:29.132]  length: 2
[17:00:29.132] 
[17:00:29.133] Future #1
[17:00:29.133] result() for MulticoreFuture ...
[17:00:29.134] result() for MulticoreFuture ...
[17:00:29.134] result() for MulticoreFuture ... done
[17:00:29.134] result() for MulticoreFuture ... done
[17:00:29.134] result() for MulticoreFuture ...
[17:00:29.135] result() for MulticoreFuture ... done
[17:00:29.135] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:29.135] - nx: 2
[17:00:29.135] - relay: TRUE
[17:00:29.135] - stdout: TRUE
[17:00:29.135] - signal: TRUE
[17:00:29.136] - resignal: FALSE
[17:00:29.136] - force: TRUE
[17:00:29.136] - relayed: [n=2] FALSE, FALSE
[17:00:29.136] - queued futures: [n=2] FALSE, FALSE
[17:00:29.136]  - until=1
[17:00:29.137]  - relaying element #1
[17:00:29.137] result() for MulticoreFuture ...
[17:00:29.137] result() for MulticoreFuture ... done
[17:00:29.137] result() for MulticoreFuture ...
[17:00:29.137] result() for MulticoreFuture ... done
[17:00:29.137] result() for MulticoreFuture ...
[17:00:29.138] result() for MulticoreFuture ... done
[17:00:29.138] result() for MulticoreFuture ...
[17:00:29.138] result() for MulticoreFuture ... done
[17:00:29.138] - relayed: [n=2] TRUE, FALSE
[17:00:29.138] - queued futures: [n=2] TRUE, FALSE
[17:00:29.138] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:29.138]  length: 1 (resolved future 1)
[17:00:29.139] Future #2
[17:00:29.139] result() for MulticoreFuture ...
[17:00:29.140] result() for MulticoreFuture ...
[17:00:29.140] result() for MulticoreFuture ... done
[17:00:29.140] result() for MulticoreFuture ... done
[17:00:29.140] result() for MulticoreFuture ...
[17:00:29.140] result() for MulticoreFuture ... done
[17:00:29.140] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:29.140] - nx: 2
[17:00:29.141] - relay: TRUE
[17:00:29.141] - stdout: TRUE
[17:00:29.141] - signal: TRUE
[17:00:29.141] - resignal: FALSE
[17:00:29.141] - force: TRUE
[17:00:29.141] - relayed: [n=2] TRUE, FALSE
[17:00:29.141] - queued futures: [n=2] TRUE, FALSE
[17:00:29.141]  - until=2
[17:00:29.142]  - relaying element #2
[17:00:29.142] result() for MulticoreFuture ...
[17:00:29.142] result() for MulticoreFuture ... done
[17:00:29.142] result() for MulticoreFuture ...
[17:00:29.142] result() for MulticoreFuture ... done
[17:00:29.142] result() for MulticoreFuture ...
[17:00:29.142] result() for MulticoreFuture ... done
[17:00:29.142] result() for MulticoreFuture ...
[17:00:29.142] result() for MulticoreFuture ... done
[17:00:29.143] - relayed: [n=2] TRUE, TRUE
[17:00:29.143] - queued futures: [n=2] TRUE, TRUE
[17:00:29.143] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:29.143]  length: 0 (resolved future 2)
[17:00:29.143] Relaying remaining futures
[17:00:29.143] signalConditionsASAP(NULL, pos=0) ...
[17:00:29.143] - nx: 2
[17:00:29.143] - relay: TRUE
[17:00:29.143] - stdout: TRUE
[17:00:29.144] - signal: TRUE
[17:00:29.144] - resignal: FALSE
[17:00:29.144] - force: TRUE
[17:00:29.144] - relayed: [n=2] TRUE, TRUE
[17:00:29.144] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:29.144] - relayed: [n=2] TRUE, TRUE
[17:00:29.144] - queued futures: [n=2] TRUE, TRUE
[17:00:29.144] signalConditionsASAP(NULL, pos=0) ... done
[17:00:29.145] resolve() on list ... DONE
[17:00:29.145] result() for MulticoreFuture ...
[17:00:29.145] result() for MulticoreFuture ... done
[17:00:29.145] result() for MulticoreFuture ...
[17:00:29.145] result() for MulticoreFuture ... done
[17:00:29.145] result() for MulticoreFuture ...
[17:00:29.145] result() for MulticoreFuture ... done
[17:00:29.145] result() for MulticoreFuture ...
[17:00:29.145] result() for MulticoreFuture ... done
[17:00:29.146]  - Number of value chunks collected: 2
[17:00:29.146] Resolving 2 futures (chunks) ... DONE
[17:00:29.146] Reducing values from 2 chunks ...
[17:00:29.146]  - Number of values collected after concatenation: 4
[17:00:29.146]  - Number of values expected: 4
[17:00:29.146] Reducing values from 2 chunks ... DONE
[17:00:29.146] future_mapply() ... DONE
[17:00:29.146] future_mapply() ...
[17:00:29.151] Number of chunks: 2
[17:00:29.151] getGlobalsAndPackagesXApply() ...
[17:00:29.151]  - future.globals: TRUE
[17:00:29.151] getGlobalsAndPackages() ...
[17:00:29.151] Searching for globals...
[17:00:29.152] - globals found: [1] ‘FUN’
[17:00:29.152] Searching for globals ... DONE
[17:00:29.152] Resolving globals: FALSE
[17:00:29.153] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:29.153] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:29.153] - globals: [1] ‘FUN’
[17:00:29.153] 
[17:00:29.154] getGlobalsAndPackages() ... DONE
[17:00:29.154]  - globals found/used: [n=1] ‘FUN’
[17:00:29.154]  - needed namespaces: [n=0] 
[17:00:29.154] Finding globals ... DONE
[17:00:29.154] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:29.154] List of 2
[17:00:29.154]  $ ...future.FUN:function (x, ...)  
[17:00:29.154]  $ MoreArgs     : NULL
[17:00:29.154]  - attr(*, "where")=List of 2
[17:00:29.154]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:29.154]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:29.154]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.154]  - attr(*, "resolved")= logi FALSE
[17:00:29.154]  - attr(*, "total_size")= num NA
[17:00:29.157] Packages to be attached in all futures: [n=0] 
[17:00:29.158] getGlobalsAndPackagesXApply() ... DONE
[17:00:29.158] Number of futures (= number of chunks): 2
[17:00:29.158] Launching 2 futures (chunks) ...
[17:00:29.158] Chunk #1 of 2 ...
[17:00:29.160]  - Finding globals in '...' for chunk #1 ...
[17:00:29.160] getGlobalsAndPackages() ...
[17:00:29.160] Searching for globals...
[17:00:29.161] 
[17:00:29.161] Searching for globals ... DONE
[17:00:29.161] - globals: [0] <none>
[17:00:29.161] getGlobalsAndPackages() ... DONE
[17:00:29.161]    + additional globals found: [n=0] 
[17:00:29.162]    + additional namespaces needed: [n=0] 
[17:00:29.162]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:29.162]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.162]  - seeds: <none>
[17:00:29.162]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.162] getGlobalsAndPackages() ...
[17:00:29.162] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.163] Resolving globals: FALSE
[17:00:29.163] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:29.164] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.164] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.164] 
[17:00:29.164] getGlobalsAndPackages() ... DONE
[17:00:29.165] run() for ‘Future’ ...
[17:00:29.165] - state: ‘created’
[17:00:29.165] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.169] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.169] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.169]   - Field: ‘label’
[17:00:29.169]   - Field: ‘local’
[17:00:29.169]   - Field: ‘owner’
[17:00:29.169]   - Field: ‘envir’
[17:00:29.169]   - Field: ‘workers’
[17:00:29.169]   - Field: ‘packages’
[17:00:29.169]   - Field: ‘gc’
[17:00:29.169]   - Field: ‘job’
[17:00:29.170]   - Field: ‘conditions’
[17:00:29.170]   - Field: ‘expr’
[17:00:29.170]   - Field: ‘uuid’
[17:00:29.170]   - Field: ‘seed’
[17:00:29.170]   - Field: ‘version’
[17:00:29.170]   - Field: ‘result’
[17:00:29.170]   - Field: ‘asynchronous’
[17:00:29.170]   - Field: ‘calls’
[17:00:29.170]   - Field: ‘globals’
[17:00:29.170]   - Field: ‘stdout’
[17:00:29.170]   - Field: ‘earlySignal’
[17:00:29.171]   - Field: ‘lazy’
[17:00:29.171]   - Field: ‘state’
[17:00:29.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.171] - Launch lazy future ...
[17:00:29.171] Packages needed by the future expression (n = 0): <none>
[17:00:29.171] Packages needed by future strategies (n = 0): <none>
[17:00:29.172] {
[17:00:29.172]     {
[17:00:29.172]         {
[17:00:29.172]             ...future.startTime <- base::Sys.time()
[17:00:29.172]             {
[17:00:29.172]                 {
[17:00:29.172]                   {
[17:00:29.172]                     {
[17:00:29.172]                       base::local({
[17:00:29.172]                         has_future <- base::requireNamespace("future", 
[17:00:29.172]                           quietly = TRUE)
[17:00:29.172]                         if (has_future) {
[17:00:29.172]                           ns <- base::getNamespace("future")
[17:00:29.172]                           version <- ns[[".package"]][["version"]]
[17:00:29.172]                           if (is.null(version)) 
[17:00:29.172]                             version <- utils::packageVersion("future")
[17:00:29.172]                         }
[17:00:29.172]                         else {
[17:00:29.172]                           version <- NULL
[17:00:29.172]                         }
[17:00:29.172]                         if (!has_future || version < "1.8.0") {
[17:00:29.172]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.172]                             "", base::R.version$version.string), 
[17:00:29.172]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.172]                               "release", "version")], collapse = " "), 
[17:00:29.172]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.172]                             info)
[17:00:29.172]                           info <- base::paste(info, collapse = "; ")
[17:00:29.172]                           if (!has_future) {
[17:00:29.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.172]                               info)
[17:00:29.172]                           }
[17:00:29.172]                           else {
[17:00:29.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.172]                               info, version)
[17:00:29.172]                           }
[17:00:29.172]                           base::stop(msg)
[17:00:29.172]                         }
[17:00:29.172]                       })
[17:00:29.172]                     }
[17:00:29.172]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.172]                     base::options(mc.cores = 1L)
[17:00:29.172]                   }
[17:00:29.172]                   ...future.strategy.old <- future::plan("list")
[17:00:29.172]                   options(future.plan = NULL)
[17:00:29.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.172]                 }
[17:00:29.172]                 ...future.workdir <- getwd()
[17:00:29.172]             }
[17:00:29.172]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.172]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.172]         }
[17:00:29.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.172]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.172]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.172]             base::names(...future.oldOptions))
[17:00:29.172]     }
[17:00:29.172]     if (FALSE) {
[17:00:29.172]     }
[17:00:29.172]     else {
[17:00:29.172]         if (TRUE) {
[17:00:29.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.172]                 open = "w")
[17:00:29.172]         }
[17:00:29.172]         else {
[17:00:29.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.172]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.172]         }
[17:00:29.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.172]             base::sink(type = "output", split = FALSE)
[17:00:29.172]             base::close(...future.stdout)
[17:00:29.172]         }, add = TRUE)
[17:00:29.172]     }
[17:00:29.172]     ...future.frame <- base::sys.nframe()
[17:00:29.172]     ...future.conditions <- base::list()
[17:00:29.172]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.172]     if (FALSE) {
[17:00:29.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.172]     }
[17:00:29.172]     ...future.result <- base::tryCatch({
[17:00:29.172]         base::withCallingHandlers({
[17:00:29.172]             ...future.value <- base::withVisible(base::local({
[17:00:29.172]                 withCallingHandlers({
[17:00:29.172]                   {
[17:00:29.172]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.172]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.172]                       ...future.globals.maxSize)) {
[17:00:29.172]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.172]                       on.exit(options(oopts), add = TRUE)
[17:00:29.172]                     }
[17:00:29.172]                     {
[17:00:29.172]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.172]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.172]                         USE.NAMES = FALSE)
[17:00:29.172]                       do.call(mapply, args = args)
[17:00:29.172]                     }
[17:00:29.172]                   }
[17:00:29.172]                 }, immediateCondition = function(cond) {
[17:00:29.172]                   save_rds <- function (object, pathname, ...) 
[17:00:29.172]                   {
[17:00:29.172]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.172]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.172]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.172]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.172]                         fi_tmp[["mtime"]])
[17:00:29.172]                     }
[17:00:29.172]                     tryCatch({
[17:00:29.172]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.172]                     }, error = function(ex) {
[17:00:29.172]                       msg <- conditionMessage(ex)
[17:00:29.172]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.172]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.172]                         fi_tmp[["mtime"]], msg)
[17:00:29.172]                       ex$message <- msg
[17:00:29.172]                       stop(ex)
[17:00:29.172]                     })
[17:00:29.172]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.172]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.172]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.172]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.172]                       fi <- file.info(pathname)
[17:00:29.172]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.172]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.172]                         fi[["size"]], fi[["mtime"]])
[17:00:29.172]                       stop(msg)
[17:00:29.172]                     }
[17:00:29.172]                     invisible(pathname)
[17:00:29.172]                   }
[17:00:29.172]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.172]                     rootPath = tempdir()) 
[17:00:29.172]                   {
[17:00:29.172]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.172]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.172]                       tmpdir = path, fileext = ".rds")
[17:00:29.172]                     save_rds(obj, file)
[17:00:29.172]                   }
[17:00:29.172]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.172]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.172]                   {
[17:00:29.172]                     inherits <- base::inherits
[17:00:29.172]                     invokeRestart <- base::invokeRestart
[17:00:29.172]                     is.null <- base::is.null
[17:00:29.172]                     muffled <- FALSE
[17:00:29.172]                     if (inherits(cond, "message")) {
[17:00:29.172]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.172]                       if (muffled) 
[17:00:29.172]                         invokeRestart("muffleMessage")
[17:00:29.172]                     }
[17:00:29.172]                     else if (inherits(cond, "warning")) {
[17:00:29.172]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.172]                       if (muffled) 
[17:00:29.172]                         invokeRestart("muffleWarning")
[17:00:29.172]                     }
[17:00:29.172]                     else if (inherits(cond, "condition")) {
[17:00:29.172]                       if (!is.null(pattern)) {
[17:00:29.172]                         computeRestarts <- base::computeRestarts
[17:00:29.172]                         grepl <- base::grepl
[17:00:29.172]                         restarts <- computeRestarts(cond)
[17:00:29.172]                         for (restart in restarts) {
[17:00:29.172]                           name <- restart$name
[17:00:29.172]                           if (is.null(name)) 
[17:00:29.172]                             next
[17:00:29.172]                           if (!grepl(pattern, name)) 
[17:00:29.172]                             next
[17:00:29.172]                           invokeRestart(restart)
[17:00:29.172]                           muffled <- TRUE
[17:00:29.172]                           break
[17:00:29.172]                         }
[17:00:29.172]                       }
[17:00:29.172]                     }
[17:00:29.172]                     invisible(muffled)
[17:00:29.172]                   }
[17:00:29.172]                   muffleCondition(cond)
[17:00:29.172]                 })
[17:00:29.172]             }))
[17:00:29.172]             future::FutureResult(value = ...future.value$value, 
[17:00:29.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.172]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.172]                     ...future.globalenv.names))
[17:00:29.172]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.172]         }, condition = base::local({
[17:00:29.172]             c <- base::c
[17:00:29.172]             inherits <- base::inherits
[17:00:29.172]             invokeRestart <- base::invokeRestart
[17:00:29.172]             length <- base::length
[17:00:29.172]             list <- base::list
[17:00:29.172]             seq.int <- base::seq.int
[17:00:29.172]             signalCondition <- base::signalCondition
[17:00:29.172]             sys.calls <- base::sys.calls
[17:00:29.172]             `[[` <- base::`[[`
[17:00:29.172]             `+` <- base::`+`
[17:00:29.172]             `<<-` <- base::`<<-`
[17:00:29.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.172]                   3L)]
[17:00:29.172]             }
[17:00:29.172]             function(cond) {
[17:00:29.172]                 is_error <- inherits(cond, "error")
[17:00:29.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.172]                   NULL)
[17:00:29.172]                 if (is_error) {
[17:00:29.172]                   sessionInformation <- function() {
[17:00:29.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.172]                       search = base::search(), system = base::Sys.info())
[17:00:29.172]                   }
[17:00:29.172]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.172]                     cond$call), session = sessionInformation(), 
[17:00:29.172]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.172]                   signalCondition(cond)
[17:00:29.172]                 }
[17:00:29.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.172]                 "immediateCondition"))) {
[17:00:29.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.172]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.172]                   if (TRUE && !signal) {
[17:00:29.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.172]                     {
[17:00:29.172]                       inherits <- base::inherits
[17:00:29.172]                       invokeRestart <- base::invokeRestart
[17:00:29.172]                       is.null <- base::is.null
[17:00:29.172]                       muffled <- FALSE
[17:00:29.172]                       if (inherits(cond, "message")) {
[17:00:29.172]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.172]                         if (muffled) 
[17:00:29.172]                           invokeRestart("muffleMessage")
[17:00:29.172]                       }
[17:00:29.172]                       else if (inherits(cond, "warning")) {
[17:00:29.172]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.172]                         if (muffled) 
[17:00:29.172]                           invokeRestart("muffleWarning")
[17:00:29.172]                       }
[17:00:29.172]                       else if (inherits(cond, "condition")) {
[17:00:29.172]                         if (!is.null(pattern)) {
[17:00:29.172]                           computeRestarts <- base::computeRestarts
[17:00:29.172]                           grepl <- base::grepl
[17:00:29.172]                           restarts <- computeRestarts(cond)
[17:00:29.172]                           for (restart in restarts) {
[17:00:29.172]                             name <- restart$name
[17:00:29.172]                             if (is.null(name)) 
[17:00:29.172]                               next
[17:00:29.172]                             if (!grepl(pattern, name)) 
[17:00:29.172]                               next
[17:00:29.172]                             invokeRestart(restart)
[17:00:29.172]                             muffled <- TRUE
[17:00:29.172]                             break
[17:00:29.172]                           }
[17:00:29.172]                         }
[17:00:29.172]                       }
[17:00:29.172]                       invisible(muffled)
[17:00:29.172]                     }
[17:00:29.172]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.172]                   }
[17:00:29.172]                 }
[17:00:29.172]                 else {
[17:00:29.172]                   if (TRUE) {
[17:00:29.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.172]                     {
[17:00:29.172]                       inherits <- base::inherits
[17:00:29.172]                       invokeRestart <- base::invokeRestart
[17:00:29.172]                       is.null <- base::is.null
[17:00:29.172]                       muffled <- FALSE
[17:00:29.172]                       if (inherits(cond, "message")) {
[17:00:29.172]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.172]                         if (muffled) 
[17:00:29.172]                           invokeRestart("muffleMessage")
[17:00:29.172]                       }
[17:00:29.172]                       else if (inherits(cond, "warning")) {
[17:00:29.172]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.172]                         if (muffled) 
[17:00:29.172]                           invokeRestart("muffleWarning")
[17:00:29.172]                       }
[17:00:29.172]                       else if (inherits(cond, "condition")) {
[17:00:29.172]                         if (!is.null(pattern)) {
[17:00:29.172]                           computeRestarts <- base::computeRestarts
[17:00:29.172]                           grepl <- base::grepl
[17:00:29.172]                           restarts <- computeRestarts(cond)
[17:00:29.172]                           for (restart in restarts) {
[17:00:29.172]                             name <- restart$name
[17:00:29.172]                             if (is.null(name)) 
[17:00:29.172]                               next
[17:00:29.172]                             if (!grepl(pattern, name)) 
[17:00:29.172]                               next
[17:00:29.172]                             invokeRestart(restart)
[17:00:29.172]                             muffled <- TRUE
[17:00:29.172]                             break
[17:00:29.172]                           }
[17:00:29.172]                         }
[17:00:29.172]                       }
[17:00:29.172]                       invisible(muffled)
[17:00:29.172]                     }
[17:00:29.172]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.172]                   }
[17:00:29.172]                 }
[17:00:29.172]             }
[17:00:29.172]         }))
[17:00:29.172]     }, error = function(ex) {
[17:00:29.172]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.172]                 ...future.rng), started = ...future.startTime, 
[17:00:29.172]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.172]             version = "1.8"), class = "FutureResult")
[17:00:29.172]     }, finally = {
[17:00:29.172]         if (!identical(...future.workdir, getwd())) 
[17:00:29.172]             setwd(...future.workdir)
[17:00:29.172]         {
[17:00:29.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.172]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.172]             }
[17:00:29.172]             base::options(...future.oldOptions)
[17:00:29.172]             if (.Platform$OS.type == "windows") {
[17:00:29.172]                 old_names <- names(...future.oldEnvVars)
[17:00:29.172]                 envs <- base::Sys.getenv()
[17:00:29.172]                 names <- names(envs)
[17:00:29.172]                 common <- intersect(names, old_names)
[17:00:29.172]                 added <- setdiff(names, old_names)
[17:00:29.172]                 removed <- setdiff(old_names, names)
[17:00:29.172]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.172]                   envs[common]]
[17:00:29.172]                 NAMES <- toupper(changed)
[17:00:29.172]                 args <- list()
[17:00:29.172]                 for (kk in seq_along(NAMES)) {
[17:00:29.172]                   name <- changed[[kk]]
[17:00:29.172]                   NAME <- NAMES[[kk]]
[17:00:29.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.172]                     next
[17:00:29.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.172]                 }
[17:00:29.172]                 NAMES <- toupper(added)
[17:00:29.172]                 for (kk in seq_along(NAMES)) {
[17:00:29.172]                   name <- added[[kk]]
[17:00:29.172]                   NAME <- NAMES[[kk]]
[17:00:29.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.172]                     next
[17:00:29.172]                   args[[name]] <- ""
[17:00:29.172]                 }
[17:00:29.172]                 NAMES <- toupper(removed)
[17:00:29.172]                 for (kk in seq_along(NAMES)) {
[17:00:29.172]                   name <- removed[[kk]]
[17:00:29.172]                   NAME <- NAMES[[kk]]
[17:00:29.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.172]                     next
[17:00:29.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.172]                 }
[17:00:29.172]                 if (length(args) > 0) 
[17:00:29.172]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.172]             }
[17:00:29.172]             else {
[17:00:29.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.172]             }
[17:00:29.172]             {
[17:00:29.172]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.172]                   0L) {
[17:00:29.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.172]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.172]                   base::options(opts)
[17:00:29.172]                 }
[17:00:29.172]                 {
[17:00:29.172]                   {
[17:00:29.172]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.172]                     NULL
[17:00:29.172]                   }
[17:00:29.172]                   options(future.plan = NULL)
[17:00:29.172]                   if (is.na(NA_character_)) 
[17:00:29.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.172]                     .init = FALSE)
[17:00:29.172]                 }
[17:00:29.172]             }
[17:00:29.172]         }
[17:00:29.172]     })
[17:00:29.172]     if (TRUE) {
[17:00:29.172]         base::sink(type = "output", split = FALSE)
[17:00:29.172]         if (TRUE) {
[17:00:29.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.172]         }
[17:00:29.172]         else {
[17:00:29.172]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.172]         }
[17:00:29.172]         base::close(...future.stdout)
[17:00:29.172]         ...future.stdout <- NULL
[17:00:29.172]     }
[17:00:29.172]     ...future.result$conditions <- ...future.conditions
[17:00:29.172]     ...future.result$finished <- base::Sys.time()
[17:00:29.172]     ...future.result
[17:00:29.172] }
[17:00:29.174] assign_globals() ...
[17:00:29.174] List of 5
[17:00:29.174]  $ ...future.FUN            :function (x, ...)  
[17:00:29.174]  $ MoreArgs                 : NULL
[17:00:29.174]  $ ...future.elements_ii    :List of 2
[17:00:29.174]   ..$ times:List of 2
[17:00:29.174]   .. ..$ : int 1
[17:00:29.174]   .. ..$ : int 2
[17:00:29.174]   ..$ x    :List of 2
[17:00:29.174]   .. ..$ : int 4
[17:00:29.174]   .. ..$ : int 3
[17:00:29.174]  $ ...future.seeds_ii       : NULL
[17:00:29.174]  $ ...future.globals.maxSize: NULL
[17:00:29.174]  - attr(*, "where")=List of 5
[17:00:29.174]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.174]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.174]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.174]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.174]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.174]  - attr(*, "resolved")= logi FALSE
[17:00:29.174]  - attr(*, "total_size")= num 280
[17:00:29.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.174]  - attr(*, "already-done")= logi TRUE
[17:00:29.180] - copied ‘...future.FUN’ to environment
[17:00:29.180] - copied ‘MoreArgs’ to environment
[17:00:29.180] - copied ‘...future.elements_ii’ to environment
[17:00:29.180] - copied ‘...future.seeds_ii’ to environment
[17:00:29.180] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.180] assign_globals() ... done
[17:00:29.181] requestCore(): workers = 2
[17:00:29.183] MulticoreFuture started
[17:00:29.183] - Launch lazy future ... done
[17:00:29.183] run() for ‘MulticoreFuture’ ... done
[17:00:29.184] Created future:
[17:00:29.184] plan(): Setting new future strategy stack:
[17:00:29.184] List of future strategies:
[17:00:29.184] 1. sequential:
[17:00:29.184]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.184]    - tweaked: FALSE
[17:00:29.184]    - call: NULL
[17:00:29.185] plan(): nbrOfWorkers() = 1
[17:00:29.187] plan(): Setting new future strategy stack:
[17:00:29.188] List of future strategies:
[17:00:29.188] 1. multicore:
[17:00:29.188]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.188]    - tweaked: FALSE
[17:00:29.188]    - call: plan(strategy)
[17:00:29.193] plan(): nbrOfWorkers() = 2
[17:00:29.184] MulticoreFuture:
[17:00:29.184] Label: ‘future_mapply-1’
[17:00:29.184] Expression:
[17:00:29.184] {
[17:00:29.184]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.184]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.184]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.184]         on.exit(options(oopts), add = TRUE)
[17:00:29.184]     }
[17:00:29.184]     {
[17:00:29.184]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.184]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.184]         do.call(mapply, args = args)
[17:00:29.184]     }
[17:00:29.184] }
[17:00:29.184] Lazy evaluation: FALSE
[17:00:29.184] Asynchronous evaluation: TRUE
[17:00:29.184] Local evaluation: TRUE
[17:00:29.184] Environment: R_GlobalEnv
[17:00:29.184] Capture standard output: TRUE
[17:00:29.184] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.184] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.184] Packages: <none>
[17:00:29.184] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.184] Resolved: TRUE
[17:00:29.184] Value: <not collected>
[17:00:29.184] Conditions captured: <none>
[17:00:29.184] Early signaling: FALSE
[17:00:29.184] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.184] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.194] Chunk #1 of 2 ... DONE
[17:00:29.194] Chunk #2 of 2 ...
[17:00:29.194]  - Finding globals in '...' for chunk #2 ...
[17:00:29.195] getGlobalsAndPackages() ...
[17:00:29.195] Searching for globals...
[17:00:29.195] 
[17:00:29.195] Searching for globals ... DONE
[17:00:29.196] - globals: [0] <none>
[17:00:29.196] getGlobalsAndPackages() ... DONE
[17:00:29.196]    + additional globals found: [n=0] 
[17:00:29.196]    + additional namespaces needed: [n=0] 
[17:00:29.196]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:29.196]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.196]  - seeds: <none>
[17:00:29.196]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.197] getGlobalsAndPackages() ...
[17:00:29.197] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.197] Resolving globals: FALSE
[17:00:29.198] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:29.199] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.199] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.199] 
[17:00:29.199] getGlobalsAndPackages() ... DONE
[17:00:29.200] run() for ‘Future’ ...
[17:00:29.200] - state: ‘created’
[17:00:29.200] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.209] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.209] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.209]   - Field: ‘label’
[17:00:29.210]   - Field: ‘local’
[17:00:29.210]   - Field: ‘owner’
[17:00:29.210]   - Field: ‘envir’
[17:00:29.211]   - Field: ‘workers’
[17:00:29.211]   - Field: ‘packages’
[17:00:29.212]   - Field: ‘gc’
[17:00:29.212]   - Field: ‘job’
[17:00:29.212]   - Field: ‘conditions’
[17:00:29.212]   - Field: ‘expr’
[17:00:29.213]   - Field: ‘uuid’
[17:00:29.213]   - Field: ‘seed’
[17:00:29.213]   - Field: ‘version’
[17:00:29.213]   - Field: ‘result’
[17:00:29.214]   - Field: ‘asynchronous’
[17:00:29.214]   - Field: ‘calls’
[17:00:29.214]   - Field: ‘globals’
[17:00:29.214]   - Field: ‘stdout’
[17:00:29.215]   - Field: ‘earlySignal’
[17:00:29.215]   - Field: ‘lazy’
[17:00:29.215]   - Field: ‘state’
[17:00:29.215] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.215] - Launch lazy future ...
[17:00:29.216] Packages needed by the future expression (n = 0): <none>
[17:00:29.216] Packages needed by future strategies (n = 0): <none>
[17:00:29.217] {
[17:00:29.217]     {
[17:00:29.217]         {
[17:00:29.217]             ...future.startTime <- base::Sys.time()
[17:00:29.217]             {
[17:00:29.217]                 {
[17:00:29.217]                   {
[17:00:29.217]                     {
[17:00:29.217]                       base::local({
[17:00:29.217]                         has_future <- base::requireNamespace("future", 
[17:00:29.217]                           quietly = TRUE)
[17:00:29.217]                         if (has_future) {
[17:00:29.217]                           ns <- base::getNamespace("future")
[17:00:29.217]                           version <- ns[[".package"]][["version"]]
[17:00:29.217]                           if (is.null(version)) 
[17:00:29.217]                             version <- utils::packageVersion("future")
[17:00:29.217]                         }
[17:00:29.217]                         else {
[17:00:29.217]                           version <- NULL
[17:00:29.217]                         }
[17:00:29.217]                         if (!has_future || version < "1.8.0") {
[17:00:29.217]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.217]                             "", base::R.version$version.string), 
[17:00:29.217]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.217]                               "release", "version")], collapse = " "), 
[17:00:29.217]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.217]                             info)
[17:00:29.217]                           info <- base::paste(info, collapse = "; ")
[17:00:29.217]                           if (!has_future) {
[17:00:29.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.217]                               info)
[17:00:29.217]                           }
[17:00:29.217]                           else {
[17:00:29.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.217]                               info, version)
[17:00:29.217]                           }
[17:00:29.217]                           base::stop(msg)
[17:00:29.217]                         }
[17:00:29.217]                       })
[17:00:29.217]                     }
[17:00:29.217]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.217]                     base::options(mc.cores = 1L)
[17:00:29.217]                   }
[17:00:29.217]                   ...future.strategy.old <- future::plan("list")
[17:00:29.217]                   options(future.plan = NULL)
[17:00:29.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.217]                 }
[17:00:29.217]                 ...future.workdir <- getwd()
[17:00:29.217]             }
[17:00:29.217]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.217]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.217]         }
[17:00:29.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.217]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.217]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.217]             base::names(...future.oldOptions))
[17:00:29.217]     }
[17:00:29.217]     if (FALSE) {
[17:00:29.217]     }
[17:00:29.217]     else {
[17:00:29.217]         if (TRUE) {
[17:00:29.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.217]                 open = "w")
[17:00:29.217]         }
[17:00:29.217]         else {
[17:00:29.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.217]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.217]         }
[17:00:29.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.217]             base::sink(type = "output", split = FALSE)
[17:00:29.217]             base::close(...future.stdout)
[17:00:29.217]         }, add = TRUE)
[17:00:29.217]     }
[17:00:29.217]     ...future.frame <- base::sys.nframe()
[17:00:29.217]     ...future.conditions <- base::list()
[17:00:29.217]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.217]     if (FALSE) {
[17:00:29.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.217]     }
[17:00:29.217]     ...future.result <- base::tryCatch({
[17:00:29.217]         base::withCallingHandlers({
[17:00:29.217]             ...future.value <- base::withVisible(base::local({
[17:00:29.217]                 withCallingHandlers({
[17:00:29.217]                   {
[17:00:29.217]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.217]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.217]                       ...future.globals.maxSize)) {
[17:00:29.217]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.217]                       on.exit(options(oopts), add = TRUE)
[17:00:29.217]                     }
[17:00:29.217]                     {
[17:00:29.217]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.217]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.217]                         USE.NAMES = FALSE)
[17:00:29.217]                       do.call(mapply, args = args)
[17:00:29.217]                     }
[17:00:29.217]                   }
[17:00:29.217]                 }, immediateCondition = function(cond) {
[17:00:29.217]                   save_rds <- function (object, pathname, ...) 
[17:00:29.217]                   {
[17:00:29.217]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.217]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.217]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.217]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.217]                         fi_tmp[["mtime"]])
[17:00:29.217]                     }
[17:00:29.217]                     tryCatch({
[17:00:29.217]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.217]                     }, error = function(ex) {
[17:00:29.217]                       msg <- conditionMessage(ex)
[17:00:29.217]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.217]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.217]                         fi_tmp[["mtime"]], msg)
[17:00:29.217]                       ex$message <- msg
[17:00:29.217]                       stop(ex)
[17:00:29.217]                     })
[17:00:29.217]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.217]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.217]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.217]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.217]                       fi <- file.info(pathname)
[17:00:29.217]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.217]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.217]                         fi[["size"]], fi[["mtime"]])
[17:00:29.217]                       stop(msg)
[17:00:29.217]                     }
[17:00:29.217]                     invisible(pathname)
[17:00:29.217]                   }
[17:00:29.217]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.217]                     rootPath = tempdir()) 
[17:00:29.217]                   {
[17:00:29.217]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.217]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.217]                       tmpdir = path, fileext = ".rds")
[17:00:29.217]                     save_rds(obj, file)
[17:00:29.217]                   }
[17:00:29.217]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.217]                   {
[17:00:29.217]                     inherits <- base::inherits
[17:00:29.217]                     invokeRestart <- base::invokeRestart
[17:00:29.217]                     is.null <- base::is.null
[17:00:29.217]                     muffled <- FALSE
[17:00:29.217]                     if (inherits(cond, "message")) {
[17:00:29.217]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.217]                       if (muffled) 
[17:00:29.217]                         invokeRestart("muffleMessage")
[17:00:29.217]                     }
[17:00:29.217]                     else if (inherits(cond, "warning")) {
[17:00:29.217]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.217]                       if (muffled) 
[17:00:29.217]                         invokeRestart("muffleWarning")
[17:00:29.217]                     }
[17:00:29.217]                     else if (inherits(cond, "condition")) {
[17:00:29.217]                       if (!is.null(pattern)) {
[17:00:29.217]                         computeRestarts <- base::computeRestarts
[17:00:29.217]                         grepl <- base::grepl
[17:00:29.217]                         restarts <- computeRestarts(cond)
[17:00:29.217]                         for (restart in restarts) {
[17:00:29.217]                           name <- restart$name
[17:00:29.217]                           if (is.null(name)) 
[17:00:29.217]                             next
[17:00:29.217]                           if (!grepl(pattern, name)) 
[17:00:29.217]                             next
[17:00:29.217]                           invokeRestart(restart)
[17:00:29.217]                           muffled <- TRUE
[17:00:29.217]                           break
[17:00:29.217]                         }
[17:00:29.217]                       }
[17:00:29.217]                     }
[17:00:29.217]                     invisible(muffled)
[17:00:29.217]                   }
[17:00:29.217]                   muffleCondition(cond)
[17:00:29.217]                 })
[17:00:29.217]             }))
[17:00:29.217]             future::FutureResult(value = ...future.value$value, 
[17:00:29.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.217]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.217]                     ...future.globalenv.names))
[17:00:29.217]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.217]         }, condition = base::local({
[17:00:29.217]             c <- base::c
[17:00:29.217]             inherits <- base::inherits
[17:00:29.217]             invokeRestart <- base::invokeRestart
[17:00:29.217]             length <- base::length
[17:00:29.217]             list <- base::list
[17:00:29.217]             seq.int <- base::seq.int
[17:00:29.217]             signalCondition <- base::signalCondition
[17:00:29.217]             sys.calls <- base::sys.calls
[17:00:29.217]             `[[` <- base::`[[`
[17:00:29.217]             `+` <- base::`+`
[17:00:29.217]             `<<-` <- base::`<<-`
[17:00:29.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.217]                   3L)]
[17:00:29.217]             }
[17:00:29.217]             function(cond) {
[17:00:29.217]                 is_error <- inherits(cond, "error")
[17:00:29.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.217]                   NULL)
[17:00:29.217]                 if (is_error) {
[17:00:29.217]                   sessionInformation <- function() {
[17:00:29.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.217]                       search = base::search(), system = base::Sys.info())
[17:00:29.217]                   }
[17:00:29.217]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.217]                     cond$call), session = sessionInformation(), 
[17:00:29.217]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.217]                   signalCondition(cond)
[17:00:29.217]                 }
[17:00:29.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.217]                 "immediateCondition"))) {
[17:00:29.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.217]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.217]                   if (TRUE && !signal) {
[17:00:29.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.217]                     {
[17:00:29.217]                       inherits <- base::inherits
[17:00:29.217]                       invokeRestart <- base::invokeRestart
[17:00:29.217]                       is.null <- base::is.null
[17:00:29.217]                       muffled <- FALSE
[17:00:29.217]                       if (inherits(cond, "message")) {
[17:00:29.217]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.217]                         if (muffled) 
[17:00:29.217]                           invokeRestart("muffleMessage")
[17:00:29.217]                       }
[17:00:29.217]                       else if (inherits(cond, "warning")) {
[17:00:29.217]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.217]                         if (muffled) 
[17:00:29.217]                           invokeRestart("muffleWarning")
[17:00:29.217]                       }
[17:00:29.217]                       else if (inherits(cond, "condition")) {
[17:00:29.217]                         if (!is.null(pattern)) {
[17:00:29.217]                           computeRestarts <- base::computeRestarts
[17:00:29.217]                           grepl <- base::grepl
[17:00:29.217]                           restarts <- computeRestarts(cond)
[17:00:29.217]                           for (restart in restarts) {
[17:00:29.217]                             name <- restart$name
[17:00:29.217]                             if (is.null(name)) 
[17:00:29.217]                               next
[17:00:29.217]                             if (!grepl(pattern, name)) 
[17:00:29.217]                               next
[17:00:29.217]                             invokeRestart(restart)
[17:00:29.217]                             muffled <- TRUE
[17:00:29.217]                             break
[17:00:29.217]                           }
[17:00:29.217]                         }
[17:00:29.217]                       }
[17:00:29.217]                       invisible(muffled)
[17:00:29.217]                     }
[17:00:29.217]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.217]                   }
[17:00:29.217]                 }
[17:00:29.217]                 else {
[17:00:29.217]                   if (TRUE) {
[17:00:29.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.217]                     {
[17:00:29.217]                       inherits <- base::inherits
[17:00:29.217]                       invokeRestart <- base::invokeRestart
[17:00:29.217]                       is.null <- base::is.null
[17:00:29.217]                       muffled <- FALSE
[17:00:29.217]                       if (inherits(cond, "message")) {
[17:00:29.217]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.217]                         if (muffled) 
[17:00:29.217]                           invokeRestart("muffleMessage")
[17:00:29.217]                       }
[17:00:29.217]                       else if (inherits(cond, "warning")) {
[17:00:29.217]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.217]                         if (muffled) 
[17:00:29.217]                           invokeRestart("muffleWarning")
[17:00:29.217]                       }
[17:00:29.217]                       else if (inherits(cond, "condition")) {
[17:00:29.217]                         if (!is.null(pattern)) {
[17:00:29.217]                           computeRestarts <- base::computeRestarts
[17:00:29.217]                           grepl <- base::grepl
[17:00:29.217]                           restarts <- computeRestarts(cond)
[17:00:29.217]                           for (restart in restarts) {
[17:00:29.217]                             name <- restart$name
[17:00:29.217]                             if (is.null(name)) 
[17:00:29.217]                               next
[17:00:29.217]                             if (!grepl(pattern, name)) 
[17:00:29.217]                               next
[17:00:29.217]                             invokeRestart(restart)
[17:00:29.217]                             muffled <- TRUE
[17:00:29.217]                             break
[17:00:29.217]                           }
[17:00:29.217]                         }
[17:00:29.217]                       }
[17:00:29.217]                       invisible(muffled)
[17:00:29.217]                     }
[17:00:29.217]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.217]                   }
[17:00:29.217]                 }
[17:00:29.217]             }
[17:00:29.217]         }))
[17:00:29.217]     }, error = function(ex) {
[17:00:29.217]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.217]                 ...future.rng), started = ...future.startTime, 
[17:00:29.217]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.217]             version = "1.8"), class = "FutureResult")
[17:00:29.217]     }, finally = {
[17:00:29.217]         if (!identical(...future.workdir, getwd())) 
[17:00:29.217]             setwd(...future.workdir)
[17:00:29.217]         {
[17:00:29.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.217]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.217]             }
[17:00:29.217]             base::options(...future.oldOptions)
[17:00:29.217]             if (.Platform$OS.type == "windows") {
[17:00:29.217]                 old_names <- names(...future.oldEnvVars)
[17:00:29.217]                 envs <- base::Sys.getenv()
[17:00:29.217]                 names <- names(envs)
[17:00:29.217]                 common <- intersect(names, old_names)
[17:00:29.217]                 added <- setdiff(names, old_names)
[17:00:29.217]                 removed <- setdiff(old_names, names)
[17:00:29.217]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.217]                   envs[common]]
[17:00:29.217]                 NAMES <- toupper(changed)
[17:00:29.217]                 args <- list()
[17:00:29.217]                 for (kk in seq_along(NAMES)) {
[17:00:29.217]                   name <- changed[[kk]]
[17:00:29.217]                   NAME <- NAMES[[kk]]
[17:00:29.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.217]                     next
[17:00:29.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.217]                 }
[17:00:29.217]                 NAMES <- toupper(added)
[17:00:29.217]                 for (kk in seq_along(NAMES)) {
[17:00:29.217]                   name <- added[[kk]]
[17:00:29.217]                   NAME <- NAMES[[kk]]
[17:00:29.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.217]                     next
[17:00:29.217]                   args[[name]] <- ""
[17:00:29.217]                 }
[17:00:29.217]                 NAMES <- toupper(removed)
[17:00:29.217]                 for (kk in seq_along(NAMES)) {
[17:00:29.217]                   name <- removed[[kk]]
[17:00:29.217]                   NAME <- NAMES[[kk]]
[17:00:29.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.217]                     next
[17:00:29.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.217]                 }
[17:00:29.217]                 if (length(args) > 0) 
[17:00:29.217]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.217]             }
[17:00:29.217]             else {
[17:00:29.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.217]             }
[17:00:29.217]             {
[17:00:29.217]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.217]                   0L) {
[17:00:29.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.217]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.217]                   base::options(opts)
[17:00:29.217]                 }
[17:00:29.217]                 {
[17:00:29.217]                   {
[17:00:29.217]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.217]                     NULL
[17:00:29.217]                   }
[17:00:29.217]                   options(future.plan = NULL)
[17:00:29.217]                   if (is.na(NA_character_)) 
[17:00:29.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.217]                     .init = FALSE)
[17:00:29.217]                 }
[17:00:29.217]             }
[17:00:29.217]         }
[17:00:29.217]     })
[17:00:29.217]     if (TRUE) {
[17:00:29.217]         base::sink(type = "output", split = FALSE)
[17:00:29.217]         if (TRUE) {
[17:00:29.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.217]         }
[17:00:29.217]         else {
[17:00:29.217]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.217]         }
[17:00:29.217]         base::close(...future.stdout)
[17:00:29.217]         ...future.stdout <- NULL
[17:00:29.217]     }
[17:00:29.217]     ...future.result$conditions <- ...future.conditions
[17:00:29.217]     ...future.result$finished <- base::Sys.time()
[17:00:29.217]     ...future.result
[17:00:29.217] }
[17:00:29.220] assign_globals() ...
[17:00:29.220] List of 5
[17:00:29.220]  $ ...future.FUN            :function (x, ...)  
[17:00:29.220]  $ MoreArgs                 : NULL
[17:00:29.220]  $ ...future.elements_ii    :List of 2
[17:00:29.220]   ..$ times:List of 2
[17:00:29.220]   .. ..$ : int 3
[17:00:29.220]   .. ..$ : int 4
[17:00:29.220]   ..$ x    :List of 2
[17:00:29.220]   .. ..$ : int 2
[17:00:29.220]   .. ..$ : int 1
[17:00:29.220]  $ ...future.seeds_ii       : NULL
[17:00:29.220]  $ ...future.globals.maxSize: NULL
[17:00:29.220]  - attr(*, "where")=List of 5
[17:00:29.220]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.220]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.220]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.220]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.220]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.220]  - attr(*, "resolved")= logi FALSE
[17:00:29.220]  - attr(*, "total_size")= num 280
[17:00:29.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.220]  - attr(*, "already-done")= logi TRUE
[17:00:29.228] - copied ‘...future.FUN’ to environment
[17:00:29.228] - copied ‘MoreArgs’ to environment
[17:00:29.228] - copied ‘...future.elements_ii’ to environment
[17:00:29.228] - copied ‘...future.seeds_ii’ to environment
[17:00:29.228] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.229] assign_globals() ... done
[17:00:29.229] requestCore(): workers = 2
[17:00:29.231] MulticoreFuture started
[17:00:29.231] - Launch lazy future ... done
[17:00:29.232] run() for ‘MulticoreFuture’ ... done
[17:00:29.232] Created future:
[17:00:29.232] plan(): Setting new future strategy stack:
[17:00:29.232] List of future strategies:
[17:00:29.232] 1. sequential:
[17:00:29.232]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.232]    - tweaked: FALSE
[17:00:29.232]    - call: NULL
[17:00:29.233] plan(): nbrOfWorkers() = 1
[17:00:29.236] plan(): Setting new future strategy stack:
[17:00:29.236] List of future strategies:
[17:00:29.236] 1. multicore:
[17:00:29.236]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.236]    - tweaked: FALSE
[17:00:29.236]    - call: plan(strategy)
[17:00:29.241] plan(): nbrOfWorkers() = 2
[17:00:29.232] MulticoreFuture:
[17:00:29.232] Label: ‘future_mapply-2’
[17:00:29.232] Expression:
[17:00:29.232] {
[17:00:29.232]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.232]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.232]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.232]         on.exit(options(oopts), add = TRUE)
[17:00:29.232]     }
[17:00:29.232]     {
[17:00:29.232]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.232]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.232]         do.call(mapply, args = args)
[17:00:29.232]     }
[17:00:29.232] }
[17:00:29.232] Lazy evaluation: FALSE
[17:00:29.232] Asynchronous evaluation: TRUE
[17:00:29.232] Local evaluation: TRUE
[17:00:29.232] Environment: R_GlobalEnv
[17:00:29.232] Capture standard output: TRUE
[17:00:29.232] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.232] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.232] Packages: <none>
[17:00:29.232] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.232] Resolved: TRUE
[17:00:29.232] Value: <not collected>
[17:00:29.232] Conditions captured: <none>
[17:00:29.232] Early signaling: FALSE
[17:00:29.232] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.232] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.242] Chunk #2 of 2 ... DONE
[17:00:29.242] Launching 2 futures (chunks) ... DONE
[17:00:29.242] Resolving 2 futures (chunks) ...
[17:00:29.242] resolve() on list ...
[17:00:29.242]  recursive: 0
[17:00:29.242]  length: 2
[17:00:29.243] 
[17:00:29.243] Future #1
[17:00:29.243] result() for MulticoreFuture ...
[17:00:29.244] result() for MulticoreFuture ...
[17:00:29.244] result() for MulticoreFuture ... done
[17:00:29.244] result() for MulticoreFuture ... done
[17:00:29.245] result() for MulticoreFuture ...
[17:00:29.245] result() for MulticoreFuture ... done
[17:00:29.245] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:29.245] - nx: 2
[17:00:29.245] - relay: TRUE
[17:00:29.246] - stdout: TRUE
[17:00:29.246] - signal: TRUE
[17:00:29.246] - resignal: FALSE
[17:00:29.246] - force: TRUE
[17:00:29.246] - relayed: [n=2] FALSE, FALSE
[17:00:29.246] - queued futures: [n=2] FALSE, FALSE
[17:00:29.247]  - until=1
[17:00:29.247]  - relaying element #1
[17:00:29.247] result() for MulticoreFuture ...
[17:00:29.247] result() for MulticoreFuture ... done
[17:00:29.247] result() for MulticoreFuture ...
[17:00:29.248] result() for MulticoreFuture ... done
[17:00:29.248] result() for MulticoreFuture ...
[17:00:29.248] result() for MulticoreFuture ... done
[17:00:29.248] result() for MulticoreFuture ...
[17:00:29.249] result() for MulticoreFuture ... done
[17:00:29.249] - relayed: [n=2] TRUE, FALSE
[17:00:29.249] - queued futures: [n=2] TRUE, FALSE
[17:00:29.249] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:29.249]  length: 1 (resolved future 1)
[17:00:29.250] Future #2
[17:00:29.250] result() for MulticoreFuture ...
[17:00:29.250] result() for MulticoreFuture ...
[17:00:29.251] result() for MulticoreFuture ... done
[17:00:29.251] result() for MulticoreFuture ... done
[17:00:29.251] result() for MulticoreFuture ...
[17:00:29.251] result() for MulticoreFuture ... done
[17:00:29.252] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:29.252] - nx: 2
[17:00:29.252] - relay: TRUE
[17:00:29.252] - stdout: TRUE
[17:00:29.252] - signal: TRUE
[17:00:29.252] - resignal: FALSE
[17:00:29.253] - force: TRUE
[17:00:29.253] - relayed: [n=2] TRUE, FALSE
[17:00:29.253] - queued futures: [n=2] TRUE, FALSE
[17:00:29.253]  - until=2
[17:00:29.253]  - relaying element #2
[17:00:29.253] result() for MulticoreFuture ...
[17:00:29.254] result() for MulticoreFuture ... done
[17:00:29.254] result() for MulticoreFuture ...
[17:00:29.254] result() for MulticoreFuture ... done
[17:00:29.254] result() for MulticoreFuture ...
[17:00:29.254] result() for MulticoreFuture ... done
[17:00:29.254] result() for MulticoreFuture ...
[17:00:29.254] result() for MulticoreFuture ... done
[17:00:29.254] - relayed: [n=2] TRUE, TRUE
[17:00:29.254] - queued futures: [n=2] TRUE, TRUE
[17:00:29.255] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:29.255]  length: 0 (resolved future 2)
[17:00:29.255] Relaying remaining futures
[17:00:29.255] signalConditionsASAP(NULL, pos=0) ...
[17:00:29.255] - nx: 2
[17:00:29.255] - relay: TRUE
[17:00:29.255] - stdout: TRUE
[17:00:29.255] - signal: TRUE
[17:00:29.256] - resignal: FALSE
[17:00:29.256] - force: TRUE
[17:00:29.256] - relayed: [n=2] TRUE, TRUE
[17:00:29.256] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:29.256] - relayed: [n=2] TRUE, TRUE
[17:00:29.256] - queued futures: [n=2] TRUE, TRUE
[17:00:29.256] signalConditionsASAP(NULL, pos=0) ... done
[17:00:29.256] resolve() on list ... DONE
[17:00:29.256] result() for MulticoreFuture ...
[17:00:29.257] result() for MulticoreFuture ... done
[17:00:29.257] result() for MulticoreFuture ...
[17:00:29.257] result() for MulticoreFuture ... done
[17:00:29.259] result() for MulticoreFuture ...
[17:00:29.260] result() for MulticoreFuture ... done
[17:00:29.260] result() for MulticoreFuture ...
[17:00:29.260] result() for MulticoreFuture ... done
[17:00:29.260]  - Number of value chunks collected: 2
[17:00:29.260] Resolving 2 futures (chunks) ... DONE
[17:00:29.260] Reducing values from 2 chunks ...
[17:00:29.261]  - Number of values collected after concatenation: 4
[17:00:29.261]  - Number of values expected: 4
[17:00:29.261] Reducing values from 2 chunks ... DONE
[17:00:29.261] future_mapply() ... DONE
[17:00:29.261] future_mapply() ...
[17:00:29.266] Number of chunks: 2
[17:00:29.266] getGlobalsAndPackagesXApply() ...
[17:00:29.266]  - future.globals: TRUE
[17:00:29.267] getGlobalsAndPackages() ...
[17:00:29.267] Searching for globals...
[17:00:29.268] - globals found: [1] ‘FUN’
[17:00:29.268] Searching for globals ... DONE
[17:00:29.268] Resolving globals: FALSE
[17:00:29.268] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:29.269] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:29.269] - globals: [1] ‘FUN’
[17:00:29.269] 
[17:00:29.269] getGlobalsAndPackages() ... DONE
[17:00:29.269]  - globals found/used: [n=1] ‘FUN’
[17:00:29.269]  - needed namespaces: [n=0] 
[17:00:29.269] Finding globals ... DONE
[17:00:29.270] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:29.270] List of 2
[17:00:29.270]  $ ...future.FUN:function (x, ...)  
[17:00:29.270]  $ MoreArgs     :List of 1
[17:00:29.270]   ..$ x: num 42
[17:00:29.270]  - attr(*, "where")=List of 2
[17:00:29.270]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:29.270]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:29.270]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.270]  - attr(*, "resolved")= logi FALSE
[17:00:29.270]  - attr(*, "total_size")= num NA
[17:00:29.273] Packages to be attached in all futures: [n=0] 
[17:00:29.273] getGlobalsAndPackagesXApply() ... DONE
[17:00:29.273] Number of futures (= number of chunks): 2
[17:00:29.274] Launching 2 futures (chunks) ...
[17:00:29.274] Chunk #1 of 2 ...
[17:00:29.274]  - Finding globals in '...' for chunk #1 ...
[17:00:29.274] getGlobalsAndPackages() ...
[17:00:29.274] Searching for globals...
[17:00:29.274] 
[17:00:29.275] Searching for globals ... DONE
[17:00:29.275] - globals: [0] <none>
[17:00:29.275] getGlobalsAndPackages() ... DONE
[17:00:29.275]    + additional globals found: [n=0] 
[17:00:29.275]    + additional namespaces needed: [n=0] 
[17:00:29.275]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:29.275]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.275]  - seeds: <none>
[17:00:29.275]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.276] getGlobalsAndPackages() ...
[17:00:29.276] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.276] Resolving globals: FALSE
[17:00:29.276] The total size of the 5 globals is 224 bytes (224 bytes)
[17:00:29.277] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:29.277] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.277] 
[17:00:29.277] getGlobalsAndPackages() ... DONE
[17:00:29.277] run() for ‘Future’ ...
[17:00:29.278] - state: ‘created’
[17:00:29.278] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.282] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.282] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.282]   - Field: ‘label’
[17:00:29.282]   - Field: ‘local’
[17:00:29.282]   - Field: ‘owner’
[17:00:29.282]   - Field: ‘envir’
[17:00:29.282]   - Field: ‘workers’
[17:00:29.282]   - Field: ‘packages’
[17:00:29.282]   - Field: ‘gc’
[17:00:29.282]   - Field: ‘job’
[17:00:29.283]   - Field: ‘conditions’
[17:00:29.283]   - Field: ‘expr’
[17:00:29.283]   - Field: ‘uuid’
[17:00:29.283]   - Field: ‘seed’
[17:00:29.283]   - Field: ‘version’
[17:00:29.283]   - Field: ‘result’
[17:00:29.283]   - Field: ‘asynchronous’
[17:00:29.283]   - Field: ‘calls’
[17:00:29.283]   - Field: ‘globals’
[17:00:29.283]   - Field: ‘stdout’
[17:00:29.284]   - Field: ‘earlySignal’
[17:00:29.284]   - Field: ‘lazy’
[17:00:29.284]   - Field: ‘state’
[17:00:29.284] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.284] - Launch lazy future ...
[17:00:29.284] Packages needed by the future expression (n = 0): <none>
[17:00:29.284] Packages needed by future strategies (n = 0): <none>
[17:00:29.285] {
[17:00:29.285]     {
[17:00:29.285]         {
[17:00:29.285]             ...future.startTime <- base::Sys.time()
[17:00:29.285]             {
[17:00:29.285]                 {
[17:00:29.285]                   {
[17:00:29.285]                     {
[17:00:29.285]                       base::local({
[17:00:29.285]                         has_future <- base::requireNamespace("future", 
[17:00:29.285]                           quietly = TRUE)
[17:00:29.285]                         if (has_future) {
[17:00:29.285]                           ns <- base::getNamespace("future")
[17:00:29.285]                           version <- ns[[".package"]][["version"]]
[17:00:29.285]                           if (is.null(version)) 
[17:00:29.285]                             version <- utils::packageVersion("future")
[17:00:29.285]                         }
[17:00:29.285]                         else {
[17:00:29.285]                           version <- NULL
[17:00:29.285]                         }
[17:00:29.285]                         if (!has_future || version < "1.8.0") {
[17:00:29.285]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.285]                             "", base::R.version$version.string), 
[17:00:29.285]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.285]                               "release", "version")], collapse = " "), 
[17:00:29.285]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.285]                             info)
[17:00:29.285]                           info <- base::paste(info, collapse = "; ")
[17:00:29.285]                           if (!has_future) {
[17:00:29.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.285]                               info)
[17:00:29.285]                           }
[17:00:29.285]                           else {
[17:00:29.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.285]                               info, version)
[17:00:29.285]                           }
[17:00:29.285]                           base::stop(msg)
[17:00:29.285]                         }
[17:00:29.285]                       })
[17:00:29.285]                     }
[17:00:29.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.285]                     base::options(mc.cores = 1L)
[17:00:29.285]                   }
[17:00:29.285]                   ...future.strategy.old <- future::plan("list")
[17:00:29.285]                   options(future.plan = NULL)
[17:00:29.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.285]                 }
[17:00:29.285]                 ...future.workdir <- getwd()
[17:00:29.285]             }
[17:00:29.285]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.285]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.285]         }
[17:00:29.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.285]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.285]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.285]             base::names(...future.oldOptions))
[17:00:29.285]     }
[17:00:29.285]     if (FALSE) {
[17:00:29.285]     }
[17:00:29.285]     else {
[17:00:29.285]         if (TRUE) {
[17:00:29.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.285]                 open = "w")
[17:00:29.285]         }
[17:00:29.285]         else {
[17:00:29.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.285]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.285]         }
[17:00:29.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.285]             base::sink(type = "output", split = FALSE)
[17:00:29.285]             base::close(...future.stdout)
[17:00:29.285]         }, add = TRUE)
[17:00:29.285]     }
[17:00:29.285]     ...future.frame <- base::sys.nframe()
[17:00:29.285]     ...future.conditions <- base::list()
[17:00:29.285]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.285]     if (FALSE) {
[17:00:29.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.285]     }
[17:00:29.285]     ...future.result <- base::tryCatch({
[17:00:29.285]         base::withCallingHandlers({
[17:00:29.285]             ...future.value <- base::withVisible(base::local({
[17:00:29.285]                 withCallingHandlers({
[17:00:29.285]                   {
[17:00:29.285]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.285]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.285]                       ...future.globals.maxSize)) {
[17:00:29.285]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.285]                       on.exit(options(oopts), add = TRUE)
[17:00:29.285]                     }
[17:00:29.285]                     {
[17:00:29.285]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.285]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.285]                         USE.NAMES = FALSE)
[17:00:29.285]                       do.call(mapply, args = args)
[17:00:29.285]                     }
[17:00:29.285]                   }
[17:00:29.285]                 }, immediateCondition = function(cond) {
[17:00:29.285]                   save_rds <- function (object, pathname, ...) 
[17:00:29.285]                   {
[17:00:29.285]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.285]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.285]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.285]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.285]                         fi_tmp[["mtime"]])
[17:00:29.285]                     }
[17:00:29.285]                     tryCatch({
[17:00:29.285]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.285]                     }, error = function(ex) {
[17:00:29.285]                       msg <- conditionMessage(ex)
[17:00:29.285]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.285]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.285]                         fi_tmp[["mtime"]], msg)
[17:00:29.285]                       ex$message <- msg
[17:00:29.285]                       stop(ex)
[17:00:29.285]                     })
[17:00:29.285]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.285]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.285]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.285]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.285]                       fi <- file.info(pathname)
[17:00:29.285]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.285]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.285]                         fi[["size"]], fi[["mtime"]])
[17:00:29.285]                       stop(msg)
[17:00:29.285]                     }
[17:00:29.285]                     invisible(pathname)
[17:00:29.285]                   }
[17:00:29.285]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.285]                     rootPath = tempdir()) 
[17:00:29.285]                   {
[17:00:29.285]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.285]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.285]                       tmpdir = path, fileext = ".rds")
[17:00:29.285]                     save_rds(obj, file)
[17:00:29.285]                   }
[17:00:29.285]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.285]                   {
[17:00:29.285]                     inherits <- base::inherits
[17:00:29.285]                     invokeRestart <- base::invokeRestart
[17:00:29.285]                     is.null <- base::is.null
[17:00:29.285]                     muffled <- FALSE
[17:00:29.285]                     if (inherits(cond, "message")) {
[17:00:29.285]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.285]                       if (muffled) 
[17:00:29.285]                         invokeRestart("muffleMessage")
[17:00:29.285]                     }
[17:00:29.285]                     else if (inherits(cond, "warning")) {
[17:00:29.285]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.285]                       if (muffled) 
[17:00:29.285]                         invokeRestart("muffleWarning")
[17:00:29.285]                     }
[17:00:29.285]                     else if (inherits(cond, "condition")) {
[17:00:29.285]                       if (!is.null(pattern)) {
[17:00:29.285]                         computeRestarts <- base::computeRestarts
[17:00:29.285]                         grepl <- base::grepl
[17:00:29.285]                         restarts <- computeRestarts(cond)
[17:00:29.285]                         for (restart in restarts) {
[17:00:29.285]                           name <- restart$name
[17:00:29.285]                           if (is.null(name)) 
[17:00:29.285]                             next
[17:00:29.285]                           if (!grepl(pattern, name)) 
[17:00:29.285]                             next
[17:00:29.285]                           invokeRestart(restart)
[17:00:29.285]                           muffled <- TRUE
[17:00:29.285]                           break
[17:00:29.285]                         }
[17:00:29.285]                       }
[17:00:29.285]                     }
[17:00:29.285]                     invisible(muffled)
[17:00:29.285]                   }
[17:00:29.285]                   muffleCondition(cond)
[17:00:29.285]                 })
[17:00:29.285]             }))
[17:00:29.285]             future::FutureResult(value = ...future.value$value, 
[17:00:29.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.285]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.285]                     ...future.globalenv.names))
[17:00:29.285]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.285]         }, condition = base::local({
[17:00:29.285]             c <- base::c
[17:00:29.285]             inherits <- base::inherits
[17:00:29.285]             invokeRestart <- base::invokeRestart
[17:00:29.285]             length <- base::length
[17:00:29.285]             list <- base::list
[17:00:29.285]             seq.int <- base::seq.int
[17:00:29.285]             signalCondition <- base::signalCondition
[17:00:29.285]             sys.calls <- base::sys.calls
[17:00:29.285]             `[[` <- base::`[[`
[17:00:29.285]             `+` <- base::`+`
[17:00:29.285]             `<<-` <- base::`<<-`
[17:00:29.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.285]                   3L)]
[17:00:29.285]             }
[17:00:29.285]             function(cond) {
[17:00:29.285]                 is_error <- inherits(cond, "error")
[17:00:29.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.285]                   NULL)
[17:00:29.285]                 if (is_error) {
[17:00:29.285]                   sessionInformation <- function() {
[17:00:29.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.285]                       search = base::search(), system = base::Sys.info())
[17:00:29.285]                   }
[17:00:29.285]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.285]                     cond$call), session = sessionInformation(), 
[17:00:29.285]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.285]                   signalCondition(cond)
[17:00:29.285]                 }
[17:00:29.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.285]                 "immediateCondition"))) {
[17:00:29.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.285]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.285]                   if (TRUE && !signal) {
[17:00:29.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.285]                     {
[17:00:29.285]                       inherits <- base::inherits
[17:00:29.285]                       invokeRestart <- base::invokeRestart
[17:00:29.285]                       is.null <- base::is.null
[17:00:29.285]                       muffled <- FALSE
[17:00:29.285]                       if (inherits(cond, "message")) {
[17:00:29.285]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.285]                         if (muffled) 
[17:00:29.285]                           invokeRestart("muffleMessage")
[17:00:29.285]                       }
[17:00:29.285]                       else if (inherits(cond, "warning")) {
[17:00:29.285]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.285]                         if (muffled) 
[17:00:29.285]                           invokeRestart("muffleWarning")
[17:00:29.285]                       }
[17:00:29.285]                       else if (inherits(cond, "condition")) {
[17:00:29.285]                         if (!is.null(pattern)) {
[17:00:29.285]                           computeRestarts <- base::computeRestarts
[17:00:29.285]                           grepl <- base::grepl
[17:00:29.285]                           restarts <- computeRestarts(cond)
[17:00:29.285]                           for (restart in restarts) {
[17:00:29.285]                             name <- restart$name
[17:00:29.285]                             if (is.null(name)) 
[17:00:29.285]                               next
[17:00:29.285]                             if (!grepl(pattern, name)) 
[17:00:29.285]                               next
[17:00:29.285]                             invokeRestart(restart)
[17:00:29.285]                             muffled <- TRUE
[17:00:29.285]                             break
[17:00:29.285]                           }
[17:00:29.285]                         }
[17:00:29.285]                       }
[17:00:29.285]                       invisible(muffled)
[17:00:29.285]                     }
[17:00:29.285]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.285]                   }
[17:00:29.285]                 }
[17:00:29.285]                 else {
[17:00:29.285]                   if (TRUE) {
[17:00:29.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.285]                     {
[17:00:29.285]                       inherits <- base::inherits
[17:00:29.285]                       invokeRestart <- base::invokeRestart
[17:00:29.285]                       is.null <- base::is.null
[17:00:29.285]                       muffled <- FALSE
[17:00:29.285]                       if (inherits(cond, "message")) {
[17:00:29.285]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.285]                         if (muffled) 
[17:00:29.285]                           invokeRestart("muffleMessage")
[17:00:29.285]                       }
[17:00:29.285]                       else if (inherits(cond, "warning")) {
[17:00:29.285]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.285]                         if (muffled) 
[17:00:29.285]                           invokeRestart("muffleWarning")
[17:00:29.285]                       }
[17:00:29.285]                       else if (inherits(cond, "condition")) {
[17:00:29.285]                         if (!is.null(pattern)) {
[17:00:29.285]                           computeRestarts <- base::computeRestarts
[17:00:29.285]                           grepl <- base::grepl
[17:00:29.285]                           restarts <- computeRestarts(cond)
[17:00:29.285]                           for (restart in restarts) {
[17:00:29.285]                             name <- restart$name
[17:00:29.285]                             if (is.null(name)) 
[17:00:29.285]                               next
[17:00:29.285]                             if (!grepl(pattern, name)) 
[17:00:29.285]                               next
[17:00:29.285]                             invokeRestart(restart)
[17:00:29.285]                             muffled <- TRUE
[17:00:29.285]                             break
[17:00:29.285]                           }
[17:00:29.285]                         }
[17:00:29.285]                       }
[17:00:29.285]                       invisible(muffled)
[17:00:29.285]                     }
[17:00:29.285]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.285]                   }
[17:00:29.285]                 }
[17:00:29.285]             }
[17:00:29.285]         }))
[17:00:29.285]     }, error = function(ex) {
[17:00:29.285]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.285]                 ...future.rng), started = ...future.startTime, 
[17:00:29.285]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.285]             version = "1.8"), class = "FutureResult")
[17:00:29.285]     }, finally = {
[17:00:29.285]         if (!identical(...future.workdir, getwd())) 
[17:00:29.285]             setwd(...future.workdir)
[17:00:29.285]         {
[17:00:29.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.285]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.285]             }
[17:00:29.285]             base::options(...future.oldOptions)
[17:00:29.285]             if (.Platform$OS.type == "windows") {
[17:00:29.285]                 old_names <- names(...future.oldEnvVars)
[17:00:29.285]                 envs <- base::Sys.getenv()
[17:00:29.285]                 names <- names(envs)
[17:00:29.285]                 common <- intersect(names, old_names)
[17:00:29.285]                 added <- setdiff(names, old_names)
[17:00:29.285]                 removed <- setdiff(old_names, names)
[17:00:29.285]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.285]                   envs[common]]
[17:00:29.285]                 NAMES <- toupper(changed)
[17:00:29.285]                 args <- list()
[17:00:29.285]                 for (kk in seq_along(NAMES)) {
[17:00:29.285]                   name <- changed[[kk]]
[17:00:29.285]                   NAME <- NAMES[[kk]]
[17:00:29.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.285]                     next
[17:00:29.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.285]                 }
[17:00:29.285]                 NAMES <- toupper(added)
[17:00:29.285]                 for (kk in seq_along(NAMES)) {
[17:00:29.285]                   name <- added[[kk]]
[17:00:29.285]                   NAME <- NAMES[[kk]]
[17:00:29.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.285]                     next
[17:00:29.285]                   args[[name]] <- ""
[17:00:29.285]                 }
[17:00:29.285]                 NAMES <- toupper(removed)
[17:00:29.285]                 for (kk in seq_along(NAMES)) {
[17:00:29.285]                   name <- removed[[kk]]
[17:00:29.285]                   NAME <- NAMES[[kk]]
[17:00:29.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.285]                     next
[17:00:29.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.285]                 }
[17:00:29.285]                 if (length(args) > 0) 
[17:00:29.285]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.285]             }
[17:00:29.285]             else {
[17:00:29.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.285]             }
[17:00:29.285]             {
[17:00:29.285]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.285]                   0L) {
[17:00:29.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.285]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.285]                   base::options(opts)
[17:00:29.285]                 }
[17:00:29.285]                 {
[17:00:29.285]                   {
[17:00:29.285]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.285]                     NULL
[17:00:29.285]                   }
[17:00:29.285]                   options(future.plan = NULL)
[17:00:29.285]                   if (is.na(NA_character_)) 
[17:00:29.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.285]                     .init = FALSE)
[17:00:29.285]                 }
[17:00:29.285]             }
[17:00:29.285]         }
[17:00:29.285]     })
[17:00:29.285]     if (TRUE) {
[17:00:29.285]         base::sink(type = "output", split = FALSE)
[17:00:29.285]         if (TRUE) {
[17:00:29.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.285]         }
[17:00:29.285]         else {
[17:00:29.285]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.285]         }
[17:00:29.285]         base::close(...future.stdout)
[17:00:29.285]         ...future.stdout <- NULL
[17:00:29.285]     }
[17:00:29.285]     ...future.result$conditions <- ...future.conditions
[17:00:29.285]     ...future.result$finished <- base::Sys.time()
[17:00:29.285]     ...future.result
[17:00:29.285] }
[17:00:29.287] assign_globals() ...
[17:00:29.287] List of 5
[17:00:29.287]  $ ...future.FUN            :function (x, ...)  
[17:00:29.287]  $ MoreArgs                 :List of 1
[17:00:29.287]   ..$ x: num 42
[17:00:29.287]  $ ...future.elements_ii    :List of 1
[17:00:29.287]   ..$ times:List of 2
[17:00:29.287]   .. ..$ : int 1
[17:00:29.287]   .. ..$ : int 2
[17:00:29.287]  $ ...future.seeds_ii       : NULL
[17:00:29.287]  $ ...future.globals.maxSize: NULL
[17:00:29.287]  - attr(*, "where")=List of 5
[17:00:29.287]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.287]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.287]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.287]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.287]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.287]  - attr(*, "resolved")= logi FALSE
[17:00:29.287]  - attr(*, "total_size")= num 224
[17:00:29.287]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.287]  - attr(*, "already-done")= logi TRUE
[17:00:29.295] - copied ‘...future.FUN’ to environment
[17:00:29.295] - copied ‘MoreArgs’ to environment
[17:00:29.295] - copied ‘...future.elements_ii’ to environment
[17:00:29.295] - copied ‘...future.seeds_ii’ to environment
[17:00:29.295] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.296] assign_globals() ... done
[17:00:29.296] requestCore(): workers = 2
[17:00:29.298] MulticoreFuture started
[17:00:29.299] - Launch lazy future ... done
[17:00:29.299] plan(): Setting new future strategy stack:
[17:00:29.299] run() for ‘MulticoreFuture’ ... done
[17:00:29.300] Created future:
[17:00:29.300] List of future strategies:
[17:00:29.300] 1. sequential:
[17:00:29.300]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.300]    - tweaked: FALSE
[17:00:29.300]    - call: NULL
[17:00:29.301] plan(): nbrOfWorkers() = 1
[17:00:29.304] plan(): Setting new future strategy stack:
[17:00:29.304] List of future strategies:
[17:00:29.304] 1. multicore:
[17:00:29.304]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.304]    - tweaked: FALSE
[17:00:29.304]    - call: plan(strategy)
[17:00:29.310] plan(): nbrOfWorkers() = 2
[17:00:29.300] MulticoreFuture:
[17:00:29.300] Label: ‘future_mapply-1’
[17:00:29.300] Expression:
[17:00:29.300] {
[17:00:29.300]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.300]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.300]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.300]         on.exit(options(oopts), add = TRUE)
[17:00:29.300]     }
[17:00:29.300]     {
[17:00:29.300]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.300]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.300]         do.call(mapply, args = args)
[17:00:29.300]     }
[17:00:29.300] }
[17:00:29.300] Lazy evaluation: FALSE
[17:00:29.300] Asynchronous evaluation: TRUE
[17:00:29.300] Local evaluation: TRUE
[17:00:29.300] Environment: R_GlobalEnv
[17:00:29.300] Capture standard output: TRUE
[17:00:29.300] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.300] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.300] Packages: <none>
[17:00:29.300] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.300] Resolved: TRUE
[17:00:29.300] Value: <not collected>
[17:00:29.300] Conditions captured: <none>
[17:00:29.300] Early signaling: FALSE
[17:00:29.300] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.300] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.311] Chunk #1 of 2 ... DONE
[17:00:29.311] Chunk #2 of 2 ...
[17:00:29.311]  - Finding globals in '...' for chunk #2 ...
[17:00:29.312] getGlobalsAndPackages() ...
[17:00:29.312] Searching for globals...
[17:00:29.312] 
[17:00:29.313] Searching for globals ... DONE
[17:00:29.313] - globals: [0] <none>
[17:00:29.313] getGlobalsAndPackages() ... DONE
[17:00:29.313]    + additional globals found: [n=0] 
[17:00:29.313]    + additional namespaces needed: [n=0] 
[17:00:29.313]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:29.313]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.314]  - seeds: <none>
[17:00:29.314]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.314] getGlobalsAndPackages() ...
[17:00:29.314] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.314] Resolving globals: FALSE
[17:00:29.315] The total size of the 5 globals is 224 bytes (224 bytes)
[17:00:29.316] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:29.316] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.317] 
[17:00:29.317] getGlobalsAndPackages() ... DONE
[17:00:29.317] run() for ‘Future’ ...
[17:00:29.317] - state: ‘created’
[17:00:29.318] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.322] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.323]   - Field: ‘label’
[17:00:29.323]   - Field: ‘local’
[17:00:29.323]   - Field: ‘owner’
[17:00:29.323]   - Field: ‘envir’
[17:00:29.323]   - Field: ‘workers’
[17:00:29.324]   - Field: ‘packages’
[17:00:29.324]   - Field: ‘gc’
[17:00:29.324]   - Field: ‘job’
[17:00:29.324]   - Field: ‘conditions’
[17:00:29.324]   - Field: ‘expr’
[17:00:29.324]   - Field: ‘uuid’
[17:00:29.324]   - Field: ‘seed’
[17:00:29.324]   - Field: ‘version’
[17:00:29.325]   - Field: ‘result’
[17:00:29.325]   - Field: ‘asynchronous’
[17:00:29.325]   - Field: ‘calls’
[17:00:29.325]   - Field: ‘globals’
[17:00:29.325]   - Field: ‘stdout’
[17:00:29.325]   - Field: ‘earlySignal’
[17:00:29.325]   - Field: ‘lazy’
[17:00:29.325]   - Field: ‘state’
[17:00:29.326] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.326] - Launch lazy future ...
[17:00:29.326] Packages needed by the future expression (n = 0): <none>
[17:00:29.326] Packages needed by future strategies (n = 0): <none>
[17:00:29.327] {
[17:00:29.327]     {
[17:00:29.327]         {
[17:00:29.327]             ...future.startTime <- base::Sys.time()
[17:00:29.327]             {
[17:00:29.327]                 {
[17:00:29.327]                   {
[17:00:29.327]                     {
[17:00:29.327]                       base::local({
[17:00:29.327]                         has_future <- base::requireNamespace("future", 
[17:00:29.327]                           quietly = TRUE)
[17:00:29.327]                         if (has_future) {
[17:00:29.327]                           ns <- base::getNamespace("future")
[17:00:29.327]                           version <- ns[[".package"]][["version"]]
[17:00:29.327]                           if (is.null(version)) 
[17:00:29.327]                             version <- utils::packageVersion("future")
[17:00:29.327]                         }
[17:00:29.327]                         else {
[17:00:29.327]                           version <- NULL
[17:00:29.327]                         }
[17:00:29.327]                         if (!has_future || version < "1.8.0") {
[17:00:29.327]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.327]                             "", base::R.version$version.string), 
[17:00:29.327]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.327]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.327]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.327]                               "release", "version")], collapse = " "), 
[17:00:29.327]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.327]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.327]                             info)
[17:00:29.327]                           info <- base::paste(info, collapse = "; ")
[17:00:29.327]                           if (!has_future) {
[17:00:29.327]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.327]                               info)
[17:00:29.327]                           }
[17:00:29.327]                           else {
[17:00:29.327]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.327]                               info, version)
[17:00:29.327]                           }
[17:00:29.327]                           base::stop(msg)
[17:00:29.327]                         }
[17:00:29.327]                       })
[17:00:29.327]                     }
[17:00:29.327]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.327]                     base::options(mc.cores = 1L)
[17:00:29.327]                   }
[17:00:29.327]                   ...future.strategy.old <- future::plan("list")
[17:00:29.327]                   options(future.plan = NULL)
[17:00:29.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.327]                 }
[17:00:29.327]                 ...future.workdir <- getwd()
[17:00:29.327]             }
[17:00:29.327]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.327]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.327]         }
[17:00:29.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.327]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.327]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.327]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.327]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.327]             base::names(...future.oldOptions))
[17:00:29.327]     }
[17:00:29.327]     if (FALSE) {
[17:00:29.327]     }
[17:00:29.327]     else {
[17:00:29.327]         if (TRUE) {
[17:00:29.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.327]                 open = "w")
[17:00:29.327]         }
[17:00:29.327]         else {
[17:00:29.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.327]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.327]         }
[17:00:29.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.327]             base::sink(type = "output", split = FALSE)
[17:00:29.327]             base::close(...future.stdout)
[17:00:29.327]         }, add = TRUE)
[17:00:29.327]     }
[17:00:29.327]     ...future.frame <- base::sys.nframe()
[17:00:29.327]     ...future.conditions <- base::list()
[17:00:29.327]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.327]     if (FALSE) {
[17:00:29.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.327]     }
[17:00:29.327]     ...future.result <- base::tryCatch({
[17:00:29.327]         base::withCallingHandlers({
[17:00:29.327]             ...future.value <- base::withVisible(base::local({
[17:00:29.327]                 withCallingHandlers({
[17:00:29.327]                   {
[17:00:29.327]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.327]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.327]                       ...future.globals.maxSize)) {
[17:00:29.327]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.327]                       on.exit(options(oopts), add = TRUE)
[17:00:29.327]                     }
[17:00:29.327]                     {
[17:00:29.327]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.327]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.327]                         USE.NAMES = FALSE)
[17:00:29.327]                       do.call(mapply, args = args)
[17:00:29.327]                     }
[17:00:29.327]                   }
[17:00:29.327]                 }, immediateCondition = function(cond) {
[17:00:29.327]                   save_rds <- function (object, pathname, ...) 
[17:00:29.327]                   {
[17:00:29.327]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.327]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.327]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.327]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.327]                         fi_tmp[["mtime"]])
[17:00:29.327]                     }
[17:00:29.327]                     tryCatch({
[17:00:29.327]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.327]                     }, error = function(ex) {
[17:00:29.327]                       msg <- conditionMessage(ex)
[17:00:29.327]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.327]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.327]                         fi_tmp[["mtime"]], msg)
[17:00:29.327]                       ex$message <- msg
[17:00:29.327]                       stop(ex)
[17:00:29.327]                     })
[17:00:29.327]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.327]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.327]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.327]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.327]                       fi <- file.info(pathname)
[17:00:29.327]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.327]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.327]                         fi[["size"]], fi[["mtime"]])
[17:00:29.327]                       stop(msg)
[17:00:29.327]                     }
[17:00:29.327]                     invisible(pathname)
[17:00:29.327]                   }
[17:00:29.327]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.327]                     rootPath = tempdir()) 
[17:00:29.327]                   {
[17:00:29.327]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.327]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.327]                       tmpdir = path, fileext = ".rds")
[17:00:29.327]                     save_rds(obj, file)
[17:00:29.327]                   }
[17:00:29.327]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.327]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.327]                   {
[17:00:29.327]                     inherits <- base::inherits
[17:00:29.327]                     invokeRestart <- base::invokeRestart
[17:00:29.327]                     is.null <- base::is.null
[17:00:29.327]                     muffled <- FALSE
[17:00:29.327]                     if (inherits(cond, "message")) {
[17:00:29.327]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.327]                       if (muffled) 
[17:00:29.327]                         invokeRestart("muffleMessage")
[17:00:29.327]                     }
[17:00:29.327]                     else if (inherits(cond, "warning")) {
[17:00:29.327]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.327]                       if (muffled) 
[17:00:29.327]                         invokeRestart("muffleWarning")
[17:00:29.327]                     }
[17:00:29.327]                     else if (inherits(cond, "condition")) {
[17:00:29.327]                       if (!is.null(pattern)) {
[17:00:29.327]                         computeRestarts <- base::computeRestarts
[17:00:29.327]                         grepl <- base::grepl
[17:00:29.327]                         restarts <- computeRestarts(cond)
[17:00:29.327]                         for (restart in restarts) {
[17:00:29.327]                           name <- restart$name
[17:00:29.327]                           if (is.null(name)) 
[17:00:29.327]                             next
[17:00:29.327]                           if (!grepl(pattern, name)) 
[17:00:29.327]                             next
[17:00:29.327]                           invokeRestart(restart)
[17:00:29.327]                           muffled <- TRUE
[17:00:29.327]                           break
[17:00:29.327]                         }
[17:00:29.327]                       }
[17:00:29.327]                     }
[17:00:29.327]                     invisible(muffled)
[17:00:29.327]                   }
[17:00:29.327]                   muffleCondition(cond)
[17:00:29.327]                 })
[17:00:29.327]             }))
[17:00:29.327]             future::FutureResult(value = ...future.value$value, 
[17:00:29.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.327]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.327]                     ...future.globalenv.names))
[17:00:29.327]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.327]         }, condition = base::local({
[17:00:29.327]             c <- base::c
[17:00:29.327]             inherits <- base::inherits
[17:00:29.327]             invokeRestart <- base::invokeRestart
[17:00:29.327]             length <- base::length
[17:00:29.327]             list <- base::list
[17:00:29.327]             seq.int <- base::seq.int
[17:00:29.327]             signalCondition <- base::signalCondition
[17:00:29.327]             sys.calls <- base::sys.calls
[17:00:29.327]             `[[` <- base::`[[`
[17:00:29.327]             `+` <- base::`+`
[17:00:29.327]             `<<-` <- base::`<<-`
[17:00:29.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.327]                   3L)]
[17:00:29.327]             }
[17:00:29.327]             function(cond) {
[17:00:29.327]                 is_error <- inherits(cond, "error")
[17:00:29.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.327]                   NULL)
[17:00:29.327]                 if (is_error) {
[17:00:29.327]                   sessionInformation <- function() {
[17:00:29.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.327]                       search = base::search(), system = base::Sys.info())
[17:00:29.327]                   }
[17:00:29.327]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.327]                     cond$call), session = sessionInformation(), 
[17:00:29.327]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.327]                   signalCondition(cond)
[17:00:29.327]                 }
[17:00:29.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.327]                 "immediateCondition"))) {
[17:00:29.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.327]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.327]                   if (TRUE && !signal) {
[17:00:29.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.327]                     {
[17:00:29.327]                       inherits <- base::inherits
[17:00:29.327]                       invokeRestart <- base::invokeRestart
[17:00:29.327]                       is.null <- base::is.null
[17:00:29.327]                       muffled <- FALSE
[17:00:29.327]                       if (inherits(cond, "message")) {
[17:00:29.327]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.327]                         if (muffled) 
[17:00:29.327]                           invokeRestart("muffleMessage")
[17:00:29.327]                       }
[17:00:29.327]                       else if (inherits(cond, "warning")) {
[17:00:29.327]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.327]                         if (muffled) 
[17:00:29.327]                           invokeRestart("muffleWarning")
[17:00:29.327]                       }
[17:00:29.327]                       else if (inherits(cond, "condition")) {
[17:00:29.327]                         if (!is.null(pattern)) {
[17:00:29.327]                           computeRestarts <- base::computeRestarts
[17:00:29.327]                           grepl <- base::grepl
[17:00:29.327]                           restarts <- computeRestarts(cond)
[17:00:29.327]                           for (restart in restarts) {
[17:00:29.327]                             name <- restart$name
[17:00:29.327]                             if (is.null(name)) 
[17:00:29.327]                               next
[17:00:29.327]                             if (!grepl(pattern, name)) 
[17:00:29.327]                               next
[17:00:29.327]                             invokeRestart(restart)
[17:00:29.327]                             muffled <- TRUE
[17:00:29.327]                             break
[17:00:29.327]                           }
[17:00:29.327]                         }
[17:00:29.327]                       }
[17:00:29.327]                       invisible(muffled)
[17:00:29.327]                     }
[17:00:29.327]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.327]                   }
[17:00:29.327]                 }
[17:00:29.327]                 else {
[17:00:29.327]                   if (TRUE) {
[17:00:29.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.327]                     {
[17:00:29.327]                       inherits <- base::inherits
[17:00:29.327]                       invokeRestart <- base::invokeRestart
[17:00:29.327]                       is.null <- base::is.null
[17:00:29.327]                       muffled <- FALSE
[17:00:29.327]                       if (inherits(cond, "message")) {
[17:00:29.327]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.327]                         if (muffled) 
[17:00:29.327]                           invokeRestart("muffleMessage")
[17:00:29.327]                       }
[17:00:29.327]                       else if (inherits(cond, "warning")) {
[17:00:29.327]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.327]                         if (muffled) 
[17:00:29.327]                           invokeRestart("muffleWarning")
[17:00:29.327]                       }
[17:00:29.327]                       else if (inherits(cond, "condition")) {
[17:00:29.327]                         if (!is.null(pattern)) {
[17:00:29.327]                           computeRestarts <- base::computeRestarts
[17:00:29.327]                           grepl <- base::grepl
[17:00:29.327]                           restarts <- computeRestarts(cond)
[17:00:29.327]                           for (restart in restarts) {
[17:00:29.327]                             name <- restart$name
[17:00:29.327]                             if (is.null(name)) 
[17:00:29.327]                               next
[17:00:29.327]                             if (!grepl(pattern, name)) 
[17:00:29.327]                               next
[17:00:29.327]                             invokeRestart(restart)
[17:00:29.327]                             muffled <- TRUE
[17:00:29.327]                             break
[17:00:29.327]                           }
[17:00:29.327]                         }
[17:00:29.327]                       }
[17:00:29.327]                       invisible(muffled)
[17:00:29.327]                     }
[17:00:29.327]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.327]                   }
[17:00:29.327]                 }
[17:00:29.327]             }
[17:00:29.327]         }))
[17:00:29.327]     }, error = function(ex) {
[17:00:29.327]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.327]                 ...future.rng), started = ...future.startTime, 
[17:00:29.327]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.327]             version = "1.8"), class = "FutureResult")
[17:00:29.327]     }, finally = {
[17:00:29.327]         if (!identical(...future.workdir, getwd())) 
[17:00:29.327]             setwd(...future.workdir)
[17:00:29.327]         {
[17:00:29.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.327]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.327]             }
[17:00:29.327]             base::options(...future.oldOptions)
[17:00:29.327]             if (.Platform$OS.type == "windows") {
[17:00:29.327]                 old_names <- names(...future.oldEnvVars)
[17:00:29.327]                 envs <- base::Sys.getenv()
[17:00:29.327]                 names <- names(envs)
[17:00:29.327]                 common <- intersect(names, old_names)
[17:00:29.327]                 added <- setdiff(names, old_names)
[17:00:29.327]                 removed <- setdiff(old_names, names)
[17:00:29.327]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.327]                   envs[common]]
[17:00:29.327]                 NAMES <- toupper(changed)
[17:00:29.327]                 args <- list()
[17:00:29.327]                 for (kk in seq_along(NAMES)) {
[17:00:29.327]                   name <- changed[[kk]]
[17:00:29.327]                   NAME <- NAMES[[kk]]
[17:00:29.327]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.327]                     next
[17:00:29.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.327]                 }
[17:00:29.327]                 NAMES <- toupper(added)
[17:00:29.327]                 for (kk in seq_along(NAMES)) {
[17:00:29.327]                   name <- added[[kk]]
[17:00:29.327]                   NAME <- NAMES[[kk]]
[17:00:29.327]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.327]                     next
[17:00:29.327]                   args[[name]] <- ""
[17:00:29.327]                 }
[17:00:29.327]                 NAMES <- toupper(removed)
[17:00:29.327]                 for (kk in seq_along(NAMES)) {
[17:00:29.327]                   name <- removed[[kk]]
[17:00:29.327]                   NAME <- NAMES[[kk]]
[17:00:29.327]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.327]                     next
[17:00:29.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.327]                 }
[17:00:29.327]                 if (length(args) > 0) 
[17:00:29.327]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.327]             }
[17:00:29.327]             else {
[17:00:29.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.327]             }
[17:00:29.327]             {
[17:00:29.327]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.327]                   0L) {
[17:00:29.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.327]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.327]                   base::options(opts)
[17:00:29.327]                 }
[17:00:29.327]                 {
[17:00:29.327]                   {
[17:00:29.327]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.327]                     NULL
[17:00:29.327]                   }
[17:00:29.327]                   options(future.plan = NULL)
[17:00:29.327]                   if (is.na(NA_character_)) 
[17:00:29.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.327]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.327]                     .init = FALSE)
[17:00:29.327]                 }
[17:00:29.327]             }
[17:00:29.327]         }
[17:00:29.327]     })
[17:00:29.327]     if (TRUE) {
[17:00:29.327]         base::sink(type = "output", split = FALSE)
[17:00:29.327]         if (TRUE) {
[17:00:29.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.327]         }
[17:00:29.327]         else {
[17:00:29.327]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.327]         }
[17:00:29.327]         base::close(...future.stdout)
[17:00:29.327]         ...future.stdout <- NULL
[17:00:29.327]     }
[17:00:29.327]     ...future.result$conditions <- ...future.conditions
[17:00:29.327]     ...future.result$finished <- base::Sys.time()
[17:00:29.327]     ...future.result
[17:00:29.327] }
[17:00:29.330] assign_globals() ...
[17:00:29.330] List of 5
[17:00:29.330]  $ ...future.FUN            :function (x, ...)  
[17:00:29.330]  $ MoreArgs                 :List of 1
[17:00:29.330]   ..$ x: num 42
[17:00:29.330]  $ ...future.elements_ii    :List of 1
[17:00:29.330]   ..$ times:List of 2
[17:00:29.330]   .. ..$ : int 3
[17:00:29.330]   .. ..$ : int 4
[17:00:29.330]  $ ...future.seeds_ii       : NULL
[17:00:29.330]  $ ...future.globals.maxSize: NULL
[17:00:29.330]  - attr(*, "where")=List of 5
[17:00:29.330]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.330]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.330]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.330]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.330]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.330]  - attr(*, "resolved")= logi FALSE
[17:00:29.330]  - attr(*, "total_size")= num 224
[17:00:29.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.330]  - attr(*, "already-done")= logi TRUE
[17:00:29.338] - copied ‘...future.FUN’ to environment
[17:00:29.338] - copied ‘MoreArgs’ to environment
[17:00:29.338] - copied ‘...future.elements_ii’ to environment
[17:00:29.339] - copied ‘...future.seeds_ii’ to environment
[17:00:29.339] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.339] assign_globals() ... done
[17:00:29.339] requestCore(): workers = 2
[17:00:29.341] MulticoreFuture started
[17:00:29.342] - Launch lazy future ... done
[17:00:29.342] run() for ‘MulticoreFuture’ ... done
[17:00:29.342] Created future:
[17:00:29.343] plan(): Setting new future strategy stack:
[17:00:29.343] List of future strategies:
[17:00:29.343] 1. sequential:
[17:00:29.343]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.343]    - tweaked: FALSE
[17:00:29.343]    - call: NULL
[17:00:29.344] plan(): nbrOfWorkers() = 1
[17:00:29.346] plan(): Setting new future strategy stack:
[17:00:29.346] List of future strategies:
[17:00:29.346] 1. multicore:
[17:00:29.346]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.346]    - tweaked: FALSE
[17:00:29.346]    - call: plan(strategy)
[17:00:29.343] MulticoreFuture:
[17:00:29.343] Label: ‘future_mapply-2’
[17:00:29.343] Expression:
[17:00:29.343] {
[17:00:29.343]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.343]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.343]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.343]         on.exit(options(oopts), add = TRUE)
[17:00:29.343]     }
[17:00:29.343]     {
[17:00:29.343]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.343]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.343]         do.call(mapply, args = args)
[17:00:29.343]     }
[17:00:29.343] }
[17:00:29.343] Lazy evaluation: FALSE
[17:00:29.343] Asynchronous evaluation: TRUE
[17:00:29.343] Local evaluation: TRUE
[17:00:29.343] Environment: R_GlobalEnv
[17:00:29.343] Capture standard output: TRUE
[17:00:29.343] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.343] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.343] Packages: <none>
[17:00:29.343] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.343] Resolved: FALSE
[17:00:29.343] Value: <not collected>
[17:00:29.343] Conditions captured: <none>
[17:00:29.343] Early signaling: FALSE
[17:00:29.343] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.343] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.355] Chunk #2 of 2 ... DONE
[17:00:29.356] Launching 2 futures (chunks) ... DONE
[17:00:29.356] Resolving 2 futures (chunks) ...
[17:00:29.356] resolve() on list ...
[17:00:29.356]  recursive: 0
[17:00:29.356]  length: 2
[17:00:29.356] 
[17:00:29.357] Future #1
[17:00:29.357] plan(): nbrOfWorkers() = 2
[17:00:29.357] result() for MulticoreFuture ...
[17:00:29.360] result() for MulticoreFuture ...
[17:00:29.361] result() for MulticoreFuture ... done
[17:00:29.361] result() for MulticoreFuture ... done
[17:00:29.361] result() for MulticoreFuture ...
[17:00:29.361] result() for MulticoreFuture ... done
[17:00:29.362] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:29.362] - nx: 2
[17:00:29.363] - relay: TRUE
[17:00:29.363] - stdout: TRUE
[17:00:29.363] - signal: TRUE
[17:00:29.363] - resignal: FALSE
[17:00:29.364] - force: TRUE
[17:00:29.364] - relayed: [n=2] FALSE, FALSE
[17:00:29.364] - queued futures: [n=2] FALSE, FALSE
[17:00:29.365]  - until=1
[17:00:29.365]  - relaying element #1
[17:00:29.365] result() for MulticoreFuture ...
[17:00:29.365] result() for MulticoreFuture ... done
[17:00:29.366] result() for MulticoreFuture ...
[17:00:29.366] result() for MulticoreFuture ... done
[17:00:29.366] result() for MulticoreFuture ...
[17:00:29.366] result() for MulticoreFuture ... done
[17:00:29.367] result() for MulticoreFuture ...
[17:00:29.367] result() for MulticoreFuture ... done
[17:00:29.367] - relayed: [n=2] TRUE, FALSE
[17:00:29.367] - queued futures: [n=2] TRUE, FALSE
[17:00:29.368] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:29.368]  length: 1 (resolved future 1)
[17:00:29.368] Future #2
[17:00:29.368] result() for MulticoreFuture ...
[17:00:29.369] result() for MulticoreFuture ...
[17:00:29.369] result() for MulticoreFuture ... done
[17:00:29.369] result() for MulticoreFuture ... done
[17:00:29.370] result() for MulticoreFuture ...
[17:00:29.370] result() for MulticoreFuture ... done
[17:00:29.370] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:29.370] - nx: 2
[17:00:29.370] - relay: TRUE
[17:00:29.370] - stdout: TRUE
[17:00:29.370] - signal: TRUE
[17:00:29.371] - resignal: FALSE
[17:00:29.371] - force: TRUE
[17:00:29.371] - relayed: [n=2] TRUE, FALSE
[17:00:29.371] - queued futures: [n=2] TRUE, FALSE
[17:00:29.371]  - until=2
[17:00:29.371]  - relaying element #2
[17:00:29.371] result() for MulticoreFuture ...
[17:00:29.371] result() for MulticoreFuture ... done
[17:00:29.371] result() for MulticoreFuture ...
[17:00:29.372] result() for MulticoreFuture ... done
[17:00:29.372] result() for MulticoreFuture ...
[17:00:29.372] result() for MulticoreFuture ... done
[17:00:29.372] result() for MulticoreFuture ...
[17:00:29.372] result() for MulticoreFuture ... done
[17:00:29.372] - relayed: [n=2] TRUE, TRUE
[17:00:29.372] - queued futures: [n=2] TRUE, TRUE
[17:00:29.372] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:29.373]  length: 0 (resolved future 2)
[17:00:29.373] Relaying remaining futures
[17:00:29.373] signalConditionsASAP(NULL, pos=0) ...
[17:00:29.373] - nx: 2
[17:00:29.373] - relay: TRUE
[17:00:29.373] - stdout: TRUE
[17:00:29.373] - signal: TRUE
[17:00:29.373] - resignal: FALSE
[17:00:29.373] - force: TRUE
[17:00:29.374] - relayed: [n=2] TRUE, TRUE
[17:00:29.374] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:29.374] - relayed: [n=2] TRUE, TRUE
[17:00:29.374] - queued futures: [n=2] TRUE, TRUE
[17:00:29.374] signalConditionsASAP(NULL, pos=0) ... done
[17:00:29.374] resolve() on list ... DONE
[17:00:29.374] result() for MulticoreFuture ...
[17:00:29.374] result() for MulticoreFuture ... done
[17:00:29.374] result() for MulticoreFuture ...
[17:00:29.374] result() for MulticoreFuture ... done
[17:00:29.375] result() for MulticoreFuture ...
[17:00:29.375] result() for MulticoreFuture ... done
[17:00:29.375] result() for MulticoreFuture ...
[17:00:29.375] result() for MulticoreFuture ... done
[17:00:29.375]  - Number of value chunks collected: 2
[17:00:29.375] Resolving 2 futures (chunks) ... DONE
[17:00:29.375] Reducing values from 2 chunks ...
[17:00:29.375]  - Number of values collected after concatenation: 4
[17:00:29.376]  - Number of values expected: 4
[17:00:29.376] Reducing values from 2 chunks ... DONE
[17:00:29.376] future_mapply() ... DONE
[17:00:29.376] future_mapply() ...
[17:00:29.380] Number of chunks: 2
[17:00:29.380] getGlobalsAndPackagesXApply() ...
[17:00:29.381]  - future.globals: TRUE
[17:00:29.381] getGlobalsAndPackages() ...
[17:00:29.381] Searching for globals...
[17:00:29.382] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:00:29.382] Searching for globals ... DONE
[17:00:29.383] Resolving globals: FALSE
[17:00:29.383] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:00:29.383] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:00:29.384] - globals: [1] ‘FUN’
[17:00:29.384] 
[17:00:29.384] getGlobalsAndPackages() ... DONE
[17:00:29.384]  - globals found/used: [n=1] ‘FUN’
[17:00:29.384]  - needed namespaces: [n=0] 
[17:00:29.384] Finding globals ... DONE
[17:00:29.384] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:29.384] List of 2
[17:00:29.384]  $ ...future.FUN:function (x, y)  
[17:00:29.384]  $ MoreArgs     : NULL
[17:00:29.384]  - attr(*, "where")=List of 2
[17:00:29.384]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:29.384]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:29.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.384]  - attr(*, "resolved")= logi FALSE
[17:00:29.384]  - attr(*, "total_size")= num NA
[17:00:29.387] Packages to be attached in all futures: [n=0] 
[17:00:29.387] getGlobalsAndPackagesXApply() ... DONE
[17:00:29.388] Number of futures (= number of chunks): 2
[17:00:29.388] Launching 2 futures (chunks) ...
[17:00:29.388] Chunk #1 of 2 ...
[17:00:29.388]  - Finding globals in '...' for chunk #1 ...
[17:00:29.388] getGlobalsAndPackages() ...
[17:00:29.388] Searching for globals...
[17:00:29.389] 
[17:00:29.389] Searching for globals ... DONE
[17:00:29.389] - globals: [0] <none>
[17:00:29.389] getGlobalsAndPackages() ... DONE
[17:00:29.389]    + additional globals found: [n=0] 
[17:00:29.389]    + additional namespaces needed: [n=0] 
[17:00:29.389]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:29.389]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.389]  - seeds: <none>
[17:00:29.389]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.390] getGlobalsAndPackages() ...
[17:00:29.390] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.390] Resolving globals: FALSE
[17:00:29.390] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:00:29.391] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.391] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.391] 
[17:00:29.391] getGlobalsAndPackages() ... DONE
[17:00:29.391] run() for ‘Future’ ...
[17:00:29.392] - state: ‘created’
[17:00:29.392] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.398] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.398] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.398]   - Field: ‘label’
[17:00:29.399]   - Field: ‘local’
[17:00:29.399]   - Field: ‘owner’
[17:00:29.399]   - Field: ‘envir’
[17:00:29.399]   - Field: ‘workers’
[17:00:29.399]   - Field: ‘packages’
[17:00:29.399]   - Field: ‘gc’
[17:00:29.399]   - Field: ‘job’
[17:00:29.400]   - Field: ‘conditions’
[17:00:29.400]   - Field: ‘expr’
[17:00:29.400]   - Field: ‘uuid’
[17:00:29.400]   - Field: ‘seed’
[17:00:29.400]   - Field: ‘version’
[17:00:29.400]   - Field: ‘result’
[17:00:29.400]   - Field: ‘asynchronous’
[17:00:29.400]   - Field: ‘calls’
[17:00:29.400]   - Field: ‘globals’
[17:00:29.401]   - Field: ‘stdout’
[17:00:29.401]   - Field: ‘earlySignal’
[17:00:29.401]   - Field: ‘lazy’
[17:00:29.401]   - Field: ‘state’
[17:00:29.401] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.401] - Launch lazy future ...
[17:00:29.401] Packages needed by the future expression (n = 0): <none>
[17:00:29.402] Packages needed by future strategies (n = 0): <none>
[17:00:29.402] {
[17:00:29.402]     {
[17:00:29.402]         {
[17:00:29.402]             ...future.startTime <- base::Sys.time()
[17:00:29.402]             {
[17:00:29.402]                 {
[17:00:29.402]                   {
[17:00:29.402]                     {
[17:00:29.402]                       base::local({
[17:00:29.402]                         has_future <- base::requireNamespace("future", 
[17:00:29.402]                           quietly = TRUE)
[17:00:29.402]                         if (has_future) {
[17:00:29.402]                           ns <- base::getNamespace("future")
[17:00:29.402]                           version <- ns[[".package"]][["version"]]
[17:00:29.402]                           if (is.null(version)) 
[17:00:29.402]                             version <- utils::packageVersion("future")
[17:00:29.402]                         }
[17:00:29.402]                         else {
[17:00:29.402]                           version <- NULL
[17:00:29.402]                         }
[17:00:29.402]                         if (!has_future || version < "1.8.0") {
[17:00:29.402]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.402]                             "", base::R.version$version.string), 
[17:00:29.402]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.402]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.402]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.402]                               "release", "version")], collapse = " "), 
[17:00:29.402]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.402]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.402]                             info)
[17:00:29.402]                           info <- base::paste(info, collapse = "; ")
[17:00:29.402]                           if (!has_future) {
[17:00:29.402]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.402]                               info)
[17:00:29.402]                           }
[17:00:29.402]                           else {
[17:00:29.402]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.402]                               info, version)
[17:00:29.402]                           }
[17:00:29.402]                           base::stop(msg)
[17:00:29.402]                         }
[17:00:29.402]                       })
[17:00:29.402]                     }
[17:00:29.402]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.402]                     base::options(mc.cores = 1L)
[17:00:29.402]                   }
[17:00:29.402]                   ...future.strategy.old <- future::plan("list")
[17:00:29.402]                   options(future.plan = NULL)
[17:00:29.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.402]                 }
[17:00:29.402]                 ...future.workdir <- getwd()
[17:00:29.402]             }
[17:00:29.402]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.402]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.402]         }
[17:00:29.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.402]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.402]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.402]             base::names(...future.oldOptions))
[17:00:29.402]     }
[17:00:29.402]     if (FALSE) {
[17:00:29.402]     }
[17:00:29.402]     else {
[17:00:29.402]         if (TRUE) {
[17:00:29.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.402]                 open = "w")
[17:00:29.402]         }
[17:00:29.402]         else {
[17:00:29.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.402]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.402]         }
[17:00:29.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.402]             base::sink(type = "output", split = FALSE)
[17:00:29.402]             base::close(...future.stdout)
[17:00:29.402]         }, add = TRUE)
[17:00:29.402]     }
[17:00:29.402]     ...future.frame <- base::sys.nframe()
[17:00:29.402]     ...future.conditions <- base::list()
[17:00:29.402]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.402]     if (FALSE) {
[17:00:29.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.402]     }
[17:00:29.402]     ...future.result <- base::tryCatch({
[17:00:29.402]         base::withCallingHandlers({
[17:00:29.402]             ...future.value <- base::withVisible(base::local({
[17:00:29.402]                 withCallingHandlers({
[17:00:29.402]                   {
[17:00:29.402]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.402]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.402]                       ...future.globals.maxSize)) {
[17:00:29.402]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.402]                       on.exit(options(oopts), add = TRUE)
[17:00:29.402]                     }
[17:00:29.402]                     {
[17:00:29.402]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.402]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.402]                         USE.NAMES = FALSE)
[17:00:29.402]                       do.call(mapply, args = args)
[17:00:29.402]                     }
[17:00:29.402]                   }
[17:00:29.402]                 }, immediateCondition = function(cond) {
[17:00:29.402]                   save_rds <- function (object, pathname, ...) 
[17:00:29.402]                   {
[17:00:29.402]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.402]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.402]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.402]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.402]                         fi_tmp[["mtime"]])
[17:00:29.402]                     }
[17:00:29.402]                     tryCatch({
[17:00:29.402]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.402]                     }, error = function(ex) {
[17:00:29.402]                       msg <- conditionMessage(ex)
[17:00:29.402]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.402]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.402]                         fi_tmp[["mtime"]], msg)
[17:00:29.402]                       ex$message <- msg
[17:00:29.402]                       stop(ex)
[17:00:29.402]                     })
[17:00:29.402]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.402]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.402]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.402]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.402]                       fi <- file.info(pathname)
[17:00:29.402]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.402]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.402]                         fi[["size"]], fi[["mtime"]])
[17:00:29.402]                       stop(msg)
[17:00:29.402]                     }
[17:00:29.402]                     invisible(pathname)
[17:00:29.402]                   }
[17:00:29.402]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.402]                     rootPath = tempdir()) 
[17:00:29.402]                   {
[17:00:29.402]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.402]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.402]                       tmpdir = path, fileext = ".rds")
[17:00:29.402]                     save_rds(obj, file)
[17:00:29.402]                   }
[17:00:29.402]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.402]                   {
[17:00:29.402]                     inherits <- base::inherits
[17:00:29.402]                     invokeRestart <- base::invokeRestart
[17:00:29.402]                     is.null <- base::is.null
[17:00:29.402]                     muffled <- FALSE
[17:00:29.402]                     if (inherits(cond, "message")) {
[17:00:29.402]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.402]                       if (muffled) 
[17:00:29.402]                         invokeRestart("muffleMessage")
[17:00:29.402]                     }
[17:00:29.402]                     else if (inherits(cond, "warning")) {
[17:00:29.402]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.402]                       if (muffled) 
[17:00:29.402]                         invokeRestart("muffleWarning")
[17:00:29.402]                     }
[17:00:29.402]                     else if (inherits(cond, "condition")) {
[17:00:29.402]                       if (!is.null(pattern)) {
[17:00:29.402]                         computeRestarts <- base::computeRestarts
[17:00:29.402]                         grepl <- base::grepl
[17:00:29.402]                         restarts <- computeRestarts(cond)
[17:00:29.402]                         for (restart in restarts) {
[17:00:29.402]                           name <- restart$name
[17:00:29.402]                           if (is.null(name)) 
[17:00:29.402]                             next
[17:00:29.402]                           if (!grepl(pattern, name)) 
[17:00:29.402]                             next
[17:00:29.402]                           invokeRestart(restart)
[17:00:29.402]                           muffled <- TRUE
[17:00:29.402]                           break
[17:00:29.402]                         }
[17:00:29.402]                       }
[17:00:29.402]                     }
[17:00:29.402]                     invisible(muffled)
[17:00:29.402]                   }
[17:00:29.402]                   muffleCondition(cond)
[17:00:29.402]                 })
[17:00:29.402]             }))
[17:00:29.402]             future::FutureResult(value = ...future.value$value, 
[17:00:29.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.402]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.402]                     ...future.globalenv.names))
[17:00:29.402]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.402]         }, condition = base::local({
[17:00:29.402]             c <- base::c
[17:00:29.402]             inherits <- base::inherits
[17:00:29.402]             invokeRestart <- base::invokeRestart
[17:00:29.402]             length <- base::length
[17:00:29.402]             list <- base::list
[17:00:29.402]             seq.int <- base::seq.int
[17:00:29.402]             signalCondition <- base::signalCondition
[17:00:29.402]             sys.calls <- base::sys.calls
[17:00:29.402]             `[[` <- base::`[[`
[17:00:29.402]             `+` <- base::`+`
[17:00:29.402]             `<<-` <- base::`<<-`
[17:00:29.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.402]                   3L)]
[17:00:29.402]             }
[17:00:29.402]             function(cond) {
[17:00:29.402]                 is_error <- inherits(cond, "error")
[17:00:29.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.402]                   NULL)
[17:00:29.402]                 if (is_error) {
[17:00:29.402]                   sessionInformation <- function() {
[17:00:29.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.402]                       search = base::search(), system = base::Sys.info())
[17:00:29.402]                   }
[17:00:29.402]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.402]                     cond$call), session = sessionInformation(), 
[17:00:29.402]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.402]                   signalCondition(cond)
[17:00:29.402]                 }
[17:00:29.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.402]                 "immediateCondition"))) {
[17:00:29.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.402]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.402]                   if (TRUE && !signal) {
[17:00:29.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.402]                     {
[17:00:29.402]                       inherits <- base::inherits
[17:00:29.402]                       invokeRestart <- base::invokeRestart
[17:00:29.402]                       is.null <- base::is.null
[17:00:29.402]                       muffled <- FALSE
[17:00:29.402]                       if (inherits(cond, "message")) {
[17:00:29.402]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.402]                         if (muffled) 
[17:00:29.402]                           invokeRestart("muffleMessage")
[17:00:29.402]                       }
[17:00:29.402]                       else if (inherits(cond, "warning")) {
[17:00:29.402]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.402]                         if (muffled) 
[17:00:29.402]                           invokeRestart("muffleWarning")
[17:00:29.402]                       }
[17:00:29.402]                       else if (inherits(cond, "condition")) {
[17:00:29.402]                         if (!is.null(pattern)) {
[17:00:29.402]                           computeRestarts <- base::computeRestarts
[17:00:29.402]                           grepl <- base::grepl
[17:00:29.402]                           restarts <- computeRestarts(cond)
[17:00:29.402]                           for (restart in restarts) {
[17:00:29.402]                             name <- restart$name
[17:00:29.402]                             if (is.null(name)) 
[17:00:29.402]                               next
[17:00:29.402]                             if (!grepl(pattern, name)) 
[17:00:29.402]                               next
[17:00:29.402]                             invokeRestart(restart)
[17:00:29.402]                             muffled <- TRUE
[17:00:29.402]                             break
[17:00:29.402]                           }
[17:00:29.402]                         }
[17:00:29.402]                       }
[17:00:29.402]                       invisible(muffled)
[17:00:29.402]                     }
[17:00:29.402]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.402]                   }
[17:00:29.402]                 }
[17:00:29.402]                 else {
[17:00:29.402]                   if (TRUE) {
[17:00:29.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.402]                     {
[17:00:29.402]                       inherits <- base::inherits
[17:00:29.402]                       invokeRestart <- base::invokeRestart
[17:00:29.402]                       is.null <- base::is.null
[17:00:29.402]                       muffled <- FALSE
[17:00:29.402]                       if (inherits(cond, "message")) {
[17:00:29.402]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.402]                         if (muffled) 
[17:00:29.402]                           invokeRestart("muffleMessage")
[17:00:29.402]                       }
[17:00:29.402]                       else if (inherits(cond, "warning")) {
[17:00:29.402]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.402]                         if (muffled) 
[17:00:29.402]                           invokeRestart("muffleWarning")
[17:00:29.402]                       }
[17:00:29.402]                       else if (inherits(cond, "condition")) {
[17:00:29.402]                         if (!is.null(pattern)) {
[17:00:29.402]                           computeRestarts <- base::computeRestarts
[17:00:29.402]                           grepl <- base::grepl
[17:00:29.402]                           restarts <- computeRestarts(cond)
[17:00:29.402]                           for (restart in restarts) {
[17:00:29.402]                             name <- restart$name
[17:00:29.402]                             if (is.null(name)) 
[17:00:29.402]                               next
[17:00:29.402]                             if (!grepl(pattern, name)) 
[17:00:29.402]                               next
[17:00:29.402]                             invokeRestart(restart)
[17:00:29.402]                             muffled <- TRUE
[17:00:29.402]                             break
[17:00:29.402]                           }
[17:00:29.402]                         }
[17:00:29.402]                       }
[17:00:29.402]                       invisible(muffled)
[17:00:29.402]                     }
[17:00:29.402]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.402]                   }
[17:00:29.402]                 }
[17:00:29.402]             }
[17:00:29.402]         }))
[17:00:29.402]     }, error = function(ex) {
[17:00:29.402]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.402]                 ...future.rng), started = ...future.startTime, 
[17:00:29.402]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.402]             version = "1.8"), class = "FutureResult")
[17:00:29.402]     }, finally = {
[17:00:29.402]         if (!identical(...future.workdir, getwd())) 
[17:00:29.402]             setwd(...future.workdir)
[17:00:29.402]         {
[17:00:29.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.402]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.402]             }
[17:00:29.402]             base::options(...future.oldOptions)
[17:00:29.402]             if (.Platform$OS.type == "windows") {
[17:00:29.402]                 old_names <- names(...future.oldEnvVars)
[17:00:29.402]                 envs <- base::Sys.getenv()
[17:00:29.402]                 names <- names(envs)
[17:00:29.402]                 common <- intersect(names, old_names)
[17:00:29.402]                 added <- setdiff(names, old_names)
[17:00:29.402]                 removed <- setdiff(old_names, names)
[17:00:29.402]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.402]                   envs[common]]
[17:00:29.402]                 NAMES <- toupper(changed)
[17:00:29.402]                 args <- list()
[17:00:29.402]                 for (kk in seq_along(NAMES)) {
[17:00:29.402]                   name <- changed[[kk]]
[17:00:29.402]                   NAME <- NAMES[[kk]]
[17:00:29.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.402]                     next
[17:00:29.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.402]                 }
[17:00:29.402]                 NAMES <- toupper(added)
[17:00:29.402]                 for (kk in seq_along(NAMES)) {
[17:00:29.402]                   name <- added[[kk]]
[17:00:29.402]                   NAME <- NAMES[[kk]]
[17:00:29.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.402]                     next
[17:00:29.402]                   args[[name]] <- ""
[17:00:29.402]                 }
[17:00:29.402]                 NAMES <- toupper(removed)
[17:00:29.402]                 for (kk in seq_along(NAMES)) {
[17:00:29.402]                   name <- removed[[kk]]
[17:00:29.402]                   NAME <- NAMES[[kk]]
[17:00:29.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.402]                     next
[17:00:29.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.402]                 }
[17:00:29.402]                 if (length(args) > 0) 
[17:00:29.402]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.402]             }
[17:00:29.402]             else {
[17:00:29.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.402]             }
[17:00:29.402]             {
[17:00:29.402]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.402]                   0L) {
[17:00:29.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.402]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.402]                   base::options(opts)
[17:00:29.402]                 }
[17:00:29.402]                 {
[17:00:29.402]                   {
[17:00:29.402]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.402]                     NULL
[17:00:29.402]                   }
[17:00:29.402]                   options(future.plan = NULL)
[17:00:29.402]                   if (is.na(NA_character_)) 
[17:00:29.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.402]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.402]                     .init = FALSE)
[17:00:29.402]                 }
[17:00:29.402]             }
[17:00:29.402]         }
[17:00:29.402]     })
[17:00:29.402]     if (TRUE) {
[17:00:29.402]         base::sink(type = "output", split = FALSE)
[17:00:29.402]         if (TRUE) {
[17:00:29.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.402]         }
[17:00:29.402]         else {
[17:00:29.402]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.402]         }
[17:00:29.402]         base::close(...future.stdout)
[17:00:29.402]         ...future.stdout <- NULL
[17:00:29.402]     }
[17:00:29.402]     ...future.result$conditions <- ...future.conditions
[17:00:29.402]     ...future.result$finished <- base::Sys.time()
[17:00:29.402]     ...future.result
[17:00:29.402] }
[17:00:29.404] assign_globals() ...
[17:00:29.405] List of 5
[17:00:29.405]  $ ...future.FUN            :function (x, y)  
[17:00:29.405]  $ MoreArgs                 : NULL
[17:00:29.405]  $ ...future.elements_ii    :List of 2
[17:00:29.405]   ..$ :List of 1
[17:00:29.405]   .. ..$ a: num 1
[17:00:29.405]   ..$ :List of 1
[17:00:29.405]   .. ..$ A: num 10
[17:00:29.405]  $ ...future.seeds_ii       : NULL
[17:00:29.405]  $ ...future.globals.maxSize: NULL
[17:00:29.405]  - attr(*, "where")=List of 5
[17:00:29.405]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.405]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.405]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.405]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.405]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.405]  - attr(*, "resolved")= logi FALSE
[17:00:29.405]  - attr(*, "total_size")= num 2088
[17:00:29.405]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.405]  - attr(*, "already-done")= logi TRUE
[17:00:29.410] - reassign environment for ‘...future.FUN’
[17:00:29.410] - copied ‘...future.FUN’ to environment
[17:00:29.410] - copied ‘MoreArgs’ to environment
[17:00:29.410] - copied ‘...future.elements_ii’ to environment
[17:00:29.410] - copied ‘...future.seeds_ii’ to environment
[17:00:29.410] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.410] assign_globals() ... done
[17:00:29.410] requestCore(): workers = 2
[17:00:29.413] MulticoreFuture started
[17:00:29.413] - Launch lazy future ... done
[17:00:29.413] run() for ‘MulticoreFuture’ ... done
[17:00:29.413] Created future:
[17:00:29.414] plan(): Setting new future strategy stack:
[17:00:29.414] List of future strategies:
[17:00:29.414] 1. sequential:
[17:00:29.414]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.414]    - tweaked: FALSE
[17:00:29.414]    - call: NULL
[17:00:29.415] plan(): nbrOfWorkers() = 1
[17:00:29.417] plan(): Setting new future strategy stack:
[17:00:29.417] List of future strategies:
[17:00:29.417] 1. multicore:
[17:00:29.417]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.417]    - tweaked: FALSE
[17:00:29.417]    - call: plan(strategy)
[17:00:29.422] plan(): nbrOfWorkers() = 2
[17:00:29.414] MulticoreFuture:
[17:00:29.414] Label: ‘future_mapply-1’
[17:00:29.414] Expression:
[17:00:29.414] {
[17:00:29.414]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.414]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.414]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.414]         on.exit(options(oopts), add = TRUE)
[17:00:29.414]     }
[17:00:29.414]     {
[17:00:29.414]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.414]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.414]         do.call(mapply, args = args)
[17:00:29.414]     }
[17:00:29.414] }
[17:00:29.414] Lazy evaluation: FALSE
[17:00:29.414] Asynchronous evaluation: TRUE
[17:00:29.414] Local evaluation: TRUE
[17:00:29.414] Environment: R_GlobalEnv
[17:00:29.414] Capture standard output: TRUE
[17:00:29.414] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.414] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.414] Packages: <none>
[17:00:29.414] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.414] Resolved: TRUE
[17:00:29.414] Value: <not collected>
[17:00:29.414] Conditions captured: <none>
[17:00:29.414] Early signaling: FALSE
[17:00:29.414] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.414] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.423] Chunk #1 of 2 ... DONE
[17:00:29.424] Chunk #2 of 2 ...
[17:00:29.424]  - Finding globals in '...' for chunk #2 ...
[17:00:29.424] getGlobalsAndPackages() ...
[17:00:29.424] Searching for globals...
[17:00:29.425] 
[17:00:29.425] Searching for globals ... DONE
[17:00:29.425] - globals: [0] <none>
[17:00:29.425] getGlobalsAndPackages() ... DONE
[17:00:29.425]    + additional globals found: [n=0] 
[17:00:29.425]    + additional namespaces needed: [n=0] 
[17:00:29.425]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:29.426]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.426]  - seeds: <none>
[17:00:29.426]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.426] getGlobalsAndPackages() ...
[17:00:29.426] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.426] Resolving globals: FALSE
[17:00:29.427] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:00:29.428] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.428] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.429] 
[17:00:29.429] getGlobalsAndPackages() ... DONE
[17:00:29.429] run() for ‘Future’ ...
[17:00:29.429] - state: ‘created’
[17:00:29.430] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.435] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.435]   - Field: ‘label’
[17:00:29.435]   - Field: ‘local’
[17:00:29.435]   - Field: ‘owner’
[17:00:29.435]   - Field: ‘envir’
[17:00:29.436]   - Field: ‘workers’
[17:00:29.436]   - Field: ‘packages’
[17:00:29.436]   - Field: ‘gc’
[17:00:29.436]   - Field: ‘job’
[17:00:29.436]   - Field: ‘conditions’
[17:00:29.436]   - Field: ‘expr’
[17:00:29.436]   - Field: ‘uuid’
[17:00:29.437]   - Field: ‘seed’
[17:00:29.437]   - Field: ‘version’
[17:00:29.437]   - Field: ‘result’
[17:00:29.437]   - Field: ‘asynchronous’
[17:00:29.437]   - Field: ‘calls’
[17:00:29.437]   - Field: ‘globals’
[17:00:29.438]   - Field: ‘stdout’
[17:00:29.438]   - Field: ‘earlySignal’
[17:00:29.438]   - Field: ‘lazy’
[17:00:29.438]   - Field: ‘state’
[17:00:29.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.438] - Launch lazy future ...
[17:00:29.439] Packages needed by the future expression (n = 0): <none>
[17:00:29.439] Packages needed by future strategies (n = 0): <none>
[17:00:29.440] {
[17:00:29.440]     {
[17:00:29.440]         {
[17:00:29.440]             ...future.startTime <- base::Sys.time()
[17:00:29.440]             {
[17:00:29.440]                 {
[17:00:29.440]                   {
[17:00:29.440]                     {
[17:00:29.440]                       base::local({
[17:00:29.440]                         has_future <- base::requireNamespace("future", 
[17:00:29.440]                           quietly = TRUE)
[17:00:29.440]                         if (has_future) {
[17:00:29.440]                           ns <- base::getNamespace("future")
[17:00:29.440]                           version <- ns[[".package"]][["version"]]
[17:00:29.440]                           if (is.null(version)) 
[17:00:29.440]                             version <- utils::packageVersion("future")
[17:00:29.440]                         }
[17:00:29.440]                         else {
[17:00:29.440]                           version <- NULL
[17:00:29.440]                         }
[17:00:29.440]                         if (!has_future || version < "1.8.0") {
[17:00:29.440]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.440]                             "", base::R.version$version.string), 
[17:00:29.440]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.440]                               "release", "version")], collapse = " "), 
[17:00:29.440]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.440]                             info)
[17:00:29.440]                           info <- base::paste(info, collapse = "; ")
[17:00:29.440]                           if (!has_future) {
[17:00:29.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.440]                               info)
[17:00:29.440]                           }
[17:00:29.440]                           else {
[17:00:29.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.440]                               info, version)
[17:00:29.440]                           }
[17:00:29.440]                           base::stop(msg)
[17:00:29.440]                         }
[17:00:29.440]                       })
[17:00:29.440]                     }
[17:00:29.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.440]                     base::options(mc.cores = 1L)
[17:00:29.440]                   }
[17:00:29.440]                   ...future.strategy.old <- future::plan("list")
[17:00:29.440]                   options(future.plan = NULL)
[17:00:29.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.440]                 }
[17:00:29.440]                 ...future.workdir <- getwd()
[17:00:29.440]             }
[17:00:29.440]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.440]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.440]         }
[17:00:29.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.440]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.440]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.440]             base::names(...future.oldOptions))
[17:00:29.440]     }
[17:00:29.440]     if (FALSE) {
[17:00:29.440]     }
[17:00:29.440]     else {
[17:00:29.440]         if (TRUE) {
[17:00:29.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.440]                 open = "w")
[17:00:29.440]         }
[17:00:29.440]         else {
[17:00:29.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.440]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.440]         }
[17:00:29.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.440]             base::sink(type = "output", split = FALSE)
[17:00:29.440]             base::close(...future.stdout)
[17:00:29.440]         }, add = TRUE)
[17:00:29.440]     }
[17:00:29.440]     ...future.frame <- base::sys.nframe()
[17:00:29.440]     ...future.conditions <- base::list()
[17:00:29.440]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.440]     if (FALSE) {
[17:00:29.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.440]     }
[17:00:29.440]     ...future.result <- base::tryCatch({
[17:00:29.440]         base::withCallingHandlers({
[17:00:29.440]             ...future.value <- base::withVisible(base::local({
[17:00:29.440]                 withCallingHandlers({
[17:00:29.440]                   {
[17:00:29.440]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.440]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.440]                       ...future.globals.maxSize)) {
[17:00:29.440]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.440]                       on.exit(options(oopts), add = TRUE)
[17:00:29.440]                     }
[17:00:29.440]                     {
[17:00:29.440]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.440]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.440]                         USE.NAMES = FALSE)
[17:00:29.440]                       do.call(mapply, args = args)
[17:00:29.440]                     }
[17:00:29.440]                   }
[17:00:29.440]                 }, immediateCondition = function(cond) {
[17:00:29.440]                   save_rds <- function (object, pathname, ...) 
[17:00:29.440]                   {
[17:00:29.440]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.440]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.440]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.440]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.440]                         fi_tmp[["mtime"]])
[17:00:29.440]                     }
[17:00:29.440]                     tryCatch({
[17:00:29.440]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.440]                     }, error = function(ex) {
[17:00:29.440]                       msg <- conditionMessage(ex)
[17:00:29.440]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.440]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.440]                         fi_tmp[["mtime"]], msg)
[17:00:29.440]                       ex$message <- msg
[17:00:29.440]                       stop(ex)
[17:00:29.440]                     })
[17:00:29.440]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.440]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.440]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.440]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.440]                       fi <- file.info(pathname)
[17:00:29.440]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.440]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.440]                         fi[["size"]], fi[["mtime"]])
[17:00:29.440]                       stop(msg)
[17:00:29.440]                     }
[17:00:29.440]                     invisible(pathname)
[17:00:29.440]                   }
[17:00:29.440]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.440]                     rootPath = tempdir()) 
[17:00:29.440]                   {
[17:00:29.440]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.440]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.440]                       tmpdir = path, fileext = ".rds")
[17:00:29.440]                     save_rds(obj, file)
[17:00:29.440]                   }
[17:00:29.440]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.440]                   {
[17:00:29.440]                     inherits <- base::inherits
[17:00:29.440]                     invokeRestart <- base::invokeRestart
[17:00:29.440]                     is.null <- base::is.null
[17:00:29.440]                     muffled <- FALSE
[17:00:29.440]                     if (inherits(cond, "message")) {
[17:00:29.440]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.440]                       if (muffled) 
[17:00:29.440]                         invokeRestart("muffleMessage")
[17:00:29.440]                     }
[17:00:29.440]                     else if (inherits(cond, "warning")) {
[17:00:29.440]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.440]                       if (muffled) 
[17:00:29.440]                         invokeRestart("muffleWarning")
[17:00:29.440]                     }
[17:00:29.440]                     else if (inherits(cond, "condition")) {
[17:00:29.440]                       if (!is.null(pattern)) {
[17:00:29.440]                         computeRestarts <- base::computeRestarts
[17:00:29.440]                         grepl <- base::grepl
[17:00:29.440]                         restarts <- computeRestarts(cond)
[17:00:29.440]                         for (restart in restarts) {
[17:00:29.440]                           name <- restart$name
[17:00:29.440]                           if (is.null(name)) 
[17:00:29.440]                             next
[17:00:29.440]                           if (!grepl(pattern, name)) 
[17:00:29.440]                             next
[17:00:29.440]                           invokeRestart(restart)
[17:00:29.440]                           muffled <- TRUE
[17:00:29.440]                           break
[17:00:29.440]                         }
[17:00:29.440]                       }
[17:00:29.440]                     }
[17:00:29.440]                     invisible(muffled)
[17:00:29.440]                   }
[17:00:29.440]                   muffleCondition(cond)
[17:00:29.440]                 })
[17:00:29.440]             }))
[17:00:29.440]             future::FutureResult(value = ...future.value$value, 
[17:00:29.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.440]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.440]                     ...future.globalenv.names))
[17:00:29.440]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.440]         }, condition = base::local({
[17:00:29.440]             c <- base::c
[17:00:29.440]             inherits <- base::inherits
[17:00:29.440]             invokeRestart <- base::invokeRestart
[17:00:29.440]             length <- base::length
[17:00:29.440]             list <- base::list
[17:00:29.440]             seq.int <- base::seq.int
[17:00:29.440]             signalCondition <- base::signalCondition
[17:00:29.440]             sys.calls <- base::sys.calls
[17:00:29.440]             `[[` <- base::`[[`
[17:00:29.440]             `+` <- base::`+`
[17:00:29.440]             `<<-` <- base::`<<-`
[17:00:29.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.440]                   3L)]
[17:00:29.440]             }
[17:00:29.440]             function(cond) {
[17:00:29.440]                 is_error <- inherits(cond, "error")
[17:00:29.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.440]                   NULL)
[17:00:29.440]                 if (is_error) {
[17:00:29.440]                   sessionInformation <- function() {
[17:00:29.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.440]                       search = base::search(), system = base::Sys.info())
[17:00:29.440]                   }
[17:00:29.440]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.440]                     cond$call), session = sessionInformation(), 
[17:00:29.440]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.440]                   signalCondition(cond)
[17:00:29.440]                 }
[17:00:29.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.440]                 "immediateCondition"))) {
[17:00:29.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.440]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.440]                   if (TRUE && !signal) {
[17:00:29.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.440]                     {
[17:00:29.440]                       inherits <- base::inherits
[17:00:29.440]                       invokeRestart <- base::invokeRestart
[17:00:29.440]                       is.null <- base::is.null
[17:00:29.440]                       muffled <- FALSE
[17:00:29.440]                       if (inherits(cond, "message")) {
[17:00:29.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.440]                         if (muffled) 
[17:00:29.440]                           invokeRestart("muffleMessage")
[17:00:29.440]                       }
[17:00:29.440]                       else if (inherits(cond, "warning")) {
[17:00:29.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.440]                         if (muffled) 
[17:00:29.440]                           invokeRestart("muffleWarning")
[17:00:29.440]                       }
[17:00:29.440]                       else if (inherits(cond, "condition")) {
[17:00:29.440]                         if (!is.null(pattern)) {
[17:00:29.440]                           computeRestarts <- base::computeRestarts
[17:00:29.440]                           grepl <- base::grepl
[17:00:29.440]                           restarts <- computeRestarts(cond)
[17:00:29.440]                           for (restart in restarts) {
[17:00:29.440]                             name <- restart$name
[17:00:29.440]                             if (is.null(name)) 
[17:00:29.440]                               next
[17:00:29.440]                             if (!grepl(pattern, name)) 
[17:00:29.440]                               next
[17:00:29.440]                             invokeRestart(restart)
[17:00:29.440]                             muffled <- TRUE
[17:00:29.440]                             break
[17:00:29.440]                           }
[17:00:29.440]                         }
[17:00:29.440]                       }
[17:00:29.440]                       invisible(muffled)
[17:00:29.440]                     }
[17:00:29.440]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.440]                   }
[17:00:29.440]                 }
[17:00:29.440]                 else {
[17:00:29.440]                   if (TRUE) {
[17:00:29.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.440]                     {
[17:00:29.440]                       inherits <- base::inherits
[17:00:29.440]                       invokeRestart <- base::invokeRestart
[17:00:29.440]                       is.null <- base::is.null
[17:00:29.440]                       muffled <- FALSE
[17:00:29.440]                       if (inherits(cond, "message")) {
[17:00:29.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.440]                         if (muffled) 
[17:00:29.440]                           invokeRestart("muffleMessage")
[17:00:29.440]                       }
[17:00:29.440]                       else if (inherits(cond, "warning")) {
[17:00:29.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.440]                         if (muffled) 
[17:00:29.440]                           invokeRestart("muffleWarning")
[17:00:29.440]                       }
[17:00:29.440]                       else if (inherits(cond, "condition")) {
[17:00:29.440]                         if (!is.null(pattern)) {
[17:00:29.440]                           computeRestarts <- base::computeRestarts
[17:00:29.440]                           grepl <- base::grepl
[17:00:29.440]                           restarts <- computeRestarts(cond)
[17:00:29.440]                           for (restart in restarts) {
[17:00:29.440]                             name <- restart$name
[17:00:29.440]                             if (is.null(name)) 
[17:00:29.440]                               next
[17:00:29.440]                             if (!grepl(pattern, name)) 
[17:00:29.440]                               next
[17:00:29.440]                             invokeRestart(restart)
[17:00:29.440]                             muffled <- TRUE
[17:00:29.440]                             break
[17:00:29.440]                           }
[17:00:29.440]                         }
[17:00:29.440]                       }
[17:00:29.440]                       invisible(muffled)
[17:00:29.440]                     }
[17:00:29.440]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.440]                   }
[17:00:29.440]                 }
[17:00:29.440]             }
[17:00:29.440]         }))
[17:00:29.440]     }, error = function(ex) {
[17:00:29.440]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.440]                 ...future.rng), started = ...future.startTime, 
[17:00:29.440]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.440]             version = "1.8"), class = "FutureResult")
[17:00:29.440]     }, finally = {
[17:00:29.440]         if (!identical(...future.workdir, getwd())) 
[17:00:29.440]             setwd(...future.workdir)
[17:00:29.440]         {
[17:00:29.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.440]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.440]             }
[17:00:29.440]             base::options(...future.oldOptions)
[17:00:29.440]             if (.Platform$OS.type == "windows") {
[17:00:29.440]                 old_names <- names(...future.oldEnvVars)
[17:00:29.440]                 envs <- base::Sys.getenv()
[17:00:29.440]                 names <- names(envs)
[17:00:29.440]                 common <- intersect(names, old_names)
[17:00:29.440]                 added <- setdiff(names, old_names)
[17:00:29.440]                 removed <- setdiff(old_names, names)
[17:00:29.440]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.440]                   envs[common]]
[17:00:29.440]                 NAMES <- toupper(changed)
[17:00:29.440]                 args <- list()
[17:00:29.440]                 for (kk in seq_along(NAMES)) {
[17:00:29.440]                   name <- changed[[kk]]
[17:00:29.440]                   NAME <- NAMES[[kk]]
[17:00:29.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.440]                     next
[17:00:29.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.440]                 }
[17:00:29.440]                 NAMES <- toupper(added)
[17:00:29.440]                 for (kk in seq_along(NAMES)) {
[17:00:29.440]                   name <- added[[kk]]
[17:00:29.440]                   NAME <- NAMES[[kk]]
[17:00:29.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.440]                     next
[17:00:29.440]                   args[[name]] <- ""
[17:00:29.440]                 }
[17:00:29.440]                 NAMES <- toupper(removed)
[17:00:29.440]                 for (kk in seq_along(NAMES)) {
[17:00:29.440]                   name <- removed[[kk]]
[17:00:29.440]                   NAME <- NAMES[[kk]]
[17:00:29.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.440]                     next
[17:00:29.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.440]                 }
[17:00:29.440]                 if (length(args) > 0) 
[17:00:29.440]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.440]             }
[17:00:29.440]             else {
[17:00:29.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.440]             }
[17:00:29.440]             {
[17:00:29.440]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.440]                   0L) {
[17:00:29.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.440]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.440]                   base::options(opts)
[17:00:29.440]                 }
[17:00:29.440]                 {
[17:00:29.440]                   {
[17:00:29.440]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.440]                     NULL
[17:00:29.440]                   }
[17:00:29.440]                   options(future.plan = NULL)
[17:00:29.440]                   if (is.na(NA_character_)) 
[17:00:29.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.440]                     .init = FALSE)
[17:00:29.440]                 }
[17:00:29.440]             }
[17:00:29.440]         }
[17:00:29.440]     })
[17:00:29.440]     if (TRUE) {
[17:00:29.440]         base::sink(type = "output", split = FALSE)
[17:00:29.440]         if (TRUE) {
[17:00:29.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.440]         }
[17:00:29.440]         else {
[17:00:29.440]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.440]         }
[17:00:29.440]         base::close(...future.stdout)
[17:00:29.440]         ...future.stdout <- NULL
[17:00:29.440]     }
[17:00:29.440]     ...future.result$conditions <- ...future.conditions
[17:00:29.440]     ...future.result$finished <- base::Sys.time()
[17:00:29.440]     ...future.result
[17:00:29.440] }
[17:00:29.446] assign_globals() ...
[17:00:29.447] List of 5
[17:00:29.447]  $ ...future.FUN            :function (x, y)  
[17:00:29.447]  $ MoreArgs                 : NULL
[17:00:29.447]  $ ...future.elements_ii    :List of 2
[17:00:29.447]   ..$ :List of 2
[17:00:29.447]   .. ..$ b: num 2
[17:00:29.447]   .. ..$ c: num 3
[17:00:29.447]   ..$ :List of 2
[17:00:29.447]   .. ..$ B: num 0
[17:00:29.447]   .. ..$ C: num -10
[17:00:29.447]  $ ...future.seeds_ii       : NULL
[17:00:29.447]  $ ...future.globals.maxSize: NULL
[17:00:29.447]  - attr(*, "where")=List of 5
[17:00:29.447]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.447]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.447]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.447]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.447]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.447]  - attr(*, "resolved")= logi FALSE
[17:00:29.447]  - attr(*, "total_size")= num 2200
[17:00:29.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.447]  - attr(*, "already-done")= logi TRUE
[17:00:29.458] - reassign environment for ‘...future.FUN’
[17:00:29.458] - copied ‘...future.FUN’ to environment
[17:00:29.458] - copied ‘MoreArgs’ to environment
[17:00:29.458] - copied ‘...future.elements_ii’ to environment
[17:00:29.458] - copied ‘...future.seeds_ii’ to environment
[17:00:29.458] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.459] assign_globals() ... done
[17:00:29.459] requestCore(): workers = 2
[17:00:29.461] MulticoreFuture started
[17:00:29.462] - Launch lazy future ... done
[17:00:29.462] run() for ‘MulticoreFuture’ ... done
[17:00:29.462] Created future:
[17:00:29.462] plan(): Setting new future strategy stack:
[17:00:29.463] List of future strategies:
[17:00:29.463] 1. sequential:
[17:00:29.463]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.463]    - tweaked: FALSE
[17:00:29.463]    - call: NULL
[17:00:29.464] plan(): nbrOfWorkers() = 1
[17:00:29.466] plan(): Setting new future strategy stack:
[17:00:29.466] List of future strategies:
[17:00:29.466] 1. multicore:
[17:00:29.466]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.466]    - tweaked: FALSE
[17:00:29.466]    - call: plan(strategy)
[17:00:29.471] plan(): nbrOfWorkers() = 2
[17:00:29.462] MulticoreFuture:
[17:00:29.462] Label: ‘future_mapply-2’
[17:00:29.462] Expression:
[17:00:29.462] {
[17:00:29.462]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.462]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.462]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.462]         on.exit(options(oopts), add = TRUE)
[17:00:29.462]     }
[17:00:29.462]     {
[17:00:29.462]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.462]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.462]         do.call(mapply, args = args)
[17:00:29.462]     }
[17:00:29.462] }
[17:00:29.462] Lazy evaluation: FALSE
[17:00:29.462] Asynchronous evaluation: TRUE
[17:00:29.462] Local evaluation: TRUE
[17:00:29.462] Environment: R_GlobalEnv
[17:00:29.462] Capture standard output: TRUE
[17:00:29.462] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.462] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.462] Packages: <none>
[17:00:29.462] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.462] Resolved: TRUE
[17:00:29.462] Value: <not collected>
[17:00:29.462] Conditions captured: <none>
[17:00:29.462] Early signaling: FALSE
[17:00:29.462] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.462] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.472] Chunk #2 of 2 ... DONE
[17:00:29.472] Launching 2 futures (chunks) ... DONE
[17:00:29.472] Resolving 2 futures (chunks) ...
[17:00:29.473] resolve() on list ...
[17:00:29.473]  recursive: 0
[17:00:29.473]  length: 2
[17:00:29.473] 
[17:00:29.473] Future #1
[17:00:29.474] result() for MulticoreFuture ...
[17:00:29.474] result() for MulticoreFuture ...
[17:00:29.475] result() for MulticoreFuture ... done
[17:00:29.475] result() for MulticoreFuture ... done
[17:00:29.475] result() for MulticoreFuture ...
[17:00:29.475] result() for MulticoreFuture ... done
[17:00:29.475] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:29.475] - nx: 2
[17:00:29.475] - relay: TRUE
[17:00:29.476] - stdout: TRUE
[17:00:29.476] - signal: TRUE
[17:00:29.476] - resignal: FALSE
[17:00:29.476] - force: TRUE
[17:00:29.476] - relayed: [n=2] FALSE, FALSE
[17:00:29.476] - queued futures: [n=2] FALSE, FALSE
[17:00:29.476]  - until=1
[17:00:29.477]  - relaying element #1
[17:00:29.477] result() for MulticoreFuture ...
[17:00:29.477] result() for MulticoreFuture ... done
[17:00:29.477] result() for MulticoreFuture ...
[17:00:29.477] result() for MulticoreFuture ... done
[17:00:29.477] result() for MulticoreFuture ...
[17:00:29.478] result() for MulticoreFuture ... done
[17:00:29.478] result() for MulticoreFuture ...
[17:00:29.478] result() for MulticoreFuture ... done
[17:00:29.478] - relayed: [n=2] TRUE, FALSE
[17:00:29.478] - queued futures: [n=2] TRUE, FALSE
[17:00:29.478] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:29.478]  length: 1 (resolved future 1)
[17:00:29.479] Future #2
[17:00:29.479] result() for MulticoreFuture ...
[17:00:29.480] result() for MulticoreFuture ...
[17:00:29.480] result() for MulticoreFuture ... done
[17:00:29.480] result() for MulticoreFuture ... done
[17:00:29.480] result() for MulticoreFuture ...
[17:00:29.480] result() for MulticoreFuture ... done
[17:00:29.481] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:29.481] - nx: 2
[17:00:29.481] - relay: TRUE
[17:00:29.481] - stdout: TRUE
[17:00:29.481] - signal: TRUE
[17:00:29.481] - resignal: FALSE
[17:00:29.482] - force: TRUE
[17:00:29.482] - relayed: [n=2] TRUE, FALSE
[17:00:29.482] - queued futures: [n=2] TRUE, FALSE
[17:00:29.482]  - until=2
[17:00:29.482]  - relaying element #2
[17:00:29.482] result() for MulticoreFuture ...
[17:00:29.483] result() for MulticoreFuture ... done
[17:00:29.483] result() for MulticoreFuture ...
[17:00:29.483] result() for MulticoreFuture ... done
[17:00:29.483] result() for MulticoreFuture ...
[17:00:29.483] result() for MulticoreFuture ... done
[17:00:29.483] result() for MulticoreFuture ...
[17:00:29.483] result() for MulticoreFuture ... done
[17:00:29.483] - relayed: [n=2] TRUE, TRUE
[17:00:29.484] - queued futures: [n=2] TRUE, TRUE
[17:00:29.484] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:29.484]  length: 0 (resolved future 2)
[17:00:29.484] Relaying remaining futures
[17:00:29.484] signalConditionsASAP(NULL, pos=0) ...
[17:00:29.484] - nx: 2
[17:00:29.484] - relay: TRUE
[17:00:29.484] - stdout: TRUE
[17:00:29.484] - signal: TRUE
[17:00:29.485] - resignal: FALSE
[17:00:29.485] - force: TRUE
[17:00:29.485] - relayed: [n=2] TRUE, TRUE
[17:00:29.485] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:29.485] - relayed: [n=2] TRUE, TRUE
[17:00:29.485] - queued futures: [n=2] TRUE, TRUE
[17:00:29.485] signalConditionsASAP(NULL, pos=0) ... done
[17:00:29.485] resolve() on list ... DONE
[17:00:29.486] result() for MulticoreFuture ...
[17:00:29.486] result() for MulticoreFuture ... done
[17:00:29.486] result() for MulticoreFuture ...
[17:00:29.486] result() for MulticoreFuture ... done
[17:00:29.486] result() for MulticoreFuture ...
[17:00:29.486] result() for MulticoreFuture ... done
[17:00:29.486] result() for MulticoreFuture ...
[17:00:29.486] result() for MulticoreFuture ... done
[17:00:29.486]  - Number of value chunks collected: 2
[17:00:29.487] Resolving 2 futures (chunks) ... DONE
[17:00:29.487] Reducing values from 2 chunks ...
[17:00:29.487]  - Number of values collected after concatenation: 3
[17:00:29.487]  - Number of values expected: 3
[17:00:29.487] Reducing values from 2 chunks ... DONE
[17:00:29.487] future_mapply() ... DONE
- future_.mapply()
[17:00:29.488] future_mapply() ...
[17:00:29.495] Number of chunks: 2
[17:00:29.495] getGlobalsAndPackagesXApply() ...
[17:00:29.495]  - future.globals: TRUE
[17:00:29.495] getGlobalsAndPackages() ...
[17:00:29.495] Searching for globals...
[17:00:29.497] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:00:29.498] Searching for globals ... DONE
[17:00:29.498] Resolving globals: FALSE
[17:00:29.498] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:00:29.499] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:00:29.499] - globals: [1] ‘FUN’
[17:00:29.499] 
[17:00:29.499] getGlobalsAndPackages() ... DONE
[17:00:29.499]  - globals found/used: [n=1] ‘FUN’
[17:00:29.499]  - needed namespaces: [n=0] 
[17:00:29.500] Finding globals ... DONE
[17:00:29.500] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:29.500] List of 2
[17:00:29.500]  $ ...future.FUN:function (x, y)  
[17:00:29.500]  $ MoreArgs     : list()
[17:00:29.500]  - attr(*, "where")=List of 2
[17:00:29.500]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:29.500]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:29.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.500]  - attr(*, "resolved")= logi FALSE
[17:00:29.500]  - attr(*, "total_size")= num NA
[17:00:29.503] Packages to be attached in all futures: [n=0] 
[17:00:29.503] getGlobalsAndPackagesXApply() ... DONE
[17:00:29.503] Number of futures (= number of chunks): 2
[17:00:29.503] Launching 2 futures (chunks) ...
[17:00:29.504] Chunk #1 of 2 ...
[17:00:29.504]  - Finding globals in '...' for chunk #1 ...
[17:00:29.504] getGlobalsAndPackages() ...
[17:00:29.504] Searching for globals...
[17:00:29.504] 
[17:00:29.504] Searching for globals ... DONE
[17:00:29.504] - globals: [0] <none>
[17:00:29.505] getGlobalsAndPackages() ... DONE
[17:00:29.505]    + additional globals found: [n=0] 
[17:00:29.505]    + additional namespaces needed: [n=0] 
[17:00:29.505]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:29.505]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.505]  - seeds: <none>
[17:00:29.505]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.505] getGlobalsAndPackages() ...
[17:00:29.505] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.505] Resolving globals: FALSE
[17:00:29.506] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:00:29.506] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:29.506] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.507] 
[17:00:29.507] getGlobalsAndPackages() ... DONE
[17:00:29.507] run() for ‘Future’ ...
[17:00:29.507] - state: ‘created’
[17:00:29.507] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.511] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.511]   - Field: ‘label’
[17:00:29.511]   - Field: ‘local’
[17:00:29.511]   - Field: ‘owner’
[17:00:29.512]   - Field: ‘envir’
[17:00:29.512]   - Field: ‘workers’
[17:00:29.512]   - Field: ‘packages’
[17:00:29.512]   - Field: ‘gc’
[17:00:29.512]   - Field: ‘job’
[17:00:29.512]   - Field: ‘conditions’
[17:00:29.512]   - Field: ‘expr’
[17:00:29.512]   - Field: ‘uuid’
[17:00:29.512]   - Field: ‘seed’
[17:00:29.512]   - Field: ‘version’
[17:00:29.512]   - Field: ‘result’
[17:00:29.513]   - Field: ‘asynchronous’
[17:00:29.513]   - Field: ‘calls’
[17:00:29.513]   - Field: ‘globals’
[17:00:29.513]   - Field: ‘stdout’
[17:00:29.513]   - Field: ‘earlySignal’
[17:00:29.513]   - Field: ‘lazy’
[17:00:29.513]   - Field: ‘state’
[17:00:29.513] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.513] - Launch lazy future ...
[17:00:29.514] Packages needed by the future expression (n = 0): <none>
[17:00:29.514] Packages needed by future strategies (n = 0): <none>
[17:00:29.514] {
[17:00:29.514]     {
[17:00:29.514]         {
[17:00:29.514]             ...future.startTime <- base::Sys.time()
[17:00:29.514]             {
[17:00:29.514]                 {
[17:00:29.514]                   {
[17:00:29.514]                     {
[17:00:29.514]                       base::local({
[17:00:29.514]                         has_future <- base::requireNamespace("future", 
[17:00:29.514]                           quietly = TRUE)
[17:00:29.514]                         if (has_future) {
[17:00:29.514]                           ns <- base::getNamespace("future")
[17:00:29.514]                           version <- ns[[".package"]][["version"]]
[17:00:29.514]                           if (is.null(version)) 
[17:00:29.514]                             version <- utils::packageVersion("future")
[17:00:29.514]                         }
[17:00:29.514]                         else {
[17:00:29.514]                           version <- NULL
[17:00:29.514]                         }
[17:00:29.514]                         if (!has_future || version < "1.8.0") {
[17:00:29.514]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.514]                             "", base::R.version$version.string), 
[17:00:29.514]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.514]                               "release", "version")], collapse = " "), 
[17:00:29.514]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.514]                             info)
[17:00:29.514]                           info <- base::paste(info, collapse = "; ")
[17:00:29.514]                           if (!has_future) {
[17:00:29.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.514]                               info)
[17:00:29.514]                           }
[17:00:29.514]                           else {
[17:00:29.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.514]                               info, version)
[17:00:29.514]                           }
[17:00:29.514]                           base::stop(msg)
[17:00:29.514]                         }
[17:00:29.514]                       })
[17:00:29.514]                     }
[17:00:29.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.514]                     base::options(mc.cores = 1L)
[17:00:29.514]                   }
[17:00:29.514]                   ...future.strategy.old <- future::plan("list")
[17:00:29.514]                   options(future.plan = NULL)
[17:00:29.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.514]                 }
[17:00:29.514]                 ...future.workdir <- getwd()
[17:00:29.514]             }
[17:00:29.514]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.514]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.514]         }
[17:00:29.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.514]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.514]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.514]             base::names(...future.oldOptions))
[17:00:29.514]     }
[17:00:29.514]     if (FALSE) {
[17:00:29.514]     }
[17:00:29.514]     else {
[17:00:29.514]         if (TRUE) {
[17:00:29.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.514]                 open = "w")
[17:00:29.514]         }
[17:00:29.514]         else {
[17:00:29.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.514]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.514]         }
[17:00:29.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.514]             base::sink(type = "output", split = FALSE)
[17:00:29.514]             base::close(...future.stdout)
[17:00:29.514]         }, add = TRUE)
[17:00:29.514]     }
[17:00:29.514]     ...future.frame <- base::sys.nframe()
[17:00:29.514]     ...future.conditions <- base::list()
[17:00:29.514]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.514]     if (FALSE) {
[17:00:29.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.514]     }
[17:00:29.514]     ...future.result <- base::tryCatch({
[17:00:29.514]         base::withCallingHandlers({
[17:00:29.514]             ...future.value <- base::withVisible(base::local({
[17:00:29.514]                 withCallingHandlers({
[17:00:29.514]                   {
[17:00:29.514]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.514]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.514]                       ...future.globals.maxSize)) {
[17:00:29.514]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.514]                       on.exit(options(oopts), add = TRUE)
[17:00:29.514]                     }
[17:00:29.514]                     {
[17:00:29.514]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.514]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.514]                         USE.NAMES = FALSE)
[17:00:29.514]                       do.call(mapply, args = args)
[17:00:29.514]                     }
[17:00:29.514]                   }
[17:00:29.514]                 }, immediateCondition = function(cond) {
[17:00:29.514]                   save_rds <- function (object, pathname, ...) 
[17:00:29.514]                   {
[17:00:29.514]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.514]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.514]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.514]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.514]                         fi_tmp[["mtime"]])
[17:00:29.514]                     }
[17:00:29.514]                     tryCatch({
[17:00:29.514]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.514]                     }, error = function(ex) {
[17:00:29.514]                       msg <- conditionMessage(ex)
[17:00:29.514]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.514]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.514]                         fi_tmp[["mtime"]], msg)
[17:00:29.514]                       ex$message <- msg
[17:00:29.514]                       stop(ex)
[17:00:29.514]                     })
[17:00:29.514]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.514]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.514]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.514]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.514]                       fi <- file.info(pathname)
[17:00:29.514]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.514]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.514]                         fi[["size"]], fi[["mtime"]])
[17:00:29.514]                       stop(msg)
[17:00:29.514]                     }
[17:00:29.514]                     invisible(pathname)
[17:00:29.514]                   }
[17:00:29.514]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.514]                     rootPath = tempdir()) 
[17:00:29.514]                   {
[17:00:29.514]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.514]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.514]                       tmpdir = path, fileext = ".rds")
[17:00:29.514]                     save_rds(obj, file)
[17:00:29.514]                   }
[17:00:29.514]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.514]                   {
[17:00:29.514]                     inherits <- base::inherits
[17:00:29.514]                     invokeRestart <- base::invokeRestart
[17:00:29.514]                     is.null <- base::is.null
[17:00:29.514]                     muffled <- FALSE
[17:00:29.514]                     if (inherits(cond, "message")) {
[17:00:29.514]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.514]                       if (muffled) 
[17:00:29.514]                         invokeRestart("muffleMessage")
[17:00:29.514]                     }
[17:00:29.514]                     else if (inherits(cond, "warning")) {
[17:00:29.514]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.514]                       if (muffled) 
[17:00:29.514]                         invokeRestart("muffleWarning")
[17:00:29.514]                     }
[17:00:29.514]                     else if (inherits(cond, "condition")) {
[17:00:29.514]                       if (!is.null(pattern)) {
[17:00:29.514]                         computeRestarts <- base::computeRestarts
[17:00:29.514]                         grepl <- base::grepl
[17:00:29.514]                         restarts <- computeRestarts(cond)
[17:00:29.514]                         for (restart in restarts) {
[17:00:29.514]                           name <- restart$name
[17:00:29.514]                           if (is.null(name)) 
[17:00:29.514]                             next
[17:00:29.514]                           if (!grepl(pattern, name)) 
[17:00:29.514]                             next
[17:00:29.514]                           invokeRestart(restart)
[17:00:29.514]                           muffled <- TRUE
[17:00:29.514]                           break
[17:00:29.514]                         }
[17:00:29.514]                       }
[17:00:29.514]                     }
[17:00:29.514]                     invisible(muffled)
[17:00:29.514]                   }
[17:00:29.514]                   muffleCondition(cond)
[17:00:29.514]                 })
[17:00:29.514]             }))
[17:00:29.514]             future::FutureResult(value = ...future.value$value, 
[17:00:29.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.514]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.514]                     ...future.globalenv.names))
[17:00:29.514]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.514]         }, condition = base::local({
[17:00:29.514]             c <- base::c
[17:00:29.514]             inherits <- base::inherits
[17:00:29.514]             invokeRestart <- base::invokeRestart
[17:00:29.514]             length <- base::length
[17:00:29.514]             list <- base::list
[17:00:29.514]             seq.int <- base::seq.int
[17:00:29.514]             signalCondition <- base::signalCondition
[17:00:29.514]             sys.calls <- base::sys.calls
[17:00:29.514]             `[[` <- base::`[[`
[17:00:29.514]             `+` <- base::`+`
[17:00:29.514]             `<<-` <- base::`<<-`
[17:00:29.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.514]                   3L)]
[17:00:29.514]             }
[17:00:29.514]             function(cond) {
[17:00:29.514]                 is_error <- inherits(cond, "error")
[17:00:29.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.514]                   NULL)
[17:00:29.514]                 if (is_error) {
[17:00:29.514]                   sessionInformation <- function() {
[17:00:29.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.514]                       search = base::search(), system = base::Sys.info())
[17:00:29.514]                   }
[17:00:29.514]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.514]                     cond$call), session = sessionInformation(), 
[17:00:29.514]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.514]                   signalCondition(cond)
[17:00:29.514]                 }
[17:00:29.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.514]                 "immediateCondition"))) {
[17:00:29.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.514]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.514]                   if (TRUE && !signal) {
[17:00:29.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.514]                     {
[17:00:29.514]                       inherits <- base::inherits
[17:00:29.514]                       invokeRestart <- base::invokeRestart
[17:00:29.514]                       is.null <- base::is.null
[17:00:29.514]                       muffled <- FALSE
[17:00:29.514]                       if (inherits(cond, "message")) {
[17:00:29.514]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.514]                         if (muffled) 
[17:00:29.514]                           invokeRestart("muffleMessage")
[17:00:29.514]                       }
[17:00:29.514]                       else if (inherits(cond, "warning")) {
[17:00:29.514]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.514]                         if (muffled) 
[17:00:29.514]                           invokeRestart("muffleWarning")
[17:00:29.514]                       }
[17:00:29.514]                       else if (inherits(cond, "condition")) {
[17:00:29.514]                         if (!is.null(pattern)) {
[17:00:29.514]                           computeRestarts <- base::computeRestarts
[17:00:29.514]                           grepl <- base::grepl
[17:00:29.514]                           restarts <- computeRestarts(cond)
[17:00:29.514]                           for (restart in restarts) {
[17:00:29.514]                             name <- restart$name
[17:00:29.514]                             if (is.null(name)) 
[17:00:29.514]                               next
[17:00:29.514]                             if (!grepl(pattern, name)) 
[17:00:29.514]                               next
[17:00:29.514]                             invokeRestart(restart)
[17:00:29.514]                             muffled <- TRUE
[17:00:29.514]                             break
[17:00:29.514]                           }
[17:00:29.514]                         }
[17:00:29.514]                       }
[17:00:29.514]                       invisible(muffled)
[17:00:29.514]                     }
[17:00:29.514]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.514]                   }
[17:00:29.514]                 }
[17:00:29.514]                 else {
[17:00:29.514]                   if (TRUE) {
[17:00:29.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.514]                     {
[17:00:29.514]                       inherits <- base::inherits
[17:00:29.514]                       invokeRestart <- base::invokeRestart
[17:00:29.514]                       is.null <- base::is.null
[17:00:29.514]                       muffled <- FALSE
[17:00:29.514]                       if (inherits(cond, "message")) {
[17:00:29.514]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.514]                         if (muffled) 
[17:00:29.514]                           invokeRestart("muffleMessage")
[17:00:29.514]                       }
[17:00:29.514]                       else if (inherits(cond, "warning")) {
[17:00:29.514]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.514]                         if (muffled) 
[17:00:29.514]                           invokeRestart("muffleWarning")
[17:00:29.514]                       }
[17:00:29.514]                       else if (inherits(cond, "condition")) {
[17:00:29.514]                         if (!is.null(pattern)) {
[17:00:29.514]                           computeRestarts <- base::computeRestarts
[17:00:29.514]                           grepl <- base::grepl
[17:00:29.514]                           restarts <- computeRestarts(cond)
[17:00:29.514]                           for (restart in restarts) {
[17:00:29.514]                             name <- restart$name
[17:00:29.514]                             if (is.null(name)) 
[17:00:29.514]                               next
[17:00:29.514]                             if (!grepl(pattern, name)) 
[17:00:29.514]                               next
[17:00:29.514]                             invokeRestart(restart)
[17:00:29.514]                             muffled <- TRUE
[17:00:29.514]                             break
[17:00:29.514]                           }
[17:00:29.514]                         }
[17:00:29.514]                       }
[17:00:29.514]                       invisible(muffled)
[17:00:29.514]                     }
[17:00:29.514]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.514]                   }
[17:00:29.514]                 }
[17:00:29.514]             }
[17:00:29.514]         }))
[17:00:29.514]     }, error = function(ex) {
[17:00:29.514]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.514]                 ...future.rng), started = ...future.startTime, 
[17:00:29.514]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.514]             version = "1.8"), class = "FutureResult")
[17:00:29.514]     }, finally = {
[17:00:29.514]         if (!identical(...future.workdir, getwd())) 
[17:00:29.514]             setwd(...future.workdir)
[17:00:29.514]         {
[17:00:29.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.514]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.514]             }
[17:00:29.514]             base::options(...future.oldOptions)
[17:00:29.514]             if (.Platform$OS.type == "windows") {
[17:00:29.514]                 old_names <- names(...future.oldEnvVars)
[17:00:29.514]                 envs <- base::Sys.getenv()
[17:00:29.514]                 names <- names(envs)
[17:00:29.514]                 common <- intersect(names, old_names)
[17:00:29.514]                 added <- setdiff(names, old_names)
[17:00:29.514]                 removed <- setdiff(old_names, names)
[17:00:29.514]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.514]                   envs[common]]
[17:00:29.514]                 NAMES <- toupper(changed)
[17:00:29.514]                 args <- list()
[17:00:29.514]                 for (kk in seq_along(NAMES)) {
[17:00:29.514]                   name <- changed[[kk]]
[17:00:29.514]                   NAME <- NAMES[[kk]]
[17:00:29.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.514]                     next
[17:00:29.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.514]                 }
[17:00:29.514]                 NAMES <- toupper(added)
[17:00:29.514]                 for (kk in seq_along(NAMES)) {
[17:00:29.514]                   name <- added[[kk]]
[17:00:29.514]                   NAME <- NAMES[[kk]]
[17:00:29.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.514]                     next
[17:00:29.514]                   args[[name]] <- ""
[17:00:29.514]                 }
[17:00:29.514]                 NAMES <- toupper(removed)
[17:00:29.514]                 for (kk in seq_along(NAMES)) {
[17:00:29.514]                   name <- removed[[kk]]
[17:00:29.514]                   NAME <- NAMES[[kk]]
[17:00:29.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.514]                     next
[17:00:29.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.514]                 }
[17:00:29.514]                 if (length(args) > 0) 
[17:00:29.514]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.514]             }
[17:00:29.514]             else {
[17:00:29.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.514]             }
[17:00:29.514]             {
[17:00:29.514]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.514]                   0L) {
[17:00:29.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.514]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.514]                   base::options(opts)
[17:00:29.514]                 }
[17:00:29.514]                 {
[17:00:29.514]                   {
[17:00:29.514]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.514]                     NULL
[17:00:29.514]                   }
[17:00:29.514]                   options(future.plan = NULL)
[17:00:29.514]                   if (is.na(NA_character_)) 
[17:00:29.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.514]                     .init = FALSE)
[17:00:29.514]                 }
[17:00:29.514]             }
[17:00:29.514]         }
[17:00:29.514]     })
[17:00:29.514]     if (TRUE) {
[17:00:29.514]         base::sink(type = "output", split = FALSE)
[17:00:29.514]         if (TRUE) {
[17:00:29.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.514]         }
[17:00:29.514]         else {
[17:00:29.514]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.514]         }
[17:00:29.514]         base::close(...future.stdout)
[17:00:29.514]         ...future.stdout <- NULL
[17:00:29.514]     }
[17:00:29.514]     ...future.result$conditions <- ...future.conditions
[17:00:29.514]     ...future.result$finished <- base::Sys.time()
[17:00:29.514]     ...future.result
[17:00:29.514] }
[17:00:29.517] assign_globals() ...
[17:00:29.517] List of 5
[17:00:29.517]  $ ...future.FUN            :function (x, y)  
[17:00:29.517]  $ MoreArgs                 : list()
[17:00:29.517]  $ ...future.elements_ii    :List of 2
[17:00:29.517]   ..$ :List of 1
[17:00:29.517]   .. ..$ a: num 1
[17:00:29.517]   ..$ :List of 1
[17:00:29.517]   .. ..$ A: num 10
[17:00:29.517]  $ ...future.seeds_ii       : NULL
[17:00:29.517]  $ ...future.globals.maxSize: NULL
[17:00:29.517]  - attr(*, "where")=List of 5
[17:00:29.517]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.517]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.517]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.517]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.517]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.517]  - attr(*, "resolved")= logi FALSE
[17:00:29.517]  - attr(*, "total_size")= num 2088
[17:00:29.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.517]  - attr(*, "already-done")= logi TRUE
[17:00:29.524] - reassign environment for ‘...future.FUN’
[17:00:29.524] - copied ‘...future.FUN’ to environment
[17:00:29.525] - copied ‘MoreArgs’ to environment
[17:00:29.525] - copied ‘...future.elements_ii’ to environment
[17:00:29.525] - copied ‘...future.seeds_ii’ to environment
[17:00:29.525] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.525] assign_globals() ... done
[17:00:29.525] requestCore(): workers = 2
[17:00:29.528] MulticoreFuture started
[17:00:29.528] - Launch lazy future ... done
[17:00:29.529] plan(): Setting new future strategy stack:
[17:00:29.529] run() for ‘MulticoreFuture’ ... done
[17:00:29.530] Created future:
[17:00:29.529] List of future strategies:
[17:00:29.529] 1. sequential:
[17:00:29.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.529]    - tweaked: FALSE
[17:00:29.529]    - call: NULL
[17:00:29.531] plan(): nbrOfWorkers() = 1
[17:00:29.534] plan(): Setting new future strategy stack:
[17:00:29.535] List of future strategies:
[17:00:29.535] 1. multicore:
[17:00:29.535]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.535]    - tweaked: FALSE
[17:00:29.535]    - call: plan(strategy)
[17:00:29.541] plan(): nbrOfWorkers() = 2
[17:00:29.530] MulticoreFuture:
[17:00:29.530] Label: ‘future_.mapply-1’
[17:00:29.530] Expression:
[17:00:29.530] {
[17:00:29.530]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.530]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.530]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.530]         on.exit(options(oopts), add = TRUE)
[17:00:29.530]     }
[17:00:29.530]     {
[17:00:29.530]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.530]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.530]         do.call(mapply, args = args)
[17:00:29.530]     }
[17:00:29.530] }
[17:00:29.530] Lazy evaluation: FALSE
[17:00:29.530] Asynchronous evaluation: TRUE
[17:00:29.530] Local evaluation: TRUE
[17:00:29.530] Environment: R_GlobalEnv
[17:00:29.530] Capture standard output: TRUE
[17:00:29.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.530] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.530] Packages: <none>
[17:00:29.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.530] Resolved: TRUE
[17:00:29.530] Value: <not collected>
[17:00:29.530] Conditions captured: <none>
[17:00:29.530] Early signaling: FALSE
[17:00:29.530] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.530] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.542] Chunk #1 of 2 ... DONE
[17:00:29.542] Chunk #2 of 2 ...
[17:00:29.542]  - Finding globals in '...' for chunk #2 ...
[17:00:29.543] getGlobalsAndPackages() ...
[17:00:29.543] Searching for globals...
[17:00:29.544] 
[17:00:29.544] Searching for globals ... DONE
[17:00:29.544] - globals: [0] <none>
[17:00:29.544] getGlobalsAndPackages() ... DONE
[17:00:29.544]    + additional globals found: [n=0] 
[17:00:29.544]    + additional namespaces needed: [n=0] 
[17:00:29.544]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:29.545]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.545]  - seeds: <none>
[17:00:29.545]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.545] getGlobalsAndPackages() ...
[17:00:29.545] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.545] Resolving globals: FALSE
[17:00:29.546] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:00:29.547] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:29.547] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.547] 
[17:00:29.548] getGlobalsAndPackages() ... DONE
[17:00:29.548] run() for ‘Future’ ...
[17:00:29.548] - state: ‘created’
[17:00:29.549] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.553] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.554] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.554]   - Field: ‘label’
[17:00:29.554]   - Field: ‘local’
[17:00:29.554]   - Field: ‘owner’
[17:00:29.554]   - Field: ‘envir’
[17:00:29.554]   - Field: ‘workers’
[17:00:29.554]   - Field: ‘packages’
[17:00:29.555]   - Field: ‘gc’
[17:00:29.555]   - Field: ‘job’
[17:00:29.555]   - Field: ‘conditions’
[17:00:29.555]   - Field: ‘expr’
[17:00:29.555]   - Field: ‘uuid’
[17:00:29.555]   - Field: ‘seed’
[17:00:29.556]   - Field: ‘version’
[17:00:29.556]   - Field: ‘result’
[17:00:29.556]   - Field: ‘asynchronous’
[17:00:29.556]   - Field: ‘calls’
[17:00:29.556]   - Field: ‘globals’
[17:00:29.556]   - Field: ‘stdout’
[17:00:29.556]   - Field: ‘earlySignal’
[17:00:29.556]   - Field: ‘lazy’
[17:00:29.557]   - Field: ‘state’
[17:00:29.557] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.557] - Launch lazy future ...
[17:00:29.557] Packages needed by the future expression (n = 0): <none>
[17:00:29.557] Packages needed by future strategies (n = 0): <none>
[17:00:29.558] {
[17:00:29.558]     {
[17:00:29.558]         {
[17:00:29.558]             ...future.startTime <- base::Sys.time()
[17:00:29.558]             {
[17:00:29.558]                 {
[17:00:29.558]                   {
[17:00:29.558]                     {
[17:00:29.558]                       base::local({
[17:00:29.558]                         has_future <- base::requireNamespace("future", 
[17:00:29.558]                           quietly = TRUE)
[17:00:29.558]                         if (has_future) {
[17:00:29.558]                           ns <- base::getNamespace("future")
[17:00:29.558]                           version <- ns[[".package"]][["version"]]
[17:00:29.558]                           if (is.null(version)) 
[17:00:29.558]                             version <- utils::packageVersion("future")
[17:00:29.558]                         }
[17:00:29.558]                         else {
[17:00:29.558]                           version <- NULL
[17:00:29.558]                         }
[17:00:29.558]                         if (!has_future || version < "1.8.0") {
[17:00:29.558]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.558]                             "", base::R.version$version.string), 
[17:00:29.558]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.558]                               "release", "version")], collapse = " "), 
[17:00:29.558]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.558]                             info)
[17:00:29.558]                           info <- base::paste(info, collapse = "; ")
[17:00:29.558]                           if (!has_future) {
[17:00:29.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.558]                               info)
[17:00:29.558]                           }
[17:00:29.558]                           else {
[17:00:29.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.558]                               info, version)
[17:00:29.558]                           }
[17:00:29.558]                           base::stop(msg)
[17:00:29.558]                         }
[17:00:29.558]                       })
[17:00:29.558]                     }
[17:00:29.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.558]                     base::options(mc.cores = 1L)
[17:00:29.558]                   }
[17:00:29.558]                   ...future.strategy.old <- future::plan("list")
[17:00:29.558]                   options(future.plan = NULL)
[17:00:29.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.558]                 }
[17:00:29.558]                 ...future.workdir <- getwd()
[17:00:29.558]             }
[17:00:29.558]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.558]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.558]         }
[17:00:29.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.558]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.558]             base::names(...future.oldOptions))
[17:00:29.558]     }
[17:00:29.558]     if (FALSE) {
[17:00:29.558]     }
[17:00:29.558]     else {
[17:00:29.558]         if (TRUE) {
[17:00:29.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.558]                 open = "w")
[17:00:29.558]         }
[17:00:29.558]         else {
[17:00:29.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.558]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.558]         }
[17:00:29.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.558]             base::sink(type = "output", split = FALSE)
[17:00:29.558]             base::close(...future.stdout)
[17:00:29.558]         }, add = TRUE)
[17:00:29.558]     }
[17:00:29.558]     ...future.frame <- base::sys.nframe()
[17:00:29.558]     ...future.conditions <- base::list()
[17:00:29.558]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.558]     if (FALSE) {
[17:00:29.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.558]     }
[17:00:29.558]     ...future.result <- base::tryCatch({
[17:00:29.558]         base::withCallingHandlers({
[17:00:29.558]             ...future.value <- base::withVisible(base::local({
[17:00:29.558]                 withCallingHandlers({
[17:00:29.558]                   {
[17:00:29.558]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.558]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.558]                       ...future.globals.maxSize)) {
[17:00:29.558]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.558]                       on.exit(options(oopts), add = TRUE)
[17:00:29.558]                     }
[17:00:29.558]                     {
[17:00:29.558]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.558]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.558]                         USE.NAMES = FALSE)
[17:00:29.558]                       do.call(mapply, args = args)
[17:00:29.558]                     }
[17:00:29.558]                   }
[17:00:29.558]                 }, immediateCondition = function(cond) {
[17:00:29.558]                   save_rds <- function (object, pathname, ...) 
[17:00:29.558]                   {
[17:00:29.558]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.558]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.558]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.558]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.558]                         fi_tmp[["mtime"]])
[17:00:29.558]                     }
[17:00:29.558]                     tryCatch({
[17:00:29.558]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.558]                     }, error = function(ex) {
[17:00:29.558]                       msg <- conditionMessage(ex)
[17:00:29.558]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.558]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.558]                         fi_tmp[["mtime"]], msg)
[17:00:29.558]                       ex$message <- msg
[17:00:29.558]                       stop(ex)
[17:00:29.558]                     })
[17:00:29.558]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.558]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.558]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.558]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.558]                       fi <- file.info(pathname)
[17:00:29.558]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.558]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.558]                         fi[["size"]], fi[["mtime"]])
[17:00:29.558]                       stop(msg)
[17:00:29.558]                     }
[17:00:29.558]                     invisible(pathname)
[17:00:29.558]                   }
[17:00:29.558]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.558]                     rootPath = tempdir()) 
[17:00:29.558]                   {
[17:00:29.558]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.558]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.558]                       tmpdir = path, fileext = ".rds")
[17:00:29.558]                     save_rds(obj, file)
[17:00:29.558]                   }
[17:00:29.558]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.558]                   {
[17:00:29.558]                     inherits <- base::inherits
[17:00:29.558]                     invokeRestart <- base::invokeRestart
[17:00:29.558]                     is.null <- base::is.null
[17:00:29.558]                     muffled <- FALSE
[17:00:29.558]                     if (inherits(cond, "message")) {
[17:00:29.558]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.558]                       if (muffled) 
[17:00:29.558]                         invokeRestart("muffleMessage")
[17:00:29.558]                     }
[17:00:29.558]                     else if (inherits(cond, "warning")) {
[17:00:29.558]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.558]                       if (muffled) 
[17:00:29.558]                         invokeRestart("muffleWarning")
[17:00:29.558]                     }
[17:00:29.558]                     else if (inherits(cond, "condition")) {
[17:00:29.558]                       if (!is.null(pattern)) {
[17:00:29.558]                         computeRestarts <- base::computeRestarts
[17:00:29.558]                         grepl <- base::grepl
[17:00:29.558]                         restarts <- computeRestarts(cond)
[17:00:29.558]                         for (restart in restarts) {
[17:00:29.558]                           name <- restart$name
[17:00:29.558]                           if (is.null(name)) 
[17:00:29.558]                             next
[17:00:29.558]                           if (!grepl(pattern, name)) 
[17:00:29.558]                             next
[17:00:29.558]                           invokeRestart(restart)
[17:00:29.558]                           muffled <- TRUE
[17:00:29.558]                           break
[17:00:29.558]                         }
[17:00:29.558]                       }
[17:00:29.558]                     }
[17:00:29.558]                     invisible(muffled)
[17:00:29.558]                   }
[17:00:29.558]                   muffleCondition(cond)
[17:00:29.558]                 })
[17:00:29.558]             }))
[17:00:29.558]             future::FutureResult(value = ...future.value$value, 
[17:00:29.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.558]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.558]                     ...future.globalenv.names))
[17:00:29.558]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.558]         }, condition = base::local({
[17:00:29.558]             c <- base::c
[17:00:29.558]             inherits <- base::inherits
[17:00:29.558]             invokeRestart <- base::invokeRestart
[17:00:29.558]             length <- base::length
[17:00:29.558]             list <- base::list
[17:00:29.558]             seq.int <- base::seq.int
[17:00:29.558]             signalCondition <- base::signalCondition
[17:00:29.558]             sys.calls <- base::sys.calls
[17:00:29.558]             `[[` <- base::`[[`
[17:00:29.558]             `+` <- base::`+`
[17:00:29.558]             `<<-` <- base::`<<-`
[17:00:29.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.558]                   3L)]
[17:00:29.558]             }
[17:00:29.558]             function(cond) {
[17:00:29.558]                 is_error <- inherits(cond, "error")
[17:00:29.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.558]                   NULL)
[17:00:29.558]                 if (is_error) {
[17:00:29.558]                   sessionInformation <- function() {
[17:00:29.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.558]                       search = base::search(), system = base::Sys.info())
[17:00:29.558]                   }
[17:00:29.558]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.558]                     cond$call), session = sessionInformation(), 
[17:00:29.558]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.558]                   signalCondition(cond)
[17:00:29.558]                 }
[17:00:29.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.558]                 "immediateCondition"))) {
[17:00:29.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.558]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.558]                   if (TRUE && !signal) {
[17:00:29.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.558]                     {
[17:00:29.558]                       inherits <- base::inherits
[17:00:29.558]                       invokeRestart <- base::invokeRestart
[17:00:29.558]                       is.null <- base::is.null
[17:00:29.558]                       muffled <- FALSE
[17:00:29.558]                       if (inherits(cond, "message")) {
[17:00:29.558]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.558]                         if (muffled) 
[17:00:29.558]                           invokeRestart("muffleMessage")
[17:00:29.558]                       }
[17:00:29.558]                       else if (inherits(cond, "warning")) {
[17:00:29.558]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.558]                         if (muffled) 
[17:00:29.558]                           invokeRestart("muffleWarning")
[17:00:29.558]                       }
[17:00:29.558]                       else if (inherits(cond, "condition")) {
[17:00:29.558]                         if (!is.null(pattern)) {
[17:00:29.558]                           computeRestarts <- base::computeRestarts
[17:00:29.558]                           grepl <- base::grepl
[17:00:29.558]                           restarts <- computeRestarts(cond)
[17:00:29.558]                           for (restart in restarts) {
[17:00:29.558]                             name <- restart$name
[17:00:29.558]                             if (is.null(name)) 
[17:00:29.558]                               next
[17:00:29.558]                             if (!grepl(pattern, name)) 
[17:00:29.558]                               next
[17:00:29.558]                             invokeRestart(restart)
[17:00:29.558]                             muffled <- TRUE
[17:00:29.558]                             break
[17:00:29.558]                           }
[17:00:29.558]                         }
[17:00:29.558]                       }
[17:00:29.558]                       invisible(muffled)
[17:00:29.558]                     }
[17:00:29.558]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.558]                   }
[17:00:29.558]                 }
[17:00:29.558]                 else {
[17:00:29.558]                   if (TRUE) {
[17:00:29.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.558]                     {
[17:00:29.558]                       inherits <- base::inherits
[17:00:29.558]                       invokeRestart <- base::invokeRestart
[17:00:29.558]                       is.null <- base::is.null
[17:00:29.558]                       muffled <- FALSE
[17:00:29.558]                       if (inherits(cond, "message")) {
[17:00:29.558]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.558]                         if (muffled) 
[17:00:29.558]                           invokeRestart("muffleMessage")
[17:00:29.558]                       }
[17:00:29.558]                       else if (inherits(cond, "warning")) {
[17:00:29.558]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.558]                         if (muffled) 
[17:00:29.558]                           invokeRestart("muffleWarning")
[17:00:29.558]                       }
[17:00:29.558]                       else if (inherits(cond, "condition")) {
[17:00:29.558]                         if (!is.null(pattern)) {
[17:00:29.558]                           computeRestarts <- base::computeRestarts
[17:00:29.558]                           grepl <- base::grepl
[17:00:29.558]                           restarts <- computeRestarts(cond)
[17:00:29.558]                           for (restart in restarts) {
[17:00:29.558]                             name <- restart$name
[17:00:29.558]                             if (is.null(name)) 
[17:00:29.558]                               next
[17:00:29.558]                             if (!grepl(pattern, name)) 
[17:00:29.558]                               next
[17:00:29.558]                             invokeRestart(restart)
[17:00:29.558]                             muffled <- TRUE
[17:00:29.558]                             break
[17:00:29.558]                           }
[17:00:29.558]                         }
[17:00:29.558]                       }
[17:00:29.558]                       invisible(muffled)
[17:00:29.558]                     }
[17:00:29.558]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.558]                   }
[17:00:29.558]                 }
[17:00:29.558]             }
[17:00:29.558]         }))
[17:00:29.558]     }, error = function(ex) {
[17:00:29.558]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.558]                 ...future.rng), started = ...future.startTime, 
[17:00:29.558]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.558]             version = "1.8"), class = "FutureResult")
[17:00:29.558]     }, finally = {
[17:00:29.558]         if (!identical(...future.workdir, getwd())) 
[17:00:29.558]             setwd(...future.workdir)
[17:00:29.558]         {
[17:00:29.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.558]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.558]             }
[17:00:29.558]             base::options(...future.oldOptions)
[17:00:29.558]             if (.Platform$OS.type == "windows") {
[17:00:29.558]                 old_names <- names(...future.oldEnvVars)
[17:00:29.558]                 envs <- base::Sys.getenv()
[17:00:29.558]                 names <- names(envs)
[17:00:29.558]                 common <- intersect(names, old_names)
[17:00:29.558]                 added <- setdiff(names, old_names)
[17:00:29.558]                 removed <- setdiff(old_names, names)
[17:00:29.558]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.558]                   envs[common]]
[17:00:29.558]                 NAMES <- toupper(changed)
[17:00:29.558]                 args <- list()
[17:00:29.558]                 for (kk in seq_along(NAMES)) {
[17:00:29.558]                   name <- changed[[kk]]
[17:00:29.558]                   NAME <- NAMES[[kk]]
[17:00:29.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.558]                     next
[17:00:29.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.558]                 }
[17:00:29.558]                 NAMES <- toupper(added)
[17:00:29.558]                 for (kk in seq_along(NAMES)) {
[17:00:29.558]                   name <- added[[kk]]
[17:00:29.558]                   NAME <- NAMES[[kk]]
[17:00:29.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.558]                     next
[17:00:29.558]                   args[[name]] <- ""
[17:00:29.558]                 }
[17:00:29.558]                 NAMES <- toupper(removed)
[17:00:29.558]                 for (kk in seq_along(NAMES)) {
[17:00:29.558]                   name <- removed[[kk]]
[17:00:29.558]                   NAME <- NAMES[[kk]]
[17:00:29.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.558]                     next
[17:00:29.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.558]                 }
[17:00:29.558]                 if (length(args) > 0) 
[17:00:29.558]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.558]             }
[17:00:29.558]             else {
[17:00:29.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.558]             }
[17:00:29.558]             {
[17:00:29.558]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.558]                   0L) {
[17:00:29.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.558]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.558]                   base::options(opts)
[17:00:29.558]                 }
[17:00:29.558]                 {
[17:00:29.558]                   {
[17:00:29.558]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.558]                     NULL
[17:00:29.558]                   }
[17:00:29.558]                   options(future.plan = NULL)
[17:00:29.558]                   if (is.na(NA_character_)) 
[17:00:29.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.558]                     .init = FALSE)
[17:00:29.558]                 }
[17:00:29.558]             }
[17:00:29.558]         }
[17:00:29.558]     })
[17:00:29.558]     if (TRUE) {
[17:00:29.558]         base::sink(type = "output", split = FALSE)
[17:00:29.558]         if (TRUE) {
[17:00:29.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.558]         }
[17:00:29.558]         else {
[17:00:29.558]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.558]         }
[17:00:29.558]         base::close(...future.stdout)
[17:00:29.558]         ...future.stdout <- NULL
[17:00:29.558]     }
[17:00:29.558]     ...future.result$conditions <- ...future.conditions
[17:00:29.558]     ...future.result$finished <- base::Sys.time()
[17:00:29.558]     ...future.result
[17:00:29.558] }
[17:00:29.561] assign_globals() ...
[17:00:29.561] List of 5
[17:00:29.561]  $ ...future.FUN            :function (x, y)  
[17:00:29.561]  $ MoreArgs                 : list()
[17:00:29.561]  $ ...future.elements_ii    :List of 2
[17:00:29.561]   ..$ :List of 2
[17:00:29.561]   .. ..$ b: num 2
[17:00:29.561]   .. ..$ c: num 3
[17:00:29.561]   ..$ :List of 2
[17:00:29.561]   .. ..$ B: num 0
[17:00:29.561]   .. ..$ C: num -10
[17:00:29.561]  $ ...future.seeds_ii       : NULL
[17:00:29.561]  $ ...future.globals.maxSize: NULL
[17:00:29.561]  - attr(*, "where")=List of 5
[17:00:29.561]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.561]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.561]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.561]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.561]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.561]  - attr(*, "resolved")= logi FALSE
[17:00:29.561]  - attr(*, "total_size")= num 2200
[17:00:29.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.561]  - attr(*, "already-done")= logi TRUE
[17:00:29.570] - reassign environment for ‘...future.FUN’
[17:00:29.570] - copied ‘...future.FUN’ to environment
[17:00:29.570] - copied ‘MoreArgs’ to environment
[17:00:29.570] - copied ‘...future.elements_ii’ to environment
[17:00:29.570] - copied ‘...future.seeds_ii’ to environment
[17:00:29.570] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.570] assign_globals() ... done
[17:00:29.571] requestCore(): workers = 2
[17:00:29.573] MulticoreFuture started
[17:00:29.574] - Launch lazy future ... done
[17:00:29.574] run() for ‘MulticoreFuture’ ... done
[17:00:29.574] Created future:
[17:00:29.574] plan(): Setting new future strategy stack:
[17:00:29.574] List of future strategies:
[17:00:29.574] 1. sequential:
[17:00:29.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.574]    - tweaked: FALSE
[17:00:29.574]    - call: NULL
[17:00:29.575] plan(): nbrOfWorkers() = 1
[17:00:29.578] plan(): Setting new future strategy stack:
[17:00:29.578] List of future strategies:
[17:00:29.578] 1. multicore:
[17:00:29.578]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.578]    - tweaked: FALSE
[17:00:29.578]    - call: plan(strategy)
[17:00:29.574] MulticoreFuture:
[17:00:29.574] Label: ‘future_.mapply-2’
[17:00:29.574] Expression:
[17:00:29.574] {
[17:00:29.574]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.574]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.574]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.574]         on.exit(options(oopts), add = TRUE)
[17:00:29.574]     }
[17:00:29.574]     {
[17:00:29.574]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.574]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.574]         do.call(mapply, args = args)
[17:00:29.574]     }
[17:00:29.574] }
[17:00:29.574] Lazy evaluation: FALSE
[17:00:29.574] Asynchronous evaluation: TRUE
[17:00:29.574] Local evaluation: TRUE
[17:00:29.574] Environment: R_GlobalEnv
[17:00:29.574] Capture standard output: TRUE
[17:00:29.574] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.574] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.574] Packages: <none>
[17:00:29.574] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.574] Resolved: FALSE
[17:00:29.574] Value: <not collected>
[17:00:29.574] Conditions captured: <none>
[17:00:29.574] Early signaling: FALSE
[17:00:29.574] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.574] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.587] Chunk #2 of 2 ... DONE
[17:00:29.587] Launching 2 futures (chunks) ... DONE
[17:00:29.588] Resolving 2 futures (chunks) ...
[17:00:29.588] resolve() on list ...
[17:00:29.588]  recursive: 0
[17:00:29.588]  length: 2
[17:00:29.590] plan(): nbrOfWorkers() = 2
[17:00:29.589] 
[17:00:29.592] Future #1
[17:00:29.593] result() for MulticoreFuture ...
[17:00:29.594] result() for MulticoreFuture ...
[17:00:29.594] result() for MulticoreFuture ... done
[17:00:29.595] result() for MulticoreFuture ... done
[17:00:29.595] result() for MulticoreFuture ...
[17:00:29.595] result() for MulticoreFuture ... done
[17:00:29.596] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:29.596] - nx: 2
[17:00:29.596] - relay: TRUE
[17:00:29.596] - stdout: TRUE
[17:00:29.597] - signal: TRUE
[17:00:29.597] - resignal: FALSE
[17:00:29.597] - force: TRUE
[17:00:29.598] - relayed: [n=2] FALSE, FALSE
[17:00:29.598] - queued futures: [n=2] FALSE, FALSE
[17:00:29.598]  - until=1
[17:00:29.599]  - relaying element #1
[17:00:29.599] result() for MulticoreFuture ...
[17:00:29.599] result() for MulticoreFuture ... done
[17:00:29.599] result() for MulticoreFuture ...
[17:00:29.600] result() for MulticoreFuture ... done
[17:00:29.600] result() for MulticoreFuture ...
[17:00:29.600] result() for MulticoreFuture ... done
[17:00:29.600] result() for MulticoreFuture ...
[17:00:29.601] result() for MulticoreFuture ... done
[17:00:29.601] - relayed: [n=2] TRUE, FALSE
[17:00:29.601] - queued futures: [n=2] TRUE, FALSE
[17:00:29.601] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:29.601]  length: 1 (resolved future 1)
[17:00:29.602] Future #2
[17:00:29.602] result() for MulticoreFuture ...
[17:00:29.602] result() for MulticoreFuture ...
[17:00:29.603] result() for MulticoreFuture ... done
[17:00:29.603] result() for MulticoreFuture ... done
[17:00:29.603] result() for MulticoreFuture ...
[17:00:29.603] result() for MulticoreFuture ... done
[17:00:29.604] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:29.604] - nx: 2
[17:00:29.604] - relay: TRUE
[17:00:29.604] - stdout: TRUE
[17:00:29.604] - signal: TRUE
[17:00:29.604] - resignal: FALSE
[17:00:29.604] - force: TRUE
[17:00:29.605] - relayed: [n=2] TRUE, FALSE
[17:00:29.605] - queued futures: [n=2] TRUE, FALSE
[17:00:29.605]  - until=2
[17:00:29.605]  - relaying element #2
[17:00:29.605] result() for MulticoreFuture ...
[17:00:29.605] result() for MulticoreFuture ... done
[17:00:29.606] result() for MulticoreFuture ...
[17:00:29.606] result() for MulticoreFuture ... done
[17:00:29.606] result() for MulticoreFuture ...
[17:00:29.606] result() for MulticoreFuture ... done
[17:00:29.606] result() for MulticoreFuture ...
[17:00:29.606] result() for MulticoreFuture ... done
[17:00:29.607] - relayed: [n=2] TRUE, TRUE
[17:00:29.607] - queued futures: [n=2] TRUE, TRUE
[17:00:29.607] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:29.607]  length: 0 (resolved future 2)
[17:00:29.607] Relaying remaining futures
[17:00:29.607] signalConditionsASAP(NULL, pos=0) ...
[17:00:29.607] - nx: 2
[17:00:29.607] - relay: TRUE
[17:00:29.608] - stdout: TRUE
[17:00:29.608] - signal: TRUE
[17:00:29.608] - resignal: FALSE
[17:00:29.608] - force: TRUE
[17:00:29.608] - relayed: [n=2] TRUE, TRUE
[17:00:29.608] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:29.608] - relayed: [n=2] TRUE, TRUE
[17:00:29.608] - queued futures: [n=2] TRUE, TRUE
[17:00:29.608] signalConditionsASAP(NULL, pos=0) ... done
[17:00:29.609] resolve() on list ... DONE
[17:00:29.609] result() for MulticoreFuture ...
[17:00:29.609] result() for MulticoreFuture ... done
[17:00:29.609] result() for MulticoreFuture ...
[17:00:29.609] result() for MulticoreFuture ... done
[17:00:29.609] result() for MulticoreFuture ...
[17:00:29.609] result() for MulticoreFuture ... done
[17:00:29.609] result() for MulticoreFuture ...
[17:00:29.609] result() for MulticoreFuture ... done
[17:00:29.610]  - Number of value chunks collected: 2
[17:00:29.610] Resolving 2 futures (chunks) ... DONE
[17:00:29.610] Reducing values from 2 chunks ...
[17:00:29.610]  - Number of values collected after concatenation: 3
[17:00:29.610]  - Number of values expected: 3
[17:00:29.610] Reducing values from 2 chunks ... DONE
[17:00:29.610] future_mapply() ... DONE
[17:00:29.611] future_mapply() ...
[17:00:29.615] Number of chunks: 5
[17:00:29.615] getGlobalsAndPackagesXApply() ...
[17:00:29.615]  - future.globals: TRUE
[17:00:29.615] getGlobalsAndPackages() ...
[17:00:29.615] Searching for globals...
[17:00:29.617] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:29.617] Searching for globals ... DONE
[17:00:29.617] Resolving globals: FALSE
[17:00:29.617] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:29.618] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:29.618] - globals: [1] ‘FUN’
[17:00:29.618] 
[17:00:29.618] getGlobalsAndPackages() ... DONE
[17:00:29.618]  - globals found/used: [n=1] ‘FUN’
[17:00:29.618]  - needed namespaces: [n=0] 
[17:00:29.618] Finding globals ... DONE
[17:00:29.619] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:29.619] List of 2
[17:00:29.619]  $ ...future.FUN:function (C, k)  
[17:00:29.619]  $ MoreArgs     : NULL
[17:00:29.619]  - attr(*, "where")=List of 2
[17:00:29.619]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:29.619]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:29.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.619]  - attr(*, "resolved")= logi FALSE
[17:00:29.619]  - attr(*, "total_size")= num NA
[17:00:29.622] Packages to be attached in all futures: [n=0] 
[17:00:29.622] getGlobalsAndPackagesXApply() ... DONE
[17:00:29.622] Number of futures (= number of chunks): 5
[17:00:29.622] Launching 5 futures (chunks) ...
[17:00:29.622] Chunk #1 of 5 ...
[17:00:29.622]  - Finding globals in '...' for chunk #1 ...
[17:00:29.622] getGlobalsAndPackages() ...
[17:00:29.623] Searching for globals...
[17:00:29.623] 
[17:00:29.623] Searching for globals ... DONE
[17:00:29.623] - globals: [0] <none>
[17:00:29.623] getGlobalsAndPackages() ... DONE
[17:00:29.623]    + additional globals found: [n=0] 
[17:00:29.623]    + additional namespaces needed: [n=0] 
[17:00:29.624]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:29.624]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:29.624]  - seeds: <none>
[17:00:29.624]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.624] getGlobalsAndPackages() ...
[17:00:29.624] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.624] Resolving globals: FALSE
[17:00:29.625] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:29.627] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.627] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.628] 
[17:00:29.628] getGlobalsAndPackages() ... DONE
[17:00:29.628] run() for ‘Future’ ...
[17:00:29.628] - state: ‘created’
[17:00:29.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.632] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.633]   - Field: ‘label’
[17:00:29.633]   - Field: ‘local’
[17:00:29.633]   - Field: ‘owner’
[17:00:29.633]   - Field: ‘envir’
[17:00:29.633]   - Field: ‘workers’
[17:00:29.633]   - Field: ‘packages’
[17:00:29.633]   - Field: ‘gc’
[17:00:29.634]   - Field: ‘job’
[17:00:29.634]   - Field: ‘conditions’
[17:00:29.634]   - Field: ‘expr’
[17:00:29.634]   - Field: ‘uuid’
[17:00:29.634]   - Field: ‘seed’
[17:00:29.634]   - Field: ‘version’
[17:00:29.634]   - Field: ‘result’
[17:00:29.634]   - Field: ‘asynchronous’
[17:00:29.634]   - Field: ‘calls’
[17:00:29.634]   - Field: ‘globals’
[17:00:29.634]   - Field: ‘stdout’
[17:00:29.635]   - Field: ‘earlySignal’
[17:00:29.635]   - Field: ‘lazy’
[17:00:29.635]   - Field: ‘state’
[17:00:29.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.635] - Launch lazy future ...
[17:00:29.635] Packages needed by the future expression (n = 0): <none>
[17:00:29.635] Packages needed by future strategies (n = 0): <none>
[17:00:29.636] {
[17:00:29.636]     {
[17:00:29.636]         {
[17:00:29.636]             ...future.startTime <- base::Sys.time()
[17:00:29.636]             {
[17:00:29.636]                 {
[17:00:29.636]                   {
[17:00:29.636]                     {
[17:00:29.636]                       base::local({
[17:00:29.636]                         has_future <- base::requireNamespace("future", 
[17:00:29.636]                           quietly = TRUE)
[17:00:29.636]                         if (has_future) {
[17:00:29.636]                           ns <- base::getNamespace("future")
[17:00:29.636]                           version <- ns[[".package"]][["version"]]
[17:00:29.636]                           if (is.null(version)) 
[17:00:29.636]                             version <- utils::packageVersion("future")
[17:00:29.636]                         }
[17:00:29.636]                         else {
[17:00:29.636]                           version <- NULL
[17:00:29.636]                         }
[17:00:29.636]                         if (!has_future || version < "1.8.0") {
[17:00:29.636]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.636]                             "", base::R.version$version.string), 
[17:00:29.636]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.636]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.636]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.636]                               "release", "version")], collapse = " "), 
[17:00:29.636]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.636]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.636]                             info)
[17:00:29.636]                           info <- base::paste(info, collapse = "; ")
[17:00:29.636]                           if (!has_future) {
[17:00:29.636]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.636]                               info)
[17:00:29.636]                           }
[17:00:29.636]                           else {
[17:00:29.636]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.636]                               info, version)
[17:00:29.636]                           }
[17:00:29.636]                           base::stop(msg)
[17:00:29.636]                         }
[17:00:29.636]                       })
[17:00:29.636]                     }
[17:00:29.636]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.636]                     base::options(mc.cores = 1L)
[17:00:29.636]                   }
[17:00:29.636]                   ...future.strategy.old <- future::plan("list")
[17:00:29.636]                   options(future.plan = NULL)
[17:00:29.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.636]                 }
[17:00:29.636]                 ...future.workdir <- getwd()
[17:00:29.636]             }
[17:00:29.636]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.636]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.636]         }
[17:00:29.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.636]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:29.636]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.636]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.636]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.636]             base::names(...future.oldOptions))
[17:00:29.636]     }
[17:00:29.636]     if (FALSE) {
[17:00:29.636]     }
[17:00:29.636]     else {
[17:00:29.636]         if (TRUE) {
[17:00:29.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.636]                 open = "w")
[17:00:29.636]         }
[17:00:29.636]         else {
[17:00:29.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.636]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.636]         }
[17:00:29.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.636]             base::sink(type = "output", split = FALSE)
[17:00:29.636]             base::close(...future.stdout)
[17:00:29.636]         }, add = TRUE)
[17:00:29.636]     }
[17:00:29.636]     ...future.frame <- base::sys.nframe()
[17:00:29.636]     ...future.conditions <- base::list()
[17:00:29.636]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.636]     if (FALSE) {
[17:00:29.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.636]     }
[17:00:29.636]     ...future.result <- base::tryCatch({
[17:00:29.636]         base::withCallingHandlers({
[17:00:29.636]             ...future.value <- base::withVisible(base::local({
[17:00:29.636]                 withCallingHandlers({
[17:00:29.636]                   {
[17:00:29.636]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.636]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.636]                       ...future.globals.maxSize)) {
[17:00:29.636]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.636]                       on.exit(options(oopts), add = TRUE)
[17:00:29.636]                     }
[17:00:29.636]                     {
[17:00:29.636]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.636]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.636]                         USE.NAMES = FALSE)
[17:00:29.636]                       do.call(mapply, args = args)
[17:00:29.636]                     }
[17:00:29.636]                   }
[17:00:29.636]                 }, immediateCondition = function(cond) {
[17:00:29.636]                   save_rds <- function (object, pathname, ...) 
[17:00:29.636]                   {
[17:00:29.636]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.636]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.636]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.636]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.636]                         fi_tmp[["mtime"]])
[17:00:29.636]                     }
[17:00:29.636]                     tryCatch({
[17:00:29.636]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.636]                     }, error = function(ex) {
[17:00:29.636]                       msg <- conditionMessage(ex)
[17:00:29.636]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.636]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.636]                         fi_tmp[["mtime"]], msg)
[17:00:29.636]                       ex$message <- msg
[17:00:29.636]                       stop(ex)
[17:00:29.636]                     })
[17:00:29.636]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.636]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.636]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.636]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.636]                       fi <- file.info(pathname)
[17:00:29.636]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.636]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.636]                         fi[["size"]], fi[["mtime"]])
[17:00:29.636]                       stop(msg)
[17:00:29.636]                     }
[17:00:29.636]                     invisible(pathname)
[17:00:29.636]                   }
[17:00:29.636]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.636]                     rootPath = tempdir()) 
[17:00:29.636]                   {
[17:00:29.636]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.636]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.636]                       tmpdir = path, fileext = ".rds")
[17:00:29.636]                     save_rds(obj, file)
[17:00:29.636]                   }
[17:00:29.636]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.636]                   {
[17:00:29.636]                     inherits <- base::inherits
[17:00:29.636]                     invokeRestart <- base::invokeRestart
[17:00:29.636]                     is.null <- base::is.null
[17:00:29.636]                     muffled <- FALSE
[17:00:29.636]                     if (inherits(cond, "message")) {
[17:00:29.636]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.636]                       if (muffled) 
[17:00:29.636]                         invokeRestart("muffleMessage")
[17:00:29.636]                     }
[17:00:29.636]                     else if (inherits(cond, "warning")) {
[17:00:29.636]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.636]                       if (muffled) 
[17:00:29.636]                         invokeRestart("muffleWarning")
[17:00:29.636]                     }
[17:00:29.636]                     else if (inherits(cond, "condition")) {
[17:00:29.636]                       if (!is.null(pattern)) {
[17:00:29.636]                         computeRestarts <- base::computeRestarts
[17:00:29.636]                         grepl <- base::grepl
[17:00:29.636]                         restarts <- computeRestarts(cond)
[17:00:29.636]                         for (restart in restarts) {
[17:00:29.636]                           name <- restart$name
[17:00:29.636]                           if (is.null(name)) 
[17:00:29.636]                             next
[17:00:29.636]                           if (!grepl(pattern, name)) 
[17:00:29.636]                             next
[17:00:29.636]                           invokeRestart(restart)
[17:00:29.636]                           muffled <- TRUE
[17:00:29.636]                           break
[17:00:29.636]                         }
[17:00:29.636]                       }
[17:00:29.636]                     }
[17:00:29.636]                     invisible(muffled)
[17:00:29.636]                   }
[17:00:29.636]                   muffleCondition(cond)
[17:00:29.636]                 })
[17:00:29.636]             }))
[17:00:29.636]             future::FutureResult(value = ...future.value$value, 
[17:00:29.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.636]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.636]                     ...future.globalenv.names))
[17:00:29.636]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.636]         }, condition = base::local({
[17:00:29.636]             c <- base::c
[17:00:29.636]             inherits <- base::inherits
[17:00:29.636]             invokeRestart <- base::invokeRestart
[17:00:29.636]             length <- base::length
[17:00:29.636]             list <- base::list
[17:00:29.636]             seq.int <- base::seq.int
[17:00:29.636]             signalCondition <- base::signalCondition
[17:00:29.636]             sys.calls <- base::sys.calls
[17:00:29.636]             `[[` <- base::`[[`
[17:00:29.636]             `+` <- base::`+`
[17:00:29.636]             `<<-` <- base::`<<-`
[17:00:29.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.636]                   3L)]
[17:00:29.636]             }
[17:00:29.636]             function(cond) {
[17:00:29.636]                 is_error <- inherits(cond, "error")
[17:00:29.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.636]                   NULL)
[17:00:29.636]                 if (is_error) {
[17:00:29.636]                   sessionInformation <- function() {
[17:00:29.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.636]                       search = base::search(), system = base::Sys.info())
[17:00:29.636]                   }
[17:00:29.636]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.636]                     cond$call), session = sessionInformation(), 
[17:00:29.636]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.636]                   signalCondition(cond)
[17:00:29.636]                 }
[17:00:29.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.636]                 "immediateCondition"))) {
[17:00:29.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.636]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.636]                   if (TRUE && !signal) {
[17:00:29.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.636]                     {
[17:00:29.636]                       inherits <- base::inherits
[17:00:29.636]                       invokeRestart <- base::invokeRestart
[17:00:29.636]                       is.null <- base::is.null
[17:00:29.636]                       muffled <- FALSE
[17:00:29.636]                       if (inherits(cond, "message")) {
[17:00:29.636]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.636]                         if (muffled) 
[17:00:29.636]                           invokeRestart("muffleMessage")
[17:00:29.636]                       }
[17:00:29.636]                       else if (inherits(cond, "warning")) {
[17:00:29.636]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.636]                         if (muffled) 
[17:00:29.636]                           invokeRestart("muffleWarning")
[17:00:29.636]                       }
[17:00:29.636]                       else if (inherits(cond, "condition")) {
[17:00:29.636]                         if (!is.null(pattern)) {
[17:00:29.636]                           computeRestarts <- base::computeRestarts
[17:00:29.636]                           grepl <- base::grepl
[17:00:29.636]                           restarts <- computeRestarts(cond)
[17:00:29.636]                           for (restart in restarts) {
[17:00:29.636]                             name <- restart$name
[17:00:29.636]                             if (is.null(name)) 
[17:00:29.636]                               next
[17:00:29.636]                             if (!grepl(pattern, name)) 
[17:00:29.636]                               next
[17:00:29.636]                             invokeRestart(restart)
[17:00:29.636]                             muffled <- TRUE
[17:00:29.636]                             break
[17:00:29.636]                           }
[17:00:29.636]                         }
[17:00:29.636]                       }
[17:00:29.636]                       invisible(muffled)
[17:00:29.636]                     }
[17:00:29.636]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.636]                   }
[17:00:29.636]                 }
[17:00:29.636]                 else {
[17:00:29.636]                   if (TRUE) {
[17:00:29.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.636]                     {
[17:00:29.636]                       inherits <- base::inherits
[17:00:29.636]                       invokeRestart <- base::invokeRestart
[17:00:29.636]                       is.null <- base::is.null
[17:00:29.636]                       muffled <- FALSE
[17:00:29.636]                       if (inherits(cond, "message")) {
[17:00:29.636]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.636]                         if (muffled) 
[17:00:29.636]                           invokeRestart("muffleMessage")
[17:00:29.636]                       }
[17:00:29.636]                       else if (inherits(cond, "warning")) {
[17:00:29.636]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.636]                         if (muffled) 
[17:00:29.636]                           invokeRestart("muffleWarning")
[17:00:29.636]                       }
[17:00:29.636]                       else if (inherits(cond, "condition")) {
[17:00:29.636]                         if (!is.null(pattern)) {
[17:00:29.636]                           computeRestarts <- base::computeRestarts
[17:00:29.636]                           grepl <- base::grepl
[17:00:29.636]                           restarts <- computeRestarts(cond)
[17:00:29.636]                           for (restart in restarts) {
[17:00:29.636]                             name <- restart$name
[17:00:29.636]                             if (is.null(name)) 
[17:00:29.636]                               next
[17:00:29.636]                             if (!grepl(pattern, name)) 
[17:00:29.636]                               next
[17:00:29.636]                             invokeRestart(restart)
[17:00:29.636]                             muffled <- TRUE
[17:00:29.636]                             break
[17:00:29.636]                           }
[17:00:29.636]                         }
[17:00:29.636]                       }
[17:00:29.636]                       invisible(muffled)
[17:00:29.636]                     }
[17:00:29.636]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.636]                   }
[17:00:29.636]                 }
[17:00:29.636]             }
[17:00:29.636]         }))
[17:00:29.636]     }, error = function(ex) {
[17:00:29.636]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.636]                 ...future.rng), started = ...future.startTime, 
[17:00:29.636]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.636]             version = "1.8"), class = "FutureResult")
[17:00:29.636]     }, finally = {
[17:00:29.636]         if (!identical(...future.workdir, getwd())) 
[17:00:29.636]             setwd(...future.workdir)
[17:00:29.636]         {
[17:00:29.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.636]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.636]             }
[17:00:29.636]             base::options(...future.oldOptions)
[17:00:29.636]             if (.Platform$OS.type == "windows") {
[17:00:29.636]                 old_names <- names(...future.oldEnvVars)
[17:00:29.636]                 envs <- base::Sys.getenv()
[17:00:29.636]                 names <- names(envs)
[17:00:29.636]                 common <- intersect(names, old_names)
[17:00:29.636]                 added <- setdiff(names, old_names)
[17:00:29.636]                 removed <- setdiff(old_names, names)
[17:00:29.636]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.636]                   envs[common]]
[17:00:29.636]                 NAMES <- toupper(changed)
[17:00:29.636]                 args <- list()
[17:00:29.636]                 for (kk in seq_along(NAMES)) {
[17:00:29.636]                   name <- changed[[kk]]
[17:00:29.636]                   NAME <- NAMES[[kk]]
[17:00:29.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.636]                     next
[17:00:29.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.636]                 }
[17:00:29.636]                 NAMES <- toupper(added)
[17:00:29.636]                 for (kk in seq_along(NAMES)) {
[17:00:29.636]                   name <- added[[kk]]
[17:00:29.636]                   NAME <- NAMES[[kk]]
[17:00:29.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.636]                     next
[17:00:29.636]                   args[[name]] <- ""
[17:00:29.636]                 }
[17:00:29.636]                 NAMES <- toupper(removed)
[17:00:29.636]                 for (kk in seq_along(NAMES)) {
[17:00:29.636]                   name <- removed[[kk]]
[17:00:29.636]                   NAME <- NAMES[[kk]]
[17:00:29.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.636]                     next
[17:00:29.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.636]                 }
[17:00:29.636]                 if (length(args) > 0) 
[17:00:29.636]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.636]             }
[17:00:29.636]             else {
[17:00:29.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.636]             }
[17:00:29.636]             {
[17:00:29.636]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.636]                   0L) {
[17:00:29.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.636]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.636]                   base::options(opts)
[17:00:29.636]                 }
[17:00:29.636]                 {
[17:00:29.636]                   {
[17:00:29.636]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.636]                     NULL
[17:00:29.636]                   }
[17:00:29.636]                   options(future.plan = NULL)
[17:00:29.636]                   if (is.na(NA_character_)) 
[17:00:29.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.636]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.636]                     .init = FALSE)
[17:00:29.636]                 }
[17:00:29.636]             }
[17:00:29.636]         }
[17:00:29.636]     })
[17:00:29.636]     if (TRUE) {
[17:00:29.636]         base::sink(type = "output", split = FALSE)
[17:00:29.636]         if (TRUE) {
[17:00:29.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.636]         }
[17:00:29.636]         else {
[17:00:29.636]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.636]         }
[17:00:29.636]         base::close(...future.stdout)
[17:00:29.636]         ...future.stdout <- NULL
[17:00:29.636]     }
[17:00:29.636]     ...future.result$conditions <- ...future.conditions
[17:00:29.636]     ...future.result$finished <- base::Sys.time()
[17:00:29.636]     ...future.result
[17:00:29.636] }
[17:00:29.638] assign_globals() ...
[17:00:29.638] List of 5
[17:00:29.638]  $ ...future.FUN            :function (C, k)  
[17:00:29.638]  $ MoreArgs                 : NULL
[17:00:29.638]  $ ...future.elements_ii    :List of 2
[17:00:29.638]   ..$ :List of 1
[17:00:29.638]   .. ..$ : chr "A"
[17:00:29.638]   ..$ :List of 1
[17:00:29.638]   .. ..$ : int 5
[17:00:29.638]  $ ...future.seeds_ii       : NULL
[17:00:29.638]  $ ...future.globals.maxSize: NULL
[17:00:29.638]  - attr(*, "where")=List of 5
[17:00:29.638]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.638]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.638]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.638]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.638]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.638]  - attr(*, "resolved")= logi FALSE
[17:00:29.638]  - attr(*, "total_size")= num 3488
[17:00:29.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.638]  - attr(*, "already-done")= logi TRUE
[17:00:29.644] - reassign environment for ‘...future.FUN’
[17:00:29.644] - copied ‘...future.FUN’ to environment
[17:00:29.644] - copied ‘MoreArgs’ to environment
[17:00:29.644] - copied ‘...future.elements_ii’ to environment
[17:00:29.644] - copied ‘...future.seeds_ii’ to environment
[17:00:29.644] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.644] assign_globals() ... done
[17:00:29.644] requestCore(): workers = 2
[17:00:29.647] MulticoreFuture started
[17:00:29.647] - Launch lazy future ... done
[17:00:29.647] run() for ‘MulticoreFuture’ ... done
[17:00:29.648] Created future:
[17:00:29.648] plan(): Setting new future strategy stack:
[17:00:29.648] List of future strategies:
[17:00:29.648] 1. sequential:
[17:00:29.648]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.648]    - tweaked: FALSE
[17:00:29.648]    - call: NULL
[17:00:29.649] plan(): nbrOfWorkers() = 1
[17:00:29.651] plan(): Setting new future strategy stack:
[17:00:29.651] List of future strategies:
[17:00:29.651] 1. multicore:
[17:00:29.651]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.651]    - tweaked: FALSE
[17:00:29.651]    - call: plan(strategy)
[17:00:29.656] plan(): nbrOfWorkers() = 2
[17:00:29.648] MulticoreFuture:
[17:00:29.648] Label: ‘future_mapply-1’
[17:00:29.648] Expression:
[17:00:29.648] {
[17:00:29.648]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.648]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.648]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.648]         on.exit(options(oopts), add = TRUE)
[17:00:29.648]     }
[17:00:29.648]     {
[17:00:29.648]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.648]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.648]         do.call(mapply, args = args)
[17:00:29.648]     }
[17:00:29.648] }
[17:00:29.648] Lazy evaluation: FALSE
[17:00:29.648] Asynchronous evaluation: TRUE
[17:00:29.648] Local evaluation: TRUE
[17:00:29.648] Environment: R_GlobalEnv
[17:00:29.648] Capture standard output: TRUE
[17:00:29.648] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.648] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.648] Packages: <none>
[17:00:29.648] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.648] Resolved: TRUE
[17:00:29.648] Value: <not collected>
[17:00:29.648] Conditions captured: <none>
[17:00:29.648] Early signaling: FALSE
[17:00:29.648] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.648] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.658] Chunk #1 of 5 ... DONE
[17:00:29.658] Chunk #2 of 5 ...
[17:00:29.658]  - Finding globals in '...' for chunk #2 ...
[17:00:29.658] getGlobalsAndPackages() ...
[17:00:29.658] Searching for globals...
[17:00:29.659] 
[17:00:29.659] Searching for globals ... DONE
[17:00:29.659] - globals: [0] <none>
[17:00:29.659] getGlobalsAndPackages() ... DONE
[17:00:29.660]    + additional globals found: [n=0] 
[17:00:29.660]    + additional namespaces needed: [n=0] 
[17:00:29.660]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:29.660]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:29.660]  - seeds: <none>
[17:00:29.660]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.661] getGlobalsAndPackages() ...
[17:00:29.661] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.661] Resolving globals: FALSE
[17:00:29.662] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:29.663] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.663] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.663] 
[17:00:29.663] getGlobalsAndPackages() ... DONE
[17:00:29.664] run() for ‘Future’ ...
[17:00:29.664] - state: ‘created’
[17:00:29.664] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.669] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.669] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.670]   - Field: ‘label’
[17:00:29.670]   - Field: ‘local’
[17:00:29.670]   - Field: ‘owner’
[17:00:29.670]   - Field: ‘envir’
[17:00:29.670]   - Field: ‘workers’
[17:00:29.670]   - Field: ‘packages’
[17:00:29.670]   - Field: ‘gc’
[17:00:29.671]   - Field: ‘job’
[17:00:29.671]   - Field: ‘conditions’
[17:00:29.671]   - Field: ‘expr’
[17:00:29.671]   - Field: ‘uuid’
[17:00:29.671]   - Field: ‘seed’
[17:00:29.671]   - Field: ‘version’
[17:00:29.675]   - Field: ‘result’
[17:00:29.675]   - Field: ‘asynchronous’
[17:00:29.676]   - Field: ‘calls’
[17:00:29.676]   - Field: ‘globals’
[17:00:29.676]   - Field: ‘stdout’
[17:00:29.676]   - Field: ‘earlySignal’
[17:00:29.677]   - Field: ‘lazy’
[17:00:29.677]   - Field: ‘state’
[17:00:29.677] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.678] - Launch lazy future ...
[17:00:29.678] Packages needed by the future expression (n = 0): <none>
[17:00:29.679] Packages needed by future strategies (n = 0): <none>
[17:00:29.680] {
[17:00:29.680]     {
[17:00:29.680]         {
[17:00:29.680]             ...future.startTime <- base::Sys.time()
[17:00:29.680]             {
[17:00:29.680]                 {
[17:00:29.680]                   {
[17:00:29.680]                     {
[17:00:29.680]                       base::local({
[17:00:29.680]                         has_future <- base::requireNamespace("future", 
[17:00:29.680]                           quietly = TRUE)
[17:00:29.680]                         if (has_future) {
[17:00:29.680]                           ns <- base::getNamespace("future")
[17:00:29.680]                           version <- ns[[".package"]][["version"]]
[17:00:29.680]                           if (is.null(version)) 
[17:00:29.680]                             version <- utils::packageVersion("future")
[17:00:29.680]                         }
[17:00:29.680]                         else {
[17:00:29.680]                           version <- NULL
[17:00:29.680]                         }
[17:00:29.680]                         if (!has_future || version < "1.8.0") {
[17:00:29.680]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.680]                             "", base::R.version$version.string), 
[17:00:29.680]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.680]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.680]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.680]                               "release", "version")], collapse = " "), 
[17:00:29.680]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.680]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.680]                             info)
[17:00:29.680]                           info <- base::paste(info, collapse = "; ")
[17:00:29.680]                           if (!has_future) {
[17:00:29.680]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.680]                               info)
[17:00:29.680]                           }
[17:00:29.680]                           else {
[17:00:29.680]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.680]                               info, version)
[17:00:29.680]                           }
[17:00:29.680]                           base::stop(msg)
[17:00:29.680]                         }
[17:00:29.680]                       })
[17:00:29.680]                     }
[17:00:29.680]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.680]                     base::options(mc.cores = 1L)
[17:00:29.680]                   }
[17:00:29.680]                   ...future.strategy.old <- future::plan("list")
[17:00:29.680]                   options(future.plan = NULL)
[17:00:29.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.680]                 }
[17:00:29.680]                 ...future.workdir <- getwd()
[17:00:29.680]             }
[17:00:29.680]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.680]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.680]         }
[17:00:29.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.680]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:29.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.680]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.680]             base::names(...future.oldOptions))
[17:00:29.680]     }
[17:00:29.680]     if (FALSE) {
[17:00:29.680]     }
[17:00:29.680]     else {
[17:00:29.680]         if (TRUE) {
[17:00:29.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.680]                 open = "w")
[17:00:29.680]         }
[17:00:29.680]         else {
[17:00:29.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.680]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.680]         }
[17:00:29.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.680]             base::sink(type = "output", split = FALSE)
[17:00:29.680]             base::close(...future.stdout)
[17:00:29.680]         }, add = TRUE)
[17:00:29.680]     }
[17:00:29.680]     ...future.frame <- base::sys.nframe()
[17:00:29.680]     ...future.conditions <- base::list()
[17:00:29.680]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.680]     if (FALSE) {
[17:00:29.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.680]     }
[17:00:29.680]     ...future.result <- base::tryCatch({
[17:00:29.680]         base::withCallingHandlers({
[17:00:29.680]             ...future.value <- base::withVisible(base::local({
[17:00:29.680]                 withCallingHandlers({
[17:00:29.680]                   {
[17:00:29.680]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.680]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.680]                       ...future.globals.maxSize)) {
[17:00:29.680]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.680]                       on.exit(options(oopts), add = TRUE)
[17:00:29.680]                     }
[17:00:29.680]                     {
[17:00:29.680]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.680]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.680]                         USE.NAMES = FALSE)
[17:00:29.680]                       do.call(mapply, args = args)
[17:00:29.680]                     }
[17:00:29.680]                   }
[17:00:29.680]                 }, immediateCondition = function(cond) {
[17:00:29.680]                   save_rds <- function (object, pathname, ...) 
[17:00:29.680]                   {
[17:00:29.680]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.680]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.680]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.680]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.680]                         fi_tmp[["mtime"]])
[17:00:29.680]                     }
[17:00:29.680]                     tryCatch({
[17:00:29.680]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.680]                     }, error = function(ex) {
[17:00:29.680]                       msg <- conditionMessage(ex)
[17:00:29.680]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.680]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.680]                         fi_tmp[["mtime"]], msg)
[17:00:29.680]                       ex$message <- msg
[17:00:29.680]                       stop(ex)
[17:00:29.680]                     })
[17:00:29.680]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.680]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.680]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.680]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.680]                       fi <- file.info(pathname)
[17:00:29.680]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.680]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.680]                         fi[["size"]], fi[["mtime"]])
[17:00:29.680]                       stop(msg)
[17:00:29.680]                     }
[17:00:29.680]                     invisible(pathname)
[17:00:29.680]                   }
[17:00:29.680]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.680]                     rootPath = tempdir()) 
[17:00:29.680]                   {
[17:00:29.680]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.680]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.680]                       tmpdir = path, fileext = ".rds")
[17:00:29.680]                     save_rds(obj, file)
[17:00:29.680]                   }
[17:00:29.680]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.680]                   {
[17:00:29.680]                     inherits <- base::inherits
[17:00:29.680]                     invokeRestart <- base::invokeRestart
[17:00:29.680]                     is.null <- base::is.null
[17:00:29.680]                     muffled <- FALSE
[17:00:29.680]                     if (inherits(cond, "message")) {
[17:00:29.680]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.680]                       if (muffled) 
[17:00:29.680]                         invokeRestart("muffleMessage")
[17:00:29.680]                     }
[17:00:29.680]                     else if (inherits(cond, "warning")) {
[17:00:29.680]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.680]                       if (muffled) 
[17:00:29.680]                         invokeRestart("muffleWarning")
[17:00:29.680]                     }
[17:00:29.680]                     else if (inherits(cond, "condition")) {
[17:00:29.680]                       if (!is.null(pattern)) {
[17:00:29.680]                         computeRestarts <- base::computeRestarts
[17:00:29.680]                         grepl <- base::grepl
[17:00:29.680]                         restarts <- computeRestarts(cond)
[17:00:29.680]                         for (restart in restarts) {
[17:00:29.680]                           name <- restart$name
[17:00:29.680]                           if (is.null(name)) 
[17:00:29.680]                             next
[17:00:29.680]                           if (!grepl(pattern, name)) 
[17:00:29.680]                             next
[17:00:29.680]                           invokeRestart(restart)
[17:00:29.680]                           muffled <- TRUE
[17:00:29.680]                           break
[17:00:29.680]                         }
[17:00:29.680]                       }
[17:00:29.680]                     }
[17:00:29.680]                     invisible(muffled)
[17:00:29.680]                   }
[17:00:29.680]                   muffleCondition(cond)
[17:00:29.680]                 })
[17:00:29.680]             }))
[17:00:29.680]             future::FutureResult(value = ...future.value$value, 
[17:00:29.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.680]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.680]                     ...future.globalenv.names))
[17:00:29.680]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.680]         }, condition = base::local({
[17:00:29.680]             c <- base::c
[17:00:29.680]             inherits <- base::inherits
[17:00:29.680]             invokeRestart <- base::invokeRestart
[17:00:29.680]             length <- base::length
[17:00:29.680]             list <- base::list
[17:00:29.680]             seq.int <- base::seq.int
[17:00:29.680]             signalCondition <- base::signalCondition
[17:00:29.680]             sys.calls <- base::sys.calls
[17:00:29.680]             `[[` <- base::`[[`
[17:00:29.680]             `+` <- base::`+`
[17:00:29.680]             `<<-` <- base::`<<-`
[17:00:29.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.680]                   3L)]
[17:00:29.680]             }
[17:00:29.680]             function(cond) {
[17:00:29.680]                 is_error <- inherits(cond, "error")
[17:00:29.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.680]                   NULL)
[17:00:29.680]                 if (is_error) {
[17:00:29.680]                   sessionInformation <- function() {
[17:00:29.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.680]                       search = base::search(), system = base::Sys.info())
[17:00:29.680]                   }
[17:00:29.680]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.680]                     cond$call), session = sessionInformation(), 
[17:00:29.680]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.680]                   signalCondition(cond)
[17:00:29.680]                 }
[17:00:29.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.680]                 "immediateCondition"))) {
[17:00:29.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.680]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.680]                   if (TRUE && !signal) {
[17:00:29.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.680]                     {
[17:00:29.680]                       inherits <- base::inherits
[17:00:29.680]                       invokeRestart <- base::invokeRestart
[17:00:29.680]                       is.null <- base::is.null
[17:00:29.680]                       muffled <- FALSE
[17:00:29.680]                       if (inherits(cond, "message")) {
[17:00:29.680]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.680]                         if (muffled) 
[17:00:29.680]                           invokeRestart("muffleMessage")
[17:00:29.680]                       }
[17:00:29.680]                       else if (inherits(cond, "warning")) {
[17:00:29.680]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.680]                         if (muffled) 
[17:00:29.680]                           invokeRestart("muffleWarning")
[17:00:29.680]                       }
[17:00:29.680]                       else if (inherits(cond, "condition")) {
[17:00:29.680]                         if (!is.null(pattern)) {
[17:00:29.680]                           computeRestarts <- base::computeRestarts
[17:00:29.680]                           grepl <- base::grepl
[17:00:29.680]                           restarts <- computeRestarts(cond)
[17:00:29.680]                           for (restart in restarts) {
[17:00:29.680]                             name <- restart$name
[17:00:29.680]                             if (is.null(name)) 
[17:00:29.680]                               next
[17:00:29.680]                             if (!grepl(pattern, name)) 
[17:00:29.680]                               next
[17:00:29.680]                             invokeRestart(restart)
[17:00:29.680]                             muffled <- TRUE
[17:00:29.680]                             break
[17:00:29.680]                           }
[17:00:29.680]                         }
[17:00:29.680]                       }
[17:00:29.680]                       invisible(muffled)
[17:00:29.680]                     }
[17:00:29.680]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.680]                   }
[17:00:29.680]                 }
[17:00:29.680]                 else {
[17:00:29.680]                   if (TRUE) {
[17:00:29.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.680]                     {
[17:00:29.680]                       inherits <- base::inherits
[17:00:29.680]                       invokeRestart <- base::invokeRestart
[17:00:29.680]                       is.null <- base::is.null
[17:00:29.680]                       muffled <- FALSE
[17:00:29.680]                       if (inherits(cond, "message")) {
[17:00:29.680]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.680]                         if (muffled) 
[17:00:29.680]                           invokeRestart("muffleMessage")
[17:00:29.680]                       }
[17:00:29.680]                       else if (inherits(cond, "warning")) {
[17:00:29.680]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.680]                         if (muffled) 
[17:00:29.680]                           invokeRestart("muffleWarning")
[17:00:29.680]                       }
[17:00:29.680]                       else if (inherits(cond, "condition")) {
[17:00:29.680]                         if (!is.null(pattern)) {
[17:00:29.680]                           computeRestarts <- base::computeRestarts
[17:00:29.680]                           grepl <- base::grepl
[17:00:29.680]                           restarts <- computeRestarts(cond)
[17:00:29.680]                           for (restart in restarts) {
[17:00:29.680]                             name <- restart$name
[17:00:29.680]                             if (is.null(name)) 
[17:00:29.680]                               next
[17:00:29.680]                             if (!grepl(pattern, name)) 
[17:00:29.680]                               next
[17:00:29.680]                             invokeRestart(restart)
[17:00:29.680]                             muffled <- TRUE
[17:00:29.680]                             break
[17:00:29.680]                           }
[17:00:29.680]                         }
[17:00:29.680]                       }
[17:00:29.680]                       invisible(muffled)
[17:00:29.680]                     }
[17:00:29.680]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.680]                   }
[17:00:29.680]                 }
[17:00:29.680]             }
[17:00:29.680]         }))
[17:00:29.680]     }, error = function(ex) {
[17:00:29.680]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.680]                 ...future.rng), started = ...future.startTime, 
[17:00:29.680]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.680]             version = "1.8"), class = "FutureResult")
[17:00:29.680]     }, finally = {
[17:00:29.680]         if (!identical(...future.workdir, getwd())) 
[17:00:29.680]             setwd(...future.workdir)
[17:00:29.680]         {
[17:00:29.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.680]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.680]             }
[17:00:29.680]             base::options(...future.oldOptions)
[17:00:29.680]             if (.Platform$OS.type == "windows") {
[17:00:29.680]                 old_names <- names(...future.oldEnvVars)
[17:00:29.680]                 envs <- base::Sys.getenv()
[17:00:29.680]                 names <- names(envs)
[17:00:29.680]                 common <- intersect(names, old_names)
[17:00:29.680]                 added <- setdiff(names, old_names)
[17:00:29.680]                 removed <- setdiff(old_names, names)
[17:00:29.680]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.680]                   envs[common]]
[17:00:29.680]                 NAMES <- toupper(changed)
[17:00:29.680]                 args <- list()
[17:00:29.680]                 for (kk in seq_along(NAMES)) {
[17:00:29.680]                   name <- changed[[kk]]
[17:00:29.680]                   NAME <- NAMES[[kk]]
[17:00:29.680]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.680]                     next
[17:00:29.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.680]                 }
[17:00:29.680]                 NAMES <- toupper(added)
[17:00:29.680]                 for (kk in seq_along(NAMES)) {
[17:00:29.680]                   name <- added[[kk]]
[17:00:29.680]                   NAME <- NAMES[[kk]]
[17:00:29.680]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.680]                     next
[17:00:29.680]                   args[[name]] <- ""
[17:00:29.680]                 }
[17:00:29.680]                 NAMES <- toupper(removed)
[17:00:29.680]                 for (kk in seq_along(NAMES)) {
[17:00:29.680]                   name <- removed[[kk]]
[17:00:29.680]                   NAME <- NAMES[[kk]]
[17:00:29.680]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.680]                     next
[17:00:29.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.680]                 }
[17:00:29.680]                 if (length(args) > 0) 
[17:00:29.680]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.680]             }
[17:00:29.680]             else {
[17:00:29.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.680]             }
[17:00:29.680]             {
[17:00:29.680]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.680]                   0L) {
[17:00:29.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.680]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.680]                   base::options(opts)
[17:00:29.680]                 }
[17:00:29.680]                 {
[17:00:29.680]                   {
[17:00:29.680]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.680]                     NULL
[17:00:29.680]                   }
[17:00:29.680]                   options(future.plan = NULL)
[17:00:29.680]                   if (is.na(NA_character_)) 
[17:00:29.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.680]                     .init = FALSE)
[17:00:29.680]                 }
[17:00:29.680]             }
[17:00:29.680]         }
[17:00:29.680]     })
[17:00:29.680]     if (TRUE) {
[17:00:29.680]         base::sink(type = "output", split = FALSE)
[17:00:29.680]         if (TRUE) {
[17:00:29.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.680]         }
[17:00:29.680]         else {
[17:00:29.680]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.680]         }
[17:00:29.680]         base::close(...future.stdout)
[17:00:29.680]         ...future.stdout <- NULL
[17:00:29.680]     }
[17:00:29.680]     ...future.result$conditions <- ...future.conditions
[17:00:29.680]     ...future.result$finished <- base::Sys.time()
[17:00:29.680]     ...future.result
[17:00:29.680] }
[17:00:29.683] assign_globals() ...
[17:00:29.683] List of 5
[17:00:29.683]  $ ...future.FUN            :function (C, k)  
[17:00:29.683]  $ MoreArgs                 : NULL
[17:00:29.683]  $ ...future.elements_ii    :List of 2
[17:00:29.683]   ..$ :List of 1
[17:00:29.683]   .. ..$ : chr "B"
[17:00:29.683]   ..$ :List of 1
[17:00:29.683]   .. ..$ : int 4
[17:00:29.683]  $ ...future.seeds_ii       : NULL
[17:00:29.683]  $ ...future.globals.maxSize: NULL
[17:00:29.683]  - attr(*, "where")=List of 5
[17:00:29.683]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.683]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.683]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.683]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.683]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.683]  - attr(*, "resolved")= logi FALSE
[17:00:29.683]  - attr(*, "total_size")= num 3488
[17:00:29.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.683]  - attr(*, "already-done")= logi TRUE
[17:00:29.691] - reassign environment for ‘...future.FUN’
[17:00:29.691] - copied ‘...future.FUN’ to environment
[17:00:29.691] - copied ‘MoreArgs’ to environment
[17:00:29.692] - copied ‘...future.elements_ii’ to environment
[17:00:29.692] - copied ‘...future.seeds_ii’ to environment
[17:00:29.692] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.692] assign_globals() ... done
[17:00:29.692] requestCore(): workers = 2
[17:00:29.694] MulticoreFuture started
[17:00:29.695] - Launch lazy future ... done
[17:00:29.695] run() for ‘MulticoreFuture’ ... done
[17:00:29.695] Created future:
[17:00:29.696] plan(): Setting new future strategy stack:
[17:00:29.696] List of future strategies:
[17:00:29.696] 1. sequential:
[17:00:29.696]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.696]    - tweaked: FALSE
[17:00:29.696]    - call: NULL
[17:00:29.697] plan(): nbrOfWorkers() = 1
[17:00:29.699] plan(): Setting new future strategy stack:
[17:00:29.699] List of future strategies:
[17:00:29.699] 1. multicore:
[17:00:29.699]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.699]    - tweaked: FALSE
[17:00:29.699]    - call: plan(strategy)
[17:00:29.704] plan(): nbrOfWorkers() = 2
[17:00:29.696] MulticoreFuture:
[17:00:29.696] Label: ‘future_mapply-2’
[17:00:29.696] Expression:
[17:00:29.696] {
[17:00:29.696]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.696]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.696]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.696]         on.exit(options(oopts), add = TRUE)
[17:00:29.696]     }
[17:00:29.696]     {
[17:00:29.696]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.696]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.696]         do.call(mapply, args = args)
[17:00:29.696]     }
[17:00:29.696] }
[17:00:29.696] Lazy evaluation: FALSE
[17:00:29.696] Asynchronous evaluation: TRUE
[17:00:29.696] Local evaluation: TRUE
[17:00:29.696] Environment: R_GlobalEnv
[17:00:29.696] Capture standard output: TRUE
[17:00:29.696] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.696] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.696] Packages: <none>
[17:00:29.696] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.696] Resolved: TRUE
[17:00:29.696] Value: <not collected>
[17:00:29.696] Conditions captured: <none>
[17:00:29.696] Early signaling: FALSE
[17:00:29.696] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.696] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.705] Chunk #2 of 5 ... DONE
[17:00:29.705] Chunk #3 of 5 ...
[17:00:29.705]  - Finding globals in '...' for chunk #3 ...
[17:00:29.706] getGlobalsAndPackages() ...
[17:00:29.706] Searching for globals...
[17:00:29.706] 
[17:00:29.706] Searching for globals ... DONE
[17:00:29.707] - globals: [0] <none>
[17:00:29.707] getGlobalsAndPackages() ... DONE
[17:00:29.707]    + additional globals found: [n=0] 
[17:00:29.707]    + additional namespaces needed: [n=0] 
[17:00:29.707]  - Finding globals in '...' for chunk #3 ... DONE
[17:00:29.707]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:29.707]  - seeds: <none>
[17:00:29.708]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.708] getGlobalsAndPackages() ...
[17:00:29.708] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.708] Resolving globals: FALSE
[17:00:29.709] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:29.710] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.710] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.710] 
[17:00:29.710] getGlobalsAndPackages() ... DONE
[17:00:29.711] run() for ‘Future’ ...
[17:00:29.711] - state: ‘created’
[17:00:29.711] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.716] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.716] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.716]   - Field: ‘label’
[17:00:29.717]   - Field: ‘local’
[17:00:29.717]   - Field: ‘owner’
[17:00:29.717]   - Field: ‘envir’
[17:00:29.717]   - Field: ‘workers’
[17:00:29.717]   - Field: ‘packages’
[17:00:29.717]   - Field: ‘gc’
[17:00:29.718]   - Field: ‘job’
[17:00:29.718]   - Field: ‘conditions’
[17:00:29.718]   - Field: ‘expr’
[17:00:29.718]   - Field: ‘uuid’
[17:00:29.718]   - Field: ‘seed’
[17:00:29.718]   - Field: ‘version’
[17:00:29.718]   - Field: ‘result’
[17:00:29.719]   - Field: ‘asynchronous’
[17:00:29.719]   - Field: ‘calls’
[17:00:29.719]   - Field: ‘globals’
[17:00:29.719]   - Field: ‘stdout’
[17:00:29.719]   - Field: ‘earlySignal’
[17:00:29.719]   - Field: ‘lazy’
[17:00:29.720]   - Field: ‘state’
[17:00:29.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.720] - Launch lazy future ...
[17:00:29.720] Packages needed by the future expression (n = 0): <none>
[17:00:29.721] Packages needed by future strategies (n = 0): <none>
[17:00:29.721] {
[17:00:29.721]     {
[17:00:29.721]         {
[17:00:29.721]             ...future.startTime <- base::Sys.time()
[17:00:29.721]             {
[17:00:29.721]                 {
[17:00:29.721]                   {
[17:00:29.721]                     {
[17:00:29.721]                       base::local({
[17:00:29.721]                         has_future <- base::requireNamespace("future", 
[17:00:29.721]                           quietly = TRUE)
[17:00:29.721]                         if (has_future) {
[17:00:29.721]                           ns <- base::getNamespace("future")
[17:00:29.721]                           version <- ns[[".package"]][["version"]]
[17:00:29.721]                           if (is.null(version)) 
[17:00:29.721]                             version <- utils::packageVersion("future")
[17:00:29.721]                         }
[17:00:29.721]                         else {
[17:00:29.721]                           version <- NULL
[17:00:29.721]                         }
[17:00:29.721]                         if (!has_future || version < "1.8.0") {
[17:00:29.721]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.721]                             "", base::R.version$version.string), 
[17:00:29.721]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.721]                               "release", "version")], collapse = " "), 
[17:00:29.721]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.721]                             info)
[17:00:29.721]                           info <- base::paste(info, collapse = "; ")
[17:00:29.721]                           if (!has_future) {
[17:00:29.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.721]                               info)
[17:00:29.721]                           }
[17:00:29.721]                           else {
[17:00:29.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.721]                               info, version)
[17:00:29.721]                           }
[17:00:29.721]                           base::stop(msg)
[17:00:29.721]                         }
[17:00:29.721]                       })
[17:00:29.721]                     }
[17:00:29.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.721]                     base::options(mc.cores = 1L)
[17:00:29.721]                   }
[17:00:29.721]                   ...future.strategy.old <- future::plan("list")
[17:00:29.721]                   options(future.plan = NULL)
[17:00:29.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.721]                 }
[17:00:29.721]                 ...future.workdir <- getwd()
[17:00:29.721]             }
[17:00:29.721]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.721]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.721]         }
[17:00:29.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.721]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:29.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.721]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.721]             base::names(...future.oldOptions))
[17:00:29.721]     }
[17:00:29.721]     if (FALSE) {
[17:00:29.721]     }
[17:00:29.721]     else {
[17:00:29.721]         if (TRUE) {
[17:00:29.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.721]                 open = "w")
[17:00:29.721]         }
[17:00:29.721]         else {
[17:00:29.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.721]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.721]         }
[17:00:29.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.721]             base::sink(type = "output", split = FALSE)
[17:00:29.721]             base::close(...future.stdout)
[17:00:29.721]         }, add = TRUE)
[17:00:29.721]     }
[17:00:29.721]     ...future.frame <- base::sys.nframe()
[17:00:29.721]     ...future.conditions <- base::list()
[17:00:29.721]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.721]     if (FALSE) {
[17:00:29.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.721]     }
[17:00:29.721]     ...future.result <- base::tryCatch({
[17:00:29.721]         base::withCallingHandlers({
[17:00:29.721]             ...future.value <- base::withVisible(base::local({
[17:00:29.721]                 withCallingHandlers({
[17:00:29.721]                   {
[17:00:29.721]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.721]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.721]                       ...future.globals.maxSize)) {
[17:00:29.721]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.721]                       on.exit(options(oopts), add = TRUE)
[17:00:29.721]                     }
[17:00:29.721]                     {
[17:00:29.721]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.721]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.721]                         USE.NAMES = FALSE)
[17:00:29.721]                       do.call(mapply, args = args)
[17:00:29.721]                     }
[17:00:29.721]                   }
[17:00:29.721]                 }, immediateCondition = function(cond) {
[17:00:29.721]                   save_rds <- function (object, pathname, ...) 
[17:00:29.721]                   {
[17:00:29.721]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.721]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.721]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.721]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.721]                         fi_tmp[["mtime"]])
[17:00:29.721]                     }
[17:00:29.721]                     tryCatch({
[17:00:29.721]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.721]                     }, error = function(ex) {
[17:00:29.721]                       msg <- conditionMessage(ex)
[17:00:29.721]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.721]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.721]                         fi_tmp[["mtime"]], msg)
[17:00:29.721]                       ex$message <- msg
[17:00:29.721]                       stop(ex)
[17:00:29.721]                     })
[17:00:29.721]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.721]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.721]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.721]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.721]                       fi <- file.info(pathname)
[17:00:29.721]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.721]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.721]                         fi[["size"]], fi[["mtime"]])
[17:00:29.721]                       stop(msg)
[17:00:29.721]                     }
[17:00:29.721]                     invisible(pathname)
[17:00:29.721]                   }
[17:00:29.721]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.721]                     rootPath = tempdir()) 
[17:00:29.721]                   {
[17:00:29.721]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.721]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.721]                       tmpdir = path, fileext = ".rds")
[17:00:29.721]                     save_rds(obj, file)
[17:00:29.721]                   }
[17:00:29.721]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.721]                   {
[17:00:29.721]                     inherits <- base::inherits
[17:00:29.721]                     invokeRestart <- base::invokeRestart
[17:00:29.721]                     is.null <- base::is.null
[17:00:29.721]                     muffled <- FALSE
[17:00:29.721]                     if (inherits(cond, "message")) {
[17:00:29.721]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.721]                       if (muffled) 
[17:00:29.721]                         invokeRestart("muffleMessage")
[17:00:29.721]                     }
[17:00:29.721]                     else if (inherits(cond, "warning")) {
[17:00:29.721]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.721]                       if (muffled) 
[17:00:29.721]                         invokeRestart("muffleWarning")
[17:00:29.721]                     }
[17:00:29.721]                     else if (inherits(cond, "condition")) {
[17:00:29.721]                       if (!is.null(pattern)) {
[17:00:29.721]                         computeRestarts <- base::computeRestarts
[17:00:29.721]                         grepl <- base::grepl
[17:00:29.721]                         restarts <- computeRestarts(cond)
[17:00:29.721]                         for (restart in restarts) {
[17:00:29.721]                           name <- restart$name
[17:00:29.721]                           if (is.null(name)) 
[17:00:29.721]                             next
[17:00:29.721]                           if (!grepl(pattern, name)) 
[17:00:29.721]                             next
[17:00:29.721]                           invokeRestart(restart)
[17:00:29.721]                           muffled <- TRUE
[17:00:29.721]                           break
[17:00:29.721]                         }
[17:00:29.721]                       }
[17:00:29.721]                     }
[17:00:29.721]                     invisible(muffled)
[17:00:29.721]                   }
[17:00:29.721]                   muffleCondition(cond)
[17:00:29.721]                 })
[17:00:29.721]             }))
[17:00:29.721]             future::FutureResult(value = ...future.value$value, 
[17:00:29.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.721]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.721]                     ...future.globalenv.names))
[17:00:29.721]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.721]         }, condition = base::local({
[17:00:29.721]             c <- base::c
[17:00:29.721]             inherits <- base::inherits
[17:00:29.721]             invokeRestart <- base::invokeRestart
[17:00:29.721]             length <- base::length
[17:00:29.721]             list <- base::list
[17:00:29.721]             seq.int <- base::seq.int
[17:00:29.721]             signalCondition <- base::signalCondition
[17:00:29.721]             sys.calls <- base::sys.calls
[17:00:29.721]             `[[` <- base::`[[`
[17:00:29.721]             `+` <- base::`+`
[17:00:29.721]             `<<-` <- base::`<<-`
[17:00:29.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.721]                   3L)]
[17:00:29.721]             }
[17:00:29.721]             function(cond) {
[17:00:29.721]                 is_error <- inherits(cond, "error")
[17:00:29.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.721]                   NULL)
[17:00:29.721]                 if (is_error) {
[17:00:29.721]                   sessionInformation <- function() {
[17:00:29.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.721]                       search = base::search(), system = base::Sys.info())
[17:00:29.721]                   }
[17:00:29.721]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.721]                     cond$call), session = sessionInformation(), 
[17:00:29.721]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.721]                   signalCondition(cond)
[17:00:29.721]                 }
[17:00:29.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.721]                 "immediateCondition"))) {
[17:00:29.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.721]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.721]                   if (TRUE && !signal) {
[17:00:29.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.721]                     {
[17:00:29.721]                       inherits <- base::inherits
[17:00:29.721]                       invokeRestart <- base::invokeRestart
[17:00:29.721]                       is.null <- base::is.null
[17:00:29.721]                       muffled <- FALSE
[17:00:29.721]                       if (inherits(cond, "message")) {
[17:00:29.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.721]                         if (muffled) 
[17:00:29.721]                           invokeRestart("muffleMessage")
[17:00:29.721]                       }
[17:00:29.721]                       else if (inherits(cond, "warning")) {
[17:00:29.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.721]                         if (muffled) 
[17:00:29.721]                           invokeRestart("muffleWarning")
[17:00:29.721]                       }
[17:00:29.721]                       else if (inherits(cond, "condition")) {
[17:00:29.721]                         if (!is.null(pattern)) {
[17:00:29.721]                           computeRestarts <- base::computeRestarts
[17:00:29.721]                           grepl <- base::grepl
[17:00:29.721]                           restarts <- computeRestarts(cond)
[17:00:29.721]                           for (restart in restarts) {
[17:00:29.721]                             name <- restart$name
[17:00:29.721]                             if (is.null(name)) 
[17:00:29.721]                               next
[17:00:29.721]                             if (!grepl(pattern, name)) 
[17:00:29.721]                               next
[17:00:29.721]                             invokeRestart(restart)
[17:00:29.721]                             muffled <- TRUE
[17:00:29.721]                             break
[17:00:29.721]                           }
[17:00:29.721]                         }
[17:00:29.721]                       }
[17:00:29.721]                       invisible(muffled)
[17:00:29.721]                     }
[17:00:29.721]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.721]                   }
[17:00:29.721]                 }
[17:00:29.721]                 else {
[17:00:29.721]                   if (TRUE) {
[17:00:29.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.721]                     {
[17:00:29.721]                       inherits <- base::inherits
[17:00:29.721]                       invokeRestart <- base::invokeRestart
[17:00:29.721]                       is.null <- base::is.null
[17:00:29.721]                       muffled <- FALSE
[17:00:29.721]                       if (inherits(cond, "message")) {
[17:00:29.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.721]                         if (muffled) 
[17:00:29.721]                           invokeRestart("muffleMessage")
[17:00:29.721]                       }
[17:00:29.721]                       else if (inherits(cond, "warning")) {
[17:00:29.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.721]                         if (muffled) 
[17:00:29.721]                           invokeRestart("muffleWarning")
[17:00:29.721]                       }
[17:00:29.721]                       else if (inherits(cond, "condition")) {
[17:00:29.721]                         if (!is.null(pattern)) {
[17:00:29.721]                           computeRestarts <- base::computeRestarts
[17:00:29.721]                           grepl <- base::grepl
[17:00:29.721]                           restarts <- computeRestarts(cond)
[17:00:29.721]                           for (restart in restarts) {
[17:00:29.721]                             name <- restart$name
[17:00:29.721]                             if (is.null(name)) 
[17:00:29.721]                               next
[17:00:29.721]                             if (!grepl(pattern, name)) 
[17:00:29.721]                               next
[17:00:29.721]                             invokeRestart(restart)
[17:00:29.721]                             muffled <- TRUE
[17:00:29.721]                             break
[17:00:29.721]                           }
[17:00:29.721]                         }
[17:00:29.721]                       }
[17:00:29.721]                       invisible(muffled)
[17:00:29.721]                     }
[17:00:29.721]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.721]                   }
[17:00:29.721]                 }
[17:00:29.721]             }
[17:00:29.721]         }))
[17:00:29.721]     }, error = function(ex) {
[17:00:29.721]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.721]                 ...future.rng), started = ...future.startTime, 
[17:00:29.721]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.721]             version = "1.8"), class = "FutureResult")
[17:00:29.721]     }, finally = {
[17:00:29.721]         if (!identical(...future.workdir, getwd())) 
[17:00:29.721]             setwd(...future.workdir)
[17:00:29.721]         {
[17:00:29.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.721]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.721]             }
[17:00:29.721]             base::options(...future.oldOptions)
[17:00:29.721]             if (.Platform$OS.type == "windows") {
[17:00:29.721]                 old_names <- names(...future.oldEnvVars)
[17:00:29.721]                 envs <- base::Sys.getenv()
[17:00:29.721]                 names <- names(envs)
[17:00:29.721]                 common <- intersect(names, old_names)
[17:00:29.721]                 added <- setdiff(names, old_names)
[17:00:29.721]                 removed <- setdiff(old_names, names)
[17:00:29.721]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.721]                   envs[common]]
[17:00:29.721]                 NAMES <- toupper(changed)
[17:00:29.721]                 args <- list()
[17:00:29.721]                 for (kk in seq_along(NAMES)) {
[17:00:29.721]                   name <- changed[[kk]]
[17:00:29.721]                   NAME <- NAMES[[kk]]
[17:00:29.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.721]                     next
[17:00:29.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.721]                 }
[17:00:29.721]                 NAMES <- toupper(added)
[17:00:29.721]                 for (kk in seq_along(NAMES)) {
[17:00:29.721]                   name <- added[[kk]]
[17:00:29.721]                   NAME <- NAMES[[kk]]
[17:00:29.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.721]                     next
[17:00:29.721]                   args[[name]] <- ""
[17:00:29.721]                 }
[17:00:29.721]                 NAMES <- toupper(removed)
[17:00:29.721]                 for (kk in seq_along(NAMES)) {
[17:00:29.721]                   name <- removed[[kk]]
[17:00:29.721]                   NAME <- NAMES[[kk]]
[17:00:29.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.721]                     next
[17:00:29.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.721]                 }
[17:00:29.721]                 if (length(args) > 0) 
[17:00:29.721]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.721]             }
[17:00:29.721]             else {
[17:00:29.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.721]             }
[17:00:29.721]             {
[17:00:29.721]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.721]                   0L) {
[17:00:29.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.721]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.721]                   base::options(opts)
[17:00:29.721]                 }
[17:00:29.721]                 {
[17:00:29.721]                   {
[17:00:29.721]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.721]                     NULL
[17:00:29.721]                   }
[17:00:29.721]                   options(future.plan = NULL)
[17:00:29.721]                   if (is.na(NA_character_)) 
[17:00:29.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.721]                     .init = FALSE)
[17:00:29.721]                 }
[17:00:29.721]             }
[17:00:29.721]         }
[17:00:29.721]     })
[17:00:29.721]     if (TRUE) {
[17:00:29.721]         base::sink(type = "output", split = FALSE)
[17:00:29.721]         if (TRUE) {
[17:00:29.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.721]         }
[17:00:29.721]         else {
[17:00:29.721]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.721]         }
[17:00:29.721]         base::close(...future.stdout)
[17:00:29.721]         ...future.stdout <- NULL
[17:00:29.721]     }
[17:00:29.721]     ...future.result$conditions <- ...future.conditions
[17:00:29.721]     ...future.result$finished <- base::Sys.time()
[17:00:29.721]     ...future.result
[17:00:29.721] }
[17:00:29.725] assign_globals() ...
[17:00:29.725] List of 5
[17:00:29.725]  $ ...future.FUN            :function (C, k)  
[17:00:29.725]  $ MoreArgs                 : NULL
[17:00:29.725]  $ ...future.elements_ii    :List of 2
[17:00:29.725]   ..$ :List of 1
[17:00:29.725]   .. ..$ : chr "C"
[17:00:29.725]   ..$ :List of 1
[17:00:29.725]   .. ..$ : int 3
[17:00:29.725]  $ ...future.seeds_ii       : NULL
[17:00:29.725]  $ ...future.globals.maxSize: NULL
[17:00:29.725]  - attr(*, "where")=List of 5
[17:00:29.725]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.725]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.725]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.725]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.725]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.725]  - attr(*, "resolved")= logi FALSE
[17:00:29.725]  - attr(*, "total_size")= num 3488
[17:00:29.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.725]  - attr(*, "already-done")= logi TRUE
[17:00:29.738] - reassign environment for ‘...future.FUN’
[17:00:29.738] - copied ‘...future.FUN’ to environment
[17:00:29.738] - copied ‘MoreArgs’ to environment
[17:00:29.738] - copied ‘...future.elements_ii’ to environment
[17:00:29.738] - copied ‘...future.seeds_ii’ to environment
[17:00:29.739] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.739] assign_globals() ... done
[17:00:29.739] requestCore(): workers = 2
[17:00:29.739] Poll #1 (0): usedCores() = 2, workers = 2
[17:00:29.750] result() for MulticoreFuture ...
[17:00:29.751] result() for MulticoreFuture ...
[17:00:29.751] result() for MulticoreFuture ... done
[17:00:29.751] result() for MulticoreFuture ... done
[17:00:29.751] result() for MulticoreFuture ...
[17:00:29.751] result() for MulticoreFuture ... done
[17:00:29.754] MulticoreFuture started
[17:00:29.755] - Launch lazy future ... done
[17:00:29.755] run() for ‘MulticoreFuture’ ... done
[17:00:29.755] plan(): Setting new future strategy stack:
[17:00:29.756] Created future:
[17:00:29.756] List of future strategies:
[17:00:29.756] 1. sequential:
[17:00:29.756]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.756]    - tweaked: FALSE
[17:00:29.756]    - call: NULL
[17:00:29.758] plan(): nbrOfWorkers() = 1
[17:00:29.760] plan(): Setting new future strategy stack:
[17:00:29.760] List of future strategies:
[17:00:29.760] 1. multicore:
[17:00:29.760]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.760]    - tweaked: FALSE
[17:00:29.760]    - call: plan(strategy)
[17:00:29.766] plan(): nbrOfWorkers() = 2
[17:00:29.756] MulticoreFuture:
[17:00:29.756] Label: ‘future_mapply-3’
[17:00:29.756] Expression:
[17:00:29.756] {
[17:00:29.756]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.756]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.756]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.756]         on.exit(options(oopts), add = TRUE)
[17:00:29.756]     }
[17:00:29.756]     {
[17:00:29.756]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.756]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.756]         do.call(mapply, args = args)
[17:00:29.756]     }
[17:00:29.756] }
[17:00:29.756] Lazy evaluation: FALSE
[17:00:29.756] Asynchronous evaluation: TRUE
[17:00:29.756] Local evaluation: TRUE
[17:00:29.756] Environment: R_GlobalEnv
[17:00:29.756] Capture standard output: TRUE
[17:00:29.756] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.756] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.756] Packages: <none>
[17:00:29.756] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.756] Resolved: TRUE
[17:00:29.756] Value: <not collected>
[17:00:29.756] Conditions captured: <none>
[17:00:29.756] Early signaling: FALSE
[17:00:29.756] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.756] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.767] Chunk #3 of 5 ... DONE
[17:00:29.767] Chunk #4 of 5 ...
[17:00:29.767]  - Finding globals in '...' for chunk #4 ...
[17:00:29.768] getGlobalsAndPackages() ...
[17:00:29.768] Searching for globals...
[17:00:29.768] 
[17:00:29.769] Searching for globals ... DONE
[17:00:29.769] - globals: [0] <none>
[17:00:29.769] getGlobalsAndPackages() ... DONE
[17:00:29.769]    + additional globals found: [n=0] 
[17:00:29.769]    + additional namespaces needed: [n=0] 
[17:00:29.769]  - Finding globals in '...' for chunk #4 ... DONE
[17:00:29.769]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:29.770]  - seeds: <none>
[17:00:29.770]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.770] getGlobalsAndPackages() ...
[17:00:29.770] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.770] Resolving globals: FALSE
[17:00:29.771] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:29.772] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.772] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.772] 
[17:00:29.772] getGlobalsAndPackages() ... DONE
[17:00:29.773] run() for ‘Future’ ...
[17:00:29.773] - state: ‘created’
[17:00:29.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.778] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.778]   - Field: ‘label’
[17:00:29.778]   - Field: ‘local’
[17:00:29.779]   - Field: ‘owner’
[17:00:29.779]   - Field: ‘envir’
[17:00:29.779]   - Field: ‘workers’
[17:00:29.779]   - Field: ‘packages’
[17:00:29.779]   - Field: ‘gc’
[17:00:29.779]   - Field: ‘job’
[17:00:29.779]   - Field: ‘conditions’
[17:00:29.780]   - Field: ‘expr’
[17:00:29.780]   - Field: ‘uuid’
[17:00:29.780]   - Field: ‘seed’
[17:00:29.780]   - Field: ‘version’
[17:00:29.780]   - Field: ‘result’
[17:00:29.780]   - Field: ‘asynchronous’
[17:00:29.781]   - Field: ‘calls’
[17:00:29.781]   - Field: ‘globals’
[17:00:29.781]   - Field: ‘stdout’
[17:00:29.781]   - Field: ‘earlySignal’
[17:00:29.781]   - Field: ‘lazy’
[17:00:29.781]   - Field: ‘state’
[17:00:29.781] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.782] - Launch lazy future ...
[17:00:29.782] Packages needed by the future expression (n = 0): <none>
[17:00:29.782] Packages needed by future strategies (n = 0): <none>
[17:00:29.783] {
[17:00:29.783]     {
[17:00:29.783]         {
[17:00:29.783]             ...future.startTime <- base::Sys.time()
[17:00:29.783]             {
[17:00:29.783]                 {
[17:00:29.783]                   {
[17:00:29.783]                     {
[17:00:29.783]                       base::local({
[17:00:29.783]                         has_future <- base::requireNamespace("future", 
[17:00:29.783]                           quietly = TRUE)
[17:00:29.783]                         if (has_future) {
[17:00:29.783]                           ns <- base::getNamespace("future")
[17:00:29.783]                           version <- ns[[".package"]][["version"]]
[17:00:29.783]                           if (is.null(version)) 
[17:00:29.783]                             version <- utils::packageVersion("future")
[17:00:29.783]                         }
[17:00:29.783]                         else {
[17:00:29.783]                           version <- NULL
[17:00:29.783]                         }
[17:00:29.783]                         if (!has_future || version < "1.8.0") {
[17:00:29.783]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.783]                             "", base::R.version$version.string), 
[17:00:29.783]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.783]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.783]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.783]                               "release", "version")], collapse = " "), 
[17:00:29.783]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.783]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.783]                             info)
[17:00:29.783]                           info <- base::paste(info, collapse = "; ")
[17:00:29.783]                           if (!has_future) {
[17:00:29.783]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.783]                               info)
[17:00:29.783]                           }
[17:00:29.783]                           else {
[17:00:29.783]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.783]                               info, version)
[17:00:29.783]                           }
[17:00:29.783]                           base::stop(msg)
[17:00:29.783]                         }
[17:00:29.783]                       })
[17:00:29.783]                     }
[17:00:29.783]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.783]                     base::options(mc.cores = 1L)
[17:00:29.783]                   }
[17:00:29.783]                   ...future.strategy.old <- future::plan("list")
[17:00:29.783]                   options(future.plan = NULL)
[17:00:29.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.783]                 }
[17:00:29.783]                 ...future.workdir <- getwd()
[17:00:29.783]             }
[17:00:29.783]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.783]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.783]         }
[17:00:29.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.783]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:29.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.783]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.783]             base::names(...future.oldOptions))
[17:00:29.783]     }
[17:00:29.783]     if (FALSE) {
[17:00:29.783]     }
[17:00:29.783]     else {
[17:00:29.783]         if (TRUE) {
[17:00:29.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.783]                 open = "w")
[17:00:29.783]         }
[17:00:29.783]         else {
[17:00:29.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.783]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.783]         }
[17:00:29.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.783]             base::sink(type = "output", split = FALSE)
[17:00:29.783]             base::close(...future.stdout)
[17:00:29.783]         }, add = TRUE)
[17:00:29.783]     }
[17:00:29.783]     ...future.frame <- base::sys.nframe()
[17:00:29.783]     ...future.conditions <- base::list()
[17:00:29.783]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.783]     if (FALSE) {
[17:00:29.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.783]     }
[17:00:29.783]     ...future.result <- base::tryCatch({
[17:00:29.783]         base::withCallingHandlers({
[17:00:29.783]             ...future.value <- base::withVisible(base::local({
[17:00:29.783]                 withCallingHandlers({
[17:00:29.783]                   {
[17:00:29.783]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.783]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.783]                       ...future.globals.maxSize)) {
[17:00:29.783]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.783]                       on.exit(options(oopts), add = TRUE)
[17:00:29.783]                     }
[17:00:29.783]                     {
[17:00:29.783]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.783]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.783]                         USE.NAMES = FALSE)
[17:00:29.783]                       do.call(mapply, args = args)
[17:00:29.783]                     }
[17:00:29.783]                   }
[17:00:29.783]                 }, immediateCondition = function(cond) {
[17:00:29.783]                   save_rds <- function (object, pathname, ...) 
[17:00:29.783]                   {
[17:00:29.783]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.783]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.783]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.783]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.783]                         fi_tmp[["mtime"]])
[17:00:29.783]                     }
[17:00:29.783]                     tryCatch({
[17:00:29.783]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.783]                     }, error = function(ex) {
[17:00:29.783]                       msg <- conditionMessage(ex)
[17:00:29.783]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.783]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.783]                         fi_tmp[["mtime"]], msg)
[17:00:29.783]                       ex$message <- msg
[17:00:29.783]                       stop(ex)
[17:00:29.783]                     })
[17:00:29.783]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.783]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.783]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.783]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.783]                       fi <- file.info(pathname)
[17:00:29.783]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.783]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.783]                         fi[["size"]], fi[["mtime"]])
[17:00:29.783]                       stop(msg)
[17:00:29.783]                     }
[17:00:29.783]                     invisible(pathname)
[17:00:29.783]                   }
[17:00:29.783]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.783]                     rootPath = tempdir()) 
[17:00:29.783]                   {
[17:00:29.783]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.783]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.783]                       tmpdir = path, fileext = ".rds")
[17:00:29.783]                     save_rds(obj, file)
[17:00:29.783]                   }
[17:00:29.783]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.783]                   {
[17:00:29.783]                     inherits <- base::inherits
[17:00:29.783]                     invokeRestart <- base::invokeRestart
[17:00:29.783]                     is.null <- base::is.null
[17:00:29.783]                     muffled <- FALSE
[17:00:29.783]                     if (inherits(cond, "message")) {
[17:00:29.783]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.783]                       if (muffled) 
[17:00:29.783]                         invokeRestart("muffleMessage")
[17:00:29.783]                     }
[17:00:29.783]                     else if (inherits(cond, "warning")) {
[17:00:29.783]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.783]                       if (muffled) 
[17:00:29.783]                         invokeRestart("muffleWarning")
[17:00:29.783]                     }
[17:00:29.783]                     else if (inherits(cond, "condition")) {
[17:00:29.783]                       if (!is.null(pattern)) {
[17:00:29.783]                         computeRestarts <- base::computeRestarts
[17:00:29.783]                         grepl <- base::grepl
[17:00:29.783]                         restarts <- computeRestarts(cond)
[17:00:29.783]                         for (restart in restarts) {
[17:00:29.783]                           name <- restart$name
[17:00:29.783]                           if (is.null(name)) 
[17:00:29.783]                             next
[17:00:29.783]                           if (!grepl(pattern, name)) 
[17:00:29.783]                             next
[17:00:29.783]                           invokeRestart(restart)
[17:00:29.783]                           muffled <- TRUE
[17:00:29.783]                           break
[17:00:29.783]                         }
[17:00:29.783]                       }
[17:00:29.783]                     }
[17:00:29.783]                     invisible(muffled)
[17:00:29.783]                   }
[17:00:29.783]                   muffleCondition(cond)
[17:00:29.783]                 })
[17:00:29.783]             }))
[17:00:29.783]             future::FutureResult(value = ...future.value$value, 
[17:00:29.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.783]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.783]                     ...future.globalenv.names))
[17:00:29.783]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.783]         }, condition = base::local({
[17:00:29.783]             c <- base::c
[17:00:29.783]             inherits <- base::inherits
[17:00:29.783]             invokeRestart <- base::invokeRestart
[17:00:29.783]             length <- base::length
[17:00:29.783]             list <- base::list
[17:00:29.783]             seq.int <- base::seq.int
[17:00:29.783]             signalCondition <- base::signalCondition
[17:00:29.783]             sys.calls <- base::sys.calls
[17:00:29.783]             `[[` <- base::`[[`
[17:00:29.783]             `+` <- base::`+`
[17:00:29.783]             `<<-` <- base::`<<-`
[17:00:29.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.783]                   3L)]
[17:00:29.783]             }
[17:00:29.783]             function(cond) {
[17:00:29.783]                 is_error <- inherits(cond, "error")
[17:00:29.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.783]                   NULL)
[17:00:29.783]                 if (is_error) {
[17:00:29.783]                   sessionInformation <- function() {
[17:00:29.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.783]                       search = base::search(), system = base::Sys.info())
[17:00:29.783]                   }
[17:00:29.783]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.783]                     cond$call), session = sessionInformation(), 
[17:00:29.783]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.783]                   signalCondition(cond)
[17:00:29.783]                 }
[17:00:29.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.783]                 "immediateCondition"))) {
[17:00:29.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.783]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.783]                   if (TRUE && !signal) {
[17:00:29.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.783]                     {
[17:00:29.783]                       inherits <- base::inherits
[17:00:29.783]                       invokeRestart <- base::invokeRestart
[17:00:29.783]                       is.null <- base::is.null
[17:00:29.783]                       muffled <- FALSE
[17:00:29.783]                       if (inherits(cond, "message")) {
[17:00:29.783]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.783]                         if (muffled) 
[17:00:29.783]                           invokeRestart("muffleMessage")
[17:00:29.783]                       }
[17:00:29.783]                       else if (inherits(cond, "warning")) {
[17:00:29.783]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.783]                         if (muffled) 
[17:00:29.783]                           invokeRestart("muffleWarning")
[17:00:29.783]                       }
[17:00:29.783]                       else if (inherits(cond, "condition")) {
[17:00:29.783]                         if (!is.null(pattern)) {
[17:00:29.783]                           computeRestarts <- base::computeRestarts
[17:00:29.783]                           grepl <- base::grepl
[17:00:29.783]                           restarts <- computeRestarts(cond)
[17:00:29.783]                           for (restart in restarts) {
[17:00:29.783]                             name <- restart$name
[17:00:29.783]                             if (is.null(name)) 
[17:00:29.783]                               next
[17:00:29.783]                             if (!grepl(pattern, name)) 
[17:00:29.783]                               next
[17:00:29.783]                             invokeRestart(restart)
[17:00:29.783]                             muffled <- TRUE
[17:00:29.783]                             break
[17:00:29.783]                           }
[17:00:29.783]                         }
[17:00:29.783]                       }
[17:00:29.783]                       invisible(muffled)
[17:00:29.783]                     }
[17:00:29.783]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.783]                   }
[17:00:29.783]                 }
[17:00:29.783]                 else {
[17:00:29.783]                   if (TRUE) {
[17:00:29.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.783]                     {
[17:00:29.783]                       inherits <- base::inherits
[17:00:29.783]                       invokeRestart <- base::invokeRestart
[17:00:29.783]                       is.null <- base::is.null
[17:00:29.783]                       muffled <- FALSE
[17:00:29.783]                       if (inherits(cond, "message")) {
[17:00:29.783]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.783]                         if (muffled) 
[17:00:29.783]                           invokeRestart("muffleMessage")
[17:00:29.783]                       }
[17:00:29.783]                       else if (inherits(cond, "warning")) {
[17:00:29.783]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.783]                         if (muffled) 
[17:00:29.783]                           invokeRestart("muffleWarning")
[17:00:29.783]                       }
[17:00:29.783]                       else if (inherits(cond, "condition")) {
[17:00:29.783]                         if (!is.null(pattern)) {
[17:00:29.783]                           computeRestarts <- base::computeRestarts
[17:00:29.783]                           grepl <- base::grepl
[17:00:29.783]                           restarts <- computeRestarts(cond)
[17:00:29.783]                           for (restart in restarts) {
[17:00:29.783]                             name <- restart$name
[17:00:29.783]                             if (is.null(name)) 
[17:00:29.783]                               next
[17:00:29.783]                             if (!grepl(pattern, name)) 
[17:00:29.783]                               next
[17:00:29.783]                             invokeRestart(restart)
[17:00:29.783]                             muffled <- TRUE
[17:00:29.783]                             break
[17:00:29.783]                           }
[17:00:29.783]                         }
[17:00:29.783]                       }
[17:00:29.783]                       invisible(muffled)
[17:00:29.783]                     }
[17:00:29.783]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.783]                   }
[17:00:29.783]                 }
[17:00:29.783]             }
[17:00:29.783]         }))
[17:00:29.783]     }, error = function(ex) {
[17:00:29.783]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.783]                 ...future.rng), started = ...future.startTime, 
[17:00:29.783]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.783]             version = "1.8"), class = "FutureResult")
[17:00:29.783]     }, finally = {
[17:00:29.783]         if (!identical(...future.workdir, getwd())) 
[17:00:29.783]             setwd(...future.workdir)
[17:00:29.783]         {
[17:00:29.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.783]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.783]             }
[17:00:29.783]             base::options(...future.oldOptions)
[17:00:29.783]             if (.Platform$OS.type == "windows") {
[17:00:29.783]                 old_names <- names(...future.oldEnvVars)
[17:00:29.783]                 envs <- base::Sys.getenv()
[17:00:29.783]                 names <- names(envs)
[17:00:29.783]                 common <- intersect(names, old_names)
[17:00:29.783]                 added <- setdiff(names, old_names)
[17:00:29.783]                 removed <- setdiff(old_names, names)
[17:00:29.783]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.783]                   envs[common]]
[17:00:29.783]                 NAMES <- toupper(changed)
[17:00:29.783]                 args <- list()
[17:00:29.783]                 for (kk in seq_along(NAMES)) {
[17:00:29.783]                   name <- changed[[kk]]
[17:00:29.783]                   NAME <- NAMES[[kk]]
[17:00:29.783]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.783]                     next
[17:00:29.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.783]                 }
[17:00:29.783]                 NAMES <- toupper(added)
[17:00:29.783]                 for (kk in seq_along(NAMES)) {
[17:00:29.783]                   name <- added[[kk]]
[17:00:29.783]                   NAME <- NAMES[[kk]]
[17:00:29.783]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.783]                     next
[17:00:29.783]                   args[[name]] <- ""
[17:00:29.783]                 }
[17:00:29.783]                 NAMES <- toupper(removed)
[17:00:29.783]                 for (kk in seq_along(NAMES)) {
[17:00:29.783]                   name <- removed[[kk]]
[17:00:29.783]                   NAME <- NAMES[[kk]]
[17:00:29.783]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.783]                     next
[17:00:29.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.783]                 }
[17:00:29.783]                 if (length(args) > 0) 
[17:00:29.783]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.783]             }
[17:00:29.783]             else {
[17:00:29.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.783]             }
[17:00:29.783]             {
[17:00:29.783]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.783]                   0L) {
[17:00:29.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.783]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.783]                   base::options(opts)
[17:00:29.783]                 }
[17:00:29.783]                 {
[17:00:29.783]                   {
[17:00:29.783]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.783]                     NULL
[17:00:29.783]                   }
[17:00:29.783]                   options(future.plan = NULL)
[17:00:29.783]                   if (is.na(NA_character_)) 
[17:00:29.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.783]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.783]                     .init = FALSE)
[17:00:29.783]                 }
[17:00:29.783]             }
[17:00:29.783]         }
[17:00:29.783]     })
[17:00:29.783]     if (TRUE) {
[17:00:29.783]         base::sink(type = "output", split = FALSE)
[17:00:29.783]         if (TRUE) {
[17:00:29.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.783]         }
[17:00:29.783]         else {
[17:00:29.783]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.783]         }
[17:00:29.783]         base::close(...future.stdout)
[17:00:29.783]         ...future.stdout <- NULL
[17:00:29.783]     }
[17:00:29.783]     ...future.result$conditions <- ...future.conditions
[17:00:29.783]     ...future.result$finished <- base::Sys.time()
[17:00:29.783]     ...future.result
[17:00:29.783] }
[17:00:29.787] assign_globals() ...
[17:00:29.787] List of 5
[17:00:29.787]  $ ...future.FUN            :function (C, k)  
[17:00:29.787]  $ MoreArgs                 : NULL
[17:00:29.787]  $ ...future.elements_ii    :List of 2
[17:00:29.787]   ..$ :List of 1
[17:00:29.787]   .. ..$ : chr "D"
[17:00:29.787]   ..$ :List of 1
[17:00:29.787]   .. ..$ : int 2
[17:00:29.787]  $ ...future.seeds_ii       : NULL
[17:00:29.787]  $ ...future.globals.maxSize: NULL
[17:00:29.787]  - attr(*, "where")=List of 5
[17:00:29.787]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.787]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.787]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.787]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.787]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.787]  - attr(*, "resolved")= logi FALSE
[17:00:29.787]  - attr(*, "total_size")= num 3488
[17:00:29.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.787]  - attr(*, "already-done")= logi TRUE
[17:00:29.799] - reassign environment for ‘...future.FUN’
[17:00:29.800] - copied ‘...future.FUN’ to environment
[17:00:29.800] - copied ‘MoreArgs’ to environment
[17:00:29.800] - copied ‘...future.elements_ii’ to environment
[17:00:29.800] - copied ‘...future.seeds_ii’ to environment
[17:00:29.800] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.800] assign_globals() ... done
[17:00:29.801] requestCore(): workers = 2
[17:00:29.801] Poll #1 (0): usedCores() = 2, workers = 2
[17:00:29.821] result() for MulticoreFuture ...
[17:00:29.822] result() for MulticoreFuture ...
[17:00:29.822] result() for MulticoreFuture ... done
[17:00:29.822] result() for MulticoreFuture ... done
[17:00:29.823] result() for MulticoreFuture ...
[17:00:29.823] result() for MulticoreFuture ... done
[17:00:29.825] MulticoreFuture started
[17:00:29.826] - Launch lazy future ... done
[17:00:29.826] run() for ‘MulticoreFuture’ ... done
[17:00:29.826] Created future:
[17:00:29.826] plan(): Setting new future strategy stack:
[17:00:29.827] List of future strategies:
[17:00:29.827] 1. sequential:
[17:00:29.827]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.827]    - tweaked: FALSE
[17:00:29.827]    - call: NULL
[17:00:29.828] plan(): nbrOfWorkers() = 1
[17:00:29.831] plan(): Setting new future strategy stack:
[17:00:29.831] List of future strategies:
[17:00:29.831] 1. multicore:
[17:00:29.831]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.831]    - tweaked: FALSE
[17:00:29.831]    - call: plan(strategy)
[17:00:29.836] plan(): nbrOfWorkers() = 2
[17:00:29.827] MulticoreFuture:
[17:00:29.827] Label: ‘future_mapply-4’
[17:00:29.827] Expression:
[17:00:29.827] {
[17:00:29.827]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.827]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.827]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.827]         on.exit(options(oopts), add = TRUE)
[17:00:29.827]     }
[17:00:29.827]     {
[17:00:29.827]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.827]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.827]         do.call(mapply, args = args)
[17:00:29.827]     }
[17:00:29.827] }
[17:00:29.827] Lazy evaluation: FALSE
[17:00:29.827] Asynchronous evaluation: TRUE
[17:00:29.827] Local evaluation: TRUE
[17:00:29.827] Environment: R_GlobalEnv
[17:00:29.827] Capture standard output: TRUE
[17:00:29.827] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.827] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.827] Packages: <none>
[17:00:29.827] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.827] Resolved: TRUE
[17:00:29.827] Value: <not collected>
[17:00:29.827] Conditions captured: <none>
[17:00:29.827] Early signaling: FALSE
[17:00:29.827] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.827] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.837] Chunk #4 of 5 ... DONE
[17:00:29.837] Chunk #5 of 5 ...
[17:00:29.838]  - Finding globals in '...' for chunk #5 ...
[17:00:29.838] getGlobalsAndPackages() ...
[17:00:29.838] Searching for globals...
[17:00:29.838] 
[17:00:29.839] Searching for globals ... DONE
[17:00:29.839] - globals: [0] <none>
[17:00:29.839] getGlobalsAndPackages() ... DONE
[17:00:29.839]    + additional globals found: [n=0] 
[17:00:29.839]    + additional namespaces needed: [n=0] 
[17:00:29.839]  - Finding globals in '...' for chunk #5 ... DONE
[17:00:29.839]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:29.839]  - seeds: <none>
[17:00:29.840]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.840] getGlobalsAndPackages() ...
[17:00:29.840] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.840] Resolving globals: FALSE
[17:00:29.841] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:29.842] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:29.842] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.842] 
[17:00:29.852] getGlobalsAndPackages() ... DONE
[17:00:29.853] run() for ‘Future’ ...
[17:00:29.853] - state: ‘created’
[17:00:29.853] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.857] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.858] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.858]   - Field: ‘label’
[17:00:29.858]   - Field: ‘local’
[17:00:29.858]   - Field: ‘owner’
[17:00:29.858]   - Field: ‘envir’
[17:00:29.859]   - Field: ‘workers’
[17:00:29.859]   - Field: ‘packages’
[17:00:29.859]   - Field: ‘gc’
[17:00:29.859]   - Field: ‘job’
[17:00:29.859]   - Field: ‘conditions’
[17:00:29.860]   - Field: ‘expr’
[17:00:29.860]   - Field: ‘uuid’
[17:00:29.860]   - Field: ‘seed’
[17:00:29.860]   - Field: ‘version’
[17:00:29.860]   - Field: ‘result’
[17:00:29.861]   - Field: ‘asynchronous’
[17:00:29.861]   - Field: ‘calls’
[17:00:29.861]   - Field: ‘globals’
[17:00:29.861]   - Field: ‘stdout’
[17:00:29.861]   - Field: ‘earlySignal’
[17:00:29.862]   - Field: ‘lazy’
[17:00:29.862]   - Field: ‘state’
[17:00:29.862] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.862] - Launch lazy future ...
[17:00:29.863] Packages needed by the future expression (n = 0): <none>
[17:00:29.863] Packages needed by future strategies (n = 0): <none>
[17:00:29.864] {
[17:00:29.864]     {
[17:00:29.864]         {
[17:00:29.864]             ...future.startTime <- base::Sys.time()
[17:00:29.864]             {
[17:00:29.864]                 {
[17:00:29.864]                   {
[17:00:29.864]                     {
[17:00:29.864]                       base::local({
[17:00:29.864]                         has_future <- base::requireNamespace("future", 
[17:00:29.864]                           quietly = TRUE)
[17:00:29.864]                         if (has_future) {
[17:00:29.864]                           ns <- base::getNamespace("future")
[17:00:29.864]                           version <- ns[[".package"]][["version"]]
[17:00:29.864]                           if (is.null(version)) 
[17:00:29.864]                             version <- utils::packageVersion("future")
[17:00:29.864]                         }
[17:00:29.864]                         else {
[17:00:29.864]                           version <- NULL
[17:00:29.864]                         }
[17:00:29.864]                         if (!has_future || version < "1.8.0") {
[17:00:29.864]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.864]                             "", base::R.version$version.string), 
[17:00:29.864]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.864]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.864]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.864]                               "release", "version")], collapse = " "), 
[17:00:29.864]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.864]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.864]                             info)
[17:00:29.864]                           info <- base::paste(info, collapse = "; ")
[17:00:29.864]                           if (!has_future) {
[17:00:29.864]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.864]                               info)
[17:00:29.864]                           }
[17:00:29.864]                           else {
[17:00:29.864]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.864]                               info, version)
[17:00:29.864]                           }
[17:00:29.864]                           base::stop(msg)
[17:00:29.864]                         }
[17:00:29.864]                       })
[17:00:29.864]                     }
[17:00:29.864]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.864]                     base::options(mc.cores = 1L)
[17:00:29.864]                   }
[17:00:29.864]                   ...future.strategy.old <- future::plan("list")
[17:00:29.864]                   options(future.plan = NULL)
[17:00:29.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.864]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.864]                 }
[17:00:29.864]                 ...future.workdir <- getwd()
[17:00:29.864]             }
[17:00:29.864]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.864]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.864]         }
[17:00:29.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.864]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:29.864]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.864]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.864]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.864]             base::names(...future.oldOptions))
[17:00:29.864]     }
[17:00:29.864]     if (FALSE) {
[17:00:29.864]     }
[17:00:29.864]     else {
[17:00:29.864]         if (TRUE) {
[17:00:29.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.864]                 open = "w")
[17:00:29.864]         }
[17:00:29.864]         else {
[17:00:29.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.864]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.864]         }
[17:00:29.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.864]             base::sink(type = "output", split = FALSE)
[17:00:29.864]             base::close(...future.stdout)
[17:00:29.864]         }, add = TRUE)
[17:00:29.864]     }
[17:00:29.864]     ...future.frame <- base::sys.nframe()
[17:00:29.864]     ...future.conditions <- base::list()
[17:00:29.864]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.864]     if (FALSE) {
[17:00:29.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.864]     }
[17:00:29.864]     ...future.result <- base::tryCatch({
[17:00:29.864]         base::withCallingHandlers({
[17:00:29.864]             ...future.value <- base::withVisible(base::local({
[17:00:29.864]                 withCallingHandlers({
[17:00:29.864]                   {
[17:00:29.864]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.864]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.864]                       ...future.globals.maxSize)) {
[17:00:29.864]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.864]                       on.exit(options(oopts), add = TRUE)
[17:00:29.864]                     }
[17:00:29.864]                     {
[17:00:29.864]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.864]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.864]                         USE.NAMES = FALSE)
[17:00:29.864]                       do.call(mapply, args = args)
[17:00:29.864]                     }
[17:00:29.864]                   }
[17:00:29.864]                 }, immediateCondition = function(cond) {
[17:00:29.864]                   save_rds <- function (object, pathname, ...) 
[17:00:29.864]                   {
[17:00:29.864]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.864]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.864]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.864]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.864]                         fi_tmp[["mtime"]])
[17:00:29.864]                     }
[17:00:29.864]                     tryCatch({
[17:00:29.864]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.864]                     }, error = function(ex) {
[17:00:29.864]                       msg <- conditionMessage(ex)
[17:00:29.864]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.864]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.864]                         fi_tmp[["mtime"]], msg)
[17:00:29.864]                       ex$message <- msg
[17:00:29.864]                       stop(ex)
[17:00:29.864]                     })
[17:00:29.864]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.864]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.864]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.864]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.864]                       fi <- file.info(pathname)
[17:00:29.864]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.864]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.864]                         fi[["size"]], fi[["mtime"]])
[17:00:29.864]                       stop(msg)
[17:00:29.864]                     }
[17:00:29.864]                     invisible(pathname)
[17:00:29.864]                   }
[17:00:29.864]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.864]                     rootPath = tempdir()) 
[17:00:29.864]                   {
[17:00:29.864]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.864]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.864]                       tmpdir = path, fileext = ".rds")
[17:00:29.864]                     save_rds(obj, file)
[17:00:29.864]                   }
[17:00:29.864]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.864]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.864]                   {
[17:00:29.864]                     inherits <- base::inherits
[17:00:29.864]                     invokeRestart <- base::invokeRestart
[17:00:29.864]                     is.null <- base::is.null
[17:00:29.864]                     muffled <- FALSE
[17:00:29.864]                     if (inherits(cond, "message")) {
[17:00:29.864]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.864]                       if (muffled) 
[17:00:29.864]                         invokeRestart("muffleMessage")
[17:00:29.864]                     }
[17:00:29.864]                     else if (inherits(cond, "warning")) {
[17:00:29.864]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.864]                       if (muffled) 
[17:00:29.864]                         invokeRestart("muffleWarning")
[17:00:29.864]                     }
[17:00:29.864]                     else if (inherits(cond, "condition")) {
[17:00:29.864]                       if (!is.null(pattern)) {
[17:00:29.864]                         computeRestarts <- base::computeRestarts
[17:00:29.864]                         grepl <- base::grepl
[17:00:29.864]                         restarts <- computeRestarts(cond)
[17:00:29.864]                         for (restart in restarts) {
[17:00:29.864]                           name <- restart$name
[17:00:29.864]                           if (is.null(name)) 
[17:00:29.864]                             next
[17:00:29.864]                           if (!grepl(pattern, name)) 
[17:00:29.864]                             next
[17:00:29.864]                           invokeRestart(restart)
[17:00:29.864]                           muffled <- TRUE
[17:00:29.864]                           break
[17:00:29.864]                         }
[17:00:29.864]                       }
[17:00:29.864]                     }
[17:00:29.864]                     invisible(muffled)
[17:00:29.864]                   }
[17:00:29.864]                   muffleCondition(cond)
[17:00:29.864]                 })
[17:00:29.864]             }))
[17:00:29.864]             future::FutureResult(value = ...future.value$value, 
[17:00:29.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.864]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.864]                     ...future.globalenv.names))
[17:00:29.864]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.864]         }, condition = base::local({
[17:00:29.864]             c <- base::c
[17:00:29.864]             inherits <- base::inherits
[17:00:29.864]             invokeRestart <- base::invokeRestart
[17:00:29.864]             length <- base::length
[17:00:29.864]             list <- base::list
[17:00:29.864]             seq.int <- base::seq.int
[17:00:29.864]             signalCondition <- base::signalCondition
[17:00:29.864]             sys.calls <- base::sys.calls
[17:00:29.864]             `[[` <- base::`[[`
[17:00:29.864]             `+` <- base::`+`
[17:00:29.864]             `<<-` <- base::`<<-`
[17:00:29.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.864]                   3L)]
[17:00:29.864]             }
[17:00:29.864]             function(cond) {
[17:00:29.864]                 is_error <- inherits(cond, "error")
[17:00:29.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.864]                   NULL)
[17:00:29.864]                 if (is_error) {
[17:00:29.864]                   sessionInformation <- function() {
[17:00:29.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.864]                       search = base::search(), system = base::Sys.info())
[17:00:29.864]                   }
[17:00:29.864]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.864]                     cond$call), session = sessionInformation(), 
[17:00:29.864]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.864]                   signalCondition(cond)
[17:00:29.864]                 }
[17:00:29.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.864]                 "immediateCondition"))) {
[17:00:29.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.864]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.864]                   if (TRUE && !signal) {
[17:00:29.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.864]                     {
[17:00:29.864]                       inherits <- base::inherits
[17:00:29.864]                       invokeRestart <- base::invokeRestart
[17:00:29.864]                       is.null <- base::is.null
[17:00:29.864]                       muffled <- FALSE
[17:00:29.864]                       if (inherits(cond, "message")) {
[17:00:29.864]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.864]                         if (muffled) 
[17:00:29.864]                           invokeRestart("muffleMessage")
[17:00:29.864]                       }
[17:00:29.864]                       else if (inherits(cond, "warning")) {
[17:00:29.864]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.864]                         if (muffled) 
[17:00:29.864]                           invokeRestart("muffleWarning")
[17:00:29.864]                       }
[17:00:29.864]                       else if (inherits(cond, "condition")) {
[17:00:29.864]                         if (!is.null(pattern)) {
[17:00:29.864]                           computeRestarts <- base::computeRestarts
[17:00:29.864]                           grepl <- base::grepl
[17:00:29.864]                           restarts <- computeRestarts(cond)
[17:00:29.864]                           for (restart in restarts) {
[17:00:29.864]                             name <- restart$name
[17:00:29.864]                             if (is.null(name)) 
[17:00:29.864]                               next
[17:00:29.864]                             if (!grepl(pattern, name)) 
[17:00:29.864]                               next
[17:00:29.864]                             invokeRestart(restart)
[17:00:29.864]                             muffled <- TRUE
[17:00:29.864]                             break
[17:00:29.864]                           }
[17:00:29.864]                         }
[17:00:29.864]                       }
[17:00:29.864]                       invisible(muffled)
[17:00:29.864]                     }
[17:00:29.864]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.864]                   }
[17:00:29.864]                 }
[17:00:29.864]                 else {
[17:00:29.864]                   if (TRUE) {
[17:00:29.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.864]                     {
[17:00:29.864]                       inherits <- base::inherits
[17:00:29.864]                       invokeRestart <- base::invokeRestart
[17:00:29.864]                       is.null <- base::is.null
[17:00:29.864]                       muffled <- FALSE
[17:00:29.864]                       if (inherits(cond, "message")) {
[17:00:29.864]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.864]                         if (muffled) 
[17:00:29.864]                           invokeRestart("muffleMessage")
[17:00:29.864]                       }
[17:00:29.864]                       else if (inherits(cond, "warning")) {
[17:00:29.864]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.864]                         if (muffled) 
[17:00:29.864]                           invokeRestart("muffleWarning")
[17:00:29.864]                       }
[17:00:29.864]                       else if (inherits(cond, "condition")) {
[17:00:29.864]                         if (!is.null(pattern)) {
[17:00:29.864]                           computeRestarts <- base::computeRestarts
[17:00:29.864]                           grepl <- base::grepl
[17:00:29.864]                           restarts <- computeRestarts(cond)
[17:00:29.864]                           for (restart in restarts) {
[17:00:29.864]                             name <- restart$name
[17:00:29.864]                             if (is.null(name)) 
[17:00:29.864]                               next
[17:00:29.864]                             if (!grepl(pattern, name)) 
[17:00:29.864]                               next
[17:00:29.864]                             invokeRestart(restart)
[17:00:29.864]                             muffled <- TRUE
[17:00:29.864]                             break
[17:00:29.864]                           }
[17:00:29.864]                         }
[17:00:29.864]                       }
[17:00:29.864]                       invisible(muffled)
[17:00:29.864]                     }
[17:00:29.864]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.864]                   }
[17:00:29.864]                 }
[17:00:29.864]             }
[17:00:29.864]         }))
[17:00:29.864]     }, error = function(ex) {
[17:00:29.864]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.864]                 ...future.rng), started = ...future.startTime, 
[17:00:29.864]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.864]             version = "1.8"), class = "FutureResult")
[17:00:29.864]     }, finally = {
[17:00:29.864]         if (!identical(...future.workdir, getwd())) 
[17:00:29.864]             setwd(...future.workdir)
[17:00:29.864]         {
[17:00:29.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.864]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.864]             }
[17:00:29.864]             base::options(...future.oldOptions)
[17:00:29.864]             if (.Platform$OS.type == "windows") {
[17:00:29.864]                 old_names <- names(...future.oldEnvVars)
[17:00:29.864]                 envs <- base::Sys.getenv()
[17:00:29.864]                 names <- names(envs)
[17:00:29.864]                 common <- intersect(names, old_names)
[17:00:29.864]                 added <- setdiff(names, old_names)
[17:00:29.864]                 removed <- setdiff(old_names, names)
[17:00:29.864]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.864]                   envs[common]]
[17:00:29.864]                 NAMES <- toupper(changed)
[17:00:29.864]                 args <- list()
[17:00:29.864]                 for (kk in seq_along(NAMES)) {
[17:00:29.864]                   name <- changed[[kk]]
[17:00:29.864]                   NAME <- NAMES[[kk]]
[17:00:29.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.864]                     next
[17:00:29.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.864]                 }
[17:00:29.864]                 NAMES <- toupper(added)
[17:00:29.864]                 for (kk in seq_along(NAMES)) {
[17:00:29.864]                   name <- added[[kk]]
[17:00:29.864]                   NAME <- NAMES[[kk]]
[17:00:29.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.864]                     next
[17:00:29.864]                   args[[name]] <- ""
[17:00:29.864]                 }
[17:00:29.864]                 NAMES <- toupper(removed)
[17:00:29.864]                 for (kk in seq_along(NAMES)) {
[17:00:29.864]                   name <- removed[[kk]]
[17:00:29.864]                   NAME <- NAMES[[kk]]
[17:00:29.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.864]                     next
[17:00:29.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.864]                 }
[17:00:29.864]                 if (length(args) > 0) 
[17:00:29.864]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.864]             }
[17:00:29.864]             else {
[17:00:29.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.864]             }
[17:00:29.864]             {
[17:00:29.864]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.864]                   0L) {
[17:00:29.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.864]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.864]                   base::options(opts)
[17:00:29.864]                 }
[17:00:29.864]                 {
[17:00:29.864]                   {
[17:00:29.864]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.864]                     NULL
[17:00:29.864]                   }
[17:00:29.864]                   options(future.plan = NULL)
[17:00:29.864]                   if (is.na(NA_character_)) 
[17:00:29.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.864]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.864]                     .init = FALSE)
[17:00:29.864]                 }
[17:00:29.864]             }
[17:00:29.864]         }
[17:00:29.864]     })
[17:00:29.864]     if (TRUE) {
[17:00:29.864]         base::sink(type = "output", split = FALSE)
[17:00:29.864]         if (TRUE) {
[17:00:29.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.864]         }
[17:00:29.864]         else {
[17:00:29.864]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.864]         }
[17:00:29.864]         base::close(...future.stdout)
[17:00:29.864]         ...future.stdout <- NULL
[17:00:29.864]     }
[17:00:29.864]     ...future.result$conditions <- ...future.conditions
[17:00:29.864]     ...future.result$finished <- base::Sys.time()
[17:00:29.864]     ...future.result
[17:00:29.864] }
[17:00:29.867] assign_globals() ...
[17:00:29.867] List of 5
[17:00:29.867]  $ ...future.FUN            :function (C, k)  
[17:00:29.867]  $ MoreArgs                 : NULL
[17:00:29.867]  $ ...future.elements_ii    :List of 2
[17:00:29.867]   ..$ :List of 1
[17:00:29.867]   .. ..$ : chr "E"
[17:00:29.867]   ..$ :List of 1
[17:00:29.867]   .. ..$ : int 1
[17:00:29.867]  $ ...future.seeds_ii       : NULL
[17:00:29.867]  $ ...future.globals.maxSize: NULL
[17:00:29.867]  - attr(*, "where")=List of 5
[17:00:29.867]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.867]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.867]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.867]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.867]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.867]  - attr(*, "resolved")= logi FALSE
[17:00:29.867]  - attr(*, "total_size")= num 3488
[17:00:29.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.867]  - attr(*, "already-done")= logi TRUE
[17:00:29.874] - reassign environment for ‘...future.FUN’
[17:00:29.874] - copied ‘...future.FUN’ to environment
[17:00:29.874] - copied ‘MoreArgs’ to environment
[17:00:29.874] - copied ‘...future.elements_ii’ to environment
[17:00:29.874] - copied ‘...future.seeds_ii’ to environment
[17:00:29.874] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.874] assign_globals() ... done
[17:00:29.874] requestCore(): workers = 2
[17:00:29.875] Poll #1 (0): usedCores() = 2, workers = 2
[17:00:29.885] result() for MulticoreFuture ...
[17:00:29.886] result() for MulticoreFuture ...
[17:00:29.886] result() for MulticoreFuture ... done
[17:00:29.886] result() for MulticoreFuture ... done
[17:00:29.887] result() for MulticoreFuture ...
[17:00:29.887] result() for MulticoreFuture ... done
[17:00:29.890] MulticoreFuture started
[17:00:29.890] - Launch lazy future ... done
[17:00:29.891] run() for ‘MulticoreFuture’ ... done
[17:00:29.891] Created future:
[17:00:29.891] plan(): Setting new future strategy stack:
[17:00:29.891] List of future strategies:
[17:00:29.891] 1. sequential:
[17:00:29.891]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.891]    - tweaked: FALSE
[17:00:29.891]    - call: NULL
[17:00:29.892] plan(): nbrOfWorkers() = 1
[17:00:29.894] plan(): Setting new future strategy stack:
[17:00:29.895] List of future strategies:
[17:00:29.895] 1. multicore:
[17:00:29.895]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.895]    - tweaked: FALSE
[17:00:29.895]    - call: plan(strategy)
[17:00:29.900] plan(): nbrOfWorkers() = 2
[17:00:29.891] MulticoreFuture:
[17:00:29.891] Label: ‘future_mapply-5’
[17:00:29.891] Expression:
[17:00:29.891] {
[17:00:29.891]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.891]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.891]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.891]         on.exit(options(oopts), add = TRUE)
[17:00:29.891]     }
[17:00:29.891]     {
[17:00:29.891]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.891]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.891]         do.call(mapply, args = args)
[17:00:29.891]     }
[17:00:29.891] }
[17:00:29.891] Lazy evaluation: FALSE
[17:00:29.891] Asynchronous evaluation: TRUE
[17:00:29.891] Local evaluation: TRUE
[17:00:29.891] Environment: R_GlobalEnv
[17:00:29.891] Capture standard output: TRUE
[17:00:29.891] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.891] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.891] Packages: <none>
[17:00:29.891] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.891] Resolved: TRUE
[17:00:29.891] Value: <not collected>
[17:00:29.891] Conditions captured: <none>
[17:00:29.891] Early signaling: FALSE
[17:00:29.891] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.891] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.901] Chunk #5 of 5 ... DONE
[17:00:29.901] Launching 5 futures (chunks) ... DONE
[17:00:29.901] Resolving 5 futures (chunks) ...
[17:00:29.901] resolve() on list ...
[17:00:29.901]  recursive: 0
[17:00:29.902]  length: 5
[17:00:29.902] 
[17:00:29.902] Future #1
[17:00:29.902] result() for MulticoreFuture ...
[17:00:29.902] result() for MulticoreFuture ... done
[17:00:29.902] result() for MulticoreFuture ...
[17:00:29.902] result() for MulticoreFuture ... done
[17:00:29.903] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:29.903] - nx: 5
[17:00:29.903] - relay: TRUE
[17:00:29.903] - stdout: TRUE
[17:00:29.903] - signal: TRUE
[17:00:29.903] - resignal: FALSE
[17:00:29.903] - force: TRUE
[17:00:29.904] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:00:29.904] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:00:29.904]  - until=1
[17:00:29.904]  - relaying element #1
[17:00:29.904] result() for MulticoreFuture ...
[17:00:29.904] result() for MulticoreFuture ... done
[17:00:29.905] result() for MulticoreFuture ...
[17:00:29.905] result() for MulticoreFuture ... done
[17:00:29.905] result() for MulticoreFuture ...
[17:00:29.905] result() for MulticoreFuture ... done
[17:00:29.905] result() for MulticoreFuture ...
[17:00:29.905] result() for MulticoreFuture ... done
[17:00:29.906] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:29.906] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:29.906] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:29.906]  length: 4 (resolved future 1)
[17:00:29.906] Future #2
[17:00:29.906] result() for MulticoreFuture ...
[17:00:29.907] result() for MulticoreFuture ... done
[17:00:29.907] result() for MulticoreFuture ...
[17:00:29.907] result() for MulticoreFuture ... done
[17:00:29.907] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:29.907] - nx: 5
[17:00:29.907] - relay: TRUE
[17:00:29.908] - stdout: TRUE
[17:00:29.908] - signal: TRUE
[17:00:29.908] - resignal: FALSE
[17:00:29.908] - force: TRUE
[17:00:29.908] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:29.908] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:29.908]  - until=2
[17:00:29.909]  - relaying element #2
[17:00:29.909] result() for MulticoreFuture ...
[17:00:29.909] result() for MulticoreFuture ... done
[17:00:29.909] result() for MulticoreFuture ...
[17:00:29.909] result() for MulticoreFuture ... done
[17:00:29.909] result() for MulticoreFuture ...
[17:00:29.910] result() for MulticoreFuture ... done
[17:00:29.910] result() for MulticoreFuture ...
[17:00:29.910] result() for MulticoreFuture ... done
[17:00:29.910] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:29.910] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:29.910] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:29.910]  length: 3 (resolved future 2)
[17:00:29.911] Future #3
[17:00:29.911] result() for MulticoreFuture ...
[17:00:29.911] result() for MulticoreFuture ... done
[17:00:29.911] result() for MulticoreFuture ...
[17:00:29.911] result() for MulticoreFuture ... done
[17:00:29.915] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:00:29.915] - nx: 5
[17:00:29.916] - relay: TRUE
[17:00:29.916] - stdout: TRUE
[17:00:29.916] - signal: TRUE
[17:00:29.917] - resignal: FALSE
[17:00:29.917] - force: TRUE
[17:00:29.917] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:29.917] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:29.917]  - until=3
[17:00:29.918]  - relaying element #3
[17:00:29.918] result() for MulticoreFuture ...
[17:00:29.918] result() for MulticoreFuture ... done
[17:00:29.918] result() for MulticoreFuture ...
[17:00:29.919] result() for MulticoreFuture ... done
[17:00:29.919] result() for MulticoreFuture ...
[17:00:29.919] result() for MulticoreFuture ... done
[17:00:29.919] result() for MulticoreFuture ...
[17:00:29.920] result() for MulticoreFuture ... done
[17:00:29.920] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:29.920] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:29.920] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:00:29.920]  length: 2 (resolved future 3)
[17:00:29.921] Future #4
[17:00:29.921] result() for MulticoreFuture ...
[17:00:29.922] result() for MulticoreFuture ...
[17:00:29.923] result() for MulticoreFuture ... done
[17:00:29.923] result() for MulticoreFuture ... done
[17:00:29.923] result() for MulticoreFuture ...
[17:00:29.923] result() for MulticoreFuture ... done
[17:00:29.924] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:00:29.924] - nx: 5
[17:00:29.924] - relay: TRUE
[17:00:29.924] - stdout: TRUE
[17:00:29.925] - signal: TRUE
[17:00:29.925] - resignal: FALSE
[17:00:29.925] - force: TRUE
[17:00:29.925] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:29.925] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:29.926]  - until=4
[17:00:29.926]  - relaying element #4
[17:00:29.926] result() for MulticoreFuture ...
[17:00:29.926] result() for MulticoreFuture ... done
[17:00:29.927] result() for MulticoreFuture ...
[17:00:29.927] result() for MulticoreFuture ... done
[17:00:29.927] result() for MulticoreFuture ...
[17:00:29.927] result() for MulticoreFuture ... done
[17:00:29.928] result() for MulticoreFuture ...
[17:00:29.928] result() for MulticoreFuture ... done
[17:00:29.928] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:29.928] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:29.928] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:00:29.928]  length: 1 (resolved future 4)
[17:00:29.928] Future #5
[17:00:29.929] result() for MulticoreFuture ...
[17:00:29.929] result() for MulticoreFuture ...
[17:00:29.930] result() for MulticoreFuture ... done
[17:00:29.930] result() for MulticoreFuture ... done
[17:00:29.930] result() for MulticoreFuture ...
[17:00:29.930] result() for MulticoreFuture ... done
[17:00:29.930] signalConditionsASAP(MulticoreFuture, pos=5) ...
[17:00:29.930] - nx: 5
[17:00:29.931] - relay: TRUE
[17:00:29.931] - stdout: TRUE
[17:00:29.931] - signal: TRUE
[17:00:29.931] - resignal: FALSE
[17:00:29.931] - force: TRUE
[17:00:29.932] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:29.932] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:29.932]  - until=5
[17:00:29.932]  - relaying element #5
[17:00:29.932] result() for MulticoreFuture ...
[17:00:29.932] result() for MulticoreFuture ... done
[17:00:29.933] result() for MulticoreFuture ...
[17:00:29.933] result() for MulticoreFuture ... done
[17:00:29.933] result() for MulticoreFuture ...
[17:00:29.933] result() for MulticoreFuture ... done
[17:00:29.933] result() for MulticoreFuture ...
[17:00:29.933] result() for MulticoreFuture ... done
[17:00:29.934] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:29.934] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:29.934] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[17:00:29.934]  length: 0 (resolved future 5)
[17:00:29.934] Relaying remaining futures
[17:00:29.934] signalConditionsASAP(NULL, pos=0) ...
[17:00:29.934] - nx: 5
[17:00:29.934] - relay: TRUE
[17:00:29.934] - stdout: TRUE
[17:00:29.934] - signal: TRUE
[17:00:29.934] - resignal: FALSE
[17:00:29.935] - force: TRUE
[17:00:29.935] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:29.935] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[17:00:29.935] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:29.935] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:29.935] signalConditionsASAP(NULL, pos=0) ... done
[17:00:29.935] resolve() on list ... DONE
[17:00:29.935] result() for MulticoreFuture ...
[17:00:29.935] result() for MulticoreFuture ... done
[17:00:29.936] result() for MulticoreFuture ...
[17:00:29.936] result() for MulticoreFuture ... done
[17:00:29.936] result() for MulticoreFuture ...
[17:00:29.936] result() for MulticoreFuture ... done
[17:00:29.936] result() for MulticoreFuture ...
[17:00:29.936] result() for MulticoreFuture ... done
[17:00:29.936] result() for MulticoreFuture ...
[17:00:29.937] result() for MulticoreFuture ... done
[17:00:29.937] result() for MulticoreFuture ...
[17:00:29.937] result() for MulticoreFuture ... done
[17:00:29.937] result() for MulticoreFuture ...
[17:00:29.937] result() for MulticoreFuture ... done
[17:00:29.937] result() for MulticoreFuture ...
[17:00:29.937] result() for MulticoreFuture ... done
[17:00:29.938] result() for MulticoreFuture ...
[17:00:29.938] result() for MulticoreFuture ... done
[17:00:29.938] result() for MulticoreFuture ...
[17:00:29.938] result() for MulticoreFuture ... done
[17:00:29.938]  - Number of value chunks collected: 5
[17:00:29.938] Resolving 5 futures (chunks) ... DONE
[17:00:29.938] Reducing values from 5 chunks ...
[17:00:29.938]  - Number of values collected after concatenation: 5
[17:00:29.938]  - Number of values expected: 5
[17:00:29.938] Reducing values from 5 chunks ... DONE
[17:00:29.939] future_mapply() ... DONE
[17:00:29.939] future_mapply() ...
[17:00:29.943] Number of chunks: 2
[17:00:29.943] getGlobalsAndPackagesXApply() ...
[17:00:29.943]  - future.globals: TRUE
[17:00:29.943] getGlobalsAndPackages() ...
[17:00:29.943] Searching for globals...
[17:00:29.945] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:29.945] Searching for globals ... DONE
[17:00:29.945] Resolving globals: FALSE
[17:00:29.946] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:29.946] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:29.946] - globals: [1] ‘FUN’
[17:00:29.946] 
[17:00:29.946] getGlobalsAndPackages() ... DONE
[17:00:29.946]  - globals found/used: [n=1] ‘FUN’
[17:00:29.946]  - needed namespaces: [n=0] 
[17:00:29.947] Finding globals ... DONE
[17:00:29.947] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:29.947] List of 2
[17:00:29.947]  $ ...future.FUN:function (C, k)  
[17:00:29.947]  $ MoreArgs     : list()
[17:00:29.947]  - attr(*, "where")=List of 2
[17:00:29.947]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:29.947]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:29.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.947]  - attr(*, "resolved")= logi FALSE
[17:00:29.947]  - attr(*, "total_size")= num NA
[17:00:29.950] Packages to be attached in all futures: [n=0] 
[17:00:29.950] getGlobalsAndPackagesXApply() ... DONE
[17:00:29.950] Number of futures (= number of chunks): 2
[17:00:29.952] Launching 2 futures (chunks) ...
[17:00:29.952] Chunk #1 of 2 ...
[17:00:29.953]  - Finding globals in '...' for chunk #1 ...
[17:00:29.953] getGlobalsAndPackages() ...
[17:00:29.953] Searching for globals...
[17:00:29.953] 
[17:00:29.953] Searching for globals ... DONE
[17:00:29.954] - globals: [0] <none>
[17:00:29.954] getGlobalsAndPackages() ... DONE
[17:00:29.954]    + additional globals found: [n=0] 
[17:00:29.954]    + additional namespaces needed: [n=0] 
[17:00:29.954]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:29.954]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.954]  - seeds: <none>
[17:00:29.954]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.954] getGlobalsAndPackages() ...
[17:00:29.955] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.955] Resolving globals: FALSE
[17:00:29.955] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:29.956] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:29.956] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.956] 
[17:00:29.956] getGlobalsAndPackages() ... DONE
[17:00:29.957] run() for ‘Future’ ...
[17:00:29.957] - state: ‘created’
[17:00:29.957] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:29.961] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.961] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:29.961]   - Field: ‘label’
[17:00:29.961]   - Field: ‘local’
[17:00:29.961]   - Field: ‘owner’
[17:00:29.962]   - Field: ‘envir’
[17:00:29.962]   - Field: ‘workers’
[17:00:29.962]   - Field: ‘packages’
[17:00:29.962]   - Field: ‘gc’
[17:00:29.962]   - Field: ‘job’
[17:00:29.962]   - Field: ‘conditions’
[17:00:29.962]   - Field: ‘expr’
[17:00:29.962]   - Field: ‘uuid’
[17:00:29.962]   - Field: ‘seed’
[17:00:29.962]   - Field: ‘version’
[17:00:29.963]   - Field: ‘result’
[17:00:29.963]   - Field: ‘asynchronous’
[17:00:29.963]   - Field: ‘calls’
[17:00:29.963]   - Field: ‘globals’
[17:00:29.963]   - Field: ‘stdout’
[17:00:29.963]   - Field: ‘earlySignal’
[17:00:29.963]   - Field: ‘lazy’
[17:00:29.963]   - Field: ‘state’
[17:00:29.963] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:29.963] - Launch lazy future ...
[17:00:29.964] Packages needed by the future expression (n = 0): <none>
[17:00:29.964] Packages needed by future strategies (n = 0): <none>
[17:00:29.964] {
[17:00:29.964]     {
[17:00:29.964]         {
[17:00:29.964]             ...future.startTime <- base::Sys.time()
[17:00:29.964]             {
[17:00:29.964]                 {
[17:00:29.964]                   {
[17:00:29.964]                     {
[17:00:29.964]                       base::local({
[17:00:29.964]                         has_future <- base::requireNamespace("future", 
[17:00:29.964]                           quietly = TRUE)
[17:00:29.964]                         if (has_future) {
[17:00:29.964]                           ns <- base::getNamespace("future")
[17:00:29.964]                           version <- ns[[".package"]][["version"]]
[17:00:29.964]                           if (is.null(version)) 
[17:00:29.964]                             version <- utils::packageVersion("future")
[17:00:29.964]                         }
[17:00:29.964]                         else {
[17:00:29.964]                           version <- NULL
[17:00:29.964]                         }
[17:00:29.964]                         if (!has_future || version < "1.8.0") {
[17:00:29.964]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:29.964]                             "", base::R.version$version.string), 
[17:00:29.964]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:29.964]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:29.964]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:29.964]                               "release", "version")], collapse = " "), 
[17:00:29.964]                             hostname = base::Sys.info()[["nodename"]])
[17:00:29.964]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:29.964]                             info)
[17:00:29.964]                           info <- base::paste(info, collapse = "; ")
[17:00:29.964]                           if (!has_future) {
[17:00:29.964]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:29.964]                               info)
[17:00:29.964]                           }
[17:00:29.964]                           else {
[17:00:29.964]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:29.964]                               info, version)
[17:00:29.964]                           }
[17:00:29.964]                           base::stop(msg)
[17:00:29.964]                         }
[17:00:29.964]                       })
[17:00:29.964]                     }
[17:00:29.964]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:29.964]                     base::options(mc.cores = 1L)
[17:00:29.964]                   }
[17:00:29.964]                   ...future.strategy.old <- future::plan("list")
[17:00:29.964]                   options(future.plan = NULL)
[17:00:29.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:29.964]                 }
[17:00:29.964]                 ...future.workdir <- getwd()
[17:00:29.964]             }
[17:00:29.964]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:29.964]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:29.964]         }
[17:00:29.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:29.964]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:29.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:29.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:29.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:29.964]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:29.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:29.964]             base::names(...future.oldOptions))
[17:00:29.964]     }
[17:00:29.964]     if (FALSE) {
[17:00:29.964]     }
[17:00:29.964]     else {
[17:00:29.964]         if (TRUE) {
[17:00:29.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:29.964]                 open = "w")
[17:00:29.964]         }
[17:00:29.964]         else {
[17:00:29.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:29.964]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:29.964]         }
[17:00:29.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:29.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:29.964]             base::sink(type = "output", split = FALSE)
[17:00:29.964]             base::close(...future.stdout)
[17:00:29.964]         }, add = TRUE)
[17:00:29.964]     }
[17:00:29.964]     ...future.frame <- base::sys.nframe()
[17:00:29.964]     ...future.conditions <- base::list()
[17:00:29.964]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:29.964]     if (FALSE) {
[17:00:29.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:29.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:29.964]     }
[17:00:29.964]     ...future.result <- base::tryCatch({
[17:00:29.964]         base::withCallingHandlers({
[17:00:29.964]             ...future.value <- base::withVisible(base::local({
[17:00:29.964]                 withCallingHandlers({
[17:00:29.964]                   {
[17:00:29.964]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.964]                     if (!identical(...future.globals.maxSize.org, 
[17:00:29.964]                       ...future.globals.maxSize)) {
[17:00:29.964]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.964]                       on.exit(options(oopts), add = TRUE)
[17:00:29.964]                     }
[17:00:29.964]                     {
[17:00:29.964]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.964]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:29.964]                         USE.NAMES = FALSE)
[17:00:29.964]                       do.call(mapply, args = args)
[17:00:29.964]                     }
[17:00:29.964]                   }
[17:00:29.964]                 }, immediateCondition = function(cond) {
[17:00:29.964]                   save_rds <- function (object, pathname, ...) 
[17:00:29.964]                   {
[17:00:29.964]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:29.964]                     if (file_test("-f", pathname_tmp)) {
[17:00:29.964]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.964]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:29.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.964]                         fi_tmp[["mtime"]])
[17:00:29.964]                     }
[17:00:29.964]                     tryCatch({
[17:00:29.964]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:29.964]                     }, error = function(ex) {
[17:00:29.964]                       msg <- conditionMessage(ex)
[17:00:29.964]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.964]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:29.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.964]                         fi_tmp[["mtime"]], msg)
[17:00:29.964]                       ex$message <- msg
[17:00:29.964]                       stop(ex)
[17:00:29.964]                     })
[17:00:29.964]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:29.964]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:29.964]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:29.964]                       fi_tmp <- file.info(pathname_tmp)
[17:00:29.964]                       fi <- file.info(pathname)
[17:00:29.964]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:29.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:29.964]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:29.964]                         fi[["size"]], fi[["mtime"]])
[17:00:29.964]                       stop(msg)
[17:00:29.964]                     }
[17:00:29.964]                     invisible(pathname)
[17:00:29.964]                   }
[17:00:29.964]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:29.964]                     rootPath = tempdir()) 
[17:00:29.964]                   {
[17:00:29.964]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:29.964]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:29.964]                       tmpdir = path, fileext = ".rds")
[17:00:29.964]                     save_rds(obj, file)
[17:00:29.964]                   }
[17:00:29.964]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:29.964]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.964]                   {
[17:00:29.964]                     inherits <- base::inherits
[17:00:29.964]                     invokeRestart <- base::invokeRestart
[17:00:29.964]                     is.null <- base::is.null
[17:00:29.964]                     muffled <- FALSE
[17:00:29.964]                     if (inherits(cond, "message")) {
[17:00:29.964]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:29.964]                       if (muffled) 
[17:00:29.964]                         invokeRestart("muffleMessage")
[17:00:29.964]                     }
[17:00:29.964]                     else if (inherits(cond, "warning")) {
[17:00:29.964]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:29.964]                       if (muffled) 
[17:00:29.964]                         invokeRestart("muffleWarning")
[17:00:29.964]                     }
[17:00:29.964]                     else if (inherits(cond, "condition")) {
[17:00:29.964]                       if (!is.null(pattern)) {
[17:00:29.964]                         computeRestarts <- base::computeRestarts
[17:00:29.964]                         grepl <- base::grepl
[17:00:29.964]                         restarts <- computeRestarts(cond)
[17:00:29.964]                         for (restart in restarts) {
[17:00:29.964]                           name <- restart$name
[17:00:29.964]                           if (is.null(name)) 
[17:00:29.964]                             next
[17:00:29.964]                           if (!grepl(pattern, name)) 
[17:00:29.964]                             next
[17:00:29.964]                           invokeRestart(restart)
[17:00:29.964]                           muffled <- TRUE
[17:00:29.964]                           break
[17:00:29.964]                         }
[17:00:29.964]                       }
[17:00:29.964]                     }
[17:00:29.964]                     invisible(muffled)
[17:00:29.964]                   }
[17:00:29.964]                   muffleCondition(cond)
[17:00:29.964]                 })
[17:00:29.964]             }))
[17:00:29.964]             future::FutureResult(value = ...future.value$value, 
[17:00:29.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.964]                   ...future.rng), globalenv = if (FALSE) 
[17:00:29.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:29.964]                     ...future.globalenv.names))
[17:00:29.964]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:29.964]         }, condition = base::local({
[17:00:29.964]             c <- base::c
[17:00:29.964]             inherits <- base::inherits
[17:00:29.964]             invokeRestart <- base::invokeRestart
[17:00:29.964]             length <- base::length
[17:00:29.964]             list <- base::list
[17:00:29.964]             seq.int <- base::seq.int
[17:00:29.964]             signalCondition <- base::signalCondition
[17:00:29.964]             sys.calls <- base::sys.calls
[17:00:29.964]             `[[` <- base::`[[`
[17:00:29.964]             `+` <- base::`+`
[17:00:29.964]             `<<-` <- base::`<<-`
[17:00:29.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:29.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:29.964]                   3L)]
[17:00:29.964]             }
[17:00:29.964]             function(cond) {
[17:00:29.964]                 is_error <- inherits(cond, "error")
[17:00:29.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:29.964]                   NULL)
[17:00:29.964]                 if (is_error) {
[17:00:29.964]                   sessionInformation <- function() {
[17:00:29.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:29.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:29.964]                       search = base::search(), system = base::Sys.info())
[17:00:29.964]                   }
[17:00:29.964]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:29.964]                     cond$call), session = sessionInformation(), 
[17:00:29.964]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:29.964]                   signalCondition(cond)
[17:00:29.964]                 }
[17:00:29.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:29.964]                 "immediateCondition"))) {
[17:00:29.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:29.964]                   ...future.conditions[[length(...future.conditions) + 
[17:00:29.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:29.964]                   if (TRUE && !signal) {
[17:00:29.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.964]                     {
[17:00:29.964]                       inherits <- base::inherits
[17:00:29.964]                       invokeRestart <- base::invokeRestart
[17:00:29.964]                       is.null <- base::is.null
[17:00:29.964]                       muffled <- FALSE
[17:00:29.964]                       if (inherits(cond, "message")) {
[17:00:29.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.964]                         if (muffled) 
[17:00:29.964]                           invokeRestart("muffleMessage")
[17:00:29.964]                       }
[17:00:29.964]                       else if (inherits(cond, "warning")) {
[17:00:29.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.964]                         if (muffled) 
[17:00:29.964]                           invokeRestart("muffleWarning")
[17:00:29.964]                       }
[17:00:29.964]                       else if (inherits(cond, "condition")) {
[17:00:29.964]                         if (!is.null(pattern)) {
[17:00:29.964]                           computeRestarts <- base::computeRestarts
[17:00:29.964]                           grepl <- base::grepl
[17:00:29.964]                           restarts <- computeRestarts(cond)
[17:00:29.964]                           for (restart in restarts) {
[17:00:29.964]                             name <- restart$name
[17:00:29.964]                             if (is.null(name)) 
[17:00:29.964]                               next
[17:00:29.964]                             if (!grepl(pattern, name)) 
[17:00:29.964]                               next
[17:00:29.964]                             invokeRestart(restart)
[17:00:29.964]                             muffled <- TRUE
[17:00:29.964]                             break
[17:00:29.964]                           }
[17:00:29.964]                         }
[17:00:29.964]                       }
[17:00:29.964]                       invisible(muffled)
[17:00:29.964]                     }
[17:00:29.964]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.964]                   }
[17:00:29.964]                 }
[17:00:29.964]                 else {
[17:00:29.964]                   if (TRUE) {
[17:00:29.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:29.964]                     {
[17:00:29.964]                       inherits <- base::inherits
[17:00:29.964]                       invokeRestart <- base::invokeRestart
[17:00:29.964]                       is.null <- base::is.null
[17:00:29.964]                       muffled <- FALSE
[17:00:29.964]                       if (inherits(cond, "message")) {
[17:00:29.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:29.964]                         if (muffled) 
[17:00:29.964]                           invokeRestart("muffleMessage")
[17:00:29.964]                       }
[17:00:29.964]                       else if (inherits(cond, "warning")) {
[17:00:29.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:29.964]                         if (muffled) 
[17:00:29.964]                           invokeRestart("muffleWarning")
[17:00:29.964]                       }
[17:00:29.964]                       else if (inherits(cond, "condition")) {
[17:00:29.964]                         if (!is.null(pattern)) {
[17:00:29.964]                           computeRestarts <- base::computeRestarts
[17:00:29.964]                           grepl <- base::grepl
[17:00:29.964]                           restarts <- computeRestarts(cond)
[17:00:29.964]                           for (restart in restarts) {
[17:00:29.964]                             name <- restart$name
[17:00:29.964]                             if (is.null(name)) 
[17:00:29.964]                               next
[17:00:29.964]                             if (!grepl(pattern, name)) 
[17:00:29.964]                               next
[17:00:29.964]                             invokeRestart(restart)
[17:00:29.964]                             muffled <- TRUE
[17:00:29.964]                             break
[17:00:29.964]                           }
[17:00:29.964]                         }
[17:00:29.964]                       }
[17:00:29.964]                       invisible(muffled)
[17:00:29.964]                     }
[17:00:29.964]                     muffleCondition(cond, pattern = "^muffle")
[17:00:29.964]                   }
[17:00:29.964]                 }
[17:00:29.964]             }
[17:00:29.964]         }))
[17:00:29.964]     }, error = function(ex) {
[17:00:29.964]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:29.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:29.964]                 ...future.rng), started = ...future.startTime, 
[17:00:29.964]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:29.964]             version = "1.8"), class = "FutureResult")
[17:00:29.964]     }, finally = {
[17:00:29.964]         if (!identical(...future.workdir, getwd())) 
[17:00:29.964]             setwd(...future.workdir)
[17:00:29.964]         {
[17:00:29.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:29.964]                 ...future.oldOptions$nwarnings <- NULL
[17:00:29.964]             }
[17:00:29.964]             base::options(...future.oldOptions)
[17:00:29.964]             if (.Platform$OS.type == "windows") {
[17:00:29.964]                 old_names <- names(...future.oldEnvVars)
[17:00:29.964]                 envs <- base::Sys.getenv()
[17:00:29.964]                 names <- names(envs)
[17:00:29.964]                 common <- intersect(names, old_names)
[17:00:29.964]                 added <- setdiff(names, old_names)
[17:00:29.964]                 removed <- setdiff(old_names, names)
[17:00:29.964]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:29.964]                   envs[common]]
[17:00:29.964]                 NAMES <- toupper(changed)
[17:00:29.964]                 args <- list()
[17:00:29.964]                 for (kk in seq_along(NAMES)) {
[17:00:29.964]                   name <- changed[[kk]]
[17:00:29.964]                   NAME <- NAMES[[kk]]
[17:00:29.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.964]                     next
[17:00:29.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.964]                 }
[17:00:29.964]                 NAMES <- toupper(added)
[17:00:29.964]                 for (kk in seq_along(NAMES)) {
[17:00:29.964]                   name <- added[[kk]]
[17:00:29.964]                   NAME <- NAMES[[kk]]
[17:00:29.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.964]                     next
[17:00:29.964]                   args[[name]] <- ""
[17:00:29.964]                 }
[17:00:29.964]                 NAMES <- toupper(removed)
[17:00:29.964]                 for (kk in seq_along(NAMES)) {
[17:00:29.964]                   name <- removed[[kk]]
[17:00:29.964]                   NAME <- NAMES[[kk]]
[17:00:29.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:29.964]                     next
[17:00:29.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:29.964]                 }
[17:00:29.964]                 if (length(args) > 0) 
[17:00:29.964]                   base::do.call(base::Sys.setenv, args = args)
[17:00:29.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:29.964]             }
[17:00:29.964]             else {
[17:00:29.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:29.964]             }
[17:00:29.964]             {
[17:00:29.964]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:29.964]                   0L) {
[17:00:29.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:29.964]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:29.964]                   base::options(opts)
[17:00:29.964]                 }
[17:00:29.964]                 {
[17:00:29.964]                   {
[17:00:29.964]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:29.964]                     NULL
[17:00:29.964]                   }
[17:00:29.964]                   options(future.plan = NULL)
[17:00:29.964]                   if (is.na(NA_character_)) 
[17:00:29.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:29.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:29.964]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:29.964]                     .init = FALSE)
[17:00:29.964]                 }
[17:00:29.964]             }
[17:00:29.964]         }
[17:00:29.964]     })
[17:00:29.964]     if (TRUE) {
[17:00:29.964]         base::sink(type = "output", split = FALSE)
[17:00:29.964]         if (TRUE) {
[17:00:29.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:29.964]         }
[17:00:29.964]         else {
[17:00:29.964]             ...future.result["stdout"] <- base::list(NULL)
[17:00:29.964]         }
[17:00:29.964]         base::close(...future.stdout)
[17:00:29.964]         ...future.stdout <- NULL
[17:00:29.964]     }
[17:00:29.964]     ...future.result$conditions <- ...future.conditions
[17:00:29.964]     ...future.result$finished <- base::Sys.time()
[17:00:29.964]     ...future.result
[17:00:29.964] }
[17:00:29.967] assign_globals() ...
[17:00:29.967] List of 5
[17:00:29.967]  $ ...future.FUN            :function (C, k)  
[17:00:29.967]  $ MoreArgs                 : list()
[17:00:29.967]  $ ...future.elements_ii    :List of 2
[17:00:29.967]   ..$ :List of 2
[17:00:29.967]   .. ..$ : chr "A"
[17:00:29.967]   .. ..$ : chr "B"
[17:00:29.967]   ..$ :List of 2
[17:00:29.967]   .. ..$ : int 5
[17:00:29.967]   .. ..$ : int 4
[17:00:29.967]  $ ...future.seeds_ii       : NULL
[17:00:29.967]  $ ...future.globals.maxSize: NULL
[17:00:29.967]  - attr(*, "where")=List of 5
[17:00:29.967]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:29.967]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:29.967]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:29.967]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:29.967]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:29.967]  - attr(*, "resolved")= logi FALSE
[17:00:29.967]  - attr(*, "total_size")= num 3656
[17:00:29.967]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:29.967]  - attr(*, "already-done")= logi TRUE
[17:00:29.972] - reassign environment for ‘...future.FUN’
[17:00:29.972] - copied ‘...future.FUN’ to environment
[17:00:29.973] - copied ‘MoreArgs’ to environment
[17:00:29.973] - copied ‘...future.elements_ii’ to environment
[17:00:29.973] - copied ‘...future.seeds_ii’ to environment
[17:00:29.973] - copied ‘...future.globals.maxSize’ to environment
[17:00:29.973] assign_globals() ... done
[17:00:29.973] requestCore(): workers = 2
[17:00:29.975] MulticoreFuture started
[17:00:29.976] - Launch lazy future ... done
[17:00:29.976] run() for ‘MulticoreFuture’ ... done
[17:00:29.976] Created future:
[17:00:29.977] plan(): Setting new future strategy stack:
[17:00:29.977] List of future strategies:
[17:00:29.977] 1. sequential:
[17:00:29.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:29.977]    - tweaked: FALSE
[17:00:29.977]    - call: NULL
[17:00:29.978] plan(): nbrOfWorkers() = 1
[17:00:29.980] plan(): Setting new future strategy stack:
[17:00:29.980] List of future strategies:
[17:00:29.980] 1. multicore:
[17:00:29.980]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:29.980]    - tweaked: FALSE
[17:00:29.980]    - call: plan(strategy)
[17:00:29.986] plan(): nbrOfWorkers() = 2
[17:00:29.977] MulticoreFuture:
[17:00:29.977] Label: ‘future_.mapply-1’
[17:00:29.977] Expression:
[17:00:29.977] {
[17:00:29.977]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:29.977]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:29.977]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:29.977]         on.exit(options(oopts), add = TRUE)
[17:00:29.977]     }
[17:00:29.977]     {
[17:00:29.977]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:29.977]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:29.977]         do.call(mapply, args = args)
[17:00:29.977]     }
[17:00:29.977] }
[17:00:29.977] Lazy evaluation: FALSE
[17:00:29.977] Asynchronous evaluation: TRUE
[17:00:29.977] Local evaluation: TRUE
[17:00:29.977] Environment: R_GlobalEnv
[17:00:29.977] Capture standard output: TRUE
[17:00:29.977] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:29.977] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:29.977] Packages: <none>
[17:00:29.977] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:29.977] Resolved: TRUE
[17:00:29.977] Value: <not collected>
[17:00:29.977] Conditions captured: <none>
[17:00:29.977] Early signaling: FALSE
[17:00:29.977] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:29.977] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:29.987] Chunk #1 of 2 ... DONE
[17:00:29.987] Chunk #2 of 2 ...
[17:00:29.987]  - Finding globals in '...' for chunk #2 ...
[17:00:29.988] getGlobalsAndPackages() ...
[17:00:29.988] Searching for globals...
[17:00:29.988] 
[17:00:29.988] Searching for globals ... DONE
[17:00:29.989] - globals: [0] <none>
[17:00:29.989] getGlobalsAndPackages() ... DONE
[17:00:29.989]    + additional globals found: [n=0] 
[17:00:29.989]    + additional namespaces needed: [n=0] 
[17:00:29.989]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:29.989]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:29.989]  - seeds: <none>
[17:00:29.990]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.990] getGlobalsAndPackages() ...
[17:00:29.990] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.990] Resolving globals: FALSE
[17:00:29.991] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:00:29.992] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:29.992] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:29.992] 
[17:00:29.992] getGlobalsAndPackages() ... DONE
[17:00:29.993] run() for ‘Future’ ...
[17:00:29.993] - state: ‘created’
[17:00:29.993] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.004]   - Field: ‘label’
[17:00:30.004]   - Field: ‘local’
[17:00:30.004]   - Field: ‘owner’
[17:00:30.005]   - Field: ‘envir’
[17:00:30.005]   - Field: ‘workers’
[17:00:30.005]   - Field: ‘packages’
[17:00:30.005]   - Field: ‘gc’
[17:00:30.006]   - Field: ‘job’
[17:00:30.006]   - Field: ‘conditions’
[17:00:30.006]   - Field: ‘expr’
[17:00:30.006]   - Field: ‘uuid’
[17:00:30.007]   - Field: ‘seed’
[17:00:30.007]   - Field: ‘version’
[17:00:30.007]   - Field: ‘result’
[17:00:30.007]   - Field: ‘asynchronous’
[17:00:30.007]   - Field: ‘calls’
[17:00:30.008]   - Field: ‘globals’
[17:00:30.008]   - Field: ‘stdout’
[17:00:30.008]   - Field: ‘earlySignal’
[17:00:30.009]   - Field: ‘lazy’
[17:00:30.009]   - Field: ‘state’
[17:00:30.009] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.009] - Launch lazy future ...
[17:00:30.010] Packages needed by the future expression (n = 0): <none>
[17:00:30.010] Packages needed by future strategies (n = 0): <none>
[17:00:30.011] {
[17:00:30.011]     {
[17:00:30.011]         {
[17:00:30.011]             ...future.startTime <- base::Sys.time()
[17:00:30.011]             {
[17:00:30.011]                 {
[17:00:30.011]                   {
[17:00:30.011]                     {
[17:00:30.011]                       base::local({
[17:00:30.011]                         has_future <- base::requireNamespace("future", 
[17:00:30.011]                           quietly = TRUE)
[17:00:30.011]                         if (has_future) {
[17:00:30.011]                           ns <- base::getNamespace("future")
[17:00:30.011]                           version <- ns[[".package"]][["version"]]
[17:00:30.011]                           if (is.null(version)) 
[17:00:30.011]                             version <- utils::packageVersion("future")
[17:00:30.011]                         }
[17:00:30.011]                         else {
[17:00:30.011]                           version <- NULL
[17:00:30.011]                         }
[17:00:30.011]                         if (!has_future || version < "1.8.0") {
[17:00:30.011]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.011]                             "", base::R.version$version.string), 
[17:00:30.011]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.011]                               "release", "version")], collapse = " "), 
[17:00:30.011]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.011]                             info)
[17:00:30.011]                           info <- base::paste(info, collapse = "; ")
[17:00:30.011]                           if (!has_future) {
[17:00:30.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.011]                               info)
[17:00:30.011]                           }
[17:00:30.011]                           else {
[17:00:30.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.011]                               info, version)
[17:00:30.011]                           }
[17:00:30.011]                           base::stop(msg)
[17:00:30.011]                         }
[17:00:30.011]                       })
[17:00:30.011]                     }
[17:00:30.011]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.011]                     base::options(mc.cores = 1L)
[17:00:30.011]                   }
[17:00:30.011]                   ...future.strategy.old <- future::plan("list")
[17:00:30.011]                   options(future.plan = NULL)
[17:00:30.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.011]                 }
[17:00:30.011]                 ...future.workdir <- getwd()
[17:00:30.011]             }
[17:00:30.011]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.011]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.011]         }
[17:00:30.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.011]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.011]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.011]             base::names(...future.oldOptions))
[17:00:30.011]     }
[17:00:30.011]     if (FALSE) {
[17:00:30.011]     }
[17:00:30.011]     else {
[17:00:30.011]         if (TRUE) {
[17:00:30.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.011]                 open = "w")
[17:00:30.011]         }
[17:00:30.011]         else {
[17:00:30.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.011]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.011]         }
[17:00:30.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.011]             base::sink(type = "output", split = FALSE)
[17:00:30.011]             base::close(...future.stdout)
[17:00:30.011]         }, add = TRUE)
[17:00:30.011]     }
[17:00:30.011]     ...future.frame <- base::sys.nframe()
[17:00:30.011]     ...future.conditions <- base::list()
[17:00:30.011]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.011]     if (FALSE) {
[17:00:30.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.011]     }
[17:00:30.011]     ...future.result <- base::tryCatch({
[17:00:30.011]         base::withCallingHandlers({
[17:00:30.011]             ...future.value <- base::withVisible(base::local({
[17:00:30.011]                 withCallingHandlers({
[17:00:30.011]                   {
[17:00:30.011]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.011]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.011]                       ...future.globals.maxSize)) {
[17:00:30.011]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.011]                       on.exit(options(oopts), add = TRUE)
[17:00:30.011]                     }
[17:00:30.011]                     {
[17:00:30.011]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.011]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.011]                         USE.NAMES = FALSE)
[17:00:30.011]                       do.call(mapply, args = args)
[17:00:30.011]                     }
[17:00:30.011]                   }
[17:00:30.011]                 }, immediateCondition = function(cond) {
[17:00:30.011]                   save_rds <- function (object, pathname, ...) 
[17:00:30.011]                   {
[17:00:30.011]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.011]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.011]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.011]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.011]                         fi_tmp[["mtime"]])
[17:00:30.011]                     }
[17:00:30.011]                     tryCatch({
[17:00:30.011]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.011]                     }, error = function(ex) {
[17:00:30.011]                       msg <- conditionMessage(ex)
[17:00:30.011]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.011]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.011]                         fi_tmp[["mtime"]], msg)
[17:00:30.011]                       ex$message <- msg
[17:00:30.011]                       stop(ex)
[17:00:30.011]                     })
[17:00:30.011]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.011]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.011]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.011]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.011]                       fi <- file.info(pathname)
[17:00:30.011]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.011]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.011]                         fi[["size"]], fi[["mtime"]])
[17:00:30.011]                       stop(msg)
[17:00:30.011]                     }
[17:00:30.011]                     invisible(pathname)
[17:00:30.011]                   }
[17:00:30.011]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.011]                     rootPath = tempdir()) 
[17:00:30.011]                   {
[17:00:30.011]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.011]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.011]                       tmpdir = path, fileext = ".rds")
[17:00:30.011]                     save_rds(obj, file)
[17:00:30.011]                   }
[17:00:30.011]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.011]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.011]                   {
[17:00:30.011]                     inherits <- base::inherits
[17:00:30.011]                     invokeRestart <- base::invokeRestart
[17:00:30.011]                     is.null <- base::is.null
[17:00:30.011]                     muffled <- FALSE
[17:00:30.011]                     if (inherits(cond, "message")) {
[17:00:30.011]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.011]                       if (muffled) 
[17:00:30.011]                         invokeRestart("muffleMessage")
[17:00:30.011]                     }
[17:00:30.011]                     else if (inherits(cond, "warning")) {
[17:00:30.011]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.011]                       if (muffled) 
[17:00:30.011]                         invokeRestart("muffleWarning")
[17:00:30.011]                     }
[17:00:30.011]                     else if (inherits(cond, "condition")) {
[17:00:30.011]                       if (!is.null(pattern)) {
[17:00:30.011]                         computeRestarts <- base::computeRestarts
[17:00:30.011]                         grepl <- base::grepl
[17:00:30.011]                         restarts <- computeRestarts(cond)
[17:00:30.011]                         for (restart in restarts) {
[17:00:30.011]                           name <- restart$name
[17:00:30.011]                           if (is.null(name)) 
[17:00:30.011]                             next
[17:00:30.011]                           if (!grepl(pattern, name)) 
[17:00:30.011]                             next
[17:00:30.011]                           invokeRestart(restart)
[17:00:30.011]                           muffled <- TRUE
[17:00:30.011]                           break
[17:00:30.011]                         }
[17:00:30.011]                       }
[17:00:30.011]                     }
[17:00:30.011]                     invisible(muffled)
[17:00:30.011]                   }
[17:00:30.011]                   muffleCondition(cond)
[17:00:30.011]                 })
[17:00:30.011]             }))
[17:00:30.011]             future::FutureResult(value = ...future.value$value, 
[17:00:30.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.011]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.011]                     ...future.globalenv.names))
[17:00:30.011]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.011]         }, condition = base::local({
[17:00:30.011]             c <- base::c
[17:00:30.011]             inherits <- base::inherits
[17:00:30.011]             invokeRestart <- base::invokeRestart
[17:00:30.011]             length <- base::length
[17:00:30.011]             list <- base::list
[17:00:30.011]             seq.int <- base::seq.int
[17:00:30.011]             signalCondition <- base::signalCondition
[17:00:30.011]             sys.calls <- base::sys.calls
[17:00:30.011]             `[[` <- base::`[[`
[17:00:30.011]             `+` <- base::`+`
[17:00:30.011]             `<<-` <- base::`<<-`
[17:00:30.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.011]                   3L)]
[17:00:30.011]             }
[17:00:30.011]             function(cond) {
[17:00:30.011]                 is_error <- inherits(cond, "error")
[17:00:30.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.011]                   NULL)
[17:00:30.011]                 if (is_error) {
[17:00:30.011]                   sessionInformation <- function() {
[17:00:30.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.011]                       search = base::search(), system = base::Sys.info())
[17:00:30.011]                   }
[17:00:30.011]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.011]                     cond$call), session = sessionInformation(), 
[17:00:30.011]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.011]                   signalCondition(cond)
[17:00:30.011]                 }
[17:00:30.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.011]                 "immediateCondition"))) {
[17:00:30.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.011]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.011]                   if (TRUE && !signal) {
[17:00:30.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.011]                     {
[17:00:30.011]                       inherits <- base::inherits
[17:00:30.011]                       invokeRestart <- base::invokeRestart
[17:00:30.011]                       is.null <- base::is.null
[17:00:30.011]                       muffled <- FALSE
[17:00:30.011]                       if (inherits(cond, "message")) {
[17:00:30.011]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.011]                         if (muffled) 
[17:00:30.011]                           invokeRestart("muffleMessage")
[17:00:30.011]                       }
[17:00:30.011]                       else if (inherits(cond, "warning")) {
[17:00:30.011]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.011]                         if (muffled) 
[17:00:30.011]                           invokeRestart("muffleWarning")
[17:00:30.011]                       }
[17:00:30.011]                       else if (inherits(cond, "condition")) {
[17:00:30.011]                         if (!is.null(pattern)) {
[17:00:30.011]                           computeRestarts <- base::computeRestarts
[17:00:30.011]                           grepl <- base::grepl
[17:00:30.011]                           restarts <- computeRestarts(cond)
[17:00:30.011]                           for (restart in restarts) {
[17:00:30.011]                             name <- restart$name
[17:00:30.011]                             if (is.null(name)) 
[17:00:30.011]                               next
[17:00:30.011]                             if (!grepl(pattern, name)) 
[17:00:30.011]                               next
[17:00:30.011]                             invokeRestart(restart)
[17:00:30.011]                             muffled <- TRUE
[17:00:30.011]                             break
[17:00:30.011]                           }
[17:00:30.011]                         }
[17:00:30.011]                       }
[17:00:30.011]                       invisible(muffled)
[17:00:30.011]                     }
[17:00:30.011]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.011]                   }
[17:00:30.011]                 }
[17:00:30.011]                 else {
[17:00:30.011]                   if (TRUE) {
[17:00:30.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.011]                     {
[17:00:30.011]                       inherits <- base::inherits
[17:00:30.011]                       invokeRestart <- base::invokeRestart
[17:00:30.011]                       is.null <- base::is.null
[17:00:30.011]                       muffled <- FALSE
[17:00:30.011]                       if (inherits(cond, "message")) {
[17:00:30.011]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.011]                         if (muffled) 
[17:00:30.011]                           invokeRestart("muffleMessage")
[17:00:30.011]                       }
[17:00:30.011]                       else if (inherits(cond, "warning")) {
[17:00:30.011]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.011]                         if (muffled) 
[17:00:30.011]                           invokeRestart("muffleWarning")
[17:00:30.011]                       }
[17:00:30.011]                       else if (inherits(cond, "condition")) {
[17:00:30.011]                         if (!is.null(pattern)) {
[17:00:30.011]                           computeRestarts <- base::computeRestarts
[17:00:30.011]                           grepl <- base::grepl
[17:00:30.011]                           restarts <- computeRestarts(cond)
[17:00:30.011]                           for (restart in restarts) {
[17:00:30.011]                             name <- restart$name
[17:00:30.011]                             if (is.null(name)) 
[17:00:30.011]                               next
[17:00:30.011]                             if (!grepl(pattern, name)) 
[17:00:30.011]                               next
[17:00:30.011]                             invokeRestart(restart)
[17:00:30.011]                             muffled <- TRUE
[17:00:30.011]                             break
[17:00:30.011]                           }
[17:00:30.011]                         }
[17:00:30.011]                       }
[17:00:30.011]                       invisible(muffled)
[17:00:30.011]                     }
[17:00:30.011]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.011]                   }
[17:00:30.011]                 }
[17:00:30.011]             }
[17:00:30.011]         }))
[17:00:30.011]     }, error = function(ex) {
[17:00:30.011]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.011]                 ...future.rng), started = ...future.startTime, 
[17:00:30.011]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.011]             version = "1.8"), class = "FutureResult")
[17:00:30.011]     }, finally = {
[17:00:30.011]         if (!identical(...future.workdir, getwd())) 
[17:00:30.011]             setwd(...future.workdir)
[17:00:30.011]         {
[17:00:30.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.011]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.011]             }
[17:00:30.011]             base::options(...future.oldOptions)
[17:00:30.011]             if (.Platform$OS.type == "windows") {
[17:00:30.011]                 old_names <- names(...future.oldEnvVars)
[17:00:30.011]                 envs <- base::Sys.getenv()
[17:00:30.011]                 names <- names(envs)
[17:00:30.011]                 common <- intersect(names, old_names)
[17:00:30.011]                 added <- setdiff(names, old_names)
[17:00:30.011]                 removed <- setdiff(old_names, names)
[17:00:30.011]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.011]                   envs[common]]
[17:00:30.011]                 NAMES <- toupper(changed)
[17:00:30.011]                 args <- list()
[17:00:30.011]                 for (kk in seq_along(NAMES)) {
[17:00:30.011]                   name <- changed[[kk]]
[17:00:30.011]                   NAME <- NAMES[[kk]]
[17:00:30.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.011]                     next
[17:00:30.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.011]                 }
[17:00:30.011]                 NAMES <- toupper(added)
[17:00:30.011]                 for (kk in seq_along(NAMES)) {
[17:00:30.011]                   name <- added[[kk]]
[17:00:30.011]                   NAME <- NAMES[[kk]]
[17:00:30.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.011]                     next
[17:00:30.011]                   args[[name]] <- ""
[17:00:30.011]                 }
[17:00:30.011]                 NAMES <- toupper(removed)
[17:00:30.011]                 for (kk in seq_along(NAMES)) {
[17:00:30.011]                   name <- removed[[kk]]
[17:00:30.011]                   NAME <- NAMES[[kk]]
[17:00:30.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.011]                     next
[17:00:30.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.011]                 }
[17:00:30.011]                 if (length(args) > 0) 
[17:00:30.011]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.011]             }
[17:00:30.011]             else {
[17:00:30.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.011]             }
[17:00:30.011]             {
[17:00:30.011]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.011]                   0L) {
[17:00:30.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.011]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.011]                   base::options(opts)
[17:00:30.011]                 }
[17:00:30.011]                 {
[17:00:30.011]                   {
[17:00:30.011]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.011]                     NULL
[17:00:30.011]                   }
[17:00:30.011]                   options(future.plan = NULL)
[17:00:30.011]                   if (is.na(NA_character_)) 
[17:00:30.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.011]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.011]                     .init = FALSE)
[17:00:30.011]                 }
[17:00:30.011]             }
[17:00:30.011]         }
[17:00:30.011]     })
[17:00:30.011]     if (TRUE) {
[17:00:30.011]         base::sink(type = "output", split = FALSE)
[17:00:30.011]         if (TRUE) {
[17:00:30.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.011]         }
[17:00:30.011]         else {
[17:00:30.011]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.011]         }
[17:00:30.011]         base::close(...future.stdout)
[17:00:30.011]         ...future.stdout <- NULL
[17:00:30.011]     }
[17:00:30.011]     ...future.result$conditions <- ...future.conditions
[17:00:30.011]     ...future.result$finished <- base::Sys.time()
[17:00:30.011]     ...future.result
[17:00:30.011] }
[17:00:30.014] assign_globals() ...
[17:00:30.014] List of 5
[17:00:30.014]  $ ...future.FUN            :function (C, k)  
[17:00:30.014]  $ MoreArgs                 : list()
[17:00:30.014]  $ ...future.elements_ii    :List of 2
[17:00:30.014]   ..$ :List of 3
[17:00:30.014]   .. ..$ : chr "C"
[17:00:30.014]   .. ..$ : chr "D"
[17:00:30.014]   .. ..$ : chr "E"
[17:00:30.014]   ..$ :List of 3
[17:00:30.014]   .. ..$ : int 3
[17:00:30.014]   .. ..$ : int 2
[17:00:30.014]   .. ..$ : int 1
[17:00:30.014]  $ ...future.seeds_ii       : NULL
[17:00:30.014]  $ ...future.globals.maxSize: NULL
[17:00:30.014]  - attr(*, "where")=List of 5
[17:00:30.014]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.014]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.014]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.014]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.014]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.014]  - attr(*, "resolved")= logi FALSE
[17:00:30.014]  - attr(*, "total_size")= num 3824
[17:00:30.014]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.014]  - attr(*, "already-done")= logi TRUE
[17:00:30.023] - reassign environment for ‘...future.FUN’
[17:00:30.023] - copied ‘...future.FUN’ to environment
[17:00:30.024] - copied ‘MoreArgs’ to environment
[17:00:30.024] - copied ‘...future.elements_ii’ to environment
[17:00:30.024] - copied ‘...future.seeds_ii’ to environment
[17:00:30.024] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.024] assign_globals() ... done
[17:00:30.024] requestCore(): workers = 2
[17:00:30.027] MulticoreFuture started
[17:00:30.027] - Launch lazy future ... done
[17:00:30.027] run() for ‘MulticoreFuture’ ... done
[17:00:30.027] Created future:
[17:00:30.028] plan(): Setting new future strategy stack:
[17:00:30.028] List of future strategies:
[17:00:30.028] 1. sequential:
[17:00:30.028]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.028]    - tweaked: FALSE
[17:00:30.028]    - call: NULL
[17:00:30.029] plan(): nbrOfWorkers() = 1
[17:00:30.031] plan(): Setting new future strategy stack:
[17:00:30.031] List of future strategies:
[17:00:30.031] 1. multicore:
[17:00:30.031]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.031]    - tweaked: FALSE
[17:00:30.031]    - call: plan(strategy)
[17:00:30.037] plan(): nbrOfWorkers() = 2
[17:00:30.028] MulticoreFuture:
[17:00:30.028] Label: ‘future_.mapply-2’
[17:00:30.028] Expression:
[17:00:30.028] {
[17:00:30.028]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.028]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.028]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.028]         on.exit(options(oopts), add = TRUE)
[17:00:30.028]     }
[17:00:30.028]     {
[17:00:30.028]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.028]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.028]         do.call(mapply, args = args)
[17:00:30.028]     }
[17:00:30.028] }
[17:00:30.028] Lazy evaluation: FALSE
[17:00:30.028] Asynchronous evaluation: TRUE
[17:00:30.028] Local evaluation: TRUE
[17:00:30.028] Environment: R_GlobalEnv
[17:00:30.028] Capture standard output: TRUE
[17:00:30.028] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.028] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.028] Packages: <none>
[17:00:30.028] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.028] Resolved: TRUE
[17:00:30.028] Value: <not collected>
[17:00:30.028] Conditions captured: <none>
[17:00:30.028] Early signaling: FALSE
[17:00:30.028] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.028] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.038] Chunk #2 of 2 ... DONE
[17:00:30.038] Launching 2 futures (chunks) ... DONE
[17:00:30.038] Resolving 2 futures (chunks) ...
[17:00:30.038] resolve() on list ...
[17:00:30.039]  recursive: 0
[17:00:30.039]  length: 2
[17:00:30.039] 
[17:00:30.039] Future #1
[17:00:30.040] result() for MulticoreFuture ...
[17:00:30.040] result() for MulticoreFuture ...
[17:00:30.041] result() for MulticoreFuture ... done
[17:00:30.041] result() for MulticoreFuture ... done
[17:00:30.041] result() for MulticoreFuture ...
[17:00:30.041] result() for MulticoreFuture ... done
[17:00:30.041] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:30.041] - nx: 2
[17:00:30.041] - relay: TRUE
[17:00:30.042] - stdout: TRUE
[17:00:30.042] - signal: TRUE
[17:00:30.042] - resignal: FALSE
[17:00:30.042] - force: TRUE
[17:00:30.042] - relayed: [n=2] FALSE, FALSE
[17:00:30.042] - queued futures: [n=2] FALSE, FALSE
[17:00:30.043]  - until=1
[17:00:30.043]  - relaying element #1
[17:00:30.043] result() for MulticoreFuture ...
[17:00:30.043] result() for MulticoreFuture ... done
[17:00:30.043] result() for MulticoreFuture ...
[17:00:30.043] result() for MulticoreFuture ... done
[17:00:30.044] result() for MulticoreFuture ...
[17:00:30.044] result() for MulticoreFuture ... done
[17:00:30.044] result() for MulticoreFuture ...
[17:00:30.044] result() for MulticoreFuture ... done
[17:00:30.044] - relayed: [n=2] TRUE, FALSE
[17:00:30.044] - queued futures: [n=2] TRUE, FALSE
[17:00:30.045] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:30.045]  length: 1 (resolved future 1)
[17:00:30.045] Future #2
[17:00:30.045] result() for MulticoreFuture ...
[17:00:30.046] result() for MulticoreFuture ...
[17:00:30.046] result() for MulticoreFuture ... done
[17:00:30.046] result() for MulticoreFuture ... done
[17:00:30.047] result() for MulticoreFuture ...
[17:00:30.047] result() for MulticoreFuture ... done
[17:00:30.047] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:30.047] - nx: 2
[17:00:30.047] - relay: TRUE
[17:00:30.047] - stdout: TRUE
[17:00:30.048] - signal: TRUE
[17:00:30.048] - resignal: FALSE
[17:00:30.048] - force: TRUE
[17:00:30.048] - relayed: [n=2] TRUE, FALSE
[17:00:30.048] - queued futures: [n=2] TRUE, FALSE
[17:00:30.048]  - until=2
[17:00:30.048]  - relaying element #2
[17:00:30.048] result() for MulticoreFuture ...
[17:00:30.049] result() for MulticoreFuture ... done
[17:00:30.049] result() for MulticoreFuture ...
[17:00:30.049] result() for MulticoreFuture ... done
[17:00:30.049] result() for MulticoreFuture ...
[17:00:30.049] result() for MulticoreFuture ... done
[17:00:30.049] result() for MulticoreFuture ...
[17:00:30.049] result() for MulticoreFuture ... done
[17:00:30.049] - relayed: [n=2] TRUE, TRUE
[17:00:30.050] - queued futures: [n=2] TRUE, TRUE
[17:00:30.050] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:30.050]  length: 0 (resolved future 2)
[17:00:30.050] Relaying remaining futures
[17:00:30.053] signalConditionsASAP(NULL, pos=0) ...
[17:00:30.053] - nx: 2
[17:00:30.053] - relay: TRUE
[17:00:30.053] - stdout: TRUE
[17:00:30.054] - signal: TRUE
[17:00:30.054] - resignal: FALSE
[17:00:30.054] - force: TRUE
[17:00:30.054] - relayed: [n=2] TRUE, TRUE
[17:00:30.054] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:30.055] - relayed: [n=2] TRUE, TRUE
[17:00:30.055] - queued futures: [n=2] TRUE, TRUE
[17:00:30.055] signalConditionsASAP(NULL, pos=0) ... done
[17:00:30.055] resolve() on list ... DONE
[17:00:30.055] result() for MulticoreFuture ...
[17:00:30.055] result() for MulticoreFuture ... done
[17:00:30.056] result() for MulticoreFuture ...
[17:00:30.056] result() for MulticoreFuture ... done
[17:00:30.056] result() for MulticoreFuture ...
[17:00:30.056] result() for MulticoreFuture ... done
[17:00:30.056] result() for MulticoreFuture ...
[17:00:30.056] result() for MulticoreFuture ... done
[17:00:30.057]  - Number of value chunks collected: 2
[17:00:30.057] Resolving 2 futures (chunks) ... DONE
[17:00:30.057] Reducing values from 2 chunks ...
[17:00:30.057]  - Number of values collected after concatenation: 5
[17:00:30.057]  - Number of values expected: 5
[17:00:30.057] Reducing values from 2 chunks ... DONE
[17:00:30.057] future_mapply() ... DONE
[17:00:30.058] future_mapply() ...
[17:00:30.063] Number of chunks: 3
[17:00:30.063] Index remapping (attribute 'ordering'): [n = 5] 1, 2, 5, 4, 3
[17:00:30.064] getGlobalsAndPackagesXApply() ...
[17:00:30.064]  - future.globals: TRUE
[17:00:30.064] getGlobalsAndPackages() ...
[17:00:30.064] Searching for globals...
[17:00:30.066] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:30.066] Searching for globals ... DONE
[17:00:30.066] Resolving globals: FALSE
[17:00:30.066] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:30.067] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:30.067] - globals: [1] ‘FUN’
[17:00:30.067] 
[17:00:30.067] getGlobalsAndPackages() ... DONE
[17:00:30.067]  - globals found/used: [n=1] ‘FUN’
[17:00:30.068]  - needed namespaces: [n=0] 
[17:00:30.068] Finding globals ... DONE
[17:00:30.068] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:30.068] List of 2
[17:00:30.068]  $ ...future.FUN:function (C, k)  
[17:00:30.068]  $ MoreArgs     : NULL
[17:00:30.068]  - attr(*, "where")=List of 2
[17:00:30.068]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:30.068]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:30.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.068]  - attr(*, "resolved")= logi FALSE
[17:00:30.068]  - attr(*, "total_size")= num NA
[17:00:30.071] Packages to be attached in all futures: [n=0] 
[17:00:30.071] getGlobalsAndPackagesXApply() ... DONE
[17:00:30.071] Number of futures (= number of chunks): 3
[17:00:30.072] Launching 3 futures (chunks) ...
[17:00:30.072] Chunk #1 of 3 ...
[17:00:30.072]  - Finding globals in '...' for chunk #1 ...
[17:00:30.072] getGlobalsAndPackages() ...
[17:00:30.072] Searching for globals...
[17:00:30.072] 
[17:00:30.072] Searching for globals ... DONE
[17:00:30.073] - globals: [0] <none>
[17:00:30.073] getGlobalsAndPackages() ... DONE
[17:00:30.073]    + additional globals found: [n=0] 
[17:00:30.073]    + additional namespaces needed: [n=0] 
[17:00:30.073]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:30.073]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:00:30.073]  - seeds: <none>
[17:00:30.073]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.073] getGlobalsAndPackages() ...
[17:00:30.073] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.074] Resolving globals: FALSE
[17:00:30.074] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:30.075] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:30.075] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.075] 
[17:00:30.075] getGlobalsAndPackages() ... DONE
[17:00:30.075] run() for ‘Future’ ...
[17:00:30.075] - state: ‘created’
[17:00:30.075] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.080] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.080]   - Field: ‘label’
[17:00:30.080]   - Field: ‘local’
[17:00:30.080]   - Field: ‘owner’
[17:00:30.080]   - Field: ‘envir’
[17:00:30.080]   - Field: ‘workers’
[17:00:30.081]   - Field: ‘packages’
[17:00:30.081]   - Field: ‘gc’
[17:00:30.081]   - Field: ‘job’
[17:00:30.081]   - Field: ‘conditions’
[17:00:30.081]   - Field: ‘expr’
[17:00:30.081]   - Field: ‘uuid’
[17:00:30.081]   - Field: ‘seed’
[17:00:30.081]   - Field: ‘version’
[17:00:30.081]   - Field: ‘result’
[17:00:30.082]   - Field: ‘asynchronous’
[17:00:30.082]   - Field: ‘calls’
[17:00:30.082]   - Field: ‘globals’
[17:00:30.082]   - Field: ‘stdout’
[17:00:30.082]   - Field: ‘earlySignal’
[17:00:30.082]   - Field: ‘lazy’
[17:00:30.082]   - Field: ‘state’
[17:00:30.082] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.082] - Launch lazy future ...
[17:00:30.083] Packages needed by the future expression (n = 0): <none>
[17:00:30.083] Packages needed by future strategies (n = 0): <none>
[17:00:30.083] {
[17:00:30.083]     {
[17:00:30.083]         {
[17:00:30.083]             ...future.startTime <- base::Sys.time()
[17:00:30.083]             {
[17:00:30.083]                 {
[17:00:30.083]                   {
[17:00:30.083]                     {
[17:00:30.083]                       base::local({
[17:00:30.083]                         has_future <- base::requireNamespace("future", 
[17:00:30.083]                           quietly = TRUE)
[17:00:30.083]                         if (has_future) {
[17:00:30.083]                           ns <- base::getNamespace("future")
[17:00:30.083]                           version <- ns[[".package"]][["version"]]
[17:00:30.083]                           if (is.null(version)) 
[17:00:30.083]                             version <- utils::packageVersion("future")
[17:00:30.083]                         }
[17:00:30.083]                         else {
[17:00:30.083]                           version <- NULL
[17:00:30.083]                         }
[17:00:30.083]                         if (!has_future || version < "1.8.0") {
[17:00:30.083]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.083]                             "", base::R.version$version.string), 
[17:00:30.083]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.083]                               "release", "version")], collapse = " "), 
[17:00:30.083]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.083]                             info)
[17:00:30.083]                           info <- base::paste(info, collapse = "; ")
[17:00:30.083]                           if (!has_future) {
[17:00:30.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.083]                               info)
[17:00:30.083]                           }
[17:00:30.083]                           else {
[17:00:30.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.083]                               info, version)
[17:00:30.083]                           }
[17:00:30.083]                           base::stop(msg)
[17:00:30.083]                         }
[17:00:30.083]                       })
[17:00:30.083]                     }
[17:00:30.083]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.083]                     base::options(mc.cores = 1L)
[17:00:30.083]                   }
[17:00:30.083]                   ...future.strategy.old <- future::plan("list")
[17:00:30.083]                   options(future.plan = NULL)
[17:00:30.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.083]                 }
[17:00:30.083]                 ...future.workdir <- getwd()
[17:00:30.083]             }
[17:00:30.083]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.083]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.083]         }
[17:00:30.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.083]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:00:30.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.083]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.083]             base::names(...future.oldOptions))
[17:00:30.083]     }
[17:00:30.083]     if (FALSE) {
[17:00:30.083]     }
[17:00:30.083]     else {
[17:00:30.083]         if (TRUE) {
[17:00:30.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.083]                 open = "w")
[17:00:30.083]         }
[17:00:30.083]         else {
[17:00:30.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.083]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.083]         }
[17:00:30.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.083]             base::sink(type = "output", split = FALSE)
[17:00:30.083]             base::close(...future.stdout)
[17:00:30.083]         }, add = TRUE)
[17:00:30.083]     }
[17:00:30.083]     ...future.frame <- base::sys.nframe()
[17:00:30.083]     ...future.conditions <- base::list()
[17:00:30.083]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.083]     if (FALSE) {
[17:00:30.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.083]     }
[17:00:30.083]     ...future.result <- base::tryCatch({
[17:00:30.083]         base::withCallingHandlers({
[17:00:30.083]             ...future.value <- base::withVisible(base::local({
[17:00:30.083]                 withCallingHandlers({
[17:00:30.083]                   {
[17:00:30.083]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.083]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.083]                       ...future.globals.maxSize)) {
[17:00:30.083]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.083]                       on.exit(options(oopts), add = TRUE)
[17:00:30.083]                     }
[17:00:30.083]                     {
[17:00:30.083]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.083]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.083]                         USE.NAMES = FALSE)
[17:00:30.083]                       do.call(mapply, args = args)
[17:00:30.083]                     }
[17:00:30.083]                   }
[17:00:30.083]                 }, immediateCondition = function(cond) {
[17:00:30.083]                   save_rds <- function (object, pathname, ...) 
[17:00:30.083]                   {
[17:00:30.083]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.083]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.083]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.083]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.083]                         fi_tmp[["mtime"]])
[17:00:30.083]                     }
[17:00:30.083]                     tryCatch({
[17:00:30.083]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.083]                     }, error = function(ex) {
[17:00:30.083]                       msg <- conditionMessage(ex)
[17:00:30.083]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.083]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.083]                         fi_tmp[["mtime"]], msg)
[17:00:30.083]                       ex$message <- msg
[17:00:30.083]                       stop(ex)
[17:00:30.083]                     })
[17:00:30.083]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.083]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.083]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.083]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.083]                       fi <- file.info(pathname)
[17:00:30.083]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.083]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.083]                         fi[["size"]], fi[["mtime"]])
[17:00:30.083]                       stop(msg)
[17:00:30.083]                     }
[17:00:30.083]                     invisible(pathname)
[17:00:30.083]                   }
[17:00:30.083]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.083]                     rootPath = tempdir()) 
[17:00:30.083]                   {
[17:00:30.083]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.083]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.083]                       tmpdir = path, fileext = ".rds")
[17:00:30.083]                     save_rds(obj, file)
[17:00:30.083]                   }
[17:00:30.083]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.083]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.083]                   {
[17:00:30.083]                     inherits <- base::inherits
[17:00:30.083]                     invokeRestart <- base::invokeRestart
[17:00:30.083]                     is.null <- base::is.null
[17:00:30.083]                     muffled <- FALSE
[17:00:30.083]                     if (inherits(cond, "message")) {
[17:00:30.083]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.083]                       if (muffled) 
[17:00:30.083]                         invokeRestart("muffleMessage")
[17:00:30.083]                     }
[17:00:30.083]                     else if (inherits(cond, "warning")) {
[17:00:30.083]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.083]                       if (muffled) 
[17:00:30.083]                         invokeRestart("muffleWarning")
[17:00:30.083]                     }
[17:00:30.083]                     else if (inherits(cond, "condition")) {
[17:00:30.083]                       if (!is.null(pattern)) {
[17:00:30.083]                         computeRestarts <- base::computeRestarts
[17:00:30.083]                         grepl <- base::grepl
[17:00:30.083]                         restarts <- computeRestarts(cond)
[17:00:30.083]                         for (restart in restarts) {
[17:00:30.083]                           name <- restart$name
[17:00:30.083]                           if (is.null(name)) 
[17:00:30.083]                             next
[17:00:30.083]                           if (!grepl(pattern, name)) 
[17:00:30.083]                             next
[17:00:30.083]                           invokeRestart(restart)
[17:00:30.083]                           muffled <- TRUE
[17:00:30.083]                           break
[17:00:30.083]                         }
[17:00:30.083]                       }
[17:00:30.083]                     }
[17:00:30.083]                     invisible(muffled)
[17:00:30.083]                   }
[17:00:30.083]                   muffleCondition(cond)
[17:00:30.083]                 })
[17:00:30.083]             }))
[17:00:30.083]             future::FutureResult(value = ...future.value$value, 
[17:00:30.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.083]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.083]                     ...future.globalenv.names))
[17:00:30.083]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.083]         }, condition = base::local({
[17:00:30.083]             c <- base::c
[17:00:30.083]             inherits <- base::inherits
[17:00:30.083]             invokeRestart <- base::invokeRestart
[17:00:30.083]             length <- base::length
[17:00:30.083]             list <- base::list
[17:00:30.083]             seq.int <- base::seq.int
[17:00:30.083]             signalCondition <- base::signalCondition
[17:00:30.083]             sys.calls <- base::sys.calls
[17:00:30.083]             `[[` <- base::`[[`
[17:00:30.083]             `+` <- base::`+`
[17:00:30.083]             `<<-` <- base::`<<-`
[17:00:30.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.083]                   3L)]
[17:00:30.083]             }
[17:00:30.083]             function(cond) {
[17:00:30.083]                 is_error <- inherits(cond, "error")
[17:00:30.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.083]                   NULL)
[17:00:30.083]                 if (is_error) {
[17:00:30.083]                   sessionInformation <- function() {
[17:00:30.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.083]                       search = base::search(), system = base::Sys.info())
[17:00:30.083]                   }
[17:00:30.083]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.083]                     cond$call), session = sessionInformation(), 
[17:00:30.083]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.083]                   signalCondition(cond)
[17:00:30.083]                 }
[17:00:30.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.083]                 "immediateCondition"))) {
[17:00:30.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.083]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.083]                   if (TRUE && !signal) {
[17:00:30.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.083]                     {
[17:00:30.083]                       inherits <- base::inherits
[17:00:30.083]                       invokeRestart <- base::invokeRestart
[17:00:30.083]                       is.null <- base::is.null
[17:00:30.083]                       muffled <- FALSE
[17:00:30.083]                       if (inherits(cond, "message")) {
[17:00:30.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.083]                         if (muffled) 
[17:00:30.083]                           invokeRestart("muffleMessage")
[17:00:30.083]                       }
[17:00:30.083]                       else if (inherits(cond, "warning")) {
[17:00:30.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.083]                         if (muffled) 
[17:00:30.083]                           invokeRestart("muffleWarning")
[17:00:30.083]                       }
[17:00:30.083]                       else if (inherits(cond, "condition")) {
[17:00:30.083]                         if (!is.null(pattern)) {
[17:00:30.083]                           computeRestarts <- base::computeRestarts
[17:00:30.083]                           grepl <- base::grepl
[17:00:30.083]                           restarts <- computeRestarts(cond)
[17:00:30.083]                           for (restart in restarts) {
[17:00:30.083]                             name <- restart$name
[17:00:30.083]                             if (is.null(name)) 
[17:00:30.083]                               next
[17:00:30.083]                             if (!grepl(pattern, name)) 
[17:00:30.083]                               next
[17:00:30.083]                             invokeRestart(restart)
[17:00:30.083]                             muffled <- TRUE
[17:00:30.083]                             break
[17:00:30.083]                           }
[17:00:30.083]                         }
[17:00:30.083]                       }
[17:00:30.083]                       invisible(muffled)
[17:00:30.083]                     }
[17:00:30.083]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.083]                   }
[17:00:30.083]                 }
[17:00:30.083]                 else {
[17:00:30.083]                   if (TRUE) {
[17:00:30.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.083]                     {
[17:00:30.083]                       inherits <- base::inherits
[17:00:30.083]                       invokeRestart <- base::invokeRestart
[17:00:30.083]                       is.null <- base::is.null
[17:00:30.083]                       muffled <- FALSE
[17:00:30.083]                       if (inherits(cond, "message")) {
[17:00:30.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.083]                         if (muffled) 
[17:00:30.083]                           invokeRestart("muffleMessage")
[17:00:30.083]                       }
[17:00:30.083]                       else if (inherits(cond, "warning")) {
[17:00:30.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.083]                         if (muffled) 
[17:00:30.083]                           invokeRestart("muffleWarning")
[17:00:30.083]                       }
[17:00:30.083]                       else if (inherits(cond, "condition")) {
[17:00:30.083]                         if (!is.null(pattern)) {
[17:00:30.083]                           computeRestarts <- base::computeRestarts
[17:00:30.083]                           grepl <- base::grepl
[17:00:30.083]                           restarts <- computeRestarts(cond)
[17:00:30.083]                           for (restart in restarts) {
[17:00:30.083]                             name <- restart$name
[17:00:30.083]                             if (is.null(name)) 
[17:00:30.083]                               next
[17:00:30.083]                             if (!grepl(pattern, name)) 
[17:00:30.083]                               next
[17:00:30.083]                             invokeRestart(restart)
[17:00:30.083]                             muffled <- TRUE
[17:00:30.083]                             break
[17:00:30.083]                           }
[17:00:30.083]                         }
[17:00:30.083]                       }
[17:00:30.083]                       invisible(muffled)
[17:00:30.083]                     }
[17:00:30.083]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.083]                   }
[17:00:30.083]                 }
[17:00:30.083]             }
[17:00:30.083]         }))
[17:00:30.083]     }, error = function(ex) {
[17:00:30.083]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.083]                 ...future.rng), started = ...future.startTime, 
[17:00:30.083]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.083]             version = "1.8"), class = "FutureResult")
[17:00:30.083]     }, finally = {
[17:00:30.083]         if (!identical(...future.workdir, getwd())) 
[17:00:30.083]             setwd(...future.workdir)
[17:00:30.083]         {
[17:00:30.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.083]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.083]             }
[17:00:30.083]             base::options(...future.oldOptions)
[17:00:30.083]             if (.Platform$OS.type == "windows") {
[17:00:30.083]                 old_names <- names(...future.oldEnvVars)
[17:00:30.083]                 envs <- base::Sys.getenv()
[17:00:30.083]                 names <- names(envs)
[17:00:30.083]                 common <- intersect(names, old_names)
[17:00:30.083]                 added <- setdiff(names, old_names)
[17:00:30.083]                 removed <- setdiff(old_names, names)
[17:00:30.083]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.083]                   envs[common]]
[17:00:30.083]                 NAMES <- toupper(changed)
[17:00:30.083]                 args <- list()
[17:00:30.083]                 for (kk in seq_along(NAMES)) {
[17:00:30.083]                   name <- changed[[kk]]
[17:00:30.083]                   NAME <- NAMES[[kk]]
[17:00:30.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.083]                     next
[17:00:30.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.083]                 }
[17:00:30.083]                 NAMES <- toupper(added)
[17:00:30.083]                 for (kk in seq_along(NAMES)) {
[17:00:30.083]                   name <- added[[kk]]
[17:00:30.083]                   NAME <- NAMES[[kk]]
[17:00:30.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.083]                     next
[17:00:30.083]                   args[[name]] <- ""
[17:00:30.083]                 }
[17:00:30.083]                 NAMES <- toupper(removed)
[17:00:30.083]                 for (kk in seq_along(NAMES)) {
[17:00:30.083]                   name <- removed[[kk]]
[17:00:30.083]                   NAME <- NAMES[[kk]]
[17:00:30.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.083]                     next
[17:00:30.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.083]                 }
[17:00:30.083]                 if (length(args) > 0) 
[17:00:30.083]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.083]             }
[17:00:30.083]             else {
[17:00:30.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.083]             }
[17:00:30.083]             {
[17:00:30.083]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.083]                   0L) {
[17:00:30.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.083]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.083]                   base::options(opts)
[17:00:30.083]                 }
[17:00:30.083]                 {
[17:00:30.083]                   {
[17:00:30.083]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.083]                     NULL
[17:00:30.083]                   }
[17:00:30.083]                   options(future.plan = NULL)
[17:00:30.083]                   if (is.na(NA_character_)) 
[17:00:30.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.083]                     .init = FALSE)
[17:00:30.083]                 }
[17:00:30.083]             }
[17:00:30.083]         }
[17:00:30.083]     })
[17:00:30.083]     if (TRUE) {
[17:00:30.083]         base::sink(type = "output", split = FALSE)
[17:00:30.083]         if (TRUE) {
[17:00:30.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.083]         }
[17:00:30.083]         else {
[17:00:30.083]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.083]         }
[17:00:30.083]         base::close(...future.stdout)
[17:00:30.083]         ...future.stdout <- NULL
[17:00:30.083]     }
[17:00:30.083]     ...future.result$conditions <- ...future.conditions
[17:00:30.083]     ...future.result$finished <- base::Sys.time()
[17:00:30.083]     ...future.result
[17:00:30.083] }
[17:00:30.086] assign_globals() ...
[17:00:30.086] List of 5
[17:00:30.086]  $ ...future.FUN            :function (C, k)  
[17:00:30.086]  $ MoreArgs                 : NULL
[17:00:30.086]  $ ...future.elements_ii    :List of 2
[17:00:30.086]   ..$ :List of 2
[17:00:30.086]   .. ..$ : chr "A"
[17:00:30.086]   .. ..$ : chr "B"
[17:00:30.086]   ..$ :List of 2
[17:00:30.086]   .. ..$ : int 5
[17:00:30.086]   .. ..$ : int 4
[17:00:30.086]  $ ...future.seeds_ii       : NULL
[17:00:30.086]  $ ...future.globals.maxSize: NULL
[17:00:30.086]  - attr(*, "where")=List of 5
[17:00:30.086]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.086]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.086]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.086]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.086]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.086]  - attr(*, "resolved")= logi FALSE
[17:00:30.086]  - attr(*, "total_size")= num 3656
[17:00:30.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.086]  - attr(*, "already-done")= logi TRUE
[17:00:30.095] - reassign environment for ‘...future.FUN’
[17:00:30.096] - copied ‘...future.FUN’ to environment
[17:00:30.096] - copied ‘MoreArgs’ to environment
[17:00:30.096] - copied ‘...future.elements_ii’ to environment
[17:00:30.096] - copied ‘...future.seeds_ii’ to environment
[17:00:30.096] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.096] assign_globals() ... done
[17:00:30.096] requestCore(): workers = 2
[17:00:30.099] MulticoreFuture started
[17:00:30.099] - Launch lazy future ... done
[17:00:30.100] run() for ‘MulticoreFuture’ ... done
[17:00:30.100] plan(): Setting new future strategy stack:
[17:00:30.100] Created future:
[17:00:30.100] List of future strategies:
[17:00:30.100] 1. sequential:
[17:00:30.100]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.100]    - tweaked: FALSE
[17:00:30.100]    - call: NULL
[17:00:30.102] plan(): nbrOfWorkers() = 1
[17:00:30.104] plan(): Setting new future strategy stack:
[17:00:30.105] List of future strategies:
[17:00:30.105] 1. multicore:
[17:00:30.105]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.105]    - tweaked: FALSE
[17:00:30.105]    - call: plan(strategy)
[17:00:30.110] plan(): nbrOfWorkers() = 2
[17:00:30.101] MulticoreFuture:
[17:00:30.101] Label: ‘future_mapply-1’
[17:00:30.101] Expression:
[17:00:30.101] {
[17:00:30.101]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.101]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.101]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.101]         on.exit(options(oopts), add = TRUE)
[17:00:30.101]     }
[17:00:30.101]     {
[17:00:30.101]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.101]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.101]         do.call(mapply, args = args)
[17:00:30.101]     }
[17:00:30.101] }
[17:00:30.101] Lazy evaluation: FALSE
[17:00:30.101] Asynchronous evaluation: TRUE
[17:00:30.101] Local evaluation: TRUE
[17:00:30.101] Environment: R_GlobalEnv
[17:00:30.101] Capture standard output: TRUE
[17:00:30.101] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.101] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.101] Packages: <none>
[17:00:30.101] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.101] Resolved: TRUE
[17:00:30.101] Value: <not collected>
[17:00:30.101] Conditions captured: <none>
[17:00:30.101] Early signaling: FALSE
[17:00:30.101] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.101] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.111] Chunk #1 of 3 ... DONE
[17:00:30.112] Chunk #2 of 3 ...
[17:00:30.112]  - Finding globals in '...' for chunk #2 ...
[17:00:30.112] getGlobalsAndPackages() ...
[17:00:30.112] Searching for globals...
[17:00:30.113] 
[17:00:30.113] Searching for globals ... DONE
[17:00:30.113] - globals: [0] <none>
[17:00:30.113] getGlobalsAndPackages() ... DONE
[17:00:30.114]    + additional globals found: [n=0] 
[17:00:30.114]    + additional namespaces needed: [n=0] 
[17:00:30.114]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:30.114]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:00:30.114]  - seeds: <none>
[17:00:30.114]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.115] getGlobalsAndPackages() ...
[17:00:30.115] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.115] Resolving globals: FALSE
[17:00:30.116] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:30.117] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:30.117] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.117] 
[17:00:30.117] getGlobalsAndPackages() ... DONE
[17:00:30.118] run() for ‘Future’ ...
[17:00:30.118] - state: ‘created’
[17:00:30.118] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.123] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.124]   - Field: ‘label’
[17:00:30.124]   - Field: ‘local’
[17:00:30.124]   - Field: ‘owner’
[17:00:30.124]   - Field: ‘envir’
[17:00:30.124]   - Field: ‘workers’
[17:00:30.124]   - Field: ‘packages’
[17:00:30.124]   - Field: ‘gc’
[17:00:30.125]   - Field: ‘job’
[17:00:30.125]   - Field: ‘conditions’
[17:00:30.125]   - Field: ‘expr’
[17:00:30.125]   - Field: ‘uuid’
[17:00:30.125]   - Field: ‘seed’
[17:00:30.125]   - Field: ‘version’
[17:00:30.125]   - Field: ‘result’
[17:00:30.126]   - Field: ‘asynchronous’
[17:00:30.126]   - Field: ‘calls’
[17:00:30.126]   - Field: ‘globals’
[17:00:30.126]   - Field: ‘stdout’
[17:00:30.126]   - Field: ‘earlySignal’
[17:00:30.126]   - Field: ‘lazy’
[17:00:30.126]   - Field: ‘state’
[17:00:30.127] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.127] - Launch lazy future ...
[17:00:30.127] Packages needed by the future expression (n = 0): <none>
[17:00:30.127] Packages needed by future strategies (n = 0): <none>
[17:00:30.128] {
[17:00:30.128]     {
[17:00:30.128]         {
[17:00:30.128]             ...future.startTime <- base::Sys.time()
[17:00:30.128]             {
[17:00:30.128]                 {
[17:00:30.128]                   {
[17:00:30.128]                     {
[17:00:30.128]                       base::local({
[17:00:30.128]                         has_future <- base::requireNamespace("future", 
[17:00:30.128]                           quietly = TRUE)
[17:00:30.128]                         if (has_future) {
[17:00:30.128]                           ns <- base::getNamespace("future")
[17:00:30.128]                           version <- ns[[".package"]][["version"]]
[17:00:30.128]                           if (is.null(version)) 
[17:00:30.128]                             version <- utils::packageVersion("future")
[17:00:30.128]                         }
[17:00:30.128]                         else {
[17:00:30.128]                           version <- NULL
[17:00:30.128]                         }
[17:00:30.128]                         if (!has_future || version < "1.8.0") {
[17:00:30.128]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.128]                             "", base::R.version$version.string), 
[17:00:30.128]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.128]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.128]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.128]                               "release", "version")], collapse = " "), 
[17:00:30.128]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.128]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.128]                             info)
[17:00:30.128]                           info <- base::paste(info, collapse = "; ")
[17:00:30.128]                           if (!has_future) {
[17:00:30.128]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.128]                               info)
[17:00:30.128]                           }
[17:00:30.128]                           else {
[17:00:30.128]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.128]                               info, version)
[17:00:30.128]                           }
[17:00:30.128]                           base::stop(msg)
[17:00:30.128]                         }
[17:00:30.128]                       })
[17:00:30.128]                     }
[17:00:30.128]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.128]                     base::options(mc.cores = 1L)
[17:00:30.128]                   }
[17:00:30.128]                   ...future.strategy.old <- future::plan("list")
[17:00:30.128]                   options(future.plan = NULL)
[17:00:30.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.128]                 }
[17:00:30.128]                 ...future.workdir <- getwd()
[17:00:30.128]             }
[17:00:30.128]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.128]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.128]         }
[17:00:30.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.128]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:00:30.128]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.128]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.128]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.128]             base::names(...future.oldOptions))
[17:00:30.128]     }
[17:00:30.128]     if (FALSE) {
[17:00:30.128]     }
[17:00:30.128]     else {
[17:00:30.128]         if (TRUE) {
[17:00:30.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.128]                 open = "w")
[17:00:30.128]         }
[17:00:30.128]         else {
[17:00:30.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.128]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.128]         }
[17:00:30.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.128]             base::sink(type = "output", split = FALSE)
[17:00:30.128]             base::close(...future.stdout)
[17:00:30.128]         }, add = TRUE)
[17:00:30.128]     }
[17:00:30.128]     ...future.frame <- base::sys.nframe()
[17:00:30.128]     ...future.conditions <- base::list()
[17:00:30.128]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.128]     if (FALSE) {
[17:00:30.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.128]     }
[17:00:30.128]     ...future.result <- base::tryCatch({
[17:00:30.128]         base::withCallingHandlers({
[17:00:30.128]             ...future.value <- base::withVisible(base::local({
[17:00:30.128]                 withCallingHandlers({
[17:00:30.128]                   {
[17:00:30.128]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.128]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.128]                       ...future.globals.maxSize)) {
[17:00:30.128]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.128]                       on.exit(options(oopts), add = TRUE)
[17:00:30.128]                     }
[17:00:30.128]                     {
[17:00:30.128]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.128]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.128]                         USE.NAMES = FALSE)
[17:00:30.128]                       do.call(mapply, args = args)
[17:00:30.128]                     }
[17:00:30.128]                   }
[17:00:30.128]                 }, immediateCondition = function(cond) {
[17:00:30.128]                   save_rds <- function (object, pathname, ...) 
[17:00:30.128]                   {
[17:00:30.128]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.128]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.128]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.128]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.128]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.128]                         fi_tmp[["mtime"]])
[17:00:30.128]                     }
[17:00:30.128]                     tryCatch({
[17:00:30.128]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.128]                     }, error = function(ex) {
[17:00:30.128]                       msg <- conditionMessage(ex)
[17:00:30.128]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.128]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.128]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.128]                         fi_tmp[["mtime"]], msg)
[17:00:30.128]                       ex$message <- msg
[17:00:30.128]                       stop(ex)
[17:00:30.128]                     })
[17:00:30.128]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.128]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.128]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.128]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.128]                       fi <- file.info(pathname)
[17:00:30.128]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.128]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.128]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.128]                         fi[["size"]], fi[["mtime"]])
[17:00:30.128]                       stop(msg)
[17:00:30.128]                     }
[17:00:30.128]                     invisible(pathname)
[17:00:30.128]                   }
[17:00:30.128]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.128]                     rootPath = tempdir()) 
[17:00:30.128]                   {
[17:00:30.128]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.128]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.128]                       tmpdir = path, fileext = ".rds")
[17:00:30.128]                     save_rds(obj, file)
[17:00:30.128]                   }
[17:00:30.128]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.128]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.128]                   {
[17:00:30.128]                     inherits <- base::inherits
[17:00:30.128]                     invokeRestart <- base::invokeRestart
[17:00:30.128]                     is.null <- base::is.null
[17:00:30.128]                     muffled <- FALSE
[17:00:30.128]                     if (inherits(cond, "message")) {
[17:00:30.128]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.128]                       if (muffled) 
[17:00:30.128]                         invokeRestart("muffleMessage")
[17:00:30.128]                     }
[17:00:30.128]                     else if (inherits(cond, "warning")) {
[17:00:30.128]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.128]                       if (muffled) 
[17:00:30.128]                         invokeRestart("muffleWarning")
[17:00:30.128]                     }
[17:00:30.128]                     else if (inherits(cond, "condition")) {
[17:00:30.128]                       if (!is.null(pattern)) {
[17:00:30.128]                         computeRestarts <- base::computeRestarts
[17:00:30.128]                         grepl <- base::grepl
[17:00:30.128]                         restarts <- computeRestarts(cond)
[17:00:30.128]                         for (restart in restarts) {
[17:00:30.128]                           name <- restart$name
[17:00:30.128]                           if (is.null(name)) 
[17:00:30.128]                             next
[17:00:30.128]                           if (!grepl(pattern, name)) 
[17:00:30.128]                             next
[17:00:30.128]                           invokeRestart(restart)
[17:00:30.128]                           muffled <- TRUE
[17:00:30.128]                           break
[17:00:30.128]                         }
[17:00:30.128]                       }
[17:00:30.128]                     }
[17:00:30.128]                     invisible(muffled)
[17:00:30.128]                   }
[17:00:30.128]                   muffleCondition(cond)
[17:00:30.128]                 })
[17:00:30.128]             }))
[17:00:30.128]             future::FutureResult(value = ...future.value$value, 
[17:00:30.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.128]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.128]                     ...future.globalenv.names))
[17:00:30.128]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.128]         }, condition = base::local({
[17:00:30.128]             c <- base::c
[17:00:30.128]             inherits <- base::inherits
[17:00:30.128]             invokeRestart <- base::invokeRestart
[17:00:30.128]             length <- base::length
[17:00:30.128]             list <- base::list
[17:00:30.128]             seq.int <- base::seq.int
[17:00:30.128]             signalCondition <- base::signalCondition
[17:00:30.128]             sys.calls <- base::sys.calls
[17:00:30.128]             `[[` <- base::`[[`
[17:00:30.128]             `+` <- base::`+`
[17:00:30.128]             `<<-` <- base::`<<-`
[17:00:30.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.128]                   3L)]
[17:00:30.128]             }
[17:00:30.128]             function(cond) {
[17:00:30.128]                 is_error <- inherits(cond, "error")
[17:00:30.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.128]                   NULL)
[17:00:30.128]                 if (is_error) {
[17:00:30.128]                   sessionInformation <- function() {
[17:00:30.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.128]                       search = base::search(), system = base::Sys.info())
[17:00:30.128]                   }
[17:00:30.128]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.128]                     cond$call), session = sessionInformation(), 
[17:00:30.128]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.128]                   signalCondition(cond)
[17:00:30.128]                 }
[17:00:30.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.128]                 "immediateCondition"))) {
[17:00:30.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.128]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.128]                   if (TRUE && !signal) {
[17:00:30.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.128]                     {
[17:00:30.128]                       inherits <- base::inherits
[17:00:30.128]                       invokeRestart <- base::invokeRestart
[17:00:30.128]                       is.null <- base::is.null
[17:00:30.128]                       muffled <- FALSE
[17:00:30.128]                       if (inherits(cond, "message")) {
[17:00:30.128]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.128]                         if (muffled) 
[17:00:30.128]                           invokeRestart("muffleMessage")
[17:00:30.128]                       }
[17:00:30.128]                       else if (inherits(cond, "warning")) {
[17:00:30.128]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.128]                         if (muffled) 
[17:00:30.128]                           invokeRestart("muffleWarning")
[17:00:30.128]                       }
[17:00:30.128]                       else if (inherits(cond, "condition")) {
[17:00:30.128]                         if (!is.null(pattern)) {
[17:00:30.128]                           computeRestarts <- base::computeRestarts
[17:00:30.128]                           grepl <- base::grepl
[17:00:30.128]                           restarts <- computeRestarts(cond)
[17:00:30.128]                           for (restart in restarts) {
[17:00:30.128]                             name <- restart$name
[17:00:30.128]                             if (is.null(name)) 
[17:00:30.128]                               next
[17:00:30.128]                             if (!grepl(pattern, name)) 
[17:00:30.128]                               next
[17:00:30.128]                             invokeRestart(restart)
[17:00:30.128]                             muffled <- TRUE
[17:00:30.128]                             break
[17:00:30.128]                           }
[17:00:30.128]                         }
[17:00:30.128]                       }
[17:00:30.128]                       invisible(muffled)
[17:00:30.128]                     }
[17:00:30.128]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.128]                   }
[17:00:30.128]                 }
[17:00:30.128]                 else {
[17:00:30.128]                   if (TRUE) {
[17:00:30.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.128]                     {
[17:00:30.128]                       inherits <- base::inherits
[17:00:30.128]                       invokeRestart <- base::invokeRestart
[17:00:30.128]                       is.null <- base::is.null
[17:00:30.128]                       muffled <- FALSE
[17:00:30.128]                       if (inherits(cond, "message")) {
[17:00:30.128]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.128]                         if (muffled) 
[17:00:30.128]                           invokeRestart("muffleMessage")
[17:00:30.128]                       }
[17:00:30.128]                       else if (inherits(cond, "warning")) {
[17:00:30.128]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.128]                         if (muffled) 
[17:00:30.128]                           invokeRestart("muffleWarning")
[17:00:30.128]                       }
[17:00:30.128]                       else if (inherits(cond, "condition")) {
[17:00:30.128]                         if (!is.null(pattern)) {
[17:00:30.128]                           computeRestarts <- base::computeRestarts
[17:00:30.128]                           grepl <- base::grepl
[17:00:30.128]                           restarts <- computeRestarts(cond)
[17:00:30.128]                           for (restart in restarts) {
[17:00:30.128]                             name <- restart$name
[17:00:30.128]                             if (is.null(name)) 
[17:00:30.128]                               next
[17:00:30.128]                             if (!grepl(pattern, name)) 
[17:00:30.128]                               next
[17:00:30.128]                             invokeRestart(restart)
[17:00:30.128]                             muffled <- TRUE
[17:00:30.128]                             break
[17:00:30.128]                           }
[17:00:30.128]                         }
[17:00:30.128]                       }
[17:00:30.128]                       invisible(muffled)
[17:00:30.128]                     }
[17:00:30.128]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.128]                   }
[17:00:30.128]                 }
[17:00:30.128]             }
[17:00:30.128]         }))
[17:00:30.128]     }, error = function(ex) {
[17:00:30.128]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.128]                 ...future.rng), started = ...future.startTime, 
[17:00:30.128]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.128]             version = "1.8"), class = "FutureResult")
[17:00:30.128]     }, finally = {
[17:00:30.128]         if (!identical(...future.workdir, getwd())) 
[17:00:30.128]             setwd(...future.workdir)
[17:00:30.128]         {
[17:00:30.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.128]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.128]             }
[17:00:30.128]             base::options(...future.oldOptions)
[17:00:30.128]             if (.Platform$OS.type == "windows") {
[17:00:30.128]                 old_names <- names(...future.oldEnvVars)
[17:00:30.128]                 envs <- base::Sys.getenv()
[17:00:30.128]                 names <- names(envs)
[17:00:30.128]                 common <- intersect(names, old_names)
[17:00:30.128]                 added <- setdiff(names, old_names)
[17:00:30.128]                 removed <- setdiff(old_names, names)
[17:00:30.128]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.128]                   envs[common]]
[17:00:30.128]                 NAMES <- toupper(changed)
[17:00:30.128]                 args <- list()
[17:00:30.128]                 for (kk in seq_along(NAMES)) {
[17:00:30.128]                   name <- changed[[kk]]
[17:00:30.128]                   NAME <- NAMES[[kk]]
[17:00:30.128]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.128]                     next
[17:00:30.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.128]                 }
[17:00:30.128]                 NAMES <- toupper(added)
[17:00:30.128]                 for (kk in seq_along(NAMES)) {
[17:00:30.128]                   name <- added[[kk]]
[17:00:30.128]                   NAME <- NAMES[[kk]]
[17:00:30.128]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.128]                     next
[17:00:30.128]                   args[[name]] <- ""
[17:00:30.128]                 }
[17:00:30.128]                 NAMES <- toupper(removed)
[17:00:30.128]                 for (kk in seq_along(NAMES)) {
[17:00:30.128]                   name <- removed[[kk]]
[17:00:30.128]                   NAME <- NAMES[[kk]]
[17:00:30.128]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.128]                     next
[17:00:30.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.128]                 }
[17:00:30.128]                 if (length(args) > 0) 
[17:00:30.128]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.128]             }
[17:00:30.128]             else {
[17:00:30.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.128]             }
[17:00:30.128]             {
[17:00:30.128]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.128]                   0L) {
[17:00:30.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.128]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.128]                   base::options(opts)
[17:00:30.128]                 }
[17:00:30.128]                 {
[17:00:30.128]                   {
[17:00:30.128]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.128]                     NULL
[17:00:30.128]                   }
[17:00:30.128]                   options(future.plan = NULL)
[17:00:30.128]                   if (is.na(NA_character_)) 
[17:00:30.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.128]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.128]                     .init = FALSE)
[17:00:30.128]                 }
[17:00:30.128]             }
[17:00:30.128]         }
[17:00:30.128]     })
[17:00:30.128]     if (TRUE) {
[17:00:30.128]         base::sink(type = "output", split = FALSE)
[17:00:30.128]         if (TRUE) {
[17:00:30.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.128]         }
[17:00:30.128]         else {
[17:00:30.128]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.128]         }
[17:00:30.128]         base::close(...future.stdout)
[17:00:30.128]         ...future.stdout <- NULL
[17:00:30.128]     }
[17:00:30.128]     ...future.result$conditions <- ...future.conditions
[17:00:30.128]     ...future.result$finished <- base::Sys.time()
[17:00:30.128]     ...future.result
[17:00:30.128] }
[17:00:30.132] assign_globals() ...
[17:00:30.132] List of 5
[17:00:30.132]  $ ...future.FUN            :function (C, k)  
[17:00:30.132]  $ MoreArgs                 : NULL
[17:00:30.132]  $ ...future.elements_ii    :List of 2
[17:00:30.132]   ..$ :List of 1
[17:00:30.132]   .. ..$ : chr "E"
[17:00:30.132]   ..$ :List of 1
[17:00:30.132]   .. ..$ : int 1
[17:00:30.132]  $ ...future.seeds_ii       : NULL
[17:00:30.132]  $ ...future.globals.maxSize: NULL
[17:00:30.132]  - attr(*, "where")=List of 5
[17:00:30.132]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.132]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.132]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.132]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.132]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.132]  - attr(*, "resolved")= logi FALSE
[17:00:30.132]  - attr(*, "total_size")= num 3488
[17:00:30.132]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.132]  - attr(*, "already-done")= logi TRUE
[17:00:30.143] - reassign environment for ‘...future.FUN’
[17:00:30.143] - copied ‘...future.FUN’ to environment
[17:00:30.144] - copied ‘MoreArgs’ to environment
[17:00:30.144] - copied ‘...future.elements_ii’ to environment
[17:00:30.144] - copied ‘...future.seeds_ii’ to environment
[17:00:30.144] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.144] assign_globals() ... done
[17:00:30.145] requestCore(): workers = 2
[17:00:30.147] MulticoreFuture started
[17:00:30.148] - Launch lazy future ... done
[17:00:30.149] plan(): Setting new future strategy stack:
[17:00:30.149] run() for ‘MulticoreFuture’ ... done
[17:00:30.150] Created future:
[17:00:30.149] List of future strategies:
[17:00:30.149] 1. sequential:
[17:00:30.149]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.149]    - tweaked: FALSE
[17:00:30.149]    - call: NULL
[17:00:30.151] plan(): nbrOfWorkers() = 1
[17:00:30.154] plan(): Setting new future strategy stack:
[17:00:30.155] List of future strategies:
[17:00:30.155] 1. multicore:
[17:00:30.155]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.155]    - tweaked: FALSE
[17:00:30.155]    - call: plan(strategy)
[17:00:30.161] plan(): nbrOfWorkers() = 2
[17:00:30.150] MulticoreFuture:
[17:00:30.150] Label: ‘future_mapply-2’
[17:00:30.150] Expression:
[17:00:30.150] {
[17:00:30.150]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.150]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.150]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.150]         on.exit(options(oopts), add = TRUE)
[17:00:30.150]     }
[17:00:30.150]     {
[17:00:30.150]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.150]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.150]         do.call(mapply, args = args)
[17:00:30.150]     }
[17:00:30.150] }
[17:00:30.150] Lazy evaluation: FALSE
[17:00:30.150] Asynchronous evaluation: TRUE
[17:00:30.150] Local evaluation: TRUE
[17:00:30.150] Environment: R_GlobalEnv
[17:00:30.150] Capture standard output: TRUE
[17:00:30.150] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.150] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.150] Packages: <none>
[17:00:30.150] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.150] Resolved: TRUE
[17:00:30.150] Value: <not collected>
[17:00:30.150] Conditions captured: <none>
[17:00:30.150] Early signaling: FALSE
[17:00:30.150] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.150] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.163] Chunk #2 of 3 ... DONE
[17:00:30.163] Chunk #3 of 3 ...
[17:00:30.164]  - Finding globals in '...' for chunk #3 ...
[17:00:30.164] getGlobalsAndPackages() ...
[17:00:30.164] Searching for globals...
[17:00:30.165] 
[17:00:30.165] Searching for globals ... DONE
[17:00:30.165] - globals: [0] <none>
[17:00:30.166] getGlobalsAndPackages() ... DONE
[17:00:30.166]    + additional globals found: [n=0] 
[17:00:30.166]    + additional namespaces needed: [n=0] 
[17:00:30.166]  - Finding globals in '...' for chunk #3 ... DONE
[17:00:30.166]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:00:30.167]  - seeds: <none>
[17:00:30.167]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.167] getGlobalsAndPackages() ...
[17:00:30.167] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.168] Resolving globals: FALSE
[17:00:30.169] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:30.169] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:30.170] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.170] 
[17:00:30.170] getGlobalsAndPackages() ... DONE
[17:00:30.171] run() for ‘Future’ ...
[17:00:30.171] - state: ‘created’
[17:00:30.171] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.176] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.176]   - Field: ‘label’
[17:00:30.176]   - Field: ‘local’
[17:00:30.177]   - Field: ‘owner’
[17:00:30.177]   - Field: ‘envir’
[17:00:30.177]   - Field: ‘workers’
[17:00:30.177]   - Field: ‘packages’
[17:00:30.177]   - Field: ‘gc’
[17:00:30.177]   - Field: ‘job’
[17:00:30.177]   - Field: ‘conditions’
[17:00:30.178]   - Field: ‘expr’
[17:00:30.178]   - Field: ‘uuid’
[17:00:30.178]   - Field: ‘seed’
[17:00:30.178]   - Field: ‘version’
[17:00:30.178]   - Field: ‘result’
[17:00:30.178]   - Field: ‘asynchronous’
[17:00:30.178]   - Field: ‘calls’
[17:00:30.178]   - Field: ‘globals’
[17:00:30.179]   - Field: ‘stdout’
[17:00:30.179]   - Field: ‘earlySignal’
[17:00:30.179]   - Field: ‘lazy’
[17:00:30.179]   - Field: ‘state’
[17:00:30.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.179] - Launch lazy future ...
[17:00:30.180] Packages needed by the future expression (n = 0): <none>
[17:00:30.180] Packages needed by future strategies (n = 0): <none>
[17:00:30.180] {
[17:00:30.180]     {
[17:00:30.180]         {
[17:00:30.180]             ...future.startTime <- base::Sys.time()
[17:00:30.180]             {
[17:00:30.180]                 {
[17:00:30.180]                   {
[17:00:30.180]                     {
[17:00:30.180]                       base::local({
[17:00:30.180]                         has_future <- base::requireNamespace("future", 
[17:00:30.180]                           quietly = TRUE)
[17:00:30.180]                         if (has_future) {
[17:00:30.180]                           ns <- base::getNamespace("future")
[17:00:30.180]                           version <- ns[[".package"]][["version"]]
[17:00:30.180]                           if (is.null(version)) 
[17:00:30.180]                             version <- utils::packageVersion("future")
[17:00:30.180]                         }
[17:00:30.180]                         else {
[17:00:30.180]                           version <- NULL
[17:00:30.180]                         }
[17:00:30.180]                         if (!has_future || version < "1.8.0") {
[17:00:30.180]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.180]                             "", base::R.version$version.string), 
[17:00:30.180]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.180]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.180]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.180]                               "release", "version")], collapse = " "), 
[17:00:30.180]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.180]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.180]                             info)
[17:00:30.180]                           info <- base::paste(info, collapse = "; ")
[17:00:30.180]                           if (!has_future) {
[17:00:30.180]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.180]                               info)
[17:00:30.180]                           }
[17:00:30.180]                           else {
[17:00:30.180]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.180]                               info, version)
[17:00:30.180]                           }
[17:00:30.180]                           base::stop(msg)
[17:00:30.180]                         }
[17:00:30.180]                       })
[17:00:30.180]                     }
[17:00:30.180]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.180]                     base::options(mc.cores = 1L)
[17:00:30.180]                   }
[17:00:30.180]                   ...future.strategy.old <- future::plan("list")
[17:00:30.180]                   options(future.plan = NULL)
[17:00:30.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.180]                 }
[17:00:30.180]                 ...future.workdir <- getwd()
[17:00:30.180]             }
[17:00:30.180]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.180]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.180]         }
[17:00:30.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.180]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:00:30.180]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.180]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.180]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.180]             base::names(...future.oldOptions))
[17:00:30.180]     }
[17:00:30.180]     if (FALSE) {
[17:00:30.180]     }
[17:00:30.180]     else {
[17:00:30.180]         if (TRUE) {
[17:00:30.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.180]                 open = "w")
[17:00:30.180]         }
[17:00:30.180]         else {
[17:00:30.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.180]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.180]         }
[17:00:30.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.180]             base::sink(type = "output", split = FALSE)
[17:00:30.180]             base::close(...future.stdout)
[17:00:30.180]         }, add = TRUE)
[17:00:30.180]     }
[17:00:30.180]     ...future.frame <- base::sys.nframe()
[17:00:30.180]     ...future.conditions <- base::list()
[17:00:30.180]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.180]     if (FALSE) {
[17:00:30.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.180]     }
[17:00:30.180]     ...future.result <- base::tryCatch({
[17:00:30.180]         base::withCallingHandlers({
[17:00:30.180]             ...future.value <- base::withVisible(base::local({
[17:00:30.180]                 withCallingHandlers({
[17:00:30.180]                   {
[17:00:30.180]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.180]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.180]                       ...future.globals.maxSize)) {
[17:00:30.180]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.180]                       on.exit(options(oopts), add = TRUE)
[17:00:30.180]                     }
[17:00:30.180]                     {
[17:00:30.180]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.180]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.180]                         USE.NAMES = FALSE)
[17:00:30.180]                       do.call(mapply, args = args)
[17:00:30.180]                     }
[17:00:30.180]                   }
[17:00:30.180]                 }, immediateCondition = function(cond) {
[17:00:30.180]                   save_rds <- function (object, pathname, ...) 
[17:00:30.180]                   {
[17:00:30.180]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.180]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.180]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.180]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.180]                         fi_tmp[["mtime"]])
[17:00:30.180]                     }
[17:00:30.180]                     tryCatch({
[17:00:30.180]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.180]                     }, error = function(ex) {
[17:00:30.180]                       msg <- conditionMessage(ex)
[17:00:30.180]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.180]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.180]                         fi_tmp[["mtime"]], msg)
[17:00:30.180]                       ex$message <- msg
[17:00:30.180]                       stop(ex)
[17:00:30.180]                     })
[17:00:30.180]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.180]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.180]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.180]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.180]                       fi <- file.info(pathname)
[17:00:30.180]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.180]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.180]                         fi[["size"]], fi[["mtime"]])
[17:00:30.180]                       stop(msg)
[17:00:30.180]                     }
[17:00:30.180]                     invisible(pathname)
[17:00:30.180]                   }
[17:00:30.180]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.180]                     rootPath = tempdir()) 
[17:00:30.180]                   {
[17:00:30.180]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.180]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.180]                       tmpdir = path, fileext = ".rds")
[17:00:30.180]                     save_rds(obj, file)
[17:00:30.180]                   }
[17:00:30.180]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.180]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.180]                   {
[17:00:30.180]                     inherits <- base::inherits
[17:00:30.180]                     invokeRestart <- base::invokeRestart
[17:00:30.180]                     is.null <- base::is.null
[17:00:30.180]                     muffled <- FALSE
[17:00:30.180]                     if (inherits(cond, "message")) {
[17:00:30.180]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.180]                       if (muffled) 
[17:00:30.180]                         invokeRestart("muffleMessage")
[17:00:30.180]                     }
[17:00:30.180]                     else if (inherits(cond, "warning")) {
[17:00:30.180]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.180]                       if (muffled) 
[17:00:30.180]                         invokeRestart("muffleWarning")
[17:00:30.180]                     }
[17:00:30.180]                     else if (inherits(cond, "condition")) {
[17:00:30.180]                       if (!is.null(pattern)) {
[17:00:30.180]                         computeRestarts <- base::computeRestarts
[17:00:30.180]                         grepl <- base::grepl
[17:00:30.180]                         restarts <- computeRestarts(cond)
[17:00:30.180]                         for (restart in restarts) {
[17:00:30.180]                           name <- restart$name
[17:00:30.180]                           if (is.null(name)) 
[17:00:30.180]                             next
[17:00:30.180]                           if (!grepl(pattern, name)) 
[17:00:30.180]                             next
[17:00:30.180]                           invokeRestart(restart)
[17:00:30.180]                           muffled <- TRUE
[17:00:30.180]                           break
[17:00:30.180]                         }
[17:00:30.180]                       }
[17:00:30.180]                     }
[17:00:30.180]                     invisible(muffled)
[17:00:30.180]                   }
[17:00:30.180]                   muffleCondition(cond)
[17:00:30.180]                 })
[17:00:30.180]             }))
[17:00:30.180]             future::FutureResult(value = ...future.value$value, 
[17:00:30.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.180]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.180]                     ...future.globalenv.names))
[17:00:30.180]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.180]         }, condition = base::local({
[17:00:30.180]             c <- base::c
[17:00:30.180]             inherits <- base::inherits
[17:00:30.180]             invokeRestart <- base::invokeRestart
[17:00:30.180]             length <- base::length
[17:00:30.180]             list <- base::list
[17:00:30.180]             seq.int <- base::seq.int
[17:00:30.180]             signalCondition <- base::signalCondition
[17:00:30.180]             sys.calls <- base::sys.calls
[17:00:30.180]             `[[` <- base::`[[`
[17:00:30.180]             `+` <- base::`+`
[17:00:30.180]             `<<-` <- base::`<<-`
[17:00:30.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.180]                   3L)]
[17:00:30.180]             }
[17:00:30.180]             function(cond) {
[17:00:30.180]                 is_error <- inherits(cond, "error")
[17:00:30.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.180]                   NULL)
[17:00:30.180]                 if (is_error) {
[17:00:30.180]                   sessionInformation <- function() {
[17:00:30.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.180]                       search = base::search(), system = base::Sys.info())
[17:00:30.180]                   }
[17:00:30.180]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.180]                     cond$call), session = sessionInformation(), 
[17:00:30.180]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.180]                   signalCondition(cond)
[17:00:30.180]                 }
[17:00:30.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.180]                 "immediateCondition"))) {
[17:00:30.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.180]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.180]                   if (TRUE && !signal) {
[17:00:30.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.180]                     {
[17:00:30.180]                       inherits <- base::inherits
[17:00:30.180]                       invokeRestart <- base::invokeRestart
[17:00:30.180]                       is.null <- base::is.null
[17:00:30.180]                       muffled <- FALSE
[17:00:30.180]                       if (inherits(cond, "message")) {
[17:00:30.180]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.180]                         if (muffled) 
[17:00:30.180]                           invokeRestart("muffleMessage")
[17:00:30.180]                       }
[17:00:30.180]                       else if (inherits(cond, "warning")) {
[17:00:30.180]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.180]                         if (muffled) 
[17:00:30.180]                           invokeRestart("muffleWarning")
[17:00:30.180]                       }
[17:00:30.180]                       else if (inherits(cond, "condition")) {
[17:00:30.180]                         if (!is.null(pattern)) {
[17:00:30.180]                           computeRestarts <- base::computeRestarts
[17:00:30.180]                           grepl <- base::grepl
[17:00:30.180]                           restarts <- computeRestarts(cond)
[17:00:30.180]                           for (restart in restarts) {
[17:00:30.180]                             name <- restart$name
[17:00:30.180]                             if (is.null(name)) 
[17:00:30.180]                               next
[17:00:30.180]                             if (!grepl(pattern, name)) 
[17:00:30.180]                               next
[17:00:30.180]                             invokeRestart(restart)
[17:00:30.180]                             muffled <- TRUE
[17:00:30.180]                             break
[17:00:30.180]                           }
[17:00:30.180]                         }
[17:00:30.180]                       }
[17:00:30.180]                       invisible(muffled)
[17:00:30.180]                     }
[17:00:30.180]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.180]                   }
[17:00:30.180]                 }
[17:00:30.180]                 else {
[17:00:30.180]                   if (TRUE) {
[17:00:30.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.180]                     {
[17:00:30.180]                       inherits <- base::inherits
[17:00:30.180]                       invokeRestart <- base::invokeRestart
[17:00:30.180]                       is.null <- base::is.null
[17:00:30.180]                       muffled <- FALSE
[17:00:30.180]                       if (inherits(cond, "message")) {
[17:00:30.180]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.180]                         if (muffled) 
[17:00:30.180]                           invokeRestart("muffleMessage")
[17:00:30.180]                       }
[17:00:30.180]                       else if (inherits(cond, "warning")) {
[17:00:30.180]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.180]                         if (muffled) 
[17:00:30.180]                           invokeRestart("muffleWarning")
[17:00:30.180]                       }
[17:00:30.180]                       else if (inherits(cond, "condition")) {
[17:00:30.180]                         if (!is.null(pattern)) {
[17:00:30.180]                           computeRestarts <- base::computeRestarts
[17:00:30.180]                           grepl <- base::grepl
[17:00:30.180]                           restarts <- computeRestarts(cond)
[17:00:30.180]                           for (restart in restarts) {
[17:00:30.180]                             name <- restart$name
[17:00:30.180]                             if (is.null(name)) 
[17:00:30.180]                               next
[17:00:30.180]                             if (!grepl(pattern, name)) 
[17:00:30.180]                               next
[17:00:30.180]                             invokeRestart(restart)
[17:00:30.180]                             muffled <- TRUE
[17:00:30.180]                             break
[17:00:30.180]                           }
[17:00:30.180]                         }
[17:00:30.180]                       }
[17:00:30.180]                       invisible(muffled)
[17:00:30.180]                     }
[17:00:30.180]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.180]                   }
[17:00:30.180]                 }
[17:00:30.180]             }
[17:00:30.180]         }))
[17:00:30.180]     }, error = function(ex) {
[17:00:30.180]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.180]                 ...future.rng), started = ...future.startTime, 
[17:00:30.180]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.180]             version = "1.8"), class = "FutureResult")
[17:00:30.180]     }, finally = {
[17:00:30.180]         if (!identical(...future.workdir, getwd())) 
[17:00:30.180]             setwd(...future.workdir)
[17:00:30.180]         {
[17:00:30.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.180]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.180]             }
[17:00:30.180]             base::options(...future.oldOptions)
[17:00:30.180]             if (.Platform$OS.type == "windows") {
[17:00:30.180]                 old_names <- names(...future.oldEnvVars)
[17:00:30.180]                 envs <- base::Sys.getenv()
[17:00:30.180]                 names <- names(envs)
[17:00:30.180]                 common <- intersect(names, old_names)
[17:00:30.180]                 added <- setdiff(names, old_names)
[17:00:30.180]                 removed <- setdiff(old_names, names)
[17:00:30.180]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.180]                   envs[common]]
[17:00:30.180]                 NAMES <- toupper(changed)
[17:00:30.180]                 args <- list()
[17:00:30.180]                 for (kk in seq_along(NAMES)) {
[17:00:30.180]                   name <- changed[[kk]]
[17:00:30.180]                   NAME <- NAMES[[kk]]
[17:00:30.180]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.180]                     next
[17:00:30.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.180]                 }
[17:00:30.180]                 NAMES <- toupper(added)
[17:00:30.180]                 for (kk in seq_along(NAMES)) {
[17:00:30.180]                   name <- added[[kk]]
[17:00:30.180]                   NAME <- NAMES[[kk]]
[17:00:30.180]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.180]                     next
[17:00:30.180]                   args[[name]] <- ""
[17:00:30.180]                 }
[17:00:30.180]                 NAMES <- toupper(removed)
[17:00:30.180]                 for (kk in seq_along(NAMES)) {
[17:00:30.180]                   name <- removed[[kk]]
[17:00:30.180]                   NAME <- NAMES[[kk]]
[17:00:30.180]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.180]                     next
[17:00:30.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.180]                 }
[17:00:30.180]                 if (length(args) > 0) 
[17:00:30.180]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.180]             }
[17:00:30.180]             else {
[17:00:30.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.180]             }
[17:00:30.180]             {
[17:00:30.180]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.180]                   0L) {
[17:00:30.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.180]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.180]                   base::options(opts)
[17:00:30.180]                 }
[17:00:30.180]                 {
[17:00:30.180]                   {
[17:00:30.180]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.180]                     NULL
[17:00:30.180]                   }
[17:00:30.180]                   options(future.plan = NULL)
[17:00:30.180]                   if (is.na(NA_character_)) 
[17:00:30.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.180]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.180]                     .init = FALSE)
[17:00:30.180]                 }
[17:00:30.180]             }
[17:00:30.180]         }
[17:00:30.180]     })
[17:00:30.180]     if (TRUE) {
[17:00:30.180]         base::sink(type = "output", split = FALSE)
[17:00:30.180]         if (TRUE) {
[17:00:30.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.180]         }
[17:00:30.180]         else {
[17:00:30.180]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.180]         }
[17:00:30.180]         base::close(...future.stdout)
[17:00:30.180]         ...future.stdout <- NULL
[17:00:30.180]     }
[17:00:30.180]     ...future.result$conditions <- ...future.conditions
[17:00:30.180]     ...future.result$finished <- base::Sys.time()
[17:00:30.180]     ...future.result
[17:00:30.180] }
[17:00:30.184] assign_globals() ...
[17:00:30.184] List of 5
[17:00:30.184]  $ ...future.FUN            :function (C, k)  
[17:00:30.184]  $ MoreArgs                 : NULL
[17:00:30.184]  $ ...future.elements_ii    :List of 2
[17:00:30.184]   ..$ :List of 2
[17:00:30.184]   .. ..$ : chr "D"
[17:00:30.184]   .. ..$ : chr "C"
[17:00:30.184]   ..$ :List of 2
[17:00:30.184]   .. ..$ : int 2
[17:00:30.184]   .. ..$ : int 3
[17:00:30.184]  $ ...future.seeds_ii       : NULL
[17:00:30.184]  $ ...future.globals.maxSize: NULL
[17:00:30.184]  - attr(*, "where")=List of 5
[17:00:30.184]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.184]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.184]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.184]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.184]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.184]  - attr(*, "resolved")= logi FALSE
[17:00:30.184]  - attr(*, "total_size")= num 3656
[17:00:30.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.184]  - attr(*, "already-done")= logi TRUE
[17:00:30.191] - reassign environment for ‘...future.FUN’
[17:00:30.191] - copied ‘...future.FUN’ to environment
[17:00:30.191] - copied ‘MoreArgs’ to environment
[17:00:30.191] - copied ‘...future.elements_ii’ to environment
[17:00:30.192] - copied ‘...future.seeds_ii’ to environment
[17:00:30.192] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.192] assign_globals() ... done
[17:00:30.192] requestCore(): workers = 2
[17:00:30.192] Poll #1 (0): usedCores() = 2, workers = 2
[17:00:30.203] result() for MulticoreFuture ...
[17:00:30.204] result() for MulticoreFuture ...
[17:00:30.204] result() for MulticoreFuture ... done
[17:00:30.204] result() for MulticoreFuture ... done
[17:00:30.204] result() for MulticoreFuture ...
[17:00:30.204] result() for MulticoreFuture ... done
[17:00:30.207] MulticoreFuture started
[17:00:30.207] - Launch lazy future ... done
[17:00:30.207] run() for ‘MulticoreFuture’ ... done
[17:00:30.208] Created future:
[17:00:30.208] plan(): Setting new future strategy stack:
[17:00:30.208] List of future strategies:
[17:00:30.208] 1. sequential:
[17:00:30.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.208]    - tweaked: FALSE
[17:00:30.208]    - call: NULL
[17:00:30.215] plan(): nbrOfWorkers() = 1
[17:00:30.219] plan(): Setting new future strategy stack:
[17:00:30.219] List of future strategies:
[17:00:30.219] 1. multicore:
[17:00:30.219]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.219]    - tweaked: FALSE
[17:00:30.219]    - call: plan(strategy)
[17:00:30.226] plan(): nbrOfWorkers() = 2
[17:00:30.208] MulticoreFuture:
[17:00:30.208] Label: ‘future_mapply-3’
[17:00:30.208] Expression:
[17:00:30.208] {
[17:00:30.208]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.208]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.208]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.208]         on.exit(options(oopts), add = TRUE)
[17:00:30.208]     }
[17:00:30.208]     {
[17:00:30.208]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.208]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.208]         do.call(mapply, args = args)
[17:00:30.208]     }
[17:00:30.208] }
[17:00:30.208] Lazy evaluation: FALSE
[17:00:30.208] Asynchronous evaluation: TRUE
[17:00:30.208] Local evaluation: TRUE
[17:00:30.208] Environment: R_GlobalEnv
[17:00:30.208] Capture standard output: TRUE
[17:00:30.208] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.208] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.208] Packages: <none>
[17:00:30.208] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.208] Resolved: TRUE
[17:00:30.208] Value: <not collected>
[17:00:30.208] Conditions captured: <none>
[17:00:30.208] Early signaling: FALSE
[17:00:30.208] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.208] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.228] Chunk #3 of 3 ... DONE
[17:00:30.228] Launching 3 futures (chunks) ... DONE
[17:00:30.228] Resolving 3 futures (chunks) ...
[17:00:30.228] resolve() on list ...
[17:00:30.229]  recursive: 0
[17:00:30.229]  length: 3
[17:00:30.229] 
[17:00:30.229] Future #1
[17:00:30.229] result() for MulticoreFuture ...
[17:00:30.230] result() for MulticoreFuture ... done
[17:00:30.230] result() for MulticoreFuture ...
[17:00:30.230] result() for MulticoreFuture ... done
[17:00:30.230] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:30.230] - nx: 3
[17:00:30.231] - relay: TRUE
[17:00:30.231] - stdout: TRUE
[17:00:30.231] - signal: TRUE
[17:00:30.231] - resignal: FALSE
[17:00:30.231] - force: TRUE
[17:00:30.232] - relayed: [n=3] FALSE, FALSE, FALSE
[17:00:30.232] - queued futures: [n=3] FALSE, FALSE, FALSE
[17:00:30.232]  - until=1
[17:00:30.232]  - relaying element #1
[17:00:30.233] result() for MulticoreFuture ...
[17:00:30.233] result() for MulticoreFuture ... done
[17:00:30.233] result() for MulticoreFuture ...
[17:00:30.233] result() for MulticoreFuture ... done
[17:00:30.234] result() for MulticoreFuture ...
[17:00:30.234] result() for MulticoreFuture ... done
[17:00:30.234] result() for MulticoreFuture ...
[17:00:30.234] result() for MulticoreFuture ... done
[17:00:30.235] - relayed: [n=3] TRUE, FALSE, FALSE
[17:00:30.235] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:00:30.235] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:30.235]  length: 2 (resolved future 1)
[17:00:30.236] Future #2
[17:00:30.236] result() for MulticoreFuture ...
[17:00:30.237] result() for MulticoreFuture ...
[17:00:30.237] result() for MulticoreFuture ... done
[17:00:30.237] result() for MulticoreFuture ... done
[17:00:30.237] result() for MulticoreFuture ...
[17:00:30.238] result() for MulticoreFuture ... done
[17:00:30.238] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:30.238] - nx: 3
[17:00:30.238] - relay: TRUE
[17:00:30.238] - stdout: TRUE
[17:00:30.238] - signal: TRUE
[17:00:30.238] - resignal: FALSE
[17:00:30.238] - force: TRUE
[17:00:30.239] - relayed: [n=3] TRUE, FALSE, FALSE
[17:00:30.239] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:00:30.239]  - until=2
[17:00:30.239]  - relaying element #2
[17:00:30.239] result() for MulticoreFuture ...
[17:00:30.239] result() for MulticoreFuture ... done
[17:00:30.239] result() for MulticoreFuture ...
[17:00:30.240] result() for MulticoreFuture ... done
[17:00:30.240] result() for MulticoreFuture ...
[17:00:30.240] result() for MulticoreFuture ... done
[17:00:30.240] result() for MulticoreFuture ...
[17:00:30.240] result() for MulticoreFuture ... done
[17:00:30.240] - relayed: [n=3] TRUE, TRUE, FALSE
[17:00:30.241] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:00:30.241] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:30.241]  length: 1 (resolved future 2)
[17:00:30.241] Future #3
[17:00:30.241] result() for MulticoreFuture ...
[17:00:30.242] result() for MulticoreFuture ...
[17:00:30.242] result() for MulticoreFuture ... done
[17:00:30.243] result() for MulticoreFuture ... done
[17:00:30.243] result() for MulticoreFuture ...
[17:00:30.243] result() for MulticoreFuture ... done
[17:00:30.243] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:00:30.243] - nx: 3
[17:00:30.243] - relay: TRUE
[17:00:30.244] - stdout: TRUE
[17:00:30.244] - signal: TRUE
[17:00:30.244] - resignal: FALSE
[17:00:30.244] - force: TRUE
[17:00:30.244] - relayed: [n=3] TRUE, TRUE, FALSE
[17:00:30.244] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:00:30.244]  - until=3
[17:00:30.245]  - relaying element #3
[17:00:30.245] result() for MulticoreFuture ...
[17:00:30.245] result() for MulticoreFuture ... done
[17:00:30.245] result() for MulticoreFuture ...
[17:00:30.245] result() for MulticoreFuture ... done
[17:00:30.245] result() for MulticoreFuture ...
[17:00:30.245] result() for MulticoreFuture ... done
[17:00:30.246] result() for MulticoreFuture ...
[17:00:30.246] result() for MulticoreFuture ... done
[17:00:30.246] - relayed: [n=3] TRUE, TRUE, TRUE
[17:00:30.246] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:00:30.246] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:00:30.246]  length: 0 (resolved future 3)
[17:00:30.246] Relaying remaining futures
[17:00:30.246] signalConditionsASAP(NULL, pos=0) ...
[17:00:30.247] - nx: 3
[17:00:30.247] - relay: TRUE
[17:00:30.247] - stdout: TRUE
[17:00:30.247] - signal: TRUE
[17:00:30.247] - resignal: FALSE
[17:00:30.247] - force: TRUE
[17:00:30.247] - relayed: [n=3] TRUE, TRUE, TRUE
[17:00:30.247] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[17:00:30.247] - relayed: [n=3] TRUE, TRUE, TRUE
[17:00:30.247] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:00:30.248] signalConditionsASAP(NULL, pos=0) ... done
[17:00:30.248] resolve() on list ... DONE
[17:00:30.248] result() for MulticoreFuture ...
[17:00:30.248] result() for MulticoreFuture ... done
[17:00:30.248] result() for MulticoreFuture ...
[17:00:30.248] result() for MulticoreFuture ... done
[17:00:30.248] result() for MulticoreFuture ...
[17:00:30.248] result() for MulticoreFuture ... done
[17:00:30.248] result() for MulticoreFuture ...
[17:00:30.248] result() for MulticoreFuture ... done
[17:00:30.249] result() for MulticoreFuture ...
[17:00:30.249] result() for MulticoreFuture ... done
[17:00:30.249] result() for MulticoreFuture ...
[17:00:30.249] result() for MulticoreFuture ... done
[17:00:30.249]  - Number of value chunks collected: 3
[17:00:30.249] Resolving 3 futures (chunks) ... DONE
[17:00:30.249] Reducing values from 3 chunks ...
[17:00:30.249]  - Number of values collected after concatenation: 5
[17:00:30.249]  - Number of values expected: 5
[17:00:30.250] Reverse index remapping (attribute 'ordering'): [n = 5] 1, 2, 5, 4, 3
[17:00:30.250] Reducing values from 3 chunks ... DONE
[17:00:30.250] future_mapply() ... DONE
[17:00:30.250] future_mapply() ...
[17:00:30.254] Number of chunks: 2
[17:00:30.255] getGlobalsAndPackagesXApply() ...
[17:00:30.255]  - future.globals: TRUE
[17:00:30.255] getGlobalsAndPackages() ...
[17:00:30.255] Searching for globals...
[17:00:30.256] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:30.257] Searching for globals ... DONE
[17:00:30.257] Resolving globals: FALSE
[17:00:30.257] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:30.257] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:30.258] - globals: [1] ‘FUN’
[17:00:30.258] 
[17:00:30.258] getGlobalsAndPackages() ... DONE
[17:00:30.258]  - globals found/used: [n=1] ‘FUN’
[17:00:30.258]  - needed namespaces: [n=0] 
[17:00:30.258] Finding globals ... DONE
[17:00:30.258] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:30.258] List of 2
[17:00:30.258]  $ ...future.FUN:function (C, k)  
[17:00:30.258]  $ MoreArgs     : list()
[17:00:30.258]  - attr(*, "where")=List of 2
[17:00:30.258]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:30.258]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:30.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.258]  - attr(*, "resolved")= logi FALSE
[17:00:30.258]  - attr(*, "total_size")= num NA
[17:00:30.264] Packages to be attached in all futures: [n=0] 
[17:00:30.264] getGlobalsAndPackagesXApply() ... DONE
[17:00:30.264] Number of futures (= number of chunks): 2
[17:00:30.264] Launching 2 futures (chunks) ...
[17:00:30.264] Chunk #1 of 2 ...
[17:00:30.265]  - Finding globals in '...' for chunk #1 ...
[17:00:30.265] getGlobalsAndPackages() ...
[17:00:30.265] Searching for globals...
[17:00:30.265] 
[17:00:30.265] Searching for globals ... DONE
[17:00:30.265] - globals: [0] <none>
[17:00:30.266] getGlobalsAndPackages() ... DONE
[17:00:30.266]    + additional globals found: [n=0] 
[17:00:30.266]    + additional namespaces needed: [n=0] 
[17:00:30.266]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:30.266]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:30.266]  - seeds: <none>
[17:00:30.266]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.266] getGlobalsAndPackages() ...
[17:00:30.266] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.267] Resolving globals: FALSE
[17:00:30.267] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:30.268] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:30.268] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.268] 
[17:00:30.268] getGlobalsAndPackages() ... DONE
[17:00:30.268] run() for ‘Future’ ...
[17:00:30.269] - state: ‘created’
[17:00:30.269] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.273] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.273]   - Field: ‘label’
[17:00:30.273]   - Field: ‘local’
[17:00:30.273]   - Field: ‘owner’
[17:00:30.273]   - Field: ‘envir’
[17:00:30.273]   - Field: ‘workers’
[17:00:30.273]   - Field: ‘packages’
[17:00:30.273]   - Field: ‘gc’
[17:00:30.273]   - Field: ‘job’
[17:00:30.274]   - Field: ‘conditions’
[17:00:30.274]   - Field: ‘expr’
[17:00:30.274]   - Field: ‘uuid’
[17:00:30.274]   - Field: ‘seed’
[17:00:30.274]   - Field: ‘version’
[17:00:30.274]   - Field: ‘result’
[17:00:30.274]   - Field: ‘asynchronous’
[17:00:30.274]   - Field: ‘calls’
[17:00:30.274]   - Field: ‘globals’
[17:00:30.274]   - Field: ‘stdout’
[17:00:30.274]   - Field: ‘earlySignal’
[17:00:30.275]   - Field: ‘lazy’
[17:00:30.275]   - Field: ‘state’
[17:00:30.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.275] - Launch lazy future ...
[17:00:30.275] Packages needed by the future expression (n = 0): <none>
[17:00:30.275] Packages needed by future strategies (n = 0): <none>
[17:00:30.276] {
[17:00:30.276]     {
[17:00:30.276]         {
[17:00:30.276]             ...future.startTime <- base::Sys.time()
[17:00:30.276]             {
[17:00:30.276]                 {
[17:00:30.276]                   {
[17:00:30.276]                     {
[17:00:30.276]                       base::local({
[17:00:30.276]                         has_future <- base::requireNamespace("future", 
[17:00:30.276]                           quietly = TRUE)
[17:00:30.276]                         if (has_future) {
[17:00:30.276]                           ns <- base::getNamespace("future")
[17:00:30.276]                           version <- ns[[".package"]][["version"]]
[17:00:30.276]                           if (is.null(version)) 
[17:00:30.276]                             version <- utils::packageVersion("future")
[17:00:30.276]                         }
[17:00:30.276]                         else {
[17:00:30.276]                           version <- NULL
[17:00:30.276]                         }
[17:00:30.276]                         if (!has_future || version < "1.8.0") {
[17:00:30.276]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.276]                             "", base::R.version$version.string), 
[17:00:30.276]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.276]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.276]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.276]                               "release", "version")], collapse = " "), 
[17:00:30.276]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.276]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.276]                             info)
[17:00:30.276]                           info <- base::paste(info, collapse = "; ")
[17:00:30.276]                           if (!has_future) {
[17:00:30.276]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.276]                               info)
[17:00:30.276]                           }
[17:00:30.276]                           else {
[17:00:30.276]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.276]                               info, version)
[17:00:30.276]                           }
[17:00:30.276]                           base::stop(msg)
[17:00:30.276]                         }
[17:00:30.276]                       })
[17:00:30.276]                     }
[17:00:30.276]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.276]                     base::options(mc.cores = 1L)
[17:00:30.276]                   }
[17:00:30.276]                   ...future.strategy.old <- future::plan("list")
[17:00:30.276]                   options(future.plan = NULL)
[17:00:30.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.276]                 }
[17:00:30.276]                 ...future.workdir <- getwd()
[17:00:30.276]             }
[17:00:30.276]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.276]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.276]         }
[17:00:30.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.276]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.276]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.276]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.276]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.276]             base::names(...future.oldOptions))
[17:00:30.276]     }
[17:00:30.276]     if (FALSE) {
[17:00:30.276]     }
[17:00:30.276]     else {
[17:00:30.276]         if (TRUE) {
[17:00:30.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.276]                 open = "w")
[17:00:30.276]         }
[17:00:30.276]         else {
[17:00:30.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.276]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.276]         }
[17:00:30.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.276]             base::sink(type = "output", split = FALSE)
[17:00:30.276]             base::close(...future.stdout)
[17:00:30.276]         }, add = TRUE)
[17:00:30.276]     }
[17:00:30.276]     ...future.frame <- base::sys.nframe()
[17:00:30.276]     ...future.conditions <- base::list()
[17:00:30.276]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.276]     if (FALSE) {
[17:00:30.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.276]     }
[17:00:30.276]     ...future.result <- base::tryCatch({
[17:00:30.276]         base::withCallingHandlers({
[17:00:30.276]             ...future.value <- base::withVisible(base::local({
[17:00:30.276]                 withCallingHandlers({
[17:00:30.276]                   {
[17:00:30.276]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.276]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.276]                       ...future.globals.maxSize)) {
[17:00:30.276]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.276]                       on.exit(options(oopts), add = TRUE)
[17:00:30.276]                     }
[17:00:30.276]                     {
[17:00:30.276]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.276]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.276]                         USE.NAMES = FALSE)
[17:00:30.276]                       do.call(mapply, args = args)
[17:00:30.276]                     }
[17:00:30.276]                   }
[17:00:30.276]                 }, immediateCondition = function(cond) {
[17:00:30.276]                   save_rds <- function (object, pathname, ...) 
[17:00:30.276]                   {
[17:00:30.276]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.276]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.276]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.276]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.276]                         fi_tmp[["mtime"]])
[17:00:30.276]                     }
[17:00:30.276]                     tryCatch({
[17:00:30.276]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.276]                     }, error = function(ex) {
[17:00:30.276]                       msg <- conditionMessage(ex)
[17:00:30.276]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.276]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.276]                         fi_tmp[["mtime"]], msg)
[17:00:30.276]                       ex$message <- msg
[17:00:30.276]                       stop(ex)
[17:00:30.276]                     })
[17:00:30.276]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.276]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.276]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.276]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.276]                       fi <- file.info(pathname)
[17:00:30.276]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.276]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.276]                         fi[["size"]], fi[["mtime"]])
[17:00:30.276]                       stop(msg)
[17:00:30.276]                     }
[17:00:30.276]                     invisible(pathname)
[17:00:30.276]                   }
[17:00:30.276]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.276]                     rootPath = tempdir()) 
[17:00:30.276]                   {
[17:00:30.276]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.276]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.276]                       tmpdir = path, fileext = ".rds")
[17:00:30.276]                     save_rds(obj, file)
[17:00:30.276]                   }
[17:00:30.276]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.276]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.276]                   {
[17:00:30.276]                     inherits <- base::inherits
[17:00:30.276]                     invokeRestart <- base::invokeRestart
[17:00:30.276]                     is.null <- base::is.null
[17:00:30.276]                     muffled <- FALSE
[17:00:30.276]                     if (inherits(cond, "message")) {
[17:00:30.276]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.276]                       if (muffled) 
[17:00:30.276]                         invokeRestart("muffleMessage")
[17:00:30.276]                     }
[17:00:30.276]                     else if (inherits(cond, "warning")) {
[17:00:30.276]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.276]                       if (muffled) 
[17:00:30.276]                         invokeRestart("muffleWarning")
[17:00:30.276]                     }
[17:00:30.276]                     else if (inherits(cond, "condition")) {
[17:00:30.276]                       if (!is.null(pattern)) {
[17:00:30.276]                         computeRestarts <- base::computeRestarts
[17:00:30.276]                         grepl <- base::grepl
[17:00:30.276]                         restarts <- computeRestarts(cond)
[17:00:30.276]                         for (restart in restarts) {
[17:00:30.276]                           name <- restart$name
[17:00:30.276]                           if (is.null(name)) 
[17:00:30.276]                             next
[17:00:30.276]                           if (!grepl(pattern, name)) 
[17:00:30.276]                             next
[17:00:30.276]                           invokeRestart(restart)
[17:00:30.276]                           muffled <- TRUE
[17:00:30.276]                           break
[17:00:30.276]                         }
[17:00:30.276]                       }
[17:00:30.276]                     }
[17:00:30.276]                     invisible(muffled)
[17:00:30.276]                   }
[17:00:30.276]                   muffleCondition(cond)
[17:00:30.276]                 })
[17:00:30.276]             }))
[17:00:30.276]             future::FutureResult(value = ...future.value$value, 
[17:00:30.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.276]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.276]                     ...future.globalenv.names))
[17:00:30.276]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.276]         }, condition = base::local({
[17:00:30.276]             c <- base::c
[17:00:30.276]             inherits <- base::inherits
[17:00:30.276]             invokeRestart <- base::invokeRestart
[17:00:30.276]             length <- base::length
[17:00:30.276]             list <- base::list
[17:00:30.276]             seq.int <- base::seq.int
[17:00:30.276]             signalCondition <- base::signalCondition
[17:00:30.276]             sys.calls <- base::sys.calls
[17:00:30.276]             `[[` <- base::`[[`
[17:00:30.276]             `+` <- base::`+`
[17:00:30.276]             `<<-` <- base::`<<-`
[17:00:30.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.276]                   3L)]
[17:00:30.276]             }
[17:00:30.276]             function(cond) {
[17:00:30.276]                 is_error <- inherits(cond, "error")
[17:00:30.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.276]                   NULL)
[17:00:30.276]                 if (is_error) {
[17:00:30.276]                   sessionInformation <- function() {
[17:00:30.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.276]                       search = base::search(), system = base::Sys.info())
[17:00:30.276]                   }
[17:00:30.276]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.276]                     cond$call), session = sessionInformation(), 
[17:00:30.276]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.276]                   signalCondition(cond)
[17:00:30.276]                 }
[17:00:30.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.276]                 "immediateCondition"))) {
[17:00:30.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.276]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.276]                   if (TRUE && !signal) {
[17:00:30.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.276]                     {
[17:00:30.276]                       inherits <- base::inherits
[17:00:30.276]                       invokeRestart <- base::invokeRestart
[17:00:30.276]                       is.null <- base::is.null
[17:00:30.276]                       muffled <- FALSE
[17:00:30.276]                       if (inherits(cond, "message")) {
[17:00:30.276]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.276]                         if (muffled) 
[17:00:30.276]                           invokeRestart("muffleMessage")
[17:00:30.276]                       }
[17:00:30.276]                       else if (inherits(cond, "warning")) {
[17:00:30.276]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.276]                         if (muffled) 
[17:00:30.276]                           invokeRestart("muffleWarning")
[17:00:30.276]                       }
[17:00:30.276]                       else if (inherits(cond, "condition")) {
[17:00:30.276]                         if (!is.null(pattern)) {
[17:00:30.276]                           computeRestarts <- base::computeRestarts
[17:00:30.276]                           grepl <- base::grepl
[17:00:30.276]                           restarts <- computeRestarts(cond)
[17:00:30.276]                           for (restart in restarts) {
[17:00:30.276]                             name <- restart$name
[17:00:30.276]                             if (is.null(name)) 
[17:00:30.276]                               next
[17:00:30.276]                             if (!grepl(pattern, name)) 
[17:00:30.276]                               next
[17:00:30.276]                             invokeRestart(restart)
[17:00:30.276]                             muffled <- TRUE
[17:00:30.276]                             break
[17:00:30.276]                           }
[17:00:30.276]                         }
[17:00:30.276]                       }
[17:00:30.276]                       invisible(muffled)
[17:00:30.276]                     }
[17:00:30.276]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.276]                   }
[17:00:30.276]                 }
[17:00:30.276]                 else {
[17:00:30.276]                   if (TRUE) {
[17:00:30.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.276]                     {
[17:00:30.276]                       inherits <- base::inherits
[17:00:30.276]                       invokeRestart <- base::invokeRestart
[17:00:30.276]                       is.null <- base::is.null
[17:00:30.276]                       muffled <- FALSE
[17:00:30.276]                       if (inherits(cond, "message")) {
[17:00:30.276]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.276]                         if (muffled) 
[17:00:30.276]                           invokeRestart("muffleMessage")
[17:00:30.276]                       }
[17:00:30.276]                       else if (inherits(cond, "warning")) {
[17:00:30.276]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.276]                         if (muffled) 
[17:00:30.276]                           invokeRestart("muffleWarning")
[17:00:30.276]                       }
[17:00:30.276]                       else if (inherits(cond, "condition")) {
[17:00:30.276]                         if (!is.null(pattern)) {
[17:00:30.276]                           computeRestarts <- base::computeRestarts
[17:00:30.276]                           grepl <- base::grepl
[17:00:30.276]                           restarts <- computeRestarts(cond)
[17:00:30.276]                           for (restart in restarts) {
[17:00:30.276]                             name <- restart$name
[17:00:30.276]                             if (is.null(name)) 
[17:00:30.276]                               next
[17:00:30.276]                             if (!grepl(pattern, name)) 
[17:00:30.276]                               next
[17:00:30.276]                             invokeRestart(restart)
[17:00:30.276]                             muffled <- TRUE
[17:00:30.276]                             break
[17:00:30.276]                           }
[17:00:30.276]                         }
[17:00:30.276]                       }
[17:00:30.276]                       invisible(muffled)
[17:00:30.276]                     }
[17:00:30.276]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.276]                   }
[17:00:30.276]                 }
[17:00:30.276]             }
[17:00:30.276]         }))
[17:00:30.276]     }, error = function(ex) {
[17:00:30.276]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.276]                 ...future.rng), started = ...future.startTime, 
[17:00:30.276]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.276]             version = "1.8"), class = "FutureResult")
[17:00:30.276]     }, finally = {
[17:00:30.276]         if (!identical(...future.workdir, getwd())) 
[17:00:30.276]             setwd(...future.workdir)
[17:00:30.276]         {
[17:00:30.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.276]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.276]             }
[17:00:30.276]             base::options(...future.oldOptions)
[17:00:30.276]             if (.Platform$OS.type == "windows") {
[17:00:30.276]                 old_names <- names(...future.oldEnvVars)
[17:00:30.276]                 envs <- base::Sys.getenv()
[17:00:30.276]                 names <- names(envs)
[17:00:30.276]                 common <- intersect(names, old_names)
[17:00:30.276]                 added <- setdiff(names, old_names)
[17:00:30.276]                 removed <- setdiff(old_names, names)
[17:00:30.276]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.276]                   envs[common]]
[17:00:30.276]                 NAMES <- toupper(changed)
[17:00:30.276]                 args <- list()
[17:00:30.276]                 for (kk in seq_along(NAMES)) {
[17:00:30.276]                   name <- changed[[kk]]
[17:00:30.276]                   NAME <- NAMES[[kk]]
[17:00:30.276]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.276]                     next
[17:00:30.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.276]                 }
[17:00:30.276]                 NAMES <- toupper(added)
[17:00:30.276]                 for (kk in seq_along(NAMES)) {
[17:00:30.276]                   name <- added[[kk]]
[17:00:30.276]                   NAME <- NAMES[[kk]]
[17:00:30.276]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.276]                     next
[17:00:30.276]                   args[[name]] <- ""
[17:00:30.276]                 }
[17:00:30.276]                 NAMES <- toupper(removed)
[17:00:30.276]                 for (kk in seq_along(NAMES)) {
[17:00:30.276]                   name <- removed[[kk]]
[17:00:30.276]                   NAME <- NAMES[[kk]]
[17:00:30.276]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.276]                     next
[17:00:30.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.276]                 }
[17:00:30.276]                 if (length(args) > 0) 
[17:00:30.276]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.276]             }
[17:00:30.276]             else {
[17:00:30.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.276]             }
[17:00:30.276]             {
[17:00:30.276]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.276]                   0L) {
[17:00:30.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.276]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.276]                   base::options(opts)
[17:00:30.276]                 }
[17:00:30.276]                 {
[17:00:30.276]                   {
[17:00:30.276]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.276]                     NULL
[17:00:30.276]                   }
[17:00:30.276]                   options(future.plan = NULL)
[17:00:30.276]                   if (is.na(NA_character_)) 
[17:00:30.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.276]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.276]                     .init = FALSE)
[17:00:30.276]                 }
[17:00:30.276]             }
[17:00:30.276]         }
[17:00:30.276]     })
[17:00:30.276]     if (TRUE) {
[17:00:30.276]         base::sink(type = "output", split = FALSE)
[17:00:30.276]         if (TRUE) {
[17:00:30.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.276]         }
[17:00:30.276]         else {
[17:00:30.276]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.276]         }
[17:00:30.276]         base::close(...future.stdout)
[17:00:30.276]         ...future.stdout <- NULL
[17:00:30.276]     }
[17:00:30.276]     ...future.result$conditions <- ...future.conditions
[17:00:30.276]     ...future.result$finished <- base::Sys.time()
[17:00:30.276]     ...future.result
[17:00:30.276] }
[17:00:30.278] assign_globals() ...
[17:00:30.278] List of 5
[17:00:30.278]  $ ...future.FUN            :function (C, k)  
[17:00:30.278]  $ MoreArgs                 : list()
[17:00:30.278]  $ ...future.elements_ii    :List of 2
[17:00:30.278]   ..$ :List of 2
[17:00:30.278]   .. ..$ : chr "A"
[17:00:30.278]   .. ..$ : chr "B"
[17:00:30.278]   ..$ :List of 2
[17:00:30.278]   .. ..$ : int 5
[17:00:30.278]   .. ..$ : int 4
[17:00:30.278]  $ ...future.seeds_ii       : NULL
[17:00:30.278]  $ ...future.globals.maxSize: NULL
[17:00:30.278]  - attr(*, "where")=List of 5
[17:00:30.278]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.278]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.278]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.278]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.278]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.278]  - attr(*, "resolved")= logi FALSE
[17:00:30.278]  - attr(*, "total_size")= num 3656
[17:00:30.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.278]  - attr(*, "already-done")= logi TRUE
[17:00:30.284] - reassign environment for ‘...future.FUN’
[17:00:30.284] - copied ‘...future.FUN’ to environment
[17:00:30.284] - copied ‘MoreArgs’ to environment
[17:00:30.284] - copied ‘...future.elements_ii’ to environment
[17:00:30.284] - copied ‘...future.seeds_ii’ to environment
[17:00:30.284] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.284] assign_globals() ... done
[17:00:30.285] requestCore(): workers = 2
[17:00:30.287] MulticoreFuture started
[17:00:30.287] - Launch lazy future ... done
[17:00:30.288] run() for ‘MulticoreFuture’ ... done
[17:00:30.288] Created future:
[17:00:30.288] plan(): Setting new future strategy stack:
[17:00:30.288] List of future strategies:
[17:00:30.288] 1. sequential:
[17:00:30.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.288]    - tweaked: FALSE
[17:00:30.288]    - call: NULL
[17:00:30.289] plan(): nbrOfWorkers() = 1
[17:00:30.291] plan(): Setting new future strategy stack:
[17:00:30.292] List of future strategies:
[17:00:30.292] 1. multicore:
[17:00:30.292]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.292]    - tweaked: FALSE
[17:00:30.292]    - call: plan(strategy)
[17:00:30.288] MulticoreFuture:
[17:00:30.288] Label: ‘future_.mapply-1’
[17:00:30.288] Expression:
[17:00:30.288] {
[17:00:30.288]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.288]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.288]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.288]         on.exit(options(oopts), add = TRUE)
[17:00:30.288]     }
[17:00:30.288]     {
[17:00:30.288]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.288]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.288]         do.call(mapply, args = args)
[17:00:30.288]     }
[17:00:30.288] }
[17:00:30.288] Lazy evaluation: FALSE
[17:00:30.288] Asynchronous evaluation: TRUE
[17:00:30.288] Local evaluation: TRUE
[17:00:30.288] Environment: R_GlobalEnv
[17:00:30.288] Capture standard output: TRUE
[17:00:30.288] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.288] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.288] Packages: <none>
[17:00:30.288] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.288] Resolved: FALSE
[17:00:30.288] Value: <not collected>
[17:00:30.288] Conditions captured: <none>
[17:00:30.288] Early signaling: FALSE
[17:00:30.288] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.288] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.301] Chunk #1 of 2 ... DONE
[17:00:30.301] Chunk #2 of 2 ...
[17:00:30.302]  - Finding globals in '...' for chunk #2 ...
[17:00:30.302] getGlobalsAndPackages() ...
[17:00:30.302] Searching for globals...
[17:00:30.303] 
[17:00:30.303] Searching for globals ... DONE
[17:00:30.304] plan(): nbrOfWorkers() = 2
[17:00:30.303] - globals: [0] <none>
[17:00:30.307] getGlobalsAndPackages() ... DONE
[17:00:30.307]    + additional globals found: [n=0] 
[17:00:30.307]    + additional namespaces needed: [n=0] 
[17:00:30.307]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:30.308]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:30.308]  - seeds: <none>
[17:00:30.308]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.309] getGlobalsAndPackages() ...
[17:00:30.309] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.309] Resolving globals: FALSE
[17:00:30.311] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:00:30.312] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:30.312] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.313] 
[17:00:30.313] getGlobalsAndPackages() ... DONE
[17:00:30.314] run() for ‘Future’ ...
[17:00:30.314] - state: ‘created’
[17:00:30.314] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.320] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.321]   - Field: ‘label’
[17:00:30.321]   - Field: ‘local’
[17:00:30.321]   - Field: ‘owner’
[17:00:30.321]   - Field: ‘envir’
[17:00:30.321]   - Field: ‘workers’
[17:00:30.322]   - Field: ‘packages’
[17:00:30.322]   - Field: ‘gc’
[17:00:30.322]   - Field: ‘job’
[17:00:30.322]   - Field: ‘conditions’
[17:00:30.322]   - Field: ‘expr’
[17:00:30.322]   - Field: ‘uuid’
[17:00:30.323]   - Field: ‘seed’
[17:00:30.323]   - Field: ‘version’
[17:00:30.323]   - Field: ‘result’
[17:00:30.323]   - Field: ‘asynchronous’
[17:00:30.323]   - Field: ‘calls’
[17:00:30.323]   - Field: ‘globals’
[17:00:30.323]   - Field: ‘stdout’
[17:00:30.323]   - Field: ‘earlySignal’
[17:00:30.324]   - Field: ‘lazy’
[17:00:30.324]   - Field: ‘state’
[17:00:30.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.324] - Launch lazy future ...
[17:00:30.324] Packages needed by the future expression (n = 0): <none>
[17:00:30.325] Packages needed by future strategies (n = 0): <none>
[17:00:30.325] {
[17:00:30.325]     {
[17:00:30.325]         {
[17:00:30.325]             ...future.startTime <- base::Sys.time()
[17:00:30.325]             {
[17:00:30.325]                 {
[17:00:30.325]                   {
[17:00:30.325]                     {
[17:00:30.325]                       base::local({
[17:00:30.325]                         has_future <- base::requireNamespace("future", 
[17:00:30.325]                           quietly = TRUE)
[17:00:30.325]                         if (has_future) {
[17:00:30.325]                           ns <- base::getNamespace("future")
[17:00:30.325]                           version <- ns[[".package"]][["version"]]
[17:00:30.325]                           if (is.null(version)) 
[17:00:30.325]                             version <- utils::packageVersion("future")
[17:00:30.325]                         }
[17:00:30.325]                         else {
[17:00:30.325]                           version <- NULL
[17:00:30.325]                         }
[17:00:30.325]                         if (!has_future || version < "1.8.0") {
[17:00:30.325]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.325]                             "", base::R.version$version.string), 
[17:00:30.325]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.325]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.325]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.325]                               "release", "version")], collapse = " "), 
[17:00:30.325]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.325]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.325]                             info)
[17:00:30.325]                           info <- base::paste(info, collapse = "; ")
[17:00:30.325]                           if (!has_future) {
[17:00:30.325]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.325]                               info)
[17:00:30.325]                           }
[17:00:30.325]                           else {
[17:00:30.325]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.325]                               info, version)
[17:00:30.325]                           }
[17:00:30.325]                           base::stop(msg)
[17:00:30.325]                         }
[17:00:30.325]                       })
[17:00:30.325]                     }
[17:00:30.325]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.325]                     base::options(mc.cores = 1L)
[17:00:30.325]                   }
[17:00:30.325]                   ...future.strategy.old <- future::plan("list")
[17:00:30.325]                   options(future.plan = NULL)
[17:00:30.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.325]                 }
[17:00:30.325]                 ...future.workdir <- getwd()
[17:00:30.325]             }
[17:00:30.325]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.325]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.325]         }
[17:00:30.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.325]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.325]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.325]             base::names(...future.oldOptions))
[17:00:30.325]     }
[17:00:30.325]     if (FALSE) {
[17:00:30.325]     }
[17:00:30.325]     else {
[17:00:30.325]         if (TRUE) {
[17:00:30.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.325]                 open = "w")
[17:00:30.325]         }
[17:00:30.325]         else {
[17:00:30.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.325]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.325]         }
[17:00:30.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.325]             base::sink(type = "output", split = FALSE)
[17:00:30.325]             base::close(...future.stdout)
[17:00:30.325]         }, add = TRUE)
[17:00:30.325]     }
[17:00:30.325]     ...future.frame <- base::sys.nframe()
[17:00:30.325]     ...future.conditions <- base::list()
[17:00:30.325]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.325]     if (FALSE) {
[17:00:30.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.325]     }
[17:00:30.325]     ...future.result <- base::tryCatch({
[17:00:30.325]         base::withCallingHandlers({
[17:00:30.325]             ...future.value <- base::withVisible(base::local({
[17:00:30.325]                 withCallingHandlers({
[17:00:30.325]                   {
[17:00:30.325]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.325]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.325]                       ...future.globals.maxSize)) {
[17:00:30.325]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.325]                       on.exit(options(oopts), add = TRUE)
[17:00:30.325]                     }
[17:00:30.325]                     {
[17:00:30.325]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.325]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.325]                         USE.NAMES = FALSE)
[17:00:30.325]                       do.call(mapply, args = args)
[17:00:30.325]                     }
[17:00:30.325]                   }
[17:00:30.325]                 }, immediateCondition = function(cond) {
[17:00:30.325]                   save_rds <- function (object, pathname, ...) 
[17:00:30.325]                   {
[17:00:30.325]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.325]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.325]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.325]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.325]                         fi_tmp[["mtime"]])
[17:00:30.325]                     }
[17:00:30.325]                     tryCatch({
[17:00:30.325]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.325]                     }, error = function(ex) {
[17:00:30.325]                       msg <- conditionMessage(ex)
[17:00:30.325]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.325]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.325]                         fi_tmp[["mtime"]], msg)
[17:00:30.325]                       ex$message <- msg
[17:00:30.325]                       stop(ex)
[17:00:30.325]                     })
[17:00:30.325]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.325]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.325]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.325]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.325]                       fi <- file.info(pathname)
[17:00:30.325]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.325]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.325]                         fi[["size"]], fi[["mtime"]])
[17:00:30.325]                       stop(msg)
[17:00:30.325]                     }
[17:00:30.325]                     invisible(pathname)
[17:00:30.325]                   }
[17:00:30.325]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.325]                     rootPath = tempdir()) 
[17:00:30.325]                   {
[17:00:30.325]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.325]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.325]                       tmpdir = path, fileext = ".rds")
[17:00:30.325]                     save_rds(obj, file)
[17:00:30.325]                   }
[17:00:30.325]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.325]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.325]                   {
[17:00:30.325]                     inherits <- base::inherits
[17:00:30.325]                     invokeRestart <- base::invokeRestart
[17:00:30.325]                     is.null <- base::is.null
[17:00:30.325]                     muffled <- FALSE
[17:00:30.325]                     if (inherits(cond, "message")) {
[17:00:30.325]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.325]                       if (muffled) 
[17:00:30.325]                         invokeRestart("muffleMessage")
[17:00:30.325]                     }
[17:00:30.325]                     else if (inherits(cond, "warning")) {
[17:00:30.325]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.325]                       if (muffled) 
[17:00:30.325]                         invokeRestart("muffleWarning")
[17:00:30.325]                     }
[17:00:30.325]                     else if (inherits(cond, "condition")) {
[17:00:30.325]                       if (!is.null(pattern)) {
[17:00:30.325]                         computeRestarts <- base::computeRestarts
[17:00:30.325]                         grepl <- base::grepl
[17:00:30.325]                         restarts <- computeRestarts(cond)
[17:00:30.325]                         for (restart in restarts) {
[17:00:30.325]                           name <- restart$name
[17:00:30.325]                           if (is.null(name)) 
[17:00:30.325]                             next
[17:00:30.325]                           if (!grepl(pattern, name)) 
[17:00:30.325]                             next
[17:00:30.325]                           invokeRestart(restart)
[17:00:30.325]                           muffled <- TRUE
[17:00:30.325]                           break
[17:00:30.325]                         }
[17:00:30.325]                       }
[17:00:30.325]                     }
[17:00:30.325]                     invisible(muffled)
[17:00:30.325]                   }
[17:00:30.325]                   muffleCondition(cond)
[17:00:30.325]                 })
[17:00:30.325]             }))
[17:00:30.325]             future::FutureResult(value = ...future.value$value, 
[17:00:30.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.325]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.325]                     ...future.globalenv.names))
[17:00:30.325]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.325]         }, condition = base::local({
[17:00:30.325]             c <- base::c
[17:00:30.325]             inherits <- base::inherits
[17:00:30.325]             invokeRestart <- base::invokeRestart
[17:00:30.325]             length <- base::length
[17:00:30.325]             list <- base::list
[17:00:30.325]             seq.int <- base::seq.int
[17:00:30.325]             signalCondition <- base::signalCondition
[17:00:30.325]             sys.calls <- base::sys.calls
[17:00:30.325]             `[[` <- base::`[[`
[17:00:30.325]             `+` <- base::`+`
[17:00:30.325]             `<<-` <- base::`<<-`
[17:00:30.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.325]                   3L)]
[17:00:30.325]             }
[17:00:30.325]             function(cond) {
[17:00:30.325]                 is_error <- inherits(cond, "error")
[17:00:30.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.325]                   NULL)
[17:00:30.325]                 if (is_error) {
[17:00:30.325]                   sessionInformation <- function() {
[17:00:30.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.325]                       search = base::search(), system = base::Sys.info())
[17:00:30.325]                   }
[17:00:30.325]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.325]                     cond$call), session = sessionInformation(), 
[17:00:30.325]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.325]                   signalCondition(cond)
[17:00:30.325]                 }
[17:00:30.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.325]                 "immediateCondition"))) {
[17:00:30.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.325]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.325]                   if (TRUE && !signal) {
[17:00:30.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.325]                     {
[17:00:30.325]                       inherits <- base::inherits
[17:00:30.325]                       invokeRestart <- base::invokeRestart
[17:00:30.325]                       is.null <- base::is.null
[17:00:30.325]                       muffled <- FALSE
[17:00:30.325]                       if (inherits(cond, "message")) {
[17:00:30.325]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.325]                         if (muffled) 
[17:00:30.325]                           invokeRestart("muffleMessage")
[17:00:30.325]                       }
[17:00:30.325]                       else if (inherits(cond, "warning")) {
[17:00:30.325]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.325]                         if (muffled) 
[17:00:30.325]                           invokeRestart("muffleWarning")
[17:00:30.325]                       }
[17:00:30.325]                       else if (inherits(cond, "condition")) {
[17:00:30.325]                         if (!is.null(pattern)) {
[17:00:30.325]                           computeRestarts <- base::computeRestarts
[17:00:30.325]                           grepl <- base::grepl
[17:00:30.325]                           restarts <- computeRestarts(cond)
[17:00:30.325]                           for (restart in restarts) {
[17:00:30.325]                             name <- restart$name
[17:00:30.325]                             if (is.null(name)) 
[17:00:30.325]                               next
[17:00:30.325]                             if (!grepl(pattern, name)) 
[17:00:30.325]                               next
[17:00:30.325]                             invokeRestart(restart)
[17:00:30.325]                             muffled <- TRUE
[17:00:30.325]                             break
[17:00:30.325]                           }
[17:00:30.325]                         }
[17:00:30.325]                       }
[17:00:30.325]                       invisible(muffled)
[17:00:30.325]                     }
[17:00:30.325]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.325]                   }
[17:00:30.325]                 }
[17:00:30.325]                 else {
[17:00:30.325]                   if (TRUE) {
[17:00:30.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.325]                     {
[17:00:30.325]                       inherits <- base::inherits
[17:00:30.325]                       invokeRestart <- base::invokeRestart
[17:00:30.325]                       is.null <- base::is.null
[17:00:30.325]                       muffled <- FALSE
[17:00:30.325]                       if (inherits(cond, "message")) {
[17:00:30.325]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.325]                         if (muffled) 
[17:00:30.325]                           invokeRestart("muffleMessage")
[17:00:30.325]                       }
[17:00:30.325]                       else if (inherits(cond, "warning")) {
[17:00:30.325]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.325]                         if (muffled) 
[17:00:30.325]                           invokeRestart("muffleWarning")
[17:00:30.325]                       }
[17:00:30.325]                       else if (inherits(cond, "condition")) {
[17:00:30.325]                         if (!is.null(pattern)) {
[17:00:30.325]                           computeRestarts <- base::computeRestarts
[17:00:30.325]                           grepl <- base::grepl
[17:00:30.325]                           restarts <- computeRestarts(cond)
[17:00:30.325]                           for (restart in restarts) {
[17:00:30.325]                             name <- restart$name
[17:00:30.325]                             if (is.null(name)) 
[17:00:30.325]                               next
[17:00:30.325]                             if (!grepl(pattern, name)) 
[17:00:30.325]                               next
[17:00:30.325]                             invokeRestart(restart)
[17:00:30.325]                             muffled <- TRUE
[17:00:30.325]                             break
[17:00:30.325]                           }
[17:00:30.325]                         }
[17:00:30.325]                       }
[17:00:30.325]                       invisible(muffled)
[17:00:30.325]                     }
[17:00:30.325]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.325]                   }
[17:00:30.325]                 }
[17:00:30.325]             }
[17:00:30.325]         }))
[17:00:30.325]     }, error = function(ex) {
[17:00:30.325]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.325]                 ...future.rng), started = ...future.startTime, 
[17:00:30.325]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.325]             version = "1.8"), class = "FutureResult")
[17:00:30.325]     }, finally = {
[17:00:30.325]         if (!identical(...future.workdir, getwd())) 
[17:00:30.325]             setwd(...future.workdir)
[17:00:30.325]         {
[17:00:30.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.325]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.325]             }
[17:00:30.325]             base::options(...future.oldOptions)
[17:00:30.325]             if (.Platform$OS.type == "windows") {
[17:00:30.325]                 old_names <- names(...future.oldEnvVars)
[17:00:30.325]                 envs <- base::Sys.getenv()
[17:00:30.325]                 names <- names(envs)
[17:00:30.325]                 common <- intersect(names, old_names)
[17:00:30.325]                 added <- setdiff(names, old_names)
[17:00:30.325]                 removed <- setdiff(old_names, names)
[17:00:30.325]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.325]                   envs[common]]
[17:00:30.325]                 NAMES <- toupper(changed)
[17:00:30.325]                 args <- list()
[17:00:30.325]                 for (kk in seq_along(NAMES)) {
[17:00:30.325]                   name <- changed[[kk]]
[17:00:30.325]                   NAME <- NAMES[[kk]]
[17:00:30.325]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.325]                     next
[17:00:30.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.325]                 }
[17:00:30.325]                 NAMES <- toupper(added)
[17:00:30.325]                 for (kk in seq_along(NAMES)) {
[17:00:30.325]                   name <- added[[kk]]
[17:00:30.325]                   NAME <- NAMES[[kk]]
[17:00:30.325]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.325]                     next
[17:00:30.325]                   args[[name]] <- ""
[17:00:30.325]                 }
[17:00:30.325]                 NAMES <- toupper(removed)
[17:00:30.325]                 for (kk in seq_along(NAMES)) {
[17:00:30.325]                   name <- removed[[kk]]
[17:00:30.325]                   NAME <- NAMES[[kk]]
[17:00:30.325]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.325]                     next
[17:00:30.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.325]                 }
[17:00:30.325]                 if (length(args) > 0) 
[17:00:30.325]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.325]             }
[17:00:30.325]             else {
[17:00:30.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.325]             }
[17:00:30.325]             {
[17:00:30.325]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.325]                   0L) {
[17:00:30.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.325]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.325]                   base::options(opts)
[17:00:30.325]                 }
[17:00:30.325]                 {
[17:00:30.325]                   {
[17:00:30.325]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.325]                     NULL
[17:00:30.325]                   }
[17:00:30.325]                   options(future.plan = NULL)
[17:00:30.325]                   if (is.na(NA_character_)) 
[17:00:30.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.325]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.325]                     .init = FALSE)
[17:00:30.325]                 }
[17:00:30.325]             }
[17:00:30.325]         }
[17:00:30.325]     })
[17:00:30.325]     if (TRUE) {
[17:00:30.325]         base::sink(type = "output", split = FALSE)
[17:00:30.325]         if (TRUE) {
[17:00:30.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.325]         }
[17:00:30.325]         else {
[17:00:30.325]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.325]         }
[17:00:30.325]         base::close(...future.stdout)
[17:00:30.325]         ...future.stdout <- NULL
[17:00:30.325]     }
[17:00:30.325]     ...future.result$conditions <- ...future.conditions
[17:00:30.325]     ...future.result$finished <- base::Sys.time()
[17:00:30.325]     ...future.result
[17:00:30.325] }
[17:00:30.328] assign_globals() ...
[17:00:30.328] List of 5
[17:00:30.328]  $ ...future.FUN            :function (C, k)  
[17:00:30.328]  $ MoreArgs                 : list()
[17:00:30.328]  $ ...future.elements_ii    :List of 2
[17:00:30.328]   ..$ :List of 3
[17:00:30.328]   .. ..$ : chr "C"
[17:00:30.328]   .. ..$ : chr "D"
[17:00:30.328]   .. ..$ : chr "E"
[17:00:30.328]   ..$ :List of 3
[17:00:30.328]   .. ..$ : int 3
[17:00:30.328]   .. ..$ : int 2
[17:00:30.328]   .. ..$ : int 1
[17:00:30.328]  $ ...future.seeds_ii       : NULL
[17:00:30.328]  $ ...future.globals.maxSize: NULL
[17:00:30.328]  - attr(*, "where")=List of 5
[17:00:30.328]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.328]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.328]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.328]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.328]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.328]  - attr(*, "resolved")= logi FALSE
[17:00:30.328]  - attr(*, "total_size")= num 3824
[17:00:30.328]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.328]  - attr(*, "already-done")= logi TRUE
[17:00:30.336] - reassign environment for ‘...future.FUN’
[17:00:30.336] - copied ‘...future.FUN’ to environment
[17:00:30.336] - copied ‘MoreArgs’ to environment
[17:00:30.337] - copied ‘...future.elements_ii’ to environment
[17:00:30.337] - copied ‘...future.seeds_ii’ to environment
[17:00:30.337] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.337] assign_globals() ... done
[17:00:30.337] requestCore(): workers = 2
[17:00:30.339] MulticoreFuture started
[17:00:30.340] - Launch lazy future ... done
[17:00:30.340] run() for ‘MulticoreFuture’ ... done
[17:00:30.340] Created future:
[17:00:30.341] plan(): Setting new future strategy stack:
[17:00:30.341] List of future strategies:
[17:00:30.341] 1. sequential:
[17:00:30.341]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.341]    - tweaked: FALSE
[17:00:30.341]    - call: NULL
[17:00:30.342] plan(): nbrOfWorkers() = 1
[17:00:30.344] plan(): Setting new future strategy stack:
[17:00:30.344] List of future strategies:
[17:00:30.344] 1. multicore:
[17:00:30.344]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.344]    - tweaked: FALSE
[17:00:30.344]    - call: plan(strategy)
[17:00:30.350] plan(): nbrOfWorkers() = 2
[17:00:30.341] MulticoreFuture:
[17:00:30.341] Label: ‘future_.mapply-2’
[17:00:30.341] Expression:
[17:00:30.341] {
[17:00:30.341]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.341]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.341]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.341]         on.exit(options(oopts), add = TRUE)
[17:00:30.341]     }
[17:00:30.341]     {
[17:00:30.341]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.341]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.341]         do.call(mapply, args = args)
[17:00:30.341]     }
[17:00:30.341] }
[17:00:30.341] Lazy evaluation: FALSE
[17:00:30.341] Asynchronous evaluation: TRUE
[17:00:30.341] Local evaluation: TRUE
[17:00:30.341] Environment: R_GlobalEnv
[17:00:30.341] Capture standard output: TRUE
[17:00:30.341] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.341] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.341] Packages: <none>
[17:00:30.341] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.341] Resolved: TRUE
[17:00:30.341] Value: <not collected>
[17:00:30.341] Conditions captured: <none>
[17:00:30.341] Early signaling: FALSE
[17:00:30.341] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.341] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.351] Chunk #2 of 2 ... DONE
[17:00:30.351] Launching 2 futures (chunks) ... DONE
[17:00:30.351] Resolving 2 futures (chunks) ...
[17:00:30.351] resolve() on list ...
[17:00:30.351]  recursive: 0
[17:00:30.352]  length: 2
[17:00:30.352] 
[17:00:30.352] Future #1
[17:00:30.352] result() for MulticoreFuture ...
[17:00:30.353] result() for MulticoreFuture ...
[17:00:30.353] result() for MulticoreFuture ... done
[17:00:30.353] result() for MulticoreFuture ... done
[17:00:30.354] result() for MulticoreFuture ...
[17:00:30.354] result() for MulticoreFuture ... done
[17:00:30.354] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:30.354] - nx: 2
[17:00:30.354] - relay: TRUE
[17:00:30.354] - stdout: TRUE
[17:00:30.355] - signal: TRUE
[17:00:30.355] - resignal: FALSE
[17:00:30.355] - force: TRUE
[17:00:30.355] - relayed: [n=2] FALSE, FALSE
[17:00:30.355] - queued futures: [n=2] FALSE, FALSE
[17:00:30.355]  - until=1
[17:00:30.355]  - relaying element #1
[17:00:30.356] result() for MulticoreFuture ...
[17:00:30.356] result() for MulticoreFuture ... done
[17:00:30.356] result() for MulticoreFuture ...
[17:00:30.356] result() for MulticoreFuture ... done
[17:00:30.356] result() for MulticoreFuture ...
[17:00:30.357] result() for MulticoreFuture ... done
[17:00:30.361] result() for MulticoreFuture ...
[17:00:30.361] result() for MulticoreFuture ... done
[17:00:30.361] - relayed: [n=2] TRUE, FALSE
[17:00:30.362] - queued futures: [n=2] TRUE, FALSE
[17:00:30.362] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:30.363]  length: 1 (resolved future 1)
[17:00:30.363] Future #2
[17:00:30.364] result() for MulticoreFuture ...
[17:00:30.365] result() for MulticoreFuture ...
[17:00:30.365] result() for MulticoreFuture ... done
[17:00:30.365] result() for MulticoreFuture ... done
[17:00:30.366] result() for MulticoreFuture ...
[17:00:30.366] result() for MulticoreFuture ... done
[17:00:30.366] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:30.366] - nx: 2
[17:00:30.366] - relay: TRUE
[17:00:30.367] - stdout: TRUE
[17:00:30.367] - signal: TRUE
[17:00:30.367] - resignal: FALSE
[17:00:30.367] - force: TRUE
[17:00:30.367] - relayed: [n=2] TRUE, FALSE
[17:00:30.367] - queued futures: [n=2] TRUE, FALSE
[17:00:30.368]  - until=2
[17:00:30.368]  - relaying element #2
[17:00:30.368] result() for MulticoreFuture ...
[17:00:30.368] result() for MulticoreFuture ... done
[17:00:30.368] result() for MulticoreFuture ...
[17:00:30.368] result() for MulticoreFuture ... done
[17:00:30.369] result() for MulticoreFuture ...
[17:00:30.369] result() for MulticoreFuture ... done
[17:00:30.369] result() for MulticoreFuture ...
[17:00:30.369] result() for MulticoreFuture ... done
[17:00:30.369] - relayed: [n=2] TRUE, TRUE
[17:00:30.369] - queued futures: [n=2] TRUE, TRUE
[17:00:30.369] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:30.370]  length: 0 (resolved future 2)
[17:00:30.370] Relaying remaining futures
[17:00:30.370] signalConditionsASAP(NULL, pos=0) ...
[17:00:30.370] - nx: 2
[17:00:30.370] - relay: TRUE
[17:00:30.370] - stdout: TRUE
[17:00:30.370] - signal: TRUE
[17:00:30.370] - resignal: FALSE
[17:00:30.371] - force: TRUE
[17:00:30.371] - relayed: [n=2] TRUE, TRUE
[17:00:30.371] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:30.371] - relayed: [n=2] TRUE, TRUE
[17:00:30.371] - queued futures: [n=2] TRUE, TRUE
[17:00:30.371] signalConditionsASAP(NULL, pos=0) ... done
[17:00:30.371] resolve() on list ... DONE
[17:00:30.372] result() for MulticoreFuture ...
[17:00:30.372] result() for MulticoreFuture ... done
[17:00:30.372] result() for MulticoreFuture ...
[17:00:30.372] result() for MulticoreFuture ... done
[17:00:30.372] result() for MulticoreFuture ...
[17:00:30.372] result() for MulticoreFuture ... done
[17:00:30.372] result() for MulticoreFuture ...
[17:00:30.372] result() for MulticoreFuture ... done
[17:00:30.373]  - Number of value chunks collected: 2
[17:00:30.373] Resolving 2 futures (chunks) ... DONE
[17:00:30.373] Reducing values from 2 chunks ...
[17:00:30.373]  - Number of values collected after concatenation: 5
[17:00:30.373]  - Number of values expected: 5
[17:00:30.373] Reducing values from 2 chunks ... DONE
[17:00:30.373] future_mapply() ... DONE
[17:00:30.374] future_mapply() ...
[17:00:30.378] Number of chunks: 2
[17:00:30.378] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:00:30.378] getGlobalsAndPackagesXApply() ...
[17:00:30.378]  - future.globals: TRUE
[17:00:30.378] getGlobalsAndPackages() ...
[17:00:30.379] Searching for globals...
[17:00:30.380] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:30.380] Searching for globals ... DONE
[17:00:30.380] Resolving globals: FALSE
[17:00:30.381] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:30.381] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:30.381] - globals: [1] ‘FUN’
[17:00:30.381] 
[17:00:30.382] getGlobalsAndPackages() ... DONE
[17:00:30.382]  - globals found/used: [n=1] ‘FUN’
[17:00:30.382]  - needed namespaces: [n=0] 
[17:00:30.382] Finding globals ... DONE
[17:00:30.382] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:30.382] List of 2
[17:00:30.382]  $ ...future.FUN:function (C, k)  
[17:00:30.382]  $ MoreArgs     : NULL
[17:00:30.382]  - attr(*, "where")=List of 2
[17:00:30.382]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:30.382]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:30.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.382]  - attr(*, "resolved")= logi FALSE
[17:00:30.382]  - attr(*, "total_size")= num NA
[17:00:30.385] Packages to be attached in all futures: [n=0] 
[17:00:30.385] getGlobalsAndPackagesXApply() ... DONE
[17:00:30.385] Number of futures (= number of chunks): 2
[17:00:30.385] Launching 2 futures (chunks) ...
[17:00:30.386] Chunk #1 of 2 ...
[17:00:30.386]  - Finding globals in '...' for chunk #1 ...
[17:00:30.386] getGlobalsAndPackages() ...
[17:00:30.386] Searching for globals...
[17:00:30.386] 
[17:00:30.386] Searching for globals ... DONE
[17:00:30.386] - globals: [0] <none>
[17:00:30.386] getGlobalsAndPackages() ... DONE
[17:00:30.387]    + additional globals found: [n=0] 
[17:00:30.387]    + additional namespaces needed: [n=0] 
[17:00:30.387]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:30.387]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:30.387]  - seeds: <none>
[17:00:30.387]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.387] getGlobalsAndPackages() ...
[17:00:30.387] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.387] Resolving globals: FALSE
[17:00:30.388] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:30.388] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:30.389] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.389] 
[17:00:30.389] getGlobalsAndPackages() ... DONE
[17:00:30.389] run() for ‘Future’ ...
[17:00:30.389] - state: ‘created’
[17:00:30.389] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.393] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.396] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.396]   - Field: ‘label’
[17:00:30.396]   - Field: ‘local’
[17:00:30.396]   - Field: ‘owner’
[17:00:30.396]   - Field: ‘envir’
[17:00:30.396]   - Field: ‘workers’
[17:00:30.396]   - Field: ‘packages’
[17:00:30.397]   - Field: ‘gc’
[17:00:30.397]   - Field: ‘job’
[17:00:30.397]   - Field: ‘conditions’
[17:00:30.397]   - Field: ‘expr’
[17:00:30.397]   - Field: ‘uuid’
[17:00:30.397]   - Field: ‘seed’
[17:00:30.397]   - Field: ‘version’
[17:00:30.397]   - Field: ‘result’
[17:00:30.398]   - Field: ‘asynchronous’
[17:00:30.398]   - Field: ‘calls’
[17:00:30.398]   - Field: ‘globals’
[17:00:30.398]   - Field: ‘stdout’
[17:00:30.398]   - Field: ‘earlySignal’
[17:00:30.398]   - Field: ‘lazy’
[17:00:30.398]   - Field: ‘state’
[17:00:30.398] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.399] - Launch lazy future ...
[17:00:30.399] Packages needed by the future expression (n = 0): <none>
[17:00:30.399] Packages needed by future strategies (n = 0): <none>
[17:00:30.400] {
[17:00:30.400]     {
[17:00:30.400]         {
[17:00:30.400]             ...future.startTime <- base::Sys.time()
[17:00:30.400]             {
[17:00:30.400]                 {
[17:00:30.400]                   {
[17:00:30.400]                     {
[17:00:30.400]                       base::local({
[17:00:30.400]                         has_future <- base::requireNamespace("future", 
[17:00:30.400]                           quietly = TRUE)
[17:00:30.400]                         if (has_future) {
[17:00:30.400]                           ns <- base::getNamespace("future")
[17:00:30.400]                           version <- ns[[".package"]][["version"]]
[17:00:30.400]                           if (is.null(version)) 
[17:00:30.400]                             version <- utils::packageVersion("future")
[17:00:30.400]                         }
[17:00:30.400]                         else {
[17:00:30.400]                           version <- NULL
[17:00:30.400]                         }
[17:00:30.400]                         if (!has_future || version < "1.8.0") {
[17:00:30.400]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.400]                             "", base::R.version$version.string), 
[17:00:30.400]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.400]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.400]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.400]                               "release", "version")], collapse = " "), 
[17:00:30.400]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.400]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.400]                             info)
[17:00:30.400]                           info <- base::paste(info, collapse = "; ")
[17:00:30.400]                           if (!has_future) {
[17:00:30.400]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.400]                               info)
[17:00:30.400]                           }
[17:00:30.400]                           else {
[17:00:30.400]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.400]                               info, version)
[17:00:30.400]                           }
[17:00:30.400]                           base::stop(msg)
[17:00:30.400]                         }
[17:00:30.400]                       })
[17:00:30.400]                     }
[17:00:30.400]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.400]                     base::options(mc.cores = 1L)
[17:00:30.400]                   }
[17:00:30.400]                   ...future.strategy.old <- future::plan("list")
[17:00:30.400]                   options(future.plan = NULL)
[17:00:30.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.400]                 }
[17:00:30.400]                 ...future.workdir <- getwd()
[17:00:30.400]             }
[17:00:30.400]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.400]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.400]         }
[17:00:30.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.400]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.400]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.400]             base::names(...future.oldOptions))
[17:00:30.400]     }
[17:00:30.400]     if (FALSE) {
[17:00:30.400]     }
[17:00:30.400]     else {
[17:00:30.400]         if (TRUE) {
[17:00:30.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.400]                 open = "w")
[17:00:30.400]         }
[17:00:30.400]         else {
[17:00:30.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.400]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.400]         }
[17:00:30.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.400]             base::sink(type = "output", split = FALSE)
[17:00:30.400]             base::close(...future.stdout)
[17:00:30.400]         }, add = TRUE)
[17:00:30.400]     }
[17:00:30.400]     ...future.frame <- base::sys.nframe()
[17:00:30.400]     ...future.conditions <- base::list()
[17:00:30.400]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.400]     if (FALSE) {
[17:00:30.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.400]     }
[17:00:30.400]     ...future.result <- base::tryCatch({
[17:00:30.400]         base::withCallingHandlers({
[17:00:30.400]             ...future.value <- base::withVisible(base::local({
[17:00:30.400]                 withCallingHandlers({
[17:00:30.400]                   {
[17:00:30.400]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.400]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.400]                       ...future.globals.maxSize)) {
[17:00:30.400]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.400]                       on.exit(options(oopts), add = TRUE)
[17:00:30.400]                     }
[17:00:30.400]                     {
[17:00:30.400]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.400]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.400]                         USE.NAMES = FALSE)
[17:00:30.400]                       do.call(mapply, args = args)
[17:00:30.400]                     }
[17:00:30.400]                   }
[17:00:30.400]                 }, immediateCondition = function(cond) {
[17:00:30.400]                   save_rds <- function (object, pathname, ...) 
[17:00:30.400]                   {
[17:00:30.400]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.400]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.400]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.400]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.400]                         fi_tmp[["mtime"]])
[17:00:30.400]                     }
[17:00:30.400]                     tryCatch({
[17:00:30.400]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.400]                     }, error = function(ex) {
[17:00:30.400]                       msg <- conditionMessage(ex)
[17:00:30.400]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.400]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.400]                         fi_tmp[["mtime"]], msg)
[17:00:30.400]                       ex$message <- msg
[17:00:30.400]                       stop(ex)
[17:00:30.400]                     })
[17:00:30.400]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.400]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.400]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.400]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.400]                       fi <- file.info(pathname)
[17:00:30.400]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.400]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.400]                         fi[["size"]], fi[["mtime"]])
[17:00:30.400]                       stop(msg)
[17:00:30.400]                     }
[17:00:30.400]                     invisible(pathname)
[17:00:30.400]                   }
[17:00:30.400]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.400]                     rootPath = tempdir()) 
[17:00:30.400]                   {
[17:00:30.400]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.400]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.400]                       tmpdir = path, fileext = ".rds")
[17:00:30.400]                     save_rds(obj, file)
[17:00:30.400]                   }
[17:00:30.400]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.400]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.400]                   {
[17:00:30.400]                     inherits <- base::inherits
[17:00:30.400]                     invokeRestart <- base::invokeRestart
[17:00:30.400]                     is.null <- base::is.null
[17:00:30.400]                     muffled <- FALSE
[17:00:30.400]                     if (inherits(cond, "message")) {
[17:00:30.400]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.400]                       if (muffled) 
[17:00:30.400]                         invokeRestart("muffleMessage")
[17:00:30.400]                     }
[17:00:30.400]                     else if (inherits(cond, "warning")) {
[17:00:30.400]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.400]                       if (muffled) 
[17:00:30.400]                         invokeRestart("muffleWarning")
[17:00:30.400]                     }
[17:00:30.400]                     else if (inherits(cond, "condition")) {
[17:00:30.400]                       if (!is.null(pattern)) {
[17:00:30.400]                         computeRestarts <- base::computeRestarts
[17:00:30.400]                         grepl <- base::grepl
[17:00:30.400]                         restarts <- computeRestarts(cond)
[17:00:30.400]                         for (restart in restarts) {
[17:00:30.400]                           name <- restart$name
[17:00:30.400]                           if (is.null(name)) 
[17:00:30.400]                             next
[17:00:30.400]                           if (!grepl(pattern, name)) 
[17:00:30.400]                             next
[17:00:30.400]                           invokeRestart(restart)
[17:00:30.400]                           muffled <- TRUE
[17:00:30.400]                           break
[17:00:30.400]                         }
[17:00:30.400]                       }
[17:00:30.400]                     }
[17:00:30.400]                     invisible(muffled)
[17:00:30.400]                   }
[17:00:30.400]                   muffleCondition(cond)
[17:00:30.400]                 })
[17:00:30.400]             }))
[17:00:30.400]             future::FutureResult(value = ...future.value$value, 
[17:00:30.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.400]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.400]                     ...future.globalenv.names))
[17:00:30.400]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.400]         }, condition = base::local({
[17:00:30.400]             c <- base::c
[17:00:30.400]             inherits <- base::inherits
[17:00:30.400]             invokeRestart <- base::invokeRestart
[17:00:30.400]             length <- base::length
[17:00:30.400]             list <- base::list
[17:00:30.400]             seq.int <- base::seq.int
[17:00:30.400]             signalCondition <- base::signalCondition
[17:00:30.400]             sys.calls <- base::sys.calls
[17:00:30.400]             `[[` <- base::`[[`
[17:00:30.400]             `+` <- base::`+`
[17:00:30.400]             `<<-` <- base::`<<-`
[17:00:30.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.400]                   3L)]
[17:00:30.400]             }
[17:00:30.400]             function(cond) {
[17:00:30.400]                 is_error <- inherits(cond, "error")
[17:00:30.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.400]                   NULL)
[17:00:30.400]                 if (is_error) {
[17:00:30.400]                   sessionInformation <- function() {
[17:00:30.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.400]                       search = base::search(), system = base::Sys.info())
[17:00:30.400]                   }
[17:00:30.400]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.400]                     cond$call), session = sessionInformation(), 
[17:00:30.400]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.400]                   signalCondition(cond)
[17:00:30.400]                 }
[17:00:30.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.400]                 "immediateCondition"))) {
[17:00:30.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.400]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.400]                   if (TRUE && !signal) {
[17:00:30.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.400]                     {
[17:00:30.400]                       inherits <- base::inherits
[17:00:30.400]                       invokeRestart <- base::invokeRestart
[17:00:30.400]                       is.null <- base::is.null
[17:00:30.400]                       muffled <- FALSE
[17:00:30.400]                       if (inherits(cond, "message")) {
[17:00:30.400]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.400]                         if (muffled) 
[17:00:30.400]                           invokeRestart("muffleMessage")
[17:00:30.400]                       }
[17:00:30.400]                       else if (inherits(cond, "warning")) {
[17:00:30.400]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.400]                         if (muffled) 
[17:00:30.400]                           invokeRestart("muffleWarning")
[17:00:30.400]                       }
[17:00:30.400]                       else if (inherits(cond, "condition")) {
[17:00:30.400]                         if (!is.null(pattern)) {
[17:00:30.400]                           computeRestarts <- base::computeRestarts
[17:00:30.400]                           grepl <- base::grepl
[17:00:30.400]                           restarts <- computeRestarts(cond)
[17:00:30.400]                           for (restart in restarts) {
[17:00:30.400]                             name <- restart$name
[17:00:30.400]                             if (is.null(name)) 
[17:00:30.400]                               next
[17:00:30.400]                             if (!grepl(pattern, name)) 
[17:00:30.400]                               next
[17:00:30.400]                             invokeRestart(restart)
[17:00:30.400]                             muffled <- TRUE
[17:00:30.400]                             break
[17:00:30.400]                           }
[17:00:30.400]                         }
[17:00:30.400]                       }
[17:00:30.400]                       invisible(muffled)
[17:00:30.400]                     }
[17:00:30.400]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.400]                   }
[17:00:30.400]                 }
[17:00:30.400]                 else {
[17:00:30.400]                   if (TRUE) {
[17:00:30.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.400]                     {
[17:00:30.400]                       inherits <- base::inherits
[17:00:30.400]                       invokeRestart <- base::invokeRestart
[17:00:30.400]                       is.null <- base::is.null
[17:00:30.400]                       muffled <- FALSE
[17:00:30.400]                       if (inherits(cond, "message")) {
[17:00:30.400]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.400]                         if (muffled) 
[17:00:30.400]                           invokeRestart("muffleMessage")
[17:00:30.400]                       }
[17:00:30.400]                       else if (inherits(cond, "warning")) {
[17:00:30.400]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.400]                         if (muffled) 
[17:00:30.400]                           invokeRestart("muffleWarning")
[17:00:30.400]                       }
[17:00:30.400]                       else if (inherits(cond, "condition")) {
[17:00:30.400]                         if (!is.null(pattern)) {
[17:00:30.400]                           computeRestarts <- base::computeRestarts
[17:00:30.400]                           grepl <- base::grepl
[17:00:30.400]                           restarts <- computeRestarts(cond)
[17:00:30.400]                           for (restart in restarts) {
[17:00:30.400]                             name <- restart$name
[17:00:30.400]                             if (is.null(name)) 
[17:00:30.400]                               next
[17:00:30.400]                             if (!grepl(pattern, name)) 
[17:00:30.400]                               next
[17:00:30.400]                             invokeRestart(restart)
[17:00:30.400]                             muffled <- TRUE
[17:00:30.400]                             break
[17:00:30.400]                           }
[17:00:30.400]                         }
[17:00:30.400]                       }
[17:00:30.400]                       invisible(muffled)
[17:00:30.400]                     }
[17:00:30.400]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.400]                   }
[17:00:30.400]                 }
[17:00:30.400]             }
[17:00:30.400]         }))
[17:00:30.400]     }, error = function(ex) {
[17:00:30.400]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.400]                 ...future.rng), started = ...future.startTime, 
[17:00:30.400]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.400]             version = "1.8"), class = "FutureResult")
[17:00:30.400]     }, finally = {
[17:00:30.400]         if (!identical(...future.workdir, getwd())) 
[17:00:30.400]             setwd(...future.workdir)
[17:00:30.400]         {
[17:00:30.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.400]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.400]             }
[17:00:30.400]             base::options(...future.oldOptions)
[17:00:30.400]             if (.Platform$OS.type == "windows") {
[17:00:30.400]                 old_names <- names(...future.oldEnvVars)
[17:00:30.400]                 envs <- base::Sys.getenv()
[17:00:30.400]                 names <- names(envs)
[17:00:30.400]                 common <- intersect(names, old_names)
[17:00:30.400]                 added <- setdiff(names, old_names)
[17:00:30.400]                 removed <- setdiff(old_names, names)
[17:00:30.400]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.400]                   envs[common]]
[17:00:30.400]                 NAMES <- toupper(changed)
[17:00:30.400]                 args <- list()
[17:00:30.400]                 for (kk in seq_along(NAMES)) {
[17:00:30.400]                   name <- changed[[kk]]
[17:00:30.400]                   NAME <- NAMES[[kk]]
[17:00:30.400]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.400]                     next
[17:00:30.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.400]                 }
[17:00:30.400]                 NAMES <- toupper(added)
[17:00:30.400]                 for (kk in seq_along(NAMES)) {
[17:00:30.400]                   name <- added[[kk]]
[17:00:30.400]                   NAME <- NAMES[[kk]]
[17:00:30.400]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.400]                     next
[17:00:30.400]                   args[[name]] <- ""
[17:00:30.400]                 }
[17:00:30.400]                 NAMES <- toupper(removed)
[17:00:30.400]                 for (kk in seq_along(NAMES)) {
[17:00:30.400]                   name <- removed[[kk]]
[17:00:30.400]                   NAME <- NAMES[[kk]]
[17:00:30.400]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.400]                     next
[17:00:30.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.400]                 }
[17:00:30.400]                 if (length(args) > 0) 
[17:00:30.400]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.400]             }
[17:00:30.400]             else {
[17:00:30.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.400]             }
[17:00:30.400]             {
[17:00:30.400]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.400]                   0L) {
[17:00:30.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.400]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.400]                   base::options(opts)
[17:00:30.400]                 }
[17:00:30.400]                 {
[17:00:30.400]                   {
[17:00:30.400]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.400]                     NULL
[17:00:30.400]                   }
[17:00:30.400]                   options(future.plan = NULL)
[17:00:30.400]                   if (is.na(NA_character_)) 
[17:00:30.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.400]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.400]                     .init = FALSE)
[17:00:30.400]                 }
[17:00:30.400]             }
[17:00:30.400]         }
[17:00:30.400]     })
[17:00:30.400]     if (TRUE) {
[17:00:30.400]         base::sink(type = "output", split = FALSE)
[17:00:30.400]         if (TRUE) {
[17:00:30.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.400]         }
[17:00:30.400]         else {
[17:00:30.400]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.400]         }
[17:00:30.400]         base::close(...future.stdout)
[17:00:30.400]         ...future.stdout <- NULL
[17:00:30.400]     }
[17:00:30.400]     ...future.result$conditions <- ...future.conditions
[17:00:30.400]     ...future.result$finished <- base::Sys.time()
[17:00:30.400]     ...future.result
[17:00:30.400] }
[17:00:30.402] assign_globals() ...
[17:00:30.402] List of 5
[17:00:30.402]  $ ...future.FUN            :function (C, k)  
[17:00:30.402]  $ MoreArgs                 : NULL
[17:00:30.402]  $ ...future.elements_ii    :List of 2
[17:00:30.402]   ..$ :List of 2
[17:00:30.402]   .. ..$ : chr "E"
[17:00:30.402]   .. ..$ : chr "D"
[17:00:30.402]   ..$ :List of 2
[17:00:30.402]   .. ..$ : int 1
[17:00:30.402]   .. ..$ : int 2
[17:00:30.402]  $ ...future.seeds_ii       : NULL
[17:00:30.402]  $ ...future.globals.maxSize: NULL
[17:00:30.402]  - attr(*, "where")=List of 5
[17:00:30.402]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.402]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.402]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.402]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.402]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.402]  - attr(*, "resolved")= logi FALSE
[17:00:30.402]  - attr(*, "total_size")= num 3656
[17:00:30.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.402]  - attr(*, "already-done")= logi TRUE
[17:00:30.408] - reassign environment for ‘...future.FUN’
[17:00:30.408] - copied ‘...future.FUN’ to environment
[17:00:30.409] - copied ‘MoreArgs’ to environment
[17:00:30.409] - copied ‘...future.elements_ii’ to environment
[17:00:30.409] - copied ‘...future.seeds_ii’ to environment
[17:00:30.409] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.409] assign_globals() ... done
[17:00:30.409] requestCore(): workers = 2
[17:00:30.411] MulticoreFuture started
[17:00:30.412] - Launch lazy future ... done
[17:00:30.412] run() for ‘MulticoreFuture’ ... done
[17:00:30.412] Created future:
[17:00:30.412] plan(): Setting new future strategy stack:
[17:00:30.413] List of future strategies:
[17:00:30.413] 1. sequential:
[17:00:30.413]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.413]    - tweaked: FALSE
[17:00:30.413]    - call: NULL
[17:00:30.414] plan(): nbrOfWorkers() = 1
[17:00:30.416] plan(): Setting new future strategy stack:
[17:00:30.416] List of future strategies:
[17:00:30.416] 1. multicore:
[17:00:30.416]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.416]    - tweaked: FALSE
[17:00:30.416]    - call: plan(strategy)
[17:00:30.421] plan(): nbrOfWorkers() = 2
[17:00:30.412] MulticoreFuture:
[17:00:30.412] Label: ‘future_mapply-1’
[17:00:30.412] Expression:
[17:00:30.412] {
[17:00:30.412]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.412]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.412]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.412]         on.exit(options(oopts), add = TRUE)
[17:00:30.412]     }
[17:00:30.412]     {
[17:00:30.412]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.412]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.412]         do.call(mapply, args = args)
[17:00:30.412]     }
[17:00:30.412] }
[17:00:30.412] Lazy evaluation: FALSE
[17:00:30.412] Asynchronous evaluation: TRUE
[17:00:30.412] Local evaluation: TRUE
[17:00:30.412] Environment: R_GlobalEnv
[17:00:30.412] Capture standard output: TRUE
[17:00:30.412] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.412] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.412] Packages: <none>
[17:00:30.412] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.412] Resolved: TRUE
[17:00:30.412] Value: <not collected>
[17:00:30.412] Conditions captured: <none>
[17:00:30.412] Early signaling: FALSE
[17:00:30.412] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.412] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.422] Chunk #1 of 2 ... DONE
[17:00:30.422] Chunk #2 of 2 ...
[17:00:30.422]  - Finding globals in '...' for chunk #2 ...
[17:00:30.423] getGlobalsAndPackages() ...
[17:00:30.423] Searching for globals...
[17:00:30.423] 
[17:00:30.423] Searching for globals ... DONE
[17:00:30.424] - globals: [0] <none>
[17:00:30.424] getGlobalsAndPackages() ... DONE
[17:00:30.424]    + additional globals found: [n=0] 
[17:00:30.424]    + additional namespaces needed: [n=0] 
[17:00:30.424]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:30.424]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:30.424]  - seeds: <none>
[17:00:30.424]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.425] getGlobalsAndPackages() ...
[17:00:30.425] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.425] Resolving globals: FALSE
[17:00:30.426] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:00:30.427] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:30.427] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.427] 
[17:00:30.427] getGlobalsAndPackages() ... DONE
[17:00:30.428] run() for ‘Future’ ...
[17:00:30.428] - state: ‘created’
[17:00:30.428] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.433] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.433] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.434]   - Field: ‘label’
[17:00:30.434]   - Field: ‘local’
[17:00:30.434]   - Field: ‘owner’
[17:00:30.434]   - Field: ‘envir’
[17:00:30.434]   - Field: ‘workers’
[17:00:30.435]   - Field: ‘packages’
[17:00:30.435]   - Field: ‘gc’
[17:00:30.435]   - Field: ‘job’
[17:00:30.435]   - Field: ‘conditions’
[17:00:30.435]   - Field: ‘expr’
[17:00:30.435]   - Field: ‘uuid’
[17:00:30.436]   - Field: ‘seed’
[17:00:30.436]   - Field: ‘version’
[17:00:30.436]   - Field: ‘result’
[17:00:30.436]   - Field: ‘asynchronous’
[17:00:30.436]   - Field: ‘calls’
[17:00:30.436]   - Field: ‘globals’
[17:00:30.436]   - Field: ‘stdout’
[17:00:30.437]   - Field: ‘earlySignal’
[17:00:30.437]   - Field: ‘lazy’
[17:00:30.437]   - Field: ‘state’
[17:00:30.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.437] - Launch lazy future ...
[17:00:30.438] Packages needed by the future expression (n = 0): <none>
[17:00:30.441] Packages needed by future strategies (n = 0): <none>
[17:00:30.443] {
[17:00:30.443]     {
[17:00:30.443]         {
[17:00:30.443]             ...future.startTime <- base::Sys.time()
[17:00:30.443]             {
[17:00:30.443]                 {
[17:00:30.443]                   {
[17:00:30.443]                     {
[17:00:30.443]                       base::local({
[17:00:30.443]                         has_future <- base::requireNamespace("future", 
[17:00:30.443]                           quietly = TRUE)
[17:00:30.443]                         if (has_future) {
[17:00:30.443]                           ns <- base::getNamespace("future")
[17:00:30.443]                           version <- ns[[".package"]][["version"]]
[17:00:30.443]                           if (is.null(version)) 
[17:00:30.443]                             version <- utils::packageVersion("future")
[17:00:30.443]                         }
[17:00:30.443]                         else {
[17:00:30.443]                           version <- NULL
[17:00:30.443]                         }
[17:00:30.443]                         if (!has_future || version < "1.8.0") {
[17:00:30.443]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.443]                             "", base::R.version$version.string), 
[17:00:30.443]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.443]                               "release", "version")], collapse = " "), 
[17:00:30.443]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.443]                             info)
[17:00:30.443]                           info <- base::paste(info, collapse = "; ")
[17:00:30.443]                           if (!has_future) {
[17:00:30.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.443]                               info)
[17:00:30.443]                           }
[17:00:30.443]                           else {
[17:00:30.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.443]                               info, version)
[17:00:30.443]                           }
[17:00:30.443]                           base::stop(msg)
[17:00:30.443]                         }
[17:00:30.443]                       })
[17:00:30.443]                     }
[17:00:30.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.443]                     base::options(mc.cores = 1L)
[17:00:30.443]                   }
[17:00:30.443]                   ...future.strategy.old <- future::plan("list")
[17:00:30.443]                   options(future.plan = NULL)
[17:00:30.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.443]                 }
[17:00:30.443]                 ...future.workdir <- getwd()
[17:00:30.443]             }
[17:00:30.443]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.443]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.443]         }
[17:00:30.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.443]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.443]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.443]             base::names(...future.oldOptions))
[17:00:30.443]     }
[17:00:30.443]     if (FALSE) {
[17:00:30.443]     }
[17:00:30.443]     else {
[17:00:30.443]         if (TRUE) {
[17:00:30.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.443]                 open = "w")
[17:00:30.443]         }
[17:00:30.443]         else {
[17:00:30.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.443]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.443]         }
[17:00:30.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.443]             base::sink(type = "output", split = FALSE)
[17:00:30.443]             base::close(...future.stdout)
[17:00:30.443]         }, add = TRUE)
[17:00:30.443]     }
[17:00:30.443]     ...future.frame <- base::sys.nframe()
[17:00:30.443]     ...future.conditions <- base::list()
[17:00:30.443]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.443]     if (FALSE) {
[17:00:30.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.443]     }
[17:00:30.443]     ...future.result <- base::tryCatch({
[17:00:30.443]         base::withCallingHandlers({
[17:00:30.443]             ...future.value <- base::withVisible(base::local({
[17:00:30.443]                 withCallingHandlers({
[17:00:30.443]                   {
[17:00:30.443]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.443]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.443]                       ...future.globals.maxSize)) {
[17:00:30.443]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.443]                       on.exit(options(oopts), add = TRUE)
[17:00:30.443]                     }
[17:00:30.443]                     {
[17:00:30.443]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.443]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.443]                         USE.NAMES = FALSE)
[17:00:30.443]                       do.call(mapply, args = args)
[17:00:30.443]                     }
[17:00:30.443]                   }
[17:00:30.443]                 }, immediateCondition = function(cond) {
[17:00:30.443]                   save_rds <- function (object, pathname, ...) 
[17:00:30.443]                   {
[17:00:30.443]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.443]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.443]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.443]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.443]                         fi_tmp[["mtime"]])
[17:00:30.443]                     }
[17:00:30.443]                     tryCatch({
[17:00:30.443]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.443]                     }, error = function(ex) {
[17:00:30.443]                       msg <- conditionMessage(ex)
[17:00:30.443]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.443]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.443]                         fi_tmp[["mtime"]], msg)
[17:00:30.443]                       ex$message <- msg
[17:00:30.443]                       stop(ex)
[17:00:30.443]                     })
[17:00:30.443]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.443]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.443]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.443]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.443]                       fi <- file.info(pathname)
[17:00:30.443]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.443]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.443]                         fi[["size"]], fi[["mtime"]])
[17:00:30.443]                       stop(msg)
[17:00:30.443]                     }
[17:00:30.443]                     invisible(pathname)
[17:00:30.443]                   }
[17:00:30.443]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.443]                     rootPath = tempdir()) 
[17:00:30.443]                   {
[17:00:30.443]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.443]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.443]                       tmpdir = path, fileext = ".rds")
[17:00:30.443]                     save_rds(obj, file)
[17:00:30.443]                   }
[17:00:30.443]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.443]                   {
[17:00:30.443]                     inherits <- base::inherits
[17:00:30.443]                     invokeRestart <- base::invokeRestart
[17:00:30.443]                     is.null <- base::is.null
[17:00:30.443]                     muffled <- FALSE
[17:00:30.443]                     if (inherits(cond, "message")) {
[17:00:30.443]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.443]                       if (muffled) 
[17:00:30.443]                         invokeRestart("muffleMessage")
[17:00:30.443]                     }
[17:00:30.443]                     else if (inherits(cond, "warning")) {
[17:00:30.443]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.443]                       if (muffled) 
[17:00:30.443]                         invokeRestart("muffleWarning")
[17:00:30.443]                     }
[17:00:30.443]                     else if (inherits(cond, "condition")) {
[17:00:30.443]                       if (!is.null(pattern)) {
[17:00:30.443]                         computeRestarts <- base::computeRestarts
[17:00:30.443]                         grepl <- base::grepl
[17:00:30.443]                         restarts <- computeRestarts(cond)
[17:00:30.443]                         for (restart in restarts) {
[17:00:30.443]                           name <- restart$name
[17:00:30.443]                           if (is.null(name)) 
[17:00:30.443]                             next
[17:00:30.443]                           if (!grepl(pattern, name)) 
[17:00:30.443]                             next
[17:00:30.443]                           invokeRestart(restart)
[17:00:30.443]                           muffled <- TRUE
[17:00:30.443]                           break
[17:00:30.443]                         }
[17:00:30.443]                       }
[17:00:30.443]                     }
[17:00:30.443]                     invisible(muffled)
[17:00:30.443]                   }
[17:00:30.443]                   muffleCondition(cond)
[17:00:30.443]                 })
[17:00:30.443]             }))
[17:00:30.443]             future::FutureResult(value = ...future.value$value, 
[17:00:30.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.443]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.443]                     ...future.globalenv.names))
[17:00:30.443]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.443]         }, condition = base::local({
[17:00:30.443]             c <- base::c
[17:00:30.443]             inherits <- base::inherits
[17:00:30.443]             invokeRestart <- base::invokeRestart
[17:00:30.443]             length <- base::length
[17:00:30.443]             list <- base::list
[17:00:30.443]             seq.int <- base::seq.int
[17:00:30.443]             signalCondition <- base::signalCondition
[17:00:30.443]             sys.calls <- base::sys.calls
[17:00:30.443]             `[[` <- base::`[[`
[17:00:30.443]             `+` <- base::`+`
[17:00:30.443]             `<<-` <- base::`<<-`
[17:00:30.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.443]                   3L)]
[17:00:30.443]             }
[17:00:30.443]             function(cond) {
[17:00:30.443]                 is_error <- inherits(cond, "error")
[17:00:30.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.443]                   NULL)
[17:00:30.443]                 if (is_error) {
[17:00:30.443]                   sessionInformation <- function() {
[17:00:30.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.443]                       search = base::search(), system = base::Sys.info())
[17:00:30.443]                   }
[17:00:30.443]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.443]                     cond$call), session = sessionInformation(), 
[17:00:30.443]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.443]                   signalCondition(cond)
[17:00:30.443]                 }
[17:00:30.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.443]                 "immediateCondition"))) {
[17:00:30.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.443]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.443]                   if (TRUE && !signal) {
[17:00:30.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.443]                     {
[17:00:30.443]                       inherits <- base::inherits
[17:00:30.443]                       invokeRestart <- base::invokeRestart
[17:00:30.443]                       is.null <- base::is.null
[17:00:30.443]                       muffled <- FALSE
[17:00:30.443]                       if (inherits(cond, "message")) {
[17:00:30.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.443]                         if (muffled) 
[17:00:30.443]                           invokeRestart("muffleMessage")
[17:00:30.443]                       }
[17:00:30.443]                       else if (inherits(cond, "warning")) {
[17:00:30.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.443]                         if (muffled) 
[17:00:30.443]                           invokeRestart("muffleWarning")
[17:00:30.443]                       }
[17:00:30.443]                       else if (inherits(cond, "condition")) {
[17:00:30.443]                         if (!is.null(pattern)) {
[17:00:30.443]                           computeRestarts <- base::computeRestarts
[17:00:30.443]                           grepl <- base::grepl
[17:00:30.443]                           restarts <- computeRestarts(cond)
[17:00:30.443]                           for (restart in restarts) {
[17:00:30.443]                             name <- restart$name
[17:00:30.443]                             if (is.null(name)) 
[17:00:30.443]                               next
[17:00:30.443]                             if (!grepl(pattern, name)) 
[17:00:30.443]                               next
[17:00:30.443]                             invokeRestart(restart)
[17:00:30.443]                             muffled <- TRUE
[17:00:30.443]                             break
[17:00:30.443]                           }
[17:00:30.443]                         }
[17:00:30.443]                       }
[17:00:30.443]                       invisible(muffled)
[17:00:30.443]                     }
[17:00:30.443]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.443]                   }
[17:00:30.443]                 }
[17:00:30.443]                 else {
[17:00:30.443]                   if (TRUE) {
[17:00:30.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.443]                     {
[17:00:30.443]                       inherits <- base::inherits
[17:00:30.443]                       invokeRestart <- base::invokeRestart
[17:00:30.443]                       is.null <- base::is.null
[17:00:30.443]                       muffled <- FALSE
[17:00:30.443]                       if (inherits(cond, "message")) {
[17:00:30.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.443]                         if (muffled) 
[17:00:30.443]                           invokeRestart("muffleMessage")
[17:00:30.443]                       }
[17:00:30.443]                       else if (inherits(cond, "warning")) {
[17:00:30.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.443]                         if (muffled) 
[17:00:30.443]                           invokeRestart("muffleWarning")
[17:00:30.443]                       }
[17:00:30.443]                       else if (inherits(cond, "condition")) {
[17:00:30.443]                         if (!is.null(pattern)) {
[17:00:30.443]                           computeRestarts <- base::computeRestarts
[17:00:30.443]                           grepl <- base::grepl
[17:00:30.443]                           restarts <- computeRestarts(cond)
[17:00:30.443]                           for (restart in restarts) {
[17:00:30.443]                             name <- restart$name
[17:00:30.443]                             if (is.null(name)) 
[17:00:30.443]                               next
[17:00:30.443]                             if (!grepl(pattern, name)) 
[17:00:30.443]                               next
[17:00:30.443]                             invokeRestart(restart)
[17:00:30.443]                             muffled <- TRUE
[17:00:30.443]                             break
[17:00:30.443]                           }
[17:00:30.443]                         }
[17:00:30.443]                       }
[17:00:30.443]                       invisible(muffled)
[17:00:30.443]                     }
[17:00:30.443]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.443]                   }
[17:00:30.443]                 }
[17:00:30.443]             }
[17:00:30.443]         }))
[17:00:30.443]     }, error = function(ex) {
[17:00:30.443]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.443]                 ...future.rng), started = ...future.startTime, 
[17:00:30.443]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.443]             version = "1.8"), class = "FutureResult")
[17:00:30.443]     }, finally = {
[17:00:30.443]         if (!identical(...future.workdir, getwd())) 
[17:00:30.443]             setwd(...future.workdir)
[17:00:30.443]         {
[17:00:30.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.443]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.443]             }
[17:00:30.443]             base::options(...future.oldOptions)
[17:00:30.443]             if (.Platform$OS.type == "windows") {
[17:00:30.443]                 old_names <- names(...future.oldEnvVars)
[17:00:30.443]                 envs <- base::Sys.getenv()
[17:00:30.443]                 names <- names(envs)
[17:00:30.443]                 common <- intersect(names, old_names)
[17:00:30.443]                 added <- setdiff(names, old_names)
[17:00:30.443]                 removed <- setdiff(old_names, names)
[17:00:30.443]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.443]                   envs[common]]
[17:00:30.443]                 NAMES <- toupper(changed)
[17:00:30.443]                 args <- list()
[17:00:30.443]                 for (kk in seq_along(NAMES)) {
[17:00:30.443]                   name <- changed[[kk]]
[17:00:30.443]                   NAME <- NAMES[[kk]]
[17:00:30.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.443]                     next
[17:00:30.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.443]                 }
[17:00:30.443]                 NAMES <- toupper(added)
[17:00:30.443]                 for (kk in seq_along(NAMES)) {
[17:00:30.443]                   name <- added[[kk]]
[17:00:30.443]                   NAME <- NAMES[[kk]]
[17:00:30.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.443]                     next
[17:00:30.443]                   args[[name]] <- ""
[17:00:30.443]                 }
[17:00:30.443]                 NAMES <- toupper(removed)
[17:00:30.443]                 for (kk in seq_along(NAMES)) {
[17:00:30.443]                   name <- removed[[kk]]
[17:00:30.443]                   NAME <- NAMES[[kk]]
[17:00:30.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.443]                     next
[17:00:30.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.443]                 }
[17:00:30.443]                 if (length(args) > 0) 
[17:00:30.443]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.443]             }
[17:00:30.443]             else {
[17:00:30.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.443]             }
[17:00:30.443]             {
[17:00:30.443]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.443]                   0L) {
[17:00:30.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.443]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.443]                   base::options(opts)
[17:00:30.443]                 }
[17:00:30.443]                 {
[17:00:30.443]                   {
[17:00:30.443]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.443]                     NULL
[17:00:30.443]                   }
[17:00:30.443]                   options(future.plan = NULL)
[17:00:30.443]                   if (is.na(NA_character_)) 
[17:00:30.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.443]                     .init = FALSE)
[17:00:30.443]                 }
[17:00:30.443]             }
[17:00:30.443]         }
[17:00:30.443]     })
[17:00:30.443]     if (TRUE) {
[17:00:30.443]         base::sink(type = "output", split = FALSE)
[17:00:30.443]         if (TRUE) {
[17:00:30.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.443]         }
[17:00:30.443]         else {
[17:00:30.443]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.443]         }
[17:00:30.443]         base::close(...future.stdout)
[17:00:30.443]         ...future.stdout <- NULL
[17:00:30.443]     }
[17:00:30.443]     ...future.result$conditions <- ...future.conditions
[17:00:30.443]     ...future.result$finished <- base::Sys.time()
[17:00:30.443]     ...future.result
[17:00:30.443] }
[17:00:30.446] assign_globals() ...
[17:00:30.447] List of 5
[17:00:30.447]  $ ...future.FUN            :function (C, k)  
[17:00:30.447]  $ MoreArgs                 : NULL
[17:00:30.447]  $ ...future.elements_ii    :List of 2
[17:00:30.447]   ..$ :List of 3
[17:00:30.447]   .. ..$ : chr "C"
[17:00:30.447]   .. ..$ : chr "B"
[17:00:30.447]   .. ..$ : chr "A"
[17:00:30.447]   ..$ :List of 3
[17:00:30.447]   .. ..$ : int 3
[17:00:30.447]   .. ..$ : int 4
[17:00:30.447]   .. ..$ : int 5
[17:00:30.447]  $ ...future.seeds_ii       : NULL
[17:00:30.447]  $ ...future.globals.maxSize: NULL
[17:00:30.447]  - attr(*, "where")=List of 5
[17:00:30.447]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.447]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.447]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.447]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.447]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.447]  - attr(*, "resolved")= logi FALSE
[17:00:30.447]  - attr(*, "total_size")= num 3824
[17:00:30.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.447]  - attr(*, "already-done")= logi TRUE
[17:00:30.458] - reassign environment for ‘...future.FUN’
[17:00:30.458] - copied ‘...future.FUN’ to environment
[17:00:30.458] - copied ‘MoreArgs’ to environment
[17:00:30.458] - copied ‘...future.elements_ii’ to environment
[17:00:30.458] - copied ‘...future.seeds_ii’ to environment
[17:00:30.459] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.459] assign_globals() ... done
[17:00:30.459] requestCore(): workers = 2
[17:00:30.461] MulticoreFuture started
[17:00:30.462] - Launch lazy future ... done
[17:00:30.462] run() for ‘MulticoreFuture’ ... done
[17:00:30.462] Created future:
[17:00:30.463] plan(): Setting new future strategy stack:
[17:00:30.463] List of future strategies:
[17:00:30.463] 1. sequential:
[17:00:30.463]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.463]    - tweaked: FALSE
[17:00:30.463]    - call: NULL
[17:00:30.464] plan(): nbrOfWorkers() = 1
[17:00:30.466] plan(): Setting new future strategy stack:
[17:00:30.466] List of future strategies:
[17:00:30.466] 1. multicore:
[17:00:30.466]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.466]    - tweaked: FALSE
[17:00:30.466]    - call: plan(strategy)
[17:00:30.472] plan(): nbrOfWorkers() = 2
[17:00:30.463] MulticoreFuture:
[17:00:30.463] Label: ‘future_mapply-2’
[17:00:30.463] Expression:
[17:00:30.463] {
[17:00:30.463]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.463]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.463]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.463]         on.exit(options(oopts), add = TRUE)
[17:00:30.463]     }
[17:00:30.463]     {
[17:00:30.463]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.463]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.463]         do.call(mapply, args = args)
[17:00:30.463]     }
[17:00:30.463] }
[17:00:30.463] Lazy evaluation: FALSE
[17:00:30.463] Asynchronous evaluation: TRUE
[17:00:30.463] Local evaluation: TRUE
[17:00:30.463] Environment: R_GlobalEnv
[17:00:30.463] Capture standard output: TRUE
[17:00:30.463] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.463] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.463] Packages: <none>
[17:00:30.463] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.463] Resolved: TRUE
[17:00:30.463] Value: <not collected>
[17:00:30.463] Conditions captured: <none>
[17:00:30.463] Early signaling: FALSE
[17:00:30.463] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.463] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.473] Chunk #2 of 2 ... DONE
[17:00:30.473] Launching 2 futures (chunks) ... DONE
[17:00:30.473] Resolving 2 futures (chunks) ...
[17:00:30.473] resolve() on list ...
[17:00:30.474]  recursive: 0
[17:00:30.474]  length: 2
[17:00:30.474] 
[17:00:30.474] Future #1
[17:00:30.474] result() for MulticoreFuture ...
[17:00:30.475] result() for MulticoreFuture ...
[17:00:30.476] result() for MulticoreFuture ... done
[17:00:30.476] result() for MulticoreFuture ... done
[17:00:30.476] result() for MulticoreFuture ...
[17:00:30.476] result() for MulticoreFuture ... done
[17:00:30.476] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:30.476] - nx: 2
[17:00:30.476] - relay: TRUE
[17:00:30.477] - stdout: TRUE
[17:00:30.477] - signal: TRUE
[17:00:30.477] - resignal: FALSE
[17:00:30.477] - force: TRUE
[17:00:30.477] - relayed: [n=2] FALSE, FALSE
[17:00:30.477] - queued futures: [n=2] FALSE, FALSE
[17:00:30.477]  - until=1
[17:00:30.478]  - relaying element #1
[17:00:30.478] result() for MulticoreFuture ...
[17:00:30.478] result() for MulticoreFuture ... done
[17:00:30.478] result() for MulticoreFuture ...
[17:00:30.478] result() for MulticoreFuture ... done
[17:00:30.478] result() for MulticoreFuture ...
[17:00:30.479] result() for MulticoreFuture ... done
[17:00:30.479] result() for MulticoreFuture ...
[17:00:30.479] result() for MulticoreFuture ... done
[17:00:30.479] - relayed: [n=2] TRUE, FALSE
[17:00:30.479] - queued futures: [n=2] TRUE, FALSE
[17:00:30.479] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:30.480]  length: 1 (resolved future 1)
[17:00:30.480] Future #2
[17:00:30.480] result() for MulticoreFuture ...
[17:00:30.481] result() for MulticoreFuture ...
[17:00:30.481] result() for MulticoreFuture ... done
[17:00:30.481] result() for MulticoreFuture ... done
[17:00:30.481] result() for MulticoreFuture ...
[17:00:30.482] result() for MulticoreFuture ... done
[17:00:30.482] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:30.482] - nx: 2
[17:00:30.482] - relay: TRUE
[17:00:30.482] - stdout: TRUE
[17:00:30.482] - signal: TRUE
[17:00:30.482] - resignal: FALSE
[17:00:30.483] - force: TRUE
[17:00:30.483] - relayed: [n=2] TRUE, FALSE
[17:00:30.483] - queued futures: [n=2] TRUE, FALSE
[17:00:30.483]  - until=2
[17:00:30.483]  - relaying element #2
[17:00:30.483] result() for MulticoreFuture ...
[17:00:30.483] result() for MulticoreFuture ... done
[17:00:30.483] result() for MulticoreFuture ...
[17:00:30.484] result() for MulticoreFuture ... done
[17:00:30.484] result() for MulticoreFuture ...
[17:00:30.484] result() for MulticoreFuture ... done
[17:00:30.484] result() for MulticoreFuture ...
[17:00:30.484] result() for MulticoreFuture ... done
[17:00:30.484] - relayed: [n=2] TRUE, TRUE
[17:00:30.484] - queued futures: [n=2] TRUE, TRUE
[17:00:30.484] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:30.485]  length: 0 (resolved future 2)
[17:00:30.485] Relaying remaining futures
[17:00:30.485] signalConditionsASAP(NULL, pos=0) ...
[17:00:30.485] - nx: 2
[17:00:30.485] - relay: TRUE
[17:00:30.485] - stdout: TRUE
[17:00:30.485] - signal: TRUE
[17:00:30.485] - resignal: FALSE
[17:00:30.485] - force: TRUE
[17:00:30.486] - relayed: [n=2] TRUE, TRUE
[17:00:30.486] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:30.486] - relayed: [n=2] TRUE, TRUE
[17:00:30.486] - queued futures: [n=2] TRUE, TRUE
[17:00:30.486] signalConditionsASAP(NULL, pos=0) ... done
[17:00:30.486] resolve() on list ... DONE
[17:00:30.486] result() for MulticoreFuture ...
[17:00:30.486] result() for MulticoreFuture ... done
[17:00:30.487] result() for MulticoreFuture ...
[17:00:30.487] result() for MulticoreFuture ... done
[17:00:30.487] result() for MulticoreFuture ...
[17:00:30.487] result() for MulticoreFuture ... done
[17:00:30.487] result() for MulticoreFuture ...
[17:00:30.487] result() for MulticoreFuture ... done
[17:00:30.487]  - Number of value chunks collected: 2
[17:00:30.490] Resolving 2 futures (chunks) ... DONE
[17:00:30.491] Reducing values from 2 chunks ...
[17:00:30.491]  - Number of values collected after concatenation: 5
[17:00:30.491]  - Number of values expected: 5
[17:00:30.491] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:00:30.491] Reducing values from 2 chunks ... DONE
[17:00:30.492] future_mapply() ... DONE
[17:00:30.492] future_mapply() ...
[17:00:30.497] Number of chunks: 2
[17:00:30.497] getGlobalsAndPackagesXApply() ...
[17:00:30.497]  - future.globals: TRUE
[17:00:30.497] getGlobalsAndPackages() ...
[17:00:30.498] Searching for globals...
[17:00:30.500] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:30.500] Searching for globals ... DONE
[17:00:30.500] Resolving globals: FALSE
[17:00:30.501] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:30.501] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:30.501] - globals: [1] ‘FUN’
[17:00:30.501] 
[17:00:30.501] getGlobalsAndPackages() ... DONE
[17:00:30.502]  - globals found/used: [n=1] ‘FUN’
[17:00:30.502]  - needed namespaces: [n=0] 
[17:00:30.502] Finding globals ... DONE
[17:00:30.502] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:30.502] List of 2
[17:00:30.502]  $ ...future.FUN:function (C, k)  
[17:00:30.502]  $ MoreArgs     : list()
[17:00:30.502]  - attr(*, "where")=List of 2
[17:00:30.502]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:30.502]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:30.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.502]  - attr(*, "resolved")= logi FALSE
[17:00:30.502]  - attr(*, "total_size")= num NA
[17:00:30.505] Packages to be attached in all futures: [n=0] 
[17:00:30.505] getGlobalsAndPackagesXApply() ... DONE
[17:00:30.505] Number of futures (= number of chunks): 2
[17:00:30.506] Launching 2 futures (chunks) ...
[17:00:30.506] Chunk #1 of 2 ...
[17:00:30.506]  - Finding globals in '...' for chunk #1 ...
[17:00:30.506] getGlobalsAndPackages() ...
[17:00:30.506] Searching for globals...
[17:00:30.506] 
[17:00:30.506] Searching for globals ... DONE
[17:00:30.506] - globals: [0] <none>
[17:00:30.507] getGlobalsAndPackages() ... DONE
[17:00:30.507]    + additional globals found: [n=0] 
[17:00:30.507]    + additional namespaces needed: [n=0] 
[17:00:30.507]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:30.507]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:30.507]  - seeds: <none>
[17:00:30.507]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.507] getGlobalsAndPackages() ...
[17:00:30.507] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.508] Resolving globals: FALSE
[17:00:30.508] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:30.508] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:30.509] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.509] 
[17:00:30.509] getGlobalsAndPackages() ... DONE
[17:00:30.509] run() for ‘Future’ ...
[17:00:30.509] - state: ‘created’
[17:00:30.509] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.513] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.513] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.514]   - Field: ‘label’
[17:00:30.514]   - Field: ‘local’
[17:00:30.514]   - Field: ‘owner’
[17:00:30.514]   - Field: ‘envir’
[17:00:30.514]   - Field: ‘workers’
[17:00:30.514]   - Field: ‘packages’
[17:00:30.514]   - Field: ‘gc’
[17:00:30.514]   - Field: ‘job’
[17:00:30.514]   - Field: ‘conditions’
[17:00:30.515]   - Field: ‘expr’
[17:00:30.515]   - Field: ‘uuid’
[17:00:30.515]   - Field: ‘seed’
[17:00:30.515]   - Field: ‘version’
[17:00:30.515]   - Field: ‘result’
[17:00:30.515]   - Field: ‘asynchronous’
[17:00:30.515]   - Field: ‘calls’
[17:00:30.515]   - Field: ‘globals’
[17:00:30.515]   - Field: ‘stdout’
[17:00:30.515]   - Field: ‘earlySignal’
[17:00:30.515]   - Field: ‘lazy’
[17:00:30.516]   - Field: ‘state’
[17:00:30.516] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.516] - Launch lazy future ...
[17:00:30.516] Packages needed by the future expression (n = 0): <none>
[17:00:30.516] Packages needed by future strategies (n = 0): <none>
[17:00:30.517] {
[17:00:30.517]     {
[17:00:30.517]         {
[17:00:30.517]             ...future.startTime <- base::Sys.time()
[17:00:30.517]             {
[17:00:30.517]                 {
[17:00:30.517]                   {
[17:00:30.517]                     {
[17:00:30.517]                       base::local({
[17:00:30.517]                         has_future <- base::requireNamespace("future", 
[17:00:30.517]                           quietly = TRUE)
[17:00:30.517]                         if (has_future) {
[17:00:30.517]                           ns <- base::getNamespace("future")
[17:00:30.517]                           version <- ns[[".package"]][["version"]]
[17:00:30.517]                           if (is.null(version)) 
[17:00:30.517]                             version <- utils::packageVersion("future")
[17:00:30.517]                         }
[17:00:30.517]                         else {
[17:00:30.517]                           version <- NULL
[17:00:30.517]                         }
[17:00:30.517]                         if (!has_future || version < "1.8.0") {
[17:00:30.517]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.517]                             "", base::R.version$version.string), 
[17:00:30.517]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.517]                               "release", "version")], collapse = " "), 
[17:00:30.517]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.517]                             info)
[17:00:30.517]                           info <- base::paste(info, collapse = "; ")
[17:00:30.517]                           if (!has_future) {
[17:00:30.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.517]                               info)
[17:00:30.517]                           }
[17:00:30.517]                           else {
[17:00:30.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.517]                               info, version)
[17:00:30.517]                           }
[17:00:30.517]                           base::stop(msg)
[17:00:30.517]                         }
[17:00:30.517]                       })
[17:00:30.517]                     }
[17:00:30.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.517]                     base::options(mc.cores = 1L)
[17:00:30.517]                   }
[17:00:30.517]                   ...future.strategy.old <- future::plan("list")
[17:00:30.517]                   options(future.plan = NULL)
[17:00:30.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.517]                 }
[17:00:30.517]                 ...future.workdir <- getwd()
[17:00:30.517]             }
[17:00:30.517]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.517]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.517]         }
[17:00:30.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.517]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.517]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.517]             base::names(...future.oldOptions))
[17:00:30.517]     }
[17:00:30.517]     if (FALSE) {
[17:00:30.517]     }
[17:00:30.517]     else {
[17:00:30.517]         if (TRUE) {
[17:00:30.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.517]                 open = "w")
[17:00:30.517]         }
[17:00:30.517]         else {
[17:00:30.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.517]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.517]         }
[17:00:30.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.517]             base::sink(type = "output", split = FALSE)
[17:00:30.517]             base::close(...future.stdout)
[17:00:30.517]         }, add = TRUE)
[17:00:30.517]     }
[17:00:30.517]     ...future.frame <- base::sys.nframe()
[17:00:30.517]     ...future.conditions <- base::list()
[17:00:30.517]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.517]     if (FALSE) {
[17:00:30.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.517]     }
[17:00:30.517]     ...future.result <- base::tryCatch({
[17:00:30.517]         base::withCallingHandlers({
[17:00:30.517]             ...future.value <- base::withVisible(base::local({
[17:00:30.517]                 withCallingHandlers({
[17:00:30.517]                   {
[17:00:30.517]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.517]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.517]                       ...future.globals.maxSize)) {
[17:00:30.517]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.517]                       on.exit(options(oopts), add = TRUE)
[17:00:30.517]                     }
[17:00:30.517]                     {
[17:00:30.517]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.517]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.517]                         USE.NAMES = FALSE)
[17:00:30.517]                       do.call(mapply, args = args)
[17:00:30.517]                     }
[17:00:30.517]                   }
[17:00:30.517]                 }, immediateCondition = function(cond) {
[17:00:30.517]                   save_rds <- function (object, pathname, ...) 
[17:00:30.517]                   {
[17:00:30.517]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.517]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.517]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.517]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.517]                         fi_tmp[["mtime"]])
[17:00:30.517]                     }
[17:00:30.517]                     tryCatch({
[17:00:30.517]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.517]                     }, error = function(ex) {
[17:00:30.517]                       msg <- conditionMessage(ex)
[17:00:30.517]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.517]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.517]                         fi_tmp[["mtime"]], msg)
[17:00:30.517]                       ex$message <- msg
[17:00:30.517]                       stop(ex)
[17:00:30.517]                     })
[17:00:30.517]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.517]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.517]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.517]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.517]                       fi <- file.info(pathname)
[17:00:30.517]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.517]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.517]                         fi[["size"]], fi[["mtime"]])
[17:00:30.517]                       stop(msg)
[17:00:30.517]                     }
[17:00:30.517]                     invisible(pathname)
[17:00:30.517]                   }
[17:00:30.517]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.517]                     rootPath = tempdir()) 
[17:00:30.517]                   {
[17:00:30.517]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.517]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.517]                       tmpdir = path, fileext = ".rds")
[17:00:30.517]                     save_rds(obj, file)
[17:00:30.517]                   }
[17:00:30.517]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.517]                   {
[17:00:30.517]                     inherits <- base::inherits
[17:00:30.517]                     invokeRestart <- base::invokeRestart
[17:00:30.517]                     is.null <- base::is.null
[17:00:30.517]                     muffled <- FALSE
[17:00:30.517]                     if (inherits(cond, "message")) {
[17:00:30.517]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.517]                       if (muffled) 
[17:00:30.517]                         invokeRestart("muffleMessage")
[17:00:30.517]                     }
[17:00:30.517]                     else if (inherits(cond, "warning")) {
[17:00:30.517]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.517]                       if (muffled) 
[17:00:30.517]                         invokeRestart("muffleWarning")
[17:00:30.517]                     }
[17:00:30.517]                     else if (inherits(cond, "condition")) {
[17:00:30.517]                       if (!is.null(pattern)) {
[17:00:30.517]                         computeRestarts <- base::computeRestarts
[17:00:30.517]                         grepl <- base::grepl
[17:00:30.517]                         restarts <- computeRestarts(cond)
[17:00:30.517]                         for (restart in restarts) {
[17:00:30.517]                           name <- restart$name
[17:00:30.517]                           if (is.null(name)) 
[17:00:30.517]                             next
[17:00:30.517]                           if (!grepl(pattern, name)) 
[17:00:30.517]                             next
[17:00:30.517]                           invokeRestart(restart)
[17:00:30.517]                           muffled <- TRUE
[17:00:30.517]                           break
[17:00:30.517]                         }
[17:00:30.517]                       }
[17:00:30.517]                     }
[17:00:30.517]                     invisible(muffled)
[17:00:30.517]                   }
[17:00:30.517]                   muffleCondition(cond)
[17:00:30.517]                 })
[17:00:30.517]             }))
[17:00:30.517]             future::FutureResult(value = ...future.value$value, 
[17:00:30.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.517]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.517]                     ...future.globalenv.names))
[17:00:30.517]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.517]         }, condition = base::local({
[17:00:30.517]             c <- base::c
[17:00:30.517]             inherits <- base::inherits
[17:00:30.517]             invokeRestart <- base::invokeRestart
[17:00:30.517]             length <- base::length
[17:00:30.517]             list <- base::list
[17:00:30.517]             seq.int <- base::seq.int
[17:00:30.517]             signalCondition <- base::signalCondition
[17:00:30.517]             sys.calls <- base::sys.calls
[17:00:30.517]             `[[` <- base::`[[`
[17:00:30.517]             `+` <- base::`+`
[17:00:30.517]             `<<-` <- base::`<<-`
[17:00:30.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.517]                   3L)]
[17:00:30.517]             }
[17:00:30.517]             function(cond) {
[17:00:30.517]                 is_error <- inherits(cond, "error")
[17:00:30.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.517]                   NULL)
[17:00:30.517]                 if (is_error) {
[17:00:30.517]                   sessionInformation <- function() {
[17:00:30.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.517]                       search = base::search(), system = base::Sys.info())
[17:00:30.517]                   }
[17:00:30.517]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.517]                     cond$call), session = sessionInformation(), 
[17:00:30.517]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.517]                   signalCondition(cond)
[17:00:30.517]                 }
[17:00:30.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.517]                 "immediateCondition"))) {
[17:00:30.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.517]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.517]                   if (TRUE && !signal) {
[17:00:30.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.517]                     {
[17:00:30.517]                       inherits <- base::inherits
[17:00:30.517]                       invokeRestart <- base::invokeRestart
[17:00:30.517]                       is.null <- base::is.null
[17:00:30.517]                       muffled <- FALSE
[17:00:30.517]                       if (inherits(cond, "message")) {
[17:00:30.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.517]                         if (muffled) 
[17:00:30.517]                           invokeRestart("muffleMessage")
[17:00:30.517]                       }
[17:00:30.517]                       else if (inherits(cond, "warning")) {
[17:00:30.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.517]                         if (muffled) 
[17:00:30.517]                           invokeRestart("muffleWarning")
[17:00:30.517]                       }
[17:00:30.517]                       else if (inherits(cond, "condition")) {
[17:00:30.517]                         if (!is.null(pattern)) {
[17:00:30.517]                           computeRestarts <- base::computeRestarts
[17:00:30.517]                           grepl <- base::grepl
[17:00:30.517]                           restarts <- computeRestarts(cond)
[17:00:30.517]                           for (restart in restarts) {
[17:00:30.517]                             name <- restart$name
[17:00:30.517]                             if (is.null(name)) 
[17:00:30.517]                               next
[17:00:30.517]                             if (!grepl(pattern, name)) 
[17:00:30.517]                               next
[17:00:30.517]                             invokeRestart(restart)
[17:00:30.517]                             muffled <- TRUE
[17:00:30.517]                             break
[17:00:30.517]                           }
[17:00:30.517]                         }
[17:00:30.517]                       }
[17:00:30.517]                       invisible(muffled)
[17:00:30.517]                     }
[17:00:30.517]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.517]                   }
[17:00:30.517]                 }
[17:00:30.517]                 else {
[17:00:30.517]                   if (TRUE) {
[17:00:30.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.517]                     {
[17:00:30.517]                       inherits <- base::inherits
[17:00:30.517]                       invokeRestart <- base::invokeRestart
[17:00:30.517]                       is.null <- base::is.null
[17:00:30.517]                       muffled <- FALSE
[17:00:30.517]                       if (inherits(cond, "message")) {
[17:00:30.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.517]                         if (muffled) 
[17:00:30.517]                           invokeRestart("muffleMessage")
[17:00:30.517]                       }
[17:00:30.517]                       else if (inherits(cond, "warning")) {
[17:00:30.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.517]                         if (muffled) 
[17:00:30.517]                           invokeRestart("muffleWarning")
[17:00:30.517]                       }
[17:00:30.517]                       else if (inherits(cond, "condition")) {
[17:00:30.517]                         if (!is.null(pattern)) {
[17:00:30.517]                           computeRestarts <- base::computeRestarts
[17:00:30.517]                           grepl <- base::grepl
[17:00:30.517]                           restarts <- computeRestarts(cond)
[17:00:30.517]                           for (restart in restarts) {
[17:00:30.517]                             name <- restart$name
[17:00:30.517]                             if (is.null(name)) 
[17:00:30.517]                               next
[17:00:30.517]                             if (!grepl(pattern, name)) 
[17:00:30.517]                               next
[17:00:30.517]                             invokeRestart(restart)
[17:00:30.517]                             muffled <- TRUE
[17:00:30.517]                             break
[17:00:30.517]                           }
[17:00:30.517]                         }
[17:00:30.517]                       }
[17:00:30.517]                       invisible(muffled)
[17:00:30.517]                     }
[17:00:30.517]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.517]                   }
[17:00:30.517]                 }
[17:00:30.517]             }
[17:00:30.517]         }))
[17:00:30.517]     }, error = function(ex) {
[17:00:30.517]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.517]                 ...future.rng), started = ...future.startTime, 
[17:00:30.517]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.517]             version = "1.8"), class = "FutureResult")
[17:00:30.517]     }, finally = {
[17:00:30.517]         if (!identical(...future.workdir, getwd())) 
[17:00:30.517]             setwd(...future.workdir)
[17:00:30.517]         {
[17:00:30.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.517]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.517]             }
[17:00:30.517]             base::options(...future.oldOptions)
[17:00:30.517]             if (.Platform$OS.type == "windows") {
[17:00:30.517]                 old_names <- names(...future.oldEnvVars)
[17:00:30.517]                 envs <- base::Sys.getenv()
[17:00:30.517]                 names <- names(envs)
[17:00:30.517]                 common <- intersect(names, old_names)
[17:00:30.517]                 added <- setdiff(names, old_names)
[17:00:30.517]                 removed <- setdiff(old_names, names)
[17:00:30.517]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.517]                   envs[common]]
[17:00:30.517]                 NAMES <- toupper(changed)
[17:00:30.517]                 args <- list()
[17:00:30.517]                 for (kk in seq_along(NAMES)) {
[17:00:30.517]                   name <- changed[[kk]]
[17:00:30.517]                   NAME <- NAMES[[kk]]
[17:00:30.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.517]                     next
[17:00:30.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.517]                 }
[17:00:30.517]                 NAMES <- toupper(added)
[17:00:30.517]                 for (kk in seq_along(NAMES)) {
[17:00:30.517]                   name <- added[[kk]]
[17:00:30.517]                   NAME <- NAMES[[kk]]
[17:00:30.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.517]                     next
[17:00:30.517]                   args[[name]] <- ""
[17:00:30.517]                 }
[17:00:30.517]                 NAMES <- toupper(removed)
[17:00:30.517]                 for (kk in seq_along(NAMES)) {
[17:00:30.517]                   name <- removed[[kk]]
[17:00:30.517]                   NAME <- NAMES[[kk]]
[17:00:30.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.517]                     next
[17:00:30.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.517]                 }
[17:00:30.517]                 if (length(args) > 0) 
[17:00:30.517]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.517]             }
[17:00:30.517]             else {
[17:00:30.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.517]             }
[17:00:30.517]             {
[17:00:30.517]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.517]                   0L) {
[17:00:30.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.517]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.517]                   base::options(opts)
[17:00:30.517]                 }
[17:00:30.517]                 {
[17:00:30.517]                   {
[17:00:30.517]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.517]                     NULL
[17:00:30.517]                   }
[17:00:30.517]                   options(future.plan = NULL)
[17:00:30.517]                   if (is.na(NA_character_)) 
[17:00:30.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.517]                     .init = FALSE)
[17:00:30.517]                 }
[17:00:30.517]             }
[17:00:30.517]         }
[17:00:30.517]     })
[17:00:30.517]     if (TRUE) {
[17:00:30.517]         base::sink(type = "output", split = FALSE)
[17:00:30.517]         if (TRUE) {
[17:00:30.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.517]         }
[17:00:30.517]         else {
[17:00:30.517]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.517]         }
[17:00:30.517]         base::close(...future.stdout)
[17:00:30.517]         ...future.stdout <- NULL
[17:00:30.517]     }
[17:00:30.517]     ...future.result$conditions <- ...future.conditions
[17:00:30.517]     ...future.result$finished <- base::Sys.time()
[17:00:30.517]     ...future.result
[17:00:30.517] }
[17:00:30.519] assign_globals() ...
[17:00:30.519] List of 5
[17:00:30.519]  $ ...future.FUN            :function (C, k)  
[17:00:30.519]  $ MoreArgs                 : list()
[17:00:30.519]  $ ...future.elements_ii    :List of 2
[17:00:30.519]   ..$ :List of 2
[17:00:30.519]   .. ..$ : chr "A"
[17:00:30.519]   .. ..$ : chr "B"
[17:00:30.519]   ..$ :List of 2
[17:00:30.519]   .. ..$ : int 5
[17:00:30.519]   .. ..$ : int 4
[17:00:30.519]  $ ...future.seeds_ii       : NULL
[17:00:30.519]  $ ...future.globals.maxSize: NULL
[17:00:30.519]  - attr(*, "where")=List of 5
[17:00:30.519]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.519]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.519]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.519]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.519]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.519]  - attr(*, "resolved")= logi FALSE
[17:00:30.519]  - attr(*, "total_size")= num 3656
[17:00:30.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.519]  - attr(*, "already-done")= logi TRUE
[17:00:30.529] - reassign environment for ‘...future.FUN’
[17:00:30.529] - copied ‘...future.FUN’ to environment
[17:00:30.529] - copied ‘MoreArgs’ to environment
[17:00:30.529] - copied ‘...future.elements_ii’ to environment
[17:00:30.529] - copied ‘...future.seeds_ii’ to environment
[17:00:30.529] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.529] assign_globals() ... done
[17:00:30.530] requestCore(): workers = 2
[17:00:30.532] MulticoreFuture started
[17:00:30.533] - Launch lazy future ... done
[17:00:30.533] run() for ‘MulticoreFuture’ ... done
[17:00:30.533] plan(): Setting new future strategy stack:
[17:00:30.534] Created future:
[17:00:30.534] List of future strategies:
[17:00:30.534] 1. sequential:
[17:00:30.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.534]    - tweaked: FALSE
[17:00:30.534]    - call: NULL
[17:00:30.536] plan(): nbrOfWorkers() = 1
[17:00:30.539] plan(): Setting new future strategy stack:
[17:00:30.539] List of future strategies:
[17:00:30.539] 1. multicore:
[17:00:30.539]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.539]    - tweaked: FALSE
[17:00:30.539]    - call: plan(strategy)
[17:00:30.545] plan(): nbrOfWorkers() = 2
[17:00:30.534] MulticoreFuture:
[17:00:30.534] Label: ‘future_.mapply-1’
[17:00:30.534] Expression:
[17:00:30.534] {
[17:00:30.534]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.534]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.534]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.534]         on.exit(options(oopts), add = TRUE)
[17:00:30.534]     }
[17:00:30.534]     {
[17:00:30.534]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.534]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.534]         do.call(mapply, args = args)
[17:00:30.534]     }
[17:00:30.534] }
[17:00:30.534] Lazy evaluation: FALSE
[17:00:30.534] Asynchronous evaluation: TRUE
[17:00:30.534] Local evaluation: TRUE
[17:00:30.534] Environment: R_GlobalEnv
[17:00:30.534] Capture standard output: TRUE
[17:00:30.534] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.534] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.534] Packages: <none>
[17:00:30.534] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.534] Resolved: TRUE
[17:00:30.534] Value: <not collected>
[17:00:30.534] Conditions captured: <none>
[17:00:30.534] Early signaling: FALSE
[17:00:30.534] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.534] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.546] Chunk #1 of 2 ... DONE
[17:00:30.546] Chunk #2 of 2 ...
[17:00:30.546]  - Finding globals in '...' for chunk #2 ...
[17:00:30.547] getGlobalsAndPackages() ...
[17:00:30.547] Searching for globals...
[17:00:30.547] 
[17:00:30.548] Searching for globals ... DONE
[17:00:30.548] - globals: [0] <none>
[17:00:30.548] getGlobalsAndPackages() ... DONE
[17:00:30.548]    + additional globals found: [n=0] 
[17:00:30.548]    + additional namespaces needed: [n=0] 
[17:00:30.548]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:30.548]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:30.549]  - seeds: <none>
[17:00:30.549]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.549] getGlobalsAndPackages() ...
[17:00:30.549] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.550] Resolving globals: FALSE
[17:00:30.550] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:00:30.551] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:30.552] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.552] 
[17:00:30.552] getGlobalsAndPackages() ... DONE
[17:00:30.552] run() for ‘Future’ ...
[17:00:30.553] - state: ‘created’
[17:00:30.553] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.558] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.558]   - Field: ‘label’
[17:00:30.558]   - Field: ‘local’
[17:00:30.558]   - Field: ‘owner’
[17:00:30.558]   - Field: ‘envir’
[17:00:30.558]   - Field: ‘workers’
[17:00:30.559]   - Field: ‘packages’
[17:00:30.559]   - Field: ‘gc’
[17:00:30.559]   - Field: ‘job’
[17:00:30.559]   - Field: ‘conditions’
[17:00:30.559]   - Field: ‘expr’
[17:00:30.559]   - Field: ‘uuid’
[17:00:30.559]   - Field: ‘seed’
[17:00:30.560]   - Field: ‘version’
[17:00:30.560]   - Field: ‘result’
[17:00:30.560]   - Field: ‘asynchronous’
[17:00:30.560]   - Field: ‘calls’
[17:00:30.560]   - Field: ‘globals’
[17:00:30.560]   - Field: ‘stdout’
[17:00:30.560]   - Field: ‘earlySignal’
[17:00:30.561]   - Field: ‘lazy’
[17:00:30.561]   - Field: ‘state’
[17:00:30.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.561] - Launch lazy future ...
[17:00:30.562] Packages needed by the future expression (n = 0): <none>
[17:00:30.562] Packages needed by future strategies (n = 0): <none>
[17:00:30.562] {
[17:00:30.562]     {
[17:00:30.562]         {
[17:00:30.562]             ...future.startTime <- base::Sys.time()
[17:00:30.562]             {
[17:00:30.562]                 {
[17:00:30.562]                   {
[17:00:30.562]                     {
[17:00:30.562]                       base::local({
[17:00:30.562]                         has_future <- base::requireNamespace("future", 
[17:00:30.562]                           quietly = TRUE)
[17:00:30.562]                         if (has_future) {
[17:00:30.562]                           ns <- base::getNamespace("future")
[17:00:30.562]                           version <- ns[[".package"]][["version"]]
[17:00:30.562]                           if (is.null(version)) 
[17:00:30.562]                             version <- utils::packageVersion("future")
[17:00:30.562]                         }
[17:00:30.562]                         else {
[17:00:30.562]                           version <- NULL
[17:00:30.562]                         }
[17:00:30.562]                         if (!has_future || version < "1.8.0") {
[17:00:30.562]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.562]                             "", base::R.version$version.string), 
[17:00:30.562]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.562]                               "release", "version")], collapse = " "), 
[17:00:30.562]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.562]                             info)
[17:00:30.562]                           info <- base::paste(info, collapse = "; ")
[17:00:30.562]                           if (!has_future) {
[17:00:30.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.562]                               info)
[17:00:30.562]                           }
[17:00:30.562]                           else {
[17:00:30.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.562]                               info, version)
[17:00:30.562]                           }
[17:00:30.562]                           base::stop(msg)
[17:00:30.562]                         }
[17:00:30.562]                       })
[17:00:30.562]                     }
[17:00:30.562]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.562]                     base::options(mc.cores = 1L)
[17:00:30.562]                   }
[17:00:30.562]                   ...future.strategy.old <- future::plan("list")
[17:00:30.562]                   options(future.plan = NULL)
[17:00:30.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.562]                 }
[17:00:30.562]                 ...future.workdir <- getwd()
[17:00:30.562]             }
[17:00:30.562]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.562]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.562]         }
[17:00:30.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.562]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.562]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.562]             base::names(...future.oldOptions))
[17:00:30.562]     }
[17:00:30.562]     if (FALSE) {
[17:00:30.562]     }
[17:00:30.562]     else {
[17:00:30.562]         if (TRUE) {
[17:00:30.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.562]                 open = "w")
[17:00:30.562]         }
[17:00:30.562]         else {
[17:00:30.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.562]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.562]         }
[17:00:30.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.562]             base::sink(type = "output", split = FALSE)
[17:00:30.562]             base::close(...future.stdout)
[17:00:30.562]         }, add = TRUE)
[17:00:30.562]     }
[17:00:30.562]     ...future.frame <- base::sys.nframe()
[17:00:30.562]     ...future.conditions <- base::list()
[17:00:30.562]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.562]     if (FALSE) {
[17:00:30.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.562]     }
[17:00:30.562]     ...future.result <- base::tryCatch({
[17:00:30.562]         base::withCallingHandlers({
[17:00:30.562]             ...future.value <- base::withVisible(base::local({
[17:00:30.562]                 withCallingHandlers({
[17:00:30.562]                   {
[17:00:30.562]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.562]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.562]                       ...future.globals.maxSize)) {
[17:00:30.562]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.562]                       on.exit(options(oopts), add = TRUE)
[17:00:30.562]                     }
[17:00:30.562]                     {
[17:00:30.562]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.562]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.562]                         USE.NAMES = FALSE)
[17:00:30.562]                       do.call(mapply, args = args)
[17:00:30.562]                     }
[17:00:30.562]                   }
[17:00:30.562]                 }, immediateCondition = function(cond) {
[17:00:30.562]                   save_rds <- function (object, pathname, ...) 
[17:00:30.562]                   {
[17:00:30.562]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.562]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.562]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.562]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.562]                         fi_tmp[["mtime"]])
[17:00:30.562]                     }
[17:00:30.562]                     tryCatch({
[17:00:30.562]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.562]                     }, error = function(ex) {
[17:00:30.562]                       msg <- conditionMessage(ex)
[17:00:30.562]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.562]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.562]                         fi_tmp[["mtime"]], msg)
[17:00:30.562]                       ex$message <- msg
[17:00:30.562]                       stop(ex)
[17:00:30.562]                     })
[17:00:30.562]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.562]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.562]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.562]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.562]                       fi <- file.info(pathname)
[17:00:30.562]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.562]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.562]                         fi[["size"]], fi[["mtime"]])
[17:00:30.562]                       stop(msg)
[17:00:30.562]                     }
[17:00:30.562]                     invisible(pathname)
[17:00:30.562]                   }
[17:00:30.562]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.562]                     rootPath = tempdir()) 
[17:00:30.562]                   {
[17:00:30.562]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.562]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.562]                       tmpdir = path, fileext = ".rds")
[17:00:30.562]                     save_rds(obj, file)
[17:00:30.562]                   }
[17:00:30.562]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.562]                   {
[17:00:30.562]                     inherits <- base::inherits
[17:00:30.562]                     invokeRestart <- base::invokeRestart
[17:00:30.562]                     is.null <- base::is.null
[17:00:30.562]                     muffled <- FALSE
[17:00:30.562]                     if (inherits(cond, "message")) {
[17:00:30.562]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.562]                       if (muffled) 
[17:00:30.562]                         invokeRestart("muffleMessage")
[17:00:30.562]                     }
[17:00:30.562]                     else if (inherits(cond, "warning")) {
[17:00:30.562]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.562]                       if (muffled) 
[17:00:30.562]                         invokeRestart("muffleWarning")
[17:00:30.562]                     }
[17:00:30.562]                     else if (inherits(cond, "condition")) {
[17:00:30.562]                       if (!is.null(pattern)) {
[17:00:30.562]                         computeRestarts <- base::computeRestarts
[17:00:30.562]                         grepl <- base::grepl
[17:00:30.562]                         restarts <- computeRestarts(cond)
[17:00:30.562]                         for (restart in restarts) {
[17:00:30.562]                           name <- restart$name
[17:00:30.562]                           if (is.null(name)) 
[17:00:30.562]                             next
[17:00:30.562]                           if (!grepl(pattern, name)) 
[17:00:30.562]                             next
[17:00:30.562]                           invokeRestart(restart)
[17:00:30.562]                           muffled <- TRUE
[17:00:30.562]                           break
[17:00:30.562]                         }
[17:00:30.562]                       }
[17:00:30.562]                     }
[17:00:30.562]                     invisible(muffled)
[17:00:30.562]                   }
[17:00:30.562]                   muffleCondition(cond)
[17:00:30.562]                 })
[17:00:30.562]             }))
[17:00:30.562]             future::FutureResult(value = ...future.value$value, 
[17:00:30.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.562]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.562]                     ...future.globalenv.names))
[17:00:30.562]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.562]         }, condition = base::local({
[17:00:30.562]             c <- base::c
[17:00:30.562]             inherits <- base::inherits
[17:00:30.562]             invokeRestart <- base::invokeRestart
[17:00:30.562]             length <- base::length
[17:00:30.562]             list <- base::list
[17:00:30.562]             seq.int <- base::seq.int
[17:00:30.562]             signalCondition <- base::signalCondition
[17:00:30.562]             sys.calls <- base::sys.calls
[17:00:30.562]             `[[` <- base::`[[`
[17:00:30.562]             `+` <- base::`+`
[17:00:30.562]             `<<-` <- base::`<<-`
[17:00:30.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.562]                   3L)]
[17:00:30.562]             }
[17:00:30.562]             function(cond) {
[17:00:30.562]                 is_error <- inherits(cond, "error")
[17:00:30.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.562]                   NULL)
[17:00:30.562]                 if (is_error) {
[17:00:30.562]                   sessionInformation <- function() {
[17:00:30.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.562]                       search = base::search(), system = base::Sys.info())
[17:00:30.562]                   }
[17:00:30.562]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.562]                     cond$call), session = sessionInformation(), 
[17:00:30.562]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.562]                   signalCondition(cond)
[17:00:30.562]                 }
[17:00:30.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.562]                 "immediateCondition"))) {
[17:00:30.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.562]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.562]                   if (TRUE && !signal) {
[17:00:30.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.562]                     {
[17:00:30.562]                       inherits <- base::inherits
[17:00:30.562]                       invokeRestart <- base::invokeRestart
[17:00:30.562]                       is.null <- base::is.null
[17:00:30.562]                       muffled <- FALSE
[17:00:30.562]                       if (inherits(cond, "message")) {
[17:00:30.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.562]                         if (muffled) 
[17:00:30.562]                           invokeRestart("muffleMessage")
[17:00:30.562]                       }
[17:00:30.562]                       else if (inherits(cond, "warning")) {
[17:00:30.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.562]                         if (muffled) 
[17:00:30.562]                           invokeRestart("muffleWarning")
[17:00:30.562]                       }
[17:00:30.562]                       else if (inherits(cond, "condition")) {
[17:00:30.562]                         if (!is.null(pattern)) {
[17:00:30.562]                           computeRestarts <- base::computeRestarts
[17:00:30.562]                           grepl <- base::grepl
[17:00:30.562]                           restarts <- computeRestarts(cond)
[17:00:30.562]                           for (restart in restarts) {
[17:00:30.562]                             name <- restart$name
[17:00:30.562]                             if (is.null(name)) 
[17:00:30.562]                               next
[17:00:30.562]                             if (!grepl(pattern, name)) 
[17:00:30.562]                               next
[17:00:30.562]                             invokeRestart(restart)
[17:00:30.562]                             muffled <- TRUE
[17:00:30.562]                             break
[17:00:30.562]                           }
[17:00:30.562]                         }
[17:00:30.562]                       }
[17:00:30.562]                       invisible(muffled)
[17:00:30.562]                     }
[17:00:30.562]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.562]                   }
[17:00:30.562]                 }
[17:00:30.562]                 else {
[17:00:30.562]                   if (TRUE) {
[17:00:30.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.562]                     {
[17:00:30.562]                       inherits <- base::inherits
[17:00:30.562]                       invokeRestart <- base::invokeRestart
[17:00:30.562]                       is.null <- base::is.null
[17:00:30.562]                       muffled <- FALSE
[17:00:30.562]                       if (inherits(cond, "message")) {
[17:00:30.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.562]                         if (muffled) 
[17:00:30.562]                           invokeRestart("muffleMessage")
[17:00:30.562]                       }
[17:00:30.562]                       else if (inherits(cond, "warning")) {
[17:00:30.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.562]                         if (muffled) 
[17:00:30.562]                           invokeRestart("muffleWarning")
[17:00:30.562]                       }
[17:00:30.562]                       else if (inherits(cond, "condition")) {
[17:00:30.562]                         if (!is.null(pattern)) {
[17:00:30.562]                           computeRestarts <- base::computeRestarts
[17:00:30.562]                           grepl <- base::grepl
[17:00:30.562]                           restarts <- computeRestarts(cond)
[17:00:30.562]                           for (restart in restarts) {
[17:00:30.562]                             name <- restart$name
[17:00:30.562]                             if (is.null(name)) 
[17:00:30.562]                               next
[17:00:30.562]                             if (!grepl(pattern, name)) 
[17:00:30.562]                               next
[17:00:30.562]                             invokeRestart(restart)
[17:00:30.562]                             muffled <- TRUE
[17:00:30.562]                             break
[17:00:30.562]                           }
[17:00:30.562]                         }
[17:00:30.562]                       }
[17:00:30.562]                       invisible(muffled)
[17:00:30.562]                     }
[17:00:30.562]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.562]                   }
[17:00:30.562]                 }
[17:00:30.562]             }
[17:00:30.562]         }))
[17:00:30.562]     }, error = function(ex) {
[17:00:30.562]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.562]                 ...future.rng), started = ...future.startTime, 
[17:00:30.562]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.562]             version = "1.8"), class = "FutureResult")
[17:00:30.562]     }, finally = {
[17:00:30.562]         if (!identical(...future.workdir, getwd())) 
[17:00:30.562]             setwd(...future.workdir)
[17:00:30.562]         {
[17:00:30.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.562]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.562]             }
[17:00:30.562]             base::options(...future.oldOptions)
[17:00:30.562]             if (.Platform$OS.type == "windows") {
[17:00:30.562]                 old_names <- names(...future.oldEnvVars)
[17:00:30.562]                 envs <- base::Sys.getenv()
[17:00:30.562]                 names <- names(envs)
[17:00:30.562]                 common <- intersect(names, old_names)
[17:00:30.562]                 added <- setdiff(names, old_names)
[17:00:30.562]                 removed <- setdiff(old_names, names)
[17:00:30.562]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.562]                   envs[common]]
[17:00:30.562]                 NAMES <- toupper(changed)
[17:00:30.562]                 args <- list()
[17:00:30.562]                 for (kk in seq_along(NAMES)) {
[17:00:30.562]                   name <- changed[[kk]]
[17:00:30.562]                   NAME <- NAMES[[kk]]
[17:00:30.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.562]                     next
[17:00:30.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.562]                 }
[17:00:30.562]                 NAMES <- toupper(added)
[17:00:30.562]                 for (kk in seq_along(NAMES)) {
[17:00:30.562]                   name <- added[[kk]]
[17:00:30.562]                   NAME <- NAMES[[kk]]
[17:00:30.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.562]                     next
[17:00:30.562]                   args[[name]] <- ""
[17:00:30.562]                 }
[17:00:30.562]                 NAMES <- toupper(removed)
[17:00:30.562]                 for (kk in seq_along(NAMES)) {
[17:00:30.562]                   name <- removed[[kk]]
[17:00:30.562]                   NAME <- NAMES[[kk]]
[17:00:30.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.562]                     next
[17:00:30.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.562]                 }
[17:00:30.562]                 if (length(args) > 0) 
[17:00:30.562]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.562]             }
[17:00:30.562]             else {
[17:00:30.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.562]             }
[17:00:30.562]             {
[17:00:30.562]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.562]                   0L) {
[17:00:30.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.562]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.562]                   base::options(opts)
[17:00:30.562]                 }
[17:00:30.562]                 {
[17:00:30.562]                   {
[17:00:30.562]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.562]                     NULL
[17:00:30.562]                   }
[17:00:30.562]                   options(future.plan = NULL)
[17:00:30.562]                   if (is.na(NA_character_)) 
[17:00:30.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.562]                     .init = FALSE)
[17:00:30.562]                 }
[17:00:30.562]             }
[17:00:30.562]         }
[17:00:30.562]     })
[17:00:30.562]     if (TRUE) {
[17:00:30.562]         base::sink(type = "output", split = FALSE)
[17:00:30.562]         if (TRUE) {
[17:00:30.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.562]         }
[17:00:30.562]         else {
[17:00:30.562]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.562]         }
[17:00:30.562]         base::close(...future.stdout)
[17:00:30.562]         ...future.stdout <- NULL
[17:00:30.562]     }
[17:00:30.562]     ...future.result$conditions <- ...future.conditions
[17:00:30.562]     ...future.result$finished <- base::Sys.time()
[17:00:30.562]     ...future.result
[17:00:30.562] }
[17:00:30.566] assign_globals() ...
[17:00:30.566] List of 5
[17:00:30.566]  $ ...future.FUN            :function (C, k)  
[17:00:30.566]  $ MoreArgs                 : list()
[17:00:30.566]  $ ...future.elements_ii    :List of 2
[17:00:30.566]   ..$ :List of 3
[17:00:30.566]   .. ..$ : chr "C"
[17:00:30.566]   .. ..$ : chr "D"
[17:00:30.566]   .. ..$ : chr "E"
[17:00:30.566]   ..$ :List of 3
[17:00:30.566]   .. ..$ : int 3
[17:00:30.566]   .. ..$ : int 2
[17:00:30.566]   .. ..$ : int 1
[17:00:30.566]  $ ...future.seeds_ii       : NULL
[17:00:30.566]  $ ...future.globals.maxSize: NULL
[17:00:30.566]  - attr(*, "where")=List of 5
[17:00:30.566]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.566]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.566]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.566]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.566]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.566]  - attr(*, "resolved")= logi FALSE
[17:00:30.566]  - attr(*, "total_size")= num 3824
[17:00:30.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.566]  - attr(*, "already-done")= logi TRUE
[17:00:30.579] - reassign environment for ‘...future.FUN’
[17:00:30.580] - copied ‘...future.FUN’ to environment
[17:00:30.580] - copied ‘MoreArgs’ to environment
[17:00:30.580] - copied ‘...future.elements_ii’ to environment
[17:00:30.580] - copied ‘...future.seeds_ii’ to environment
[17:00:30.580] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.580] assign_globals() ... done
[17:00:30.581] requestCore(): workers = 2
[17:00:30.584] MulticoreFuture started
[17:00:30.584] - Launch lazy future ... done
[17:00:30.585] run() for ‘MulticoreFuture’ ... done
[17:00:30.585] plan(): Setting new future strategy stack:
[17:00:30.585] Created future:
[17:00:30.585] List of future strategies:
[17:00:30.585] 1. sequential:
[17:00:30.585]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.585]    - tweaked: FALSE
[17:00:30.585]    - call: NULL
[17:00:30.587] plan(): nbrOfWorkers() = 1
[17:00:30.590] plan(): Setting new future strategy stack:
[17:00:30.590] List of future strategies:
[17:00:30.590] 1. multicore:
[17:00:30.590]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.590]    - tweaked: FALSE
[17:00:30.590]    - call: plan(strategy)
[17:00:30.596] plan(): nbrOfWorkers() = 2
[17:00:30.585] MulticoreFuture:
[17:00:30.585] Label: ‘future_.mapply-2’
[17:00:30.585] Expression:
[17:00:30.585] {
[17:00:30.585]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.585]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.585]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.585]         on.exit(options(oopts), add = TRUE)
[17:00:30.585]     }
[17:00:30.585]     {
[17:00:30.585]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.585]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.585]         do.call(mapply, args = args)
[17:00:30.585]     }
[17:00:30.585] }
[17:00:30.585] Lazy evaluation: FALSE
[17:00:30.585] Asynchronous evaluation: TRUE
[17:00:30.585] Local evaluation: TRUE
[17:00:30.585] Environment: R_GlobalEnv
[17:00:30.585] Capture standard output: TRUE
[17:00:30.585] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.585] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.585] Packages: <none>
[17:00:30.585] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.585] Resolved: TRUE
[17:00:30.585] Value: <not collected>
[17:00:30.585] Conditions captured: <none>
[17:00:30.585] Early signaling: FALSE
[17:00:30.585] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.585] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.597] Chunk #2 of 2 ... DONE
[17:00:30.597] Launching 2 futures (chunks) ... DONE
[17:00:30.597] Resolving 2 futures (chunks) ...
[17:00:30.598] resolve() on list ...
[17:00:30.598]  recursive: 0
[17:00:30.598]  length: 2
[17:00:30.598] 
[17:00:30.599] Future #1
[17:00:30.599] result() for MulticoreFuture ...
[17:00:30.600] result() for MulticoreFuture ...
[17:00:30.600] result() for MulticoreFuture ... done
[17:00:30.600] result() for MulticoreFuture ... done
[17:00:30.600] result() for MulticoreFuture ...
[17:00:30.601] result() for MulticoreFuture ... done
[17:00:30.601] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:30.601] - nx: 2
[17:00:30.601] - relay: TRUE
[17:00:30.601] - stdout: TRUE
[17:00:30.602] - signal: TRUE
[17:00:30.602] - resignal: FALSE
[17:00:30.602] - force: TRUE
[17:00:30.602] - relayed: [n=2] FALSE, FALSE
[17:00:30.602] - queued futures: [n=2] FALSE, FALSE
[17:00:30.603]  - until=1
[17:00:30.603]  - relaying element #1
[17:00:30.603] result() for MulticoreFuture ...
[17:00:30.604] result() for MulticoreFuture ... done
[17:00:30.604] result() for MulticoreFuture ...
[17:00:30.604] result() for MulticoreFuture ... done
[17:00:30.604] result() for MulticoreFuture ...
[17:00:30.605] result() for MulticoreFuture ... done
[17:00:30.605] result() for MulticoreFuture ...
[17:00:30.605] result() for MulticoreFuture ... done
[17:00:30.605] - relayed: [n=2] TRUE, FALSE
[17:00:30.605] - queued futures: [n=2] TRUE, FALSE
[17:00:30.605] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:30.606]  length: 1 (resolved future 1)
[17:00:30.606] Future #2
[17:00:30.606] result() for MulticoreFuture ...
[17:00:30.607] result() for MulticoreFuture ...
[17:00:30.607] result() for MulticoreFuture ... done
[17:00:30.607] result() for MulticoreFuture ... done
[17:00:30.607] result() for MulticoreFuture ...
[17:00:30.608] result() for MulticoreFuture ... done
[17:00:30.608] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:30.608] - nx: 2
[17:00:30.608] - relay: TRUE
[17:00:30.608] - stdout: TRUE
[17:00:30.608] - signal: TRUE
[17:00:30.609] - resignal: FALSE
[17:00:30.609] - force: TRUE
[17:00:30.609] - relayed: [n=2] TRUE, FALSE
[17:00:30.609] - queued futures: [n=2] TRUE, FALSE
[17:00:30.609]  - until=2
[17:00:30.609]  - relaying element #2
[17:00:30.610] result() for MulticoreFuture ...
[17:00:30.610] result() for MulticoreFuture ... done
[17:00:30.610] result() for MulticoreFuture ...
[17:00:30.610] result() for MulticoreFuture ... done
[17:00:30.610] result() for MulticoreFuture ...
[17:00:30.610] result() for MulticoreFuture ... done
[17:00:30.610] result() for MulticoreFuture ...
[17:00:30.611] result() for MulticoreFuture ... done
[17:00:30.611] - relayed: [n=2] TRUE, TRUE
[17:00:30.611] - queued futures: [n=2] TRUE, TRUE
[17:00:30.611] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:30.611]  length: 0 (resolved future 2)
[17:00:30.611] Relaying remaining futures
[17:00:30.611] signalConditionsASAP(NULL, pos=0) ...
[17:00:30.611] - nx: 2
[17:00:30.611] - relay: TRUE
[17:00:30.612] - stdout: TRUE
[17:00:30.612] - signal: TRUE
[17:00:30.612] - resignal: FALSE
[17:00:30.612] - force: TRUE
[17:00:30.612] - relayed: [n=2] TRUE, TRUE
[17:00:30.612] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:30.612] - relayed: [n=2] TRUE, TRUE
[17:00:30.612] - queued futures: [n=2] TRUE, TRUE
[17:00:30.612] signalConditionsASAP(NULL, pos=0) ... done
[17:00:30.613] resolve() on list ... DONE
[17:00:30.613] result() for MulticoreFuture ...
[17:00:30.613] result() for MulticoreFuture ... done
[17:00:30.613] result() for MulticoreFuture ...
[17:00:30.613] result() for MulticoreFuture ... done
[17:00:30.613] result() for MulticoreFuture ...
[17:00:30.613] result() for MulticoreFuture ... done
[17:00:30.613] result() for MulticoreFuture ...
[17:00:30.613] result() for MulticoreFuture ... done
[17:00:30.614]  - Number of value chunks collected: 2
[17:00:30.614] Resolving 2 futures (chunks) ... DONE
[17:00:30.614] Reducing values from 2 chunks ...
[17:00:30.614]  - Number of values collected after concatenation: 5
[17:00:30.614]  - Number of values expected: 5
[17:00:30.614] Reducing values from 2 chunks ... DONE
[17:00:30.614] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[17:00:30.615] future_mapply() ...
[17:00:30.619] Number of chunks: 1
[17:00:30.619] getGlobalsAndPackagesXApply() ...
[17:00:30.619]  - future.globals: TRUE
[17:00:30.619] getGlobalsAndPackages() ...
[17:00:30.619] Searching for globals...
[17:00:30.621] - globals found: [1] ‘FUN’
[17:00:30.621] Searching for globals ... DONE
[17:00:30.621] Resolving globals: FALSE
[17:00:30.621] The total size of the 1 globals is 848 bytes (848 bytes)
[17:00:30.622] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:00:30.622] - globals: [1] ‘FUN’
[17:00:30.622] 
[17:00:30.622] getGlobalsAndPackages() ... DONE
[17:00:30.622]  - globals found/used: [n=1] ‘FUN’
[17:00:30.622]  - needed namespaces: [n=0] 
[17:00:30.625] Finding globals ... DONE
[17:00:30.625] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:30.625] List of 2
[17:00:30.625]  $ ...future.FUN:function (x)  
[17:00:30.625]  $ MoreArgs     : NULL
[17:00:30.625]  - attr(*, "where")=List of 2
[17:00:30.625]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:30.625]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:30.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.625]  - attr(*, "resolved")= logi FALSE
[17:00:30.625]  - attr(*, "total_size")= num NA
[17:00:30.629] Packages to be attached in all futures: [n=0] 
[17:00:30.629] getGlobalsAndPackagesXApply() ... DONE
[17:00:30.629] Number of futures (= number of chunks): 1
[17:00:30.630] Launching 1 futures (chunks) ...
[17:00:30.630] Chunk #1 of 1 ...
[17:00:30.630]  - Finding globals in '...' for chunk #1 ...
[17:00:30.630] getGlobalsAndPackages() ...
[17:00:30.630] Searching for globals...
[17:00:30.631] 
[17:00:30.631] Searching for globals ... DONE
[17:00:30.631] - globals: [0] <none>
[17:00:30.631] getGlobalsAndPackages() ... DONE
[17:00:30.631]    + additional globals found: [n=0] 
[17:00:30.631]    + additional namespaces needed: [n=0] 
[17:00:30.631]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:30.631]  - seeds: <none>
[17:00:30.631]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.632] getGlobalsAndPackages() ...
[17:00:30.632] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.632] Resolving globals: FALSE
[17:00:30.632] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:00:30.633] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:30.633] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.633] 
[17:00:30.633] getGlobalsAndPackages() ... DONE
[17:00:30.633] run() for ‘Future’ ...
[17:00:30.634] - state: ‘created’
[17:00:30.634] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.638] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.638] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.638]   - Field: ‘label’
[17:00:30.638]   - Field: ‘local’
[17:00:30.638]   - Field: ‘owner’
[17:00:30.638]   - Field: ‘envir’
[17:00:30.638]   - Field: ‘workers’
[17:00:30.638]   - Field: ‘packages’
[17:00:30.639]   - Field: ‘gc’
[17:00:30.639]   - Field: ‘job’
[17:00:30.639]   - Field: ‘conditions’
[17:00:30.639]   - Field: ‘expr’
[17:00:30.639]   - Field: ‘uuid’
[17:00:30.639]   - Field: ‘seed’
[17:00:30.639]   - Field: ‘version’
[17:00:30.639]   - Field: ‘result’
[17:00:30.639]   - Field: ‘asynchronous’
[17:00:30.639]   - Field: ‘calls’
[17:00:30.640]   - Field: ‘globals’
[17:00:30.640]   - Field: ‘stdout’
[17:00:30.640]   - Field: ‘earlySignal’
[17:00:30.640]   - Field: ‘lazy’
[17:00:30.640]   - Field: ‘state’
[17:00:30.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.640] - Launch lazy future ...
[17:00:30.641] Packages needed by the future expression (n = 0): <none>
[17:00:30.641] Packages needed by future strategies (n = 0): <none>
[17:00:30.641] {
[17:00:30.641]     {
[17:00:30.641]         {
[17:00:30.641]             ...future.startTime <- base::Sys.time()
[17:00:30.641]             {
[17:00:30.641]                 {
[17:00:30.641]                   {
[17:00:30.641]                     {
[17:00:30.641]                       base::local({
[17:00:30.641]                         has_future <- base::requireNamespace("future", 
[17:00:30.641]                           quietly = TRUE)
[17:00:30.641]                         if (has_future) {
[17:00:30.641]                           ns <- base::getNamespace("future")
[17:00:30.641]                           version <- ns[[".package"]][["version"]]
[17:00:30.641]                           if (is.null(version)) 
[17:00:30.641]                             version <- utils::packageVersion("future")
[17:00:30.641]                         }
[17:00:30.641]                         else {
[17:00:30.641]                           version <- NULL
[17:00:30.641]                         }
[17:00:30.641]                         if (!has_future || version < "1.8.0") {
[17:00:30.641]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.641]                             "", base::R.version$version.string), 
[17:00:30.641]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.641]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.641]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.641]                               "release", "version")], collapse = " "), 
[17:00:30.641]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.641]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.641]                             info)
[17:00:30.641]                           info <- base::paste(info, collapse = "; ")
[17:00:30.641]                           if (!has_future) {
[17:00:30.641]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.641]                               info)
[17:00:30.641]                           }
[17:00:30.641]                           else {
[17:00:30.641]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.641]                               info, version)
[17:00:30.641]                           }
[17:00:30.641]                           base::stop(msg)
[17:00:30.641]                         }
[17:00:30.641]                       })
[17:00:30.641]                     }
[17:00:30.641]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.641]                     base::options(mc.cores = 1L)
[17:00:30.641]                   }
[17:00:30.641]                   ...future.strategy.old <- future::plan("list")
[17:00:30.641]                   options(future.plan = NULL)
[17:00:30.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.641]                 }
[17:00:30.641]                 ...future.workdir <- getwd()
[17:00:30.641]             }
[17:00:30.641]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.641]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.641]         }
[17:00:30.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.641]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:30.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.641]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.641]             base::names(...future.oldOptions))
[17:00:30.641]     }
[17:00:30.641]     if (FALSE) {
[17:00:30.641]     }
[17:00:30.641]     else {
[17:00:30.641]         if (TRUE) {
[17:00:30.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.641]                 open = "w")
[17:00:30.641]         }
[17:00:30.641]         else {
[17:00:30.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.641]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.641]         }
[17:00:30.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.641]             base::sink(type = "output", split = FALSE)
[17:00:30.641]             base::close(...future.stdout)
[17:00:30.641]         }, add = TRUE)
[17:00:30.641]     }
[17:00:30.641]     ...future.frame <- base::sys.nframe()
[17:00:30.641]     ...future.conditions <- base::list()
[17:00:30.641]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.641]     if (FALSE) {
[17:00:30.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.641]     }
[17:00:30.641]     ...future.result <- base::tryCatch({
[17:00:30.641]         base::withCallingHandlers({
[17:00:30.641]             ...future.value <- base::withVisible(base::local({
[17:00:30.641]                 withCallingHandlers({
[17:00:30.641]                   {
[17:00:30.641]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.641]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.641]                       ...future.globals.maxSize)) {
[17:00:30.641]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.641]                       on.exit(options(oopts), add = TRUE)
[17:00:30.641]                     }
[17:00:30.641]                     {
[17:00:30.641]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.641]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.641]                         USE.NAMES = FALSE)
[17:00:30.641]                       do.call(mapply, args = args)
[17:00:30.641]                     }
[17:00:30.641]                   }
[17:00:30.641]                 }, immediateCondition = function(cond) {
[17:00:30.641]                   save_rds <- function (object, pathname, ...) 
[17:00:30.641]                   {
[17:00:30.641]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.641]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.641]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.641]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.641]                         fi_tmp[["mtime"]])
[17:00:30.641]                     }
[17:00:30.641]                     tryCatch({
[17:00:30.641]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.641]                     }, error = function(ex) {
[17:00:30.641]                       msg <- conditionMessage(ex)
[17:00:30.641]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.641]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.641]                         fi_tmp[["mtime"]], msg)
[17:00:30.641]                       ex$message <- msg
[17:00:30.641]                       stop(ex)
[17:00:30.641]                     })
[17:00:30.641]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.641]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.641]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.641]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.641]                       fi <- file.info(pathname)
[17:00:30.641]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.641]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.641]                         fi[["size"]], fi[["mtime"]])
[17:00:30.641]                       stop(msg)
[17:00:30.641]                     }
[17:00:30.641]                     invisible(pathname)
[17:00:30.641]                   }
[17:00:30.641]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.641]                     rootPath = tempdir()) 
[17:00:30.641]                   {
[17:00:30.641]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.641]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.641]                       tmpdir = path, fileext = ".rds")
[17:00:30.641]                     save_rds(obj, file)
[17:00:30.641]                   }
[17:00:30.641]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.641]                   {
[17:00:30.641]                     inherits <- base::inherits
[17:00:30.641]                     invokeRestart <- base::invokeRestart
[17:00:30.641]                     is.null <- base::is.null
[17:00:30.641]                     muffled <- FALSE
[17:00:30.641]                     if (inherits(cond, "message")) {
[17:00:30.641]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.641]                       if (muffled) 
[17:00:30.641]                         invokeRestart("muffleMessage")
[17:00:30.641]                     }
[17:00:30.641]                     else if (inherits(cond, "warning")) {
[17:00:30.641]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.641]                       if (muffled) 
[17:00:30.641]                         invokeRestart("muffleWarning")
[17:00:30.641]                     }
[17:00:30.641]                     else if (inherits(cond, "condition")) {
[17:00:30.641]                       if (!is.null(pattern)) {
[17:00:30.641]                         computeRestarts <- base::computeRestarts
[17:00:30.641]                         grepl <- base::grepl
[17:00:30.641]                         restarts <- computeRestarts(cond)
[17:00:30.641]                         for (restart in restarts) {
[17:00:30.641]                           name <- restart$name
[17:00:30.641]                           if (is.null(name)) 
[17:00:30.641]                             next
[17:00:30.641]                           if (!grepl(pattern, name)) 
[17:00:30.641]                             next
[17:00:30.641]                           invokeRestart(restart)
[17:00:30.641]                           muffled <- TRUE
[17:00:30.641]                           break
[17:00:30.641]                         }
[17:00:30.641]                       }
[17:00:30.641]                     }
[17:00:30.641]                     invisible(muffled)
[17:00:30.641]                   }
[17:00:30.641]                   muffleCondition(cond)
[17:00:30.641]                 })
[17:00:30.641]             }))
[17:00:30.641]             future::FutureResult(value = ...future.value$value, 
[17:00:30.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.641]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.641]                     ...future.globalenv.names))
[17:00:30.641]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.641]         }, condition = base::local({
[17:00:30.641]             c <- base::c
[17:00:30.641]             inherits <- base::inherits
[17:00:30.641]             invokeRestart <- base::invokeRestart
[17:00:30.641]             length <- base::length
[17:00:30.641]             list <- base::list
[17:00:30.641]             seq.int <- base::seq.int
[17:00:30.641]             signalCondition <- base::signalCondition
[17:00:30.641]             sys.calls <- base::sys.calls
[17:00:30.641]             `[[` <- base::`[[`
[17:00:30.641]             `+` <- base::`+`
[17:00:30.641]             `<<-` <- base::`<<-`
[17:00:30.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.641]                   3L)]
[17:00:30.641]             }
[17:00:30.641]             function(cond) {
[17:00:30.641]                 is_error <- inherits(cond, "error")
[17:00:30.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.641]                   NULL)
[17:00:30.641]                 if (is_error) {
[17:00:30.641]                   sessionInformation <- function() {
[17:00:30.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.641]                       search = base::search(), system = base::Sys.info())
[17:00:30.641]                   }
[17:00:30.641]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.641]                     cond$call), session = sessionInformation(), 
[17:00:30.641]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.641]                   signalCondition(cond)
[17:00:30.641]                 }
[17:00:30.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.641]                 "immediateCondition"))) {
[17:00:30.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.641]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.641]                   if (TRUE && !signal) {
[17:00:30.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.641]                     {
[17:00:30.641]                       inherits <- base::inherits
[17:00:30.641]                       invokeRestart <- base::invokeRestart
[17:00:30.641]                       is.null <- base::is.null
[17:00:30.641]                       muffled <- FALSE
[17:00:30.641]                       if (inherits(cond, "message")) {
[17:00:30.641]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.641]                         if (muffled) 
[17:00:30.641]                           invokeRestart("muffleMessage")
[17:00:30.641]                       }
[17:00:30.641]                       else if (inherits(cond, "warning")) {
[17:00:30.641]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.641]                         if (muffled) 
[17:00:30.641]                           invokeRestart("muffleWarning")
[17:00:30.641]                       }
[17:00:30.641]                       else if (inherits(cond, "condition")) {
[17:00:30.641]                         if (!is.null(pattern)) {
[17:00:30.641]                           computeRestarts <- base::computeRestarts
[17:00:30.641]                           grepl <- base::grepl
[17:00:30.641]                           restarts <- computeRestarts(cond)
[17:00:30.641]                           for (restart in restarts) {
[17:00:30.641]                             name <- restart$name
[17:00:30.641]                             if (is.null(name)) 
[17:00:30.641]                               next
[17:00:30.641]                             if (!grepl(pattern, name)) 
[17:00:30.641]                               next
[17:00:30.641]                             invokeRestart(restart)
[17:00:30.641]                             muffled <- TRUE
[17:00:30.641]                             break
[17:00:30.641]                           }
[17:00:30.641]                         }
[17:00:30.641]                       }
[17:00:30.641]                       invisible(muffled)
[17:00:30.641]                     }
[17:00:30.641]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.641]                   }
[17:00:30.641]                 }
[17:00:30.641]                 else {
[17:00:30.641]                   if (TRUE) {
[17:00:30.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.641]                     {
[17:00:30.641]                       inherits <- base::inherits
[17:00:30.641]                       invokeRestart <- base::invokeRestart
[17:00:30.641]                       is.null <- base::is.null
[17:00:30.641]                       muffled <- FALSE
[17:00:30.641]                       if (inherits(cond, "message")) {
[17:00:30.641]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.641]                         if (muffled) 
[17:00:30.641]                           invokeRestart("muffleMessage")
[17:00:30.641]                       }
[17:00:30.641]                       else if (inherits(cond, "warning")) {
[17:00:30.641]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.641]                         if (muffled) 
[17:00:30.641]                           invokeRestart("muffleWarning")
[17:00:30.641]                       }
[17:00:30.641]                       else if (inherits(cond, "condition")) {
[17:00:30.641]                         if (!is.null(pattern)) {
[17:00:30.641]                           computeRestarts <- base::computeRestarts
[17:00:30.641]                           grepl <- base::grepl
[17:00:30.641]                           restarts <- computeRestarts(cond)
[17:00:30.641]                           for (restart in restarts) {
[17:00:30.641]                             name <- restart$name
[17:00:30.641]                             if (is.null(name)) 
[17:00:30.641]                               next
[17:00:30.641]                             if (!grepl(pattern, name)) 
[17:00:30.641]                               next
[17:00:30.641]                             invokeRestart(restart)
[17:00:30.641]                             muffled <- TRUE
[17:00:30.641]                             break
[17:00:30.641]                           }
[17:00:30.641]                         }
[17:00:30.641]                       }
[17:00:30.641]                       invisible(muffled)
[17:00:30.641]                     }
[17:00:30.641]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.641]                   }
[17:00:30.641]                 }
[17:00:30.641]             }
[17:00:30.641]         }))
[17:00:30.641]     }, error = function(ex) {
[17:00:30.641]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.641]                 ...future.rng), started = ...future.startTime, 
[17:00:30.641]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.641]             version = "1.8"), class = "FutureResult")
[17:00:30.641]     }, finally = {
[17:00:30.641]         if (!identical(...future.workdir, getwd())) 
[17:00:30.641]             setwd(...future.workdir)
[17:00:30.641]         {
[17:00:30.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.641]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.641]             }
[17:00:30.641]             base::options(...future.oldOptions)
[17:00:30.641]             if (.Platform$OS.type == "windows") {
[17:00:30.641]                 old_names <- names(...future.oldEnvVars)
[17:00:30.641]                 envs <- base::Sys.getenv()
[17:00:30.641]                 names <- names(envs)
[17:00:30.641]                 common <- intersect(names, old_names)
[17:00:30.641]                 added <- setdiff(names, old_names)
[17:00:30.641]                 removed <- setdiff(old_names, names)
[17:00:30.641]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.641]                   envs[common]]
[17:00:30.641]                 NAMES <- toupper(changed)
[17:00:30.641]                 args <- list()
[17:00:30.641]                 for (kk in seq_along(NAMES)) {
[17:00:30.641]                   name <- changed[[kk]]
[17:00:30.641]                   NAME <- NAMES[[kk]]
[17:00:30.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.641]                     next
[17:00:30.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.641]                 }
[17:00:30.641]                 NAMES <- toupper(added)
[17:00:30.641]                 for (kk in seq_along(NAMES)) {
[17:00:30.641]                   name <- added[[kk]]
[17:00:30.641]                   NAME <- NAMES[[kk]]
[17:00:30.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.641]                     next
[17:00:30.641]                   args[[name]] <- ""
[17:00:30.641]                 }
[17:00:30.641]                 NAMES <- toupper(removed)
[17:00:30.641]                 for (kk in seq_along(NAMES)) {
[17:00:30.641]                   name <- removed[[kk]]
[17:00:30.641]                   NAME <- NAMES[[kk]]
[17:00:30.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.641]                     next
[17:00:30.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.641]                 }
[17:00:30.641]                 if (length(args) > 0) 
[17:00:30.641]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.641]             }
[17:00:30.641]             else {
[17:00:30.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.641]             }
[17:00:30.641]             {
[17:00:30.641]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.641]                   0L) {
[17:00:30.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.641]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.641]                   base::options(opts)
[17:00:30.641]                 }
[17:00:30.641]                 {
[17:00:30.641]                   {
[17:00:30.641]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.641]                     NULL
[17:00:30.641]                   }
[17:00:30.641]                   options(future.plan = NULL)
[17:00:30.641]                   if (is.na(NA_character_)) 
[17:00:30.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.641]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.641]                     .init = FALSE)
[17:00:30.641]                 }
[17:00:30.641]             }
[17:00:30.641]         }
[17:00:30.641]     })
[17:00:30.641]     if (TRUE) {
[17:00:30.641]         base::sink(type = "output", split = FALSE)
[17:00:30.641]         if (TRUE) {
[17:00:30.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.641]         }
[17:00:30.641]         else {
[17:00:30.641]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.641]         }
[17:00:30.641]         base::close(...future.stdout)
[17:00:30.641]         ...future.stdout <- NULL
[17:00:30.641]     }
[17:00:30.641]     ...future.result$conditions <- ...future.conditions
[17:00:30.641]     ...future.result$finished <- base::Sys.time()
[17:00:30.641]     ...future.result
[17:00:30.641] }
[17:00:30.644] assign_globals() ...
[17:00:30.644] List of 5
[17:00:30.644]  $ ...future.FUN            :function (x)  
[17:00:30.644]  $ MoreArgs                 : NULL
[17:00:30.644]  $ ...future.elements_ii    :List of 1
[17:00:30.644]   ..$ :List of 1
[17:00:30.644]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:00:30.644]  $ ...future.seeds_ii       : NULL
[17:00:30.644]  $ ...future.globals.maxSize: NULL
[17:00:30.644]  - attr(*, "where")=List of 5
[17:00:30.644]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.644]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.644]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.644]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.644]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.644]  - attr(*, "resolved")= logi FALSE
[17:00:30.644]  - attr(*, "total_size")= num 1128
[17:00:30.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.644]  - attr(*, "already-done")= logi TRUE
[17:00:30.649] - copied ‘...future.FUN’ to environment
[17:00:30.649] - copied ‘MoreArgs’ to environment
[17:00:30.649] - copied ‘...future.elements_ii’ to environment
[17:00:30.649] - copied ‘...future.seeds_ii’ to environment
[17:00:30.649] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.649] assign_globals() ... done
[17:00:30.649] requestCore(): workers = 2
[17:00:30.652] MulticoreFuture started
[17:00:30.652] - Launch lazy future ... done
[17:00:30.653] run() for ‘MulticoreFuture’ ... done
[17:00:30.653] Created future:
[17:00:30.653] plan(): Setting new future strategy stack:
[17:00:30.653] List of future strategies:
[17:00:30.653] 1. sequential:
[17:00:30.653]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.653]    - tweaked: FALSE
[17:00:30.653]    - call: NULL
[17:00:30.654] plan(): nbrOfWorkers() = 1
[17:00:30.661] plan(): Setting new future strategy stack:
[17:00:30.662] List of future strategies:
[17:00:30.662] 1. multicore:
[17:00:30.662]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.662]    - tweaked: FALSE
[17:00:30.662]    - call: plan(strategy)
[17:00:30.653] MulticoreFuture:
[17:00:30.653] Label: ‘future_mapply-1’
[17:00:30.653] Expression:
[17:00:30.653] {
[17:00:30.653]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.653]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.653]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.653]         on.exit(options(oopts), add = TRUE)
[17:00:30.653]     }
[17:00:30.653]     {
[17:00:30.653]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.653]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.653]         do.call(mapply, args = args)
[17:00:30.653]     }
[17:00:30.653] }
[17:00:30.653] Lazy evaluation: FALSE
[17:00:30.653] Asynchronous evaluation: TRUE
[17:00:30.653] Local evaluation: TRUE
[17:00:30.653] Environment: R_GlobalEnv
[17:00:30.653] Capture standard output: TRUE
[17:00:30.653] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.653] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.653] Packages: <none>
[17:00:30.653] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.653] Resolved: FALSE
[17:00:30.653] Value: <not collected>
[17:00:30.653] Conditions captured: <none>
[17:00:30.653] Early signaling: FALSE
[17:00:30.653] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.653] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.669] Chunk #1 of 1 ... DONE
[17:00:30.669] Launching 1 futures (chunks) ... DONE
[17:00:30.669] Resolving 1 futures (chunks) ...
[17:00:30.670] plan(): nbrOfWorkers() = 2
[17:00:30.670] resolve() on list ...
[17:00:30.670]  recursive: 0
[17:00:30.670]  length: 1
[17:00:30.670] 
[17:00:30.671] Future #1
[17:00:30.671] result() for MulticoreFuture ...
[17:00:30.672] result() for MulticoreFuture ...
[17:00:30.673] result() for MulticoreFuture ... done
[17:00:30.673] result() for MulticoreFuture ... done
[17:00:30.673] result() for MulticoreFuture ...
[17:00:30.673] result() for MulticoreFuture ... done
[17:00:30.673] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:30.674] - nx: 1
[17:00:30.674] - relay: TRUE
[17:00:30.674] - stdout: TRUE
[17:00:30.674] - signal: TRUE
[17:00:30.674] - resignal: FALSE
[17:00:30.674] - force: TRUE
[17:00:30.675] - relayed: [n=1] FALSE
[17:00:30.675] - queued futures: [n=1] FALSE
[17:00:30.675]  - until=1
[17:00:30.675]  - relaying element #1
[17:00:30.675] result() for MulticoreFuture ...
[17:00:30.675] result() for MulticoreFuture ... done
[17:00:30.676] result() for MulticoreFuture ...
[17:00:30.676] result() for MulticoreFuture ... done
[17:00:30.676] result() for MulticoreFuture ...
[17:00:30.676] result() for MulticoreFuture ... done
[17:00:30.676] result() for MulticoreFuture ...
[17:00:30.676] result() for MulticoreFuture ... done
[17:00:30.677] - relayed: [n=1] TRUE
[17:00:30.677] - queued futures: [n=1] TRUE
[17:00:30.677] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:30.677]  length: 0 (resolved future 1)
[17:00:30.677] Relaying remaining futures
[17:00:30.677] signalConditionsASAP(NULL, pos=0) ...
[17:00:30.677] - nx: 1
[17:00:30.678] - relay: TRUE
[17:00:30.678] - stdout: TRUE
[17:00:30.678] - signal: TRUE
[17:00:30.678] - resignal: FALSE
[17:00:30.678] - force: TRUE
[17:00:30.678] - relayed: [n=1] TRUE
[17:00:30.678] - queued futures: [n=1] TRUE
 - flush all
[17:00:30.679] - relayed: [n=1] TRUE
[17:00:30.679] - queued futures: [n=1] TRUE
[17:00:30.679] signalConditionsASAP(NULL, pos=0) ... done
[17:00:30.679] resolve() on list ... DONE
[17:00:30.679] result() for MulticoreFuture ...
[17:00:30.679] result() for MulticoreFuture ... done
[17:00:30.679] result() for MulticoreFuture ...
[17:00:30.679] result() for MulticoreFuture ... done
[17:00:30.680]  - Number of value chunks collected: 1
[17:00:30.680] Resolving 1 futures (chunks) ... DONE
[17:00:30.680] Reducing values from 1 chunks ...
[17:00:30.680]  - Number of values collected after concatenation: 1
[17:00:30.680]  - Number of values expected: 1
[17:00:30.680] Reducing values from 1 chunks ... DONE
[17:00:30.680] future_mapply() ... DONE
[17:00:30.680] future_mapply() ...
[17:00:30.685] Number of chunks: 1
[17:00:30.685] getGlobalsAndPackagesXApply() ...
[17:00:30.685]  - future.globals: TRUE
[17:00:30.685] getGlobalsAndPackages() ...
[17:00:30.685] Searching for globals...
[17:00:30.687] - globals found: [1] ‘FUN’
[17:00:30.687] Searching for globals ... DONE
[17:00:30.687] Resolving globals: FALSE
[17:00:30.687] The total size of the 1 globals is 848 bytes (848 bytes)
[17:00:30.688] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:00:30.688] - globals: [1] ‘FUN’
[17:00:30.688] 
[17:00:30.688] getGlobalsAndPackages() ... DONE
[17:00:30.688]  - globals found/used: [n=1] ‘FUN’
[17:00:30.688]  - needed namespaces: [n=0] 
[17:00:30.688] Finding globals ... DONE
[17:00:30.689] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:30.689] List of 2
[17:00:30.689]  $ ...future.FUN:function (x)  
[17:00:30.689]  $ MoreArgs     : list()
[17:00:30.689]  - attr(*, "where")=List of 2
[17:00:30.689]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:30.689]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:30.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.689]  - attr(*, "resolved")= logi FALSE
[17:00:30.689]  - attr(*, "total_size")= num NA
[17:00:30.691] Packages to be attached in all futures: [n=0] 
[17:00:30.692] getGlobalsAndPackagesXApply() ... DONE
[17:00:30.692] Number of futures (= number of chunks): 1
[17:00:30.692] Launching 1 futures (chunks) ...
[17:00:30.692] Chunk #1 of 1 ...
[17:00:30.692]  - Finding globals in '...' for chunk #1 ...
[17:00:30.692] getGlobalsAndPackages() ...
[17:00:30.692] Searching for globals...
[17:00:30.693] 
[17:00:30.693] Searching for globals ... DONE
[17:00:30.693] - globals: [0] <none>
[17:00:30.693] getGlobalsAndPackages() ... DONE
[17:00:30.693]    + additional globals found: [n=0] 
[17:00:30.693]    + additional namespaces needed: [n=0] 
[17:00:30.693]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:30.693]  - seeds: <none>
[17:00:30.693]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.694] getGlobalsAndPackages() ...
[17:00:30.694] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.694] Resolving globals: FALSE
[17:00:30.694] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:00:30.695] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:30.695] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.695] 
[17:00:30.695] getGlobalsAndPackages() ... DONE
[17:00:30.696] run() for ‘Future’ ...
[17:00:30.696] - state: ‘created’
[17:00:30.696] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.700] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.700]   - Field: ‘label’
[17:00:30.700]   - Field: ‘local’
[17:00:30.702]   - Field: ‘owner’
[17:00:30.702]   - Field: ‘envir’
[17:00:30.703]   - Field: ‘workers’
[17:00:30.703]   - Field: ‘packages’
[17:00:30.703]   - Field: ‘gc’
[17:00:30.703]   - Field: ‘job’
[17:00:30.703]   - Field: ‘conditions’
[17:00:30.703]   - Field: ‘expr’
[17:00:30.703]   - Field: ‘uuid’
[17:00:30.703]   - Field: ‘seed’
[17:00:30.704]   - Field: ‘version’
[17:00:30.704]   - Field: ‘result’
[17:00:30.704]   - Field: ‘asynchronous’
[17:00:30.704]   - Field: ‘calls’
[17:00:30.704]   - Field: ‘globals’
[17:00:30.704]   - Field: ‘stdout’
[17:00:30.704]   - Field: ‘earlySignal’
[17:00:30.704]   - Field: ‘lazy’
[17:00:30.704]   - Field: ‘state’
[17:00:30.705] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.705] - Launch lazy future ...
[17:00:30.705] Packages needed by the future expression (n = 0): <none>
[17:00:30.705] Packages needed by future strategies (n = 0): <none>
[17:00:30.706] {
[17:00:30.706]     {
[17:00:30.706]         {
[17:00:30.706]             ...future.startTime <- base::Sys.time()
[17:00:30.706]             {
[17:00:30.706]                 {
[17:00:30.706]                   {
[17:00:30.706]                     {
[17:00:30.706]                       base::local({
[17:00:30.706]                         has_future <- base::requireNamespace("future", 
[17:00:30.706]                           quietly = TRUE)
[17:00:30.706]                         if (has_future) {
[17:00:30.706]                           ns <- base::getNamespace("future")
[17:00:30.706]                           version <- ns[[".package"]][["version"]]
[17:00:30.706]                           if (is.null(version)) 
[17:00:30.706]                             version <- utils::packageVersion("future")
[17:00:30.706]                         }
[17:00:30.706]                         else {
[17:00:30.706]                           version <- NULL
[17:00:30.706]                         }
[17:00:30.706]                         if (!has_future || version < "1.8.0") {
[17:00:30.706]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.706]                             "", base::R.version$version.string), 
[17:00:30.706]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.706]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.706]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.706]                               "release", "version")], collapse = " "), 
[17:00:30.706]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.706]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.706]                             info)
[17:00:30.706]                           info <- base::paste(info, collapse = "; ")
[17:00:30.706]                           if (!has_future) {
[17:00:30.706]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.706]                               info)
[17:00:30.706]                           }
[17:00:30.706]                           else {
[17:00:30.706]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.706]                               info, version)
[17:00:30.706]                           }
[17:00:30.706]                           base::stop(msg)
[17:00:30.706]                         }
[17:00:30.706]                       })
[17:00:30.706]                     }
[17:00:30.706]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.706]                     base::options(mc.cores = 1L)
[17:00:30.706]                   }
[17:00:30.706]                   ...future.strategy.old <- future::plan("list")
[17:00:30.706]                   options(future.plan = NULL)
[17:00:30.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.706]                 }
[17:00:30.706]                 ...future.workdir <- getwd()
[17:00:30.706]             }
[17:00:30.706]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.706]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.706]         }
[17:00:30.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.706]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:30.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.706]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.706]             base::names(...future.oldOptions))
[17:00:30.706]     }
[17:00:30.706]     if (FALSE) {
[17:00:30.706]     }
[17:00:30.706]     else {
[17:00:30.706]         if (TRUE) {
[17:00:30.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.706]                 open = "w")
[17:00:30.706]         }
[17:00:30.706]         else {
[17:00:30.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.706]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.706]         }
[17:00:30.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.706]             base::sink(type = "output", split = FALSE)
[17:00:30.706]             base::close(...future.stdout)
[17:00:30.706]         }, add = TRUE)
[17:00:30.706]     }
[17:00:30.706]     ...future.frame <- base::sys.nframe()
[17:00:30.706]     ...future.conditions <- base::list()
[17:00:30.706]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.706]     if (FALSE) {
[17:00:30.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.706]     }
[17:00:30.706]     ...future.result <- base::tryCatch({
[17:00:30.706]         base::withCallingHandlers({
[17:00:30.706]             ...future.value <- base::withVisible(base::local({
[17:00:30.706]                 withCallingHandlers({
[17:00:30.706]                   {
[17:00:30.706]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.706]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.706]                       ...future.globals.maxSize)) {
[17:00:30.706]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.706]                       on.exit(options(oopts), add = TRUE)
[17:00:30.706]                     }
[17:00:30.706]                     {
[17:00:30.706]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.706]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.706]                         USE.NAMES = FALSE)
[17:00:30.706]                       do.call(mapply, args = args)
[17:00:30.706]                     }
[17:00:30.706]                   }
[17:00:30.706]                 }, immediateCondition = function(cond) {
[17:00:30.706]                   save_rds <- function (object, pathname, ...) 
[17:00:30.706]                   {
[17:00:30.706]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.706]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.706]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.706]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.706]                         fi_tmp[["mtime"]])
[17:00:30.706]                     }
[17:00:30.706]                     tryCatch({
[17:00:30.706]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.706]                     }, error = function(ex) {
[17:00:30.706]                       msg <- conditionMessage(ex)
[17:00:30.706]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.706]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.706]                         fi_tmp[["mtime"]], msg)
[17:00:30.706]                       ex$message <- msg
[17:00:30.706]                       stop(ex)
[17:00:30.706]                     })
[17:00:30.706]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.706]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.706]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.706]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.706]                       fi <- file.info(pathname)
[17:00:30.706]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.706]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.706]                         fi[["size"]], fi[["mtime"]])
[17:00:30.706]                       stop(msg)
[17:00:30.706]                     }
[17:00:30.706]                     invisible(pathname)
[17:00:30.706]                   }
[17:00:30.706]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.706]                     rootPath = tempdir()) 
[17:00:30.706]                   {
[17:00:30.706]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.706]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.706]                       tmpdir = path, fileext = ".rds")
[17:00:30.706]                     save_rds(obj, file)
[17:00:30.706]                   }
[17:00:30.706]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.706]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.706]                   {
[17:00:30.706]                     inherits <- base::inherits
[17:00:30.706]                     invokeRestart <- base::invokeRestart
[17:00:30.706]                     is.null <- base::is.null
[17:00:30.706]                     muffled <- FALSE
[17:00:30.706]                     if (inherits(cond, "message")) {
[17:00:30.706]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.706]                       if (muffled) 
[17:00:30.706]                         invokeRestart("muffleMessage")
[17:00:30.706]                     }
[17:00:30.706]                     else if (inherits(cond, "warning")) {
[17:00:30.706]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.706]                       if (muffled) 
[17:00:30.706]                         invokeRestart("muffleWarning")
[17:00:30.706]                     }
[17:00:30.706]                     else if (inherits(cond, "condition")) {
[17:00:30.706]                       if (!is.null(pattern)) {
[17:00:30.706]                         computeRestarts <- base::computeRestarts
[17:00:30.706]                         grepl <- base::grepl
[17:00:30.706]                         restarts <- computeRestarts(cond)
[17:00:30.706]                         for (restart in restarts) {
[17:00:30.706]                           name <- restart$name
[17:00:30.706]                           if (is.null(name)) 
[17:00:30.706]                             next
[17:00:30.706]                           if (!grepl(pattern, name)) 
[17:00:30.706]                             next
[17:00:30.706]                           invokeRestart(restart)
[17:00:30.706]                           muffled <- TRUE
[17:00:30.706]                           break
[17:00:30.706]                         }
[17:00:30.706]                       }
[17:00:30.706]                     }
[17:00:30.706]                     invisible(muffled)
[17:00:30.706]                   }
[17:00:30.706]                   muffleCondition(cond)
[17:00:30.706]                 })
[17:00:30.706]             }))
[17:00:30.706]             future::FutureResult(value = ...future.value$value, 
[17:00:30.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.706]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.706]                     ...future.globalenv.names))
[17:00:30.706]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.706]         }, condition = base::local({
[17:00:30.706]             c <- base::c
[17:00:30.706]             inherits <- base::inherits
[17:00:30.706]             invokeRestart <- base::invokeRestart
[17:00:30.706]             length <- base::length
[17:00:30.706]             list <- base::list
[17:00:30.706]             seq.int <- base::seq.int
[17:00:30.706]             signalCondition <- base::signalCondition
[17:00:30.706]             sys.calls <- base::sys.calls
[17:00:30.706]             `[[` <- base::`[[`
[17:00:30.706]             `+` <- base::`+`
[17:00:30.706]             `<<-` <- base::`<<-`
[17:00:30.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.706]                   3L)]
[17:00:30.706]             }
[17:00:30.706]             function(cond) {
[17:00:30.706]                 is_error <- inherits(cond, "error")
[17:00:30.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.706]                   NULL)
[17:00:30.706]                 if (is_error) {
[17:00:30.706]                   sessionInformation <- function() {
[17:00:30.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.706]                       search = base::search(), system = base::Sys.info())
[17:00:30.706]                   }
[17:00:30.706]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.706]                     cond$call), session = sessionInformation(), 
[17:00:30.706]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.706]                   signalCondition(cond)
[17:00:30.706]                 }
[17:00:30.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.706]                 "immediateCondition"))) {
[17:00:30.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.706]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.706]                   if (TRUE && !signal) {
[17:00:30.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.706]                     {
[17:00:30.706]                       inherits <- base::inherits
[17:00:30.706]                       invokeRestart <- base::invokeRestart
[17:00:30.706]                       is.null <- base::is.null
[17:00:30.706]                       muffled <- FALSE
[17:00:30.706]                       if (inherits(cond, "message")) {
[17:00:30.706]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.706]                         if (muffled) 
[17:00:30.706]                           invokeRestart("muffleMessage")
[17:00:30.706]                       }
[17:00:30.706]                       else if (inherits(cond, "warning")) {
[17:00:30.706]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.706]                         if (muffled) 
[17:00:30.706]                           invokeRestart("muffleWarning")
[17:00:30.706]                       }
[17:00:30.706]                       else if (inherits(cond, "condition")) {
[17:00:30.706]                         if (!is.null(pattern)) {
[17:00:30.706]                           computeRestarts <- base::computeRestarts
[17:00:30.706]                           grepl <- base::grepl
[17:00:30.706]                           restarts <- computeRestarts(cond)
[17:00:30.706]                           for (restart in restarts) {
[17:00:30.706]                             name <- restart$name
[17:00:30.706]                             if (is.null(name)) 
[17:00:30.706]                               next
[17:00:30.706]                             if (!grepl(pattern, name)) 
[17:00:30.706]                               next
[17:00:30.706]                             invokeRestart(restart)
[17:00:30.706]                             muffled <- TRUE
[17:00:30.706]                             break
[17:00:30.706]                           }
[17:00:30.706]                         }
[17:00:30.706]                       }
[17:00:30.706]                       invisible(muffled)
[17:00:30.706]                     }
[17:00:30.706]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.706]                   }
[17:00:30.706]                 }
[17:00:30.706]                 else {
[17:00:30.706]                   if (TRUE) {
[17:00:30.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.706]                     {
[17:00:30.706]                       inherits <- base::inherits
[17:00:30.706]                       invokeRestart <- base::invokeRestart
[17:00:30.706]                       is.null <- base::is.null
[17:00:30.706]                       muffled <- FALSE
[17:00:30.706]                       if (inherits(cond, "message")) {
[17:00:30.706]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.706]                         if (muffled) 
[17:00:30.706]                           invokeRestart("muffleMessage")
[17:00:30.706]                       }
[17:00:30.706]                       else if (inherits(cond, "warning")) {
[17:00:30.706]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.706]                         if (muffled) 
[17:00:30.706]                           invokeRestart("muffleWarning")
[17:00:30.706]                       }
[17:00:30.706]                       else if (inherits(cond, "condition")) {
[17:00:30.706]                         if (!is.null(pattern)) {
[17:00:30.706]                           computeRestarts <- base::computeRestarts
[17:00:30.706]                           grepl <- base::grepl
[17:00:30.706]                           restarts <- computeRestarts(cond)
[17:00:30.706]                           for (restart in restarts) {
[17:00:30.706]                             name <- restart$name
[17:00:30.706]                             if (is.null(name)) 
[17:00:30.706]                               next
[17:00:30.706]                             if (!grepl(pattern, name)) 
[17:00:30.706]                               next
[17:00:30.706]                             invokeRestart(restart)
[17:00:30.706]                             muffled <- TRUE
[17:00:30.706]                             break
[17:00:30.706]                           }
[17:00:30.706]                         }
[17:00:30.706]                       }
[17:00:30.706]                       invisible(muffled)
[17:00:30.706]                     }
[17:00:30.706]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.706]                   }
[17:00:30.706]                 }
[17:00:30.706]             }
[17:00:30.706]         }))
[17:00:30.706]     }, error = function(ex) {
[17:00:30.706]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.706]                 ...future.rng), started = ...future.startTime, 
[17:00:30.706]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.706]             version = "1.8"), class = "FutureResult")
[17:00:30.706]     }, finally = {
[17:00:30.706]         if (!identical(...future.workdir, getwd())) 
[17:00:30.706]             setwd(...future.workdir)
[17:00:30.706]         {
[17:00:30.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.706]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.706]             }
[17:00:30.706]             base::options(...future.oldOptions)
[17:00:30.706]             if (.Platform$OS.type == "windows") {
[17:00:30.706]                 old_names <- names(...future.oldEnvVars)
[17:00:30.706]                 envs <- base::Sys.getenv()
[17:00:30.706]                 names <- names(envs)
[17:00:30.706]                 common <- intersect(names, old_names)
[17:00:30.706]                 added <- setdiff(names, old_names)
[17:00:30.706]                 removed <- setdiff(old_names, names)
[17:00:30.706]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.706]                   envs[common]]
[17:00:30.706]                 NAMES <- toupper(changed)
[17:00:30.706]                 args <- list()
[17:00:30.706]                 for (kk in seq_along(NAMES)) {
[17:00:30.706]                   name <- changed[[kk]]
[17:00:30.706]                   NAME <- NAMES[[kk]]
[17:00:30.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.706]                     next
[17:00:30.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.706]                 }
[17:00:30.706]                 NAMES <- toupper(added)
[17:00:30.706]                 for (kk in seq_along(NAMES)) {
[17:00:30.706]                   name <- added[[kk]]
[17:00:30.706]                   NAME <- NAMES[[kk]]
[17:00:30.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.706]                     next
[17:00:30.706]                   args[[name]] <- ""
[17:00:30.706]                 }
[17:00:30.706]                 NAMES <- toupper(removed)
[17:00:30.706]                 for (kk in seq_along(NAMES)) {
[17:00:30.706]                   name <- removed[[kk]]
[17:00:30.706]                   NAME <- NAMES[[kk]]
[17:00:30.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.706]                     next
[17:00:30.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.706]                 }
[17:00:30.706]                 if (length(args) > 0) 
[17:00:30.706]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.706]             }
[17:00:30.706]             else {
[17:00:30.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.706]             }
[17:00:30.706]             {
[17:00:30.706]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.706]                   0L) {
[17:00:30.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.706]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.706]                   base::options(opts)
[17:00:30.706]                 }
[17:00:30.706]                 {
[17:00:30.706]                   {
[17:00:30.706]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.706]                     NULL
[17:00:30.706]                   }
[17:00:30.706]                   options(future.plan = NULL)
[17:00:30.706]                   if (is.na(NA_character_)) 
[17:00:30.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.706]                     .init = FALSE)
[17:00:30.706]                 }
[17:00:30.706]             }
[17:00:30.706]         }
[17:00:30.706]     })
[17:00:30.706]     if (TRUE) {
[17:00:30.706]         base::sink(type = "output", split = FALSE)
[17:00:30.706]         if (TRUE) {
[17:00:30.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.706]         }
[17:00:30.706]         else {
[17:00:30.706]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.706]         }
[17:00:30.706]         base::close(...future.stdout)
[17:00:30.706]         ...future.stdout <- NULL
[17:00:30.706]     }
[17:00:30.706]     ...future.result$conditions <- ...future.conditions
[17:00:30.706]     ...future.result$finished <- base::Sys.time()
[17:00:30.706]     ...future.result
[17:00:30.706] }
[17:00:30.708] assign_globals() ...
[17:00:30.708] List of 5
[17:00:30.708]  $ ...future.FUN            :function (x)  
[17:00:30.708]  $ MoreArgs                 : list()
[17:00:30.708]  $ ...future.elements_ii    :List of 1
[17:00:30.708]   ..$ :List of 1
[17:00:30.708]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:00:30.708]  $ ...future.seeds_ii       : NULL
[17:00:30.708]  $ ...future.globals.maxSize: NULL
[17:00:30.708]  - attr(*, "where")=List of 5
[17:00:30.708]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.708]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.708]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.708]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.708]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.708]  - attr(*, "resolved")= logi FALSE
[17:00:30.708]  - attr(*, "total_size")= num 1128
[17:00:30.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.708]  - attr(*, "already-done")= logi TRUE
[17:00:30.714] - copied ‘...future.FUN’ to environment
[17:00:30.714] - copied ‘MoreArgs’ to environment
[17:00:30.714] - copied ‘...future.elements_ii’ to environment
[17:00:30.714] - copied ‘...future.seeds_ii’ to environment
[17:00:30.714] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.714] assign_globals() ... done
[17:00:30.714] requestCore(): workers = 2
[17:00:30.717] MulticoreFuture started
[17:00:30.717] - Launch lazy future ... done
[17:00:30.717] run() for ‘MulticoreFuture’ ... done
[17:00:30.717] Created future:
[17:00:30.717] plan(): Setting new future strategy stack:
[17:00:30.718] List of future strategies:
[17:00:30.718] 1. sequential:
[17:00:30.718]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.718]    - tweaked: FALSE
[17:00:30.718]    - call: NULL
[17:00:30.719] plan(): nbrOfWorkers() = 1
[17:00:30.721] plan(): Setting new future strategy stack:
[17:00:30.721] List of future strategies:
[17:00:30.721] 1. multicore:
[17:00:30.721]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.721]    - tweaked: FALSE
[17:00:30.721]    - call: plan(strategy)
[17:00:30.726] plan(): nbrOfWorkers() = 2
[17:00:30.718] MulticoreFuture:
[17:00:30.718] Label: ‘future_.mapply-1’
[17:00:30.718] Expression:
[17:00:30.718] {
[17:00:30.718]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.718]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.718]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.718]         on.exit(options(oopts), add = TRUE)
[17:00:30.718]     }
[17:00:30.718]     {
[17:00:30.718]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.718]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.718]         do.call(mapply, args = args)
[17:00:30.718]     }
[17:00:30.718] }
[17:00:30.718] Lazy evaluation: FALSE
[17:00:30.718] Asynchronous evaluation: TRUE
[17:00:30.718] Local evaluation: TRUE
[17:00:30.718] Environment: R_GlobalEnv
[17:00:30.718] Capture standard output: TRUE
[17:00:30.718] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.718] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.718] Packages: <none>
[17:00:30.718] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.718] Resolved: TRUE
[17:00:30.718] Value: <not collected>
[17:00:30.718] Conditions captured: <none>
[17:00:30.718] Early signaling: FALSE
[17:00:30.718] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.718] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.727] Chunk #1 of 1 ... DONE
[17:00:30.728] Launching 1 futures (chunks) ... DONE
[17:00:30.728] Resolving 1 futures (chunks) ...
[17:00:30.728] resolve() on list ...
[17:00:30.728]  recursive: 0
[17:00:30.728]  length: 1
[17:00:30.728] 
[17:00:30.729] Future #1
[17:00:30.729] result() for MulticoreFuture ...
[17:00:30.730] result() for MulticoreFuture ...
[17:00:30.730] result() for MulticoreFuture ... done
[17:00:30.730] result() for MulticoreFuture ... done
[17:00:30.730] result() for MulticoreFuture ...
[17:00:30.730] result() for MulticoreFuture ... done
[17:00:30.730] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:30.730] - nx: 1
[17:00:30.731] - relay: TRUE
[17:00:30.731] - stdout: TRUE
[17:00:30.731] - signal: TRUE
[17:00:30.731] - resignal: FALSE
[17:00:30.731] - force: TRUE
[17:00:30.731] - relayed: [n=1] FALSE
[17:00:30.731] - queued futures: [n=1] FALSE
[17:00:30.732]  - until=1
[17:00:30.732]  - relaying element #1
[17:00:30.732] result() for MulticoreFuture ...
[17:00:30.732] result() for MulticoreFuture ... done
[17:00:30.732] result() for MulticoreFuture ...
[17:00:30.732] result() for MulticoreFuture ... done
[17:00:30.732] result() for MulticoreFuture ...
[17:00:30.732] result() for MulticoreFuture ... done
[17:00:30.733] result() for MulticoreFuture ...
[17:00:30.733] result() for MulticoreFuture ... done
[17:00:30.733] - relayed: [n=1] TRUE
[17:00:30.733] - queued futures: [n=1] TRUE
[17:00:30.733] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:30.733]  length: 0 (resolved future 1)
[17:00:30.733] Relaying remaining futures
[17:00:30.733] signalConditionsASAP(NULL, pos=0) ...
[17:00:30.734] - nx: 1
[17:00:30.734] - relay: TRUE
[17:00:30.734] - stdout: TRUE
[17:00:30.734] - signal: TRUE
[17:00:30.734] - resignal: FALSE
[17:00:30.734] - force: TRUE
[17:00:30.734] - relayed: [n=1] TRUE
[17:00:30.734] - queued futures: [n=1] TRUE
 - flush all
[17:00:30.734] - relayed: [n=1] TRUE
[17:00:30.735] - queued futures: [n=1] TRUE
[17:00:30.735] signalConditionsASAP(NULL, pos=0) ... done
[17:00:30.735] resolve() on list ... DONE
[17:00:30.735] result() for MulticoreFuture ...
[17:00:30.735] result() for MulticoreFuture ... done
[17:00:30.735] result() for MulticoreFuture ...
[17:00:30.735] result() for MulticoreFuture ... done
[17:00:30.735]  - Number of value chunks collected: 1
[17:00:30.736] Resolving 1 futures (chunks) ... DONE
[17:00:30.736] Reducing values from 1 chunks ...
[17:00:30.736]  - Number of values collected after concatenation: 1
[17:00:30.736]  - Number of values expected: 1
[17:00:30.736] Reducing values from 1 chunks ... DONE
[17:00:30.736] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[17:00:30.736] future_mapply() ...
[17:00:30.741] Number of chunks: 2
[17:00:30.741] getGlobalsAndPackagesXApply() ...
[17:00:30.741]  - future.globals: TRUE
[17:00:30.744] getGlobalsAndPackages() ...
[17:00:30.745] Searching for globals...
[17:00:30.746] - globals found: [1] ‘FUN’
[17:00:30.747] Searching for globals ... DONE
[17:00:30.747] Resolving globals: FALSE
[17:00:30.747] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:00:30.748] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:00:30.748] - globals: [1] ‘FUN’
[17:00:30.748] 
[17:00:30.748] getGlobalsAndPackages() ... DONE
[17:00:30.748]  - globals found/used: [n=1] ‘FUN’
[17:00:30.749]  - needed namespaces: [n=0] 
[17:00:30.749] Finding globals ... DONE
[17:00:30.749] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:30.749] List of 2
[17:00:30.749]  $ ...future.FUN:function (x, y)  
[17:00:30.749]  $ MoreArgs     :List of 1
[17:00:30.749]   ..$ y: int [1:2] 3 4
[17:00:30.749]  - attr(*, "where")=List of 2
[17:00:30.749]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:30.749]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:30.749]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.749]  - attr(*, "resolved")= logi FALSE
[17:00:30.749]  - attr(*, "total_size")= num NA
[17:00:30.753] Packages to be attached in all futures: [n=0] 
[17:00:30.753] getGlobalsAndPackagesXApply() ... DONE
[17:00:30.754] Number of futures (= number of chunks): 2
[17:00:30.754] Launching 2 futures (chunks) ...
[17:00:30.754] Chunk #1 of 2 ...
[17:00:30.754]  - Finding globals in '...' for chunk #1 ...
[17:00:30.754] getGlobalsAndPackages() ...
[17:00:30.754] Searching for globals...
[17:00:30.755] 
[17:00:30.755] Searching for globals ... DONE
[17:00:30.755] - globals: [0] <none>
[17:00:30.755] getGlobalsAndPackages() ... DONE
[17:00:30.755]    + additional globals found: [n=0] 
[17:00:30.755]    + additional namespaces needed: [n=0] 
[17:00:30.755]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:30.755]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:30.756]  - seeds: <none>
[17:00:30.756]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.756] getGlobalsAndPackages() ...
[17:00:30.756] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.756] Resolving globals: FALSE
[17:00:30.756] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:00:30.757] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:00:30.757] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.757] 
[17:00:30.757] getGlobalsAndPackages() ... DONE
[17:00:30.758] run() for ‘Future’ ...
[17:00:30.758] - state: ‘created’
[17:00:30.758] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.762] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.762]   - Field: ‘label’
[17:00:30.762]   - Field: ‘local’
[17:00:30.762]   - Field: ‘owner’
[17:00:30.762]   - Field: ‘envir’
[17:00:30.762]   - Field: ‘workers’
[17:00:30.762]   - Field: ‘packages’
[17:00:30.763]   - Field: ‘gc’
[17:00:30.763]   - Field: ‘job’
[17:00:30.763]   - Field: ‘conditions’
[17:00:30.763]   - Field: ‘expr’
[17:00:30.763]   - Field: ‘uuid’
[17:00:30.763]   - Field: ‘seed’
[17:00:30.763]   - Field: ‘version’
[17:00:30.763]   - Field: ‘result’
[17:00:30.763]   - Field: ‘asynchronous’
[17:00:30.763]   - Field: ‘calls’
[17:00:30.763]   - Field: ‘globals’
[17:00:30.764]   - Field: ‘stdout’
[17:00:30.764]   - Field: ‘earlySignal’
[17:00:30.764]   - Field: ‘lazy’
[17:00:30.764]   - Field: ‘state’
[17:00:30.764] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.764] - Launch lazy future ...
[17:00:30.764] Packages needed by the future expression (n = 0): <none>
[17:00:30.764] Packages needed by future strategies (n = 0): <none>
[17:00:30.765] {
[17:00:30.765]     {
[17:00:30.765]         {
[17:00:30.765]             ...future.startTime <- base::Sys.time()
[17:00:30.765]             {
[17:00:30.765]                 {
[17:00:30.765]                   {
[17:00:30.765]                     {
[17:00:30.765]                       base::local({
[17:00:30.765]                         has_future <- base::requireNamespace("future", 
[17:00:30.765]                           quietly = TRUE)
[17:00:30.765]                         if (has_future) {
[17:00:30.765]                           ns <- base::getNamespace("future")
[17:00:30.765]                           version <- ns[[".package"]][["version"]]
[17:00:30.765]                           if (is.null(version)) 
[17:00:30.765]                             version <- utils::packageVersion("future")
[17:00:30.765]                         }
[17:00:30.765]                         else {
[17:00:30.765]                           version <- NULL
[17:00:30.765]                         }
[17:00:30.765]                         if (!has_future || version < "1.8.0") {
[17:00:30.765]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.765]                             "", base::R.version$version.string), 
[17:00:30.765]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.765]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.765]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.765]                               "release", "version")], collapse = " "), 
[17:00:30.765]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.765]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.765]                             info)
[17:00:30.765]                           info <- base::paste(info, collapse = "; ")
[17:00:30.765]                           if (!has_future) {
[17:00:30.765]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.765]                               info)
[17:00:30.765]                           }
[17:00:30.765]                           else {
[17:00:30.765]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.765]                               info, version)
[17:00:30.765]                           }
[17:00:30.765]                           base::stop(msg)
[17:00:30.765]                         }
[17:00:30.765]                       })
[17:00:30.765]                     }
[17:00:30.765]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.765]                     base::options(mc.cores = 1L)
[17:00:30.765]                   }
[17:00:30.765]                   ...future.strategy.old <- future::plan("list")
[17:00:30.765]                   options(future.plan = NULL)
[17:00:30.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.765]                 }
[17:00:30.765]                 ...future.workdir <- getwd()
[17:00:30.765]             }
[17:00:30.765]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.765]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.765]         }
[17:00:30.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.765]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.765]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.765]             base::names(...future.oldOptions))
[17:00:30.765]     }
[17:00:30.765]     if (FALSE) {
[17:00:30.765]     }
[17:00:30.765]     else {
[17:00:30.765]         if (TRUE) {
[17:00:30.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.765]                 open = "w")
[17:00:30.765]         }
[17:00:30.765]         else {
[17:00:30.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.765]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.765]         }
[17:00:30.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.765]             base::sink(type = "output", split = FALSE)
[17:00:30.765]             base::close(...future.stdout)
[17:00:30.765]         }, add = TRUE)
[17:00:30.765]     }
[17:00:30.765]     ...future.frame <- base::sys.nframe()
[17:00:30.765]     ...future.conditions <- base::list()
[17:00:30.765]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.765]     if (FALSE) {
[17:00:30.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.765]     }
[17:00:30.765]     ...future.result <- base::tryCatch({
[17:00:30.765]         base::withCallingHandlers({
[17:00:30.765]             ...future.value <- base::withVisible(base::local({
[17:00:30.765]                 withCallingHandlers({
[17:00:30.765]                   {
[17:00:30.765]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.765]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.765]                       ...future.globals.maxSize)) {
[17:00:30.765]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.765]                       on.exit(options(oopts), add = TRUE)
[17:00:30.765]                     }
[17:00:30.765]                     {
[17:00:30.765]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.765]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.765]                         USE.NAMES = FALSE)
[17:00:30.765]                       do.call(mapply, args = args)
[17:00:30.765]                     }
[17:00:30.765]                   }
[17:00:30.765]                 }, immediateCondition = function(cond) {
[17:00:30.765]                   save_rds <- function (object, pathname, ...) 
[17:00:30.765]                   {
[17:00:30.765]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.765]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.765]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.765]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.765]                         fi_tmp[["mtime"]])
[17:00:30.765]                     }
[17:00:30.765]                     tryCatch({
[17:00:30.765]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.765]                     }, error = function(ex) {
[17:00:30.765]                       msg <- conditionMessage(ex)
[17:00:30.765]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.765]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.765]                         fi_tmp[["mtime"]], msg)
[17:00:30.765]                       ex$message <- msg
[17:00:30.765]                       stop(ex)
[17:00:30.765]                     })
[17:00:30.765]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.765]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.765]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.765]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.765]                       fi <- file.info(pathname)
[17:00:30.765]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.765]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.765]                         fi[["size"]], fi[["mtime"]])
[17:00:30.765]                       stop(msg)
[17:00:30.765]                     }
[17:00:30.765]                     invisible(pathname)
[17:00:30.765]                   }
[17:00:30.765]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.765]                     rootPath = tempdir()) 
[17:00:30.765]                   {
[17:00:30.765]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.765]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.765]                       tmpdir = path, fileext = ".rds")
[17:00:30.765]                     save_rds(obj, file)
[17:00:30.765]                   }
[17:00:30.765]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.765]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.765]                   {
[17:00:30.765]                     inherits <- base::inherits
[17:00:30.765]                     invokeRestart <- base::invokeRestart
[17:00:30.765]                     is.null <- base::is.null
[17:00:30.765]                     muffled <- FALSE
[17:00:30.765]                     if (inherits(cond, "message")) {
[17:00:30.765]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.765]                       if (muffled) 
[17:00:30.765]                         invokeRestart("muffleMessage")
[17:00:30.765]                     }
[17:00:30.765]                     else if (inherits(cond, "warning")) {
[17:00:30.765]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.765]                       if (muffled) 
[17:00:30.765]                         invokeRestart("muffleWarning")
[17:00:30.765]                     }
[17:00:30.765]                     else if (inherits(cond, "condition")) {
[17:00:30.765]                       if (!is.null(pattern)) {
[17:00:30.765]                         computeRestarts <- base::computeRestarts
[17:00:30.765]                         grepl <- base::grepl
[17:00:30.765]                         restarts <- computeRestarts(cond)
[17:00:30.765]                         for (restart in restarts) {
[17:00:30.765]                           name <- restart$name
[17:00:30.765]                           if (is.null(name)) 
[17:00:30.765]                             next
[17:00:30.765]                           if (!grepl(pattern, name)) 
[17:00:30.765]                             next
[17:00:30.765]                           invokeRestart(restart)
[17:00:30.765]                           muffled <- TRUE
[17:00:30.765]                           break
[17:00:30.765]                         }
[17:00:30.765]                       }
[17:00:30.765]                     }
[17:00:30.765]                     invisible(muffled)
[17:00:30.765]                   }
[17:00:30.765]                   muffleCondition(cond)
[17:00:30.765]                 })
[17:00:30.765]             }))
[17:00:30.765]             future::FutureResult(value = ...future.value$value, 
[17:00:30.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.765]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.765]                     ...future.globalenv.names))
[17:00:30.765]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.765]         }, condition = base::local({
[17:00:30.765]             c <- base::c
[17:00:30.765]             inherits <- base::inherits
[17:00:30.765]             invokeRestart <- base::invokeRestart
[17:00:30.765]             length <- base::length
[17:00:30.765]             list <- base::list
[17:00:30.765]             seq.int <- base::seq.int
[17:00:30.765]             signalCondition <- base::signalCondition
[17:00:30.765]             sys.calls <- base::sys.calls
[17:00:30.765]             `[[` <- base::`[[`
[17:00:30.765]             `+` <- base::`+`
[17:00:30.765]             `<<-` <- base::`<<-`
[17:00:30.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.765]                   3L)]
[17:00:30.765]             }
[17:00:30.765]             function(cond) {
[17:00:30.765]                 is_error <- inherits(cond, "error")
[17:00:30.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.765]                   NULL)
[17:00:30.765]                 if (is_error) {
[17:00:30.765]                   sessionInformation <- function() {
[17:00:30.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.765]                       search = base::search(), system = base::Sys.info())
[17:00:30.765]                   }
[17:00:30.765]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.765]                     cond$call), session = sessionInformation(), 
[17:00:30.765]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.765]                   signalCondition(cond)
[17:00:30.765]                 }
[17:00:30.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.765]                 "immediateCondition"))) {
[17:00:30.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.765]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.765]                   if (TRUE && !signal) {
[17:00:30.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.765]                     {
[17:00:30.765]                       inherits <- base::inherits
[17:00:30.765]                       invokeRestart <- base::invokeRestart
[17:00:30.765]                       is.null <- base::is.null
[17:00:30.765]                       muffled <- FALSE
[17:00:30.765]                       if (inherits(cond, "message")) {
[17:00:30.765]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.765]                         if (muffled) 
[17:00:30.765]                           invokeRestart("muffleMessage")
[17:00:30.765]                       }
[17:00:30.765]                       else if (inherits(cond, "warning")) {
[17:00:30.765]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.765]                         if (muffled) 
[17:00:30.765]                           invokeRestart("muffleWarning")
[17:00:30.765]                       }
[17:00:30.765]                       else if (inherits(cond, "condition")) {
[17:00:30.765]                         if (!is.null(pattern)) {
[17:00:30.765]                           computeRestarts <- base::computeRestarts
[17:00:30.765]                           grepl <- base::grepl
[17:00:30.765]                           restarts <- computeRestarts(cond)
[17:00:30.765]                           for (restart in restarts) {
[17:00:30.765]                             name <- restart$name
[17:00:30.765]                             if (is.null(name)) 
[17:00:30.765]                               next
[17:00:30.765]                             if (!grepl(pattern, name)) 
[17:00:30.765]                               next
[17:00:30.765]                             invokeRestart(restart)
[17:00:30.765]                             muffled <- TRUE
[17:00:30.765]                             break
[17:00:30.765]                           }
[17:00:30.765]                         }
[17:00:30.765]                       }
[17:00:30.765]                       invisible(muffled)
[17:00:30.765]                     }
[17:00:30.765]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.765]                   }
[17:00:30.765]                 }
[17:00:30.765]                 else {
[17:00:30.765]                   if (TRUE) {
[17:00:30.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.765]                     {
[17:00:30.765]                       inherits <- base::inherits
[17:00:30.765]                       invokeRestart <- base::invokeRestart
[17:00:30.765]                       is.null <- base::is.null
[17:00:30.765]                       muffled <- FALSE
[17:00:30.765]                       if (inherits(cond, "message")) {
[17:00:30.765]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.765]                         if (muffled) 
[17:00:30.765]                           invokeRestart("muffleMessage")
[17:00:30.765]                       }
[17:00:30.765]                       else if (inherits(cond, "warning")) {
[17:00:30.765]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.765]                         if (muffled) 
[17:00:30.765]                           invokeRestart("muffleWarning")
[17:00:30.765]                       }
[17:00:30.765]                       else if (inherits(cond, "condition")) {
[17:00:30.765]                         if (!is.null(pattern)) {
[17:00:30.765]                           computeRestarts <- base::computeRestarts
[17:00:30.765]                           grepl <- base::grepl
[17:00:30.765]                           restarts <- computeRestarts(cond)
[17:00:30.765]                           for (restart in restarts) {
[17:00:30.765]                             name <- restart$name
[17:00:30.765]                             if (is.null(name)) 
[17:00:30.765]                               next
[17:00:30.765]                             if (!grepl(pattern, name)) 
[17:00:30.765]                               next
[17:00:30.765]                             invokeRestart(restart)
[17:00:30.765]                             muffled <- TRUE
[17:00:30.765]                             break
[17:00:30.765]                           }
[17:00:30.765]                         }
[17:00:30.765]                       }
[17:00:30.765]                       invisible(muffled)
[17:00:30.765]                     }
[17:00:30.765]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.765]                   }
[17:00:30.765]                 }
[17:00:30.765]             }
[17:00:30.765]         }))
[17:00:30.765]     }, error = function(ex) {
[17:00:30.765]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.765]                 ...future.rng), started = ...future.startTime, 
[17:00:30.765]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.765]             version = "1.8"), class = "FutureResult")
[17:00:30.765]     }, finally = {
[17:00:30.765]         if (!identical(...future.workdir, getwd())) 
[17:00:30.765]             setwd(...future.workdir)
[17:00:30.765]         {
[17:00:30.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.765]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.765]             }
[17:00:30.765]             base::options(...future.oldOptions)
[17:00:30.765]             if (.Platform$OS.type == "windows") {
[17:00:30.765]                 old_names <- names(...future.oldEnvVars)
[17:00:30.765]                 envs <- base::Sys.getenv()
[17:00:30.765]                 names <- names(envs)
[17:00:30.765]                 common <- intersect(names, old_names)
[17:00:30.765]                 added <- setdiff(names, old_names)
[17:00:30.765]                 removed <- setdiff(old_names, names)
[17:00:30.765]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.765]                   envs[common]]
[17:00:30.765]                 NAMES <- toupper(changed)
[17:00:30.765]                 args <- list()
[17:00:30.765]                 for (kk in seq_along(NAMES)) {
[17:00:30.765]                   name <- changed[[kk]]
[17:00:30.765]                   NAME <- NAMES[[kk]]
[17:00:30.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.765]                     next
[17:00:30.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.765]                 }
[17:00:30.765]                 NAMES <- toupper(added)
[17:00:30.765]                 for (kk in seq_along(NAMES)) {
[17:00:30.765]                   name <- added[[kk]]
[17:00:30.765]                   NAME <- NAMES[[kk]]
[17:00:30.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.765]                     next
[17:00:30.765]                   args[[name]] <- ""
[17:00:30.765]                 }
[17:00:30.765]                 NAMES <- toupper(removed)
[17:00:30.765]                 for (kk in seq_along(NAMES)) {
[17:00:30.765]                   name <- removed[[kk]]
[17:00:30.765]                   NAME <- NAMES[[kk]]
[17:00:30.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.765]                     next
[17:00:30.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.765]                 }
[17:00:30.765]                 if (length(args) > 0) 
[17:00:30.765]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.765]             }
[17:00:30.765]             else {
[17:00:30.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.765]             }
[17:00:30.765]             {
[17:00:30.765]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.765]                   0L) {
[17:00:30.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.765]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.765]                   base::options(opts)
[17:00:30.765]                 }
[17:00:30.765]                 {
[17:00:30.765]                   {
[17:00:30.765]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.765]                     NULL
[17:00:30.765]                   }
[17:00:30.765]                   options(future.plan = NULL)
[17:00:30.765]                   if (is.na(NA_character_)) 
[17:00:30.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.765]                     .init = FALSE)
[17:00:30.765]                 }
[17:00:30.765]             }
[17:00:30.765]         }
[17:00:30.765]     })
[17:00:30.765]     if (TRUE) {
[17:00:30.765]         base::sink(type = "output", split = FALSE)
[17:00:30.765]         if (TRUE) {
[17:00:30.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.765]         }
[17:00:30.765]         else {
[17:00:30.765]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.765]         }
[17:00:30.765]         base::close(...future.stdout)
[17:00:30.765]         ...future.stdout <- NULL
[17:00:30.765]     }
[17:00:30.765]     ...future.result$conditions <- ...future.conditions
[17:00:30.765]     ...future.result$finished <- base::Sys.time()
[17:00:30.765]     ...future.result
[17:00:30.765] }
[17:00:30.767] assign_globals() ...
[17:00:30.768] List of 5
[17:00:30.768]  $ ...future.FUN            :function (x, y)  
[17:00:30.768]  $ MoreArgs                 :List of 1
[17:00:30.768]   ..$ y: int [1:2] 3 4
[17:00:30.768]  $ ...future.elements_ii    :List of 1
[17:00:30.768]   ..$ x:List of 1
[17:00:30.768]   .. ..$ : int 1
[17:00:30.768]  $ ...future.seeds_ii       : NULL
[17:00:30.768]  $ ...future.globals.maxSize: NULL
[17:00:30.768]  - attr(*, "where")=List of 5
[17:00:30.768]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.768]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.768]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.768]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.768]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.768]  - attr(*, "resolved")= logi FALSE
[17:00:30.768]  - attr(*, "total_size")= num 1816
[17:00:30.768]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.768]  - attr(*, "already-done")= logi TRUE
[17:00:30.776] - reassign environment for ‘...future.FUN’
[17:00:30.776] - copied ‘...future.FUN’ to environment
[17:00:30.776] - copied ‘MoreArgs’ to environment
[17:00:30.776] - copied ‘...future.elements_ii’ to environment
[17:00:30.776] - copied ‘...future.seeds_ii’ to environment
[17:00:30.776] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.776] assign_globals() ... done
[17:00:30.777] requestCore(): workers = 2
[17:00:30.779] MulticoreFuture started
[17:00:30.780] - Launch lazy future ... done
[17:00:30.781] plan(): Setting new future strategy stack:
[17:00:30.781] run() for ‘MulticoreFuture’ ... done
[17:00:30.781] Created future:
[17:00:30.781] List of future strategies:
[17:00:30.781] 1. sequential:
[17:00:30.781]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.781]    - tweaked: FALSE
[17:00:30.781]    - call: NULL
[17:00:30.783] plan(): nbrOfWorkers() = 1
[17:00:30.786] plan(): Setting new future strategy stack:
[17:00:30.786] List of future strategies:
[17:00:30.786] 1. multicore:
[17:00:30.786]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.786]    - tweaked: FALSE
[17:00:30.786]    - call: plan(strategy)
[17:00:30.792] plan(): nbrOfWorkers() = 2
[17:00:30.782] MulticoreFuture:
[17:00:30.782] Label: ‘future_mapply-1’
[17:00:30.782] Expression:
[17:00:30.782] {
[17:00:30.782]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.782]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.782]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.782]         on.exit(options(oopts), add = TRUE)
[17:00:30.782]     }
[17:00:30.782]     {
[17:00:30.782]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.782]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.782]         do.call(mapply, args = args)
[17:00:30.782]     }
[17:00:30.782] }
[17:00:30.782] Lazy evaluation: FALSE
[17:00:30.782] Asynchronous evaluation: TRUE
[17:00:30.782] Local evaluation: TRUE
[17:00:30.782] Environment: R_GlobalEnv
[17:00:30.782] Capture standard output: TRUE
[17:00:30.782] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.782] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.782] Packages: <none>
[17:00:30.782] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.782] Resolved: TRUE
[17:00:30.782] Value: <not collected>
[17:00:30.782] Conditions captured: <none>
[17:00:30.782] Early signaling: FALSE
[17:00:30.782] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.782] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.794] Chunk #1 of 2 ... DONE
[17:00:30.794] Chunk #2 of 2 ...
[17:00:30.794]  - Finding globals in '...' for chunk #2 ...
[17:00:30.794] getGlobalsAndPackages() ...
[17:00:30.795] Searching for globals...
[17:00:30.796] 
[17:00:30.796] Searching for globals ... DONE
[17:00:30.796] - globals: [0] <none>
[17:00:30.796] getGlobalsAndPackages() ... DONE
[17:00:30.796]    + additional globals found: [n=0] 
[17:00:30.796]    + additional namespaces needed: [n=0] 
[17:00:30.797]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:30.797]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:30.797]  - seeds: <none>
[17:00:30.797]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.797] getGlobalsAndPackages() ...
[17:00:30.797] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.797] Resolving globals: FALSE
[17:00:30.798] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:00:30.799] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:00:30.799] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.800] 
[17:00:30.800] getGlobalsAndPackages() ... DONE
[17:00:30.800] run() for ‘Future’ ...
[17:00:30.800] - state: ‘created’
[17:00:30.801] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.806] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.806]   - Field: ‘label’
[17:00:30.806]   - Field: ‘local’
[17:00:30.806]   - Field: ‘owner’
[17:00:30.806]   - Field: ‘envir’
[17:00:30.807]   - Field: ‘workers’
[17:00:30.807]   - Field: ‘packages’
[17:00:30.807]   - Field: ‘gc’
[17:00:30.807]   - Field: ‘job’
[17:00:30.807]   - Field: ‘conditions’
[17:00:30.807]   - Field: ‘expr’
[17:00:30.808]   - Field: ‘uuid’
[17:00:30.808]   - Field: ‘seed’
[17:00:30.808]   - Field: ‘version’
[17:00:30.808]   - Field: ‘result’
[17:00:30.808]   - Field: ‘asynchronous’
[17:00:30.808]   - Field: ‘calls’
[17:00:30.808]   - Field: ‘globals’
[17:00:30.808]   - Field: ‘stdout’
[17:00:30.809]   - Field: ‘earlySignal’
[17:00:30.809]   - Field: ‘lazy’
[17:00:30.809]   - Field: ‘state’
[17:00:30.809] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.809] - Launch lazy future ...
[17:00:30.809] Packages needed by the future expression (n = 0): <none>
[17:00:30.810] Packages needed by future strategies (n = 0): <none>
[17:00:30.810] {
[17:00:30.810]     {
[17:00:30.810]         {
[17:00:30.810]             ...future.startTime <- base::Sys.time()
[17:00:30.810]             {
[17:00:30.810]                 {
[17:00:30.810]                   {
[17:00:30.810]                     {
[17:00:30.810]                       base::local({
[17:00:30.810]                         has_future <- base::requireNamespace("future", 
[17:00:30.810]                           quietly = TRUE)
[17:00:30.810]                         if (has_future) {
[17:00:30.810]                           ns <- base::getNamespace("future")
[17:00:30.810]                           version <- ns[[".package"]][["version"]]
[17:00:30.810]                           if (is.null(version)) 
[17:00:30.810]                             version <- utils::packageVersion("future")
[17:00:30.810]                         }
[17:00:30.810]                         else {
[17:00:30.810]                           version <- NULL
[17:00:30.810]                         }
[17:00:30.810]                         if (!has_future || version < "1.8.0") {
[17:00:30.810]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.810]                             "", base::R.version$version.string), 
[17:00:30.810]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.810]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.810]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.810]                               "release", "version")], collapse = " "), 
[17:00:30.810]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.810]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.810]                             info)
[17:00:30.810]                           info <- base::paste(info, collapse = "; ")
[17:00:30.810]                           if (!has_future) {
[17:00:30.810]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.810]                               info)
[17:00:30.810]                           }
[17:00:30.810]                           else {
[17:00:30.810]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.810]                               info, version)
[17:00:30.810]                           }
[17:00:30.810]                           base::stop(msg)
[17:00:30.810]                         }
[17:00:30.810]                       })
[17:00:30.810]                     }
[17:00:30.810]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.810]                     base::options(mc.cores = 1L)
[17:00:30.810]                   }
[17:00:30.810]                   ...future.strategy.old <- future::plan("list")
[17:00:30.810]                   options(future.plan = NULL)
[17:00:30.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.810]                 }
[17:00:30.810]                 ...future.workdir <- getwd()
[17:00:30.810]             }
[17:00:30.810]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.810]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.810]         }
[17:00:30.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.810]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.810]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.810]             base::names(...future.oldOptions))
[17:00:30.810]     }
[17:00:30.810]     if (FALSE) {
[17:00:30.810]     }
[17:00:30.810]     else {
[17:00:30.810]         if (TRUE) {
[17:00:30.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.810]                 open = "w")
[17:00:30.810]         }
[17:00:30.810]         else {
[17:00:30.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.810]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.810]         }
[17:00:30.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.810]             base::sink(type = "output", split = FALSE)
[17:00:30.810]             base::close(...future.stdout)
[17:00:30.810]         }, add = TRUE)
[17:00:30.810]     }
[17:00:30.810]     ...future.frame <- base::sys.nframe()
[17:00:30.810]     ...future.conditions <- base::list()
[17:00:30.810]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.810]     if (FALSE) {
[17:00:30.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.810]     }
[17:00:30.810]     ...future.result <- base::tryCatch({
[17:00:30.810]         base::withCallingHandlers({
[17:00:30.810]             ...future.value <- base::withVisible(base::local({
[17:00:30.810]                 withCallingHandlers({
[17:00:30.810]                   {
[17:00:30.810]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.810]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.810]                       ...future.globals.maxSize)) {
[17:00:30.810]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.810]                       on.exit(options(oopts), add = TRUE)
[17:00:30.810]                     }
[17:00:30.810]                     {
[17:00:30.810]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.810]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.810]                         USE.NAMES = FALSE)
[17:00:30.810]                       do.call(mapply, args = args)
[17:00:30.810]                     }
[17:00:30.810]                   }
[17:00:30.810]                 }, immediateCondition = function(cond) {
[17:00:30.810]                   save_rds <- function (object, pathname, ...) 
[17:00:30.810]                   {
[17:00:30.810]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.810]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.810]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.810]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.810]                         fi_tmp[["mtime"]])
[17:00:30.810]                     }
[17:00:30.810]                     tryCatch({
[17:00:30.810]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.810]                     }, error = function(ex) {
[17:00:30.810]                       msg <- conditionMessage(ex)
[17:00:30.810]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.810]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.810]                         fi_tmp[["mtime"]], msg)
[17:00:30.810]                       ex$message <- msg
[17:00:30.810]                       stop(ex)
[17:00:30.810]                     })
[17:00:30.810]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.810]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.810]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.810]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.810]                       fi <- file.info(pathname)
[17:00:30.810]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.810]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.810]                         fi[["size"]], fi[["mtime"]])
[17:00:30.810]                       stop(msg)
[17:00:30.810]                     }
[17:00:30.810]                     invisible(pathname)
[17:00:30.810]                   }
[17:00:30.810]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.810]                     rootPath = tempdir()) 
[17:00:30.810]                   {
[17:00:30.810]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.810]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.810]                       tmpdir = path, fileext = ".rds")
[17:00:30.810]                     save_rds(obj, file)
[17:00:30.810]                   }
[17:00:30.810]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.810]                   {
[17:00:30.810]                     inherits <- base::inherits
[17:00:30.810]                     invokeRestart <- base::invokeRestart
[17:00:30.810]                     is.null <- base::is.null
[17:00:30.810]                     muffled <- FALSE
[17:00:30.810]                     if (inherits(cond, "message")) {
[17:00:30.810]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.810]                       if (muffled) 
[17:00:30.810]                         invokeRestart("muffleMessage")
[17:00:30.810]                     }
[17:00:30.810]                     else if (inherits(cond, "warning")) {
[17:00:30.810]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.810]                       if (muffled) 
[17:00:30.810]                         invokeRestart("muffleWarning")
[17:00:30.810]                     }
[17:00:30.810]                     else if (inherits(cond, "condition")) {
[17:00:30.810]                       if (!is.null(pattern)) {
[17:00:30.810]                         computeRestarts <- base::computeRestarts
[17:00:30.810]                         grepl <- base::grepl
[17:00:30.810]                         restarts <- computeRestarts(cond)
[17:00:30.810]                         for (restart in restarts) {
[17:00:30.810]                           name <- restart$name
[17:00:30.810]                           if (is.null(name)) 
[17:00:30.810]                             next
[17:00:30.810]                           if (!grepl(pattern, name)) 
[17:00:30.810]                             next
[17:00:30.810]                           invokeRestart(restart)
[17:00:30.810]                           muffled <- TRUE
[17:00:30.810]                           break
[17:00:30.810]                         }
[17:00:30.810]                       }
[17:00:30.810]                     }
[17:00:30.810]                     invisible(muffled)
[17:00:30.810]                   }
[17:00:30.810]                   muffleCondition(cond)
[17:00:30.810]                 })
[17:00:30.810]             }))
[17:00:30.810]             future::FutureResult(value = ...future.value$value, 
[17:00:30.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.810]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.810]                     ...future.globalenv.names))
[17:00:30.810]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.810]         }, condition = base::local({
[17:00:30.810]             c <- base::c
[17:00:30.810]             inherits <- base::inherits
[17:00:30.810]             invokeRestart <- base::invokeRestart
[17:00:30.810]             length <- base::length
[17:00:30.810]             list <- base::list
[17:00:30.810]             seq.int <- base::seq.int
[17:00:30.810]             signalCondition <- base::signalCondition
[17:00:30.810]             sys.calls <- base::sys.calls
[17:00:30.810]             `[[` <- base::`[[`
[17:00:30.810]             `+` <- base::`+`
[17:00:30.810]             `<<-` <- base::`<<-`
[17:00:30.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.810]                   3L)]
[17:00:30.810]             }
[17:00:30.810]             function(cond) {
[17:00:30.810]                 is_error <- inherits(cond, "error")
[17:00:30.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.810]                   NULL)
[17:00:30.810]                 if (is_error) {
[17:00:30.810]                   sessionInformation <- function() {
[17:00:30.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.810]                       search = base::search(), system = base::Sys.info())
[17:00:30.810]                   }
[17:00:30.810]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.810]                     cond$call), session = sessionInformation(), 
[17:00:30.810]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.810]                   signalCondition(cond)
[17:00:30.810]                 }
[17:00:30.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.810]                 "immediateCondition"))) {
[17:00:30.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.810]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.810]                   if (TRUE && !signal) {
[17:00:30.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.810]                     {
[17:00:30.810]                       inherits <- base::inherits
[17:00:30.810]                       invokeRestart <- base::invokeRestart
[17:00:30.810]                       is.null <- base::is.null
[17:00:30.810]                       muffled <- FALSE
[17:00:30.810]                       if (inherits(cond, "message")) {
[17:00:30.810]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.810]                         if (muffled) 
[17:00:30.810]                           invokeRestart("muffleMessage")
[17:00:30.810]                       }
[17:00:30.810]                       else if (inherits(cond, "warning")) {
[17:00:30.810]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.810]                         if (muffled) 
[17:00:30.810]                           invokeRestart("muffleWarning")
[17:00:30.810]                       }
[17:00:30.810]                       else if (inherits(cond, "condition")) {
[17:00:30.810]                         if (!is.null(pattern)) {
[17:00:30.810]                           computeRestarts <- base::computeRestarts
[17:00:30.810]                           grepl <- base::grepl
[17:00:30.810]                           restarts <- computeRestarts(cond)
[17:00:30.810]                           for (restart in restarts) {
[17:00:30.810]                             name <- restart$name
[17:00:30.810]                             if (is.null(name)) 
[17:00:30.810]                               next
[17:00:30.810]                             if (!grepl(pattern, name)) 
[17:00:30.810]                               next
[17:00:30.810]                             invokeRestart(restart)
[17:00:30.810]                             muffled <- TRUE
[17:00:30.810]                             break
[17:00:30.810]                           }
[17:00:30.810]                         }
[17:00:30.810]                       }
[17:00:30.810]                       invisible(muffled)
[17:00:30.810]                     }
[17:00:30.810]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.810]                   }
[17:00:30.810]                 }
[17:00:30.810]                 else {
[17:00:30.810]                   if (TRUE) {
[17:00:30.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.810]                     {
[17:00:30.810]                       inherits <- base::inherits
[17:00:30.810]                       invokeRestart <- base::invokeRestart
[17:00:30.810]                       is.null <- base::is.null
[17:00:30.810]                       muffled <- FALSE
[17:00:30.810]                       if (inherits(cond, "message")) {
[17:00:30.810]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.810]                         if (muffled) 
[17:00:30.810]                           invokeRestart("muffleMessage")
[17:00:30.810]                       }
[17:00:30.810]                       else if (inherits(cond, "warning")) {
[17:00:30.810]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.810]                         if (muffled) 
[17:00:30.810]                           invokeRestart("muffleWarning")
[17:00:30.810]                       }
[17:00:30.810]                       else if (inherits(cond, "condition")) {
[17:00:30.810]                         if (!is.null(pattern)) {
[17:00:30.810]                           computeRestarts <- base::computeRestarts
[17:00:30.810]                           grepl <- base::grepl
[17:00:30.810]                           restarts <- computeRestarts(cond)
[17:00:30.810]                           for (restart in restarts) {
[17:00:30.810]                             name <- restart$name
[17:00:30.810]                             if (is.null(name)) 
[17:00:30.810]                               next
[17:00:30.810]                             if (!grepl(pattern, name)) 
[17:00:30.810]                               next
[17:00:30.810]                             invokeRestart(restart)
[17:00:30.810]                             muffled <- TRUE
[17:00:30.810]                             break
[17:00:30.810]                           }
[17:00:30.810]                         }
[17:00:30.810]                       }
[17:00:30.810]                       invisible(muffled)
[17:00:30.810]                     }
[17:00:30.810]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.810]                   }
[17:00:30.810]                 }
[17:00:30.810]             }
[17:00:30.810]         }))
[17:00:30.810]     }, error = function(ex) {
[17:00:30.810]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.810]                 ...future.rng), started = ...future.startTime, 
[17:00:30.810]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.810]             version = "1.8"), class = "FutureResult")
[17:00:30.810]     }, finally = {
[17:00:30.810]         if (!identical(...future.workdir, getwd())) 
[17:00:30.810]             setwd(...future.workdir)
[17:00:30.810]         {
[17:00:30.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.810]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.810]             }
[17:00:30.810]             base::options(...future.oldOptions)
[17:00:30.810]             if (.Platform$OS.type == "windows") {
[17:00:30.810]                 old_names <- names(...future.oldEnvVars)
[17:00:30.810]                 envs <- base::Sys.getenv()
[17:00:30.810]                 names <- names(envs)
[17:00:30.810]                 common <- intersect(names, old_names)
[17:00:30.810]                 added <- setdiff(names, old_names)
[17:00:30.810]                 removed <- setdiff(old_names, names)
[17:00:30.810]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.810]                   envs[common]]
[17:00:30.810]                 NAMES <- toupper(changed)
[17:00:30.810]                 args <- list()
[17:00:30.810]                 for (kk in seq_along(NAMES)) {
[17:00:30.810]                   name <- changed[[kk]]
[17:00:30.810]                   NAME <- NAMES[[kk]]
[17:00:30.810]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.810]                     next
[17:00:30.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.810]                 }
[17:00:30.810]                 NAMES <- toupper(added)
[17:00:30.810]                 for (kk in seq_along(NAMES)) {
[17:00:30.810]                   name <- added[[kk]]
[17:00:30.810]                   NAME <- NAMES[[kk]]
[17:00:30.810]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.810]                     next
[17:00:30.810]                   args[[name]] <- ""
[17:00:30.810]                 }
[17:00:30.810]                 NAMES <- toupper(removed)
[17:00:30.810]                 for (kk in seq_along(NAMES)) {
[17:00:30.810]                   name <- removed[[kk]]
[17:00:30.810]                   NAME <- NAMES[[kk]]
[17:00:30.810]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.810]                     next
[17:00:30.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.810]                 }
[17:00:30.810]                 if (length(args) > 0) 
[17:00:30.810]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.810]             }
[17:00:30.810]             else {
[17:00:30.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.810]             }
[17:00:30.810]             {
[17:00:30.810]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.810]                   0L) {
[17:00:30.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.810]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.810]                   base::options(opts)
[17:00:30.810]                 }
[17:00:30.810]                 {
[17:00:30.810]                   {
[17:00:30.810]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.810]                     NULL
[17:00:30.810]                   }
[17:00:30.810]                   options(future.plan = NULL)
[17:00:30.810]                   if (is.na(NA_character_)) 
[17:00:30.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.810]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.810]                     .init = FALSE)
[17:00:30.810]                 }
[17:00:30.810]             }
[17:00:30.810]         }
[17:00:30.810]     })
[17:00:30.810]     if (TRUE) {
[17:00:30.810]         base::sink(type = "output", split = FALSE)
[17:00:30.810]         if (TRUE) {
[17:00:30.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.810]         }
[17:00:30.810]         else {
[17:00:30.810]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.810]         }
[17:00:30.810]         base::close(...future.stdout)
[17:00:30.810]         ...future.stdout <- NULL
[17:00:30.810]     }
[17:00:30.810]     ...future.result$conditions <- ...future.conditions
[17:00:30.810]     ...future.result$finished <- base::Sys.time()
[17:00:30.810]     ...future.result
[17:00:30.810] }
[17:00:30.814] assign_globals() ...
[17:00:30.814] List of 5
[17:00:30.814]  $ ...future.FUN            :function (x, y)  
[17:00:30.814]  $ MoreArgs                 :List of 1
[17:00:30.814]   ..$ y: int [1:2] 3 4
[17:00:30.814]  $ ...future.elements_ii    :List of 1
[17:00:30.814]   ..$ x:List of 1
[17:00:30.814]   .. ..$ : int 2
[17:00:30.814]  $ ...future.seeds_ii       : NULL
[17:00:30.814]  $ ...future.globals.maxSize: NULL
[17:00:30.814]  - attr(*, "where")=List of 5
[17:00:30.814]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.814]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.814]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.814]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.814]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.814]  - attr(*, "resolved")= logi FALSE
[17:00:30.814]  - attr(*, "total_size")= num 1816
[17:00:30.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.814]  - attr(*, "already-done")= logi TRUE
[17:00:30.821] - reassign environment for ‘...future.FUN’
[17:00:30.821] - copied ‘...future.FUN’ to environment
[17:00:30.821] - copied ‘MoreArgs’ to environment
[17:00:30.821] - copied ‘...future.elements_ii’ to environment
[17:00:30.821] - copied ‘...future.seeds_ii’ to environment
[17:00:30.822] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.827] assign_globals() ... done
[17:00:30.827] requestCore(): workers = 2
[17:00:30.830] MulticoreFuture started
[17:00:30.830] - Launch lazy future ... done
[17:00:30.831] plan(): Setting new future strategy stack:
[17:00:30.831] run() for ‘MulticoreFuture’ ... done
[17:00:30.832] Created future:
[17:00:30.831] List of future strategies:
[17:00:30.831] 1. sequential:
[17:00:30.831]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.831]    - tweaked: FALSE
[17:00:30.831]    - call: NULL
[17:00:30.833] plan(): nbrOfWorkers() = 1
[17:00:30.836] plan(): Setting new future strategy stack:
[17:00:30.837] List of future strategies:
[17:00:30.837] 1. multicore:
[17:00:30.837]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.837]    - tweaked: FALSE
[17:00:30.837]    - call: plan(strategy)
[17:00:30.844] plan(): nbrOfWorkers() = 2
[17:00:30.832] MulticoreFuture:
[17:00:30.832] Label: ‘future_mapply-2’
[17:00:30.832] Expression:
[17:00:30.832] {
[17:00:30.832]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.832]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.832]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.832]         on.exit(options(oopts), add = TRUE)
[17:00:30.832]     }
[17:00:30.832]     {
[17:00:30.832]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:30.832]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.832]         do.call(mapply, args = args)
[17:00:30.832]     }
[17:00:30.832] }
[17:00:30.832] Lazy evaluation: FALSE
[17:00:30.832] Asynchronous evaluation: TRUE
[17:00:30.832] Local evaluation: TRUE
[17:00:30.832] Environment: R_GlobalEnv
[17:00:30.832] Capture standard output: TRUE
[17:00:30.832] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.832] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.832] Packages: <none>
[17:00:30.832] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:30.832] Resolved: TRUE
[17:00:30.832] Value: <not collected>
[17:00:30.832] Conditions captured: <none>
[17:00:30.832] Early signaling: FALSE
[17:00:30.832] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.832] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.845] Chunk #2 of 2 ... DONE
[17:00:30.845] Launching 2 futures (chunks) ... DONE
[17:00:30.846] Resolving 2 futures (chunks) ...
[17:00:30.846] resolve() on list ...
[17:00:30.846]  recursive: 0
[17:00:30.846]  length: 2
[17:00:30.847] 
[17:00:30.847] Future #1
[17:00:30.847] result() for MulticoreFuture ...
[17:00:30.848] result() for MulticoreFuture ...
[17:00:30.849] result() for MulticoreFuture ... done
[17:00:30.849] result() for MulticoreFuture ... done
[17:00:30.849] result() for MulticoreFuture ...
[17:00:30.849] result() for MulticoreFuture ... done
[17:00:30.849] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:30.850] - nx: 2
[17:00:30.850] - relay: TRUE
[17:00:30.850] - stdout: TRUE
[17:00:30.850] - signal: TRUE
[17:00:30.850] - resignal: FALSE
[17:00:30.851] - force: TRUE
[17:00:30.851] - relayed: [n=2] FALSE, FALSE
[17:00:30.851] - queued futures: [n=2] FALSE, FALSE
[17:00:30.851]  - until=1
[17:00:30.851]  - relaying element #1
[17:00:30.852] result() for MulticoreFuture ...
[17:00:30.852] result() for MulticoreFuture ... done
[17:00:30.852] result() for MulticoreFuture ...
[17:00:30.852] result() for MulticoreFuture ... done
[17:00:30.853] result() for MulticoreFuture ...
[17:00:30.853] result() for MulticoreFuture ... done
[17:00:30.853] result() for MulticoreFuture ...
[17:00:30.853] result() for MulticoreFuture ... done
[17:00:30.854] - relayed: [n=2] TRUE, FALSE
[17:00:30.854] - queued futures: [n=2] TRUE, FALSE
[17:00:30.854] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:30.854]  length: 1 (resolved future 1)
[17:00:30.855] Future #2
[17:00:30.855] result() for MulticoreFuture ...
[17:00:30.856] result() for MulticoreFuture ...
[17:00:30.856] result() for MulticoreFuture ... done
[17:00:30.856] result() for MulticoreFuture ... done
[17:00:30.856] result() for MulticoreFuture ...
[17:00:30.857] result() for MulticoreFuture ... done
[17:00:30.857] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:30.857] - nx: 2
[17:00:30.857] - relay: TRUE
[17:00:30.857] - stdout: TRUE
[17:00:30.857] - signal: TRUE
[17:00:30.857] - resignal: FALSE
[17:00:30.857] - force: TRUE
[17:00:30.858] - relayed: [n=2] TRUE, FALSE
[17:00:30.858] - queued futures: [n=2] TRUE, FALSE
[17:00:30.858]  - until=2
[17:00:30.858]  - relaying element #2
[17:00:30.858] result() for MulticoreFuture ...
[17:00:30.858] result() for MulticoreFuture ... done
[17:00:30.858] result() for MulticoreFuture ...
[17:00:30.858] result() for MulticoreFuture ... done
[17:00:30.859] result() for MulticoreFuture ...
[17:00:30.859] result() for MulticoreFuture ... done
[17:00:30.859] result() for MulticoreFuture ...
[17:00:30.859] result() for MulticoreFuture ... done
[17:00:30.859] - relayed: [n=2] TRUE, TRUE
[17:00:30.859] - queued futures: [n=2] TRUE, TRUE
[17:00:30.859] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:30.860]  length: 0 (resolved future 2)
[17:00:30.860] Relaying remaining futures
[17:00:30.860] signalConditionsASAP(NULL, pos=0) ...
[17:00:30.860] - nx: 2
[17:00:30.860] - relay: TRUE
[17:00:30.860] - stdout: TRUE
[17:00:30.860] - signal: TRUE
[17:00:30.860] - resignal: FALSE
[17:00:30.860] - force: TRUE
[17:00:30.860] - relayed: [n=2] TRUE, TRUE
[17:00:30.861] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:30.861] - relayed: [n=2] TRUE, TRUE
[17:00:30.861] - queued futures: [n=2] TRUE, TRUE
[17:00:30.861] signalConditionsASAP(NULL, pos=0) ... done
[17:00:30.861] resolve() on list ... DONE
[17:00:30.861] result() for MulticoreFuture ...
[17:00:30.861] result() for MulticoreFuture ... done
[17:00:30.861] result() for MulticoreFuture ...
[17:00:30.861] result() for MulticoreFuture ... done
[17:00:30.862] result() for MulticoreFuture ...
[17:00:30.862] result() for MulticoreFuture ... done
[17:00:30.862] result() for MulticoreFuture ...
[17:00:30.862] result() for MulticoreFuture ... done
[17:00:30.862]  - Number of value chunks collected: 2
[17:00:30.862] Resolving 2 futures (chunks) ... DONE
[17:00:30.862] Reducing values from 2 chunks ...
[17:00:30.862]  - Number of values collected after concatenation: 2
[17:00:30.862]  - Number of values expected: 2
[17:00:30.863] Reducing values from 2 chunks ... DONE
[17:00:30.863] future_mapply() ... DONE
[17:00:30.863] future_mapply() ...
[17:00:30.863] Generating random seeds ...
[17:00:30.863] Generating random seed streams for 2 elements ...
[17:00:30.863] Generating random seed streams for 2 elements ... DONE
[17:00:30.863] Generating random seeds ... DONE
[17:00:30.863] Will set RNG state on exit: 10407, -1944143463, -520840416, 269197478, -96650886, 519985141, 752569467
[17:00:30.868] Number of chunks: 2
[17:00:30.869] getGlobalsAndPackagesXApply() ...
[17:00:30.869]  - future.globals: TRUE
[17:00:30.869] getGlobalsAndPackages() ...
[17:00:30.869] Searching for globals...
[17:00:30.870] - globals found: [1] ‘FUN’
[17:00:30.870] Searching for globals ... DONE
[17:00:30.870] Resolving globals: FALSE
[17:00:30.871] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:00:30.871] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:00:30.871] - globals: [1] ‘FUN’
[17:00:30.871] 
[17:00:30.871] getGlobalsAndPackages() ... DONE
[17:00:30.872]  - globals found/used: [n=1] ‘FUN’
[17:00:30.872]  - needed namespaces: [n=0] 
[17:00:30.872] Finding globals ... DONE
[17:00:30.872] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:30.872] List of 2
[17:00:30.872]  $ ...future.FUN:function (x, y)  
[17:00:30.872]  $ MoreArgs     :List of 1
[17:00:30.872]   ..$ y: int [1:2] 3 4
[17:00:30.872]  - attr(*, "where")=List of 2
[17:00:30.872]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:30.872]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:30.872]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.872]  - attr(*, "resolved")= logi FALSE
[17:00:30.872]  - attr(*, "total_size")= num NA
[17:00:30.875] Packages to be attached in all futures: [n=0] 
[17:00:30.875] getGlobalsAndPackagesXApply() ... DONE
[17:00:30.878] Number of futures (= number of chunks): 2
[17:00:30.878] Launching 2 futures (chunks) ...
[17:00:30.878] Chunk #1 of 2 ...
[17:00:30.878]  - Finding globals in '...' for chunk #1 ...
[17:00:30.879] getGlobalsAndPackages() ...
[17:00:30.879] Searching for globals...
[17:00:30.879] 
[17:00:30.879] Searching for globals ... DONE
[17:00:30.879] - globals: [0] <none>
[17:00:30.880] getGlobalsAndPackages() ... DONE
[17:00:30.880]    + additional globals found: [n=0] 
[17:00:30.880]    + additional namespaces needed: [n=0] 
[17:00:30.880]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:30.880]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:30.880]  - seeds: [1] <seeds>
[17:00:30.880]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.880] getGlobalsAndPackages() ...
[17:00:30.881] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.881] Resolving globals: FALSE
[17:00:30.881] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:00:30.882] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:30.882] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.882] 
[17:00:30.882] getGlobalsAndPackages() ... DONE
[17:00:30.883] run() for ‘Future’ ...
[17:00:30.883] - state: ‘created’
[17:00:30.883] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.887] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.887]   - Field: ‘label’
[17:00:30.888]   - Field: ‘local’
[17:00:30.888]   - Field: ‘owner’
[17:00:30.888]   - Field: ‘envir’
[17:00:30.888]   - Field: ‘workers’
[17:00:30.888]   - Field: ‘packages’
[17:00:30.888]   - Field: ‘gc’
[17:00:30.888]   - Field: ‘job’
[17:00:30.888]   - Field: ‘conditions’
[17:00:30.889]   - Field: ‘expr’
[17:00:30.889]   - Field: ‘uuid’
[17:00:30.889]   - Field: ‘seed’
[17:00:30.889]   - Field: ‘version’
[17:00:30.889]   - Field: ‘result’
[17:00:30.889]   - Field: ‘asynchronous’
[17:00:30.889]   - Field: ‘calls’
[17:00:30.889]   - Field: ‘globals’
[17:00:30.889]   - Field: ‘stdout’
[17:00:30.889]   - Field: ‘earlySignal’
[17:00:30.890]   - Field: ‘lazy’
[17:00:30.890]   - Field: ‘state’
[17:00:30.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.890] - Launch lazy future ...
[17:00:30.890] Packages needed by the future expression (n = 0): <none>
[17:00:30.890] Packages needed by future strategies (n = 0): <none>
[17:00:30.891] {
[17:00:30.891]     {
[17:00:30.891]         {
[17:00:30.891]             ...future.startTime <- base::Sys.time()
[17:00:30.891]             {
[17:00:30.891]                 {
[17:00:30.891]                   {
[17:00:30.891]                     {
[17:00:30.891]                       base::local({
[17:00:30.891]                         has_future <- base::requireNamespace("future", 
[17:00:30.891]                           quietly = TRUE)
[17:00:30.891]                         if (has_future) {
[17:00:30.891]                           ns <- base::getNamespace("future")
[17:00:30.891]                           version <- ns[[".package"]][["version"]]
[17:00:30.891]                           if (is.null(version)) 
[17:00:30.891]                             version <- utils::packageVersion("future")
[17:00:30.891]                         }
[17:00:30.891]                         else {
[17:00:30.891]                           version <- NULL
[17:00:30.891]                         }
[17:00:30.891]                         if (!has_future || version < "1.8.0") {
[17:00:30.891]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.891]                             "", base::R.version$version.string), 
[17:00:30.891]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.891]                               "release", "version")], collapse = " "), 
[17:00:30.891]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.891]                             info)
[17:00:30.891]                           info <- base::paste(info, collapse = "; ")
[17:00:30.891]                           if (!has_future) {
[17:00:30.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.891]                               info)
[17:00:30.891]                           }
[17:00:30.891]                           else {
[17:00:30.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.891]                               info, version)
[17:00:30.891]                           }
[17:00:30.891]                           base::stop(msg)
[17:00:30.891]                         }
[17:00:30.891]                       })
[17:00:30.891]                     }
[17:00:30.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.891]                     base::options(mc.cores = 1L)
[17:00:30.891]                   }
[17:00:30.891]                   ...future.strategy.old <- future::plan("list")
[17:00:30.891]                   options(future.plan = NULL)
[17:00:30.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.891]                 }
[17:00:30.891]                 ...future.workdir <- getwd()
[17:00:30.891]             }
[17:00:30.891]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.891]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.891]         }
[17:00:30.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.891]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.891]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.891]             base::names(...future.oldOptions))
[17:00:30.891]     }
[17:00:30.891]     if (FALSE) {
[17:00:30.891]     }
[17:00:30.891]     else {
[17:00:30.891]         if (TRUE) {
[17:00:30.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.891]                 open = "w")
[17:00:30.891]         }
[17:00:30.891]         else {
[17:00:30.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.891]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.891]         }
[17:00:30.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.891]             base::sink(type = "output", split = FALSE)
[17:00:30.891]             base::close(...future.stdout)
[17:00:30.891]         }, add = TRUE)
[17:00:30.891]     }
[17:00:30.891]     ...future.frame <- base::sys.nframe()
[17:00:30.891]     ...future.conditions <- base::list()
[17:00:30.891]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.891]     if (FALSE) {
[17:00:30.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.891]     }
[17:00:30.891]     ...future.result <- base::tryCatch({
[17:00:30.891]         base::withCallingHandlers({
[17:00:30.891]             ...future.value <- base::withVisible(base::local({
[17:00:30.891]                 withCallingHandlers({
[17:00:30.891]                   {
[17:00:30.891]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.891]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.891]                       ...future.globals.maxSize)) {
[17:00:30.891]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.891]                       on.exit(options(oopts), add = TRUE)
[17:00:30.891]                     }
[17:00:30.891]                     {
[17:00:30.891]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:30.891]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:30.891]                           envir = globalenv(), inherits = FALSE)
[17:00:30.891]                         ...future.FUN(...)
[17:00:30.891]                       }
[17:00:30.891]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:30.891]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:30.891]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.891]                         USE.NAMES = FALSE)
[17:00:30.891]                       do.call(mapply, args = args)
[17:00:30.891]                     }
[17:00:30.891]                   }
[17:00:30.891]                 }, immediateCondition = function(cond) {
[17:00:30.891]                   save_rds <- function (object, pathname, ...) 
[17:00:30.891]                   {
[17:00:30.891]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.891]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.891]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.891]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.891]                         fi_tmp[["mtime"]])
[17:00:30.891]                     }
[17:00:30.891]                     tryCatch({
[17:00:30.891]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.891]                     }, error = function(ex) {
[17:00:30.891]                       msg <- conditionMessage(ex)
[17:00:30.891]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.891]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.891]                         fi_tmp[["mtime"]], msg)
[17:00:30.891]                       ex$message <- msg
[17:00:30.891]                       stop(ex)
[17:00:30.891]                     })
[17:00:30.891]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.891]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.891]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.891]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.891]                       fi <- file.info(pathname)
[17:00:30.891]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.891]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.891]                         fi[["size"]], fi[["mtime"]])
[17:00:30.891]                       stop(msg)
[17:00:30.891]                     }
[17:00:30.891]                     invisible(pathname)
[17:00:30.891]                   }
[17:00:30.891]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.891]                     rootPath = tempdir()) 
[17:00:30.891]                   {
[17:00:30.891]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.891]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.891]                       tmpdir = path, fileext = ".rds")
[17:00:30.891]                     save_rds(obj, file)
[17:00:30.891]                   }
[17:00:30.891]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.891]                   {
[17:00:30.891]                     inherits <- base::inherits
[17:00:30.891]                     invokeRestart <- base::invokeRestart
[17:00:30.891]                     is.null <- base::is.null
[17:00:30.891]                     muffled <- FALSE
[17:00:30.891]                     if (inherits(cond, "message")) {
[17:00:30.891]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.891]                       if (muffled) 
[17:00:30.891]                         invokeRestart("muffleMessage")
[17:00:30.891]                     }
[17:00:30.891]                     else if (inherits(cond, "warning")) {
[17:00:30.891]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.891]                       if (muffled) 
[17:00:30.891]                         invokeRestart("muffleWarning")
[17:00:30.891]                     }
[17:00:30.891]                     else if (inherits(cond, "condition")) {
[17:00:30.891]                       if (!is.null(pattern)) {
[17:00:30.891]                         computeRestarts <- base::computeRestarts
[17:00:30.891]                         grepl <- base::grepl
[17:00:30.891]                         restarts <- computeRestarts(cond)
[17:00:30.891]                         for (restart in restarts) {
[17:00:30.891]                           name <- restart$name
[17:00:30.891]                           if (is.null(name)) 
[17:00:30.891]                             next
[17:00:30.891]                           if (!grepl(pattern, name)) 
[17:00:30.891]                             next
[17:00:30.891]                           invokeRestart(restart)
[17:00:30.891]                           muffled <- TRUE
[17:00:30.891]                           break
[17:00:30.891]                         }
[17:00:30.891]                       }
[17:00:30.891]                     }
[17:00:30.891]                     invisible(muffled)
[17:00:30.891]                   }
[17:00:30.891]                   muffleCondition(cond)
[17:00:30.891]                 })
[17:00:30.891]             }))
[17:00:30.891]             future::FutureResult(value = ...future.value$value, 
[17:00:30.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.891]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.891]                     ...future.globalenv.names))
[17:00:30.891]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.891]         }, condition = base::local({
[17:00:30.891]             c <- base::c
[17:00:30.891]             inherits <- base::inherits
[17:00:30.891]             invokeRestart <- base::invokeRestart
[17:00:30.891]             length <- base::length
[17:00:30.891]             list <- base::list
[17:00:30.891]             seq.int <- base::seq.int
[17:00:30.891]             signalCondition <- base::signalCondition
[17:00:30.891]             sys.calls <- base::sys.calls
[17:00:30.891]             `[[` <- base::`[[`
[17:00:30.891]             `+` <- base::`+`
[17:00:30.891]             `<<-` <- base::`<<-`
[17:00:30.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.891]                   3L)]
[17:00:30.891]             }
[17:00:30.891]             function(cond) {
[17:00:30.891]                 is_error <- inherits(cond, "error")
[17:00:30.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.891]                   NULL)
[17:00:30.891]                 if (is_error) {
[17:00:30.891]                   sessionInformation <- function() {
[17:00:30.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.891]                       search = base::search(), system = base::Sys.info())
[17:00:30.891]                   }
[17:00:30.891]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.891]                     cond$call), session = sessionInformation(), 
[17:00:30.891]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.891]                   signalCondition(cond)
[17:00:30.891]                 }
[17:00:30.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.891]                 "immediateCondition"))) {
[17:00:30.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.891]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.891]                   if (TRUE && !signal) {
[17:00:30.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.891]                     {
[17:00:30.891]                       inherits <- base::inherits
[17:00:30.891]                       invokeRestart <- base::invokeRestart
[17:00:30.891]                       is.null <- base::is.null
[17:00:30.891]                       muffled <- FALSE
[17:00:30.891]                       if (inherits(cond, "message")) {
[17:00:30.891]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.891]                         if (muffled) 
[17:00:30.891]                           invokeRestart("muffleMessage")
[17:00:30.891]                       }
[17:00:30.891]                       else if (inherits(cond, "warning")) {
[17:00:30.891]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.891]                         if (muffled) 
[17:00:30.891]                           invokeRestart("muffleWarning")
[17:00:30.891]                       }
[17:00:30.891]                       else if (inherits(cond, "condition")) {
[17:00:30.891]                         if (!is.null(pattern)) {
[17:00:30.891]                           computeRestarts <- base::computeRestarts
[17:00:30.891]                           grepl <- base::grepl
[17:00:30.891]                           restarts <- computeRestarts(cond)
[17:00:30.891]                           for (restart in restarts) {
[17:00:30.891]                             name <- restart$name
[17:00:30.891]                             if (is.null(name)) 
[17:00:30.891]                               next
[17:00:30.891]                             if (!grepl(pattern, name)) 
[17:00:30.891]                               next
[17:00:30.891]                             invokeRestart(restart)
[17:00:30.891]                             muffled <- TRUE
[17:00:30.891]                             break
[17:00:30.891]                           }
[17:00:30.891]                         }
[17:00:30.891]                       }
[17:00:30.891]                       invisible(muffled)
[17:00:30.891]                     }
[17:00:30.891]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.891]                   }
[17:00:30.891]                 }
[17:00:30.891]                 else {
[17:00:30.891]                   if (TRUE) {
[17:00:30.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.891]                     {
[17:00:30.891]                       inherits <- base::inherits
[17:00:30.891]                       invokeRestart <- base::invokeRestart
[17:00:30.891]                       is.null <- base::is.null
[17:00:30.891]                       muffled <- FALSE
[17:00:30.891]                       if (inherits(cond, "message")) {
[17:00:30.891]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.891]                         if (muffled) 
[17:00:30.891]                           invokeRestart("muffleMessage")
[17:00:30.891]                       }
[17:00:30.891]                       else if (inherits(cond, "warning")) {
[17:00:30.891]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.891]                         if (muffled) 
[17:00:30.891]                           invokeRestart("muffleWarning")
[17:00:30.891]                       }
[17:00:30.891]                       else if (inherits(cond, "condition")) {
[17:00:30.891]                         if (!is.null(pattern)) {
[17:00:30.891]                           computeRestarts <- base::computeRestarts
[17:00:30.891]                           grepl <- base::grepl
[17:00:30.891]                           restarts <- computeRestarts(cond)
[17:00:30.891]                           for (restart in restarts) {
[17:00:30.891]                             name <- restart$name
[17:00:30.891]                             if (is.null(name)) 
[17:00:30.891]                               next
[17:00:30.891]                             if (!grepl(pattern, name)) 
[17:00:30.891]                               next
[17:00:30.891]                             invokeRestart(restart)
[17:00:30.891]                             muffled <- TRUE
[17:00:30.891]                             break
[17:00:30.891]                           }
[17:00:30.891]                         }
[17:00:30.891]                       }
[17:00:30.891]                       invisible(muffled)
[17:00:30.891]                     }
[17:00:30.891]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.891]                   }
[17:00:30.891]                 }
[17:00:30.891]             }
[17:00:30.891]         }))
[17:00:30.891]     }, error = function(ex) {
[17:00:30.891]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.891]                 ...future.rng), started = ...future.startTime, 
[17:00:30.891]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.891]             version = "1.8"), class = "FutureResult")
[17:00:30.891]     }, finally = {
[17:00:30.891]         if (!identical(...future.workdir, getwd())) 
[17:00:30.891]             setwd(...future.workdir)
[17:00:30.891]         {
[17:00:30.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.891]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.891]             }
[17:00:30.891]             base::options(...future.oldOptions)
[17:00:30.891]             if (.Platform$OS.type == "windows") {
[17:00:30.891]                 old_names <- names(...future.oldEnvVars)
[17:00:30.891]                 envs <- base::Sys.getenv()
[17:00:30.891]                 names <- names(envs)
[17:00:30.891]                 common <- intersect(names, old_names)
[17:00:30.891]                 added <- setdiff(names, old_names)
[17:00:30.891]                 removed <- setdiff(old_names, names)
[17:00:30.891]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.891]                   envs[common]]
[17:00:30.891]                 NAMES <- toupper(changed)
[17:00:30.891]                 args <- list()
[17:00:30.891]                 for (kk in seq_along(NAMES)) {
[17:00:30.891]                   name <- changed[[kk]]
[17:00:30.891]                   NAME <- NAMES[[kk]]
[17:00:30.891]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.891]                     next
[17:00:30.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.891]                 }
[17:00:30.891]                 NAMES <- toupper(added)
[17:00:30.891]                 for (kk in seq_along(NAMES)) {
[17:00:30.891]                   name <- added[[kk]]
[17:00:30.891]                   NAME <- NAMES[[kk]]
[17:00:30.891]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.891]                     next
[17:00:30.891]                   args[[name]] <- ""
[17:00:30.891]                 }
[17:00:30.891]                 NAMES <- toupper(removed)
[17:00:30.891]                 for (kk in seq_along(NAMES)) {
[17:00:30.891]                   name <- removed[[kk]]
[17:00:30.891]                   NAME <- NAMES[[kk]]
[17:00:30.891]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.891]                     next
[17:00:30.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.891]                 }
[17:00:30.891]                 if (length(args) > 0) 
[17:00:30.891]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.891]             }
[17:00:30.891]             else {
[17:00:30.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.891]             }
[17:00:30.891]             {
[17:00:30.891]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.891]                   0L) {
[17:00:30.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.891]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.891]                   base::options(opts)
[17:00:30.891]                 }
[17:00:30.891]                 {
[17:00:30.891]                   {
[17:00:30.891]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.891]                     NULL
[17:00:30.891]                   }
[17:00:30.891]                   options(future.plan = NULL)
[17:00:30.891]                   if (is.na(NA_character_)) 
[17:00:30.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.891]                     .init = FALSE)
[17:00:30.891]                 }
[17:00:30.891]             }
[17:00:30.891]         }
[17:00:30.891]     })
[17:00:30.891]     if (TRUE) {
[17:00:30.891]         base::sink(type = "output", split = FALSE)
[17:00:30.891]         if (TRUE) {
[17:00:30.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.891]         }
[17:00:30.891]         else {
[17:00:30.891]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.891]         }
[17:00:30.891]         base::close(...future.stdout)
[17:00:30.891]         ...future.stdout <- NULL
[17:00:30.891]     }
[17:00:30.891]     ...future.result$conditions <- ...future.conditions
[17:00:30.891]     ...future.result$finished <- base::Sys.time()
[17:00:30.891]     ...future.result
[17:00:30.891] }
[17:00:30.893] assign_globals() ...
[17:00:30.893] List of 5
[17:00:30.893]  $ ...future.FUN            :function (x, y)  
[17:00:30.893]  $ MoreArgs                 :List of 1
[17:00:30.893]   ..$ y: int [1:2] 3 4
[17:00:30.893]  $ ...future.elements_ii    :List of 1
[17:00:30.893]   ..$ x:List of 1
[17:00:30.893]   .. ..$ : int 1
[17:00:30.893]  $ ...future.seeds_ii       :List of 1
[17:00:30.893]   ..$ : int [1:7] 10407 988560801 676344235 759481232 -1119201805 812423982 1662142756
[17:00:30.893]  $ ...future.globals.maxSize: NULL
[17:00:30.893]  - attr(*, "where")=List of 5
[17:00:30.893]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.893]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.893]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.893]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.893]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.893]  - attr(*, "resolved")= logi FALSE
[17:00:30.893]  - attr(*, "total_size")= num 1896
[17:00:30.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.893]  - attr(*, "already-done")= logi TRUE
[17:00:30.899] - reassign environment for ‘...future.FUN’
[17:00:30.899] - copied ‘...future.FUN’ to environment
[17:00:30.899] - copied ‘MoreArgs’ to environment
[17:00:30.899] - copied ‘...future.elements_ii’ to environment
[17:00:30.899] - copied ‘...future.seeds_ii’ to environment
[17:00:30.899] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.900] assign_globals() ... done
[17:00:30.900] requestCore(): workers = 2
[17:00:30.902] MulticoreFuture started
[17:00:30.902] - Launch lazy future ... done
[17:00:30.903] run() for ‘MulticoreFuture’ ... done
[17:00:30.903] Created future:
[17:00:30.903] plan(): Setting new future strategy stack:
[17:00:30.903] List of future strategies:
[17:00:30.903] 1. sequential:
[17:00:30.903]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.903]    - tweaked: FALSE
[17:00:30.903]    - call: NULL
[17:00:30.904] plan(): nbrOfWorkers() = 1
[17:00:30.906] plan(): Setting new future strategy stack:
[17:00:30.907] List of future strategies:
[17:00:30.907] 1. multicore:
[17:00:30.907]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.907]    - tweaked: FALSE
[17:00:30.907]    - call: plan(strategy)
[17:00:30.912] plan(): nbrOfWorkers() = 2
[17:00:30.903] MulticoreFuture:
[17:00:30.903] Label: ‘future_mapply-1’
[17:00:30.903] Expression:
[17:00:30.903] {
[17:00:30.903]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.903]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.903]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.903]         on.exit(options(oopts), add = TRUE)
[17:00:30.903]     }
[17:00:30.903]     {
[17:00:30.903]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:30.903]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:30.903]                 inherits = FALSE)
[17:00:30.903]             ...future.FUN(...)
[17:00:30.903]         }
[17:00:30.903]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:30.903]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:30.903]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.903]         do.call(mapply, args = args)
[17:00:30.903]     }
[17:00:30.903] }
[17:00:30.903] Lazy evaluation: FALSE
[17:00:30.903] Asynchronous evaluation: TRUE
[17:00:30.903] Local evaluation: TRUE
[17:00:30.903] Environment: R_GlobalEnv
[17:00:30.903] Capture standard output: TRUE
[17:00:30.903] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.903] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.903] Packages: <none>
[17:00:30.903] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:30.903] Resolved: TRUE
[17:00:30.903] Value: <not collected>
[17:00:30.903] Conditions captured: <none>
[17:00:30.903] Early signaling: FALSE
[17:00:30.903] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.903] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.913] Chunk #1 of 2 ... DONE
[17:00:30.913] Chunk #2 of 2 ...
[17:00:30.913]  - Finding globals in '...' for chunk #2 ...
[17:00:30.914] getGlobalsAndPackages() ...
[17:00:30.914] Searching for globals...
[17:00:30.914] 
[17:00:30.914] Searching for globals ... DONE
[17:00:30.915] - globals: [0] <none>
[17:00:30.915] getGlobalsAndPackages() ... DONE
[17:00:30.915]    + additional globals found: [n=0] 
[17:00:30.915]    + additional namespaces needed: [n=0] 
[17:00:30.915]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:30.915]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:30.915]  - seeds: [1] <seeds>
[17:00:30.916]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.916] getGlobalsAndPackages() ...
[17:00:30.916] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.916] Resolving globals: FALSE
[17:00:30.917] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:00:30.918] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:30.918] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:30.918] 
[17:00:30.919] getGlobalsAndPackages() ... DONE
[17:00:30.923] run() for ‘Future’ ...
[17:00:30.924] - state: ‘created’
[17:00:30.924] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:30.931] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.931] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:30.931]   - Field: ‘label’
[17:00:30.932]   - Field: ‘local’
[17:00:30.932]   - Field: ‘owner’
[17:00:30.932]   - Field: ‘envir’
[17:00:30.932]   - Field: ‘workers’
[17:00:30.933]   - Field: ‘packages’
[17:00:30.933]   - Field: ‘gc’
[17:00:30.933]   - Field: ‘job’
[17:00:30.933]   - Field: ‘conditions’
[17:00:30.933]   - Field: ‘expr’
[17:00:30.934]   - Field: ‘uuid’
[17:00:30.934]   - Field: ‘seed’
[17:00:30.934]   - Field: ‘version’
[17:00:30.934]   - Field: ‘result’
[17:00:30.934]   - Field: ‘asynchronous’
[17:00:30.935]   - Field: ‘calls’
[17:00:30.935]   - Field: ‘globals’
[17:00:30.935]   - Field: ‘stdout’
[17:00:30.935]   - Field: ‘earlySignal’
[17:00:30.935]   - Field: ‘lazy’
[17:00:30.936]   - Field: ‘state’
[17:00:30.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:30.936] - Launch lazy future ...
[17:00:30.937] Packages needed by the future expression (n = 0): <none>
[17:00:30.937] Packages needed by future strategies (n = 0): <none>
[17:00:30.938] {
[17:00:30.938]     {
[17:00:30.938]         {
[17:00:30.938]             ...future.startTime <- base::Sys.time()
[17:00:30.938]             {
[17:00:30.938]                 {
[17:00:30.938]                   {
[17:00:30.938]                     {
[17:00:30.938]                       base::local({
[17:00:30.938]                         has_future <- base::requireNamespace("future", 
[17:00:30.938]                           quietly = TRUE)
[17:00:30.938]                         if (has_future) {
[17:00:30.938]                           ns <- base::getNamespace("future")
[17:00:30.938]                           version <- ns[[".package"]][["version"]]
[17:00:30.938]                           if (is.null(version)) 
[17:00:30.938]                             version <- utils::packageVersion("future")
[17:00:30.938]                         }
[17:00:30.938]                         else {
[17:00:30.938]                           version <- NULL
[17:00:30.938]                         }
[17:00:30.938]                         if (!has_future || version < "1.8.0") {
[17:00:30.938]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:30.938]                             "", base::R.version$version.string), 
[17:00:30.938]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:30.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:30.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:30.938]                               "release", "version")], collapse = " "), 
[17:00:30.938]                             hostname = base::Sys.info()[["nodename"]])
[17:00:30.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:30.938]                             info)
[17:00:30.938]                           info <- base::paste(info, collapse = "; ")
[17:00:30.938]                           if (!has_future) {
[17:00:30.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:30.938]                               info)
[17:00:30.938]                           }
[17:00:30.938]                           else {
[17:00:30.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:30.938]                               info, version)
[17:00:30.938]                           }
[17:00:30.938]                           base::stop(msg)
[17:00:30.938]                         }
[17:00:30.938]                       })
[17:00:30.938]                     }
[17:00:30.938]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:30.938]                     base::options(mc.cores = 1L)
[17:00:30.938]                   }
[17:00:30.938]                   ...future.strategy.old <- future::plan("list")
[17:00:30.938]                   options(future.plan = NULL)
[17:00:30.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:30.938]                 }
[17:00:30.938]                 ...future.workdir <- getwd()
[17:00:30.938]             }
[17:00:30.938]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:30.938]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:30.938]         }
[17:00:30.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:30.938]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:30.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:30.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:30.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:30.938]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:30.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:30.938]             base::names(...future.oldOptions))
[17:00:30.938]     }
[17:00:30.938]     if (FALSE) {
[17:00:30.938]     }
[17:00:30.938]     else {
[17:00:30.938]         if (TRUE) {
[17:00:30.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:30.938]                 open = "w")
[17:00:30.938]         }
[17:00:30.938]         else {
[17:00:30.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:30.938]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:30.938]         }
[17:00:30.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:30.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:30.938]             base::sink(type = "output", split = FALSE)
[17:00:30.938]             base::close(...future.stdout)
[17:00:30.938]         }, add = TRUE)
[17:00:30.938]     }
[17:00:30.938]     ...future.frame <- base::sys.nframe()
[17:00:30.938]     ...future.conditions <- base::list()
[17:00:30.938]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:30.938]     if (FALSE) {
[17:00:30.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:30.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:30.938]     }
[17:00:30.938]     ...future.result <- base::tryCatch({
[17:00:30.938]         base::withCallingHandlers({
[17:00:30.938]             ...future.value <- base::withVisible(base::local({
[17:00:30.938]                 withCallingHandlers({
[17:00:30.938]                   {
[17:00:30.938]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.938]                     if (!identical(...future.globals.maxSize.org, 
[17:00:30.938]                       ...future.globals.maxSize)) {
[17:00:30.938]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.938]                       on.exit(options(oopts), add = TRUE)
[17:00:30.938]                     }
[17:00:30.938]                     {
[17:00:30.938]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:30.938]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:30.938]                           envir = globalenv(), inherits = FALSE)
[17:00:30.938]                         ...future.FUN(...)
[17:00:30.938]                       }
[17:00:30.938]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:30.938]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:30.938]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:30.938]                         USE.NAMES = FALSE)
[17:00:30.938]                       do.call(mapply, args = args)
[17:00:30.938]                     }
[17:00:30.938]                   }
[17:00:30.938]                 }, immediateCondition = function(cond) {
[17:00:30.938]                   save_rds <- function (object, pathname, ...) 
[17:00:30.938]                   {
[17:00:30.938]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:30.938]                     if (file_test("-f", pathname_tmp)) {
[17:00:30.938]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.938]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:30.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.938]                         fi_tmp[["mtime"]])
[17:00:30.938]                     }
[17:00:30.938]                     tryCatch({
[17:00:30.938]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:30.938]                     }, error = function(ex) {
[17:00:30.938]                       msg <- conditionMessage(ex)
[17:00:30.938]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.938]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:30.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.938]                         fi_tmp[["mtime"]], msg)
[17:00:30.938]                       ex$message <- msg
[17:00:30.938]                       stop(ex)
[17:00:30.938]                     })
[17:00:30.938]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:30.938]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:30.938]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:30.938]                       fi_tmp <- file.info(pathname_tmp)
[17:00:30.938]                       fi <- file.info(pathname)
[17:00:30.938]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:30.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:30.938]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:30.938]                         fi[["size"]], fi[["mtime"]])
[17:00:30.938]                       stop(msg)
[17:00:30.938]                     }
[17:00:30.938]                     invisible(pathname)
[17:00:30.938]                   }
[17:00:30.938]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:30.938]                     rootPath = tempdir()) 
[17:00:30.938]                   {
[17:00:30.938]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:30.938]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:30.938]                       tmpdir = path, fileext = ".rds")
[17:00:30.938]                     save_rds(obj, file)
[17:00:30.938]                   }
[17:00:30.938]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:30.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.938]                   {
[17:00:30.938]                     inherits <- base::inherits
[17:00:30.938]                     invokeRestart <- base::invokeRestart
[17:00:30.938]                     is.null <- base::is.null
[17:00:30.938]                     muffled <- FALSE
[17:00:30.938]                     if (inherits(cond, "message")) {
[17:00:30.938]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:30.938]                       if (muffled) 
[17:00:30.938]                         invokeRestart("muffleMessage")
[17:00:30.938]                     }
[17:00:30.938]                     else if (inherits(cond, "warning")) {
[17:00:30.938]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:30.938]                       if (muffled) 
[17:00:30.938]                         invokeRestart("muffleWarning")
[17:00:30.938]                     }
[17:00:30.938]                     else if (inherits(cond, "condition")) {
[17:00:30.938]                       if (!is.null(pattern)) {
[17:00:30.938]                         computeRestarts <- base::computeRestarts
[17:00:30.938]                         grepl <- base::grepl
[17:00:30.938]                         restarts <- computeRestarts(cond)
[17:00:30.938]                         for (restart in restarts) {
[17:00:30.938]                           name <- restart$name
[17:00:30.938]                           if (is.null(name)) 
[17:00:30.938]                             next
[17:00:30.938]                           if (!grepl(pattern, name)) 
[17:00:30.938]                             next
[17:00:30.938]                           invokeRestart(restart)
[17:00:30.938]                           muffled <- TRUE
[17:00:30.938]                           break
[17:00:30.938]                         }
[17:00:30.938]                       }
[17:00:30.938]                     }
[17:00:30.938]                     invisible(muffled)
[17:00:30.938]                   }
[17:00:30.938]                   muffleCondition(cond)
[17:00:30.938]                 })
[17:00:30.938]             }))
[17:00:30.938]             future::FutureResult(value = ...future.value$value, 
[17:00:30.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.938]                   ...future.rng), globalenv = if (FALSE) 
[17:00:30.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:30.938]                     ...future.globalenv.names))
[17:00:30.938]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:30.938]         }, condition = base::local({
[17:00:30.938]             c <- base::c
[17:00:30.938]             inherits <- base::inherits
[17:00:30.938]             invokeRestart <- base::invokeRestart
[17:00:30.938]             length <- base::length
[17:00:30.938]             list <- base::list
[17:00:30.938]             seq.int <- base::seq.int
[17:00:30.938]             signalCondition <- base::signalCondition
[17:00:30.938]             sys.calls <- base::sys.calls
[17:00:30.938]             `[[` <- base::`[[`
[17:00:30.938]             `+` <- base::`+`
[17:00:30.938]             `<<-` <- base::`<<-`
[17:00:30.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:30.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:30.938]                   3L)]
[17:00:30.938]             }
[17:00:30.938]             function(cond) {
[17:00:30.938]                 is_error <- inherits(cond, "error")
[17:00:30.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:30.938]                   NULL)
[17:00:30.938]                 if (is_error) {
[17:00:30.938]                   sessionInformation <- function() {
[17:00:30.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:30.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:30.938]                       search = base::search(), system = base::Sys.info())
[17:00:30.938]                   }
[17:00:30.938]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:30.938]                     cond$call), session = sessionInformation(), 
[17:00:30.938]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:30.938]                   signalCondition(cond)
[17:00:30.938]                 }
[17:00:30.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:30.938]                 "immediateCondition"))) {
[17:00:30.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:30.938]                   ...future.conditions[[length(...future.conditions) + 
[17:00:30.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:30.938]                   if (TRUE && !signal) {
[17:00:30.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.938]                     {
[17:00:30.938]                       inherits <- base::inherits
[17:00:30.938]                       invokeRestart <- base::invokeRestart
[17:00:30.938]                       is.null <- base::is.null
[17:00:30.938]                       muffled <- FALSE
[17:00:30.938]                       if (inherits(cond, "message")) {
[17:00:30.938]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.938]                         if (muffled) 
[17:00:30.938]                           invokeRestart("muffleMessage")
[17:00:30.938]                       }
[17:00:30.938]                       else if (inherits(cond, "warning")) {
[17:00:30.938]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.938]                         if (muffled) 
[17:00:30.938]                           invokeRestart("muffleWarning")
[17:00:30.938]                       }
[17:00:30.938]                       else if (inherits(cond, "condition")) {
[17:00:30.938]                         if (!is.null(pattern)) {
[17:00:30.938]                           computeRestarts <- base::computeRestarts
[17:00:30.938]                           grepl <- base::grepl
[17:00:30.938]                           restarts <- computeRestarts(cond)
[17:00:30.938]                           for (restart in restarts) {
[17:00:30.938]                             name <- restart$name
[17:00:30.938]                             if (is.null(name)) 
[17:00:30.938]                               next
[17:00:30.938]                             if (!grepl(pattern, name)) 
[17:00:30.938]                               next
[17:00:30.938]                             invokeRestart(restart)
[17:00:30.938]                             muffled <- TRUE
[17:00:30.938]                             break
[17:00:30.938]                           }
[17:00:30.938]                         }
[17:00:30.938]                       }
[17:00:30.938]                       invisible(muffled)
[17:00:30.938]                     }
[17:00:30.938]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.938]                   }
[17:00:30.938]                 }
[17:00:30.938]                 else {
[17:00:30.938]                   if (TRUE) {
[17:00:30.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:30.938]                     {
[17:00:30.938]                       inherits <- base::inherits
[17:00:30.938]                       invokeRestart <- base::invokeRestart
[17:00:30.938]                       is.null <- base::is.null
[17:00:30.938]                       muffled <- FALSE
[17:00:30.938]                       if (inherits(cond, "message")) {
[17:00:30.938]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:30.938]                         if (muffled) 
[17:00:30.938]                           invokeRestart("muffleMessage")
[17:00:30.938]                       }
[17:00:30.938]                       else if (inherits(cond, "warning")) {
[17:00:30.938]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:30.938]                         if (muffled) 
[17:00:30.938]                           invokeRestart("muffleWarning")
[17:00:30.938]                       }
[17:00:30.938]                       else if (inherits(cond, "condition")) {
[17:00:30.938]                         if (!is.null(pattern)) {
[17:00:30.938]                           computeRestarts <- base::computeRestarts
[17:00:30.938]                           grepl <- base::grepl
[17:00:30.938]                           restarts <- computeRestarts(cond)
[17:00:30.938]                           for (restart in restarts) {
[17:00:30.938]                             name <- restart$name
[17:00:30.938]                             if (is.null(name)) 
[17:00:30.938]                               next
[17:00:30.938]                             if (!grepl(pattern, name)) 
[17:00:30.938]                               next
[17:00:30.938]                             invokeRestart(restart)
[17:00:30.938]                             muffled <- TRUE
[17:00:30.938]                             break
[17:00:30.938]                           }
[17:00:30.938]                         }
[17:00:30.938]                       }
[17:00:30.938]                       invisible(muffled)
[17:00:30.938]                     }
[17:00:30.938]                     muffleCondition(cond, pattern = "^muffle")
[17:00:30.938]                   }
[17:00:30.938]                 }
[17:00:30.938]             }
[17:00:30.938]         }))
[17:00:30.938]     }, error = function(ex) {
[17:00:30.938]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:30.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:30.938]                 ...future.rng), started = ...future.startTime, 
[17:00:30.938]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:30.938]             version = "1.8"), class = "FutureResult")
[17:00:30.938]     }, finally = {
[17:00:30.938]         if (!identical(...future.workdir, getwd())) 
[17:00:30.938]             setwd(...future.workdir)
[17:00:30.938]         {
[17:00:30.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:30.938]                 ...future.oldOptions$nwarnings <- NULL
[17:00:30.938]             }
[17:00:30.938]             base::options(...future.oldOptions)
[17:00:30.938]             if (.Platform$OS.type == "windows") {
[17:00:30.938]                 old_names <- names(...future.oldEnvVars)
[17:00:30.938]                 envs <- base::Sys.getenv()
[17:00:30.938]                 names <- names(envs)
[17:00:30.938]                 common <- intersect(names, old_names)
[17:00:30.938]                 added <- setdiff(names, old_names)
[17:00:30.938]                 removed <- setdiff(old_names, names)
[17:00:30.938]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:30.938]                   envs[common]]
[17:00:30.938]                 NAMES <- toupper(changed)
[17:00:30.938]                 args <- list()
[17:00:30.938]                 for (kk in seq_along(NAMES)) {
[17:00:30.938]                   name <- changed[[kk]]
[17:00:30.938]                   NAME <- NAMES[[kk]]
[17:00:30.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.938]                     next
[17:00:30.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.938]                 }
[17:00:30.938]                 NAMES <- toupper(added)
[17:00:30.938]                 for (kk in seq_along(NAMES)) {
[17:00:30.938]                   name <- added[[kk]]
[17:00:30.938]                   NAME <- NAMES[[kk]]
[17:00:30.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.938]                     next
[17:00:30.938]                   args[[name]] <- ""
[17:00:30.938]                 }
[17:00:30.938]                 NAMES <- toupper(removed)
[17:00:30.938]                 for (kk in seq_along(NAMES)) {
[17:00:30.938]                   name <- removed[[kk]]
[17:00:30.938]                   NAME <- NAMES[[kk]]
[17:00:30.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:30.938]                     next
[17:00:30.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:30.938]                 }
[17:00:30.938]                 if (length(args) > 0) 
[17:00:30.938]                   base::do.call(base::Sys.setenv, args = args)
[17:00:30.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:30.938]             }
[17:00:30.938]             else {
[17:00:30.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:30.938]             }
[17:00:30.938]             {
[17:00:30.938]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:30.938]                   0L) {
[17:00:30.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:30.938]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:30.938]                   base::options(opts)
[17:00:30.938]                 }
[17:00:30.938]                 {
[17:00:30.938]                   {
[17:00:30.938]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:30.938]                     NULL
[17:00:30.938]                   }
[17:00:30.938]                   options(future.plan = NULL)
[17:00:30.938]                   if (is.na(NA_character_)) 
[17:00:30.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:30.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:30.938]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:30.938]                     .init = FALSE)
[17:00:30.938]                 }
[17:00:30.938]             }
[17:00:30.938]         }
[17:00:30.938]     })
[17:00:30.938]     if (TRUE) {
[17:00:30.938]         base::sink(type = "output", split = FALSE)
[17:00:30.938]         if (TRUE) {
[17:00:30.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:30.938]         }
[17:00:30.938]         else {
[17:00:30.938]             ...future.result["stdout"] <- base::list(NULL)
[17:00:30.938]         }
[17:00:30.938]         base::close(...future.stdout)
[17:00:30.938]         ...future.stdout <- NULL
[17:00:30.938]     }
[17:00:30.938]     ...future.result$conditions <- ...future.conditions
[17:00:30.938]     ...future.result$finished <- base::Sys.time()
[17:00:30.938]     ...future.result
[17:00:30.938] }
[17:00:30.942] assign_globals() ...
[17:00:30.942] List of 5
[17:00:30.942]  $ ...future.FUN            :function (x, y)  
[17:00:30.942]  $ MoreArgs                 :List of 1
[17:00:30.942]   ..$ y: int [1:2] 3 4
[17:00:30.942]  $ ...future.elements_ii    :List of 1
[17:00:30.942]   ..$ x:List of 1
[17:00:30.942]   .. ..$ : int 2
[17:00:30.942]  $ ...future.seeds_ii       :List of 1
[17:00:30.942]   ..$ : int [1:7] 10407 -1957419052 -761109614 447549901 1952382692 1278522826 -543136873
[17:00:30.942]  $ ...future.globals.maxSize: NULL
[17:00:30.942]  - attr(*, "where")=List of 5
[17:00:30.942]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:30.942]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:30.942]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:30.942]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:30.942]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:30.942]  - attr(*, "resolved")= logi FALSE
[17:00:30.942]  - attr(*, "total_size")= num 1896
[17:00:30.942]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.942]  - attr(*, "already-done")= logi TRUE
[17:00:30.951] - reassign environment for ‘...future.FUN’
[17:00:30.951] - copied ‘...future.FUN’ to environment
[17:00:30.951] - copied ‘MoreArgs’ to environment
[17:00:30.951] - copied ‘...future.elements_ii’ to environment
[17:00:30.951] - copied ‘...future.seeds_ii’ to environment
[17:00:30.951] - copied ‘...future.globals.maxSize’ to environment
[17:00:30.951] assign_globals() ... done
[17:00:30.951] requestCore(): workers = 2
[17:00:30.954] MulticoreFuture started
[17:00:30.954] - Launch lazy future ... done
[17:00:30.954] run() for ‘MulticoreFuture’ ... done
[17:00:30.955] Created future:
[17:00:30.955] plan(): Setting new future strategy stack:
[17:00:30.955] List of future strategies:
[17:00:30.955] 1. sequential:
[17:00:30.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:30.955]    - tweaked: FALSE
[17:00:30.955]    - call: NULL
[17:00:30.956] plan(): nbrOfWorkers() = 1
[17:00:30.958] plan(): Setting new future strategy stack:
[17:00:30.959] List of future strategies:
[17:00:30.959] 1. multicore:
[17:00:30.959]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:30.959]    - tweaked: FALSE
[17:00:30.959]    - call: plan(strategy)
[17:00:30.964] plan(): nbrOfWorkers() = 2
[17:00:30.955] MulticoreFuture:
[17:00:30.955] Label: ‘future_mapply-2’
[17:00:30.955] Expression:
[17:00:30.955] {
[17:00:30.955]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:30.955]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:30.955]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:30.955]         on.exit(options(oopts), add = TRUE)
[17:00:30.955]     }
[17:00:30.955]     {
[17:00:30.955]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:30.955]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:30.955]                 inherits = FALSE)
[17:00:30.955]             ...future.FUN(...)
[17:00:30.955]         }
[17:00:30.955]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:30.955]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:30.955]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:30.955]         do.call(mapply, args = args)
[17:00:30.955]     }
[17:00:30.955] }
[17:00:30.955] Lazy evaluation: FALSE
[17:00:30.955] Asynchronous evaluation: TRUE
[17:00:30.955] Local evaluation: TRUE
[17:00:30.955] Environment: R_GlobalEnv
[17:00:30.955] Capture standard output: TRUE
[17:00:30.955] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:30.955] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:30.955] Packages: <none>
[17:00:30.955] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:30.955] Resolved: TRUE
[17:00:30.955] Value: <not collected>
[17:00:30.955] Conditions captured: <none>
[17:00:30.955] Early signaling: FALSE
[17:00:30.955] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:30.955] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:30.965] Chunk #2 of 2 ... DONE
[17:00:30.966] Launching 2 futures (chunks) ... DONE
[17:00:30.966] Resolving 2 futures (chunks) ...
[17:00:30.966] resolve() on list ...
[17:00:30.966]  recursive: 0
[17:00:30.966]  length: 2
[17:00:30.966] 
[17:00:30.967] Future #1
[17:00:30.967] result() for MulticoreFuture ...
[17:00:30.968] result() for MulticoreFuture ...
[17:00:30.968] result() for MulticoreFuture ... done
[17:00:30.968] result() for MulticoreFuture ... done
[17:00:30.968] result() for MulticoreFuture ...
[17:00:30.968] result() for MulticoreFuture ... done
[17:00:30.969] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:30.969] - nx: 2
[17:00:30.969] - relay: TRUE
[17:00:30.969] - stdout: TRUE
[17:00:30.969] - signal: TRUE
[17:00:30.969] - resignal: FALSE
[17:00:30.970] - force: TRUE
[17:00:30.970] - relayed: [n=2] FALSE, FALSE
[17:00:30.970] - queued futures: [n=2] FALSE, FALSE
[17:00:30.970]  - until=1
[17:00:30.970]  - relaying element #1
[17:00:30.970] result() for MulticoreFuture ...
[17:00:30.970] result() for MulticoreFuture ... done
[17:00:30.971] result() for MulticoreFuture ...
[17:00:30.971] result() for MulticoreFuture ... done
[17:00:30.971] result() for MulticoreFuture ...
[17:00:30.971] result() for MulticoreFuture ... done
[17:00:30.971] result() for MulticoreFuture ...
[17:00:30.971] result() for MulticoreFuture ... done
[17:00:30.972] - relayed: [n=2] TRUE, FALSE
[17:00:30.972] - queued futures: [n=2] TRUE, FALSE
[17:00:30.972] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:30.972]  length: 1 (resolved future 1)
[17:00:30.972] Future #2
[17:00:30.973] result() for MulticoreFuture ...
[17:00:30.973] result() for MulticoreFuture ...
[17:00:30.974] result() for MulticoreFuture ... done
[17:00:30.974] result() for MulticoreFuture ... done
[17:00:30.974] result() for MulticoreFuture ...
[17:00:30.974] result() for MulticoreFuture ... done
[17:00:30.974] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:30.974] - nx: 2
[17:00:30.974] - relay: TRUE
[17:00:30.975] - stdout: TRUE
[17:00:30.975] - signal: TRUE
[17:00:30.975] - resignal: FALSE
[17:00:30.975] - force: TRUE
[17:00:30.975] - relayed: [n=2] TRUE, FALSE
[17:00:30.975] - queued futures: [n=2] TRUE, FALSE
[17:00:30.975]  - until=2
[17:00:30.975]  - relaying element #2
[17:00:30.976] result() for MulticoreFuture ...
[17:00:30.976] result() for MulticoreFuture ... done
[17:00:30.976] result() for MulticoreFuture ...
[17:00:30.976] result() for MulticoreFuture ... done
[17:00:30.979] result() for MulticoreFuture ...
[17:00:30.979] result() for MulticoreFuture ... done
[17:00:30.980] result() for MulticoreFuture ...
[17:00:30.980] result() for MulticoreFuture ... done
[17:00:30.980] - relayed: [n=2] TRUE, TRUE
[17:00:30.980] - queued futures: [n=2] TRUE, TRUE
[17:00:30.980] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:30.981]  length: 0 (resolved future 2)
[17:00:30.981] Relaying remaining futures
[17:00:30.981] signalConditionsASAP(NULL, pos=0) ...
[17:00:30.981] - nx: 2
[17:00:30.981] - relay: TRUE
[17:00:30.981] - stdout: TRUE
[17:00:30.981] - signal: TRUE
[17:00:30.982] - resignal: FALSE
[17:00:30.982] - force: TRUE
[17:00:30.982] - relayed: [n=2] TRUE, TRUE
[17:00:30.982] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:30.982] - relayed: [n=2] TRUE, TRUE
[17:00:30.982] - queued futures: [n=2] TRUE, TRUE
[17:00:30.983] signalConditionsASAP(NULL, pos=0) ... done
[17:00:30.983] resolve() on list ... DONE
[17:00:30.983] result() for MulticoreFuture ...
[17:00:30.983] result() for MulticoreFuture ... done
[17:00:30.983] result() for MulticoreFuture ...
[17:00:30.983] result() for MulticoreFuture ... done
[17:00:30.984] result() for MulticoreFuture ...
[17:00:30.984] result() for MulticoreFuture ... done
[17:00:30.984] result() for MulticoreFuture ...
[17:00:30.984] result() for MulticoreFuture ... done
[17:00:30.984]  - Number of value chunks collected: 2
[17:00:30.984] Resolving 2 futures (chunks) ... DONE
[17:00:30.984] Reducing values from 2 chunks ...
[17:00:30.985]  - Number of values collected after concatenation: 2
[17:00:30.985]  - Number of values expected: 2
[17:00:30.985] Reducing values from 2 chunks ... DONE
[17:00:30.985] future_mapply() ... DONE
[17:00:30.985] future_mapply() ...
[17:00:30.990] Number of chunks: 2
[17:00:30.990] getGlobalsAndPackagesXApply() ...
[17:00:30.990]  - future.globals: TRUE
[17:00:30.990] getGlobalsAndPackages() ...
[17:00:30.991] Searching for globals...
[17:00:30.992] - globals found: [1] ‘FUN’
[17:00:30.992] Searching for globals ... DONE
[17:00:30.992] Resolving globals: FALSE
[17:00:30.993] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:00:30.993] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:00:30.993] - globals: [1] ‘FUN’
[17:00:30.993] 
[17:00:30.994] getGlobalsAndPackages() ... DONE
[17:00:30.994]  - globals found/used: [n=1] ‘FUN’
[17:00:30.994]  - needed namespaces: [n=0] 
[17:00:30.994] Finding globals ... DONE
[17:00:30.994] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:30.994] List of 2
[17:00:30.994]  $ ...future.FUN:function (x, y)  
[17:00:30.994]  $ MoreArgs     :List of 1
[17:00:30.994]   ..$ y: int [1:2] 3 4
[17:00:30.994]  - attr(*, "where")=List of 2
[17:00:30.994]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:30.994]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:30.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:30.994]  - attr(*, "resolved")= logi FALSE
[17:00:30.994]  - attr(*, "total_size")= num NA
[17:00:30.998] Packages to be attached in all futures: [n=0] 
[17:00:30.998] getGlobalsAndPackagesXApply() ... DONE
[17:00:30.998] Number of futures (= number of chunks): 2
[17:00:30.998] Launching 2 futures (chunks) ...
[17:00:30.998] Chunk #1 of 2 ...
[17:00:30.998]  - Finding globals in '...' for chunk #1 ...
[17:00:30.998] getGlobalsAndPackages() ...
[17:00:30.999] Searching for globals...
[17:00:30.999] 
[17:00:30.999] Searching for globals ... DONE
[17:00:30.999] - globals: [0] <none>
[17:00:30.999] getGlobalsAndPackages() ... DONE
[17:00:30.999]    + additional globals found: [n=0] 
[17:00:30.999]    + additional namespaces needed: [n=0] 
[17:00:30.999]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:31.000]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.000]  - seeds: <none>
[17:00:31.000]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.000] getGlobalsAndPackages() ...
[17:00:31.000] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.000] Resolving globals: FALSE
[17:00:31.001] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:00:31.001] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:00:31.001] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.001] 
[17:00:31.001] getGlobalsAndPackages() ... DONE
[17:00:31.002] run() for ‘Future’ ...
[17:00:31.002] - state: ‘created’
[17:00:31.002] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.006] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.006]   - Field: ‘label’
[17:00:31.007]   - Field: ‘local’
[17:00:31.007]   - Field: ‘owner’
[17:00:31.007]   - Field: ‘envir’
[17:00:31.007]   - Field: ‘workers’
[17:00:31.007]   - Field: ‘packages’
[17:00:31.007]   - Field: ‘gc’
[17:00:31.007]   - Field: ‘job’
[17:00:31.007]   - Field: ‘conditions’
[17:00:31.008]   - Field: ‘expr’
[17:00:31.008]   - Field: ‘uuid’
[17:00:31.008]   - Field: ‘seed’
[17:00:31.008]   - Field: ‘version’
[17:00:31.008]   - Field: ‘result’
[17:00:31.008]   - Field: ‘asynchronous’
[17:00:31.008]   - Field: ‘calls’
[17:00:31.008]   - Field: ‘globals’
[17:00:31.008]   - Field: ‘stdout’
[17:00:31.008]   - Field: ‘earlySignal’
[17:00:31.009]   - Field: ‘lazy’
[17:00:31.009]   - Field: ‘state’
[17:00:31.009] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.009] - Launch lazy future ...
[17:00:31.009] Packages needed by the future expression (n = 0): <none>
[17:00:31.009] Packages needed by future strategies (n = 0): <none>
[17:00:31.010] {
[17:00:31.010]     {
[17:00:31.010]         {
[17:00:31.010]             ...future.startTime <- base::Sys.time()
[17:00:31.010]             {
[17:00:31.010]                 {
[17:00:31.010]                   {
[17:00:31.010]                     {
[17:00:31.010]                       base::local({
[17:00:31.010]                         has_future <- base::requireNamespace("future", 
[17:00:31.010]                           quietly = TRUE)
[17:00:31.010]                         if (has_future) {
[17:00:31.010]                           ns <- base::getNamespace("future")
[17:00:31.010]                           version <- ns[[".package"]][["version"]]
[17:00:31.010]                           if (is.null(version)) 
[17:00:31.010]                             version <- utils::packageVersion("future")
[17:00:31.010]                         }
[17:00:31.010]                         else {
[17:00:31.010]                           version <- NULL
[17:00:31.010]                         }
[17:00:31.010]                         if (!has_future || version < "1.8.0") {
[17:00:31.010]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.010]                             "", base::R.version$version.string), 
[17:00:31.010]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:31.010]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:31.010]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.010]                               "release", "version")], collapse = " "), 
[17:00:31.010]                             hostname = base::Sys.info()[["nodename"]])
[17:00:31.010]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.010]                             info)
[17:00:31.010]                           info <- base::paste(info, collapse = "; ")
[17:00:31.010]                           if (!has_future) {
[17:00:31.010]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.010]                               info)
[17:00:31.010]                           }
[17:00:31.010]                           else {
[17:00:31.010]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.010]                               info, version)
[17:00:31.010]                           }
[17:00:31.010]                           base::stop(msg)
[17:00:31.010]                         }
[17:00:31.010]                       })
[17:00:31.010]                     }
[17:00:31.010]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.010]                     base::options(mc.cores = 1L)
[17:00:31.010]                   }
[17:00:31.010]                   ...future.strategy.old <- future::plan("list")
[17:00:31.010]                   options(future.plan = NULL)
[17:00:31.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.010]                 }
[17:00:31.010]                 ...future.workdir <- getwd()
[17:00:31.010]             }
[17:00:31.010]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.010]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.010]         }
[17:00:31.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.010]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.010]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.010]             base::names(...future.oldOptions))
[17:00:31.010]     }
[17:00:31.010]     if (FALSE) {
[17:00:31.010]     }
[17:00:31.010]     else {
[17:00:31.010]         if (TRUE) {
[17:00:31.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.010]                 open = "w")
[17:00:31.010]         }
[17:00:31.010]         else {
[17:00:31.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.010]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.010]         }
[17:00:31.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.010]             base::sink(type = "output", split = FALSE)
[17:00:31.010]             base::close(...future.stdout)
[17:00:31.010]         }, add = TRUE)
[17:00:31.010]     }
[17:00:31.010]     ...future.frame <- base::sys.nframe()
[17:00:31.010]     ...future.conditions <- base::list()
[17:00:31.010]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.010]     if (FALSE) {
[17:00:31.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.010]     }
[17:00:31.010]     ...future.result <- base::tryCatch({
[17:00:31.010]         base::withCallingHandlers({
[17:00:31.010]             ...future.value <- base::withVisible(base::local({
[17:00:31.010]                 withCallingHandlers({
[17:00:31.010]                   {
[17:00:31.010]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.010]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.010]                       ...future.globals.maxSize)) {
[17:00:31.010]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.010]                       on.exit(options(oopts), add = TRUE)
[17:00:31.010]                     }
[17:00:31.010]                     {
[17:00:31.010]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.010]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.010]                         USE.NAMES = FALSE)
[17:00:31.010]                       do.call(mapply, args = args)
[17:00:31.010]                     }
[17:00:31.010]                   }
[17:00:31.010]                 }, immediateCondition = function(cond) {
[17:00:31.010]                   save_rds <- function (object, pathname, ...) 
[17:00:31.010]                   {
[17:00:31.010]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.010]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.010]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.010]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.010]                         fi_tmp[["mtime"]])
[17:00:31.010]                     }
[17:00:31.010]                     tryCatch({
[17:00:31.010]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.010]                     }, error = function(ex) {
[17:00:31.010]                       msg <- conditionMessage(ex)
[17:00:31.010]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.010]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.010]                         fi_tmp[["mtime"]], msg)
[17:00:31.010]                       ex$message <- msg
[17:00:31.010]                       stop(ex)
[17:00:31.010]                     })
[17:00:31.010]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.010]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.010]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.010]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.010]                       fi <- file.info(pathname)
[17:00:31.010]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.010]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.010]                         fi[["size"]], fi[["mtime"]])
[17:00:31.010]                       stop(msg)
[17:00:31.010]                     }
[17:00:31.010]                     invisible(pathname)
[17:00:31.010]                   }
[17:00:31.010]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.010]                     rootPath = tempdir()) 
[17:00:31.010]                   {
[17:00:31.010]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.010]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.010]                       tmpdir = path, fileext = ".rds")
[17:00:31.010]                     save_rds(obj, file)
[17:00:31.010]                   }
[17:00:31.010]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.010]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.010]                   {
[17:00:31.010]                     inherits <- base::inherits
[17:00:31.010]                     invokeRestart <- base::invokeRestart
[17:00:31.010]                     is.null <- base::is.null
[17:00:31.010]                     muffled <- FALSE
[17:00:31.010]                     if (inherits(cond, "message")) {
[17:00:31.010]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.010]                       if (muffled) 
[17:00:31.010]                         invokeRestart("muffleMessage")
[17:00:31.010]                     }
[17:00:31.010]                     else if (inherits(cond, "warning")) {
[17:00:31.010]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.010]                       if (muffled) 
[17:00:31.010]                         invokeRestart("muffleWarning")
[17:00:31.010]                     }
[17:00:31.010]                     else if (inherits(cond, "condition")) {
[17:00:31.010]                       if (!is.null(pattern)) {
[17:00:31.010]                         computeRestarts <- base::computeRestarts
[17:00:31.010]                         grepl <- base::grepl
[17:00:31.010]                         restarts <- computeRestarts(cond)
[17:00:31.010]                         for (restart in restarts) {
[17:00:31.010]                           name <- restart$name
[17:00:31.010]                           if (is.null(name)) 
[17:00:31.010]                             next
[17:00:31.010]                           if (!grepl(pattern, name)) 
[17:00:31.010]                             next
[17:00:31.010]                           invokeRestart(restart)
[17:00:31.010]                           muffled <- TRUE
[17:00:31.010]                           break
[17:00:31.010]                         }
[17:00:31.010]                       }
[17:00:31.010]                     }
[17:00:31.010]                     invisible(muffled)
[17:00:31.010]                   }
[17:00:31.010]                   muffleCondition(cond)
[17:00:31.010]                 })
[17:00:31.010]             }))
[17:00:31.010]             future::FutureResult(value = ...future.value$value, 
[17:00:31.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.010]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.010]                     ...future.globalenv.names))
[17:00:31.010]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.010]         }, condition = base::local({
[17:00:31.010]             c <- base::c
[17:00:31.010]             inherits <- base::inherits
[17:00:31.010]             invokeRestart <- base::invokeRestart
[17:00:31.010]             length <- base::length
[17:00:31.010]             list <- base::list
[17:00:31.010]             seq.int <- base::seq.int
[17:00:31.010]             signalCondition <- base::signalCondition
[17:00:31.010]             sys.calls <- base::sys.calls
[17:00:31.010]             `[[` <- base::`[[`
[17:00:31.010]             `+` <- base::`+`
[17:00:31.010]             `<<-` <- base::`<<-`
[17:00:31.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.010]                   3L)]
[17:00:31.010]             }
[17:00:31.010]             function(cond) {
[17:00:31.010]                 is_error <- inherits(cond, "error")
[17:00:31.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.010]                   NULL)
[17:00:31.010]                 if (is_error) {
[17:00:31.010]                   sessionInformation <- function() {
[17:00:31.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.010]                       search = base::search(), system = base::Sys.info())
[17:00:31.010]                   }
[17:00:31.010]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.010]                     cond$call), session = sessionInformation(), 
[17:00:31.010]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.010]                   signalCondition(cond)
[17:00:31.010]                 }
[17:00:31.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.010]                 "immediateCondition"))) {
[17:00:31.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.010]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.010]                   if (TRUE && !signal) {
[17:00:31.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.010]                     {
[17:00:31.010]                       inherits <- base::inherits
[17:00:31.010]                       invokeRestart <- base::invokeRestart
[17:00:31.010]                       is.null <- base::is.null
[17:00:31.010]                       muffled <- FALSE
[17:00:31.010]                       if (inherits(cond, "message")) {
[17:00:31.010]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.010]                         if (muffled) 
[17:00:31.010]                           invokeRestart("muffleMessage")
[17:00:31.010]                       }
[17:00:31.010]                       else if (inherits(cond, "warning")) {
[17:00:31.010]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.010]                         if (muffled) 
[17:00:31.010]                           invokeRestart("muffleWarning")
[17:00:31.010]                       }
[17:00:31.010]                       else if (inherits(cond, "condition")) {
[17:00:31.010]                         if (!is.null(pattern)) {
[17:00:31.010]                           computeRestarts <- base::computeRestarts
[17:00:31.010]                           grepl <- base::grepl
[17:00:31.010]                           restarts <- computeRestarts(cond)
[17:00:31.010]                           for (restart in restarts) {
[17:00:31.010]                             name <- restart$name
[17:00:31.010]                             if (is.null(name)) 
[17:00:31.010]                               next
[17:00:31.010]                             if (!grepl(pattern, name)) 
[17:00:31.010]                               next
[17:00:31.010]                             invokeRestart(restart)
[17:00:31.010]                             muffled <- TRUE
[17:00:31.010]                             break
[17:00:31.010]                           }
[17:00:31.010]                         }
[17:00:31.010]                       }
[17:00:31.010]                       invisible(muffled)
[17:00:31.010]                     }
[17:00:31.010]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.010]                   }
[17:00:31.010]                 }
[17:00:31.010]                 else {
[17:00:31.010]                   if (TRUE) {
[17:00:31.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.010]                     {
[17:00:31.010]                       inherits <- base::inherits
[17:00:31.010]                       invokeRestart <- base::invokeRestart
[17:00:31.010]                       is.null <- base::is.null
[17:00:31.010]                       muffled <- FALSE
[17:00:31.010]                       if (inherits(cond, "message")) {
[17:00:31.010]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.010]                         if (muffled) 
[17:00:31.010]                           invokeRestart("muffleMessage")
[17:00:31.010]                       }
[17:00:31.010]                       else if (inherits(cond, "warning")) {
[17:00:31.010]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.010]                         if (muffled) 
[17:00:31.010]                           invokeRestart("muffleWarning")
[17:00:31.010]                       }
[17:00:31.010]                       else if (inherits(cond, "condition")) {
[17:00:31.010]                         if (!is.null(pattern)) {
[17:00:31.010]                           computeRestarts <- base::computeRestarts
[17:00:31.010]                           grepl <- base::grepl
[17:00:31.010]                           restarts <- computeRestarts(cond)
[17:00:31.010]                           for (restart in restarts) {
[17:00:31.010]                             name <- restart$name
[17:00:31.010]                             if (is.null(name)) 
[17:00:31.010]                               next
[17:00:31.010]                             if (!grepl(pattern, name)) 
[17:00:31.010]                               next
[17:00:31.010]                             invokeRestart(restart)
[17:00:31.010]                             muffled <- TRUE
[17:00:31.010]                             break
[17:00:31.010]                           }
[17:00:31.010]                         }
[17:00:31.010]                       }
[17:00:31.010]                       invisible(muffled)
[17:00:31.010]                     }
[17:00:31.010]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.010]                   }
[17:00:31.010]                 }
[17:00:31.010]             }
[17:00:31.010]         }))
[17:00:31.010]     }, error = function(ex) {
[17:00:31.010]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.010]                 ...future.rng), started = ...future.startTime, 
[17:00:31.010]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.010]             version = "1.8"), class = "FutureResult")
[17:00:31.010]     }, finally = {
[17:00:31.010]         if (!identical(...future.workdir, getwd())) 
[17:00:31.010]             setwd(...future.workdir)
[17:00:31.010]         {
[17:00:31.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.010]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.010]             }
[17:00:31.010]             base::options(...future.oldOptions)
[17:00:31.010]             if (.Platform$OS.type == "windows") {
[17:00:31.010]                 old_names <- names(...future.oldEnvVars)
[17:00:31.010]                 envs <- base::Sys.getenv()
[17:00:31.010]                 names <- names(envs)
[17:00:31.010]                 common <- intersect(names, old_names)
[17:00:31.010]                 added <- setdiff(names, old_names)
[17:00:31.010]                 removed <- setdiff(old_names, names)
[17:00:31.010]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.010]                   envs[common]]
[17:00:31.010]                 NAMES <- toupper(changed)
[17:00:31.010]                 args <- list()
[17:00:31.010]                 for (kk in seq_along(NAMES)) {
[17:00:31.010]                   name <- changed[[kk]]
[17:00:31.010]                   NAME <- NAMES[[kk]]
[17:00:31.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.010]                     next
[17:00:31.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.010]                 }
[17:00:31.010]                 NAMES <- toupper(added)
[17:00:31.010]                 for (kk in seq_along(NAMES)) {
[17:00:31.010]                   name <- added[[kk]]
[17:00:31.010]                   NAME <- NAMES[[kk]]
[17:00:31.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.010]                     next
[17:00:31.010]                   args[[name]] <- ""
[17:00:31.010]                 }
[17:00:31.010]                 NAMES <- toupper(removed)
[17:00:31.010]                 for (kk in seq_along(NAMES)) {
[17:00:31.010]                   name <- removed[[kk]]
[17:00:31.010]                   NAME <- NAMES[[kk]]
[17:00:31.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.010]                     next
[17:00:31.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.010]                 }
[17:00:31.010]                 if (length(args) > 0) 
[17:00:31.010]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.010]             }
[17:00:31.010]             else {
[17:00:31.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.010]             }
[17:00:31.010]             {
[17:00:31.010]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.010]                   0L) {
[17:00:31.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.010]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.010]                   base::options(opts)
[17:00:31.010]                 }
[17:00:31.010]                 {
[17:00:31.010]                   {
[17:00:31.010]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.010]                     NULL
[17:00:31.010]                   }
[17:00:31.010]                   options(future.plan = NULL)
[17:00:31.010]                   if (is.na(NA_character_)) 
[17:00:31.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.010]                     .init = FALSE)
[17:00:31.010]                 }
[17:00:31.010]             }
[17:00:31.010]         }
[17:00:31.010]     })
[17:00:31.010]     if (TRUE) {
[17:00:31.010]         base::sink(type = "output", split = FALSE)
[17:00:31.010]         if (TRUE) {
[17:00:31.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.010]         }
[17:00:31.010]         else {
[17:00:31.010]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.010]         }
[17:00:31.010]         base::close(...future.stdout)
[17:00:31.010]         ...future.stdout <- NULL
[17:00:31.010]     }
[17:00:31.010]     ...future.result$conditions <- ...future.conditions
[17:00:31.010]     ...future.result$finished <- base::Sys.time()
[17:00:31.010]     ...future.result
[17:00:31.010] }
[17:00:31.015] assign_globals() ...
[17:00:31.015] List of 5
[17:00:31.015]  $ ...future.FUN            :function (x, y)  
[17:00:31.015]  $ MoreArgs                 :List of 1
[17:00:31.015]   ..$ y: int [1:2] 3 4
[17:00:31.015]  $ ...future.elements_ii    :List of 1
[17:00:31.015]   ..$ x:List of 1
[17:00:31.015]   .. ..$ : int 1
[17:00:31.015]  $ ...future.seeds_ii       : NULL
[17:00:31.015]  $ ...future.globals.maxSize: NULL
[17:00:31.015]  - attr(*, "where")=List of 5
[17:00:31.015]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.015]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.015]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.015]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.015]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.015]  - attr(*, "resolved")= logi FALSE
[17:00:31.015]  - attr(*, "total_size")= num 1816
[17:00:31.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.015]  - attr(*, "already-done")= logi TRUE
[17:00:31.022] - reassign environment for ‘...future.FUN’
[17:00:31.022] - copied ‘...future.FUN’ to environment
[17:00:31.022] - copied ‘MoreArgs’ to environment
[17:00:31.022] - copied ‘...future.elements_ii’ to environment
[17:00:31.022] - copied ‘...future.seeds_ii’ to environment
[17:00:31.022] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.022] assign_globals() ... done
[17:00:31.023] requestCore(): workers = 2
[17:00:31.025] MulticoreFuture started
[17:00:31.026] - Launch lazy future ... done
[17:00:31.026] run() for ‘MulticoreFuture’ ... done
[17:00:31.026] plan(): Setting new future strategy stack:
[17:00:31.026] Created future:
[17:00:31.026] List of future strategies:
[17:00:31.026] 1. sequential:
[17:00:31.026]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.026]    - tweaked: FALSE
[17:00:31.026]    - call: NULL
[17:00:31.028] plan(): nbrOfWorkers() = 1
[17:00:31.030] plan(): Setting new future strategy stack:
[17:00:31.030] List of future strategies:
[17:00:31.030] 1. multicore:
[17:00:31.030]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.030]    - tweaked: FALSE
[17:00:31.030]    - call: plan(strategy)
[17:00:31.036] plan(): nbrOfWorkers() = 2
[17:00:31.027] MulticoreFuture:
[17:00:31.027] Label: ‘future_.mapply-1’
[17:00:31.027] Expression:
[17:00:31.027] {
[17:00:31.027]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.027]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.027]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.027]         on.exit(options(oopts), add = TRUE)
[17:00:31.027]     }
[17:00:31.027]     {
[17:00:31.027]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.027]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.027]         do.call(mapply, args = args)
[17:00:31.027]     }
[17:00:31.027] }
[17:00:31.027] Lazy evaluation: FALSE
[17:00:31.027] Asynchronous evaluation: TRUE
[17:00:31.027] Local evaluation: TRUE
[17:00:31.027] Environment: R_GlobalEnv
[17:00:31.027] Capture standard output: TRUE
[17:00:31.027] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.027] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.027] Packages: <none>
[17:00:31.027] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:31.027] Resolved: TRUE
[17:00:31.027] Value: <not collected>
[17:00:31.027] Conditions captured: <none>
[17:00:31.027] Early signaling: FALSE
[17:00:31.027] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.027] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.037] Chunk #1 of 2 ... DONE
[17:00:31.037] Chunk #2 of 2 ...
[17:00:31.038]  - Finding globals in '...' for chunk #2 ...
[17:00:31.038] getGlobalsAndPackages() ...
[17:00:31.038] Searching for globals...
[17:00:31.039] 
[17:00:31.039] Searching for globals ... DONE
[17:00:31.039] - globals: [0] <none>
[17:00:31.039] getGlobalsAndPackages() ... DONE
[17:00:31.039]    + additional globals found: [n=0] 
[17:00:31.039]    + additional namespaces needed: [n=0] 
[17:00:31.040]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:31.040]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.040]  - seeds: <none>
[17:00:31.040]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.040] getGlobalsAndPackages() ...
[17:00:31.040] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.041] Resolving globals: FALSE
[17:00:31.042] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:00:31.042] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:00:31.043] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.043] 
[17:00:31.043] getGlobalsAndPackages() ... DONE
[17:00:31.043] run() for ‘Future’ ...
[17:00:31.044] - state: ‘created’
[17:00:31.044] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.048] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.049] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.049]   - Field: ‘label’
[17:00:31.049]   - Field: ‘local’
[17:00:31.049]   - Field: ‘owner’
[17:00:31.049]   - Field: ‘envir’
[17:00:31.049]   - Field: ‘workers’
[17:00:31.050]   - Field: ‘packages’
[17:00:31.050]   - Field: ‘gc’
[17:00:31.050]   - Field: ‘job’
[17:00:31.050]   - Field: ‘conditions’
[17:00:31.050]   - Field: ‘expr’
[17:00:31.050]   - Field: ‘uuid’
[17:00:31.050]   - Field: ‘seed’
[17:00:31.050]   - Field: ‘version’
[17:00:31.051]   - Field: ‘result’
[17:00:31.051]   - Field: ‘asynchronous’
[17:00:31.051]   - Field: ‘calls’
[17:00:31.051]   - Field: ‘globals’
[17:00:31.051]   - Field: ‘stdout’
[17:00:31.051]   - Field: ‘earlySignal’
[17:00:31.052]   - Field: ‘lazy’
[17:00:31.052]   - Field: ‘state’
[17:00:31.052] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.052] - Launch lazy future ...
[17:00:31.052] Packages needed by the future expression (n = 0): <none>
[17:00:31.053] Packages needed by future strategies (n = 0): <none>
[17:00:31.053] {
[17:00:31.053]     {
[17:00:31.053]         {
[17:00:31.053]             ...future.startTime <- base::Sys.time()
[17:00:31.053]             {
[17:00:31.053]                 {
[17:00:31.053]                   {
[17:00:31.053]                     {
[17:00:31.053]                       base::local({
[17:00:31.053]                         has_future <- base::requireNamespace("future", 
[17:00:31.053]                           quietly = TRUE)
[17:00:31.053]                         if (has_future) {
[17:00:31.053]                           ns <- base::getNamespace("future")
[17:00:31.053]                           version <- ns[[".package"]][["version"]]
[17:00:31.053]                           if (is.null(version)) 
[17:00:31.053]                             version <- utils::packageVersion("future")
[17:00:31.053]                         }
[17:00:31.053]                         else {
[17:00:31.053]                           version <- NULL
[17:00:31.053]                         }
[17:00:31.053]                         if (!has_future || version < "1.8.0") {
[17:00:31.053]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.053]                             "", base::R.version$version.string), 
[17:00:31.053]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:31.053]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:31.053]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.053]                               "release", "version")], collapse = " "), 
[17:00:31.053]                             hostname = base::Sys.info()[["nodename"]])
[17:00:31.053]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.053]                             info)
[17:00:31.053]                           info <- base::paste(info, collapse = "; ")
[17:00:31.053]                           if (!has_future) {
[17:00:31.053]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.053]                               info)
[17:00:31.053]                           }
[17:00:31.053]                           else {
[17:00:31.053]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.053]                               info, version)
[17:00:31.053]                           }
[17:00:31.053]                           base::stop(msg)
[17:00:31.053]                         }
[17:00:31.053]                       })
[17:00:31.053]                     }
[17:00:31.053]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.053]                     base::options(mc.cores = 1L)
[17:00:31.053]                   }
[17:00:31.053]                   ...future.strategy.old <- future::plan("list")
[17:00:31.053]                   options(future.plan = NULL)
[17:00:31.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.053]                 }
[17:00:31.053]                 ...future.workdir <- getwd()
[17:00:31.053]             }
[17:00:31.053]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.053]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.053]         }
[17:00:31.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.053]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.053]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.053]             base::names(...future.oldOptions))
[17:00:31.053]     }
[17:00:31.053]     if (FALSE) {
[17:00:31.053]     }
[17:00:31.053]     else {
[17:00:31.053]         if (TRUE) {
[17:00:31.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.053]                 open = "w")
[17:00:31.053]         }
[17:00:31.053]         else {
[17:00:31.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.053]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.053]         }
[17:00:31.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.053]             base::sink(type = "output", split = FALSE)
[17:00:31.053]             base::close(...future.stdout)
[17:00:31.053]         }, add = TRUE)
[17:00:31.053]     }
[17:00:31.053]     ...future.frame <- base::sys.nframe()
[17:00:31.053]     ...future.conditions <- base::list()
[17:00:31.053]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.053]     if (FALSE) {
[17:00:31.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.053]     }
[17:00:31.053]     ...future.result <- base::tryCatch({
[17:00:31.053]         base::withCallingHandlers({
[17:00:31.053]             ...future.value <- base::withVisible(base::local({
[17:00:31.053]                 withCallingHandlers({
[17:00:31.053]                   {
[17:00:31.053]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.053]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.053]                       ...future.globals.maxSize)) {
[17:00:31.053]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.053]                       on.exit(options(oopts), add = TRUE)
[17:00:31.053]                     }
[17:00:31.053]                     {
[17:00:31.053]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.053]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.053]                         USE.NAMES = FALSE)
[17:00:31.053]                       do.call(mapply, args = args)
[17:00:31.053]                     }
[17:00:31.053]                   }
[17:00:31.053]                 }, immediateCondition = function(cond) {
[17:00:31.053]                   save_rds <- function (object, pathname, ...) 
[17:00:31.053]                   {
[17:00:31.053]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.053]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.053]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.053]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.053]                         fi_tmp[["mtime"]])
[17:00:31.053]                     }
[17:00:31.053]                     tryCatch({
[17:00:31.053]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.053]                     }, error = function(ex) {
[17:00:31.053]                       msg <- conditionMessage(ex)
[17:00:31.053]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.053]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.053]                         fi_tmp[["mtime"]], msg)
[17:00:31.053]                       ex$message <- msg
[17:00:31.053]                       stop(ex)
[17:00:31.053]                     })
[17:00:31.053]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.053]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.053]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.053]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.053]                       fi <- file.info(pathname)
[17:00:31.053]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.053]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.053]                         fi[["size"]], fi[["mtime"]])
[17:00:31.053]                       stop(msg)
[17:00:31.053]                     }
[17:00:31.053]                     invisible(pathname)
[17:00:31.053]                   }
[17:00:31.053]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.053]                     rootPath = tempdir()) 
[17:00:31.053]                   {
[17:00:31.053]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.053]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.053]                       tmpdir = path, fileext = ".rds")
[17:00:31.053]                     save_rds(obj, file)
[17:00:31.053]                   }
[17:00:31.053]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.053]                   {
[17:00:31.053]                     inherits <- base::inherits
[17:00:31.053]                     invokeRestart <- base::invokeRestart
[17:00:31.053]                     is.null <- base::is.null
[17:00:31.053]                     muffled <- FALSE
[17:00:31.053]                     if (inherits(cond, "message")) {
[17:00:31.053]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.053]                       if (muffled) 
[17:00:31.053]                         invokeRestart("muffleMessage")
[17:00:31.053]                     }
[17:00:31.053]                     else if (inherits(cond, "warning")) {
[17:00:31.053]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.053]                       if (muffled) 
[17:00:31.053]                         invokeRestart("muffleWarning")
[17:00:31.053]                     }
[17:00:31.053]                     else if (inherits(cond, "condition")) {
[17:00:31.053]                       if (!is.null(pattern)) {
[17:00:31.053]                         computeRestarts <- base::computeRestarts
[17:00:31.053]                         grepl <- base::grepl
[17:00:31.053]                         restarts <- computeRestarts(cond)
[17:00:31.053]                         for (restart in restarts) {
[17:00:31.053]                           name <- restart$name
[17:00:31.053]                           if (is.null(name)) 
[17:00:31.053]                             next
[17:00:31.053]                           if (!grepl(pattern, name)) 
[17:00:31.053]                             next
[17:00:31.053]                           invokeRestart(restart)
[17:00:31.053]                           muffled <- TRUE
[17:00:31.053]                           break
[17:00:31.053]                         }
[17:00:31.053]                       }
[17:00:31.053]                     }
[17:00:31.053]                     invisible(muffled)
[17:00:31.053]                   }
[17:00:31.053]                   muffleCondition(cond)
[17:00:31.053]                 })
[17:00:31.053]             }))
[17:00:31.053]             future::FutureResult(value = ...future.value$value, 
[17:00:31.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.053]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.053]                     ...future.globalenv.names))
[17:00:31.053]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.053]         }, condition = base::local({
[17:00:31.053]             c <- base::c
[17:00:31.053]             inherits <- base::inherits
[17:00:31.053]             invokeRestart <- base::invokeRestart
[17:00:31.053]             length <- base::length
[17:00:31.053]             list <- base::list
[17:00:31.053]             seq.int <- base::seq.int
[17:00:31.053]             signalCondition <- base::signalCondition
[17:00:31.053]             sys.calls <- base::sys.calls
[17:00:31.053]             `[[` <- base::`[[`
[17:00:31.053]             `+` <- base::`+`
[17:00:31.053]             `<<-` <- base::`<<-`
[17:00:31.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.053]                   3L)]
[17:00:31.053]             }
[17:00:31.053]             function(cond) {
[17:00:31.053]                 is_error <- inherits(cond, "error")
[17:00:31.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.053]                   NULL)
[17:00:31.053]                 if (is_error) {
[17:00:31.053]                   sessionInformation <- function() {
[17:00:31.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.053]                       search = base::search(), system = base::Sys.info())
[17:00:31.053]                   }
[17:00:31.053]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.053]                     cond$call), session = sessionInformation(), 
[17:00:31.053]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.053]                   signalCondition(cond)
[17:00:31.053]                 }
[17:00:31.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.053]                 "immediateCondition"))) {
[17:00:31.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.053]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.053]                   if (TRUE && !signal) {
[17:00:31.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.053]                     {
[17:00:31.053]                       inherits <- base::inherits
[17:00:31.053]                       invokeRestart <- base::invokeRestart
[17:00:31.053]                       is.null <- base::is.null
[17:00:31.053]                       muffled <- FALSE
[17:00:31.053]                       if (inherits(cond, "message")) {
[17:00:31.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.053]                         if (muffled) 
[17:00:31.053]                           invokeRestart("muffleMessage")
[17:00:31.053]                       }
[17:00:31.053]                       else if (inherits(cond, "warning")) {
[17:00:31.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.053]                         if (muffled) 
[17:00:31.053]                           invokeRestart("muffleWarning")
[17:00:31.053]                       }
[17:00:31.053]                       else if (inherits(cond, "condition")) {
[17:00:31.053]                         if (!is.null(pattern)) {
[17:00:31.053]                           computeRestarts <- base::computeRestarts
[17:00:31.053]                           grepl <- base::grepl
[17:00:31.053]                           restarts <- computeRestarts(cond)
[17:00:31.053]                           for (restart in restarts) {
[17:00:31.053]                             name <- restart$name
[17:00:31.053]                             if (is.null(name)) 
[17:00:31.053]                               next
[17:00:31.053]                             if (!grepl(pattern, name)) 
[17:00:31.053]                               next
[17:00:31.053]                             invokeRestart(restart)
[17:00:31.053]                             muffled <- TRUE
[17:00:31.053]                             break
[17:00:31.053]                           }
[17:00:31.053]                         }
[17:00:31.053]                       }
[17:00:31.053]                       invisible(muffled)
[17:00:31.053]                     }
[17:00:31.053]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.053]                   }
[17:00:31.053]                 }
[17:00:31.053]                 else {
[17:00:31.053]                   if (TRUE) {
[17:00:31.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.053]                     {
[17:00:31.053]                       inherits <- base::inherits
[17:00:31.053]                       invokeRestart <- base::invokeRestart
[17:00:31.053]                       is.null <- base::is.null
[17:00:31.053]                       muffled <- FALSE
[17:00:31.053]                       if (inherits(cond, "message")) {
[17:00:31.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.053]                         if (muffled) 
[17:00:31.053]                           invokeRestart("muffleMessage")
[17:00:31.053]                       }
[17:00:31.053]                       else if (inherits(cond, "warning")) {
[17:00:31.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.053]                         if (muffled) 
[17:00:31.053]                           invokeRestart("muffleWarning")
[17:00:31.053]                       }
[17:00:31.053]                       else if (inherits(cond, "condition")) {
[17:00:31.053]                         if (!is.null(pattern)) {
[17:00:31.053]                           computeRestarts <- base::computeRestarts
[17:00:31.053]                           grepl <- base::grepl
[17:00:31.053]                           restarts <- computeRestarts(cond)
[17:00:31.053]                           for (restart in restarts) {
[17:00:31.053]                             name <- restart$name
[17:00:31.053]                             if (is.null(name)) 
[17:00:31.053]                               next
[17:00:31.053]                             if (!grepl(pattern, name)) 
[17:00:31.053]                               next
[17:00:31.053]                             invokeRestart(restart)
[17:00:31.053]                             muffled <- TRUE
[17:00:31.053]                             break
[17:00:31.053]                           }
[17:00:31.053]                         }
[17:00:31.053]                       }
[17:00:31.053]                       invisible(muffled)
[17:00:31.053]                     }
[17:00:31.053]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.053]                   }
[17:00:31.053]                 }
[17:00:31.053]             }
[17:00:31.053]         }))
[17:00:31.053]     }, error = function(ex) {
[17:00:31.053]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.053]                 ...future.rng), started = ...future.startTime, 
[17:00:31.053]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.053]             version = "1.8"), class = "FutureResult")
[17:00:31.053]     }, finally = {
[17:00:31.053]         if (!identical(...future.workdir, getwd())) 
[17:00:31.053]             setwd(...future.workdir)
[17:00:31.053]         {
[17:00:31.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.053]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.053]             }
[17:00:31.053]             base::options(...future.oldOptions)
[17:00:31.053]             if (.Platform$OS.type == "windows") {
[17:00:31.053]                 old_names <- names(...future.oldEnvVars)
[17:00:31.053]                 envs <- base::Sys.getenv()
[17:00:31.053]                 names <- names(envs)
[17:00:31.053]                 common <- intersect(names, old_names)
[17:00:31.053]                 added <- setdiff(names, old_names)
[17:00:31.053]                 removed <- setdiff(old_names, names)
[17:00:31.053]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.053]                   envs[common]]
[17:00:31.053]                 NAMES <- toupper(changed)
[17:00:31.053]                 args <- list()
[17:00:31.053]                 for (kk in seq_along(NAMES)) {
[17:00:31.053]                   name <- changed[[kk]]
[17:00:31.053]                   NAME <- NAMES[[kk]]
[17:00:31.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.053]                     next
[17:00:31.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.053]                 }
[17:00:31.053]                 NAMES <- toupper(added)
[17:00:31.053]                 for (kk in seq_along(NAMES)) {
[17:00:31.053]                   name <- added[[kk]]
[17:00:31.053]                   NAME <- NAMES[[kk]]
[17:00:31.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.053]                     next
[17:00:31.053]                   args[[name]] <- ""
[17:00:31.053]                 }
[17:00:31.053]                 NAMES <- toupper(removed)
[17:00:31.053]                 for (kk in seq_along(NAMES)) {
[17:00:31.053]                   name <- removed[[kk]]
[17:00:31.053]                   NAME <- NAMES[[kk]]
[17:00:31.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.053]                     next
[17:00:31.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.053]                 }
[17:00:31.053]                 if (length(args) > 0) 
[17:00:31.053]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.053]             }
[17:00:31.053]             else {
[17:00:31.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.053]             }
[17:00:31.053]             {
[17:00:31.053]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.053]                   0L) {
[17:00:31.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.053]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.053]                   base::options(opts)
[17:00:31.053]                 }
[17:00:31.053]                 {
[17:00:31.053]                   {
[17:00:31.053]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.053]                     NULL
[17:00:31.053]                   }
[17:00:31.053]                   options(future.plan = NULL)
[17:00:31.053]                   if (is.na(NA_character_)) 
[17:00:31.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.053]                     .init = FALSE)
[17:00:31.053]                 }
[17:00:31.053]             }
[17:00:31.053]         }
[17:00:31.053]     })
[17:00:31.053]     if (TRUE) {
[17:00:31.053]         base::sink(type = "output", split = FALSE)
[17:00:31.053]         if (TRUE) {
[17:00:31.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.053]         }
[17:00:31.053]         else {
[17:00:31.053]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.053]         }
[17:00:31.053]         base::close(...future.stdout)
[17:00:31.053]         ...future.stdout <- NULL
[17:00:31.053]     }
[17:00:31.053]     ...future.result$conditions <- ...future.conditions
[17:00:31.053]     ...future.result$finished <- base::Sys.time()
[17:00:31.053]     ...future.result
[17:00:31.053] }
[17:00:31.057] assign_globals() ...
[17:00:31.057] List of 5
[17:00:31.057]  $ ...future.FUN            :function (x, y)  
[17:00:31.057]  $ MoreArgs                 :List of 1
[17:00:31.057]   ..$ y: int [1:2] 3 4
[17:00:31.057]  $ ...future.elements_ii    :List of 1
[17:00:31.057]   ..$ x:List of 1
[17:00:31.057]   .. ..$ : int 2
[17:00:31.057]  $ ...future.seeds_ii       : NULL
[17:00:31.057]  $ ...future.globals.maxSize: NULL
[17:00:31.057]  - attr(*, "where")=List of 5
[17:00:31.057]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.057]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.057]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.057]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.057]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.057]  - attr(*, "resolved")= logi FALSE
[17:00:31.057]  - attr(*, "total_size")= num 1816
[17:00:31.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.057]  - attr(*, "already-done")= logi TRUE
[17:00:31.070] - reassign environment for ‘...future.FUN’
[17:00:31.070] - copied ‘...future.FUN’ to environment
[17:00:31.070] - copied ‘MoreArgs’ to environment
[17:00:31.071] - copied ‘...future.elements_ii’ to environment
[17:00:31.071] - copied ‘...future.seeds_ii’ to environment
[17:00:31.071] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.071] assign_globals() ... done
[17:00:31.071] requestCore(): workers = 2
[17:00:31.074] MulticoreFuture started
[17:00:31.075] - Launch lazy future ... done
[17:00:31.075] plan(): Setting new future strategy stack:
[17:00:31.075] run() for ‘MulticoreFuture’ ... done
[17:00:31.076] Created future:
[17:00:31.076] List of future strategies:
[17:00:31.076] 1. sequential:
[17:00:31.076]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.076]    - tweaked: FALSE
[17:00:31.076]    - call: NULL
[17:00:31.078] plan(): nbrOfWorkers() = 1
[17:00:31.081] plan(): Setting new future strategy stack:
[17:00:31.081] List of future strategies:
[17:00:31.081] 1. multicore:
[17:00:31.081]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.081]    - tweaked: FALSE
[17:00:31.081]    - call: plan(strategy)
[17:00:31.088] plan(): nbrOfWorkers() = 2
[17:00:31.076] MulticoreFuture:
[17:00:31.076] Label: ‘future_.mapply-2’
[17:00:31.076] Expression:
[17:00:31.076] {
[17:00:31.076]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.076]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.076]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.076]         on.exit(options(oopts), add = TRUE)
[17:00:31.076]     }
[17:00:31.076]     {
[17:00:31.076]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.076]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.076]         do.call(mapply, args = args)
[17:00:31.076]     }
[17:00:31.076] }
[17:00:31.076] Lazy evaluation: FALSE
[17:00:31.076] Asynchronous evaluation: TRUE
[17:00:31.076] Local evaluation: TRUE
[17:00:31.076] Environment: R_GlobalEnv
[17:00:31.076] Capture standard output: TRUE
[17:00:31.076] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.076] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.076] Packages: <none>
[17:00:31.076] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:31.076] Resolved: TRUE
[17:00:31.076] Value: <not collected>
[17:00:31.076] Conditions captured: <none>
[17:00:31.076] Early signaling: FALSE
[17:00:31.076] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.076] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.090] Chunk #2 of 2 ... DONE
[17:00:31.090] Launching 2 futures (chunks) ... DONE
[17:00:31.090] Resolving 2 futures (chunks) ...
[17:00:31.091] resolve() on list ...
[17:00:31.091]  recursive: 0
[17:00:31.091]  length: 2
[17:00:31.091] 
[17:00:31.092] Future #1
[17:00:31.092] result() for MulticoreFuture ...
[17:00:31.093] result() for MulticoreFuture ...
[17:00:31.094] result() for MulticoreFuture ... done
[17:00:31.094] result() for MulticoreFuture ... done
[17:00:31.094] result() for MulticoreFuture ...
[17:00:31.094] result() for MulticoreFuture ... done
[17:00:31.095] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:31.095] - nx: 2
[17:00:31.095] - relay: TRUE
[17:00:31.095] - stdout: TRUE
[17:00:31.095] - signal: TRUE
[17:00:31.096] - resignal: FALSE
[17:00:31.096] - force: TRUE
[17:00:31.096] - relayed: [n=2] FALSE, FALSE
[17:00:31.096] - queued futures: [n=2] FALSE, FALSE
[17:00:31.096]  - until=1
[17:00:31.096]  - relaying element #1
[17:00:31.097] result() for MulticoreFuture ...
[17:00:31.097] result() for MulticoreFuture ... done
[17:00:31.097] result() for MulticoreFuture ...
[17:00:31.097] result() for MulticoreFuture ... done
[17:00:31.098] result() for MulticoreFuture ...
[17:00:31.098] result() for MulticoreFuture ... done
[17:00:31.098] result() for MulticoreFuture ...
[17:00:31.098] result() for MulticoreFuture ... done
[17:00:31.098] - relayed: [n=2] TRUE, FALSE
[17:00:31.098] - queued futures: [n=2] TRUE, FALSE
[17:00:31.098] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:31.099]  length: 1 (resolved future 1)
[17:00:31.099] Future #2
[17:00:31.099] result() for MulticoreFuture ...
[17:00:31.100] result() for MulticoreFuture ...
[17:00:31.100] result() for MulticoreFuture ... done
[17:00:31.101] result() for MulticoreFuture ... done
[17:00:31.101] result() for MulticoreFuture ...
[17:00:31.101] result() for MulticoreFuture ... done
[17:00:31.101] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:31.101] - nx: 2
[17:00:31.101] - relay: TRUE
[17:00:31.101] - stdout: TRUE
[17:00:31.102] - signal: TRUE
[17:00:31.102] - resignal: FALSE
[17:00:31.102] - force: TRUE
[17:00:31.102] - relayed: [n=2] TRUE, FALSE
[17:00:31.102] - queued futures: [n=2] TRUE, FALSE
[17:00:31.102]  - until=2
[17:00:31.102]  - relaying element #2
[17:00:31.102] result() for MulticoreFuture ...
[17:00:31.102] result() for MulticoreFuture ... done
[17:00:31.103] result() for MulticoreFuture ...
[17:00:31.103] result() for MulticoreFuture ... done
[17:00:31.103] result() for MulticoreFuture ...
[17:00:31.103] result() for MulticoreFuture ... done
[17:00:31.103] result() for MulticoreFuture ...
[17:00:31.103] result() for MulticoreFuture ... done
[17:00:31.103] - relayed: [n=2] TRUE, TRUE
[17:00:31.103] - queued futures: [n=2] TRUE, TRUE
[17:00:31.103] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:31.104]  length: 0 (resolved future 2)
[17:00:31.104] Relaying remaining futures
[17:00:31.104] signalConditionsASAP(NULL, pos=0) ...
[17:00:31.104] - nx: 2
[17:00:31.104] - relay: TRUE
[17:00:31.104] - stdout: TRUE
[17:00:31.104] - signal: TRUE
[17:00:31.104] - resignal: FALSE
[17:00:31.104] - force: TRUE
[17:00:31.104] - relayed: [n=2] TRUE, TRUE
[17:00:31.105] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:31.105] - relayed: [n=2] TRUE, TRUE
[17:00:31.105] - queued futures: [n=2] TRUE, TRUE
[17:00:31.105] signalConditionsASAP(NULL, pos=0) ... done
[17:00:31.105] resolve() on list ... DONE
[17:00:31.105] result() for MulticoreFuture ...
[17:00:31.105] result() for MulticoreFuture ... done
[17:00:31.105] result() for MulticoreFuture ...
[17:00:31.105] result() for MulticoreFuture ... done
[17:00:31.106] result() for MulticoreFuture ...
[17:00:31.106] result() for MulticoreFuture ... done
[17:00:31.106] result() for MulticoreFuture ...
[17:00:31.106] result() for MulticoreFuture ... done
[17:00:31.106]  - Number of value chunks collected: 2
[17:00:31.106] Resolving 2 futures (chunks) ... DONE
[17:00:31.106] Reducing values from 2 chunks ...
[17:00:31.106]  - Number of values collected after concatenation: 2
[17:00:31.106]  - Number of values expected: 2
[17:00:31.107] Reducing values from 2 chunks ... DONE
[17:00:31.107] future_mapply() ... DONE
- Recycle arguments to same length ...
[17:00:31.107] future_mapply() ...
[17:00:31.111] Number of chunks: 2
[17:00:31.111] getGlobalsAndPackagesXApply() ...
[17:00:31.111]  - future.globals: TRUE
[17:00:31.112] getGlobalsAndPackages() ...
[17:00:31.112] Searching for globals...
[17:00:31.112] - globals found: [1] ‘FUN’
[17:00:31.113] Searching for globals ... DONE
[17:00:31.113] Resolving globals: FALSE
[17:00:31.113] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:31.113] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:31.114] - globals: [1] ‘FUN’
[17:00:31.114] 
[17:00:31.114] getGlobalsAndPackages() ... DONE
[17:00:31.114]  - globals found/used: [n=1] ‘FUN’
[17:00:31.114]  - needed namespaces: [n=0] 
[17:00:31.114] Finding globals ... DONE
[17:00:31.114] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:31.114] List of 2
[17:00:31.114]  $ ...future.FUN:function (x, ...)  
[17:00:31.114]  $ MoreArgs     : NULL
[17:00:31.114]  - attr(*, "where")=List of 2
[17:00:31.114]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:31.114]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:31.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.114]  - attr(*, "resolved")= logi FALSE
[17:00:31.114]  - attr(*, "total_size")= num NA
[17:00:31.121] Packages to be attached in all futures: [n=0] 
[17:00:31.121] getGlobalsAndPackagesXApply() ... DONE
[17:00:31.121] Number of futures (= number of chunks): 2
[17:00:31.121] Launching 2 futures (chunks) ...
[17:00:31.121] Chunk #1 of 2 ...
[17:00:31.121]  - Finding globals in '...' for chunk #1 ...
[17:00:31.122] getGlobalsAndPackages() ...
[17:00:31.122] Searching for globals...
[17:00:31.122] 
[17:00:31.122] Searching for globals ... DONE
[17:00:31.122] - globals: [0] <none>
[17:00:31.122] getGlobalsAndPackages() ... DONE
[17:00:31.123]    + additional globals found: [n=0] 
[17:00:31.123]    + additional namespaces needed: [n=0] 
[17:00:31.123]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:31.123]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.123]  - seeds: <none>
[17:00:31.123]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.123] getGlobalsAndPackages() ...
[17:00:31.123] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.124] Resolving globals: FALSE
[17:00:31.124] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:31.125] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:31.125] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.125] 
[17:00:31.125] getGlobalsAndPackages() ... DONE
[17:00:31.126] run() for ‘Future’ ...
[17:00:31.126] - state: ‘created’
[17:00:31.126] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.130] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.130] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.130]   - Field: ‘label’
[17:00:31.130]   - Field: ‘local’
[17:00:31.130]   - Field: ‘owner’
[17:00:31.130]   - Field: ‘envir’
[17:00:31.130]   - Field: ‘workers’
[17:00:31.130]   - Field: ‘packages’
[17:00:31.131]   - Field: ‘gc’
[17:00:31.131]   - Field: ‘job’
[17:00:31.131]   - Field: ‘conditions’
[17:00:31.131]   - Field: ‘expr’
[17:00:31.131]   - Field: ‘uuid’
[17:00:31.131]   - Field: ‘seed’
[17:00:31.131]   - Field: ‘version’
[17:00:31.131]   - Field: ‘result’
[17:00:31.131]   - Field: ‘asynchronous’
[17:00:31.131]   - Field: ‘calls’
[17:00:31.132]   - Field: ‘globals’
[17:00:31.132]   - Field: ‘stdout’
[17:00:31.132]   - Field: ‘earlySignal’
[17:00:31.132]   - Field: ‘lazy’
[17:00:31.132]   - Field: ‘state’
[17:00:31.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.132] - Launch lazy future ...
[17:00:31.132] Packages needed by the future expression (n = 0): <none>
[17:00:31.132] Packages needed by future strategies (n = 0): <none>
[17:00:31.133] {
[17:00:31.133]     {
[17:00:31.133]         {
[17:00:31.133]             ...future.startTime <- base::Sys.time()
[17:00:31.133]             {
[17:00:31.133]                 {
[17:00:31.133]                   {
[17:00:31.133]                     {
[17:00:31.133]                       base::local({
[17:00:31.133]                         has_future <- base::requireNamespace("future", 
[17:00:31.133]                           quietly = TRUE)
[17:00:31.133]                         if (has_future) {
[17:00:31.133]                           ns <- base::getNamespace("future")
[17:00:31.133]                           version <- ns[[".package"]][["version"]]
[17:00:31.133]                           if (is.null(version)) 
[17:00:31.133]                             version <- utils::packageVersion("future")
[17:00:31.133]                         }
[17:00:31.133]                         else {
[17:00:31.133]                           version <- NULL
[17:00:31.133]                         }
[17:00:31.133]                         if (!has_future || version < "1.8.0") {
[17:00:31.133]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.133]                             "", base::R.version$version.string), 
[17:00:31.133]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:31.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:31.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.133]                               "release", "version")], collapse = " "), 
[17:00:31.133]                             hostname = base::Sys.info()[["nodename"]])
[17:00:31.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.133]                             info)
[17:00:31.133]                           info <- base::paste(info, collapse = "; ")
[17:00:31.133]                           if (!has_future) {
[17:00:31.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.133]                               info)
[17:00:31.133]                           }
[17:00:31.133]                           else {
[17:00:31.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.133]                               info, version)
[17:00:31.133]                           }
[17:00:31.133]                           base::stop(msg)
[17:00:31.133]                         }
[17:00:31.133]                       })
[17:00:31.133]                     }
[17:00:31.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.133]                     base::options(mc.cores = 1L)
[17:00:31.133]                   }
[17:00:31.133]                   ...future.strategy.old <- future::plan("list")
[17:00:31.133]                   options(future.plan = NULL)
[17:00:31.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.133]                 }
[17:00:31.133]                 ...future.workdir <- getwd()
[17:00:31.133]             }
[17:00:31.133]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.133]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.133]         }
[17:00:31.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.133]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.133]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.133]             base::names(...future.oldOptions))
[17:00:31.133]     }
[17:00:31.133]     if (FALSE) {
[17:00:31.133]     }
[17:00:31.133]     else {
[17:00:31.133]         if (TRUE) {
[17:00:31.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.133]                 open = "w")
[17:00:31.133]         }
[17:00:31.133]         else {
[17:00:31.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.133]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.133]         }
[17:00:31.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.133]             base::sink(type = "output", split = FALSE)
[17:00:31.133]             base::close(...future.stdout)
[17:00:31.133]         }, add = TRUE)
[17:00:31.133]     }
[17:00:31.133]     ...future.frame <- base::sys.nframe()
[17:00:31.133]     ...future.conditions <- base::list()
[17:00:31.133]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.133]     if (FALSE) {
[17:00:31.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.133]     }
[17:00:31.133]     ...future.result <- base::tryCatch({
[17:00:31.133]         base::withCallingHandlers({
[17:00:31.133]             ...future.value <- base::withVisible(base::local({
[17:00:31.133]                 withCallingHandlers({
[17:00:31.133]                   {
[17:00:31.133]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.133]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.133]                       ...future.globals.maxSize)) {
[17:00:31.133]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.133]                       on.exit(options(oopts), add = TRUE)
[17:00:31.133]                     }
[17:00:31.133]                     {
[17:00:31.133]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.133]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.133]                         USE.NAMES = FALSE)
[17:00:31.133]                       do.call(mapply, args = args)
[17:00:31.133]                     }
[17:00:31.133]                   }
[17:00:31.133]                 }, immediateCondition = function(cond) {
[17:00:31.133]                   save_rds <- function (object, pathname, ...) 
[17:00:31.133]                   {
[17:00:31.133]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.133]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.133]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.133]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.133]                         fi_tmp[["mtime"]])
[17:00:31.133]                     }
[17:00:31.133]                     tryCatch({
[17:00:31.133]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.133]                     }, error = function(ex) {
[17:00:31.133]                       msg <- conditionMessage(ex)
[17:00:31.133]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.133]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.133]                         fi_tmp[["mtime"]], msg)
[17:00:31.133]                       ex$message <- msg
[17:00:31.133]                       stop(ex)
[17:00:31.133]                     })
[17:00:31.133]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.133]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.133]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.133]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.133]                       fi <- file.info(pathname)
[17:00:31.133]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.133]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.133]                         fi[["size"]], fi[["mtime"]])
[17:00:31.133]                       stop(msg)
[17:00:31.133]                     }
[17:00:31.133]                     invisible(pathname)
[17:00:31.133]                   }
[17:00:31.133]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.133]                     rootPath = tempdir()) 
[17:00:31.133]                   {
[17:00:31.133]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.133]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.133]                       tmpdir = path, fileext = ".rds")
[17:00:31.133]                     save_rds(obj, file)
[17:00:31.133]                   }
[17:00:31.133]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.133]                   {
[17:00:31.133]                     inherits <- base::inherits
[17:00:31.133]                     invokeRestart <- base::invokeRestart
[17:00:31.133]                     is.null <- base::is.null
[17:00:31.133]                     muffled <- FALSE
[17:00:31.133]                     if (inherits(cond, "message")) {
[17:00:31.133]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.133]                       if (muffled) 
[17:00:31.133]                         invokeRestart("muffleMessage")
[17:00:31.133]                     }
[17:00:31.133]                     else if (inherits(cond, "warning")) {
[17:00:31.133]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.133]                       if (muffled) 
[17:00:31.133]                         invokeRestart("muffleWarning")
[17:00:31.133]                     }
[17:00:31.133]                     else if (inherits(cond, "condition")) {
[17:00:31.133]                       if (!is.null(pattern)) {
[17:00:31.133]                         computeRestarts <- base::computeRestarts
[17:00:31.133]                         grepl <- base::grepl
[17:00:31.133]                         restarts <- computeRestarts(cond)
[17:00:31.133]                         for (restart in restarts) {
[17:00:31.133]                           name <- restart$name
[17:00:31.133]                           if (is.null(name)) 
[17:00:31.133]                             next
[17:00:31.133]                           if (!grepl(pattern, name)) 
[17:00:31.133]                             next
[17:00:31.133]                           invokeRestart(restart)
[17:00:31.133]                           muffled <- TRUE
[17:00:31.133]                           break
[17:00:31.133]                         }
[17:00:31.133]                       }
[17:00:31.133]                     }
[17:00:31.133]                     invisible(muffled)
[17:00:31.133]                   }
[17:00:31.133]                   muffleCondition(cond)
[17:00:31.133]                 })
[17:00:31.133]             }))
[17:00:31.133]             future::FutureResult(value = ...future.value$value, 
[17:00:31.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.133]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.133]                     ...future.globalenv.names))
[17:00:31.133]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.133]         }, condition = base::local({
[17:00:31.133]             c <- base::c
[17:00:31.133]             inherits <- base::inherits
[17:00:31.133]             invokeRestart <- base::invokeRestart
[17:00:31.133]             length <- base::length
[17:00:31.133]             list <- base::list
[17:00:31.133]             seq.int <- base::seq.int
[17:00:31.133]             signalCondition <- base::signalCondition
[17:00:31.133]             sys.calls <- base::sys.calls
[17:00:31.133]             `[[` <- base::`[[`
[17:00:31.133]             `+` <- base::`+`
[17:00:31.133]             `<<-` <- base::`<<-`
[17:00:31.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.133]                   3L)]
[17:00:31.133]             }
[17:00:31.133]             function(cond) {
[17:00:31.133]                 is_error <- inherits(cond, "error")
[17:00:31.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.133]                   NULL)
[17:00:31.133]                 if (is_error) {
[17:00:31.133]                   sessionInformation <- function() {
[17:00:31.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.133]                       search = base::search(), system = base::Sys.info())
[17:00:31.133]                   }
[17:00:31.133]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.133]                     cond$call), session = sessionInformation(), 
[17:00:31.133]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.133]                   signalCondition(cond)
[17:00:31.133]                 }
[17:00:31.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.133]                 "immediateCondition"))) {
[17:00:31.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.133]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.133]                   if (TRUE && !signal) {
[17:00:31.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.133]                     {
[17:00:31.133]                       inherits <- base::inherits
[17:00:31.133]                       invokeRestart <- base::invokeRestart
[17:00:31.133]                       is.null <- base::is.null
[17:00:31.133]                       muffled <- FALSE
[17:00:31.133]                       if (inherits(cond, "message")) {
[17:00:31.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.133]                         if (muffled) 
[17:00:31.133]                           invokeRestart("muffleMessage")
[17:00:31.133]                       }
[17:00:31.133]                       else if (inherits(cond, "warning")) {
[17:00:31.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.133]                         if (muffled) 
[17:00:31.133]                           invokeRestart("muffleWarning")
[17:00:31.133]                       }
[17:00:31.133]                       else if (inherits(cond, "condition")) {
[17:00:31.133]                         if (!is.null(pattern)) {
[17:00:31.133]                           computeRestarts <- base::computeRestarts
[17:00:31.133]                           grepl <- base::grepl
[17:00:31.133]                           restarts <- computeRestarts(cond)
[17:00:31.133]                           for (restart in restarts) {
[17:00:31.133]                             name <- restart$name
[17:00:31.133]                             if (is.null(name)) 
[17:00:31.133]                               next
[17:00:31.133]                             if (!grepl(pattern, name)) 
[17:00:31.133]                               next
[17:00:31.133]                             invokeRestart(restart)
[17:00:31.133]                             muffled <- TRUE
[17:00:31.133]                             break
[17:00:31.133]                           }
[17:00:31.133]                         }
[17:00:31.133]                       }
[17:00:31.133]                       invisible(muffled)
[17:00:31.133]                     }
[17:00:31.133]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.133]                   }
[17:00:31.133]                 }
[17:00:31.133]                 else {
[17:00:31.133]                   if (TRUE) {
[17:00:31.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.133]                     {
[17:00:31.133]                       inherits <- base::inherits
[17:00:31.133]                       invokeRestart <- base::invokeRestart
[17:00:31.133]                       is.null <- base::is.null
[17:00:31.133]                       muffled <- FALSE
[17:00:31.133]                       if (inherits(cond, "message")) {
[17:00:31.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.133]                         if (muffled) 
[17:00:31.133]                           invokeRestart("muffleMessage")
[17:00:31.133]                       }
[17:00:31.133]                       else if (inherits(cond, "warning")) {
[17:00:31.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.133]                         if (muffled) 
[17:00:31.133]                           invokeRestart("muffleWarning")
[17:00:31.133]                       }
[17:00:31.133]                       else if (inherits(cond, "condition")) {
[17:00:31.133]                         if (!is.null(pattern)) {
[17:00:31.133]                           computeRestarts <- base::computeRestarts
[17:00:31.133]                           grepl <- base::grepl
[17:00:31.133]                           restarts <- computeRestarts(cond)
[17:00:31.133]                           for (restart in restarts) {
[17:00:31.133]                             name <- restart$name
[17:00:31.133]                             if (is.null(name)) 
[17:00:31.133]                               next
[17:00:31.133]                             if (!grepl(pattern, name)) 
[17:00:31.133]                               next
[17:00:31.133]                             invokeRestart(restart)
[17:00:31.133]                             muffled <- TRUE
[17:00:31.133]                             break
[17:00:31.133]                           }
[17:00:31.133]                         }
[17:00:31.133]                       }
[17:00:31.133]                       invisible(muffled)
[17:00:31.133]                     }
[17:00:31.133]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.133]                   }
[17:00:31.133]                 }
[17:00:31.133]             }
[17:00:31.133]         }))
[17:00:31.133]     }, error = function(ex) {
[17:00:31.133]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.133]                 ...future.rng), started = ...future.startTime, 
[17:00:31.133]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.133]             version = "1.8"), class = "FutureResult")
[17:00:31.133]     }, finally = {
[17:00:31.133]         if (!identical(...future.workdir, getwd())) 
[17:00:31.133]             setwd(...future.workdir)
[17:00:31.133]         {
[17:00:31.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.133]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.133]             }
[17:00:31.133]             base::options(...future.oldOptions)
[17:00:31.133]             if (.Platform$OS.type == "windows") {
[17:00:31.133]                 old_names <- names(...future.oldEnvVars)
[17:00:31.133]                 envs <- base::Sys.getenv()
[17:00:31.133]                 names <- names(envs)
[17:00:31.133]                 common <- intersect(names, old_names)
[17:00:31.133]                 added <- setdiff(names, old_names)
[17:00:31.133]                 removed <- setdiff(old_names, names)
[17:00:31.133]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.133]                   envs[common]]
[17:00:31.133]                 NAMES <- toupper(changed)
[17:00:31.133]                 args <- list()
[17:00:31.133]                 for (kk in seq_along(NAMES)) {
[17:00:31.133]                   name <- changed[[kk]]
[17:00:31.133]                   NAME <- NAMES[[kk]]
[17:00:31.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.133]                     next
[17:00:31.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.133]                 }
[17:00:31.133]                 NAMES <- toupper(added)
[17:00:31.133]                 for (kk in seq_along(NAMES)) {
[17:00:31.133]                   name <- added[[kk]]
[17:00:31.133]                   NAME <- NAMES[[kk]]
[17:00:31.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.133]                     next
[17:00:31.133]                   args[[name]] <- ""
[17:00:31.133]                 }
[17:00:31.133]                 NAMES <- toupper(removed)
[17:00:31.133]                 for (kk in seq_along(NAMES)) {
[17:00:31.133]                   name <- removed[[kk]]
[17:00:31.133]                   NAME <- NAMES[[kk]]
[17:00:31.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.133]                     next
[17:00:31.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.133]                 }
[17:00:31.133]                 if (length(args) > 0) 
[17:00:31.133]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.133]             }
[17:00:31.133]             else {
[17:00:31.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.133]             }
[17:00:31.133]             {
[17:00:31.133]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.133]                   0L) {
[17:00:31.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.133]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.133]                   base::options(opts)
[17:00:31.133]                 }
[17:00:31.133]                 {
[17:00:31.133]                   {
[17:00:31.133]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.133]                     NULL
[17:00:31.133]                   }
[17:00:31.133]                   options(future.plan = NULL)
[17:00:31.133]                   if (is.na(NA_character_)) 
[17:00:31.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.133]                     .init = FALSE)
[17:00:31.133]                 }
[17:00:31.133]             }
[17:00:31.133]         }
[17:00:31.133]     })
[17:00:31.133]     if (TRUE) {
[17:00:31.133]         base::sink(type = "output", split = FALSE)
[17:00:31.133]         if (TRUE) {
[17:00:31.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.133]         }
[17:00:31.133]         else {
[17:00:31.133]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.133]         }
[17:00:31.133]         base::close(...future.stdout)
[17:00:31.133]         ...future.stdout <- NULL
[17:00:31.133]     }
[17:00:31.133]     ...future.result$conditions <- ...future.conditions
[17:00:31.133]     ...future.result$finished <- base::Sys.time()
[17:00:31.133]     ...future.result
[17:00:31.133] }
[17:00:31.136] assign_globals() ...
[17:00:31.136] List of 5
[17:00:31.136]  $ ...future.FUN            :function (x, ...)  
[17:00:31.136]  $ MoreArgs                 : NULL
[17:00:31.136]  $ ...future.elements_ii    :List of 2
[17:00:31.136]   ..$ :List of 2
[17:00:31.136]   .. ..$ : int 1
[17:00:31.136]   .. ..$ : int 2
[17:00:31.136]   ..$ :List of 2
[17:00:31.136]   .. ..$ : int 2
[17:00:31.136]   .. ..$ : int 1
[17:00:31.136]  $ ...future.seeds_ii       : NULL
[17:00:31.136]  $ ...future.globals.maxSize: NULL
[17:00:31.136]  - attr(*, "where")=List of 5
[17:00:31.136]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.136]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.136]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.136]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.136]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.136]  - attr(*, "resolved")= logi FALSE
[17:00:31.136]  - attr(*, "total_size")= num 280
[17:00:31.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.136]  - attr(*, "already-done")= logi TRUE
[17:00:31.142] - copied ‘...future.FUN’ to environment
[17:00:31.142] - copied ‘MoreArgs’ to environment
[17:00:31.142] - copied ‘...future.elements_ii’ to environment
[17:00:31.142] - copied ‘...future.seeds_ii’ to environment
[17:00:31.142] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.142] assign_globals() ... done
[17:00:31.142] requestCore(): workers = 2
[17:00:31.145] MulticoreFuture started
[17:00:31.145] - Launch lazy future ... done
[17:00:31.145] run() for ‘MulticoreFuture’ ... done
[17:00:31.146] plan(): Setting new future strategy stack:
[17:00:31.146] Created future:
[17:00:31.146] List of future strategies:
[17:00:31.146] 1. sequential:
[17:00:31.146]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.146]    - tweaked: FALSE
[17:00:31.146]    - call: NULL
[17:00:31.147] plan(): nbrOfWorkers() = 1
[17:00:31.154] plan(): Setting new future strategy stack:
[17:00:31.154] List of future strategies:
[17:00:31.154] 1. multicore:
[17:00:31.154]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.154]    - tweaked: FALSE
[17:00:31.154]    - call: plan(strategy)
[17:00:31.162] plan(): nbrOfWorkers() = 2
[17:00:31.146] MulticoreFuture:
[17:00:31.146] Label: ‘future_mapply-1’
[17:00:31.146] Expression:
[17:00:31.146] {
[17:00:31.146]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.146]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.146]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.146]         on.exit(options(oopts), add = TRUE)
[17:00:31.146]     }
[17:00:31.146]     {
[17:00:31.146]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.146]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.146]         do.call(mapply, args = args)
[17:00:31.146]     }
[17:00:31.146] }
[17:00:31.146] Lazy evaluation: FALSE
[17:00:31.146] Asynchronous evaluation: TRUE
[17:00:31.146] Local evaluation: TRUE
[17:00:31.146] Environment: R_GlobalEnv
[17:00:31.146] Capture standard output: TRUE
[17:00:31.146] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.146] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.146] Packages: <none>
[17:00:31.146] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:31.146] Resolved: TRUE
[17:00:31.146] Value: <not collected>
[17:00:31.146] Conditions captured: <none>
[17:00:31.146] Early signaling: FALSE
[17:00:31.146] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.146] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.163] Chunk #1 of 2 ... DONE
[17:00:31.163] Chunk #2 of 2 ...
[17:00:31.164]  - Finding globals in '...' for chunk #2 ...
[17:00:31.164] getGlobalsAndPackages() ...
[17:00:31.164] Searching for globals...
[17:00:31.165] 
[17:00:31.165] Searching for globals ... DONE
[17:00:31.166] - globals: [0] <none>
[17:00:31.166] getGlobalsAndPackages() ... DONE
[17:00:31.166]    + additional globals found: [n=0] 
[17:00:31.166]    + additional namespaces needed: [n=0] 
[17:00:31.166]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:31.167]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.167]  - seeds: <none>
[17:00:31.167]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.167] getGlobalsAndPackages() ...
[17:00:31.168] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.168] Resolving globals: FALSE
[17:00:31.169] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:31.170] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:31.170] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.171] 
[17:00:31.171] getGlobalsAndPackages() ... DONE
[17:00:31.171] run() for ‘Future’ ...
[17:00:31.172] - state: ‘created’
[17:00:31.172] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.177] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.178]   - Field: ‘label’
[17:00:31.178]   - Field: ‘local’
[17:00:31.178]   - Field: ‘owner’
[17:00:31.178]   - Field: ‘envir’
[17:00:31.179]   - Field: ‘workers’
[17:00:31.179]   - Field: ‘packages’
[17:00:31.179]   - Field: ‘gc’
[17:00:31.179]   - Field: ‘job’
[17:00:31.179]   - Field: ‘conditions’
[17:00:31.179]   - Field: ‘expr’
[17:00:31.180]   - Field: ‘uuid’
[17:00:31.180]   - Field: ‘seed’
[17:00:31.180]   - Field: ‘version’
[17:00:31.180]   - Field: ‘result’
[17:00:31.180]   - Field: ‘asynchronous’
[17:00:31.180]   - Field: ‘calls’
[17:00:31.180]   - Field: ‘globals’
[17:00:31.180]   - Field: ‘stdout’
[17:00:31.181]   - Field: ‘earlySignal’
[17:00:31.181]   - Field: ‘lazy’
[17:00:31.181]   - Field: ‘state’
[17:00:31.181] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.181] - Launch lazy future ...
[17:00:31.182] Packages needed by the future expression (n = 0): <none>
[17:00:31.182] Packages needed by future strategies (n = 0): <none>
[17:00:31.183] {
[17:00:31.183]     {
[17:00:31.183]         {
[17:00:31.183]             ...future.startTime <- base::Sys.time()
[17:00:31.183]             {
[17:00:31.183]                 {
[17:00:31.183]                   {
[17:00:31.183]                     {
[17:00:31.183]                       base::local({
[17:00:31.183]                         has_future <- base::requireNamespace("future", 
[17:00:31.183]                           quietly = TRUE)
[17:00:31.183]                         if (has_future) {
[17:00:31.183]                           ns <- base::getNamespace("future")
[17:00:31.183]                           version <- ns[[".package"]][["version"]]
[17:00:31.183]                           if (is.null(version)) 
[17:00:31.183]                             version <- utils::packageVersion("future")
[17:00:31.183]                         }
[17:00:31.183]                         else {
[17:00:31.183]                           version <- NULL
[17:00:31.183]                         }
[17:00:31.183]                         if (!has_future || version < "1.8.0") {
[17:00:31.183]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.183]                             "", base::R.version$version.string), 
[17:00:31.183]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:31.183]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:31.183]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.183]                               "release", "version")], collapse = " "), 
[17:00:31.183]                             hostname = base::Sys.info()[["nodename"]])
[17:00:31.183]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.183]                             info)
[17:00:31.183]                           info <- base::paste(info, collapse = "; ")
[17:00:31.183]                           if (!has_future) {
[17:00:31.183]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.183]                               info)
[17:00:31.183]                           }
[17:00:31.183]                           else {
[17:00:31.183]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.183]                               info, version)
[17:00:31.183]                           }
[17:00:31.183]                           base::stop(msg)
[17:00:31.183]                         }
[17:00:31.183]                       })
[17:00:31.183]                     }
[17:00:31.183]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.183]                     base::options(mc.cores = 1L)
[17:00:31.183]                   }
[17:00:31.183]                   ...future.strategy.old <- future::plan("list")
[17:00:31.183]                   options(future.plan = NULL)
[17:00:31.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.183]                 }
[17:00:31.183]                 ...future.workdir <- getwd()
[17:00:31.183]             }
[17:00:31.183]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.183]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.183]         }
[17:00:31.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.183]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.183]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.183]             base::names(...future.oldOptions))
[17:00:31.183]     }
[17:00:31.183]     if (FALSE) {
[17:00:31.183]     }
[17:00:31.183]     else {
[17:00:31.183]         if (TRUE) {
[17:00:31.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.183]                 open = "w")
[17:00:31.183]         }
[17:00:31.183]         else {
[17:00:31.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.183]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.183]         }
[17:00:31.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.183]             base::sink(type = "output", split = FALSE)
[17:00:31.183]             base::close(...future.stdout)
[17:00:31.183]         }, add = TRUE)
[17:00:31.183]     }
[17:00:31.183]     ...future.frame <- base::sys.nframe()
[17:00:31.183]     ...future.conditions <- base::list()
[17:00:31.183]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.183]     if (FALSE) {
[17:00:31.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.183]     }
[17:00:31.183]     ...future.result <- base::tryCatch({
[17:00:31.183]         base::withCallingHandlers({
[17:00:31.183]             ...future.value <- base::withVisible(base::local({
[17:00:31.183]                 withCallingHandlers({
[17:00:31.183]                   {
[17:00:31.183]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.183]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.183]                       ...future.globals.maxSize)) {
[17:00:31.183]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.183]                       on.exit(options(oopts), add = TRUE)
[17:00:31.183]                     }
[17:00:31.183]                     {
[17:00:31.183]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.183]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.183]                         USE.NAMES = FALSE)
[17:00:31.183]                       do.call(mapply, args = args)
[17:00:31.183]                     }
[17:00:31.183]                   }
[17:00:31.183]                 }, immediateCondition = function(cond) {
[17:00:31.183]                   save_rds <- function (object, pathname, ...) 
[17:00:31.183]                   {
[17:00:31.183]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.183]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.183]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.183]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.183]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.183]                         fi_tmp[["mtime"]])
[17:00:31.183]                     }
[17:00:31.183]                     tryCatch({
[17:00:31.183]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.183]                     }, error = function(ex) {
[17:00:31.183]                       msg <- conditionMessage(ex)
[17:00:31.183]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.183]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.183]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.183]                         fi_tmp[["mtime"]], msg)
[17:00:31.183]                       ex$message <- msg
[17:00:31.183]                       stop(ex)
[17:00:31.183]                     })
[17:00:31.183]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.183]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.183]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.183]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.183]                       fi <- file.info(pathname)
[17:00:31.183]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.183]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.183]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.183]                         fi[["size"]], fi[["mtime"]])
[17:00:31.183]                       stop(msg)
[17:00:31.183]                     }
[17:00:31.183]                     invisible(pathname)
[17:00:31.183]                   }
[17:00:31.183]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.183]                     rootPath = tempdir()) 
[17:00:31.183]                   {
[17:00:31.183]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.183]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.183]                       tmpdir = path, fileext = ".rds")
[17:00:31.183]                     save_rds(obj, file)
[17:00:31.183]                   }
[17:00:31.183]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.183]                   {
[17:00:31.183]                     inherits <- base::inherits
[17:00:31.183]                     invokeRestart <- base::invokeRestart
[17:00:31.183]                     is.null <- base::is.null
[17:00:31.183]                     muffled <- FALSE
[17:00:31.183]                     if (inherits(cond, "message")) {
[17:00:31.183]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.183]                       if (muffled) 
[17:00:31.183]                         invokeRestart("muffleMessage")
[17:00:31.183]                     }
[17:00:31.183]                     else if (inherits(cond, "warning")) {
[17:00:31.183]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.183]                       if (muffled) 
[17:00:31.183]                         invokeRestart("muffleWarning")
[17:00:31.183]                     }
[17:00:31.183]                     else if (inherits(cond, "condition")) {
[17:00:31.183]                       if (!is.null(pattern)) {
[17:00:31.183]                         computeRestarts <- base::computeRestarts
[17:00:31.183]                         grepl <- base::grepl
[17:00:31.183]                         restarts <- computeRestarts(cond)
[17:00:31.183]                         for (restart in restarts) {
[17:00:31.183]                           name <- restart$name
[17:00:31.183]                           if (is.null(name)) 
[17:00:31.183]                             next
[17:00:31.183]                           if (!grepl(pattern, name)) 
[17:00:31.183]                             next
[17:00:31.183]                           invokeRestart(restart)
[17:00:31.183]                           muffled <- TRUE
[17:00:31.183]                           break
[17:00:31.183]                         }
[17:00:31.183]                       }
[17:00:31.183]                     }
[17:00:31.183]                     invisible(muffled)
[17:00:31.183]                   }
[17:00:31.183]                   muffleCondition(cond)
[17:00:31.183]                 })
[17:00:31.183]             }))
[17:00:31.183]             future::FutureResult(value = ...future.value$value, 
[17:00:31.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.183]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.183]                     ...future.globalenv.names))
[17:00:31.183]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.183]         }, condition = base::local({
[17:00:31.183]             c <- base::c
[17:00:31.183]             inherits <- base::inherits
[17:00:31.183]             invokeRestart <- base::invokeRestart
[17:00:31.183]             length <- base::length
[17:00:31.183]             list <- base::list
[17:00:31.183]             seq.int <- base::seq.int
[17:00:31.183]             signalCondition <- base::signalCondition
[17:00:31.183]             sys.calls <- base::sys.calls
[17:00:31.183]             `[[` <- base::`[[`
[17:00:31.183]             `+` <- base::`+`
[17:00:31.183]             `<<-` <- base::`<<-`
[17:00:31.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.183]                   3L)]
[17:00:31.183]             }
[17:00:31.183]             function(cond) {
[17:00:31.183]                 is_error <- inherits(cond, "error")
[17:00:31.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.183]                   NULL)
[17:00:31.183]                 if (is_error) {
[17:00:31.183]                   sessionInformation <- function() {
[17:00:31.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.183]                       search = base::search(), system = base::Sys.info())
[17:00:31.183]                   }
[17:00:31.183]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.183]                     cond$call), session = sessionInformation(), 
[17:00:31.183]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.183]                   signalCondition(cond)
[17:00:31.183]                 }
[17:00:31.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.183]                 "immediateCondition"))) {
[17:00:31.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.183]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.183]                   if (TRUE && !signal) {
[17:00:31.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.183]                     {
[17:00:31.183]                       inherits <- base::inherits
[17:00:31.183]                       invokeRestart <- base::invokeRestart
[17:00:31.183]                       is.null <- base::is.null
[17:00:31.183]                       muffled <- FALSE
[17:00:31.183]                       if (inherits(cond, "message")) {
[17:00:31.183]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.183]                         if (muffled) 
[17:00:31.183]                           invokeRestart("muffleMessage")
[17:00:31.183]                       }
[17:00:31.183]                       else if (inherits(cond, "warning")) {
[17:00:31.183]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.183]                         if (muffled) 
[17:00:31.183]                           invokeRestart("muffleWarning")
[17:00:31.183]                       }
[17:00:31.183]                       else if (inherits(cond, "condition")) {
[17:00:31.183]                         if (!is.null(pattern)) {
[17:00:31.183]                           computeRestarts <- base::computeRestarts
[17:00:31.183]                           grepl <- base::grepl
[17:00:31.183]                           restarts <- computeRestarts(cond)
[17:00:31.183]                           for (restart in restarts) {
[17:00:31.183]                             name <- restart$name
[17:00:31.183]                             if (is.null(name)) 
[17:00:31.183]                               next
[17:00:31.183]                             if (!grepl(pattern, name)) 
[17:00:31.183]                               next
[17:00:31.183]                             invokeRestart(restart)
[17:00:31.183]                             muffled <- TRUE
[17:00:31.183]                             break
[17:00:31.183]                           }
[17:00:31.183]                         }
[17:00:31.183]                       }
[17:00:31.183]                       invisible(muffled)
[17:00:31.183]                     }
[17:00:31.183]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.183]                   }
[17:00:31.183]                 }
[17:00:31.183]                 else {
[17:00:31.183]                   if (TRUE) {
[17:00:31.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.183]                     {
[17:00:31.183]                       inherits <- base::inherits
[17:00:31.183]                       invokeRestart <- base::invokeRestart
[17:00:31.183]                       is.null <- base::is.null
[17:00:31.183]                       muffled <- FALSE
[17:00:31.183]                       if (inherits(cond, "message")) {
[17:00:31.183]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.183]                         if (muffled) 
[17:00:31.183]                           invokeRestart("muffleMessage")
[17:00:31.183]                       }
[17:00:31.183]                       else if (inherits(cond, "warning")) {
[17:00:31.183]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.183]                         if (muffled) 
[17:00:31.183]                           invokeRestart("muffleWarning")
[17:00:31.183]                       }
[17:00:31.183]                       else if (inherits(cond, "condition")) {
[17:00:31.183]                         if (!is.null(pattern)) {
[17:00:31.183]                           computeRestarts <- base::computeRestarts
[17:00:31.183]                           grepl <- base::grepl
[17:00:31.183]                           restarts <- computeRestarts(cond)
[17:00:31.183]                           for (restart in restarts) {
[17:00:31.183]                             name <- restart$name
[17:00:31.183]                             if (is.null(name)) 
[17:00:31.183]                               next
[17:00:31.183]                             if (!grepl(pattern, name)) 
[17:00:31.183]                               next
[17:00:31.183]                             invokeRestart(restart)
[17:00:31.183]                             muffled <- TRUE
[17:00:31.183]                             break
[17:00:31.183]                           }
[17:00:31.183]                         }
[17:00:31.183]                       }
[17:00:31.183]                       invisible(muffled)
[17:00:31.183]                     }
[17:00:31.183]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.183]                   }
[17:00:31.183]                 }
[17:00:31.183]             }
[17:00:31.183]         }))
[17:00:31.183]     }, error = function(ex) {
[17:00:31.183]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.183]                 ...future.rng), started = ...future.startTime, 
[17:00:31.183]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.183]             version = "1.8"), class = "FutureResult")
[17:00:31.183]     }, finally = {
[17:00:31.183]         if (!identical(...future.workdir, getwd())) 
[17:00:31.183]             setwd(...future.workdir)
[17:00:31.183]         {
[17:00:31.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.183]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.183]             }
[17:00:31.183]             base::options(...future.oldOptions)
[17:00:31.183]             if (.Platform$OS.type == "windows") {
[17:00:31.183]                 old_names <- names(...future.oldEnvVars)
[17:00:31.183]                 envs <- base::Sys.getenv()
[17:00:31.183]                 names <- names(envs)
[17:00:31.183]                 common <- intersect(names, old_names)
[17:00:31.183]                 added <- setdiff(names, old_names)
[17:00:31.183]                 removed <- setdiff(old_names, names)
[17:00:31.183]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.183]                   envs[common]]
[17:00:31.183]                 NAMES <- toupper(changed)
[17:00:31.183]                 args <- list()
[17:00:31.183]                 for (kk in seq_along(NAMES)) {
[17:00:31.183]                   name <- changed[[kk]]
[17:00:31.183]                   NAME <- NAMES[[kk]]
[17:00:31.183]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.183]                     next
[17:00:31.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.183]                 }
[17:00:31.183]                 NAMES <- toupper(added)
[17:00:31.183]                 for (kk in seq_along(NAMES)) {
[17:00:31.183]                   name <- added[[kk]]
[17:00:31.183]                   NAME <- NAMES[[kk]]
[17:00:31.183]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.183]                     next
[17:00:31.183]                   args[[name]] <- ""
[17:00:31.183]                 }
[17:00:31.183]                 NAMES <- toupper(removed)
[17:00:31.183]                 for (kk in seq_along(NAMES)) {
[17:00:31.183]                   name <- removed[[kk]]
[17:00:31.183]                   NAME <- NAMES[[kk]]
[17:00:31.183]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.183]                     next
[17:00:31.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.183]                 }
[17:00:31.183]                 if (length(args) > 0) 
[17:00:31.183]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.183]             }
[17:00:31.183]             else {
[17:00:31.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.183]             }
[17:00:31.183]             {
[17:00:31.183]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.183]                   0L) {
[17:00:31.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.183]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.183]                   base::options(opts)
[17:00:31.183]                 }
[17:00:31.183]                 {
[17:00:31.183]                   {
[17:00:31.183]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.183]                     NULL
[17:00:31.183]                   }
[17:00:31.183]                   options(future.plan = NULL)
[17:00:31.183]                   if (is.na(NA_character_)) 
[17:00:31.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.183]                     .init = FALSE)
[17:00:31.183]                 }
[17:00:31.183]             }
[17:00:31.183]         }
[17:00:31.183]     })
[17:00:31.183]     if (TRUE) {
[17:00:31.183]         base::sink(type = "output", split = FALSE)
[17:00:31.183]         if (TRUE) {
[17:00:31.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.183]         }
[17:00:31.183]         else {
[17:00:31.183]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.183]         }
[17:00:31.183]         base::close(...future.stdout)
[17:00:31.183]         ...future.stdout <- NULL
[17:00:31.183]     }
[17:00:31.183]     ...future.result$conditions <- ...future.conditions
[17:00:31.183]     ...future.result$finished <- base::Sys.time()
[17:00:31.183]     ...future.result
[17:00:31.183] }
[17:00:31.185] assign_globals() ...
[17:00:31.186] List of 5
[17:00:31.186]  $ ...future.FUN            :function (x, ...)  
[17:00:31.186]  $ MoreArgs                 : NULL
[17:00:31.186]  $ ...future.elements_ii    :List of 2
[17:00:31.186]   ..$ :List of 2
[17:00:31.186]   .. ..$ : int 3
[17:00:31.186]   .. ..$ : int 4
[17:00:31.186]   ..$ :List of 2
[17:00:31.186]   .. ..$ : int 2
[17:00:31.186]   .. ..$ : int 1
[17:00:31.186]  $ ...future.seeds_ii       : NULL
[17:00:31.186]  $ ...future.globals.maxSize: NULL
[17:00:31.186]  - attr(*, "where")=List of 5
[17:00:31.186]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.186]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.186]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.186]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.186]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.186]  - attr(*, "resolved")= logi FALSE
[17:00:31.186]  - attr(*, "total_size")= num 280
[17:00:31.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.186]  - attr(*, "already-done")= logi TRUE
[17:00:31.193] - copied ‘...future.FUN’ to environment
[17:00:31.193] - copied ‘MoreArgs’ to environment
[17:00:31.193] - copied ‘...future.elements_ii’ to environment
[17:00:31.193] - copied ‘...future.seeds_ii’ to environment
[17:00:31.193] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.193] assign_globals() ... done
[17:00:31.193] requestCore(): workers = 2
[17:00:31.196] MulticoreFuture started
[17:00:31.196] - Launch lazy future ... done
[17:00:31.196] run() for ‘MulticoreFuture’ ... done
[17:00:31.197] Created future:
[17:00:31.197] plan(): Setting new future strategy stack:
[17:00:31.197] List of future strategies:
[17:00:31.197] 1. sequential:
[17:00:31.197]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.197]    - tweaked: FALSE
[17:00:31.197]    - call: NULL
[17:00:31.198] plan(): nbrOfWorkers() = 1
[17:00:31.200] plan(): Setting new future strategy stack:
[17:00:31.200] List of future strategies:
[17:00:31.200] 1. multicore:
[17:00:31.200]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.200]    - tweaked: FALSE
[17:00:31.200]    - call: plan(strategy)
[17:00:31.206] plan(): nbrOfWorkers() = 2
[17:00:31.197] MulticoreFuture:
[17:00:31.197] Label: ‘future_mapply-2’
[17:00:31.197] Expression:
[17:00:31.197] {
[17:00:31.197]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.197]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.197]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.197]         on.exit(options(oopts), add = TRUE)
[17:00:31.197]     }
[17:00:31.197]     {
[17:00:31.197]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.197]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.197]         do.call(mapply, args = args)
[17:00:31.197]     }
[17:00:31.197] }
[17:00:31.197] Lazy evaluation: FALSE
[17:00:31.197] Asynchronous evaluation: TRUE
[17:00:31.197] Local evaluation: TRUE
[17:00:31.197] Environment: R_GlobalEnv
[17:00:31.197] Capture standard output: TRUE
[17:00:31.197] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.197] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.197] Packages: <none>
[17:00:31.197] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:31.197] Resolved: FALSE
[17:00:31.197] Value: <not collected>
[17:00:31.197] Conditions captured: <none>
[17:00:31.197] Early signaling: FALSE
[17:00:31.197] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.197] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.209] Chunk #2 of 2 ... DONE
[17:00:31.210] Launching 2 futures (chunks) ... DONE
[17:00:31.210] Resolving 2 futures (chunks) ...
[17:00:31.210] resolve() on list ...
[17:00:31.210]  recursive: 0
[17:00:31.210]  length: 2
[17:00:31.210] 
[17:00:31.211] Future #1
[17:00:31.211] result() for MulticoreFuture ...
[17:00:31.212] result() for MulticoreFuture ...
[17:00:31.212] result() for MulticoreFuture ... done
[17:00:31.212] result() for MulticoreFuture ... done
[17:00:31.212] result() for MulticoreFuture ...
[17:00:31.216] result() for MulticoreFuture ... done
[17:00:31.216] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:31.216] - nx: 2
[17:00:31.217] - relay: TRUE
[17:00:31.217] - stdout: TRUE
[17:00:31.217] - signal: TRUE
[17:00:31.218] - resignal: FALSE
[17:00:31.218] - force: TRUE
[17:00:31.218] - relayed: [n=2] FALSE, FALSE
[17:00:31.219] - queued futures: [n=2] FALSE, FALSE
[17:00:31.219]  - until=1
[17:00:31.219]  - relaying element #1
[17:00:31.219] result() for MulticoreFuture ...
[17:00:31.220] result() for MulticoreFuture ... done
[17:00:31.220] result() for MulticoreFuture ...
[17:00:31.220] result() for MulticoreFuture ... done
[17:00:31.221] result() for MulticoreFuture ...
[17:00:31.221] result() for MulticoreFuture ... done
[17:00:31.221] result() for MulticoreFuture ...
[17:00:31.221] result() for MulticoreFuture ... done
[17:00:31.222] - relayed: [n=2] TRUE, FALSE
[17:00:31.222] - queued futures: [n=2] TRUE, FALSE
[17:00:31.222] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:31.222]  length: 1 (resolved future 1)
[17:00:31.223] Future #2
[17:00:31.223] result() for MulticoreFuture ...
[17:00:31.224] result() for MulticoreFuture ...
[17:00:31.224] result() for MulticoreFuture ... done
[17:00:31.224] result() for MulticoreFuture ... done
[17:00:31.225] result() for MulticoreFuture ...
[17:00:31.225] result() for MulticoreFuture ... done
[17:00:31.225] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:31.225] - nx: 2
[17:00:31.225] - relay: TRUE
[17:00:31.225] - stdout: TRUE
[17:00:31.226] - signal: TRUE
[17:00:31.226] - resignal: FALSE
[17:00:31.226] - force: TRUE
[17:00:31.226] - relayed: [n=2] TRUE, FALSE
[17:00:31.226] - queued futures: [n=2] TRUE, FALSE
[17:00:31.226]  - until=2
[17:00:31.226]  - relaying element #2
[17:00:31.227] result() for MulticoreFuture ...
[17:00:31.227] result() for MulticoreFuture ... done
[17:00:31.227] result() for MulticoreFuture ...
[17:00:31.227] result() for MulticoreFuture ... done
[17:00:31.227] result() for MulticoreFuture ...
[17:00:31.227] result() for MulticoreFuture ... done
[17:00:31.228] result() for MulticoreFuture ...
[17:00:31.228] result() for MulticoreFuture ... done
[17:00:31.228] - relayed: [n=2] TRUE, TRUE
[17:00:31.228] - queued futures: [n=2] TRUE, TRUE
[17:00:31.228] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:31.228]  length: 0 (resolved future 2)
[17:00:31.228] Relaying remaining futures
[17:00:31.229] signalConditionsASAP(NULL, pos=0) ...
[17:00:31.229] - nx: 2
[17:00:31.229] - relay: TRUE
[17:00:31.229] - stdout: TRUE
[17:00:31.229] - signal: TRUE
[17:00:31.229] - resignal: FALSE
[17:00:31.229] - force: TRUE
[17:00:31.229] - relayed: [n=2] TRUE, TRUE
[17:00:31.229] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:31.230] - relayed: [n=2] TRUE, TRUE
[17:00:31.230] - queued futures: [n=2] TRUE, TRUE
[17:00:31.230] signalConditionsASAP(NULL, pos=0) ... done
[17:00:31.230] resolve() on list ... DONE
[17:00:31.230] result() for MulticoreFuture ...
[17:00:31.230] result() for MulticoreFuture ... done
[17:00:31.230] result() for MulticoreFuture ...
[17:00:31.230] result() for MulticoreFuture ... done
[17:00:31.231] result() for MulticoreFuture ...
[17:00:31.231] result() for MulticoreFuture ... done
[17:00:31.231] result() for MulticoreFuture ...
[17:00:31.231] result() for MulticoreFuture ... done
[17:00:31.231]  - Number of value chunks collected: 2
[17:00:31.231] Resolving 2 futures (chunks) ... DONE
[17:00:31.231] Reducing values from 2 chunks ...
[17:00:31.231]  - Number of values collected after concatenation: 4
[17:00:31.232]  - Number of values expected: 4
[17:00:31.232] Reducing values from 2 chunks ... DONE
[17:00:31.232] future_mapply() ... DONE
- Parallel RNG ...
[17:00:31.232] future_mapply() ...
[17:00:31.232] Generating random seeds ...
[17:00:31.232] Generating random seed streams for 4 elements ...
[17:00:31.232] Generating random seed streams for 4 elements ... DONE
[17:00:31.233] Generating random seeds ... DONE
[17:00:31.233] Will set RNG state on exit: 10407, 269197478, 1210644688, -893191329, 752569467, -224933867, -743250175
[17:00:31.237] Number of chunks: 2
[17:00:31.237] getGlobalsAndPackagesXApply() ...
[17:00:31.237]  - future.globals: TRUE
[17:00:31.237] getGlobalsAndPackages() ...
[17:00:31.237] Searching for globals...
[17:00:31.239] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:00:31.239] Searching for globals ... DONE
[17:00:31.239] Resolving globals: FALSE
[17:00:31.240] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:00:31.240] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:00:31.240] - globals: [1] ‘FUN’
[17:00:31.240] - packages: [1] ‘stats’
[17:00:31.240] getGlobalsAndPackages() ... DONE
[17:00:31.241]  - globals found/used: [n=1] ‘FUN’
[17:00:31.241]  - needed namespaces: [n=1] ‘stats’
[17:00:31.241] Finding globals ... DONE
[17:00:31.241] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:31.241] List of 2
[17:00:31.241]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:00:31.241]  $ MoreArgs     :List of 1
[17:00:31.241]   ..$ min: num 1
[17:00:31.241]  - attr(*, "where")=List of 2
[17:00:31.241]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:31.241]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:31.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.241]  - attr(*, "resolved")= logi FALSE
[17:00:31.241]  - attr(*, "total_size")= num NA
[17:00:31.244] Packages to be attached in all futures: [n=1] ‘stats’
[17:00:31.244] getGlobalsAndPackagesXApply() ... DONE
[17:00:31.245] Number of futures (= number of chunks): 2
[17:00:31.245] Launching 2 futures (chunks) ...
[17:00:31.245] Chunk #1 of 2 ...
[17:00:31.245]  - Finding globals in '...' for chunk #1 ...
[17:00:31.245] getGlobalsAndPackages() ...
[17:00:31.245] Searching for globals...
[17:00:31.245] 
[17:00:31.246] Searching for globals ... DONE
[17:00:31.246] - globals: [0] <none>
[17:00:31.246] getGlobalsAndPackages() ... DONE
[17:00:31.246]    + additional globals found: [n=0] 
[17:00:31.246]    + additional namespaces needed: [n=0] 
[17:00:31.249]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:31.249]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.249]  - seeds: [2] <seeds>
[17:00:31.249]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.249] getGlobalsAndPackages() ...
[17:00:31.249] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.249] Resolving globals: FALSE
[17:00:31.250] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:00:31.251] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:00:31.251] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.251] - packages: [1] ‘stats’
[17:00:31.251] getGlobalsAndPackages() ... DONE
[17:00:31.251] run() for ‘Future’ ...
[17:00:31.252] - state: ‘created’
[17:00:31.252] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.256] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.256] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.256]   - Field: ‘label’
[17:00:31.256]   - Field: ‘local’
[17:00:31.256]   - Field: ‘owner’
[17:00:31.257]   - Field: ‘envir’
[17:00:31.257]   - Field: ‘workers’
[17:00:31.257]   - Field: ‘packages’
[17:00:31.257]   - Field: ‘gc’
[17:00:31.257]   - Field: ‘job’
[17:00:31.257]   - Field: ‘conditions’
[17:00:31.257]   - Field: ‘expr’
[17:00:31.257]   - Field: ‘uuid’
[17:00:31.257]   - Field: ‘seed’
[17:00:31.258]   - Field: ‘version’
[17:00:31.258]   - Field: ‘result’
[17:00:31.258]   - Field: ‘asynchronous’
[17:00:31.258]   - Field: ‘calls’
[17:00:31.258]   - Field: ‘globals’
[17:00:31.258]   - Field: ‘stdout’
[17:00:31.258]   - Field: ‘earlySignal’
[17:00:31.258]   - Field: ‘lazy’
[17:00:31.259]   - Field: ‘state’
[17:00:31.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.259] - Launch lazy future ...
[17:00:31.259] Packages needed by the future expression (n = 1): ‘stats’
[17:00:31.259] Packages needed by future strategies (n = 0): <none>
[17:00:31.260] {
[17:00:31.260]     {
[17:00:31.260]         {
[17:00:31.260]             ...future.startTime <- base::Sys.time()
[17:00:31.260]             {
[17:00:31.260]                 {
[17:00:31.260]                   {
[17:00:31.260]                     {
[17:00:31.260]                       {
[17:00:31.260]                         base::local({
[17:00:31.260]                           has_future <- base::requireNamespace("future", 
[17:00:31.260]                             quietly = TRUE)
[17:00:31.260]                           if (has_future) {
[17:00:31.260]                             ns <- base::getNamespace("future")
[17:00:31.260]                             version <- ns[[".package"]][["version"]]
[17:00:31.260]                             if (is.null(version)) 
[17:00:31.260]                               version <- utils::packageVersion("future")
[17:00:31.260]                           }
[17:00:31.260]                           else {
[17:00:31.260]                             version <- NULL
[17:00:31.260]                           }
[17:00:31.260]                           if (!has_future || version < "1.8.0") {
[17:00:31.260]                             info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.260]                               "", base::R.version$version.string), 
[17:00:31.260]                               platform = base::sprintf("%s (%s-bit)", 
[17:00:31.260]                                 base::R.version$platform, 8 * 
[17:00:31.260]                                   base::.Machine$sizeof.pointer), 
[17:00:31.260]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.260]                                 "release", "version")], collapse = " "), 
[17:00:31.260]                               hostname = base::Sys.info()[["nodename"]])
[17:00:31.260]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.260]                               info)
[17:00:31.260]                             info <- base::paste(info, collapse = "; ")
[17:00:31.260]                             if (!has_future) {
[17:00:31.260]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.260]                                 info)
[17:00:31.260]                             }
[17:00:31.260]                             else {
[17:00:31.260]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.260]                                 info, version)
[17:00:31.260]                             }
[17:00:31.260]                             base::stop(msg)
[17:00:31.260]                           }
[17:00:31.260]                         })
[17:00:31.260]                       }
[17:00:31.260]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.260]                       base::options(mc.cores = 1L)
[17:00:31.260]                     }
[17:00:31.260]                     base::local({
[17:00:31.260]                       for (pkg in "stats") {
[17:00:31.260]                         base::loadNamespace(pkg)
[17:00:31.260]                         base::library(pkg, character.only = TRUE)
[17:00:31.260]                       }
[17:00:31.260]                     })
[17:00:31.260]                   }
[17:00:31.260]                   ...future.strategy.old <- future::plan("list")
[17:00:31.260]                   options(future.plan = NULL)
[17:00:31.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.260]                 }
[17:00:31.260]                 ...future.workdir <- getwd()
[17:00:31.260]             }
[17:00:31.260]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.260]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.260]         }
[17:00:31.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.260]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.260]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.260]             base::names(...future.oldOptions))
[17:00:31.260]     }
[17:00:31.260]     if (FALSE) {
[17:00:31.260]     }
[17:00:31.260]     else {
[17:00:31.260]         if (TRUE) {
[17:00:31.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.260]                 open = "w")
[17:00:31.260]         }
[17:00:31.260]         else {
[17:00:31.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.260]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.260]         }
[17:00:31.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.260]             base::sink(type = "output", split = FALSE)
[17:00:31.260]             base::close(...future.stdout)
[17:00:31.260]         }, add = TRUE)
[17:00:31.260]     }
[17:00:31.260]     ...future.frame <- base::sys.nframe()
[17:00:31.260]     ...future.conditions <- base::list()
[17:00:31.260]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.260]     if (FALSE) {
[17:00:31.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.260]     }
[17:00:31.260]     ...future.result <- base::tryCatch({
[17:00:31.260]         base::withCallingHandlers({
[17:00:31.260]             ...future.value <- base::withVisible(base::local({
[17:00:31.260]                 withCallingHandlers({
[17:00:31.260]                   {
[17:00:31.260]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.260]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.260]                       ...future.globals.maxSize)) {
[17:00:31.260]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.260]                       on.exit(options(oopts), add = TRUE)
[17:00:31.260]                     }
[17:00:31.260]                     {
[17:00:31.260]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:31.260]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:31.260]                           envir = globalenv(), inherits = FALSE)
[17:00:31.260]                         ...future.FUN(...)
[17:00:31.260]                       }
[17:00:31.260]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:31.260]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:31.260]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.260]                         USE.NAMES = FALSE)
[17:00:31.260]                       do.call(mapply, args = args)
[17:00:31.260]                     }
[17:00:31.260]                   }
[17:00:31.260]                 }, immediateCondition = function(cond) {
[17:00:31.260]                   save_rds <- function (object, pathname, ...) 
[17:00:31.260]                   {
[17:00:31.260]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.260]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.260]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.260]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.260]                         fi_tmp[["mtime"]])
[17:00:31.260]                     }
[17:00:31.260]                     tryCatch({
[17:00:31.260]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.260]                     }, error = function(ex) {
[17:00:31.260]                       msg <- conditionMessage(ex)
[17:00:31.260]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.260]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.260]                         fi_tmp[["mtime"]], msg)
[17:00:31.260]                       ex$message <- msg
[17:00:31.260]                       stop(ex)
[17:00:31.260]                     })
[17:00:31.260]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.260]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.260]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.260]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.260]                       fi <- file.info(pathname)
[17:00:31.260]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.260]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.260]                         fi[["size"]], fi[["mtime"]])
[17:00:31.260]                       stop(msg)
[17:00:31.260]                     }
[17:00:31.260]                     invisible(pathname)
[17:00:31.260]                   }
[17:00:31.260]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.260]                     rootPath = tempdir()) 
[17:00:31.260]                   {
[17:00:31.260]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.260]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.260]                       tmpdir = path, fileext = ".rds")
[17:00:31.260]                     save_rds(obj, file)
[17:00:31.260]                   }
[17:00:31.260]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.260]                   {
[17:00:31.260]                     inherits <- base::inherits
[17:00:31.260]                     invokeRestart <- base::invokeRestart
[17:00:31.260]                     is.null <- base::is.null
[17:00:31.260]                     muffled <- FALSE
[17:00:31.260]                     if (inherits(cond, "message")) {
[17:00:31.260]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.260]                       if (muffled) 
[17:00:31.260]                         invokeRestart("muffleMessage")
[17:00:31.260]                     }
[17:00:31.260]                     else if (inherits(cond, "warning")) {
[17:00:31.260]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.260]                       if (muffled) 
[17:00:31.260]                         invokeRestart("muffleWarning")
[17:00:31.260]                     }
[17:00:31.260]                     else if (inherits(cond, "condition")) {
[17:00:31.260]                       if (!is.null(pattern)) {
[17:00:31.260]                         computeRestarts <- base::computeRestarts
[17:00:31.260]                         grepl <- base::grepl
[17:00:31.260]                         restarts <- computeRestarts(cond)
[17:00:31.260]                         for (restart in restarts) {
[17:00:31.260]                           name <- restart$name
[17:00:31.260]                           if (is.null(name)) 
[17:00:31.260]                             next
[17:00:31.260]                           if (!grepl(pattern, name)) 
[17:00:31.260]                             next
[17:00:31.260]                           invokeRestart(restart)
[17:00:31.260]                           muffled <- TRUE
[17:00:31.260]                           break
[17:00:31.260]                         }
[17:00:31.260]                       }
[17:00:31.260]                     }
[17:00:31.260]                     invisible(muffled)
[17:00:31.260]                   }
[17:00:31.260]                   muffleCondition(cond)
[17:00:31.260]                 })
[17:00:31.260]             }))
[17:00:31.260]             future::FutureResult(value = ...future.value$value, 
[17:00:31.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.260]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.260]                     ...future.globalenv.names))
[17:00:31.260]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.260]         }, condition = base::local({
[17:00:31.260]             c <- base::c
[17:00:31.260]             inherits <- base::inherits
[17:00:31.260]             invokeRestart <- base::invokeRestart
[17:00:31.260]             length <- base::length
[17:00:31.260]             list <- base::list
[17:00:31.260]             seq.int <- base::seq.int
[17:00:31.260]             signalCondition <- base::signalCondition
[17:00:31.260]             sys.calls <- base::sys.calls
[17:00:31.260]             `[[` <- base::`[[`
[17:00:31.260]             `+` <- base::`+`
[17:00:31.260]             `<<-` <- base::`<<-`
[17:00:31.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.260]                   3L)]
[17:00:31.260]             }
[17:00:31.260]             function(cond) {
[17:00:31.260]                 is_error <- inherits(cond, "error")
[17:00:31.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.260]                   NULL)
[17:00:31.260]                 if (is_error) {
[17:00:31.260]                   sessionInformation <- function() {
[17:00:31.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.260]                       search = base::search(), system = base::Sys.info())
[17:00:31.260]                   }
[17:00:31.260]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.260]                     cond$call), session = sessionInformation(), 
[17:00:31.260]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.260]                   signalCondition(cond)
[17:00:31.260]                 }
[17:00:31.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.260]                 "immediateCondition"))) {
[17:00:31.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.260]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.260]                   if (TRUE && !signal) {
[17:00:31.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.260]                     {
[17:00:31.260]                       inherits <- base::inherits
[17:00:31.260]                       invokeRestart <- base::invokeRestart
[17:00:31.260]                       is.null <- base::is.null
[17:00:31.260]                       muffled <- FALSE
[17:00:31.260]                       if (inherits(cond, "message")) {
[17:00:31.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.260]                         if (muffled) 
[17:00:31.260]                           invokeRestart("muffleMessage")
[17:00:31.260]                       }
[17:00:31.260]                       else if (inherits(cond, "warning")) {
[17:00:31.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.260]                         if (muffled) 
[17:00:31.260]                           invokeRestart("muffleWarning")
[17:00:31.260]                       }
[17:00:31.260]                       else if (inherits(cond, "condition")) {
[17:00:31.260]                         if (!is.null(pattern)) {
[17:00:31.260]                           computeRestarts <- base::computeRestarts
[17:00:31.260]                           grepl <- base::grepl
[17:00:31.260]                           restarts <- computeRestarts(cond)
[17:00:31.260]                           for (restart in restarts) {
[17:00:31.260]                             name <- restart$name
[17:00:31.260]                             if (is.null(name)) 
[17:00:31.260]                               next
[17:00:31.260]                             if (!grepl(pattern, name)) 
[17:00:31.260]                               next
[17:00:31.260]                             invokeRestart(restart)
[17:00:31.260]                             muffled <- TRUE
[17:00:31.260]                             break
[17:00:31.260]                           }
[17:00:31.260]                         }
[17:00:31.260]                       }
[17:00:31.260]                       invisible(muffled)
[17:00:31.260]                     }
[17:00:31.260]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.260]                   }
[17:00:31.260]                 }
[17:00:31.260]                 else {
[17:00:31.260]                   if (TRUE) {
[17:00:31.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.260]                     {
[17:00:31.260]                       inherits <- base::inherits
[17:00:31.260]                       invokeRestart <- base::invokeRestart
[17:00:31.260]                       is.null <- base::is.null
[17:00:31.260]                       muffled <- FALSE
[17:00:31.260]                       if (inherits(cond, "message")) {
[17:00:31.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.260]                         if (muffled) 
[17:00:31.260]                           invokeRestart("muffleMessage")
[17:00:31.260]                       }
[17:00:31.260]                       else if (inherits(cond, "warning")) {
[17:00:31.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.260]                         if (muffled) 
[17:00:31.260]                           invokeRestart("muffleWarning")
[17:00:31.260]                       }
[17:00:31.260]                       else if (inherits(cond, "condition")) {
[17:00:31.260]                         if (!is.null(pattern)) {
[17:00:31.260]                           computeRestarts <- base::computeRestarts
[17:00:31.260]                           grepl <- base::grepl
[17:00:31.260]                           restarts <- computeRestarts(cond)
[17:00:31.260]                           for (restart in restarts) {
[17:00:31.260]                             name <- restart$name
[17:00:31.260]                             if (is.null(name)) 
[17:00:31.260]                               next
[17:00:31.260]                             if (!grepl(pattern, name)) 
[17:00:31.260]                               next
[17:00:31.260]                             invokeRestart(restart)
[17:00:31.260]                             muffled <- TRUE
[17:00:31.260]                             break
[17:00:31.260]                           }
[17:00:31.260]                         }
[17:00:31.260]                       }
[17:00:31.260]                       invisible(muffled)
[17:00:31.260]                     }
[17:00:31.260]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.260]                   }
[17:00:31.260]                 }
[17:00:31.260]             }
[17:00:31.260]         }))
[17:00:31.260]     }, error = function(ex) {
[17:00:31.260]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.260]                 ...future.rng), started = ...future.startTime, 
[17:00:31.260]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.260]             version = "1.8"), class = "FutureResult")
[17:00:31.260]     }, finally = {
[17:00:31.260]         if (!identical(...future.workdir, getwd())) 
[17:00:31.260]             setwd(...future.workdir)
[17:00:31.260]         {
[17:00:31.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.260]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.260]             }
[17:00:31.260]             base::options(...future.oldOptions)
[17:00:31.260]             if (.Platform$OS.type == "windows") {
[17:00:31.260]                 old_names <- names(...future.oldEnvVars)
[17:00:31.260]                 envs <- base::Sys.getenv()
[17:00:31.260]                 names <- names(envs)
[17:00:31.260]                 common <- intersect(names, old_names)
[17:00:31.260]                 added <- setdiff(names, old_names)
[17:00:31.260]                 removed <- setdiff(old_names, names)
[17:00:31.260]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.260]                   envs[common]]
[17:00:31.260]                 NAMES <- toupper(changed)
[17:00:31.260]                 args <- list()
[17:00:31.260]                 for (kk in seq_along(NAMES)) {
[17:00:31.260]                   name <- changed[[kk]]
[17:00:31.260]                   NAME <- NAMES[[kk]]
[17:00:31.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.260]                     next
[17:00:31.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.260]                 }
[17:00:31.260]                 NAMES <- toupper(added)
[17:00:31.260]                 for (kk in seq_along(NAMES)) {
[17:00:31.260]                   name <- added[[kk]]
[17:00:31.260]                   NAME <- NAMES[[kk]]
[17:00:31.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.260]                     next
[17:00:31.260]                   args[[name]] <- ""
[17:00:31.260]                 }
[17:00:31.260]                 NAMES <- toupper(removed)
[17:00:31.260]                 for (kk in seq_along(NAMES)) {
[17:00:31.260]                   name <- removed[[kk]]
[17:00:31.260]                   NAME <- NAMES[[kk]]
[17:00:31.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.260]                     next
[17:00:31.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.260]                 }
[17:00:31.260]                 if (length(args) > 0) 
[17:00:31.260]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.260]             }
[17:00:31.260]             else {
[17:00:31.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.260]             }
[17:00:31.260]             {
[17:00:31.260]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.260]                   0L) {
[17:00:31.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.260]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.260]                   base::options(opts)
[17:00:31.260]                 }
[17:00:31.260]                 {
[17:00:31.260]                   {
[17:00:31.260]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.260]                     NULL
[17:00:31.260]                   }
[17:00:31.260]                   options(future.plan = NULL)
[17:00:31.260]                   if (is.na(NA_character_)) 
[17:00:31.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.260]                     .init = FALSE)
[17:00:31.260]                 }
[17:00:31.260]             }
[17:00:31.260]         }
[17:00:31.260]     })
[17:00:31.260]     if (TRUE) {
[17:00:31.260]         base::sink(type = "output", split = FALSE)
[17:00:31.260]         if (TRUE) {
[17:00:31.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.260]         }
[17:00:31.260]         else {
[17:00:31.260]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.260]         }
[17:00:31.260]         base::close(...future.stdout)
[17:00:31.260]         ...future.stdout <- NULL
[17:00:31.260]     }
[17:00:31.260]     ...future.result$conditions <- ...future.conditions
[17:00:31.260]     ...future.result$finished <- base::Sys.time()
[17:00:31.260]     ...future.result
[17:00:31.260] }
[17:00:31.262] assign_globals() ...
[17:00:31.262] List of 5
[17:00:31.262]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:00:31.262]  $ MoreArgs                 :List of 1
[17:00:31.262]   ..$ min: num 1
[17:00:31.262]  $ ...future.elements_ii    :List of 2
[17:00:31.262]   ..$ n  :List of 2
[17:00:31.262]   .. ..$ : int 1
[17:00:31.262]   .. ..$ : int 2
[17:00:31.262]   ..$ max:List of 2
[17:00:31.262]   .. ..$ : int 2
[17:00:31.262]   .. ..$ : int 3
[17:00:31.262]  $ ...future.seeds_ii       :List of 2
[17:00:31.262]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:00:31.262]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:00:31.262]  $ ...future.globals.maxSize: NULL
[17:00:31.262]  - attr(*, "where")=List of 5
[17:00:31.262]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.262]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.262]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.262]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.262]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.262]  - attr(*, "resolved")= logi FALSE
[17:00:31.262]  - attr(*, "total_size")= num 2528
[17:00:31.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.262]  - attr(*, "already-done")= logi TRUE
[17:00:31.269] - copied ‘...future.FUN’ to environment
[17:00:31.269] - copied ‘MoreArgs’ to environment
[17:00:31.269] - copied ‘...future.elements_ii’ to environment
[17:00:31.269] - copied ‘...future.seeds_ii’ to environment
[17:00:31.270] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.270] assign_globals() ... done
[17:00:31.270] requestCore(): workers = 2
[17:00:31.272] MulticoreFuture started
[17:00:31.273] - Launch lazy future ... done
[17:00:31.273] run() for ‘MulticoreFuture’ ... done
[17:00:31.273] Created future:
[17:00:31.273] plan(): Setting new future strategy stack:
[17:00:31.274] List of future strategies:
[17:00:31.274] 1. sequential:
[17:00:31.274]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.274]    - tweaked: FALSE
[17:00:31.274]    - call: NULL
[17:00:31.275] plan(): nbrOfWorkers() = 1
[17:00:31.277] plan(): Setting new future strategy stack:
[17:00:31.277] List of future strategies:
[17:00:31.277] 1. multicore:
[17:00:31.277]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.277]    - tweaked: FALSE
[17:00:31.277]    - call: plan(strategy)
[17:00:31.283] plan(): nbrOfWorkers() = 2
[17:00:31.273] MulticoreFuture:
[17:00:31.273] Label: ‘future_mapply-1’
[17:00:31.273] Expression:
[17:00:31.273] {
[17:00:31.273]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.273]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.273]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.273]         on.exit(options(oopts), add = TRUE)
[17:00:31.273]     }
[17:00:31.273]     {
[17:00:31.273]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:31.273]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:31.273]                 inherits = FALSE)
[17:00:31.273]             ...future.FUN(...)
[17:00:31.273]         }
[17:00:31.273]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:31.273]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:31.273]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.273]         do.call(mapply, args = args)
[17:00:31.273]     }
[17:00:31.273] }
[17:00:31.273] Lazy evaluation: FALSE
[17:00:31.273] Asynchronous evaluation: TRUE
[17:00:31.273] Local evaluation: TRUE
[17:00:31.273] Environment: R_GlobalEnv
[17:00:31.273] Capture standard output: TRUE
[17:00:31.273] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.273] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.273] Packages: 1 packages (‘stats’)
[17:00:31.273] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:31.273] Resolved: TRUE
[17:00:31.273] Value: <not collected>
[17:00:31.273] Conditions captured: <none>
[17:00:31.273] Early signaling: FALSE
[17:00:31.273] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.273] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.284] Chunk #1 of 2 ... DONE
[17:00:31.284] Chunk #2 of 2 ...
[17:00:31.284]  - Finding globals in '...' for chunk #2 ...
[17:00:31.284] getGlobalsAndPackages() ...
[17:00:31.285] Searching for globals...
[17:00:31.285] 
[17:00:31.285] Searching for globals ... DONE
[17:00:31.286] - globals: [0] <none>
[17:00:31.286] getGlobalsAndPackages() ... DONE
[17:00:31.286]    + additional globals found: [n=0] 
[17:00:31.286]    + additional namespaces needed: [n=0] 
[17:00:31.286]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:31.286]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.286]  - seeds: [2] <seeds>
[17:00:31.286]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.287] getGlobalsAndPackages() ...
[17:00:31.291] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.292] Resolving globals: FALSE
[17:00:31.293] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:00:31.295] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:00:31.295] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.296] - packages: [1] ‘stats’
[17:00:31.296] getGlobalsAndPackages() ... DONE
[17:00:31.297] run() for ‘Future’ ...
[17:00:31.297] - state: ‘created’
[17:00:31.297] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.304] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.304]   - Field: ‘label’
[17:00:31.304]   - Field: ‘local’
[17:00:31.304]   - Field: ‘owner’
[17:00:31.305]   - Field: ‘envir’
[17:00:31.305]   - Field: ‘workers’
[17:00:31.305]   - Field: ‘packages’
[17:00:31.305]   - Field: ‘gc’
[17:00:31.305]   - Field: ‘job’
[17:00:31.306]   - Field: ‘conditions’
[17:00:31.306]   - Field: ‘expr’
[17:00:31.306]   - Field: ‘uuid’
[17:00:31.306]   - Field: ‘seed’
[17:00:31.306]   - Field: ‘version’
[17:00:31.307]   - Field: ‘result’
[17:00:31.307]   - Field: ‘asynchronous’
[17:00:31.307]   - Field: ‘calls’
[17:00:31.307]   - Field: ‘globals’
[17:00:31.307]   - Field: ‘stdout’
[17:00:31.308]   - Field: ‘earlySignal’
[17:00:31.308]   - Field: ‘lazy’
[17:00:31.308]   - Field: ‘state’
[17:00:31.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.308] - Launch lazy future ...
[17:00:31.309] Packages needed by the future expression (n = 1): ‘stats’
[17:00:31.309] Packages needed by future strategies (n = 0): <none>
[17:00:31.310] {
[17:00:31.310]     {
[17:00:31.310]         {
[17:00:31.310]             ...future.startTime <- base::Sys.time()
[17:00:31.310]             {
[17:00:31.310]                 {
[17:00:31.310]                   {
[17:00:31.310]                     {
[17:00:31.310]                       {
[17:00:31.310]                         base::local({
[17:00:31.310]                           has_future <- base::requireNamespace("future", 
[17:00:31.310]                             quietly = TRUE)
[17:00:31.310]                           if (has_future) {
[17:00:31.310]                             ns <- base::getNamespace("future")
[17:00:31.310]                             version <- ns[[".package"]][["version"]]
[17:00:31.310]                             if (is.null(version)) 
[17:00:31.310]                               version <- utils::packageVersion("future")
[17:00:31.310]                           }
[17:00:31.310]                           else {
[17:00:31.310]                             version <- NULL
[17:00:31.310]                           }
[17:00:31.310]                           if (!has_future || version < "1.8.0") {
[17:00:31.310]                             info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.310]                               "", base::R.version$version.string), 
[17:00:31.310]                               platform = base::sprintf("%s (%s-bit)", 
[17:00:31.310]                                 base::R.version$platform, 8 * 
[17:00:31.310]                                   base::.Machine$sizeof.pointer), 
[17:00:31.310]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.310]                                 "release", "version")], collapse = " "), 
[17:00:31.310]                               hostname = base::Sys.info()[["nodename"]])
[17:00:31.310]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.310]                               info)
[17:00:31.310]                             info <- base::paste(info, collapse = "; ")
[17:00:31.310]                             if (!has_future) {
[17:00:31.310]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.310]                                 info)
[17:00:31.310]                             }
[17:00:31.310]                             else {
[17:00:31.310]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.310]                                 info, version)
[17:00:31.310]                             }
[17:00:31.310]                             base::stop(msg)
[17:00:31.310]                           }
[17:00:31.310]                         })
[17:00:31.310]                       }
[17:00:31.310]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.310]                       base::options(mc.cores = 1L)
[17:00:31.310]                     }
[17:00:31.310]                     base::local({
[17:00:31.310]                       for (pkg in "stats") {
[17:00:31.310]                         base::loadNamespace(pkg)
[17:00:31.310]                         base::library(pkg, character.only = TRUE)
[17:00:31.310]                       }
[17:00:31.310]                     })
[17:00:31.310]                   }
[17:00:31.310]                   ...future.strategy.old <- future::plan("list")
[17:00:31.310]                   options(future.plan = NULL)
[17:00:31.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.310]                 }
[17:00:31.310]                 ...future.workdir <- getwd()
[17:00:31.310]             }
[17:00:31.310]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.310]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.310]         }
[17:00:31.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.310]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.310]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.310]             base::names(...future.oldOptions))
[17:00:31.310]     }
[17:00:31.310]     if (FALSE) {
[17:00:31.310]     }
[17:00:31.310]     else {
[17:00:31.310]         if (TRUE) {
[17:00:31.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.310]                 open = "w")
[17:00:31.310]         }
[17:00:31.310]         else {
[17:00:31.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.310]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.310]         }
[17:00:31.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.310]             base::sink(type = "output", split = FALSE)
[17:00:31.310]             base::close(...future.stdout)
[17:00:31.310]         }, add = TRUE)
[17:00:31.310]     }
[17:00:31.310]     ...future.frame <- base::sys.nframe()
[17:00:31.310]     ...future.conditions <- base::list()
[17:00:31.310]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.310]     if (FALSE) {
[17:00:31.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.310]     }
[17:00:31.310]     ...future.result <- base::tryCatch({
[17:00:31.310]         base::withCallingHandlers({
[17:00:31.310]             ...future.value <- base::withVisible(base::local({
[17:00:31.310]                 withCallingHandlers({
[17:00:31.310]                   {
[17:00:31.310]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.310]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.310]                       ...future.globals.maxSize)) {
[17:00:31.310]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.310]                       on.exit(options(oopts), add = TRUE)
[17:00:31.310]                     }
[17:00:31.310]                     {
[17:00:31.310]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:31.310]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:31.310]                           envir = globalenv(), inherits = FALSE)
[17:00:31.310]                         ...future.FUN(...)
[17:00:31.310]                       }
[17:00:31.310]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:31.310]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:31.310]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.310]                         USE.NAMES = FALSE)
[17:00:31.310]                       do.call(mapply, args = args)
[17:00:31.310]                     }
[17:00:31.310]                   }
[17:00:31.310]                 }, immediateCondition = function(cond) {
[17:00:31.310]                   save_rds <- function (object, pathname, ...) 
[17:00:31.310]                   {
[17:00:31.310]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.310]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.310]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.310]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.310]                         fi_tmp[["mtime"]])
[17:00:31.310]                     }
[17:00:31.310]                     tryCatch({
[17:00:31.310]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.310]                     }, error = function(ex) {
[17:00:31.310]                       msg <- conditionMessage(ex)
[17:00:31.310]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.310]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.310]                         fi_tmp[["mtime"]], msg)
[17:00:31.310]                       ex$message <- msg
[17:00:31.310]                       stop(ex)
[17:00:31.310]                     })
[17:00:31.310]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.310]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.310]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.310]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.310]                       fi <- file.info(pathname)
[17:00:31.310]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.310]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.310]                         fi[["size"]], fi[["mtime"]])
[17:00:31.310]                       stop(msg)
[17:00:31.310]                     }
[17:00:31.310]                     invisible(pathname)
[17:00:31.310]                   }
[17:00:31.310]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.310]                     rootPath = tempdir()) 
[17:00:31.310]                   {
[17:00:31.310]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.310]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.310]                       tmpdir = path, fileext = ".rds")
[17:00:31.310]                     save_rds(obj, file)
[17:00:31.310]                   }
[17:00:31.310]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.310]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.310]                   {
[17:00:31.310]                     inherits <- base::inherits
[17:00:31.310]                     invokeRestart <- base::invokeRestart
[17:00:31.310]                     is.null <- base::is.null
[17:00:31.310]                     muffled <- FALSE
[17:00:31.310]                     if (inherits(cond, "message")) {
[17:00:31.310]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.310]                       if (muffled) 
[17:00:31.310]                         invokeRestart("muffleMessage")
[17:00:31.310]                     }
[17:00:31.310]                     else if (inherits(cond, "warning")) {
[17:00:31.310]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.310]                       if (muffled) 
[17:00:31.310]                         invokeRestart("muffleWarning")
[17:00:31.310]                     }
[17:00:31.310]                     else if (inherits(cond, "condition")) {
[17:00:31.310]                       if (!is.null(pattern)) {
[17:00:31.310]                         computeRestarts <- base::computeRestarts
[17:00:31.310]                         grepl <- base::grepl
[17:00:31.310]                         restarts <- computeRestarts(cond)
[17:00:31.310]                         for (restart in restarts) {
[17:00:31.310]                           name <- restart$name
[17:00:31.310]                           if (is.null(name)) 
[17:00:31.310]                             next
[17:00:31.310]                           if (!grepl(pattern, name)) 
[17:00:31.310]                             next
[17:00:31.310]                           invokeRestart(restart)
[17:00:31.310]                           muffled <- TRUE
[17:00:31.310]                           break
[17:00:31.310]                         }
[17:00:31.310]                       }
[17:00:31.310]                     }
[17:00:31.310]                     invisible(muffled)
[17:00:31.310]                   }
[17:00:31.310]                   muffleCondition(cond)
[17:00:31.310]                 })
[17:00:31.310]             }))
[17:00:31.310]             future::FutureResult(value = ...future.value$value, 
[17:00:31.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.310]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.310]                     ...future.globalenv.names))
[17:00:31.310]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.310]         }, condition = base::local({
[17:00:31.310]             c <- base::c
[17:00:31.310]             inherits <- base::inherits
[17:00:31.310]             invokeRestart <- base::invokeRestart
[17:00:31.310]             length <- base::length
[17:00:31.310]             list <- base::list
[17:00:31.310]             seq.int <- base::seq.int
[17:00:31.310]             signalCondition <- base::signalCondition
[17:00:31.310]             sys.calls <- base::sys.calls
[17:00:31.310]             `[[` <- base::`[[`
[17:00:31.310]             `+` <- base::`+`
[17:00:31.310]             `<<-` <- base::`<<-`
[17:00:31.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.310]                   3L)]
[17:00:31.310]             }
[17:00:31.310]             function(cond) {
[17:00:31.310]                 is_error <- inherits(cond, "error")
[17:00:31.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.310]                   NULL)
[17:00:31.310]                 if (is_error) {
[17:00:31.310]                   sessionInformation <- function() {
[17:00:31.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.310]                       search = base::search(), system = base::Sys.info())
[17:00:31.310]                   }
[17:00:31.310]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.310]                     cond$call), session = sessionInformation(), 
[17:00:31.310]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.310]                   signalCondition(cond)
[17:00:31.310]                 }
[17:00:31.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.310]                 "immediateCondition"))) {
[17:00:31.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.310]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.310]                   if (TRUE && !signal) {
[17:00:31.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.310]                     {
[17:00:31.310]                       inherits <- base::inherits
[17:00:31.310]                       invokeRestart <- base::invokeRestart
[17:00:31.310]                       is.null <- base::is.null
[17:00:31.310]                       muffled <- FALSE
[17:00:31.310]                       if (inherits(cond, "message")) {
[17:00:31.310]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.310]                         if (muffled) 
[17:00:31.310]                           invokeRestart("muffleMessage")
[17:00:31.310]                       }
[17:00:31.310]                       else if (inherits(cond, "warning")) {
[17:00:31.310]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.310]                         if (muffled) 
[17:00:31.310]                           invokeRestart("muffleWarning")
[17:00:31.310]                       }
[17:00:31.310]                       else if (inherits(cond, "condition")) {
[17:00:31.310]                         if (!is.null(pattern)) {
[17:00:31.310]                           computeRestarts <- base::computeRestarts
[17:00:31.310]                           grepl <- base::grepl
[17:00:31.310]                           restarts <- computeRestarts(cond)
[17:00:31.310]                           for (restart in restarts) {
[17:00:31.310]                             name <- restart$name
[17:00:31.310]                             if (is.null(name)) 
[17:00:31.310]                               next
[17:00:31.310]                             if (!grepl(pattern, name)) 
[17:00:31.310]                               next
[17:00:31.310]                             invokeRestart(restart)
[17:00:31.310]                             muffled <- TRUE
[17:00:31.310]                             break
[17:00:31.310]                           }
[17:00:31.310]                         }
[17:00:31.310]                       }
[17:00:31.310]                       invisible(muffled)
[17:00:31.310]                     }
[17:00:31.310]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.310]                   }
[17:00:31.310]                 }
[17:00:31.310]                 else {
[17:00:31.310]                   if (TRUE) {
[17:00:31.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.310]                     {
[17:00:31.310]                       inherits <- base::inherits
[17:00:31.310]                       invokeRestart <- base::invokeRestart
[17:00:31.310]                       is.null <- base::is.null
[17:00:31.310]                       muffled <- FALSE
[17:00:31.310]                       if (inherits(cond, "message")) {
[17:00:31.310]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.310]                         if (muffled) 
[17:00:31.310]                           invokeRestart("muffleMessage")
[17:00:31.310]                       }
[17:00:31.310]                       else if (inherits(cond, "warning")) {
[17:00:31.310]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.310]                         if (muffled) 
[17:00:31.310]                           invokeRestart("muffleWarning")
[17:00:31.310]                       }
[17:00:31.310]                       else if (inherits(cond, "condition")) {
[17:00:31.310]                         if (!is.null(pattern)) {
[17:00:31.310]                           computeRestarts <- base::computeRestarts
[17:00:31.310]                           grepl <- base::grepl
[17:00:31.310]                           restarts <- computeRestarts(cond)
[17:00:31.310]                           for (restart in restarts) {
[17:00:31.310]                             name <- restart$name
[17:00:31.310]                             if (is.null(name)) 
[17:00:31.310]                               next
[17:00:31.310]                             if (!grepl(pattern, name)) 
[17:00:31.310]                               next
[17:00:31.310]                             invokeRestart(restart)
[17:00:31.310]                             muffled <- TRUE
[17:00:31.310]                             break
[17:00:31.310]                           }
[17:00:31.310]                         }
[17:00:31.310]                       }
[17:00:31.310]                       invisible(muffled)
[17:00:31.310]                     }
[17:00:31.310]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.310]                   }
[17:00:31.310]                 }
[17:00:31.310]             }
[17:00:31.310]         }))
[17:00:31.310]     }, error = function(ex) {
[17:00:31.310]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.310]                 ...future.rng), started = ...future.startTime, 
[17:00:31.310]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.310]             version = "1.8"), class = "FutureResult")
[17:00:31.310]     }, finally = {
[17:00:31.310]         if (!identical(...future.workdir, getwd())) 
[17:00:31.310]             setwd(...future.workdir)
[17:00:31.310]         {
[17:00:31.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.310]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.310]             }
[17:00:31.310]             base::options(...future.oldOptions)
[17:00:31.310]             if (.Platform$OS.type == "windows") {
[17:00:31.310]                 old_names <- names(...future.oldEnvVars)
[17:00:31.310]                 envs <- base::Sys.getenv()
[17:00:31.310]                 names <- names(envs)
[17:00:31.310]                 common <- intersect(names, old_names)
[17:00:31.310]                 added <- setdiff(names, old_names)
[17:00:31.310]                 removed <- setdiff(old_names, names)
[17:00:31.310]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.310]                   envs[common]]
[17:00:31.310]                 NAMES <- toupper(changed)
[17:00:31.310]                 args <- list()
[17:00:31.310]                 for (kk in seq_along(NAMES)) {
[17:00:31.310]                   name <- changed[[kk]]
[17:00:31.310]                   NAME <- NAMES[[kk]]
[17:00:31.310]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.310]                     next
[17:00:31.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.310]                 }
[17:00:31.310]                 NAMES <- toupper(added)
[17:00:31.310]                 for (kk in seq_along(NAMES)) {
[17:00:31.310]                   name <- added[[kk]]
[17:00:31.310]                   NAME <- NAMES[[kk]]
[17:00:31.310]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.310]                     next
[17:00:31.310]                   args[[name]] <- ""
[17:00:31.310]                 }
[17:00:31.310]                 NAMES <- toupper(removed)
[17:00:31.310]                 for (kk in seq_along(NAMES)) {
[17:00:31.310]                   name <- removed[[kk]]
[17:00:31.310]                   NAME <- NAMES[[kk]]
[17:00:31.310]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.310]                     next
[17:00:31.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.310]                 }
[17:00:31.310]                 if (length(args) > 0) 
[17:00:31.310]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.310]             }
[17:00:31.310]             else {
[17:00:31.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.310]             }
[17:00:31.310]             {
[17:00:31.310]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.310]                   0L) {
[17:00:31.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.310]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.310]                   base::options(opts)
[17:00:31.310]                 }
[17:00:31.310]                 {
[17:00:31.310]                   {
[17:00:31.310]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.310]                     NULL
[17:00:31.310]                   }
[17:00:31.310]                   options(future.plan = NULL)
[17:00:31.310]                   if (is.na(NA_character_)) 
[17:00:31.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.310]                     .init = FALSE)
[17:00:31.310]                 }
[17:00:31.310]             }
[17:00:31.310]         }
[17:00:31.310]     })
[17:00:31.310]     if (TRUE) {
[17:00:31.310]         base::sink(type = "output", split = FALSE)
[17:00:31.310]         if (TRUE) {
[17:00:31.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.310]         }
[17:00:31.310]         else {
[17:00:31.310]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.310]         }
[17:00:31.310]         base::close(...future.stdout)
[17:00:31.310]         ...future.stdout <- NULL
[17:00:31.310]     }
[17:00:31.310]     ...future.result$conditions <- ...future.conditions
[17:00:31.310]     ...future.result$finished <- base::Sys.time()
[17:00:31.310]     ...future.result
[17:00:31.310] }
[17:00:31.313] assign_globals() ...
[17:00:31.313] List of 5
[17:00:31.313]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:00:31.313]  $ MoreArgs                 :List of 1
[17:00:31.313]   ..$ min: num 1
[17:00:31.313]  $ ...future.elements_ii    :List of 2
[17:00:31.313]   ..$ n  :List of 2
[17:00:31.313]   .. ..$ : int 3
[17:00:31.313]   .. ..$ : int 4
[17:00:31.313]   ..$ max:List of 2
[17:00:31.313]   .. ..$ : int 4
[17:00:31.313]   .. ..$ : int 5
[17:00:31.313]  $ ...future.seeds_ii       :List of 2
[17:00:31.313]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[17:00:31.313]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[17:00:31.313]  $ ...future.globals.maxSize: NULL
[17:00:31.313]  - attr(*, "where")=List of 5
[17:00:31.313]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.313]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.313]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.313]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.313]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.313]  - attr(*, "resolved")= logi FALSE
[17:00:31.313]  - attr(*, "total_size")= num 2528
[17:00:31.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.313]  - attr(*, "already-done")= logi TRUE
[17:00:31.322] - copied ‘...future.FUN’ to environment
[17:00:31.322] - copied ‘MoreArgs’ to environment
[17:00:31.322] - copied ‘...future.elements_ii’ to environment
[17:00:31.322] - copied ‘...future.seeds_ii’ to environment
[17:00:31.323] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.323] assign_globals() ... done
[17:00:31.323] requestCore(): workers = 2
[17:00:31.325] MulticoreFuture started
[17:00:31.326] - Launch lazy future ... done
[17:00:31.326] run() for ‘MulticoreFuture’ ... done
[17:00:31.326] Created future:
[17:00:31.327] plan(): Setting new future strategy stack:
[17:00:31.327] List of future strategies:
[17:00:31.327] 1. sequential:
[17:00:31.327]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.327]    - tweaked: FALSE
[17:00:31.327]    - call: NULL
[17:00:31.328] plan(): nbrOfWorkers() = 1
[17:00:31.330] plan(): Setting new future strategy stack:
[17:00:31.330] List of future strategies:
[17:00:31.330] 1. multicore:
[17:00:31.330]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.330]    - tweaked: FALSE
[17:00:31.330]    - call: plan(strategy)
[17:00:31.335] plan(): nbrOfWorkers() = 2
[17:00:31.326] MulticoreFuture:
[17:00:31.326] Label: ‘future_mapply-2’
[17:00:31.326] Expression:
[17:00:31.326] {
[17:00:31.326]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.326]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.326]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.326]         on.exit(options(oopts), add = TRUE)
[17:00:31.326]     }
[17:00:31.326]     {
[17:00:31.326]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:31.326]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:31.326]                 inherits = FALSE)
[17:00:31.326]             ...future.FUN(...)
[17:00:31.326]         }
[17:00:31.326]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:31.326]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:31.326]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.326]         do.call(mapply, args = args)
[17:00:31.326]     }
[17:00:31.326] }
[17:00:31.326] Lazy evaluation: FALSE
[17:00:31.326] Asynchronous evaluation: TRUE
[17:00:31.326] Local evaluation: TRUE
[17:00:31.326] Environment: R_GlobalEnv
[17:00:31.326] Capture standard output: TRUE
[17:00:31.326] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.326] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.326] Packages: 1 packages (‘stats’)
[17:00:31.326] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:31.326] Resolved: TRUE
[17:00:31.326] Value: <not collected>
[17:00:31.326] Conditions captured: <none>
[17:00:31.326] Early signaling: FALSE
[17:00:31.326] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.326] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.336] Chunk #2 of 2 ... DONE
[17:00:31.337] Launching 2 futures (chunks) ... DONE
[17:00:31.337] Resolving 2 futures (chunks) ...
[17:00:31.337] resolve() on list ...
[17:00:31.337]  recursive: 0
[17:00:31.337]  length: 2
[17:00:31.337] 
[17:00:31.338] Future #1
[17:00:31.338] result() for MulticoreFuture ...
[17:00:31.339] result() for MulticoreFuture ...
[17:00:31.339] result() for MulticoreFuture ... done
[17:00:31.339] result() for MulticoreFuture ... done
[17:00:31.339] result() for MulticoreFuture ...
[17:00:31.339] result() for MulticoreFuture ... done
[17:00:31.339] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:31.340] - nx: 2
[17:00:31.340] - relay: TRUE
[17:00:31.340] - stdout: TRUE
[17:00:31.340] - signal: TRUE
[17:00:31.340] - resignal: FALSE
[17:00:31.345] - force: TRUE
[17:00:31.345] - relayed: [n=2] FALSE, FALSE
[17:00:31.345] - queued futures: [n=2] FALSE, FALSE
[17:00:31.346]  - until=1
[17:00:31.346]  - relaying element #1
[17:00:31.346] result() for MulticoreFuture ...
[17:00:31.347] result() for MulticoreFuture ... done
[17:00:31.347] result() for MulticoreFuture ...
[17:00:31.347] result() for MulticoreFuture ... done
[17:00:31.348] result() for MulticoreFuture ...
[17:00:31.348] result() for MulticoreFuture ... done
[17:00:31.348] result() for MulticoreFuture ...
[17:00:31.349] result() for MulticoreFuture ... done
[17:00:31.349] - relayed: [n=2] TRUE, FALSE
[17:00:31.349] - queued futures: [n=2] TRUE, FALSE
[17:00:31.349] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:31.350]  length: 1 (resolved future 1)
[17:00:31.350] Future #2
[17:00:31.350] result() for MulticoreFuture ...
[17:00:31.351] result() for MulticoreFuture ...
[17:00:31.352] result() for MulticoreFuture ... done
[17:00:31.352] result() for MulticoreFuture ... done
[17:00:31.352] result() for MulticoreFuture ...
[17:00:31.352] result() for MulticoreFuture ... done
[17:00:31.353] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:31.353] - nx: 2
[17:00:31.353] - relay: TRUE
[17:00:31.353] - stdout: TRUE
[17:00:31.353] - signal: TRUE
[17:00:31.353] - resignal: FALSE
[17:00:31.353] - force: TRUE
[17:00:31.354] - relayed: [n=2] TRUE, FALSE
[17:00:31.354] - queued futures: [n=2] TRUE, FALSE
[17:00:31.354]  - until=2
[17:00:31.354]  - relaying element #2
[17:00:31.354] result() for MulticoreFuture ...
[17:00:31.354] result() for MulticoreFuture ... done
[17:00:31.354] result() for MulticoreFuture ...
[17:00:31.355] result() for MulticoreFuture ... done
[17:00:31.355] result() for MulticoreFuture ...
[17:00:31.355] result() for MulticoreFuture ... done
[17:00:31.355] result() for MulticoreFuture ...
[17:00:31.355] result() for MulticoreFuture ... done
[17:00:31.355] - relayed: [n=2] TRUE, TRUE
[17:00:31.356] - queued futures: [n=2] TRUE, TRUE
[17:00:31.356] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:31.356]  length: 0 (resolved future 2)
[17:00:31.356] Relaying remaining futures
[17:00:31.356] signalConditionsASAP(NULL, pos=0) ...
[17:00:31.356] - nx: 2
[17:00:31.356] - relay: TRUE
[17:00:31.357] - stdout: TRUE
[17:00:31.357] - signal: TRUE
[17:00:31.357] - resignal: FALSE
[17:00:31.357] - force: TRUE
[17:00:31.357] - relayed: [n=2] TRUE, TRUE
[17:00:31.357] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:31.357] - relayed: [n=2] TRUE, TRUE
[17:00:31.358] - queued futures: [n=2] TRUE, TRUE
[17:00:31.358] signalConditionsASAP(NULL, pos=0) ... done
[17:00:31.358] resolve() on list ... DONE
[17:00:31.358] result() for MulticoreFuture ...
[17:00:31.358] result() for MulticoreFuture ... done
[17:00:31.358] result() for MulticoreFuture ...
[17:00:31.358] result() for MulticoreFuture ... done
[17:00:31.358] result() for MulticoreFuture ...
[17:00:31.358] result() for MulticoreFuture ... done
[17:00:31.359] result() for MulticoreFuture ...
[17:00:31.359] result() for MulticoreFuture ... done
[17:00:31.359]  - Number of value chunks collected: 2
[17:00:31.359] Resolving 2 futures (chunks) ... DONE
[17:00:31.359] Reducing values from 2 chunks ...
[17:00:31.359]  - Number of values collected after concatenation: 4
[17:00:31.359]  - Number of values expected: 4
[17:00:31.359] Reducing values from 2 chunks ... DONE
[17:00:31.360] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[17:00:31.360] future_mapply() ...
[17:00:31.365] Number of chunks: 2
[17:00:31.365] getGlobalsAndPackagesXApply() ...
[17:00:31.365]  - future.globals: TRUE
[17:00:31.365] getGlobalsAndPackages() ...
[17:00:31.365] Searching for globals...
[17:00:31.366] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:00:31.367] Searching for globals ... DONE
[17:00:31.367] Resolving globals: FALSE
[17:00:31.367] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[17:00:31.368] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[17:00:31.368] - globals: [1] ‘FUN’
[17:00:31.368] - packages: [1] ‘stats’
[17:00:31.368] getGlobalsAndPackages() ... DONE
[17:00:31.368]  - globals found/used: [n=1] ‘FUN’
[17:00:31.368]  - needed namespaces: [n=1] ‘stats’
[17:00:31.368] Finding globals ... DONE
[17:00:31.369] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:31.369] List of 2
[17:00:31.369]  $ ...future.FUN:function (x, w, ...)  
[17:00:31.369]  $ MoreArgs     : NULL
[17:00:31.369]  - attr(*, "where")=List of 2
[17:00:31.369]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:31.369]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:31.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.369]  - attr(*, "resolved")= logi FALSE
[17:00:31.369]  - attr(*, "total_size")= num NA
[17:00:31.371] Packages to be attached in all futures: [n=1] ‘stats’
[17:00:31.371] getGlobalsAndPackagesXApply() ... DONE
[17:00:31.372] Number of futures (= number of chunks): 2
[17:00:31.372] Launching 2 futures (chunks) ...
[17:00:31.372] Chunk #1 of 2 ...
[17:00:31.372]  - Finding globals in '...' for chunk #1 ...
[17:00:31.372] getGlobalsAndPackages() ...
[17:00:31.372] Searching for globals...
[17:00:31.373] 
[17:00:31.373] Searching for globals ... DONE
[17:00:31.373] - globals: [0] <none>
[17:00:31.373] getGlobalsAndPackages() ... DONE
[17:00:31.373]    + additional globals found: [n=0] 
[17:00:31.373]    + additional namespaces needed: [n=0] 
[17:00:31.373]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:31.373]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.373]  - seeds: <none>
[17:00:31.373]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.374] getGlobalsAndPackages() ...
[17:00:31.374] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.374] Resolving globals: FALSE
[17:00:31.374] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[17:00:31.377] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:31.378] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.378] - packages: [1] ‘stats’
[17:00:31.378] getGlobalsAndPackages() ... DONE
[17:00:31.378] run() for ‘Future’ ...
[17:00:31.378] - state: ‘created’
[17:00:31.379] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.383] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.383]   - Field: ‘label’
[17:00:31.383]   - Field: ‘local’
[17:00:31.383]   - Field: ‘owner’
[17:00:31.384]   - Field: ‘envir’
[17:00:31.384]   - Field: ‘workers’
[17:00:31.384]   - Field: ‘packages’
[17:00:31.384]   - Field: ‘gc’
[17:00:31.384]   - Field: ‘job’
[17:00:31.384]   - Field: ‘conditions’
[17:00:31.384]   - Field: ‘expr’
[17:00:31.384]   - Field: ‘uuid’
[17:00:31.385]   - Field: ‘seed’
[17:00:31.385]   - Field: ‘version’
[17:00:31.385]   - Field: ‘result’
[17:00:31.385]   - Field: ‘asynchronous’
[17:00:31.385]   - Field: ‘calls’
[17:00:31.385]   - Field: ‘globals’
[17:00:31.385]   - Field: ‘stdout’
[17:00:31.385]   - Field: ‘earlySignal’
[17:00:31.386]   - Field: ‘lazy’
[17:00:31.386]   - Field: ‘state’
[17:00:31.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.386] - Launch lazy future ...
[17:00:31.386] Packages needed by the future expression (n = 1): ‘stats’
[17:00:31.386] Packages needed by future strategies (n = 0): <none>
[17:00:31.387] {
[17:00:31.387]     {
[17:00:31.387]         {
[17:00:31.387]             ...future.startTime <- base::Sys.time()
[17:00:31.387]             {
[17:00:31.387]                 {
[17:00:31.387]                   {
[17:00:31.387]                     {
[17:00:31.387]                       {
[17:00:31.387]                         base::local({
[17:00:31.387]                           has_future <- base::requireNamespace("future", 
[17:00:31.387]                             quietly = TRUE)
[17:00:31.387]                           if (has_future) {
[17:00:31.387]                             ns <- base::getNamespace("future")
[17:00:31.387]                             version <- ns[[".package"]][["version"]]
[17:00:31.387]                             if (is.null(version)) 
[17:00:31.387]                               version <- utils::packageVersion("future")
[17:00:31.387]                           }
[17:00:31.387]                           else {
[17:00:31.387]                             version <- NULL
[17:00:31.387]                           }
[17:00:31.387]                           if (!has_future || version < "1.8.0") {
[17:00:31.387]                             info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.387]                               "", base::R.version$version.string), 
[17:00:31.387]                               platform = base::sprintf("%s (%s-bit)", 
[17:00:31.387]                                 base::R.version$platform, 8 * 
[17:00:31.387]                                   base::.Machine$sizeof.pointer), 
[17:00:31.387]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.387]                                 "release", "version")], collapse = " "), 
[17:00:31.387]                               hostname = base::Sys.info()[["nodename"]])
[17:00:31.387]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.387]                               info)
[17:00:31.387]                             info <- base::paste(info, collapse = "; ")
[17:00:31.387]                             if (!has_future) {
[17:00:31.387]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.387]                                 info)
[17:00:31.387]                             }
[17:00:31.387]                             else {
[17:00:31.387]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.387]                                 info, version)
[17:00:31.387]                             }
[17:00:31.387]                             base::stop(msg)
[17:00:31.387]                           }
[17:00:31.387]                         })
[17:00:31.387]                       }
[17:00:31.387]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.387]                       base::options(mc.cores = 1L)
[17:00:31.387]                     }
[17:00:31.387]                     base::local({
[17:00:31.387]                       for (pkg in "stats") {
[17:00:31.387]                         base::loadNamespace(pkg)
[17:00:31.387]                         base::library(pkg, character.only = TRUE)
[17:00:31.387]                       }
[17:00:31.387]                     })
[17:00:31.387]                   }
[17:00:31.387]                   ...future.strategy.old <- future::plan("list")
[17:00:31.387]                   options(future.plan = NULL)
[17:00:31.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.387]                 }
[17:00:31.387]                 ...future.workdir <- getwd()
[17:00:31.387]             }
[17:00:31.387]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.387]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.387]         }
[17:00:31.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.387]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.387]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.387]             base::names(...future.oldOptions))
[17:00:31.387]     }
[17:00:31.387]     if (FALSE) {
[17:00:31.387]     }
[17:00:31.387]     else {
[17:00:31.387]         if (TRUE) {
[17:00:31.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.387]                 open = "w")
[17:00:31.387]         }
[17:00:31.387]         else {
[17:00:31.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.387]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.387]         }
[17:00:31.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.387]             base::sink(type = "output", split = FALSE)
[17:00:31.387]             base::close(...future.stdout)
[17:00:31.387]         }, add = TRUE)
[17:00:31.387]     }
[17:00:31.387]     ...future.frame <- base::sys.nframe()
[17:00:31.387]     ...future.conditions <- base::list()
[17:00:31.387]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.387]     if (FALSE) {
[17:00:31.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.387]     }
[17:00:31.387]     ...future.result <- base::tryCatch({
[17:00:31.387]         base::withCallingHandlers({
[17:00:31.387]             ...future.value <- base::withVisible(base::local({
[17:00:31.387]                 withCallingHandlers({
[17:00:31.387]                   {
[17:00:31.387]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.387]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.387]                       ...future.globals.maxSize)) {
[17:00:31.387]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.387]                       on.exit(options(oopts), add = TRUE)
[17:00:31.387]                     }
[17:00:31.387]                     {
[17:00:31.387]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.387]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.387]                         USE.NAMES = FALSE)
[17:00:31.387]                       do.call(mapply, args = args)
[17:00:31.387]                     }
[17:00:31.387]                   }
[17:00:31.387]                 }, immediateCondition = function(cond) {
[17:00:31.387]                   save_rds <- function (object, pathname, ...) 
[17:00:31.387]                   {
[17:00:31.387]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.387]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.387]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.387]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.387]                         fi_tmp[["mtime"]])
[17:00:31.387]                     }
[17:00:31.387]                     tryCatch({
[17:00:31.387]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.387]                     }, error = function(ex) {
[17:00:31.387]                       msg <- conditionMessage(ex)
[17:00:31.387]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.387]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.387]                         fi_tmp[["mtime"]], msg)
[17:00:31.387]                       ex$message <- msg
[17:00:31.387]                       stop(ex)
[17:00:31.387]                     })
[17:00:31.387]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.387]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.387]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.387]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.387]                       fi <- file.info(pathname)
[17:00:31.387]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.387]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.387]                         fi[["size"]], fi[["mtime"]])
[17:00:31.387]                       stop(msg)
[17:00:31.387]                     }
[17:00:31.387]                     invisible(pathname)
[17:00:31.387]                   }
[17:00:31.387]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.387]                     rootPath = tempdir()) 
[17:00:31.387]                   {
[17:00:31.387]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.387]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.387]                       tmpdir = path, fileext = ".rds")
[17:00:31.387]                     save_rds(obj, file)
[17:00:31.387]                   }
[17:00:31.387]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.387]                   {
[17:00:31.387]                     inherits <- base::inherits
[17:00:31.387]                     invokeRestart <- base::invokeRestart
[17:00:31.387]                     is.null <- base::is.null
[17:00:31.387]                     muffled <- FALSE
[17:00:31.387]                     if (inherits(cond, "message")) {
[17:00:31.387]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.387]                       if (muffled) 
[17:00:31.387]                         invokeRestart("muffleMessage")
[17:00:31.387]                     }
[17:00:31.387]                     else if (inherits(cond, "warning")) {
[17:00:31.387]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.387]                       if (muffled) 
[17:00:31.387]                         invokeRestart("muffleWarning")
[17:00:31.387]                     }
[17:00:31.387]                     else if (inherits(cond, "condition")) {
[17:00:31.387]                       if (!is.null(pattern)) {
[17:00:31.387]                         computeRestarts <- base::computeRestarts
[17:00:31.387]                         grepl <- base::grepl
[17:00:31.387]                         restarts <- computeRestarts(cond)
[17:00:31.387]                         for (restart in restarts) {
[17:00:31.387]                           name <- restart$name
[17:00:31.387]                           if (is.null(name)) 
[17:00:31.387]                             next
[17:00:31.387]                           if (!grepl(pattern, name)) 
[17:00:31.387]                             next
[17:00:31.387]                           invokeRestart(restart)
[17:00:31.387]                           muffled <- TRUE
[17:00:31.387]                           break
[17:00:31.387]                         }
[17:00:31.387]                       }
[17:00:31.387]                     }
[17:00:31.387]                     invisible(muffled)
[17:00:31.387]                   }
[17:00:31.387]                   muffleCondition(cond)
[17:00:31.387]                 })
[17:00:31.387]             }))
[17:00:31.387]             future::FutureResult(value = ...future.value$value, 
[17:00:31.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.387]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.387]                     ...future.globalenv.names))
[17:00:31.387]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.387]         }, condition = base::local({
[17:00:31.387]             c <- base::c
[17:00:31.387]             inherits <- base::inherits
[17:00:31.387]             invokeRestart <- base::invokeRestart
[17:00:31.387]             length <- base::length
[17:00:31.387]             list <- base::list
[17:00:31.387]             seq.int <- base::seq.int
[17:00:31.387]             signalCondition <- base::signalCondition
[17:00:31.387]             sys.calls <- base::sys.calls
[17:00:31.387]             `[[` <- base::`[[`
[17:00:31.387]             `+` <- base::`+`
[17:00:31.387]             `<<-` <- base::`<<-`
[17:00:31.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.387]                   3L)]
[17:00:31.387]             }
[17:00:31.387]             function(cond) {
[17:00:31.387]                 is_error <- inherits(cond, "error")
[17:00:31.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.387]                   NULL)
[17:00:31.387]                 if (is_error) {
[17:00:31.387]                   sessionInformation <- function() {
[17:00:31.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.387]                       search = base::search(), system = base::Sys.info())
[17:00:31.387]                   }
[17:00:31.387]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.387]                     cond$call), session = sessionInformation(), 
[17:00:31.387]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.387]                   signalCondition(cond)
[17:00:31.387]                 }
[17:00:31.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.387]                 "immediateCondition"))) {
[17:00:31.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.387]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.387]                   if (TRUE && !signal) {
[17:00:31.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.387]                     {
[17:00:31.387]                       inherits <- base::inherits
[17:00:31.387]                       invokeRestart <- base::invokeRestart
[17:00:31.387]                       is.null <- base::is.null
[17:00:31.387]                       muffled <- FALSE
[17:00:31.387]                       if (inherits(cond, "message")) {
[17:00:31.387]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.387]                         if (muffled) 
[17:00:31.387]                           invokeRestart("muffleMessage")
[17:00:31.387]                       }
[17:00:31.387]                       else if (inherits(cond, "warning")) {
[17:00:31.387]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.387]                         if (muffled) 
[17:00:31.387]                           invokeRestart("muffleWarning")
[17:00:31.387]                       }
[17:00:31.387]                       else if (inherits(cond, "condition")) {
[17:00:31.387]                         if (!is.null(pattern)) {
[17:00:31.387]                           computeRestarts <- base::computeRestarts
[17:00:31.387]                           grepl <- base::grepl
[17:00:31.387]                           restarts <- computeRestarts(cond)
[17:00:31.387]                           for (restart in restarts) {
[17:00:31.387]                             name <- restart$name
[17:00:31.387]                             if (is.null(name)) 
[17:00:31.387]                               next
[17:00:31.387]                             if (!grepl(pattern, name)) 
[17:00:31.387]                               next
[17:00:31.387]                             invokeRestart(restart)
[17:00:31.387]                             muffled <- TRUE
[17:00:31.387]                             break
[17:00:31.387]                           }
[17:00:31.387]                         }
[17:00:31.387]                       }
[17:00:31.387]                       invisible(muffled)
[17:00:31.387]                     }
[17:00:31.387]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.387]                   }
[17:00:31.387]                 }
[17:00:31.387]                 else {
[17:00:31.387]                   if (TRUE) {
[17:00:31.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.387]                     {
[17:00:31.387]                       inherits <- base::inherits
[17:00:31.387]                       invokeRestart <- base::invokeRestart
[17:00:31.387]                       is.null <- base::is.null
[17:00:31.387]                       muffled <- FALSE
[17:00:31.387]                       if (inherits(cond, "message")) {
[17:00:31.387]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.387]                         if (muffled) 
[17:00:31.387]                           invokeRestart("muffleMessage")
[17:00:31.387]                       }
[17:00:31.387]                       else if (inherits(cond, "warning")) {
[17:00:31.387]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.387]                         if (muffled) 
[17:00:31.387]                           invokeRestart("muffleWarning")
[17:00:31.387]                       }
[17:00:31.387]                       else if (inherits(cond, "condition")) {
[17:00:31.387]                         if (!is.null(pattern)) {
[17:00:31.387]                           computeRestarts <- base::computeRestarts
[17:00:31.387]                           grepl <- base::grepl
[17:00:31.387]                           restarts <- computeRestarts(cond)
[17:00:31.387]                           for (restart in restarts) {
[17:00:31.387]                             name <- restart$name
[17:00:31.387]                             if (is.null(name)) 
[17:00:31.387]                               next
[17:00:31.387]                             if (!grepl(pattern, name)) 
[17:00:31.387]                               next
[17:00:31.387]                             invokeRestart(restart)
[17:00:31.387]                             muffled <- TRUE
[17:00:31.387]                             break
[17:00:31.387]                           }
[17:00:31.387]                         }
[17:00:31.387]                       }
[17:00:31.387]                       invisible(muffled)
[17:00:31.387]                     }
[17:00:31.387]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.387]                   }
[17:00:31.387]                 }
[17:00:31.387]             }
[17:00:31.387]         }))
[17:00:31.387]     }, error = function(ex) {
[17:00:31.387]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.387]                 ...future.rng), started = ...future.startTime, 
[17:00:31.387]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.387]             version = "1.8"), class = "FutureResult")
[17:00:31.387]     }, finally = {
[17:00:31.387]         if (!identical(...future.workdir, getwd())) 
[17:00:31.387]             setwd(...future.workdir)
[17:00:31.387]         {
[17:00:31.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.387]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.387]             }
[17:00:31.387]             base::options(...future.oldOptions)
[17:00:31.387]             if (.Platform$OS.type == "windows") {
[17:00:31.387]                 old_names <- names(...future.oldEnvVars)
[17:00:31.387]                 envs <- base::Sys.getenv()
[17:00:31.387]                 names <- names(envs)
[17:00:31.387]                 common <- intersect(names, old_names)
[17:00:31.387]                 added <- setdiff(names, old_names)
[17:00:31.387]                 removed <- setdiff(old_names, names)
[17:00:31.387]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.387]                   envs[common]]
[17:00:31.387]                 NAMES <- toupper(changed)
[17:00:31.387]                 args <- list()
[17:00:31.387]                 for (kk in seq_along(NAMES)) {
[17:00:31.387]                   name <- changed[[kk]]
[17:00:31.387]                   NAME <- NAMES[[kk]]
[17:00:31.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.387]                     next
[17:00:31.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.387]                 }
[17:00:31.387]                 NAMES <- toupper(added)
[17:00:31.387]                 for (kk in seq_along(NAMES)) {
[17:00:31.387]                   name <- added[[kk]]
[17:00:31.387]                   NAME <- NAMES[[kk]]
[17:00:31.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.387]                     next
[17:00:31.387]                   args[[name]] <- ""
[17:00:31.387]                 }
[17:00:31.387]                 NAMES <- toupper(removed)
[17:00:31.387]                 for (kk in seq_along(NAMES)) {
[17:00:31.387]                   name <- removed[[kk]]
[17:00:31.387]                   NAME <- NAMES[[kk]]
[17:00:31.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.387]                     next
[17:00:31.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.387]                 }
[17:00:31.387]                 if (length(args) > 0) 
[17:00:31.387]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.387]             }
[17:00:31.387]             else {
[17:00:31.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.387]             }
[17:00:31.387]             {
[17:00:31.387]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.387]                   0L) {
[17:00:31.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.387]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.387]                   base::options(opts)
[17:00:31.387]                 }
[17:00:31.387]                 {
[17:00:31.387]                   {
[17:00:31.387]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.387]                     NULL
[17:00:31.387]                   }
[17:00:31.387]                   options(future.plan = NULL)
[17:00:31.387]                   if (is.na(NA_character_)) 
[17:00:31.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.387]                     .init = FALSE)
[17:00:31.387]                 }
[17:00:31.387]             }
[17:00:31.387]         }
[17:00:31.387]     })
[17:00:31.387]     if (TRUE) {
[17:00:31.387]         base::sink(type = "output", split = FALSE)
[17:00:31.387]         if (TRUE) {
[17:00:31.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.387]         }
[17:00:31.387]         else {
[17:00:31.387]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.387]         }
[17:00:31.387]         base::close(...future.stdout)
[17:00:31.387]         ...future.stdout <- NULL
[17:00:31.387]     }
[17:00:31.387]     ...future.result$conditions <- ...future.conditions
[17:00:31.387]     ...future.result$finished <- base::Sys.time()
[17:00:31.387]     ...future.result
[17:00:31.387] }
[17:00:31.390] assign_globals() ...
[17:00:31.390] List of 5
[17:00:31.390]  $ ...future.FUN            :function (x, w, ...)  
[17:00:31.390]  $ MoreArgs                 : NULL
[17:00:31.390]  $ ...future.elements_ii    :List of 2
[17:00:31.390]   ..$ :List of 2
[17:00:31.390]   .. ..$ : num [1:10] 0.299 0.5001 0.7959 0.0286 0.8783 ...
[17:00:31.390]   .. ..$ : num [1:10] 0.0818 0.8332 0.5595 0.3057 0.2525 ...
[17:00:31.390]   ..$ :List of 2
[17:00:31.390]   .. ..$ : num [1:10] 4 8 7 4 6 5 8 5 7 1
[17:00:31.390]   .. ..$ : num [1:10] 7 4 8 4 9 4 7 6 4 6
[17:00:31.390]  $ ...future.seeds_ii       : NULL
[17:00:31.390]  $ ...future.globals.maxSize: NULL
[17:00:31.390]  - attr(*, "where")=List of 5
[17:00:31.390]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.390]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.390]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.390]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.390]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.390]  - attr(*, "resolved")= logi FALSE
[17:00:31.390]  - attr(*, "total_size")= num 2120
[17:00:31.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.390]  - attr(*, "already-done")= logi TRUE
[17:00:31.396] - copied ‘...future.FUN’ to environment
[17:00:31.396] - copied ‘MoreArgs’ to environment
[17:00:31.396] - copied ‘...future.elements_ii’ to environment
[17:00:31.396] - copied ‘...future.seeds_ii’ to environment
[17:00:31.397] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.397] assign_globals() ... done
[17:00:31.397] requestCore(): workers = 2
[17:00:31.399] MulticoreFuture started
[17:00:31.400] - Launch lazy future ... done
[17:00:31.400] run() for ‘MulticoreFuture’ ... done
[17:00:31.400] Created future:
[17:00:31.401] plan(): Setting new future strategy stack:
[17:00:31.401] List of future strategies:
[17:00:31.401] 1. sequential:
[17:00:31.401]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.401]    - tweaked: FALSE
[17:00:31.401]    - call: NULL
[17:00:31.402] plan(): nbrOfWorkers() = 1
[17:00:31.404] plan(): Setting new future strategy stack:
[17:00:31.404] List of future strategies:
[17:00:31.404] 1. multicore:
[17:00:31.404]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.404]    - tweaked: FALSE
[17:00:31.404]    - call: plan(strategy)
[17:00:31.410] plan(): nbrOfWorkers() = 2
[17:00:31.400] MulticoreFuture:
[17:00:31.400] Label: ‘future_Map-1’
[17:00:31.400] Expression:
[17:00:31.400] {
[17:00:31.400]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.400]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.400]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.400]         on.exit(options(oopts), add = TRUE)
[17:00:31.400]     }
[17:00:31.400]     {
[17:00:31.400]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.400]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.400]         do.call(mapply, args = args)
[17:00:31.400]     }
[17:00:31.400] }
[17:00:31.400] Lazy evaluation: FALSE
[17:00:31.400] Asynchronous evaluation: TRUE
[17:00:31.400] Local evaluation: TRUE
[17:00:31.400] Environment: R_GlobalEnv
[17:00:31.400] Capture standard output: TRUE
[17:00:31.400] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.400] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.400] Packages: 1 packages (‘stats’)
[17:00:31.400] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:31.400] Resolved: TRUE
[17:00:31.400] Value: <not collected>
[17:00:31.400] Conditions captured: <none>
[17:00:31.400] Early signaling: FALSE
[17:00:31.400] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.400] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.411] Chunk #1 of 2 ... DONE
[17:00:31.411] Chunk #2 of 2 ...
[17:00:31.412]  - Finding globals in '...' for chunk #2 ...
[17:00:31.412] getGlobalsAndPackages() ...
[17:00:31.412] Searching for globals...
[17:00:31.413] 
[17:00:31.413] Searching for globals ... DONE
[17:00:31.413] - globals: [0] <none>
[17:00:31.413] getGlobalsAndPackages() ... DONE
[17:00:31.413]    + additional globals found: [n=0] 
[17:00:31.413]    + additional namespaces needed: [n=0] 
[17:00:31.413]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:31.413]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.414]  - seeds: <none>
[17:00:31.414]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.414] getGlobalsAndPackages() ...
[17:00:31.414] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.414] Resolving globals: FALSE
[17:00:31.415] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[17:00:31.416] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:31.416] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.417] - packages: [1] ‘stats’
[17:00:31.417] getGlobalsAndPackages() ... DONE
[17:00:31.417] run() for ‘Future’ ...
[17:00:31.418] - state: ‘created’
[17:00:31.418] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.429] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.430]   - Field: ‘label’
[17:00:31.430]   - Field: ‘local’
[17:00:31.431]   - Field: ‘owner’
[17:00:31.431]   - Field: ‘envir’
[17:00:31.431]   - Field: ‘workers’
[17:00:31.431]   - Field: ‘packages’
[17:00:31.432]   - Field: ‘gc’
[17:00:31.432]   - Field: ‘job’
[17:00:31.432]   - Field: ‘conditions’
[17:00:31.433]   - Field: ‘expr’
[17:00:31.433]   - Field: ‘uuid’
[17:00:31.433]   - Field: ‘seed’
[17:00:31.433]   - Field: ‘version’
[17:00:31.433]   - Field: ‘result’
[17:00:31.434]   - Field: ‘asynchronous’
[17:00:31.434]   - Field: ‘calls’
[17:00:31.434]   - Field: ‘globals’
[17:00:31.434]   - Field: ‘stdout’
[17:00:31.435]   - Field: ‘earlySignal’
[17:00:31.435]   - Field: ‘lazy’
[17:00:31.435]   - Field: ‘state’
[17:00:31.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.435] - Launch lazy future ...
[17:00:31.436] Packages needed by the future expression (n = 1): ‘stats’
[17:00:31.436] Packages needed by future strategies (n = 0): <none>
[17:00:31.437] {
[17:00:31.437]     {
[17:00:31.437]         {
[17:00:31.437]             ...future.startTime <- base::Sys.time()
[17:00:31.437]             {
[17:00:31.437]                 {
[17:00:31.437]                   {
[17:00:31.437]                     {
[17:00:31.437]                       {
[17:00:31.437]                         base::local({
[17:00:31.437]                           has_future <- base::requireNamespace("future", 
[17:00:31.437]                             quietly = TRUE)
[17:00:31.437]                           if (has_future) {
[17:00:31.437]                             ns <- base::getNamespace("future")
[17:00:31.437]                             version <- ns[[".package"]][["version"]]
[17:00:31.437]                             if (is.null(version)) 
[17:00:31.437]                               version <- utils::packageVersion("future")
[17:00:31.437]                           }
[17:00:31.437]                           else {
[17:00:31.437]                             version <- NULL
[17:00:31.437]                           }
[17:00:31.437]                           if (!has_future || version < "1.8.0") {
[17:00:31.437]                             info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.437]                               "", base::R.version$version.string), 
[17:00:31.437]                               platform = base::sprintf("%s (%s-bit)", 
[17:00:31.437]                                 base::R.version$platform, 8 * 
[17:00:31.437]                                   base::.Machine$sizeof.pointer), 
[17:00:31.437]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.437]                                 "release", "version")], collapse = " "), 
[17:00:31.437]                               hostname = base::Sys.info()[["nodename"]])
[17:00:31.437]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.437]                               info)
[17:00:31.437]                             info <- base::paste(info, collapse = "; ")
[17:00:31.437]                             if (!has_future) {
[17:00:31.437]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.437]                                 info)
[17:00:31.437]                             }
[17:00:31.437]                             else {
[17:00:31.437]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.437]                                 info, version)
[17:00:31.437]                             }
[17:00:31.437]                             base::stop(msg)
[17:00:31.437]                           }
[17:00:31.437]                         })
[17:00:31.437]                       }
[17:00:31.437]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.437]                       base::options(mc.cores = 1L)
[17:00:31.437]                     }
[17:00:31.437]                     base::local({
[17:00:31.437]                       for (pkg in "stats") {
[17:00:31.437]                         base::loadNamespace(pkg)
[17:00:31.437]                         base::library(pkg, character.only = TRUE)
[17:00:31.437]                       }
[17:00:31.437]                     })
[17:00:31.437]                   }
[17:00:31.437]                   ...future.strategy.old <- future::plan("list")
[17:00:31.437]                   options(future.plan = NULL)
[17:00:31.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.437]                 }
[17:00:31.437]                 ...future.workdir <- getwd()
[17:00:31.437]             }
[17:00:31.437]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.437]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.437]         }
[17:00:31.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.437]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.437]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.437]             base::names(...future.oldOptions))
[17:00:31.437]     }
[17:00:31.437]     if (FALSE) {
[17:00:31.437]     }
[17:00:31.437]     else {
[17:00:31.437]         if (TRUE) {
[17:00:31.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.437]                 open = "w")
[17:00:31.437]         }
[17:00:31.437]         else {
[17:00:31.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.437]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.437]         }
[17:00:31.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.437]             base::sink(type = "output", split = FALSE)
[17:00:31.437]             base::close(...future.stdout)
[17:00:31.437]         }, add = TRUE)
[17:00:31.437]     }
[17:00:31.437]     ...future.frame <- base::sys.nframe()
[17:00:31.437]     ...future.conditions <- base::list()
[17:00:31.437]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.437]     if (FALSE) {
[17:00:31.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.437]     }
[17:00:31.437]     ...future.result <- base::tryCatch({
[17:00:31.437]         base::withCallingHandlers({
[17:00:31.437]             ...future.value <- base::withVisible(base::local({
[17:00:31.437]                 withCallingHandlers({
[17:00:31.437]                   {
[17:00:31.437]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.437]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.437]                       ...future.globals.maxSize)) {
[17:00:31.437]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.437]                       on.exit(options(oopts), add = TRUE)
[17:00:31.437]                     }
[17:00:31.437]                     {
[17:00:31.437]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.437]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.437]                         USE.NAMES = FALSE)
[17:00:31.437]                       do.call(mapply, args = args)
[17:00:31.437]                     }
[17:00:31.437]                   }
[17:00:31.437]                 }, immediateCondition = function(cond) {
[17:00:31.437]                   save_rds <- function (object, pathname, ...) 
[17:00:31.437]                   {
[17:00:31.437]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.437]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.437]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.437]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.437]                         fi_tmp[["mtime"]])
[17:00:31.437]                     }
[17:00:31.437]                     tryCatch({
[17:00:31.437]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.437]                     }, error = function(ex) {
[17:00:31.437]                       msg <- conditionMessage(ex)
[17:00:31.437]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.437]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.437]                         fi_tmp[["mtime"]], msg)
[17:00:31.437]                       ex$message <- msg
[17:00:31.437]                       stop(ex)
[17:00:31.437]                     })
[17:00:31.437]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.437]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.437]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.437]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.437]                       fi <- file.info(pathname)
[17:00:31.437]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.437]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.437]                         fi[["size"]], fi[["mtime"]])
[17:00:31.437]                       stop(msg)
[17:00:31.437]                     }
[17:00:31.437]                     invisible(pathname)
[17:00:31.437]                   }
[17:00:31.437]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.437]                     rootPath = tempdir()) 
[17:00:31.437]                   {
[17:00:31.437]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.437]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.437]                       tmpdir = path, fileext = ".rds")
[17:00:31.437]                     save_rds(obj, file)
[17:00:31.437]                   }
[17:00:31.437]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.437]                   {
[17:00:31.437]                     inherits <- base::inherits
[17:00:31.437]                     invokeRestart <- base::invokeRestart
[17:00:31.437]                     is.null <- base::is.null
[17:00:31.437]                     muffled <- FALSE
[17:00:31.437]                     if (inherits(cond, "message")) {
[17:00:31.437]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.437]                       if (muffled) 
[17:00:31.437]                         invokeRestart("muffleMessage")
[17:00:31.437]                     }
[17:00:31.437]                     else if (inherits(cond, "warning")) {
[17:00:31.437]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.437]                       if (muffled) 
[17:00:31.437]                         invokeRestart("muffleWarning")
[17:00:31.437]                     }
[17:00:31.437]                     else if (inherits(cond, "condition")) {
[17:00:31.437]                       if (!is.null(pattern)) {
[17:00:31.437]                         computeRestarts <- base::computeRestarts
[17:00:31.437]                         grepl <- base::grepl
[17:00:31.437]                         restarts <- computeRestarts(cond)
[17:00:31.437]                         for (restart in restarts) {
[17:00:31.437]                           name <- restart$name
[17:00:31.437]                           if (is.null(name)) 
[17:00:31.437]                             next
[17:00:31.437]                           if (!grepl(pattern, name)) 
[17:00:31.437]                             next
[17:00:31.437]                           invokeRestart(restart)
[17:00:31.437]                           muffled <- TRUE
[17:00:31.437]                           break
[17:00:31.437]                         }
[17:00:31.437]                       }
[17:00:31.437]                     }
[17:00:31.437]                     invisible(muffled)
[17:00:31.437]                   }
[17:00:31.437]                   muffleCondition(cond)
[17:00:31.437]                 })
[17:00:31.437]             }))
[17:00:31.437]             future::FutureResult(value = ...future.value$value, 
[17:00:31.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.437]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.437]                     ...future.globalenv.names))
[17:00:31.437]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.437]         }, condition = base::local({
[17:00:31.437]             c <- base::c
[17:00:31.437]             inherits <- base::inherits
[17:00:31.437]             invokeRestart <- base::invokeRestart
[17:00:31.437]             length <- base::length
[17:00:31.437]             list <- base::list
[17:00:31.437]             seq.int <- base::seq.int
[17:00:31.437]             signalCondition <- base::signalCondition
[17:00:31.437]             sys.calls <- base::sys.calls
[17:00:31.437]             `[[` <- base::`[[`
[17:00:31.437]             `+` <- base::`+`
[17:00:31.437]             `<<-` <- base::`<<-`
[17:00:31.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.437]                   3L)]
[17:00:31.437]             }
[17:00:31.437]             function(cond) {
[17:00:31.437]                 is_error <- inherits(cond, "error")
[17:00:31.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.437]                   NULL)
[17:00:31.437]                 if (is_error) {
[17:00:31.437]                   sessionInformation <- function() {
[17:00:31.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.437]                       search = base::search(), system = base::Sys.info())
[17:00:31.437]                   }
[17:00:31.437]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.437]                     cond$call), session = sessionInformation(), 
[17:00:31.437]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.437]                   signalCondition(cond)
[17:00:31.437]                 }
[17:00:31.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.437]                 "immediateCondition"))) {
[17:00:31.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.437]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.437]                   if (TRUE && !signal) {
[17:00:31.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.437]                     {
[17:00:31.437]                       inherits <- base::inherits
[17:00:31.437]                       invokeRestart <- base::invokeRestart
[17:00:31.437]                       is.null <- base::is.null
[17:00:31.437]                       muffled <- FALSE
[17:00:31.437]                       if (inherits(cond, "message")) {
[17:00:31.437]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.437]                         if (muffled) 
[17:00:31.437]                           invokeRestart("muffleMessage")
[17:00:31.437]                       }
[17:00:31.437]                       else if (inherits(cond, "warning")) {
[17:00:31.437]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.437]                         if (muffled) 
[17:00:31.437]                           invokeRestart("muffleWarning")
[17:00:31.437]                       }
[17:00:31.437]                       else if (inherits(cond, "condition")) {
[17:00:31.437]                         if (!is.null(pattern)) {
[17:00:31.437]                           computeRestarts <- base::computeRestarts
[17:00:31.437]                           grepl <- base::grepl
[17:00:31.437]                           restarts <- computeRestarts(cond)
[17:00:31.437]                           for (restart in restarts) {
[17:00:31.437]                             name <- restart$name
[17:00:31.437]                             if (is.null(name)) 
[17:00:31.437]                               next
[17:00:31.437]                             if (!grepl(pattern, name)) 
[17:00:31.437]                               next
[17:00:31.437]                             invokeRestart(restart)
[17:00:31.437]                             muffled <- TRUE
[17:00:31.437]                             break
[17:00:31.437]                           }
[17:00:31.437]                         }
[17:00:31.437]                       }
[17:00:31.437]                       invisible(muffled)
[17:00:31.437]                     }
[17:00:31.437]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.437]                   }
[17:00:31.437]                 }
[17:00:31.437]                 else {
[17:00:31.437]                   if (TRUE) {
[17:00:31.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.437]                     {
[17:00:31.437]                       inherits <- base::inherits
[17:00:31.437]                       invokeRestart <- base::invokeRestart
[17:00:31.437]                       is.null <- base::is.null
[17:00:31.437]                       muffled <- FALSE
[17:00:31.437]                       if (inherits(cond, "message")) {
[17:00:31.437]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.437]                         if (muffled) 
[17:00:31.437]                           invokeRestart("muffleMessage")
[17:00:31.437]                       }
[17:00:31.437]                       else if (inherits(cond, "warning")) {
[17:00:31.437]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.437]                         if (muffled) 
[17:00:31.437]                           invokeRestart("muffleWarning")
[17:00:31.437]                       }
[17:00:31.437]                       else if (inherits(cond, "condition")) {
[17:00:31.437]                         if (!is.null(pattern)) {
[17:00:31.437]                           computeRestarts <- base::computeRestarts
[17:00:31.437]                           grepl <- base::grepl
[17:00:31.437]                           restarts <- computeRestarts(cond)
[17:00:31.437]                           for (restart in restarts) {
[17:00:31.437]                             name <- restart$name
[17:00:31.437]                             if (is.null(name)) 
[17:00:31.437]                               next
[17:00:31.437]                             if (!grepl(pattern, name)) 
[17:00:31.437]                               next
[17:00:31.437]                             invokeRestart(restart)
[17:00:31.437]                             muffled <- TRUE
[17:00:31.437]                             break
[17:00:31.437]                           }
[17:00:31.437]                         }
[17:00:31.437]                       }
[17:00:31.437]                       invisible(muffled)
[17:00:31.437]                     }
[17:00:31.437]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.437]                   }
[17:00:31.437]                 }
[17:00:31.437]             }
[17:00:31.437]         }))
[17:00:31.437]     }, error = function(ex) {
[17:00:31.437]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.437]                 ...future.rng), started = ...future.startTime, 
[17:00:31.437]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.437]             version = "1.8"), class = "FutureResult")
[17:00:31.437]     }, finally = {
[17:00:31.437]         if (!identical(...future.workdir, getwd())) 
[17:00:31.437]             setwd(...future.workdir)
[17:00:31.437]         {
[17:00:31.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.437]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.437]             }
[17:00:31.437]             base::options(...future.oldOptions)
[17:00:31.437]             if (.Platform$OS.type == "windows") {
[17:00:31.437]                 old_names <- names(...future.oldEnvVars)
[17:00:31.437]                 envs <- base::Sys.getenv()
[17:00:31.437]                 names <- names(envs)
[17:00:31.437]                 common <- intersect(names, old_names)
[17:00:31.437]                 added <- setdiff(names, old_names)
[17:00:31.437]                 removed <- setdiff(old_names, names)
[17:00:31.437]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.437]                   envs[common]]
[17:00:31.437]                 NAMES <- toupper(changed)
[17:00:31.437]                 args <- list()
[17:00:31.437]                 for (kk in seq_along(NAMES)) {
[17:00:31.437]                   name <- changed[[kk]]
[17:00:31.437]                   NAME <- NAMES[[kk]]
[17:00:31.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.437]                     next
[17:00:31.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.437]                 }
[17:00:31.437]                 NAMES <- toupper(added)
[17:00:31.437]                 for (kk in seq_along(NAMES)) {
[17:00:31.437]                   name <- added[[kk]]
[17:00:31.437]                   NAME <- NAMES[[kk]]
[17:00:31.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.437]                     next
[17:00:31.437]                   args[[name]] <- ""
[17:00:31.437]                 }
[17:00:31.437]                 NAMES <- toupper(removed)
[17:00:31.437]                 for (kk in seq_along(NAMES)) {
[17:00:31.437]                   name <- removed[[kk]]
[17:00:31.437]                   NAME <- NAMES[[kk]]
[17:00:31.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.437]                     next
[17:00:31.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.437]                 }
[17:00:31.437]                 if (length(args) > 0) 
[17:00:31.437]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.437]             }
[17:00:31.437]             else {
[17:00:31.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.437]             }
[17:00:31.437]             {
[17:00:31.437]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.437]                   0L) {
[17:00:31.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.437]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.437]                   base::options(opts)
[17:00:31.437]                 }
[17:00:31.437]                 {
[17:00:31.437]                   {
[17:00:31.437]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.437]                     NULL
[17:00:31.437]                   }
[17:00:31.437]                   options(future.plan = NULL)
[17:00:31.437]                   if (is.na(NA_character_)) 
[17:00:31.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.437]                     .init = FALSE)
[17:00:31.437]                 }
[17:00:31.437]             }
[17:00:31.437]         }
[17:00:31.437]     })
[17:00:31.437]     if (TRUE) {
[17:00:31.437]         base::sink(type = "output", split = FALSE)
[17:00:31.437]         if (TRUE) {
[17:00:31.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.437]         }
[17:00:31.437]         else {
[17:00:31.437]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.437]         }
[17:00:31.437]         base::close(...future.stdout)
[17:00:31.437]         ...future.stdout <- NULL
[17:00:31.437]     }
[17:00:31.437]     ...future.result$conditions <- ...future.conditions
[17:00:31.437]     ...future.result$finished <- base::Sys.time()
[17:00:31.437]     ...future.result
[17:00:31.437] }
[17:00:31.441] assign_globals() ...
[17:00:31.441] List of 5
[17:00:31.441]  $ ...future.FUN            :function (x, w, ...)  
[17:00:31.441]  $ MoreArgs                 : NULL
[17:00:31.441]  $ ...future.elements_ii    :List of 2
[17:00:31.441]   ..$ :List of 3
[17:00:31.441]   .. ..$ : num [1:10] 0.153 0.0193 0.3096 0.73 0.7977 ...
[17:00:31.441]   .. ..$ : num [1:10] 0.579439 0.254527 0.278429 0.371244 0.000841 ...
[17:00:31.441]   .. ..$ : num [1:10] 0.612 0.225 0.434 0.455 0.708 ...
[17:00:31.441]   ..$ :List of 3
[17:00:31.441]   .. ..$ : num [1:10] 10 7 8 9 8 5 2 10 5 4
[17:00:31.441]   .. ..$ : num [1:10] 7 3 5 10 2 6 10 5 2 6
[17:00:31.441]   .. ..$ : num [1:10] 11 6 4 7 10 6 4 6 4 6
[17:00:31.441]  $ ...future.seeds_ii       : NULL
[17:00:31.441]  $ ...future.globals.maxSize: NULL
[17:00:31.441]  - attr(*, "where")=List of 5
[17:00:31.441]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.441]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.441]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.441]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.441]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.441]  - attr(*, "resolved")= logi FALSE
[17:00:31.441]  - attr(*, "total_size")= num 2472
[17:00:31.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.441]  - attr(*, "already-done")= logi TRUE
[17:00:31.451] - copied ‘...future.FUN’ to environment
[17:00:31.451] - copied ‘MoreArgs’ to environment
[17:00:31.451] - copied ‘...future.elements_ii’ to environment
[17:00:31.451] - copied ‘...future.seeds_ii’ to environment
[17:00:31.451] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.452] assign_globals() ... done
[17:00:31.452] requestCore(): workers = 2
[17:00:31.454] MulticoreFuture started
[17:00:31.455] - Launch lazy future ... done
[17:00:31.455] run() for ‘MulticoreFuture’ ... done
[17:00:31.455] Created future:
[17:00:31.456] plan(): Setting new future strategy stack:
[17:00:31.456] List of future strategies:
[17:00:31.456] 1. sequential:
[17:00:31.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.456]    - tweaked: FALSE
[17:00:31.456]    - call: NULL
[17:00:31.457] plan(): nbrOfWorkers() = 1
[17:00:31.459] plan(): Setting new future strategy stack:
[17:00:31.459] List of future strategies:
[17:00:31.459] 1. multicore:
[17:00:31.459]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.459]    - tweaked: FALSE
[17:00:31.459]    - call: plan(strategy)
[17:00:31.465] plan(): nbrOfWorkers() = 2
[17:00:31.455] MulticoreFuture:
[17:00:31.455] Label: ‘future_Map-2’
[17:00:31.455] Expression:
[17:00:31.455] {
[17:00:31.455]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.455]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.455]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.455]         on.exit(options(oopts), add = TRUE)
[17:00:31.455]     }
[17:00:31.455]     {
[17:00:31.455]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.455]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.455]         do.call(mapply, args = args)
[17:00:31.455]     }
[17:00:31.455] }
[17:00:31.455] Lazy evaluation: FALSE
[17:00:31.455] Asynchronous evaluation: TRUE
[17:00:31.455] Local evaluation: TRUE
[17:00:31.455] Environment: R_GlobalEnv
[17:00:31.455] Capture standard output: TRUE
[17:00:31.455] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.455] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.455] Packages: 1 packages (‘stats’)
[17:00:31.455] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:31.455] Resolved: TRUE
[17:00:31.455] Value: <not collected>
[17:00:31.455] Conditions captured: <none>
[17:00:31.455] Early signaling: FALSE
[17:00:31.455] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.455] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.466] Chunk #2 of 2 ... DONE
[17:00:31.466] Launching 2 futures (chunks) ... DONE
[17:00:31.466] Resolving 2 futures (chunks) ...
[17:00:31.466] resolve() on list ...
[17:00:31.466]  recursive: 0
[17:00:31.467]  length: 2
[17:00:31.467] 
[17:00:31.467] Future #1
[17:00:31.467] result() for MulticoreFuture ...
[17:00:31.468] result() for MulticoreFuture ...
[17:00:31.468] result() for MulticoreFuture ... done
[17:00:31.469] result() for MulticoreFuture ... done
[17:00:31.469] result() for MulticoreFuture ...
[17:00:31.469] result() for MulticoreFuture ... done
[17:00:31.469] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:31.469] - nx: 2
[17:00:31.469] - relay: TRUE
[17:00:31.470] - stdout: TRUE
[17:00:31.470] - signal: TRUE
[17:00:31.470] - resignal: FALSE
[17:00:31.470] - force: TRUE
[17:00:31.470] - relayed: [n=2] FALSE, FALSE
[17:00:31.471] - queued futures: [n=2] FALSE, FALSE
[17:00:31.471]  - until=1
[17:00:31.471]  - relaying element #1
[17:00:31.471] result() for MulticoreFuture ...
[17:00:31.471] result() for MulticoreFuture ... done
[17:00:31.472] result() for MulticoreFuture ...
[17:00:31.472] result() for MulticoreFuture ... done
[17:00:31.472] result() for MulticoreFuture ...
[17:00:31.472] result() for MulticoreFuture ... done
[17:00:31.473] result() for MulticoreFuture ...
[17:00:31.473] result() for MulticoreFuture ... done
[17:00:31.473] - relayed: [n=2] TRUE, FALSE
[17:00:31.473] - queued futures: [n=2] TRUE, FALSE
[17:00:31.473] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:31.474]  length: 1 (resolved future 1)
[17:00:31.474] Future #2
[17:00:31.474] result() for MulticoreFuture ...
[17:00:31.480] result() for MulticoreFuture ...
[17:00:31.480] result() for MulticoreFuture ... done
[17:00:31.480] result() for MulticoreFuture ... done
[17:00:31.481] result() for MulticoreFuture ...
[17:00:31.481] result() for MulticoreFuture ... done
[17:00:31.481] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:31.482] - nx: 2
[17:00:31.482] - relay: TRUE
[17:00:31.482] - stdout: TRUE
[17:00:31.482] - signal: TRUE
[17:00:31.482] - resignal: FALSE
[17:00:31.482] - force: TRUE
[17:00:31.483] - relayed: [n=2] TRUE, FALSE
[17:00:31.483] - queued futures: [n=2] TRUE, FALSE
[17:00:31.483]  - until=2
[17:00:31.483]  - relaying element #2
[17:00:31.483] result() for MulticoreFuture ...
[17:00:31.483] result() for MulticoreFuture ... done
[17:00:31.484] result() for MulticoreFuture ...
[17:00:31.484] result() for MulticoreFuture ... done
[17:00:31.484] result() for MulticoreFuture ...
[17:00:31.484] result() for MulticoreFuture ... done
[17:00:31.484] result() for MulticoreFuture ...
[17:00:31.484] result() for MulticoreFuture ... done
[17:00:31.485] - relayed: [n=2] TRUE, TRUE
[17:00:31.485] - queued futures: [n=2] TRUE, TRUE
[17:00:31.485] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:31.485]  length: 0 (resolved future 2)
[17:00:31.485] Relaying remaining futures
[17:00:31.485] signalConditionsASAP(NULL, pos=0) ...
[17:00:31.486] - nx: 2
[17:00:31.486] - relay: TRUE
[17:00:31.486] - stdout: TRUE
[17:00:31.486] - signal: TRUE
[17:00:31.486] - resignal: FALSE
[17:00:31.486] - force: TRUE
[17:00:31.486] - relayed: [n=2] TRUE, TRUE
[17:00:31.486] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:31.487] - relayed: [n=2] TRUE, TRUE
[17:00:31.487] - queued futures: [n=2] TRUE, TRUE
[17:00:31.487] signalConditionsASAP(NULL, pos=0) ... done
[17:00:31.487] resolve() on list ... DONE
[17:00:31.487] result() for MulticoreFuture ...
[17:00:31.487] result() for MulticoreFuture ... done
[17:00:31.488] result() for MulticoreFuture ...
[17:00:31.488] result() for MulticoreFuture ... done
[17:00:31.488] result() for MulticoreFuture ...
[17:00:31.488] result() for MulticoreFuture ... done
[17:00:31.488] result() for MulticoreFuture ...
[17:00:31.488] result() for MulticoreFuture ... done
[17:00:31.488]  - Number of value chunks collected: 2
[17:00:31.489] Resolving 2 futures (chunks) ... DONE
[17:00:31.489] Reducing values from 2 chunks ...
[17:00:31.489]  - Number of values collected after concatenation: 5
[17:00:31.489]  - Number of values expected: 5
[17:00:31.489] Reducing values from 2 chunks ... DONE
[17:00:31.489] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[17:00:31.491] future_mapply() ...
[17:00:31.496] Number of chunks: 2
[17:00:31.496] getGlobalsAndPackagesXApply() ...
[17:00:31.496]  - future.globals: TRUE
[17:00:31.496] getGlobalsAndPackages() ...
[17:00:31.496] Searching for globals...
[17:00:31.497] - globals found: [1] ‘FUN’
[17:00:31.497] Searching for globals ... DONE
[17:00:31.497] Resolving globals: FALSE
[17:00:31.497] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:31.498] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:31.498] - globals: [1] ‘FUN’
[17:00:31.498] 
[17:00:31.498] getGlobalsAndPackages() ... DONE
[17:00:31.498]  - globals found/used: [n=1] ‘FUN’
[17:00:31.498]  - needed namespaces: [n=0] 
[17:00:31.498] Finding globals ... DONE
[17:00:31.499] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:31.499] List of 2
[17:00:31.499]  $ ...future.FUN:function (e1, e2)  
[17:00:31.499]  $ MoreArgs     : NULL
[17:00:31.499]  - attr(*, "where")=List of 2
[17:00:31.499]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:31.499]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:31.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.499]  - attr(*, "resolved")= logi FALSE
[17:00:31.499]  - attr(*, "total_size")= num NA
[17:00:31.502] Packages to be attached in all futures: [n=0] 
[17:00:31.502] getGlobalsAndPackagesXApply() ... DONE
[17:00:31.502] Number of futures (= number of chunks): 2
[17:00:31.502] Launching 2 futures (chunks) ...
[17:00:31.502] Chunk #1 of 2 ...
[17:00:31.502]  - Finding globals in '...' for chunk #1 ...
[17:00:31.502] getGlobalsAndPackages() ...
[17:00:31.502] Searching for globals...
[17:00:31.503] 
[17:00:31.503] Searching for globals ... DONE
[17:00:31.503] - globals: [0] <none>
[17:00:31.503] getGlobalsAndPackages() ... DONE
[17:00:31.503]    + additional globals found: [n=0] 
[17:00:31.503]    + additional namespaces needed: [n=0] 
[17:00:31.503]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:31.503]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.504]  - seeds: <none>
[17:00:31.504]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.504] getGlobalsAndPackages() ...
[17:00:31.504] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.504] Resolving globals: FALSE
[17:00:31.504] The total size of the 5 globals is 168 bytes (168 bytes)
[17:00:31.505] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:31.505] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.505] 
[17:00:31.505] getGlobalsAndPackages() ... DONE
[17:00:31.506] run() for ‘Future’ ...
[17:00:31.506] - state: ‘created’
[17:00:31.506] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.513] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.513] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.513]   - Field: ‘label’
[17:00:31.513]   - Field: ‘local’
[17:00:31.514]   - Field: ‘owner’
[17:00:31.514]   - Field: ‘envir’
[17:00:31.514]   - Field: ‘workers’
[17:00:31.514]   - Field: ‘packages’
[17:00:31.514]   - Field: ‘gc’
[17:00:31.514]   - Field: ‘job’
[17:00:31.514]   - Field: ‘conditions’
[17:00:31.514]   - Field: ‘expr’
[17:00:31.515]   - Field: ‘uuid’
[17:00:31.515]   - Field: ‘seed’
[17:00:31.515]   - Field: ‘version’
[17:00:31.515]   - Field: ‘result’
[17:00:31.515]   - Field: ‘asynchronous’
[17:00:31.515]   - Field: ‘calls’
[17:00:31.515]   - Field: ‘globals’
[17:00:31.515]   - Field: ‘stdout’
[17:00:31.516]   - Field: ‘earlySignal’
[17:00:31.516]   - Field: ‘lazy’
[17:00:31.516]   - Field: ‘state’
[17:00:31.516] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.516] - Launch lazy future ...
[17:00:31.516] Packages needed by the future expression (n = 0): <none>
[17:00:31.517] Packages needed by future strategies (n = 0): <none>
[17:00:31.517] {
[17:00:31.517]     {
[17:00:31.517]         {
[17:00:31.517]             ...future.startTime <- base::Sys.time()
[17:00:31.517]             {
[17:00:31.517]                 {
[17:00:31.517]                   {
[17:00:31.517]                     {
[17:00:31.517]                       base::local({
[17:00:31.517]                         has_future <- base::requireNamespace("future", 
[17:00:31.517]                           quietly = TRUE)
[17:00:31.517]                         if (has_future) {
[17:00:31.517]                           ns <- base::getNamespace("future")
[17:00:31.517]                           version <- ns[[".package"]][["version"]]
[17:00:31.517]                           if (is.null(version)) 
[17:00:31.517]                             version <- utils::packageVersion("future")
[17:00:31.517]                         }
[17:00:31.517]                         else {
[17:00:31.517]                           version <- NULL
[17:00:31.517]                         }
[17:00:31.517]                         if (!has_future || version < "1.8.0") {
[17:00:31.517]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.517]                             "", base::R.version$version.string), 
[17:00:31.517]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:31.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:31.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.517]                               "release", "version")], collapse = " "), 
[17:00:31.517]                             hostname = base::Sys.info()[["nodename"]])
[17:00:31.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.517]                             info)
[17:00:31.517]                           info <- base::paste(info, collapse = "; ")
[17:00:31.517]                           if (!has_future) {
[17:00:31.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.517]                               info)
[17:00:31.517]                           }
[17:00:31.517]                           else {
[17:00:31.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.517]                               info, version)
[17:00:31.517]                           }
[17:00:31.517]                           base::stop(msg)
[17:00:31.517]                         }
[17:00:31.517]                       })
[17:00:31.517]                     }
[17:00:31.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.517]                     base::options(mc.cores = 1L)
[17:00:31.517]                   }
[17:00:31.517]                   ...future.strategy.old <- future::plan("list")
[17:00:31.517]                   options(future.plan = NULL)
[17:00:31.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.517]                 }
[17:00:31.517]                 ...future.workdir <- getwd()
[17:00:31.517]             }
[17:00:31.517]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.517]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.517]         }
[17:00:31.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.517]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.517]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.517]             base::names(...future.oldOptions))
[17:00:31.517]     }
[17:00:31.517]     if (FALSE) {
[17:00:31.517]     }
[17:00:31.517]     else {
[17:00:31.517]         if (TRUE) {
[17:00:31.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.517]                 open = "w")
[17:00:31.517]         }
[17:00:31.517]         else {
[17:00:31.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.517]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.517]         }
[17:00:31.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.517]             base::sink(type = "output", split = FALSE)
[17:00:31.517]             base::close(...future.stdout)
[17:00:31.517]         }, add = TRUE)
[17:00:31.517]     }
[17:00:31.517]     ...future.frame <- base::sys.nframe()
[17:00:31.517]     ...future.conditions <- base::list()
[17:00:31.517]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.517]     if (FALSE) {
[17:00:31.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.517]     }
[17:00:31.517]     ...future.result <- base::tryCatch({
[17:00:31.517]         base::withCallingHandlers({
[17:00:31.517]             ...future.value <- base::withVisible(base::local({
[17:00:31.517]                 withCallingHandlers({
[17:00:31.517]                   {
[17:00:31.517]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.517]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.517]                       ...future.globals.maxSize)) {
[17:00:31.517]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.517]                       on.exit(options(oopts), add = TRUE)
[17:00:31.517]                     }
[17:00:31.517]                     {
[17:00:31.517]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.517]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.517]                         USE.NAMES = FALSE)
[17:00:31.517]                       do.call(mapply, args = args)
[17:00:31.517]                     }
[17:00:31.517]                   }
[17:00:31.517]                 }, immediateCondition = function(cond) {
[17:00:31.517]                   save_rds <- function (object, pathname, ...) 
[17:00:31.517]                   {
[17:00:31.517]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.517]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.517]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.517]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.517]                         fi_tmp[["mtime"]])
[17:00:31.517]                     }
[17:00:31.517]                     tryCatch({
[17:00:31.517]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.517]                     }, error = function(ex) {
[17:00:31.517]                       msg <- conditionMessage(ex)
[17:00:31.517]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.517]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.517]                         fi_tmp[["mtime"]], msg)
[17:00:31.517]                       ex$message <- msg
[17:00:31.517]                       stop(ex)
[17:00:31.517]                     })
[17:00:31.517]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.517]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.517]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.517]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.517]                       fi <- file.info(pathname)
[17:00:31.517]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.517]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.517]                         fi[["size"]], fi[["mtime"]])
[17:00:31.517]                       stop(msg)
[17:00:31.517]                     }
[17:00:31.517]                     invisible(pathname)
[17:00:31.517]                   }
[17:00:31.517]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.517]                     rootPath = tempdir()) 
[17:00:31.517]                   {
[17:00:31.517]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.517]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.517]                       tmpdir = path, fileext = ".rds")
[17:00:31.517]                     save_rds(obj, file)
[17:00:31.517]                   }
[17:00:31.517]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.517]                   {
[17:00:31.517]                     inherits <- base::inherits
[17:00:31.517]                     invokeRestart <- base::invokeRestart
[17:00:31.517]                     is.null <- base::is.null
[17:00:31.517]                     muffled <- FALSE
[17:00:31.517]                     if (inherits(cond, "message")) {
[17:00:31.517]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.517]                       if (muffled) 
[17:00:31.517]                         invokeRestart("muffleMessage")
[17:00:31.517]                     }
[17:00:31.517]                     else if (inherits(cond, "warning")) {
[17:00:31.517]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.517]                       if (muffled) 
[17:00:31.517]                         invokeRestart("muffleWarning")
[17:00:31.517]                     }
[17:00:31.517]                     else if (inherits(cond, "condition")) {
[17:00:31.517]                       if (!is.null(pattern)) {
[17:00:31.517]                         computeRestarts <- base::computeRestarts
[17:00:31.517]                         grepl <- base::grepl
[17:00:31.517]                         restarts <- computeRestarts(cond)
[17:00:31.517]                         for (restart in restarts) {
[17:00:31.517]                           name <- restart$name
[17:00:31.517]                           if (is.null(name)) 
[17:00:31.517]                             next
[17:00:31.517]                           if (!grepl(pattern, name)) 
[17:00:31.517]                             next
[17:00:31.517]                           invokeRestart(restart)
[17:00:31.517]                           muffled <- TRUE
[17:00:31.517]                           break
[17:00:31.517]                         }
[17:00:31.517]                       }
[17:00:31.517]                     }
[17:00:31.517]                     invisible(muffled)
[17:00:31.517]                   }
[17:00:31.517]                   muffleCondition(cond)
[17:00:31.517]                 })
[17:00:31.517]             }))
[17:00:31.517]             future::FutureResult(value = ...future.value$value, 
[17:00:31.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.517]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.517]                     ...future.globalenv.names))
[17:00:31.517]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.517]         }, condition = base::local({
[17:00:31.517]             c <- base::c
[17:00:31.517]             inherits <- base::inherits
[17:00:31.517]             invokeRestart <- base::invokeRestart
[17:00:31.517]             length <- base::length
[17:00:31.517]             list <- base::list
[17:00:31.517]             seq.int <- base::seq.int
[17:00:31.517]             signalCondition <- base::signalCondition
[17:00:31.517]             sys.calls <- base::sys.calls
[17:00:31.517]             `[[` <- base::`[[`
[17:00:31.517]             `+` <- base::`+`
[17:00:31.517]             `<<-` <- base::`<<-`
[17:00:31.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.517]                   3L)]
[17:00:31.517]             }
[17:00:31.517]             function(cond) {
[17:00:31.517]                 is_error <- inherits(cond, "error")
[17:00:31.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.517]                   NULL)
[17:00:31.517]                 if (is_error) {
[17:00:31.517]                   sessionInformation <- function() {
[17:00:31.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.517]                       search = base::search(), system = base::Sys.info())
[17:00:31.517]                   }
[17:00:31.517]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.517]                     cond$call), session = sessionInformation(), 
[17:00:31.517]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.517]                   signalCondition(cond)
[17:00:31.517]                 }
[17:00:31.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.517]                 "immediateCondition"))) {
[17:00:31.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.517]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.517]                   if (TRUE && !signal) {
[17:00:31.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.517]                     {
[17:00:31.517]                       inherits <- base::inherits
[17:00:31.517]                       invokeRestart <- base::invokeRestart
[17:00:31.517]                       is.null <- base::is.null
[17:00:31.517]                       muffled <- FALSE
[17:00:31.517]                       if (inherits(cond, "message")) {
[17:00:31.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.517]                         if (muffled) 
[17:00:31.517]                           invokeRestart("muffleMessage")
[17:00:31.517]                       }
[17:00:31.517]                       else if (inherits(cond, "warning")) {
[17:00:31.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.517]                         if (muffled) 
[17:00:31.517]                           invokeRestart("muffleWarning")
[17:00:31.517]                       }
[17:00:31.517]                       else if (inherits(cond, "condition")) {
[17:00:31.517]                         if (!is.null(pattern)) {
[17:00:31.517]                           computeRestarts <- base::computeRestarts
[17:00:31.517]                           grepl <- base::grepl
[17:00:31.517]                           restarts <- computeRestarts(cond)
[17:00:31.517]                           for (restart in restarts) {
[17:00:31.517]                             name <- restart$name
[17:00:31.517]                             if (is.null(name)) 
[17:00:31.517]                               next
[17:00:31.517]                             if (!grepl(pattern, name)) 
[17:00:31.517]                               next
[17:00:31.517]                             invokeRestart(restart)
[17:00:31.517]                             muffled <- TRUE
[17:00:31.517]                             break
[17:00:31.517]                           }
[17:00:31.517]                         }
[17:00:31.517]                       }
[17:00:31.517]                       invisible(muffled)
[17:00:31.517]                     }
[17:00:31.517]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.517]                   }
[17:00:31.517]                 }
[17:00:31.517]                 else {
[17:00:31.517]                   if (TRUE) {
[17:00:31.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.517]                     {
[17:00:31.517]                       inherits <- base::inherits
[17:00:31.517]                       invokeRestart <- base::invokeRestart
[17:00:31.517]                       is.null <- base::is.null
[17:00:31.517]                       muffled <- FALSE
[17:00:31.517]                       if (inherits(cond, "message")) {
[17:00:31.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.517]                         if (muffled) 
[17:00:31.517]                           invokeRestart("muffleMessage")
[17:00:31.517]                       }
[17:00:31.517]                       else if (inherits(cond, "warning")) {
[17:00:31.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.517]                         if (muffled) 
[17:00:31.517]                           invokeRestart("muffleWarning")
[17:00:31.517]                       }
[17:00:31.517]                       else if (inherits(cond, "condition")) {
[17:00:31.517]                         if (!is.null(pattern)) {
[17:00:31.517]                           computeRestarts <- base::computeRestarts
[17:00:31.517]                           grepl <- base::grepl
[17:00:31.517]                           restarts <- computeRestarts(cond)
[17:00:31.517]                           for (restart in restarts) {
[17:00:31.517]                             name <- restart$name
[17:00:31.517]                             if (is.null(name)) 
[17:00:31.517]                               next
[17:00:31.517]                             if (!grepl(pattern, name)) 
[17:00:31.517]                               next
[17:00:31.517]                             invokeRestart(restart)
[17:00:31.517]                             muffled <- TRUE
[17:00:31.517]                             break
[17:00:31.517]                           }
[17:00:31.517]                         }
[17:00:31.517]                       }
[17:00:31.517]                       invisible(muffled)
[17:00:31.517]                     }
[17:00:31.517]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.517]                   }
[17:00:31.517]                 }
[17:00:31.517]             }
[17:00:31.517]         }))
[17:00:31.517]     }, error = function(ex) {
[17:00:31.517]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.517]                 ...future.rng), started = ...future.startTime, 
[17:00:31.517]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.517]             version = "1.8"), class = "FutureResult")
[17:00:31.517]     }, finally = {
[17:00:31.517]         if (!identical(...future.workdir, getwd())) 
[17:00:31.517]             setwd(...future.workdir)
[17:00:31.517]         {
[17:00:31.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.517]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.517]             }
[17:00:31.517]             base::options(...future.oldOptions)
[17:00:31.517]             if (.Platform$OS.type == "windows") {
[17:00:31.517]                 old_names <- names(...future.oldEnvVars)
[17:00:31.517]                 envs <- base::Sys.getenv()
[17:00:31.517]                 names <- names(envs)
[17:00:31.517]                 common <- intersect(names, old_names)
[17:00:31.517]                 added <- setdiff(names, old_names)
[17:00:31.517]                 removed <- setdiff(old_names, names)
[17:00:31.517]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.517]                   envs[common]]
[17:00:31.517]                 NAMES <- toupper(changed)
[17:00:31.517]                 args <- list()
[17:00:31.517]                 for (kk in seq_along(NAMES)) {
[17:00:31.517]                   name <- changed[[kk]]
[17:00:31.517]                   NAME <- NAMES[[kk]]
[17:00:31.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.517]                     next
[17:00:31.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.517]                 }
[17:00:31.517]                 NAMES <- toupper(added)
[17:00:31.517]                 for (kk in seq_along(NAMES)) {
[17:00:31.517]                   name <- added[[kk]]
[17:00:31.517]                   NAME <- NAMES[[kk]]
[17:00:31.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.517]                     next
[17:00:31.517]                   args[[name]] <- ""
[17:00:31.517]                 }
[17:00:31.517]                 NAMES <- toupper(removed)
[17:00:31.517]                 for (kk in seq_along(NAMES)) {
[17:00:31.517]                   name <- removed[[kk]]
[17:00:31.517]                   NAME <- NAMES[[kk]]
[17:00:31.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.517]                     next
[17:00:31.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.517]                 }
[17:00:31.517]                 if (length(args) > 0) 
[17:00:31.517]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.517]             }
[17:00:31.517]             else {
[17:00:31.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.517]             }
[17:00:31.517]             {
[17:00:31.517]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.517]                   0L) {
[17:00:31.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.517]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.517]                   base::options(opts)
[17:00:31.517]                 }
[17:00:31.517]                 {
[17:00:31.517]                   {
[17:00:31.517]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.517]                     NULL
[17:00:31.517]                   }
[17:00:31.517]                   options(future.plan = NULL)
[17:00:31.517]                   if (is.na(NA_character_)) 
[17:00:31.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.517]                     .init = FALSE)
[17:00:31.517]                 }
[17:00:31.517]             }
[17:00:31.517]         }
[17:00:31.517]     })
[17:00:31.517]     if (TRUE) {
[17:00:31.517]         base::sink(type = "output", split = FALSE)
[17:00:31.517]         if (TRUE) {
[17:00:31.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.517]         }
[17:00:31.517]         else {
[17:00:31.517]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.517]         }
[17:00:31.517]         base::close(...future.stdout)
[17:00:31.517]         ...future.stdout <- NULL
[17:00:31.517]     }
[17:00:31.517]     ...future.result$conditions <- ...future.conditions
[17:00:31.517]     ...future.result$finished <- base::Sys.time()
[17:00:31.517]     ...future.result
[17:00:31.517] }
[17:00:31.520] assign_globals() ...
[17:00:31.520] List of 5
[17:00:31.520]  $ ...future.FUN            :function (e1, e2)  
[17:00:31.520]  $ MoreArgs                 : NULL
[17:00:31.520]  $ ...future.elements_ii    :List of 2
[17:00:31.520]   ..$ :List of 1
[17:00:31.520]   .. ..$ : num 1
[17:00:31.520]   ..$ :List of 1
[17:00:31.520]   .. ..$ : int 1
[17:00:31.520]  $ ...future.seeds_ii       : NULL
[17:00:31.520]  $ ...future.globals.maxSize: NULL
[17:00:31.520]  - attr(*, "where")=List of 5
[17:00:31.520]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.520]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.520]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.520]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.520]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.520]  - attr(*, "resolved")= logi FALSE
[17:00:31.520]  - attr(*, "total_size")= num 168
[17:00:31.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.520]  - attr(*, "already-done")= logi TRUE
[17:00:31.525] - copied ‘...future.FUN’ to environment
[17:00:31.525] - copied ‘MoreArgs’ to environment
[17:00:31.526] - copied ‘...future.elements_ii’ to environment
[17:00:31.526] - copied ‘...future.seeds_ii’ to environment
[17:00:31.526] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.526] assign_globals() ... done
[17:00:31.526] requestCore(): workers = 2
[17:00:31.528] MulticoreFuture started
[17:00:31.529] - Launch lazy future ... done
[17:00:31.529] run() for ‘MulticoreFuture’ ... done
[17:00:31.529] Created future:
[17:00:31.529] plan(): Setting new future strategy stack:
[17:00:31.530] List of future strategies:
[17:00:31.530] 1. sequential:
[17:00:31.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.530]    - tweaked: FALSE
[17:00:31.530]    - call: NULL
[17:00:31.531] plan(): nbrOfWorkers() = 1
[17:00:31.533] plan(): Setting new future strategy stack:
[17:00:31.533] List of future strategies:
[17:00:31.533] 1. multicore:
[17:00:31.533]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.533]    - tweaked: FALSE
[17:00:31.533]    - call: plan(strategy)
[17:00:31.538] plan(): nbrOfWorkers() = 2
[17:00:31.529] MulticoreFuture:
[17:00:31.529] Label: ‘future_Map-1’
[17:00:31.529] Expression:
[17:00:31.529] {
[17:00:31.529]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.529]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.529]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.529]         on.exit(options(oopts), add = TRUE)
[17:00:31.529]     }
[17:00:31.529]     {
[17:00:31.529]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.529]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.529]         do.call(mapply, args = args)
[17:00:31.529]     }
[17:00:31.529] }
[17:00:31.529] Lazy evaluation: FALSE
[17:00:31.529] Asynchronous evaluation: TRUE
[17:00:31.529] Local evaluation: TRUE
[17:00:31.529] Environment: R_GlobalEnv
[17:00:31.529] Capture standard output: TRUE
[17:00:31.529] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.529] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.529] Packages: <none>
[17:00:31.529] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:31.529] Resolved: TRUE
[17:00:31.529] Value: <not collected>
[17:00:31.529] Conditions captured: <none>
[17:00:31.529] Early signaling: FALSE
[17:00:31.529] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.529] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.539] Chunk #1 of 2 ... DONE
[17:00:31.540] Chunk #2 of 2 ...
[17:00:31.540]  - Finding globals in '...' for chunk #2 ...
[17:00:31.540] getGlobalsAndPackages() ...
[17:00:31.540] Searching for globals...
[17:00:31.541] 
[17:00:31.541] Searching for globals ... DONE
[17:00:31.541] - globals: [0] <none>
[17:00:31.541] getGlobalsAndPackages() ... DONE
[17:00:31.541]    + additional globals found: [n=0] 
[17:00:31.541]    + additional namespaces needed: [n=0] 
[17:00:31.542]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:31.542]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.542]  - seeds: <none>
[17:00:31.542]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.542] getGlobalsAndPackages() ...
[17:00:31.542] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.543] Resolving globals: FALSE
[17:00:31.544] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:31.544] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:31.545] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.545] 
[17:00:31.545] getGlobalsAndPackages() ... DONE
[17:00:31.545] run() for ‘Future’ ...
[17:00:31.546] - state: ‘created’
[17:00:31.546] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.551] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.551] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.551]   - Field: ‘label’
[17:00:31.551]   - Field: ‘local’
[17:00:31.552]   - Field: ‘owner’
[17:00:31.552]   - Field: ‘envir’
[17:00:31.552]   - Field: ‘workers’
[17:00:31.556]   - Field: ‘packages’
[17:00:31.556]   - Field: ‘gc’
[17:00:31.557]   - Field: ‘job’
[17:00:31.557]   - Field: ‘conditions’
[17:00:31.557]   - Field: ‘expr’
[17:00:31.558]   - Field: ‘uuid’
[17:00:31.558]   - Field: ‘seed’
[17:00:31.558]   - Field: ‘version’
[17:00:31.559]   - Field: ‘result’
[17:00:31.559]   - Field: ‘asynchronous’
[17:00:31.559]   - Field: ‘calls’
[17:00:31.559]   - Field: ‘globals’
[17:00:31.560]   - Field: ‘stdout’
[17:00:31.560]   - Field: ‘earlySignal’
[17:00:31.560]   - Field: ‘lazy’
[17:00:31.560]   - Field: ‘state’
[17:00:31.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.561] - Launch lazy future ...
[17:00:31.562] Packages needed by the future expression (n = 0): <none>
[17:00:31.562] Packages needed by future strategies (n = 0): <none>
[17:00:31.563] {
[17:00:31.563]     {
[17:00:31.563]         {
[17:00:31.563]             ...future.startTime <- base::Sys.time()
[17:00:31.563]             {
[17:00:31.563]                 {
[17:00:31.563]                   {
[17:00:31.563]                     {
[17:00:31.563]                       base::local({
[17:00:31.563]                         has_future <- base::requireNamespace("future", 
[17:00:31.563]                           quietly = TRUE)
[17:00:31.563]                         if (has_future) {
[17:00:31.563]                           ns <- base::getNamespace("future")
[17:00:31.563]                           version <- ns[[".package"]][["version"]]
[17:00:31.563]                           if (is.null(version)) 
[17:00:31.563]                             version <- utils::packageVersion("future")
[17:00:31.563]                         }
[17:00:31.563]                         else {
[17:00:31.563]                           version <- NULL
[17:00:31.563]                         }
[17:00:31.563]                         if (!has_future || version < "1.8.0") {
[17:00:31.563]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.563]                             "", base::R.version$version.string), 
[17:00:31.563]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:31.563]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:31.563]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.563]                               "release", "version")], collapse = " "), 
[17:00:31.563]                             hostname = base::Sys.info()[["nodename"]])
[17:00:31.563]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.563]                             info)
[17:00:31.563]                           info <- base::paste(info, collapse = "; ")
[17:00:31.563]                           if (!has_future) {
[17:00:31.563]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.563]                               info)
[17:00:31.563]                           }
[17:00:31.563]                           else {
[17:00:31.563]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.563]                               info, version)
[17:00:31.563]                           }
[17:00:31.563]                           base::stop(msg)
[17:00:31.563]                         }
[17:00:31.563]                       })
[17:00:31.563]                     }
[17:00:31.563]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.563]                     base::options(mc.cores = 1L)
[17:00:31.563]                   }
[17:00:31.563]                   ...future.strategy.old <- future::plan("list")
[17:00:31.563]                   options(future.plan = NULL)
[17:00:31.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.563]                 }
[17:00:31.563]                 ...future.workdir <- getwd()
[17:00:31.563]             }
[17:00:31.563]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.563]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.563]         }
[17:00:31.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.563]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.563]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.563]             base::names(...future.oldOptions))
[17:00:31.563]     }
[17:00:31.563]     if (FALSE) {
[17:00:31.563]     }
[17:00:31.563]     else {
[17:00:31.563]         if (TRUE) {
[17:00:31.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.563]                 open = "w")
[17:00:31.563]         }
[17:00:31.563]         else {
[17:00:31.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.563]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.563]         }
[17:00:31.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.563]             base::sink(type = "output", split = FALSE)
[17:00:31.563]             base::close(...future.stdout)
[17:00:31.563]         }, add = TRUE)
[17:00:31.563]     }
[17:00:31.563]     ...future.frame <- base::sys.nframe()
[17:00:31.563]     ...future.conditions <- base::list()
[17:00:31.563]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.563]     if (FALSE) {
[17:00:31.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.563]     }
[17:00:31.563]     ...future.result <- base::tryCatch({
[17:00:31.563]         base::withCallingHandlers({
[17:00:31.563]             ...future.value <- base::withVisible(base::local({
[17:00:31.563]                 withCallingHandlers({
[17:00:31.563]                   {
[17:00:31.563]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.563]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.563]                       ...future.globals.maxSize)) {
[17:00:31.563]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.563]                       on.exit(options(oopts), add = TRUE)
[17:00:31.563]                     }
[17:00:31.563]                     {
[17:00:31.563]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.563]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.563]                         USE.NAMES = FALSE)
[17:00:31.563]                       do.call(mapply, args = args)
[17:00:31.563]                     }
[17:00:31.563]                   }
[17:00:31.563]                 }, immediateCondition = function(cond) {
[17:00:31.563]                   save_rds <- function (object, pathname, ...) 
[17:00:31.563]                   {
[17:00:31.563]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.563]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.563]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.563]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.563]                         fi_tmp[["mtime"]])
[17:00:31.563]                     }
[17:00:31.563]                     tryCatch({
[17:00:31.563]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.563]                     }, error = function(ex) {
[17:00:31.563]                       msg <- conditionMessage(ex)
[17:00:31.563]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.563]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.563]                         fi_tmp[["mtime"]], msg)
[17:00:31.563]                       ex$message <- msg
[17:00:31.563]                       stop(ex)
[17:00:31.563]                     })
[17:00:31.563]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.563]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.563]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.563]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.563]                       fi <- file.info(pathname)
[17:00:31.563]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.563]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.563]                         fi[["size"]], fi[["mtime"]])
[17:00:31.563]                       stop(msg)
[17:00:31.563]                     }
[17:00:31.563]                     invisible(pathname)
[17:00:31.563]                   }
[17:00:31.563]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.563]                     rootPath = tempdir()) 
[17:00:31.563]                   {
[17:00:31.563]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.563]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.563]                       tmpdir = path, fileext = ".rds")
[17:00:31.563]                     save_rds(obj, file)
[17:00:31.563]                   }
[17:00:31.563]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.563]                   {
[17:00:31.563]                     inherits <- base::inherits
[17:00:31.563]                     invokeRestart <- base::invokeRestart
[17:00:31.563]                     is.null <- base::is.null
[17:00:31.563]                     muffled <- FALSE
[17:00:31.563]                     if (inherits(cond, "message")) {
[17:00:31.563]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.563]                       if (muffled) 
[17:00:31.563]                         invokeRestart("muffleMessage")
[17:00:31.563]                     }
[17:00:31.563]                     else if (inherits(cond, "warning")) {
[17:00:31.563]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.563]                       if (muffled) 
[17:00:31.563]                         invokeRestart("muffleWarning")
[17:00:31.563]                     }
[17:00:31.563]                     else if (inherits(cond, "condition")) {
[17:00:31.563]                       if (!is.null(pattern)) {
[17:00:31.563]                         computeRestarts <- base::computeRestarts
[17:00:31.563]                         grepl <- base::grepl
[17:00:31.563]                         restarts <- computeRestarts(cond)
[17:00:31.563]                         for (restart in restarts) {
[17:00:31.563]                           name <- restart$name
[17:00:31.563]                           if (is.null(name)) 
[17:00:31.563]                             next
[17:00:31.563]                           if (!grepl(pattern, name)) 
[17:00:31.563]                             next
[17:00:31.563]                           invokeRestart(restart)
[17:00:31.563]                           muffled <- TRUE
[17:00:31.563]                           break
[17:00:31.563]                         }
[17:00:31.563]                       }
[17:00:31.563]                     }
[17:00:31.563]                     invisible(muffled)
[17:00:31.563]                   }
[17:00:31.563]                   muffleCondition(cond)
[17:00:31.563]                 })
[17:00:31.563]             }))
[17:00:31.563]             future::FutureResult(value = ...future.value$value, 
[17:00:31.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.563]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.563]                     ...future.globalenv.names))
[17:00:31.563]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.563]         }, condition = base::local({
[17:00:31.563]             c <- base::c
[17:00:31.563]             inherits <- base::inherits
[17:00:31.563]             invokeRestart <- base::invokeRestart
[17:00:31.563]             length <- base::length
[17:00:31.563]             list <- base::list
[17:00:31.563]             seq.int <- base::seq.int
[17:00:31.563]             signalCondition <- base::signalCondition
[17:00:31.563]             sys.calls <- base::sys.calls
[17:00:31.563]             `[[` <- base::`[[`
[17:00:31.563]             `+` <- base::`+`
[17:00:31.563]             `<<-` <- base::`<<-`
[17:00:31.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.563]                   3L)]
[17:00:31.563]             }
[17:00:31.563]             function(cond) {
[17:00:31.563]                 is_error <- inherits(cond, "error")
[17:00:31.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.563]                   NULL)
[17:00:31.563]                 if (is_error) {
[17:00:31.563]                   sessionInformation <- function() {
[17:00:31.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.563]                       search = base::search(), system = base::Sys.info())
[17:00:31.563]                   }
[17:00:31.563]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.563]                     cond$call), session = sessionInformation(), 
[17:00:31.563]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.563]                   signalCondition(cond)
[17:00:31.563]                 }
[17:00:31.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.563]                 "immediateCondition"))) {
[17:00:31.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.563]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.563]                   if (TRUE && !signal) {
[17:00:31.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.563]                     {
[17:00:31.563]                       inherits <- base::inherits
[17:00:31.563]                       invokeRestart <- base::invokeRestart
[17:00:31.563]                       is.null <- base::is.null
[17:00:31.563]                       muffled <- FALSE
[17:00:31.563]                       if (inherits(cond, "message")) {
[17:00:31.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.563]                         if (muffled) 
[17:00:31.563]                           invokeRestart("muffleMessage")
[17:00:31.563]                       }
[17:00:31.563]                       else if (inherits(cond, "warning")) {
[17:00:31.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.563]                         if (muffled) 
[17:00:31.563]                           invokeRestart("muffleWarning")
[17:00:31.563]                       }
[17:00:31.563]                       else if (inherits(cond, "condition")) {
[17:00:31.563]                         if (!is.null(pattern)) {
[17:00:31.563]                           computeRestarts <- base::computeRestarts
[17:00:31.563]                           grepl <- base::grepl
[17:00:31.563]                           restarts <- computeRestarts(cond)
[17:00:31.563]                           for (restart in restarts) {
[17:00:31.563]                             name <- restart$name
[17:00:31.563]                             if (is.null(name)) 
[17:00:31.563]                               next
[17:00:31.563]                             if (!grepl(pattern, name)) 
[17:00:31.563]                               next
[17:00:31.563]                             invokeRestart(restart)
[17:00:31.563]                             muffled <- TRUE
[17:00:31.563]                             break
[17:00:31.563]                           }
[17:00:31.563]                         }
[17:00:31.563]                       }
[17:00:31.563]                       invisible(muffled)
[17:00:31.563]                     }
[17:00:31.563]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.563]                   }
[17:00:31.563]                 }
[17:00:31.563]                 else {
[17:00:31.563]                   if (TRUE) {
[17:00:31.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.563]                     {
[17:00:31.563]                       inherits <- base::inherits
[17:00:31.563]                       invokeRestart <- base::invokeRestart
[17:00:31.563]                       is.null <- base::is.null
[17:00:31.563]                       muffled <- FALSE
[17:00:31.563]                       if (inherits(cond, "message")) {
[17:00:31.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.563]                         if (muffled) 
[17:00:31.563]                           invokeRestart("muffleMessage")
[17:00:31.563]                       }
[17:00:31.563]                       else if (inherits(cond, "warning")) {
[17:00:31.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.563]                         if (muffled) 
[17:00:31.563]                           invokeRestart("muffleWarning")
[17:00:31.563]                       }
[17:00:31.563]                       else if (inherits(cond, "condition")) {
[17:00:31.563]                         if (!is.null(pattern)) {
[17:00:31.563]                           computeRestarts <- base::computeRestarts
[17:00:31.563]                           grepl <- base::grepl
[17:00:31.563]                           restarts <- computeRestarts(cond)
[17:00:31.563]                           for (restart in restarts) {
[17:00:31.563]                             name <- restart$name
[17:00:31.563]                             if (is.null(name)) 
[17:00:31.563]                               next
[17:00:31.563]                             if (!grepl(pattern, name)) 
[17:00:31.563]                               next
[17:00:31.563]                             invokeRestart(restart)
[17:00:31.563]                             muffled <- TRUE
[17:00:31.563]                             break
[17:00:31.563]                           }
[17:00:31.563]                         }
[17:00:31.563]                       }
[17:00:31.563]                       invisible(muffled)
[17:00:31.563]                     }
[17:00:31.563]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.563]                   }
[17:00:31.563]                 }
[17:00:31.563]             }
[17:00:31.563]         }))
[17:00:31.563]     }, error = function(ex) {
[17:00:31.563]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.563]                 ...future.rng), started = ...future.startTime, 
[17:00:31.563]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.563]             version = "1.8"), class = "FutureResult")
[17:00:31.563]     }, finally = {
[17:00:31.563]         if (!identical(...future.workdir, getwd())) 
[17:00:31.563]             setwd(...future.workdir)
[17:00:31.563]         {
[17:00:31.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.563]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.563]             }
[17:00:31.563]             base::options(...future.oldOptions)
[17:00:31.563]             if (.Platform$OS.type == "windows") {
[17:00:31.563]                 old_names <- names(...future.oldEnvVars)
[17:00:31.563]                 envs <- base::Sys.getenv()
[17:00:31.563]                 names <- names(envs)
[17:00:31.563]                 common <- intersect(names, old_names)
[17:00:31.563]                 added <- setdiff(names, old_names)
[17:00:31.563]                 removed <- setdiff(old_names, names)
[17:00:31.563]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.563]                   envs[common]]
[17:00:31.563]                 NAMES <- toupper(changed)
[17:00:31.563]                 args <- list()
[17:00:31.563]                 for (kk in seq_along(NAMES)) {
[17:00:31.563]                   name <- changed[[kk]]
[17:00:31.563]                   NAME <- NAMES[[kk]]
[17:00:31.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.563]                     next
[17:00:31.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.563]                 }
[17:00:31.563]                 NAMES <- toupper(added)
[17:00:31.563]                 for (kk in seq_along(NAMES)) {
[17:00:31.563]                   name <- added[[kk]]
[17:00:31.563]                   NAME <- NAMES[[kk]]
[17:00:31.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.563]                     next
[17:00:31.563]                   args[[name]] <- ""
[17:00:31.563]                 }
[17:00:31.563]                 NAMES <- toupper(removed)
[17:00:31.563]                 for (kk in seq_along(NAMES)) {
[17:00:31.563]                   name <- removed[[kk]]
[17:00:31.563]                   NAME <- NAMES[[kk]]
[17:00:31.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.563]                     next
[17:00:31.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.563]                 }
[17:00:31.563]                 if (length(args) > 0) 
[17:00:31.563]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.563]             }
[17:00:31.563]             else {
[17:00:31.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.563]             }
[17:00:31.563]             {
[17:00:31.563]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.563]                   0L) {
[17:00:31.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.563]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.563]                   base::options(opts)
[17:00:31.563]                 }
[17:00:31.563]                 {
[17:00:31.563]                   {
[17:00:31.563]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.563]                     NULL
[17:00:31.563]                   }
[17:00:31.563]                   options(future.plan = NULL)
[17:00:31.563]                   if (is.na(NA_character_)) 
[17:00:31.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.563]                     .init = FALSE)
[17:00:31.563]                 }
[17:00:31.563]             }
[17:00:31.563]         }
[17:00:31.563]     })
[17:00:31.563]     if (TRUE) {
[17:00:31.563]         base::sink(type = "output", split = FALSE)
[17:00:31.563]         if (TRUE) {
[17:00:31.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.563]         }
[17:00:31.563]         else {
[17:00:31.563]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.563]         }
[17:00:31.563]         base::close(...future.stdout)
[17:00:31.563]         ...future.stdout <- NULL
[17:00:31.563]     }
[17:00:31.563]     ...future.result$conditions <- ...future.conditions
[17:00:31.563]     ...future.result$finished <- base::Sys.time()
[17:00:31.563]     ...future.result
[17:00:31.563] }
[17:00:31.566] assign_globals() ...
[17:00:31.566] List of 5
[17:00:31.566]  $ ...future.FUN            :function (e1, e2)  
[17:00:31.566]  $ MoreArgs                 : NULL
[17:00:31.566]  $ ...future.elements_ii    :List of 2
[17:00:31.566]   ..$ :List of 2
[17:00:31.566]   .. ..$ : num 1
[17:00:31.566]   .. ..$ : num 1
[17:00:31.566]   ..$ :List of 2
[17:00:31.566]   .. ..$ : int 2
[17:00:31.566]   .. ..$ : int 3
[17:00:31.566]  $ ...future.seeds_ii       : NULL
[17:00:31.566]  $ ...future.globals.maxSize: NULL
[17:00:31.566]  - attr(*, "where")=List of 5
[17:00:31.566]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.566]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.566]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.566]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.566]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.566]  - attr(*, "resolved")= logi FALSE
[17:00:31.566]  - attr(*, "total_size")= num 280
[17:00:31.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.566]  - attr(*, "already-done")= logi TRUE
[17:00:31.576] - copied ‘...future.FUN’ to environment
[17:00:31.576] - copied ‘MoreArgs’ to environment
[17:00:31.576] - copied ‘...future.elements_ii’ to environment
[17:00:31.576] - copied ‘...future.seeds_ii’ to environment
[17:00:31.576] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.577] assign_globals() ... done
[17:00:31.577] requestCore(): workers = 2
[17:00:31.579] MulticoreFuture started
[17:00:31.580] - Launch lazy future ... done
[17:00:31.580] run() for ‘MulticoreFuture’ ... done
[17:00:31.580] Created future:
[17:00:31.580] plan(): Setting new future strategy stack:
[17:00:31.581] List of future strategies:
[17:00:31.581] 1. sequential:
[17:00:31.581]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.581]    - tweaked: FALSE
[17:00:31.581]    - call: NULL
[17:00:31.582] plan(): nbrOfWorkers() = 1
[17:00:31.584] plan(): Setting new future strategy stack:
[17:00:31.584] List of future strategies:
[17:00:31.584] 1. multicore:
[17:00:31.584]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.584]    - tweaked: FALSE
[17:00:31.584]    - call: plan(strategy)
[17:00:31.589] plan(): nbrOfWorkers() = 2
[17:00:31.580] MulticoreFuture:
[17:00:31.580] Label: ‘future_Map-2’
[17:00:31.580] Expression:
[17:00:31.580] {
[17:00:31.580]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.580]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.580]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.580]         on.exit(options(oopts), add = TRUE)
[17:00:31.580]     }
[17:00:31.580]     {
[17:00:31.580]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.580]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.580]         do.call(mapply, args = args)
[17:00:31.580]     }
[17:00:31.580] }
[17:00:31.580] Lazy evaluation: FALSE
[17:00:31.580] Asynchronous evaluation: TRUE
[17:00:31.580] Local evaluation: TRUE
[17:00:31.580] Environment: R_GlobalEnv
[17:00:31.580] Capture standard output: TRUE
[17:00:31.580] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.580] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.580] Packages: <none>
[17:00:31.580] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:31.580] Resolved: TRUE
[17:00:31.580] Value: <not collected>
[17:00:31.580] Conditions captured: <none>
[17:00:31.580] Early signaling: FALSE
[17:00:31.580] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.580] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.590] Chunk #2 of 2 ... DONE
[17:00:31.591] Launching 2 futures (chunks) ... DONE
[17:00:31.591] Resolving 2 futures (chunks) ...
[17:00:31.591] resolve() on list ...
[17:00:31.591]  recursive: 0
[17:00:31.591]  length: 2
[17:00:31.591] 
[17:00:31.592] Future #1
[17:00:31.592] result() for MulticoreFuture ...
[17:00:31.593] result() for MulticoreFuture ...
[17:00:31.593] result() for MulticoreFuture ... done
[17:00:31.593] result() for MulticoreFuture ... done
[17:00:31.593] result() for MulticoreFuture ...
[17:00:31.593] result() for MulticoreFuture ... done
[17:00:31.593] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:31.594] - nx: 2
[17:00:31.594] - relay: TRUE
[17:00:31.594] - stdout: TRUE
[17:00:31.594] - signal: TRUE
[17:00:31.594] - resignal: FALSE
[17:00:31.594] - force: TRUE
[17:00:31.595] - relayed: [n=2] FALSE, FALSE
[17:00:31.595] - queued futures: [n=2] FALSE, FALSE
[17:00:31.595]  - until=1
[17:00:31.595]  - relaying element #1
[17:00:31.595] result() for MulticoreFuture ...
[17:00:31.595] result() for MulticoreFuture ... done
[17:00:31.596] result() for MulticoreFuture ...
[17:00:31.596] result() for MulticoreFuture ... done
[17:00:31.596] result() for MulticoreFuture ...
[17:00:31.596] result() for MulticoreFuture ... done
[17:00:31.596] result() for MulticoreFuture ...
[17:00:31.596] result() for MulticoreFuture ... done
[17:00:31.597] - relayed: [n=2] TRUE, FALSE
[17:00:31.597] - queued futures: [n=2] TRUE, FALSE
[17:00:31.597] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:31.597]  length: 1 (resolved future 1)
[17:00:31.597] Future #2
[17:00:31.598] result() for MulticoreFuture ...
[17:00:31.598] result() for MulticoreFuture ...
[17:00:31.598] result() for MulticoreFuture ... done
[17:00:31.599] result() for MulticoreFuture ... done
[17:00:31.599] result() for MulticoreFuture ...
[17:00:31.599] result() for MulticoreFuture ... done
[17:00:31.599] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:31.599] - nx: 2
[17:00:31.599] - relay: TRUE
[17:00:31.599] - stdout: TRUE
[17:00:31.600] - signal: TRUE
[17:00:31.600] - resignal: FALSE
[17:00:31.600] - force: TRUE
[17:00:31.600] - relayed: [n=2] TRUE, FALSE
[17:00:31.600] - queued futures: [n=2] TRUE, FALSE
[17:00:31.600]  - until=2
[17:00:31.600]  - relaying element #2
[17:00:31.600] result() for MulticoreFuture ...
[17:00:31.601] result() for MulticoreFuture ... done
[17:00:31.601] result() for MulticoreFuture ...
[17:00:31.601] result() for MulticoreFuture ... done
[17:00:31.604] result() for MulticoreFuture ...
[17:00:31.604] result() for MulticoreFuture ... done
[17:00:31.605] result() for MulticoreFuture ...
[17:00:31.605] result() for MulticoreFuture ... done
[17:00:31.605] - relayed: [n=2] TRUE, TRUE
[17:00:31.605] - queued futures: [n=2] TRUE, TRUE
[17:00:31.605] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:31.606]  length: 0 (resolved future 2)
[17:00:31.606] Relaying remaining futures
[17:00:31.606] signalConditionsASAP(NULL, pos=0) ...
[17:00:31.606] - nx: 2
[17:00:31.606] - relay: TRUE
[17:00:31.606] - stdout: TRUE
[17:00:31.607] - signal: TRUE
[17:00:31.607] - resignal: FALSE
[17:00:31.607] - force: TRUE
[17:00:31.607] - relayed: [n=2] TRUE, TRUE
[17:00:31.607] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:31.607] - relayed: [n=2] TRUE, TRUE
[17:00:31.608] - queued futures: [n=2] TRUE, TRUE
[17:00:31.608] signalConditionsASAP(NULL, pos=0) ... done
[17:00:31.608] resolve() on list ... DONE
[17:00:31.608] result() for MulticoreFuture ...
[17:00:31.608] result() for MulticoreFuture ... done
[17:00:31.608] result() for MulticoreFuture ...
[17:00:31.609] result() for MulticoreFuture ... done
[17:00:31.609] result() for MulticoreFuture ...
[17:00:31.609] result() for MulticoreFuture ... done
[17:00:31.609] result() for MulticoreFuture ...
[17:00:31.609] result() for MulticoreFuture ... done
[17:00:31.609]  - Number of value chunks collected: 2
[17:00:31.610] Resolving 2 futures (chunks) ... DONE
[17:00:31.610] Reducing values from 2 chunks ...
[17:00:31.610]  - Number of values collected after concatenation: 3
[17:00:31.610]  - Number of values expected: 3
[17:00:31.610] Reducing values from 2 chunks ... DONE
[17:00:31.610] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[17:00:31.611] future_mapply() ...
[17:00:31.616] Number of chunks: 2
[17:00:31.616] getGlobalsAndPackagesXApply() ...
[17:00:31.616]  - future.globals: TRUE
[17:00:31.617] getGlobalsAndPackages() ...
[17:00:31.617] Searching for globals...
[17:00:31.618] - globals found: [1] ‘FUN’
[17:00:31.618] Searching for globals ... DONE
[17:00:31.619] Resolving globals: FALSE
[17:00:31.619] The total size of the 1 globals is 848 bytes (848 bytes)
[17:00:31.619] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:00:31.620] - globals: [1] ‘FUN’
[17:00:31.620] 
[17:00:31.620] getGlobalsAndPackages() ... DONE
[17:00:31.620]  - globals found/used: [n=1] ‘FUN’
[17:00:31.620]  - needed namespaces: [n=0] 
[17:00:31.620] Finding globals ... DONE
[17:00:31.620] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:31.621] List of 2
[17:00:31.621]  $ ...future.FUN:function (x)  
[17:00:31.621]  $ MoreArgs     : NULL
[17:00:31.621]  - attr(*, "where")=List of 2
[17:00:31.621]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:31.621]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:31.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.621]  - attr(*, "resolved")= logi FALSE
[17:00:31.621]  - attr(*, "total_size")= num NA
[17:00:31.623] Packages to be attached in all futures: [n=0] 
[17:00:31.624] getGlobalsAndPackagesXApply() ... DONE
[17:00:31.624] Number of futures (= number of chunks): 2
[17:00:31.624] Launching 2 futures (chunks) ...
[17:00:31.624] Chunk #1 of 2 ...
[17:00:31.624]  - Finding globals in '...' for chunk #1 ...
[17:00:31.624] getGlobalsAndPackages() ...
[17:00:31.624] Searching for globals...
[17:00:31.625] 
[17:00:31.625] Searching for globals ... DONE
[17:00:31.625] - globals: [0] <none>
[17:00:31.625] getGlobalsAndPackages() ... DONE
[17:00:31.625]    + additional globals found: [n=0] 
[17:00:31.625]    + additional namespaces needed: [n=0] 
[17:00:31.625]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:31.625]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.625]  - seeds: <none>
[17:00:31.625]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.626] getGlobalsAndPackages() ...
[17:00:31.626] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.626] Resolving globals: FALSE
[17:00:31.626] The total size of the 5 globals is 904 bytes (904 bytes)
[17:00:31.627] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:31.627] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.627] 
[17:00:31.627] getGlobalsAndPackages() ... DONE
[17:00:31.627] run() for ‘Future’ ...
[17:00:31.628] - state: ‘created’
[17:00:31.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.632] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.632]   - Field: ‘label’
[17:00:31.632]   - Field: ‘local’
[17:00:31.633]   - Field: ‘owner’
[17:00:31.633]   - Field: ‘envir’
[17:00:31.633]   - Field: ‘workers’
[17:00:31.633]   - Field: ‘packages’
[17:00:31.633]   - Field: ‘gc’
[17:00:31.633]   - Field: ‘job’
[17:00:31.633]   - Field: ‘conditions’
[17:00:31.633]   - Field: ‘expr’
[17:00:31.634]   - Field: ‘uuid’
[17:00:31.634]   - Field: ‘seed’
[17:00:31.634]   - Field: ‘version’
[17:00:31.634]   - Field: ‘result’
[17:00:31.634]   - Field: ‘asynchronous’
[17:00:31.634]   - Field: ‘calls’
[17:00:31.637]   - Field: ‘globals’
[17:00:31.637]   - Field: ‘stdout’
[17:00:31.637]   - Field: ‘earlySignal’
[17:00:31.638]   - Field: ‘lazy’
[17:00:31.638]   - Field: ‘state’
[17:00:31.638] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.638] - Launch lazy future ...
[17:00:31.638] Packages needed by the future expression (n = 0): <none>
[17:00:31.638] Packages needed by future strategies (n = 0): <none>
[17:00:31.639] {
[17:00:31.639]     {
[17:00:31.639]         {
[17:00:31.639]             ...future.startTime <- base::Sys.time()
[17:00:31.639]             {
[17:00:31.639]                 {
[17:00:31.639]                   {
[17:00:31.639]                     {
[17:00:31.639]                       base::local({
[17:00:31.639]                         has_future <- base::requireNamespace("future", 
[17:00:31.639]                           quietly = TRUE)
[17:00:31.639]                         if (has_future) {
[17:00:31.639]                           ns <- base::getNamespace("future")
[17:00:31.639]                           version <- ns[[".package"]][["version"]]
[17:00:31.639]                           if (is.null(version)) 
[17:00:31.639]                             version <- utils::packageVersion("future")
[17:00:31.639]                         }
[17:00:31.639]                         else {
[17:00:31.639]                           version <- NULL
[17:00:31.639]                         }
[17:00:31.639]                         if (!has_future || version < "1.8.0") {
[17:00:31.639]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.639]                             "", base::R.version$version.string), 
[17:00:31.639]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:31.639]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:31.639]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.639]                               "release", "version")], collapse = " "), 
[17:00:31.639]                             hostname = base::Sys.info()[["nodename"]])
[17:00:31.639]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.639]                             info)
[17:00:31.639]                           info <- base::paste(info, collapse = "; ")
[17:00:31.639]                           if (!has_future) {
[17:00:31.639]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.639]                               info)
[17:00:31.639]                           }
[17:00:31.639]                           else {
[17:00:31.639]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.639]                               info, version)
[17:00:31.639]                           }
[17:00:31.639]                           base::stop(msg)
[17:00:31.639]                         }
[17:00:31.639]                       })
[17:00:31.639]                     }
[17:00:31.639]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.639]                     base::options(mc.cores = 1L)
[17:00:31.639]                   }
[17:00:31.639]                   ...future.strategy.old <- future::plan("list")
[17:00:31.639]                   options(future.plan = NULL)
[17:00:31.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.639]                 }
[17:00:31.639]                 ...future.workdir <- getwd()
[17:00:31.639]             }
[17:00:31.639]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.639]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.639]         }
[17:00:31.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.639]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.639]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.639]             base::names(...future.oldOptions))
[17:00:31.639]     }
[17:00:31.639]     if (FALSE) {
[17:00:31.639]     }
[17:00:31.639]     else {
[17:00:31.639]         if (TRUE) {
[17:00:31.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.639]                 open = "w")
[17:00:31.639]         }
[17:00:31.639]         else {
[17:00:31.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.639]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.639]         }
[17:00:31.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.639]             base::sink(type = "output", split = FALSE)
[17:00:31.639]             base::close(...future.stdout)
[17:00:31.639]         }, add = TRUE)
[17:00:31.639]     }
[17:00:31.639]     ...future.frame <- base::sys.nframe()
[17:00:31.639]     ...future.conditions <- base::list()
[17:00:31.639]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.639]     if (FALSE) {
[17:00:31.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.639]     }
[17:00:31.639]     ...future.result <- base::tryCatch({
[17:00:31.639]         base::withCallingHandlers({
[17:00:31.639]             ...future.value <- base::withVisible(base::local({
[17:00:31.639]                 withCallingHandlers({
[17:00:31.639]                   {
[17:00:31.639]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.639]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.639]                       ...future.globals.maxSize)) {
[17:00:31.639]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.639]                       on.exit(options(oopts), add = TRUE)
[17:00:31.639]                     }
[17:00:31.639]                     {
[17:00:31.639]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.639]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.639]                         USE.NAMES = FALSE)
[17:00:31.639]                       do.call(mapply, args = args)
[17:00:31.639]                     }
[17:00:31.639]                   }
[17:00:31.639]                 }, immediateCondition = function(cond) {
[17:00:31.639]                   save_rds <- function (object, pathname, ...) 
[17:00:31.639]                   {
[17:00:31.639]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.639]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.639]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.639]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.639]                         fi_tmp[["mtime"]])
[17:00:31.639]                     }
[17:00:31.639]                     tryCatch({
[17:00:31.639]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.639]                     }, error = function(ex) {
[17:00:31.639]                       msg <- conditionMessage(ex)
[17:00:31.639]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.639]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.639]                         fi_tmp[["mtime"]], msg)
[17:00:31.639]                       ex$message <- msg
[17:00:31.639]                       stop(ex)
[17:00:31.639]                     })
[17:00:31.639]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.639]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.639]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.639]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.639]                       fi <- file.info(pathname)
[17:00:31.639]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.639]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.639]                         fi[["size"]], fi[["mtime"]])
[17:00:31.639]                       stop(msg)
[17:00:31.639]                     }
[17:00:31.639]                     invisible(pathname)
[17:00:31.639]                   }
[17:00:31.639]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.639]                     rootPath = tempdir()) 
[17:00:31.639]                   {
[17:00:31.639]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.639]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.639]                       tmpdir = path, fileext = ".rds")
[17:00:31.639]                     save_rds(obj, file)
[17:00:31.639]                   }
[17:00:31.639]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.639]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.639]                   {
[17:00:31.639]                     inherits <- base::inherits
[17:00:31.639]                     invokeRestart <- base::invokeRestart
[17:00:31.639]                     is.null <- base::is.null
[17:00:31.639]                     muffled <- FALSE
[17:00:31.639]                     if (inherits(cond, "message")) {
[17:00:31.639]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.639]                       if (muffled) 
[17:00:31.639]                         invokeRestart("muffleMessage")
[17:00:31.639]                     }
[17:00:31.639]                     else if (inherits(cond, "warning")) {
[17:00:31.639]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.639]                       if (muffled) 
[17:00:31.639]                         invokeRestart("muffleWarning")
[17:00:31.639]                     }
[17:00:31.639]                     else if (inherits(cond, "condition")) {
[17:00:31.639]                       if (!is.null(pattern)) {
[17:00:31.639]                         computeRestarts <- base::computeRestarts
[17:00:31.639]                         grepl <- base::grepl
[17:00:31.639]                         restarts <- computeRestarts(cond)
[17:00:31.639]                         for (restart in restarts) {
[17:00:31.639]                           name <- restart$name
[17:00:31.639]                           if (is.null(name)) 
[17:00:31.639]                             next
[17:00:31.639]                           if (!grepl(pattern, name)) 
[17:00:31.639]                             next
[17:00:31.639]                           invokeRestart(restart)
[17:00:31.639]                           muffled <- TRUE
[17:00:31.639]                           break
[17:00:31.639]                         }
[17:00:31.639]                       }
[17:00:31.639]                     }
[17:00:31.639]                     invisible(muffled)
[17:00:31.639]                   }
[17:00:31.639]                   muffleCondition(cond)
[17:00:31.639]                 })
[17:00:31.639]             }))
[17:00:31.639]             future::FutureResult(value = ...future.value$value, 
[17:00:31.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.639]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.639]                     ...future.globalenv.names))
[17:00:31.639]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.639]         }, condition = base::local({
[17:00:31.639]             c <- base::c
[17:00:31.639]             inherits <- base::inherits
[17:00:31.639]             invokeRestart <- base::invokeRestart
[17:00:31.639]             length <- base::length
[17:00:31.639]             list <- base::list
[17:00:31.639]             seq.int <- base::seq.int
[17:00:31.639]             signalCondition <- base::signalCondition
[17:00:31.639]             sys.calls <- base::sys.calls
[17:00:31.639]             `[[` <- base::`[[`
[17:00:31.639]             `+` <- base::`+`
[17:00:31.639]             `<<-` <- base::`<<-`
[17:00:31.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.639]                   3L)]
[17:00:31.639]             }
[17:00:31.639]             function(cond) {
[17:00:31.639]                 is_error <- inherits(cond, "error")
[17:00:31.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.639]                   NULL)
[17:00:31.639]                 if (is_error) {
[17:00:31.639]                   sessionInformation <- function() {
[17:00:31.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.639]                       search = base::search(), system = base::Sys.info())
[17:00:31.639]                   }
[17:00:31.639]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.639]                     cond$call), session = sessionInformation(), 
[17:00:31.639]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.639]                   signalCondition(cond)
[17:00:31.639]                 }
[17:00:31.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.639]                 "immediateCondition"))) {
[17:00:31.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.639]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.639]                   if (TRUE && !signal) {
[17:00:31.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.639]                     {
[17:00:31.639]                       inherits <- base::inherits
[17:00:31.639]                       invokeRestart <- base::invokeRestart
[17:00:31.639]                       is.null <- base::is.null
[17:00:31.639]                       muffled <- FALSE
[17:00:31.639]                       if (inherits(cond, "message")) {
[17:00:31.639]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.639]                         if (muffled) 
[17:00:31.639]                           invokeRestart("muffleMessage")
[17:00:31.639]                       }
[17:00:31.639]                       else if (inherits(cond, "warning")) {
[17:00:31.639]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.639]                         if (muffled) 
[17:00:31.639]                           invokeRestart("muffleWarning")
[17:00:31.639]                       }
[17:00:31.639]                       else if (inherits(cond, "condition")) {
[17:00:31.639]                         if (!is.null(pattern)) {
[17:00:31.639]                           computeRestarts <- base::computeRestarts
[17:00:31.639]                           grepl <- base::grepl
[17:00:31.639]                           restarts <- computeRestarts(cond)
[17:00:31.639]                           for (restart in restarts) {
[17:00:31.639]                             name <- restart$name
[17:00:31.639]                             if (is.null(name)) 
[17:00:31.639]                               next
[17:00:31.639]                             if (!grepl(pattern, name)) 
[17:00:31.639]                               next
[17:00:31.639]                             invokeRestart(restart)
[17:00:31.639]                             muffled <- TRUE
[17:00:31.639]                             break
[17:00:31.639]                           }
[17:00:31.639]                         }
[17:00:31.639]                       }
[17:00:31.639]                       invisible(muffled)
[17:00:31.639]                     }
[17:00:31.639]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.639]                   }
[17:00:31.639]                 }
[17:00:31.639]                 else {
[17:00:31.639]                   if (TRUE) {
[17:00:31.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.639]                     {
[17:00:31.639]                       inherits <- base::inherits
[17:00:31.639]                       invokeRestart <- base::invokeRestart
[17:00:31.639]                       is.null <- base::is.null
[17:00:31.639]                       muffled <- FALSE
[17:00:31.639]                       if (inherits(cond, "message")) {
[17:00:31.639]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.639]                         if (muffled) 
[17:00:31.639]                           invokeRestart("muffleMessage")
[17:00:31.639]                       }
[17:00:31.639]                       else if (inherits(cond, "warning")) {
[17:00:31.639]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.639]                         if (muffled) 
[17:00:31.639]                           invokeRestart("muffleWarning")
[17:00:31.639]                       }
[17:00:31.639]                       else if (inherits(cond, "condition")) {
[17:00:31.639]                         if (!is.null(pattern)) {
[17:00:31.639]                           computeRestarts <- base::computeRestarts
[17:00:31.639]                           grepl <- base::grepl
[17:00:31.639]                           restarts <- computeRestarts(cond)
[17:00:31.639]                           for (restart in restarts) {
[17:00:31.639]                             name <- restart$name
[17:00:31.639]                             if (is.null(name)) 
[17:00:31.639]                               next
[17:00:31.639]                             if (!grepl(pattern, name)) 
[17:00:31.639]                               next
[17:00:31.639]                             invokeRestart(restart)
[17:00:31.639]                             muffled <- TRUE
[17:00:31.639]                             break
[17:00:31.639]                           }
[17:00:31.639]                         }
[17:00:31.639]                       }
[17:00:31.639]                       invisible(muffled)
[17:00:31.639]                     }
[17:00:31.639]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.639]                   }
[17:00:31.639]                 }
[17:00:31.639]             }
[17:00:31.639]         }))
[17:00:31.639]     }, error = function(ex) {
[17:00:31.639]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.639]                 ...future.rng), started = ...future.startTime, 
[17:00:31.639]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.639]             version = "1.8"), class = "FutureResult")
[17:00:31.639]     }, finally = {
[17:00:31.639]         if (!identical(...future.workdir, getwd())) 
[17:00:31.639]             setwd(...future.workdir)
[17:00:31.639]         {
[17:00:31.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.639]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.639]             }
[17:00:31.639]             base::options(...future.oldOptions)
[17:00:31.639]             if (.Platform$OS.type == "windows") {
[17:00:31.639]                 old_names <- names(...future.oldEnvVars)
[17:00:31.639]                 envs <- base::Sys.getenv()
[17:00:31.639]                 names <- names(envs)
[17:00:31.639]                 common <- intersect(names, old_names)
[17:00:31.639]                 added <- setdiff(names, old_names)
[17:00:31.639]                 removed <- setdiff(old_names, names)
[17:00:31.639]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.639]                   envs[common]]
[17:00:31.639]                 NAMES <- toupper(changed)
[17:00:31.639]                 args <- list()
[17:00:31.639]                 for (kk in seq_along(NAMES)) {
[17:00:31.639]                   name <- changed[[kk]]
[17:00:31.639]                   NAME <- NAMES[[kk]]
[17:00:31.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.639]                     next
[17:00:31.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.639]                 }
[17:00:31.639]                 NAMES <- toupper(added)
[17:00:31.639]                 for (kk in seq_along(NAMES)) {
[17:00:31.639]                   name <- added[[kk]]
[17:00:31.639]                   NAME <- NAMES[[kk]]
[17:00:31.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.639]                     next
[17:00:31.639]                   args[[name]] <- ""
[17:00:31.639]                 }
[17:00:31.639]                 NAMES <- toupper(removed)
[17:00:31.639]                 for (kk in seq_along(NAMES)) {
[17:00:31.639]                   name <- removed[[kk]]
[17:00:31.639]                   NAME <- NAMES[[kk]]
[17:00:31.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.639]                     next
[17:00:31.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.639]                 }
[17:00:31.639]                 if (length(args) > 0) 
[17:00:31.639]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.639]             }
[17:00:31.639]             else {
[17:00:31.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.639]             }
[17:00:31.639]             {
[17:00:31.639]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.639]                   0L) {
[17:00:31.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.639]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.639]                   base::options(opts)
[17:00:31.639]                 }
[17:00:31.639]                 {
[17:00:31.639]                   {
[17:00:31.639]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.639]                     NULL
[17:00:31.639]                   }
[17:00:31.639]                   options(future.plan = NULL)
[17:00:31.639]                   if (is.na(NA_character_)) 
[17:00:31.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.639]                     .init = FALSE)
[17:00:31.639]                 }
[17:00:31.639]             }
[17:00:31.639]         }
[17:00:31.639]     })
[17:00:31.639]     if (TRUE) {
[17:00:31.639]         base::sink(type = "output", split = FALSE)
[17:00:31.639]         if (TRUE) {
[17:00:31.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.639]         }
[17:00:31.639]         else {
[17:00:31.639]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.639]         }
[17:00:31.639]         base::close(...future.stdout)
[17:00:31.639]         ...future.stdout <- NULL
[17:00:31.639]     }
[17:00:31.639]     ...future.result$conditions <- ...future.conditions
[17:00:31.639]     ...future.result$finished <- base::Sys.time()
[17:00:31.639]     ...future.result
[17:00:31.639] }
[17:00:31.642] assign_globals() ...
[17:00:31.642] List of 5
[17:00:31.642]  $ ...future.FUN            :function (x)  
[17:00:31.642]  $ MoreArgs                 : NULL
[17:00:31.642]  $ ...future.elements_ii    :List of 1
[17:00:31.642]   ..$ :List of 1
[17:00:31.642]   .. ..$ a: num 0
[17:00:31.642]  $ ...future.seeds_ii       : NULL
[17:00:31.642]  $ ...future.globals.maxSize: NULL
[17:00:31.642]  - attr(*, "where")=List of 5
[17:00:31.642]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.642]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.642]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.642]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.642]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.642]  - attr(*, "resolved")= logi FALSE
[17:00:31.642]  - attr(*, "total_size")= num 904
[17:00:31.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.642]  - attr(*, "already-done")= logi TRUE
[17:00:31.648] - copied ‘...future.FUN’ to environment
[17:00:31.648] - copied ‘MoreArgs’ to environment
[17:00:31.648] - copied ‘...future.elements_ii’ to environment
[17:00:31.648] - copied ‘...future.seeds_ii’ to environment
[17:00:31.648] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.648] assign_globals() ... done
[17:00:31.648] requestCore(): workers = 2
[17:00:31.651] MulticoreFuture started
[17:00:31.651] - Launch lazy future ... done
[17:00:31.652] run() for ‘MulticoreFuture’ ... done
[17:00:31.652] plan(): Setting new future strategy stack:
[17:00:31.652] Created future:
[17:00:31.652] List of future strategies:
[17:00:31.652] 1. sequential:
[17:00:31.652]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.652]    - tweaked: FALSE
[17:00:31.652]    - call: NULL
[17:00:31.653] plan(): nbrOfWorkers() = 1
[17:00:31.656] plan(): Setting new future strategy stack:
[17:00:31.656] List of future strategies:
[17:00:31.656] 1. multicore:
[17:00:31.656]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.656]    - tweaked: FALSE
[17:00:31.656]    - call: plan(strategy)
[17:00:31.662] plan(): nbrOfWorkers() = 2
[17:00:31.652] MulticoreFuture:
[17:00:31.652] Label: ‘future_mapply-1’
[17:00:31.652] Expression:
[17:00:31.652] {
[17:00:31.652]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.652]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.652]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.652]         on.exit(options(oopts), add = TRUE)
[17:00:31.652]     }
[17:00:31.652]     {
[17:00:31.652]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.652]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.652]         do.call(mapply, args = args)
[17:00:31.652]     }
[17:00:31.652] }
[17:00:31.652] Lazy evaluation: FALSE
[17:00:31.652] Asynchronous evaluation: TRUE
[17:00:31.652] Local evaluation: TRUE
[17:00:31.652] Environment: R_GlobalEnv
[17:00:31.652] Capture standard output: TRUE
[17:00:31.652] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.652] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.652] Packages: <none>
[17:00:31.652] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:31.652] Resolved: TRUE
[17:00:31.652] Value: <not collected>
[17:00:31.652] Conditions captured: <none>
[17:00:31.652] Early signaling: FALSE
[17:00:31.652] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.652] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.663] Chunk #1 of 2 ... DONE
[17:00:31.663] Chunk #2 of 2 ...
[17:00:31.663]  - Finding globals in '...' for chunk #2 ...
[17:00:31.663] getGlobalsAndPackages() ...
[17:00:31.663] Searching for globals...
[17:00:31.664] 
[17:00:31.664] Searching for globals ... DONE
[17:00:31.664] - globals: [0] <none>
[17:00:31.664] getGlobalsAndPackages() ... DONE
[17:00:31.664]    + additional globals found: [n=0] 
[17:00:31.665]    + additional namespaces needed: [n=0] 
[17:00:31.665]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:31.665]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:31.665]  - seeds: <none>
[17:00:31.665]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.665] getGlobalsAndPackages() ...
[17:00:31.665] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.666] Resolving globals: FALSE
[17:00:31.667] The total size of the 5 globals is 904 bytes (904 bytes)
[17:00:31.667] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:31.668] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:31.668] 
[17:00:31.668] getGlobalsAndPackages() ... DONE
[17:00:31.669] run() for ‘Future’ ...
[17:00:31.669] - state: ‘created’
[17:00:31.669] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:00:31.674] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.674] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:00:31.674]   - Field: ‘label’
[17:00:31.674]   - Field: ‘local’
[17:00:31.674]   - Field: ‘owner’
[17:00:31.675]   - Field: ‘envir’
[17:00:31.675]   - Field: ‘workers’
[17:00:31.675]   - Field: ‘packages’
[17:00:31.675]   - Field: ‘gc’
[17:00:31.675]   - Field: ‘job’
[17:00:31.675]   - Field: ‘conditions’
[17:00:31.676]   - Field: ‘expr’
[17:00:31.676]   - Field: ‘uuid’
[17:00:31.676]   - Field: ‘seed’
[17:00:31.676]   - Field: ‘version’
[17:00:31.676]   - Field: ‘result’
[17:00:31.676]   - Field: ‘asynchronous’
[17:00:31.676]   - Field: ‘calls’
[17:00:31.677]   - Field: ‘globals’
[17:00:31.677]   - Field: ‘stdout’
[17:00:31.677]   - Field: ‘earlySignal’
[17:00:31.677]   - Field: ‘lazy’
[17:00:31.677]   - Field: ‘state’
[17:00:31.677] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:00:31.677] - Launch lazy future ...
[17:00:31.678] Packages needed by the future expression (n = 0): <none>
[17:00:31.678] Packages needed by future strategies (n = 0): <none>
[17:00:31.679] {
[17:00:31.679]     {
[17:00:31.679]         {
[17:00:31.679]             ...future.startTime <- base::Sys.time()
[17:00:31.679]             {
[17:00:31.679]                 {
[17:00:31.679]                   {
[17:00:31.679]                     {
[17:00:31.679]                       base::local({
[17:00:31.679]                         has_future <- base::requireNamespace("future", 
[17:00:31.679]                           quietly = TRUE)
[17:00:31.679]                         if (has_future) {
[17:00:31.679]                           ns <- base::getNamespace("future")
[17:00:31.679]                           version <- ns[[".package"]][["version"]]
[17:00:31.679]                           if (is.null(version)) 
[17:00:31.679]                             version <- utils::packageVersion("future")
[17:00:31.679]                         }
[17:00:31.679]                         else {
[17:00:31.679]                           version <- NULL
[17:00:31.679]                         }
[17:00:31.679]                         if (!has_future || version < "1.8.0") {
[17:00:31.679]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:31.679]                             "", base::R.version$version.string), 
[17:00:31.679]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:31.679]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:31.679]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:31.679]                               "release", "version")], collapse = " "), 
[17:00:31.679]                             hostname = base::Sys.info()[["nodename"]])
[17:00:31.679]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:31.679]                             info)
[17:00:31.679]                           info <- base::paste(info, collapse = "; ")
[17:00:31.679]                           if (!has_future) {
[17:00:31.679]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:31.679]                               info)
[17:00:31.679]                           }
[17:00:31.679]                           else {
[17:00:31.679]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:31.679]                               info, version)
[17:00:31.679]                           }
[17:00:31.679]                           base::stop(msg)
[17:00:31.679]                         }
[17:00:31.679]                       })
[17:00:31.679]                     }
[17:00:31.679]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:31.679]                     base::options(mc.cores = 1L)
[17:00:31.679]                   }
[17:00:31.679]                   ...future.strategy.old <- future::plan("list")
[17:00:31.679]                   options(future.plan = NULL)
[17:00:31.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:31.679]                 }
[17:00:31.679]                 ...future.workdir <- getwd()
[17:00:31.679]             }
[17:00:31.679]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:31.679]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:31.679]         }
[17:00:31.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:31.679]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:31.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:31.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:31.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:31.679]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:31.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:31.679]             base::names(...future.oldOptions))
[17:00:31.679]     }
[17:00:31.679]     if (FALSE) {
[17:00:31.679]     }
[17:00:31.679]     else {
[17:00:31.679]         if (TRUE) {
[17:00:31.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:31.679]                 open = "w")
[17:00:31.679]         }
[17:00:31.679]         else {
[17:00:31.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:31.679]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:31.679]         }
[17:00:31.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:31.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:31.679]             base::sink(type = "output", split = FALSE)
[17:00:31.679]             base::close(...future.stdout)
[17:00:31.679]         }, add = TRUE)
[17:00:31.679]     }
[17:00:31.679]     ...future.frame <- base::sys.nframe()
[17:00:31.679]     ...future.conditions <- base::list()
[17:00:31.679]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:31.679]     if (FALSE) {
[17:00:31.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:31.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:31.679]     }
[17:00:31.679]     ...future.result <- base::tryCatch({
[17:00:31.679]         base::withCallingHandlers({
[17:00:31.679]             ...future.value <- base::withVisible(base::local({
[17:00:31.679]                 withCallingHandlers({
[17:00:31.679]                   {
[17:00:31.679]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.679]                     if (!identical(...future.globals.maxSize.org, 
[17:00:31.679]                       ...future.globals.maxSize)) {
[17:00:31.679]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.679]                       on.exit(options(oopts), add = TRUE)
[17:00:31.679]                     }
[17:00:31.679]                     {
[17:00:31.679]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.679]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:31.679]                         USE.NAMES = FALSE)
[17:00:31.679]                       do.call(mapply, args = args)
[17:00:31.679]                     }
[17:00:31.679]                   }
[17:00:31.679]                 }, immediateCondition = function(cond) {
[17:00:31.679]                   save_rds <- function (object, pathname, ...) 
[17:00:31.679]                   {
[17:00:31.679]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:00:31.679]                     if (file_test("-f", pathname_tmp)) {
[17:00:31.679]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.679]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:00:31.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.679]                         fi_tmp[["mtime"]])
[17:00:31.679]                     }
[17:00:31.679]                     tryCatch({
[17:00:31.679]                       saveRDS(object, file = pathname_tmp, ...)
[17:00:31.679]                     }, error = function(ex) {
[17:00:31.679]                       msg <- conditionMessage(ex)
[17:00:31.679]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.679]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:00:31.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.679]                         fi_tmp[["mtime"]], msg)
[17:00:31.679]                       ex$message <- msg
[17:00:31.679]                       stop(ex)
[17:00:31.679]                     })
[17:00:31.679]                     stopifnot(file_test("-f", pathname_tmp))
[17:00:31.679]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:00:31.679]                     if (!res || file_test("-f", pathname_tmp)) {
[17:00:31.679]                       fi_tmp <- file.info(pathname_tmp)
[17:00:31.679]                       fi <- file.info(pathname)
[17:00:31.679]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:00:31.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:00:31.679]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:00:31.679]                         fi[["size"]], fi[["mtime"]])
[17:00:31.679]                       stop(msg)
[17:00:31.679]                     }
[17:00:31.679]                     invisible(pathname)
[17:00:31.679]                   }
[17:00:31.679]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:00:31.679]                     rootPath = tempdir()) 
[17:00:31.679]                   {
[17:00:31.679]                     obj <- list(time = Sys.time(), condition = cond)
[17:00:31.679]                     file <- tempfile(pattern = class(cond)[1], 
[17:00:31.679]                       tmpdir = path, fileext = ".rds")
[17:00:31.679]                     save_rds(obj, file)
[17:00:31.679]                   }
[17:00:31.679]                   saveImmediateCondition(cond, path = "/tmp/RtmpcgMQPN/.future/immediateConditions")
[17:00:31.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.679]                   {
[17:00:31.679]                     inherits <- base::inherits
[17:00:31.679]                     invokeRestart <- base::invokeRestart
[17:00:31.679]                     is.null <- base::is.null
[17:00:31.679]                     muffled <- FALSE
[17:00:31.679]                     if (inherits(cond, "message")) {
[17:00:31.679]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:31.679]                       if (muffled) 
[17:00:31.679]                         invokeRestart("muffleMessage")
[17:00:31.679]                     }
[17:00:31.679]                     else if (inherits(cond, "warning")) {
[17:00:31.679]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:31.679]                       if (muffled) 
[17:00:31.679]                         invokeRestart("muffleWarning")
[17:00:31.679]                     }
[17:00:31.679]                     else if (inherits(cond, "condition")) {
[17:00:31.679]                       if (!is.null(pattern)) {
[17:00:31.679]                         computeRestarts <- base::computeRestarts
[17:00:31.679]                         grepl <- base::grepl
[17:00:31.679]                         restarts <- computeRestarts(cond)
[17:00:31.679]                         for (restart in restarts) {
[17:00:31.679]                           name <- restart$name
[17:00:31.679]                           if (is.null(name)) 
[17:00:31.679]                             next
[17:00:31.679]                           if (!grepl(pattern, name)) 
[17:00:31.679]                             next
[17:00:31.679]                           invokeRestart(restart)
[17:00:31.679]                           muffled <- TRUE
[17:00:31.679]                           break
[17:00:31.679]                         }
[17:00:31.679]                       }
[17:00:31.679]                     }
[17:00:31.679]                     invisible(muffled)
[17:00:31.679]                   }
[17:00:31.679]                   muffleCondition(cond)
[17:00:31.679]                 })
[17:00:31.679]             }))
[17:00:31.679]             future::FutureResult(value = ...future.value$value, 
[17:00:31.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.679]                   ...future.rng), globalenv = if (FALSE) 
[17:00:31.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:31.679]                     ...future.globalenv.names))
[17:00:31.679]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:31.679]         }, condition = base::local({
[17:00:31.679]             c <- base::c
[17:00:31.679]             inherits <- base::inherits
[17:00:31.679]             invokeRestart <- base::invokeRestart
[17:00:31.679]             length <- base::length
[17:00:31.679]             list <- base::list
[17:00:31.679]             seq.int <- base::seq.int
[17:00:31.679]             signalCondition <- base::signalCondition
[17:00:31.679]             sys.calls <- base::sys.calls
[17:00:31.679]             `[[` <- base::`[[`
[17:00:31.679]             `+` <- base::`+`
[17:00:31.679]             `<<-` <- base::`<<-`
[17:00:31.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:31.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:31.679]                   3L)]
[17:00:31.679]             }
[17:00:31.679]             function(cond) {
[17:00:31.679]                 is_error <- inherits(cond, "error")
[17:00:31.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:31.679]                   NULL)
[17:00:31.679]                 if (is_error) {
[17:00:31.679]                   sessionInformation <- function() {
[17:00:31.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:31.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:31.679]                       search = base::search(), system = base::Sys.info())
[17:00:31.679]                   }
[17:00:31.679]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:31.679]                     cond$call), session = sessionInformation(), 
[17:00:31.679]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:31.679]                   signalCondition(cond)
[17:00:31.679]                 }
[17:00:31.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:31.679]                 "immediateCondition"))) {
[17:00:31.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:31.679]                   ...future.conditions[[length(...future.conditions) + 
[17:00:31.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:31.679]                   if (TRUE && !signal) {
[17:00:31.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.679]                     {
[17:00:31.679]                       inherits <- base::inherits
[17:00:31.679]                       invokeRestart <- base::invokeRestart
[17:00:31.679]                       is.null <- base::is.null
[17:00:31.679]                       muffled <- FALSE
[17:00:31.679]                       if (inherits(cond, "message")) {
[17:00:31.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.679]                         if (muffled) 
[17:00:31.679]                           invokeRestart("muffleMessage")
[17:00:31.679]                       }
[17:00:31.679]                       else if (inherits(cond, "warning")) {
[17:00:31.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.679]                         if (muffled) 
[17:00:31.679]                           invokeRestart("muffleWarning")
[17:00:31.679]                       }
[17:00:31.679]                       else if (inherits(cond, "condition")) {
[17:00:31.679]                         if (!is.null(pattern)) {
[17:00:31.679]                           computeRestarts <- base::computeRestarts
[17:00:31.679]                           grepl <- base::grepl
[17:00:31.679]                           restarts <- computeRestarts(cond)
[17:00:31.679]                           for (restart in restarts) {
[17:00:31.679]                             name <- restart$name
[17:00:31.679]                             if (is.null(name)) 
[17:00:31.679]                               next
[17:00:31.679]                             if (!grepl(pattern, name)) 
[17:00:31.679]                               next
[17:00:31.679]                             invokeRestart(restart)
[17:00:31.679]                             muffled <- TRUE
[17:00:31.679]                             break
[17:00:31.679]                           }
[17:00:31.679]                         }
[17:00:31.679]                       }
[17:00:31.679]                       invisible(muffled)
[17:00:31.679]                     }
[17:00:31.679]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.679]                   }
[17:00:31.679]                 }
[17:00:31.679]                 else {
[17:00:31.679]                   if (TRUE) {
[17:00:31.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:31.679]                     {
[17:00:31.679]                       inherits <- base::inherits
[17:00:31.679]                       invokeRestart <- base::invokeRestart
[17:00:31.679]                       is.null <- base::is.null
[17:00:31.679]                       muffled <- FALSE
[17:00:31.679]                       if (inherits(cond, "message")) {
[17:00:31.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:31.679]                         if (muffled) 
[17:00:31.679]                           invokeRestart("muffleMessage")
[17:00:31.679]                       }
[17:00:31.679]                       else if (inherits(cond, "warning")) {
[17:00:31.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:31.679]                         if (muffled) 
[17:00:31.679]                           invokeRestart("muffleWarning")
[17:00:31.679]                       }
[17:00:31.679]                       else if (inherits(cond, "condition")) {
[17:00:31.679]                         if (!is.null(pattern)) {
[17:00:31.679]                           computeRestarts <- base::computeRestarts
[17:00:31.679]                           grepl <- base::grepl
[17:00:31.679]                           restarts <- computeRestarts(cond)
[17:00:31.679]                           for (restart in restarts) {
[17:00:31.679]                             name <- restart$name
[17:00:31.679]                             if (is.null(name)) 
[17:00:31.679]                               next
[17:00:31.679]                             if (!grepl(pattern, name)) 
[17:00:31.679]                               next
[17:00:31.679]                             invokeRestart(restart)
[17:00:31.679]                             muffled <- TRUE
[17:00:31.679]                             break
[17:00:31.679]                           }
[17:00:31.679]                         }
[17:00:31.679]                       }
[17:00:31.679]                       invisible(muffled)
[17:00:31.679]                     }
[17:00:31.679]                     muffleCondition(cond, pattern = "^muffle")
[17:00:31.679]                   }
[17:00:31.679]                 }
[17:00:31.679]             }
[17:00:31.679]         }))
[17:00:31.679]     }, error = function(ex) {
[17:00:31.679]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:31.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:31.679]                 ...future.rng), started = ...future.startTime, 
[17:00:31.679]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:31.679]             version = "1.8"), class = "FutureResult")
[17:00:31.679]     }, finally = {
[17:00:31.679]         if (!identical(...future.workdir, getwd())) 
[17:00:31.679]             setwd(...future.workdir)
[17:00:31.679]         {
[17:00:31.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:31.679]                 ...future.oldOptions$nwarnings <- NULL
[17:00:31.679]             }
[17:00:31.679]             base::options(...future.oldOptions)
[17:00:31.679]             if (.Platform$OS.type == "windows") {
[17:00:31.679]                 old_names <- names(...future.oldEnvVars)
[17:00:31.679]                 envs <- base::Sys.getenv()
[17:00:31.679]                 names <- names(envs)
[17:00:31.679]                 common <- intersect(names, old_names)
[17:00:31.679]                 added <- setdiff(names, old_names)
[17:00:31.679]                 removed <- setdiff(old_names, names)
[17:00:31.679]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:31.679]                   envs[common]]
[17:00:31.679]                 NAMES <- toupper(changed)
[17:00:31.679]                 args <- list()
[17:00:31.679]                 for (kk in seq_along(NAMES)) {
[17:00:31.679]                   name <- changed[[kk]]
[17:00:31.679]                   NAME <- NAMES[[kk]]
[17:00:31.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.679]                     next
[17:00:31.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.679]                 }
[17:00:31.679]                 NAMES <- toupper(added)
[17:00:31.679]                 for (kk in seq_along(NAMES)) {
[17:00:31.679]                   name <- added[[kk]]
[17:00:31.679]                   NAME <- NAMES[[kk]]
[17:00:31.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.679]                     next
[17:00:31.679]                   args[[name]] <- ""
[17:00:31.679]                 }
[17:00:31.679]                 NAMES <- toupper(removed)
[17:00:31.679]                 for (kk in seq_along(NAMES)) {
[17:00:31.679]                   name <- removed[[kk]]
[17:00:31.679]                   NAME <- NAMES[[kk]]
[17:00:31.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:31.679]                     next
[17:00:31.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:31.679]                 }
[17:00:31.679]                 if (length(args) > 0) 
[17:00:31.679]                   base::do.call(base::Sys.setenv, args = args)
[17:00:31.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:31.679]             }
[17:00:31.679]             else {
[17:00:31.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:31.679]             }
[17:00:31.679]             {
[17:00:31.679]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:31.679]                   0L) {
[17:00:31.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:31.679]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:31.679]                   base::options(opts)
[17:00:31.679]                 }
[17:00:31.679]                 {
[17:00:31.679]                   {
[17:00:31.679]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:31.679]                     NULL
[17:00:31.679]                   }
[17:00:31.679]                   options(future.plan = NULL)
[17:00:31.679]                   if (is.na(NA_character_)) 
[17:00:31.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:31.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:31.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:31.679]                     .init = FALSE)
[17:00:31.679]                 }
[17:00:31.679]             }
[17:00:31.679]         }
[17:00:31.679]     })
[17:00:31.679]     if (TRUE) {
[17:00:31.679]         base::sink(type = "output", split = FALSE)
[17:00:31.679]         if (TRUE) {
[17:00:31.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:31.679]         }
[17:00:31.679]         else {
[17:00:31.679]             ...future.result["stdout"] <- base::list(NULL)
[17:00:31.679]         }
[17:00:31.679]         base::close(...future.stdout)
[17:00:31.679]         ...future.stdout <- NULL
[17:00:31.679]     }
[17:00:31.679]     ...future.result$conditions <- ...future.conditions
[17:00:31.679]     ...future.result$finished <- base::Sys.time()
[17:00:31.679]     ...future.result
[17:00:31.679] }
[17:00:31.682] assign_globals() ...
[17:00:31.682] List of 5
[17:00:31.682]  $ ...future.FUN            :function (x)  
[17:00:31.682]  $ MoreArgs                 : NULL
[17:00:31.682]  $ ...future.elements_ii    :List of 1
[17:00:31.682]   ..$ :List of 1
[17:00:31.682]   .. ..$ b: num 0
[17:00:31.682]  $ ...future.seeds_ii       : NULL
[17:00:31.682]  $ ...future.globals.maxSize: NULL
[17:00:31.682]  - attr(*, "where")=List of 5
[17:00:31.682]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:00:31.682]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:00:31.682]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:00:31.682]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:00:31.682]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:00:31.682]  - attr(*, "resolved")= logi FALSE
[17:00:31.682]  - attr(*, "total_size")= num 904
[17:00:31.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:31.682]  - attr(*, "already-done")= logi TRUE
[17:00:31.696] - copied ‘...future.FUN’ to environment
[17:00:31.697] - copied ‘MoreArgs’ to environment
[17:00:31.697] - copied ‘...future.elements_ii’ to environment
[17:00:31.697] - copied ‘...future.seeds_ii’ to environment
[17:00:31.697] - copied ‘...future.globals.maxSize’ to environment
[17:00:31.697] assign_globals() ... done
[17:00:31.697] requestCore(): workers = 2
[17:00:31.700] MulticoreFuture started
[17:00:31.701] - Launch lazy future ... done
[17:00:31.701] plan(): Setting new future strategy stack:
[17:00:31.701] run() for ‘MulticoreFuture’ ... done
[17:00:31.702] Created future:
[17:00:31.702] List of future strategies:
[17:00:31.702] 1. sequential:
[17:00:31.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.702]    - tweaked: FALSE
[17:00:31.702]    - call: NULL
[17:00:31.703] plan(): nbrOfWorkers() = 1
[17:00:31.706] plan(): Setting new future strategy stack:
[17:00:31.706] List of future strategies:
[17:00:31.706] 1. multicore:
[17:00:31.706]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:00:31.706]    - tweaked: FALSE
[17:00:31.706]    - call: plan(strategy)
[17:00:31.712] plan(): nbrOfWorkers() = 2
[17:00:31.702] MulticoreFuture:
[17:00:31.702] Label: ‘future_mapply-2’
[17:00:31.702] Expression:
[17:00:31.702] {
[17:00:31.702]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:31.702]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:31.702]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:31.702]         on.exit(options(oopts), add = TRUE)
[17:00:31.702]     }
[17:00:31.702]     {
[17:00:31.702]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:31.702]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:31.702]         do.call(mapply, args = args)
[17:00:31.702]     }
[17:00:31.702] }
[17:00:31.702] Lazy evaluation: FALSE
[17:00:31.702] Asynchronous evaluation: TRUE
[17:00:31.702] Local evaluation: TRUE
[17:00:31.702] Environment: R_GlobalEnv
[17:00:31.702] Capture standard output: TRUE
[17:00:31.702] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:31.702] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:31.702] Packages: <none>
[17:00:31.702] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:31.702] Resolved: TRUE
[17:00:31.702] Value: <not collected>
[17:00:31.702] Conditions captured: <none>
[17:00:31.702] Early signaling: FALSE
[17:00:31.702] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:31.702] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:31.713] Chunk #2 of 2 ... DONE
[17:00:31.713] Launching 2 futures (chunks) ... DONE
[17:00:31.713] Resolving 2 futures (chunks) ...
[17:00:31.713] resolve() on list ...
[17:00:31.714]  recursive: 0
[17:00:31.714]  length: 2
[17:00:31.714] 
[17:00:31.714] Future #1
[17:00:31.715] result() for MulticoreFuture ...
[17:00:31.716] result() for MulticoreFuture ...
[17:00:31.716] result() for MulticoreFuture ... done
[17:00:31.716] result() for MulticoreFuture ... done
[17:00:31.716] result() for MulticoreFuture ...
[17:00:31.716] result() for MulticoreFuture ... done
[17:00:31.716] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:00:31.717] - nx: 2
[17:00:31.717] - relay: TRUE
[17:00:31.717] - stdout: TRUE
[17:00:31.717] - signal: TRUE
[17:00:31.717] - resignal: FALSE
[17:00:31.717] - force: TRUE
[17:00:31.718] - relayed: [n=2] FALSE, FALSE
[17:00:31.718] - queued futures: [n=2] FALSE, FALSE
[17:00:31.718]  - until=1
[17:00:31.718]  - relaying element #1
[17:00:31.718] result() for MulticoreFuture ...
[17:00:31.718] result() for MulticoreFuture ... done
[17:00:31.718] result() for MulticoreFuture ...
[17:00:31.719] result() for MulticoreFuture ... done
[17:00:31.719] result() for MulticoreFuture ...
[17:00:31.719] result() for MulticoreFuture ... done
[17:00:31.719] result() for MulticoreFuture ...
[17:00:31.719] result() for MulticoreFuture ... done
[17:00:31.720] - relayed: [n=2] TRUE, FALSE
[17:00:31.720] - queued futures: [n=2] TRUE, FALSE
[17:00:31.720] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:00:31.720]  length: 1 (resolved future 1)
[17:00:31.720] Future #2
[17:00:31.721] result() for MulticoreFuture ...
[17:00:31.721] result() for MulticoreFuture ...
[17:00:31.721] result() for MulticoreFuture ... done
[17:00:31.722] result() for MulticoreFuture ... done
[17:00:31.722] result() for MulticoreFuture ...
[17:00:31.722] result() for MulticoreFuture ... done
[17:00:31.722] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:00:31.722] - nx: 2
[17:00:31.722] - relay: TRUE
[17:00:31.722] - stdout: TRUE
[17:00:31.723] - signal: TRUE
[17:00:31.723] - resignal: FALSE
[17:00:31.723] - force: TRUE
[17:00:31.723] - relayed: [n=2] TRUE, FALSE
[17:00:31.723] - queued futures: [n=2] TRUE, FALSE
[17:00:31.723]  - until=2
[17:00:31.723]  - relaying element #2
[17:00:31.723] result() for MulticoreFuture ...
[17:00:31.723] result() for MulticoreFuture ... done
[17:00:31.724] result() for MulticoreFuture ...
[17:00:31.724] result() for MulticoreFuture ... done
[17:00:31.724] result() for MulticoreFuture ...
[17:00:31.724] result() for MulticoreFuture ... done
[17:00:31.724] result() for MulticoreFuture ...
[17:00:31.724] result() for MulticoreFuture ... done
[17:00:31.724] - relayed: [n=2] TRUE, TRUE
[17:00:31.724] - queued futures: [n=2] TRUE, TRUE
[17:00:31.725] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:00:31.725]  length: 0 (resolved future 2)
[17:00:31.725] Relaying remaining futures
[17:00:31.725] signalConditionsASAP(NULL, pos=0) ...
[17:00:31.725] - nx: 2
[17:00:31.725] - relay: TRUE
[17:00:31.725] - stdout: TRUE
[17:00:31.725] - signal: TRUE
[17:00:31.725] - resignal: FALSE
[17:00:31.725] - force: TRUE
[17:00:31.726] - relayed: [n=2] TRUE, TRUE
[17:00:31.726] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:31.726] - relayed: [n=2] TRUE, TRUE
[17:00:31.726] - queued futures: [n=2] TRUE, TRUE
[17:00:31.726] signalConditionsASAP(NULL, pos=0) ... done
[17:00:31.726] resolve() on list ... DONE
[17:00:31.726] result() for MulticoreFuture ...
[17:00:31.726] result() for MulticoreFuture ... done
[17:00:31.727] result() for MulticoreFuture ...
[17:00:31.727] result() for MulticoreFuture ... done
[17:00:31.727] result() for MulticoreFuture ...
[17:00:31.727] result() for MulticoreFuture ... done
[17:00:31.727] result() for MulticoreFuture ...
[17:00:31.727] result() for MulticoreFuture ... done
[17:00:31.727]  - Number of value chunks collected: 2
[17:00:31.727] Resolving 2 futures (chunks) ... DONE
[17:00:31.728] Reducing values from 2 chunks ...
[17:00:31.728]  - Number of values collected after concatenation: 2
[17:00:31.728]  - Number of values expected: 2
[17:00:31.728] Reducing values from 2 chunks ... DONE
[17:00:31.728] future_mapply() ... DONE
[17:00:31.728] plan(): Setting new future strategy stack:
[17:00:31.728] List of future strategies:
[17:00:31.728] 1. sequential:
[17:00:31.728]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:31.728]    - tweaked: FALSE
[17:00:31.728]    - call: plan(sequential)
[17:00:31.732] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:00:31.733] plan(): Setting new future strategy stack:
[17:00:31.733] List of future strategies:
[17:00:31.733] 1. multisession:
[17:00:31.733]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:00:31.733]    - tweaked: FALSE
[17:00:31.733]    - call: plan(strategy)
[17:00:31.734] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:00:31.734] multisession:
[17:00:31.734] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:00:31.734] - tweaked: FALSE
[17:00:31.734] - call: plan(strategy)
[17:00:31.742] getGlobalsAndPackages() ...
[17:00:31.742] Not searching for globals
[17:00:31.742] - globals: [0] <none>
[17:00:31.742] getGlobalsAndPackages() ... DONE
[17:00:31.743] [local output] makeClusterPSOCK() ...
[17:00:31.798] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:00:31.799] [local output] Base port: 11852
[17:00:31.799] [local output] Getting setup options for 2 cluster nodes ...
[17:00:31.799] [local output]  - Node 1 of 2 ...
[17:00:31.799] [local output] localMachine=TRUE => revtunnel=FALSE

[17:00:31.800] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpcgMQPN/worker.rank=1.parallelly.parent=34421.867514bb377e.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpcgMQPN/worker.rank=1.parallelly.parent=34421.867514bb377e.pid")'’
[17:00:31.991] - Possible to infer worker's PID: TRUE
[17:00:31.991] [local output] Rscript port: 11852

[17:00:31.992] [local output]  - Node 2 of 2 ...
[17:00:31.992] [local output] localMachine=TRUE => revtunnel=FALSE

[17:00:31.993] [local output] Rscript port: 11852

[17:00:31.993] [local output] Getting setup options for 2 cluster nodes ... done
[17:00:31.993] [local output]  - Parallel setup requested for some PSOCK nodes
[17:00:31.994] [local output] Setting up PSOCK nodes in parallel
[17:00:31.994] List of 36
[17:00:31.994]  $ worker          : chr "localhost"
[17:00:31.994]   ..- attr(*, "localhost")= logi TRUE
[17:00:31.994]  $ master          : chr "localhost"
[17:00:31.994]  $ port            : int 11852
[17:00:31.994]  $ connectTimeout  : num 120
[17:00:31.994]  $ timeout         : num 2592000
[17:00:31.994]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:00:31.994]  $ homogeneous     : logi TRUE
[17:00:31.994]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:00:31.994]  $ rscript_envs    : NULL
[17:00:31.994]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:00:31.994]  $ rscript_startup : NULL
[17:00:31.994]  $ rscript_sh      : chr "sh"
[17:00:31.994]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:00:31.994]  $ methods         : logi TRUE
[17:00:31.994]  $ socketOptions   : chr "no-delay"
[17:00:31.994]  $ useXDR          : logi FALSE
[17:00:31.994]  $ outfile         : chr "/dev/null"
[17:00:31.994]  $ renice          : int NA
[17:00:31.994]  $ rshcmd          : NULL
[17:00:31.994]  $ user            : chr(0) 
[17:00:31.994]  $ revtunnel       : logi FALSE
[17:00:31.994]  $ rshlogfile      : NULL
[17:00:31.994]  $ rshopts         : chr(0) 
[17:00:31.994]  $ rank            : int 1
[17:00:31.994]  $ manual          : logi FALSE
[17:00:31.994]  $ dryrun          : logi FALSE
[17:00:31.994]  $ quiet           : logi FALSE
[17:00:31.994]  $ setup_strategy  : chr "parallel"
[17:00:31.994]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:00:31.994]  $ pidfile         : chr "/tmp/RtmpcgMQPN/worker.rank=1.parallelly.parent=34421.867514bb377e.pid"
[17:00:31.994]  $ rshcmd_label    : NULL
[17:00:31.994]  $ rsh_call        : NULL
[17:00:31.994]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:00:31.994]  $ localMachine    : logi TRUE
[17:00:31.994]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:00:31.994]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:00:31.994]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:00:31.994]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:00:31.994]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:00:31.994]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:00:31.994]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:00:31.994]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:00:31.994]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:00:31.994]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:00:31.994]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:00:31.994]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:00:31.994]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:00:31.994]  $ arguments       :List of 28
[17:00:31.994]   ..$ worker          : chr "localhost"
[17:00:31.994]   ..$ master          : NULL
[17:00:31.994]   ..$ port            : int 11852
[17:00:31.994]   ..$ connectTimeout  : num 120
[17:00:31.994]   ..$ timeout         : num 2592000
[17:00:31.994]   ..$ rscript         : NULL
[17:00:31.994]   ..$ homogeneous     : NULL
[17:00:31.994]   ..$ rscript_args    : NULL
[17:00:31.994]   ..$ rscript_envs    : NULL
[17:00:31.994]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:00:31.994]   ..$ rscript_startup : NULL
[17:00:31.994]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:00:31.994]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:00:31.994]   ..$ methods         : logi TRUE
[17:00:31.994]   ..$ socketOptions   : chr "no-delay"
[17:00:31.994]   ..$ useXDR          : logi FALSE
[17:00:31.994]   ..$ outfile         : chr "/dev/null"
[17:00:31.994]   ..$ renice          : int NA
[17:00:31.994]   ..$ rshcmd          : NULL
[17:00:31.994]   ..$ user            : NULL
[17:00:31.994]   ..$ revtunnel       : logi NA
[17:00:31.994]   ..$ rshlogfile      : NULL
[17:00:31.994]   ..$ rshopts         : NULL
[17:00:31.994]   ..$ rank            : int 1
[17:00:31.994]   ..$ manual          : logi FALSE
[17:00:31.994]   ..$ dryrun          : logi FALSE
[17:00:31.994]   ..$ quiet           : logi FALSE
[17:00:31.994]   ..$ setup_strategy  : chr "parallel"
[17:00:31.994]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:00:32.011] [local output] System call to launch all workers:
[17:00:32.011] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpcgMQPN/worker.rank=1.parallelly.parent=34421.867514bb377e.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11852 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:00:32.011] [local output] Starting PSOCK main server
[17:00:32.017] [local output] Workers launched
[17:00:32.017] [local output] Waiting for workers to connect back
[17:00:32.017]  - [local output] 0 workers out of 2 ready
[17:00:32.262]  - [local output] 0 workers out of 2 ready
[17:00:32.263]  - [local output] 1 workers out of 2 ready
[17:00:32.274]  - [local output] 1 workers out of 2 ready
[17:00:32.274]  - [local output] 2 workers out of 2 ready
[17:00:32.274] [local output] Launching of workers completed
[17:00:32.274] [local output] Collecting session information from workers
[17:00:32.275] [local output]  - Worker #1 of 2
[17:00:32.276] [local output]  - Worker #2 of 2
[17:00:32.276] [local output] makeClusterPSOCK() ... done
[17:00:32.288] Packages needed by the future expression (n = 0): <none>
[17:00:32.288] Packages needed by future strategies (n = 0): <none>
[17:00:32.288] {
[17:00:32.288]     {
[17:00:32.288]         {
[17:00:32.288]             ...future.startTime <- base::Sys.time()
[17:00:32.288]             {
[17:00:32.288]                 {
[17:00:32.288]                   {
[17:00:32.288]                     {
[17:00:32.288]                       base::local({
[17:00:32.288]                         has_future <- base::requireNamespace("future", 
[17:00:32.288]                           quietly = TRUE)
[17:00:32.288]                         if (has_future) {
[17:00:32.288]                           ns <- base::getNamespace("future")
[17:00:32.288]                           version <- ns[[".package"]][["version"]]
[17:00:32.288]                           if (is.null(version)) 
[17:00:32.288]                             version <- utils::packageVersion("future")
[17:00:32.288]                         }
[17:00:32.288]                         else {
[17:00:32.288]                           version <- NULL
[17:00:32.288]                         }
[17:00:32.288]                         if (!has_future || version < "1.8.0") {
[17:00:32.288]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:32.288]                             "", base::R.version$version.string), 
[17:00:32.288]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:32.288]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:32.288]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:32.288]                               "release", "version")], collapse = " "), 
[17:00:32.288]                             hostname = base::Sys.info()[["nodename"]])
[17:00:32.288]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:32.288]                             info)
[17:00:32.288]                           info <- base::paste(info, collapse = "; ")
[17:00:32.288]                           if (!has_future) {
[17:00:32.288]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:32.288]                               info)
[17:00:32.288]                           }
[17:00:32.288]                           else {
[17:00:32.288]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:32.288]                               info, version)
[17:00:32.288]                           }
[17:00:32.288]                           base::stop(msg)
[17:00:32.288]                         }
[17:00:32.288]                       })
[17:00:32.288]                     }
[17:00:32.288]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:32.288]                     base::options(mc.cores = 1L)
[17:00:32.288]                   }
[17:00:32.288]                   ...future.strategy.old <- future::plan("list")
[17:00:32.288]                   options(future.plan = NULL)
[17:00:32.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:32.288]                 }
[17:00:32.288]                 ...future.workdir <- getwd()
[17:00:32.288]             }
[17:00:32.288]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:32.288]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:32.288]         }
[17:00:32.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:32.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:32.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:32.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:32.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:32.288]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:32.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:32.288]             base::names(...future.oldOptions))
[17:00:32.288]     }
[17:00:32.288]     if (FALSE) {
[17:00:32.288]     }
[17:00:32.288]     else {
[17:00:32.288]         if (TRUE) {
[17:00:32.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:32.288]                 open = "w")
[17:00:32.288]         }
[17:00:32.288]         else {
[17:00:32.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:32.288]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:32.288]         }
[17:00:32.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:32.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:32.288]             base::sink(type = "output", split = FALSE)
[17:00:32.288]             base::close(...future.stdout)
[17:00:32.288]         }, add = TRUE)
[17:00:32.288]     }
[17:00:32.288]     ...future.frame <- base::sys.nframe()
[17:00:32.288]     ...future.conditions <- base::list()
[17:00:32.288]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:32.288]     if (FALSE) {
[17:00:32.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:32.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:32.288]     }
[17:00:32.288]     ...future.result <- base::tryCatch({
[17:00:32.288]         base::withCallingHandlers({
[17:00:32.288]             ...future.value <- base::withVisible(base::local({
[17:00:32.288]                 ...future.makeSendCondition <- base::local({
[17:00:32.288]                   sendCondition <- NULL
[17:00:32.288]                   function(frame = 1L) {
[17:00:32.288]                     if (is.function(sendCondition)) 
[17:00:32.288]                       return(sendCondition)
[17:00:32.288]                     ns <- getNamespace("parallel")
[17:00:32.288]                     if (exists("sendData", mode = "function", 
[17:00:32.288]                       envir = ns)) {
[17:00:32.288]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:32.288]                         envir = ns)
[17:00:32.288]                       envir <- sys.frame(frame)
[17:00:32.288]                       master <- NULL
[17:00:32.288]                       while (!identical(envir, .GlobalEnv) && 
[17:00:32.288]                         !identical(envir, emptyenv())) {
[17:00:32.288]                         if (exists("master", mode = "list", envir = envir, 
[17:00:32.288]                           inherits = FALSE)) {
[17:00:32.288]                           master <- get("master", mode = "list", 
[17:00:32.288]                             envir = envir, inherits = FALSE)
[17:00:32.288]                           if (inherits(master, c("SOCKnode", 
[17:00:32.288]                             "SOCK0node"))) {
[17:00:32.288]                             sendCondition <<- function(cond) {
[17:00:32.288]                               data <- list(type = "VALUE", value = cond, 
[17:00:32.288]                                 success = TRUE)
[17:00:32.288]                               parallel_sendData(master, data)
[17:00:32.288]                             }
[17:00:32.288]                             return(sendCondition)
[17:00:32.288]                           }
[17:00:32.288]                         }
[17:00:32.288]                         frame <- frame + 1L
[17:00:32.288]                         envir <- sys.frame(frame)
[17:00:32.288]                       }
[17:00:32.288]                     }
[17:00:32.288]                     sendCondition <<- function(cond) NULL
[17:00:32.288]                   }
[17:00:32.288]                 })
[17:00:32.288]                 withCallingHandlers({
[17:00:32.288]                   NA
[17:00:32.288]                 }, immediateCondition = function(cond) {
[17:00:32.288]                   sendCondition <- ...future.makeSendCondition()
[17:00:32.288]                   sendCondition(cond)
[17:00:32.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.288]                   {
[17:00:32.288]                     inherits <- base::inherits
[17:00:32.288]                     invokeRestart <- base::invokeRestart
[17:00:32.288]                     is.null <- base::is.null
[17:00:32.288]                     muffled <- FALSE
[17:00:32.288]                     if (inherits(cond, "message")) {
[17:00:32.288]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:32.288]                       if (muffled) 
[17:00:32.288]                         invokeRestart("muffleMessage")
[17:00:32.288]                     }
[17:00:32.288]                     else if (inherits(cond, "warning")) {
[17:00:32.288]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:32.288]                       if (muffled) 
[17:00:32.288]                         invokeRestart("muffleWarning")
[17:00:32.288]                     }
[17:00:32.288]                     else if (inherits(cond, "condition")) {
[17:00:32.288]                       if (!is.null(pattern)) {
[17:00:32.288]                         computeRestarts <- base::computeRestarts
[17:00:32.288]                         grepl <- base::grepl
[17:00:32.288]                         restarts <- computeRestarts(cond)
[17:00:32.288]                         for (restart in restarts) {
[17:00:32.288]                           name <- restart$name
[17:00:32.288]                           if (is.null(name)) 
[17:00:32.288]                             next
[17:00:32.288]                           if (!grepl(pattern, name)) 
[17:00:32.288]                             next
[17:00:32.288]                           invokeRestart(restart)
[17:00:32.288]                           muffled <- TRUE
[17:00:32.288]                           break
[17:00:32.288]                         }
[17:00:32.288]                       }
[17:00:32.288]                     }
[17:00:32.288]                     invisible(muffled)
[17:00:32.288]                   }
[17:00:32.288]                   muffleCondition(cond)
[17:00:32.288]                 })
[17:00:32.288]             }))
[17:00:32.288]             future::FutureResult(value = ...future.value$value, 
[17:00:32.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.288]                   ...future.rng), globalenv = if (FALSE) 
[17:00:32.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:32.288]                     ...future.globalenv.names))
[17:00:32.288]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:32.288]         }, condition = base::local({
[17:00:32.288]             c <- base::c
[17:00:32.288]             inherits <- base::inherits
[17:00:32.288]             invokeRestart <- base::invokeRestart
[17:00:32.288]             length <- base::length
[17:00:32.288]             list <- base::list
[17:00:32.288]             seq.int <- base::seq.int
[17:00:32.288]             signalCondition <- base::signalCondition
[17:00:32.288]             sys.calls <- base::sys.calls
[17:00:32.288]             `[[` <- base::`[[`
[17:00:32.288]             `+` <- base::`+`
[17:00:32.288]             `<<-` <- base::`<<-`
[17:00:32.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:32.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:32.288]                   3L)]
[17:00:32.288]             }
[17:00:32.288]             function(cond) {
[17:00:32.288]                 is_error <- inherits(cond, "error")
[17:00:32.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:32.288]                   NULL)
[17:00:32.288]                 if (is_error) {
[17:00:32.288]                   sessionInformation <- function() {
[17:00:32.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:32.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:32.288]                       search = base::search(), system = base::Sys.info())
[17:00:32.288]                   }
[17:00:32.288]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:32.288]                     cond$call), session = sessionInformation(), 
[17:00:32.288]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:32.288]                   signalCondition(cond)
[17:00:32.288]                 }
[17:00:32.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:32.288]                 "immediateCondition"))) {
[17:00:32.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:32.288]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:32.288]                   if (TRUE && !signal) {
[17:00:32.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.288]                     {
[17:00:32.288]                       inherits <- base::inherits
[17:00:32.288]                       invokeRestart <- base::invokeRestart
[17:00:32.288]                       is.null <- base::is.null
[17:00:32.288]                       muffled <- FALSE
[17:00:32.288]                       if (inherits(cond, "message")) {
[17:00:32.288]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.288]                         if (muffled) 
[17:00:32.288]                           invokeRestart("muffleMessage")
[17:00:32.288]                       }
[17:00:32.288]                       else if (inherits(cond, "warning")) {
[17:00:32.288]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.288]                         if (muffled) 
[17:00:32.288]                           invokeRestart("muffleWarning")
[17:00:32.288]                       }
[17:00:32.288]                       else if (inherits(cond, "condition")) {
[17:00:32.288]                         if (!is.null(pattern)) {
[17:00:32.288]                           computeRestarts <- base::computeRestarts
[17:00:32.288]                           grepl <- base::grepl
[17:00:32.288]                           restarts <- computeRestarts(cond)
[17:00:32.288]                           for (restart in restarts) {
[17:00:32.288]                             name <- restart$name
[17:00:32.288]                             if (is.null(name)) 
[17:00:32.288]                               next
[17:00:32.288]                             if (!grepl(pattern, name)) 
[17:00:32.288]                               next
[17:00:32.288]                             invokeRestart(restart)
[17:00:32.288]                             muffled <- TRUE
[17:00:32.288]                             break
[17:00:32.288]                           }
[17:00:32.288]                         }
[17:00:32.288]                       }
[17:00:32.288]                       invisible(muffled)
[17:00:32.288]                     }
[17:00:32.288]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.288]                   }
[17:00:32.288]                 }
[17:00:32.288]                 else {
[17:00:32.288]                   if (TRUE) {
[17:00:32.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.288]                     {
[17:00:32.288]                       inherits <- base::inherits
[17:00:32.288]                       invokeRestart <- base::invokeRestart
[17:00:32.288]                       is.null <- base::is.null
[17:00:32.288]                       muffled <- FALSE
[17:00:32.288]                       if (inherits(cond, "message")) {
[17:00:32.288]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.288]                         if (muffled) 
[17:00:32.288]                           invokeRestart("muffleMessage")
[17:00:32.288]                       }
[17:00:32.288]                       else if (inherits(cond, "warning")) {
[17:00:32.288]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.288]                         if (muffled) 
[17:00:32.288]                           invokeRestart("muffleWarning")
[17:00:32.288]                       }
[17:00:32.288]                       else if (inherits(cond, "condition")) {
[17:00:32.288]                         if (!is.null(pattern)) {
[17:00:32.288]                           computeRestarts <- base::computeRestarts
[17:00:32.288]                           grepl <- base::grepl
[17:00:32.288]                           restarts <- computeRestarts(cond)
[17:00:32.288]                           for (restart in restarts) {
[17:00:32.288]                             name <- restart$name
[17:00:32.288]                             if (is.null(name)) 
[17:00:32.288]                               next
[17:00:32.288]                             if (!grepl(pattern, name)) 
[17:00:32.288]                               next
[17:00:32.288]                             invokeRestart(restart)
[17:00:32.288]                             muffled <- TRUE
[17:00:32.288]                             break
[17:00:32.288]                           }
[17:00:32.288]                         }
[17:00:32.288]                       }
[17:00:32.288]                       invisible(muffled)
[17:00:32.288]                     }
[17:00:32.288]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.288]                   }
[17:00:32.288]                 }
[17:00:32.288]             }
[17:00:32.288]         }))
[17:00:32.288]     }, error = function(ex) {
[17:00:32.288]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:32.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.288]                 ...future.rng), started = ...future.startTime, 
[17:00:32.288]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:32.288]             version = "1.8"), class = "FutureResult")
[17:00:32.288]     }, finally = {
[17:00:32.288]         if (!identical(...future.workdir, getwd())) 
[17:00:32.288]             setwd(...future.workdir)
[17:00:32.288]         {
[17:00:32.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:32.288]                 ...future.oldOptions$nwarnings <- NULL
[17:00:32.288]             }
[17:00:32.288]             base::options(...future.oldOptions)
[17:00:32.288]             if (.Platform$OS.type == "windows") {
[17:00:32.288]                 old_names <- names(...future.oldEnvVars)
[17:00:32.288]                 envs <- base::Sys.getenv()
[17:00:32.288]                 names <- names(envs)
[17:00:32.288]                 common <- intersect(names, old_names)
[17:00:32.288]                 added <- setdiff(names, old_names)
[17:00:32.288]                 removed <- setdiff(old_names, names)
[17:00:32.288]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:32.288]                   envs[common]]
[17:00:32.288]                 NAMES <- toupper(changed)
[17:00:32.288]                 args <- list()
[17:00:32.288]                 for (kk in seq_along(NAMES)) {
[17:00:32.288]                   name <- changed[[kk]]
[17:00:32.288]                   NAME <- NAMES[[kk]]
[17:00:32.288]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.288]                     next
[17:00:32.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.288]                 }
[17:00:32.288]                 NAMES <- toupper(added)
[17:00:32.288]                 for (kk in seq_along(NAMES)) {
[17:00:32.288]                   name <- added[[kk]]
[17:00:32.288]                   NAME <- NAMES[[kk]]
[17:00:32.288]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.288]                     next
[17:00:32.288]                   args[[name]] <- ""
[17:00:32.288]                 }
[17:00:32.288]                 NAMES <- toupper(removed)
[17:00:32.288]                 for (kk in seq_along(NAMES)) {
[17:00:32.288]                   name <- removed[[kk]]
[17:00:32.288]                   NAME <- NAMES[[kk]]
[17:00:32.288]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.288]                     next
[17:00:32.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.288]                 }
[17:00:32.288]                 if (length(args) > 0) 
[17:00:32.288]                   base::do.call(base::Sys.setenv, args = args)
[17:00:32.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:32.288]             }
[17:00:32.288]             else {
[17:00:32.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:32.288]             }
[17:00:32.288]             {
[17:00:32.288]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:32.288]                   0L) {
[17:00:32.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:32.288]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:32.288]                   base::options(opts)
[17:00:32.288]                 }
[17:00:32.288]                 {
[17:00:32.288]                   {
[17:00:32.288]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:32.288]                     NULL
[17:00:32.288]                   }
[17:00:32.288]                   options(future.plan = NULL)
[17:00:32.288]                   if (is.na(NA_character_)) 
[17:00:32.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:32.288]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:32.288]                     .init = FALSE)
[17:00:32.288]                 }
[17:00:32.288]             }
[17:00:32.288]         }
[17:00:32.288]     })
[17:00:32.288]     if (TRUE) {
[17:00:32.288]         base::sink(type = "output", split = FALSE)
[17:00:32.288]         if (TRUE) {
[17:00:32.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:32.288]         }
[17:00:32.288]         else {
[17:00:32.288]             ...future.result["stdout"] <- base::list(NULL)
[17:00:32.288]         }
[17:00:32.288]         base::close(...future.stdout)
[17:00:32.288]         ...future.stdout <- NULL
[17:00:32.288]     }
[17:00:32.288]     ...future.result$conditions <- ...future.conditions
[17:00:32.288]     ...future.result$finished <- base::Sys.time()
[17:00:32.288]     ...future.result
[17:00:32.288] }
[17:00:32.343] MultisessionFuture started
[17:00:32.343] result() for ClusterFuture ...
[17:00:32.344] receiveMessageFromWorker() for ClusterFuture ...
[17:00:32.344] - Validating connection of MultisessionFuture
[17:00:32.376] - received message: FutureResult
[17:00:32.376] - Received FutureResult
[17:00:32.377] - Erased future from FutureRegistry
[17:00:32.377] result() for ClusterFuture ...
[17:00:32.377] - result already collected: FutureResult
[17:00:32.377] result() for ClusterFuture ... done
[17:00:32.377] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:32.377] result() for ClusterFuture ... done
[17:00:32.377] result() for ClusterFuture ...
[17:00:32.377] - result already collected: FutureResult
[17:00:32.377] result() for ClusterFuture ... done
[17:00:32.378] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:00:32.382] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[17:00:32.382] future_mapply() ...
[17:00:32.386] Number of chunks: 2
[17:00:32.386] getGlobalsAndPackagesXApply() ...
[17:00:32.386]  - future.globals: TRUE
[17:00:32.386] getGlobalsAndPackages() ...
[17:00:32.387] Searching for globals...
[17:00:32.387] - globals found: [1] ‘FUN’
[17:00:32.388] Searching for globals ... DONE
[17:00:32.388] Resolving globals: FALSE
[17:00:32.388] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:32.388] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:32.389] - globals: [1] ‘FUN’
[17:00:32.389] 
[17:00:32.389] getGlobalsAndPackages() ... DONE
[17:00:32.389]  - globals found/used: [n=1] ‘FUN’
[17:00:32.389]  - needed namespaces: [n=0] 
[17:00:32.389] Finding globals ... DONE
[17:00:32.389] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:32.389] List of 2
[17:00:32.389]  $ ...future.FUN:function (x, ...)  
[17:00:32.389]  $ MoreArgs     : NULL
[17:00:32.389]  - attr(*, "where")=List of 2
[17:00:32.389]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:32.389]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:32.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:32.389]  - attr(*, "resolved")= logi FALSE
[17:00:32.389]  - attr(*, "total_size")= num NA
[17:00:32.393] Packages to be attached in all futures: [n=0] 
[17:00:32.393] getGlobalsAndPackagesXApply() ... DONE
[17:00:32.393] Number of futures (= number of chunks): 2
[17:00:32.393] Launching 2 futures (chunks) ...
[17:00:32.393] Chunk #1 of 2 ...
[17:00:32.393]  - Finding globals in '...' for chunk #1 ...
[17:00:32.393] getGlobalsAndPackages() ...
[17:00:32.394] Searching for globals...
[17:00:32.394] 
[17:00:32.394] Searching for globals ... DONE
[17:00:32.394] - globals: [0] <none>
[17:00:32.394] getGlobalsAndPackages() ... DONE
[17:00:32.394]    + additional globals found: [n=0] 
[17:00:32.394]    + additional namespaces needed: [n=0] 
[17:00:32.395]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:32.395]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:32.395]  - seeds: <none>
[17:00:32.395]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.395] getGlobalsAndPackages() ...
[17:00:32.395] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.395] Resolving globals: FALSE
[17:00:32.396] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:32.396] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:32.397] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.397] 
[17:00:32.397] getGlobalsAndPackages() ... DONE
[17:00:32.397] run() for ‘Future’ ...
[17:00:32.397] - state: ‘created’
[17:00:32.397] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:32.412] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:32.413]   - Field: ‘node’
[17:00:32.413]   - Field: ‘label’
[17:00:32.413]   - Field: ‘local’
[17:00:32.413]   - Field: ‘owner’
[17:00:32.413]   - Field: ‘envir’
[17:00:32.413]   - Field: ‘workers’
[17:00:32.413]   - Field: ‘packages’
[17:00:32.413]   - Field: ‘gc’
[17:00:32.413]   - Field: ‘conditions’
[17:00:32.414]   - Field: ‘persistent’
[17:00:32.414]   - Field: ‘expr’
[17:00:32.414]   - Field: ‘uuid’
[17:00:32.414]   - Field: ‘seed’
[17:00:32.414]   - Field: ‘version’
[17:00:32.414]   - Field: ‘result’
[17:00:32.414]   - Field: ‘asynchronous’
[17:00:32.414]   - Field: ‘calls’
[17:00:32.415]   - Field: ‘globals’
[17:00:32.415]   - Field: ‘stdout’
[17:00:32.415]   - Field: ‘earlySignal’
[17:00:32.415]   - Field: ‘lazy’
[17:00:32.415]   - Field: ‘state’
[17:00:32.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:32.415] - Launch lazy future ...
[17:00:32.416] Packages needed by the future expression (n = 0): <none>
[17:00:32.416] Packages needed by future strategies (n = 0): <none>
[17:00:32.416] {
[17:00:32.416]     {
[17:00:32.416]         {
[17:00:32.416]             ...future.startTime <- base::Sys.time()
[17:00:32.416]             {
[17:00:32.416]                 {
[17:00:32.416]                   {
[17:00:32.416]                     {
[17:00:32.416]                       base::local({
[17:00:32.416]                         has_future <- base::requireNamespace("future", 
[17:00:32.416]                           quietly = TRUE)
[17:00:32.416]                         if (has_future) {
[17:00:32.416]                           ns <- base::getNamespace("future")
[17:00:32.416]                           version <- ns[[".package"]][["version"]]
[17:00:32.416]                           if (is.null(version)) 
[17:00:32.416]                             version <- utils::packageVersion("future")
[17:00:32.416]                         }
[17:00:32.416]                         else {
[17:00:32.416]                           version <- NULL
[17:00:32.416]                         }
[17:00:32.416]                         if (!has_future || version < "1.8.0") {
[17:00:32.416]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:32.416]                             "", base::R.version$version.string), 
[17:00:32.416]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:32.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:32.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:32.416]                               "release", "version")], collapse = " "), 
[17:00:32.416]                             hostname = base::Sys.info()[["nodename"]])
[17:00:32.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:32.416]                             info)
[17:00:32.416]                           info <- base::paste(info, collapse = "; ")
[17:00:32.416]                           if (!has_future) {
[17:00:32.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:32.416]                               info)
[17:00:32.416]                           }
[17:00:32.416]                           else {
[17:00:32.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:32.416]                               info, version)
[17:00:32.416]                           }
[17:00:32.416]                           base::stop(msg)
[17:00:32.416]                         }
[17:00:32.416]                       })
[17:00:32.416]                     }
[17:00:32.416]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:32.416]                     base::options(mc.cores = 1L)
[17:00:32.416]                   }
[17:00:32.416]                   ...future.strategy.old <- future::plan("list")
[17:00:32.416]                   options(future.plan = NULL)
[17:00:32.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:32.416]                 }
[17:00:32.416]                 ...future.workdir <- getwd()
[17:00:32.416]             }
[17:00:32.416]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:32.416]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:32.416]         }
[17:00:32.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:32.416]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:32.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:32.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:32.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:32.416]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:32.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:32.416]             base::names(...future.oldOptions))
[17:00:32.416]     }
[17:00:32.416]     if (FALSE) {
[17:00:32.416]     }
[17:00:32.416]     else {
[17:00:32.416]         if (TRUE) {
[17:00:32.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:32.416]                 open = "w")
[17:00:32.416]         }
[17:00:32.416]         else {
[17:00:32.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:32.416]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:32.416]         }
[17:00:32.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:32.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:32.416]             base::sink(type = "output", split = FALSE)
[17:00:32.416]             base::close(...future.stdout)
[17:00:32.416]         }, add = TRUE)
[17:00:32.416]     }
[17:00:32.416]     ...future.frame <- base::sys.nframe()
[17:00:32.416]     ...future.conditions <- base::list()
[17:00:32.416]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:32.416]     if (FALSE) {
[17:00:32.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:32.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:32.416]     }
[17:00:32.416]     ...future.result <- base::tryCatch({
[17:00:32.416]         base::withCallingHandlers({
[17:00:32.416]             ...future.value <- base::withVisible(base::local({
[17:00:32.416]                 ...future.makeSendCondition <- base::local({
[17:00:32.416]                   sendCondition <- NULL
[17:00:32.416]                   function(frame = 1L) {
[17:00:32.416]                     if (is.function(sendCondition)) 
[17:00:32.416]                       return(sendCondition)
[17:00:32.416]                     ns <- getNamespace("parallel")
[17:00:32.416]                     if (exists("sendData", mode = "function", 
[17:00:32.416]                       envir = ns)) {
[17:00:32.416]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:32.416]                         envir = ns)
[17:00:32.416]                       envir <- sys.frame(frame)
[17:00:32.416]                       master <- NULL
[17:00:32.416]                       while (!identical(envir, .GlobalEnv) && 
[17:00:32.416]                         !identical(envir, emptyenv())) {
[17:00:32.416]                         if (exists("master", mode = "list", envir = envir, 
[17:00:32.416]                           inherits = FALSE)) {
[17:00:32.416]                           master <- get("master", mode = "list", 
[17:00:32.416]                             envir = envir, inherits = FALSE)
[17:00:32.416]                           if (inherits(master, c("SOCKnode", 
[17:00:32.416]                             "SOCK0node"))) {
[17:00:32.416]                             sendCondition <<- function(cond) {
[17:00:32.416]                               data <- list(type = "VALUE", value = cond, 
[17:00:32.416]                                 success = TRUE)
[17:00:32.416]                               parallel_sendData(master, data)
[17:00:32.416]                             }
[17:00:32.416]                             return(sendCondition)
[17:00:32.416]                           }
[17:00:32.416]                         }
[17:00:32.416]                         frame <- frame + 1L
[17:00:32.416]                         envir <- sys.frame(frame)
[17:00:32.416]                       }
[17:00:32.416]                     }
[17:00:32.416]                     sendCondition <<- function(cond) NULL
[17:00:32.416]                   }
[17:00:32.416]                 })
[17:00:32.416]                 withCallingHandlers({
[17:00:32.416]                   {
[17:00:32.416]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.416]                     if (!identical(...future.globals.maxSize.org, 
[17:00:32.416]                       ...future.globals.maxSize)) {
[17:00:32.416]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.416]                       on.exit(options(oopts), add = TRUE)
[17:00:32.416]                     }
[17:00:32.416]                     {
[17:00:32.416]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.416]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:32.416]                         USE.NAMES = FALSE)
[17:00:32.416]                       do.call(mapply, args = args)
[17:00:32.416]                     }
[17:00:32.416]                   }
[17:00:32.416]                 }, immediateCondition = function(cond) {
[17:00:32.416]                   sendCondition <- ...future.makeSendCondition()
[17:00:32.416]                   sendCondition(cond)
[17:00:32.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.416]                   {
[17:00:32.416]                     inherits <- base::inherits
[17:00:32.416]                     invokeRestart <- base::invokeRestart
[17:00:32.416]                     is.null <- base::is.null
[17:00:32.416]                     muffled <- FALSE
[17:00:32.416]                     if (inherits(cond, "message")) {
[17:00:32.416]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:32.416]                       if (muffled) 
[17:00:32.416]                         invokeRestart("muffleMessage")
[17:00:32.416]                     }
[17:00:32.416]                     else if (inherits(cond, "warning")) {
[17:00:32.416]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:32.416]                       if (muffled) 
[17:00:32.416]                         invokeRestart("muffleWarning")
[17:00:32.416]                     }
[17:00:32.416]                     else if (inherits(cond, "condition")) {
[17:00:32.416]                       if (!is.null(pattern)) {
[17:00:32.416]                         computeRestarts <- base::computeRestarts
[17:00:32.416]                         grepl <- base::grepl
[17:00:32.416]                         restarts <- computeRestarts(cond)
[17:00:32.416]                         for (restart in restarts) {
[17:00:32.416]                           name <- restart$name
[17:00:32.416]                           if (is.null(name)) 
[17:00:32.416]                             next
[17:00:32.416]                           if (!grepl(pattern, name)) 
[17:00:32.416]                             next
[17:00:32.416]                           invokeRestart(restart)
[17:00:32.416]                           muffled <- TRUE
[17:00:32.416]                           break
[17:00:32.416]                         }
[17:00:32.416]                       }
[17:00:32.416]                     }
[17:00:32.416]                     invisible(muffled)
[17:00:32.416]                   }
[17:00:32.416]                   muffleCondition(cond)
[17:00:32.416]                 })
[17:00:32.416]             }))
[17:00:32.416]             future::FutureResult(value = ...future.value$value, 
[17:00:32.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.416]                   ...future.rng), globalenv = if (FALSE) 
[17:00:32.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:32.416]                     ...future.globalenv.names))
[17:00:32.416]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:32.416]         }, condition = base::local({
[17:00:32.416]             c <- base::c
[17:00:32.416]             inherits <- base::inherits
[17:00:32.416]             invokeRestart <- base::invokeRestart
[17:00:32.416]             length <- base::length
[17:00:32.416]             list <- base::list
[17:00:32.416]             seq.int <- base::seq.int
[17:00:32.416]             signalCondition <- base::signalCondition
[17:00:32.416]             sys.calls <- base::sys.calls
[17:00:32.416]             `[[` <- base::`[[`
[17:00:32.416]             `+` <- base::`+`
[17:00:32.416]             `<<-` <- base::`<<-`
[17:00:32.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:32.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:32.416]                   3L)]
[17:00:32.416]             }
[17:00:32.416]             function(cond) {
[17:00:32.416]                 is_error <- inherits(cond, "error")
[17:00:32.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:32.416]                   NULL)
[17:00:32.416]                 if (is_error) {
[17:00:32.416]                   sessionInformation <- function() {
[17:00:32.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:32.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:32.416]                       search = base::search(), system = base::Sys.info())
[17:00:32.416]                   }
[17:00:32.416]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:32.416]                     cond$call), session = sessionInformation(), 
[17:00:32.416]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:32.416]                   signalCondition(cond)
[17:00:32.416]                 }
[17:00:32.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:32.416]                 "immediateCondition"))) {
[17:00:32.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:32.416]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:32.416]                   if (TRUE && !signal) {
[17:00:32.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.416]                     {
[17:00:32.416]                       inherits <- base::inherits
[17:00:32.416]                       invokeRestart <- base::invokeRestart
[17:00:32.416]                       is.null <- base::is.null
[17:00:32.416]                       muffled <- FALSE
[17:00:32.416]                       if (inherits(cond, "message")) {
[17:00:32.416]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.416]                         if (muffled) 
[17:00:32.416]                           invokeRestart("muffleMessage")
[17:00:32.416]                       }
[17:00:32.416]                       else if (inherits(cond, "warning")) {
[17:00:32.416]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.416]                         if (muffled) 
[17:00:32.416]                           invokeRestart("muffleWarning")
[17:00:32.416]                       }
[17:00:32.416]                       else if (inherits(cond, "condition")) {
[17:00:32.416]                         if (!is.null(pattern)) {
[17:00:32.416]                           computeRestarts <- base::computeRestarts
[17:00:32.416]                           grepl <- base::grepl
[17:00:32.416]                           restarts <- computeRestarts(cond)
[17:00:32.416]                           for (restart in restarts) {
[17:00:32.416]                             name <- restart$name
[17:00:32.416]                             if (is.null(name)) 
[17:00:32.416]                               next
[17:00:32.416]                             if (!grepl(pattern, name)) 
[17:00:32.416]                               next
[17:00:32.416]                             invokeRestart(restart)
[17:00:32.416]                             muffled <- TRUE
[17:00:32.416]                             break
[17:00:32.416]                           }
[17:00:32.416]                         }
[17:00:32.416]                       }
[17:00:32.416]                       invisible(muffled)
[17:00:32.416]                     }
[17:00:32.416]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.416]                   }
[17:00:32.416]                 }
[17:00:32.416]                 else {
[17:00:32.416]                   if (TRUE) {
[17:00:32.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.416]                     {
[17:00:32.416]                       inherits <- base::inherits
[17:00:32.416]                       invokeRestart <- base::invokeRestart
[17:00:32.416]                       is.null <- base::is.null
[17:00:32.416]                       muffled <- FALSE
[17:00:32.416]                       if (inherits(cond, "message")) {
[17:00:32.416]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.416]                         if (muffled) 
[17:00:32.416]                           invokeRestart("muffleMessage")
[17:00:32.416]                       }
[17:00:32.416]                       else if (inherits(cond, "warning")) {
[17:00:32.416]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.416]                         if (muffled) 
[17:00:32.416]                           invokeRestart("muffleWarning")
[17:00:32.416]                       }
[17:00:32.416]                       else if (inherits(cond, "condition")) {
[17:00:32.416]                         if (!is.null(pattern)) {
[17:00:32.416]                           computeRestarts <- base::computeRestarts
[17:00:32.416]                           grepl <- base::grepl
[17:00:32.416]                           restarts <- computeRestarts(cond)
[17:00:32.416]                           for (restart in restarts) {
[17:00:32.416]                             name <- restart$name
[17:00:32.416]                             if (is.null(name)) 
[17:00:32.416]                               next
[17:00:32.416]                             if (!grepl(pattern, name)) 
[17:00:32.416]                               next
[17:00:32.416]                             invokeRestart(restart)
[17:00:32.416]                             muffled <- TRUE
[17:00:32.416]                             break
[17:00:32.416]                           }
[17:00:32.416]                         }
[17:00:32.416]                       }
[17:00:32.416]                       invisible(muffled)
[17:00:32.416]                     }
[17:00:32.416]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.416]                   }
[17:00:32.416]                 }
[17:00:32.416]             }
[17:00:32.416]         }))
[17:00:32.416]     }, error = function(ex) {
[17:00:32.416]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:32.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.416]                 ...future.rng), started = ...future.startTime, 
[17:00:32.416]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:32.416]             version = "1.8"), class = "FutureResult")
[17:00:32.416]     }, finally = {
[17:00:32.416]         if (!identical(...future.workdir, getwd())) 
[17:00:32.416]             setwd(...future.workdir)
[17:00:32.416]         {
[17:00:32.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:32.416]                 ...future.oldOptions$nwarnings <- NULL
[17:00:32.416]             }
[17:00:32.416]             base::options(...future.oldOptions)
[17:00:32.416]             if (.Platform$OS.type == "windows") {
[17:00:32.416]                 old_names <- names(...future.oldEnvVars)
[17:00:32.416]                 envs <- base::Sys.getenv()
[17:00:32.416]                 names <- names(envs)
[17:00:32.416]                 common <- intersect(names, old_names)
[17:00:32.416]                 added <- setdiff(names, old_names)
[17:00:32.416]                 removed <- setdiff(old_names, names)
[17:00:32.416]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:32.416]                   envs[common]]
[17:00:32.416]                 NAMES <- toupper(changed)
[17:00:32.416]                 args <- list()
[17:00:32.416]                 for (kk in seq_along(NAMES)) {
[17:00:32.416]                   name <- changed[[kk]]
[17:00:32.416]                   NAME <- NAMES[[kk]]
[17:00:32.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.416]                     next
[17:00:32.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.416]                 }
[17:00:32.416]                 NAMES <- toupper(added)
[17:00:32.416]                 for (kk in seq_along(NAMES)) {
[17:00:32.416]                   name <- added[[kk]]
[17:00:32.416]                   NAME <- NAMES[[kk]]
[17:00:32.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.416]                     next
[17:00:32.416]                   args[[name]] <- ""
[17:00:32.416]                 }
[17:00:32.416]                 NAMES <- toupper(removed)
[17:00:32.416]                 for (kk in seq_along(NAMES)) {
[17:00:32.416]                   name <- removed[[kk]]
[17:00:32.416]                   NAME <- NAMES[[kk]]
[17:00:32.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.416]                     next
[17:00:32.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.416]                 }
[17:00:32.416]                 if (length(args) > 0) 
[17:00:32.416]                   base::do.call(base::Sys.setenv, args = args)
[17:00:32.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:32.416]             }
[17:00:32.416]             else {
[17:00:32.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:32.416]             }
[17:00:32.416]             {
[17:00:32.416]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:32.416]                   0L) {
[17:00:32.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:32.416]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:32.416]                   base::options(opts)
[17:00:32.416]                 }
[17:00:32.416]                 {
[17:00:32.416]                   {
[17:00:32.416]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:32.416]                     NULL
[17:00:32.416]                   }
[17:00:32.416]                   options(future.plan = NULL)
[17:00:32.416]                   if (is.na(NA_character_)) 
[17:00:32.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:32.416]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:32.416]                     .init = FALSE)
[17:00:32.416]                 }
[17:00:32.416]             }
[17:00:32.416]         }
[17:00:32.416]     })
[17:00:32.416]     if (TRUE) {
[17:00:32.416]         base::sink(type = "output", split = FALSE)
[17:00:32.416]         if (TRUE) {
[17:00:32.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:32.416]         }
[17:00:32.416]         else {
[17:00:32.416]             ...future.result["stdout"] <- base::list(NULL)
[17:00:32.416]         }
[17:00:32.416]         base::close(...future.stdout)
[17:00:32.416]         ...future.stdout <- NULL
[17:00:32.416]     }
[17:00:32.416]     ...future.result$conditions <- ...future.conditions
[17:00:32.416]     ...future.result$finished <- base::Sys.time()
[17:00:32.416]     ...future.result
[17:00:32.416] }
[17:00:32.419] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:00:32.420] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:00:32.420] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:00:32.420] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:32.421] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.421] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:00:32.421] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:00:32.421] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:32.422] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.422] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:32.422] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.422] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:00:32.423] MultisessionFuture started
[17:00:32.423] - Launch lazy future ... done
[17:00:32.423] run() for ‘MultisessionFuture’ ... done
[17:00:32.423] Created future:
[17:00:32.423] MultisessionFuture:
[17:00:32.423] Label: ‘future_mapply-1’
[17:00:32.423] Expression:
[17:00:32.423] {
[17:00:32.423]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.423]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:32.423]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.423]         on.exit(options(oopts), add = TRUE)
[17:00:32.423]     }
[17:00:32.423]     {
[17:00:32.423]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.423]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:32.423]         do.call(mapply, args = args)
[17:00:32.423]     }
[17:00:32.423] }
[17:00:32.423] Lazy evaluation: FALSE
[17:00:32.423] Asynchronous evaluation: TRUE
[17:00:32.423] Local evaluation: TRUE
[17:00:32.423] Environment: R_GlobalEnv
[17:00:32.423] Capture standard output: TRUE
[17:00:32.423] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:32.423] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:32.423] Packages: <none>
[17:00:32.423] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:32.423] Resolved: FALSE
[17:00:32.423] Value: <not collected>
[17:00:32.423] Conditions captured: <none>
[17:00:32.423] Early signaling: FALSE
[17:00:32.423] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:32.423] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.435] Chunk #1 of 2 ... DONE
[17:00:32.436] Chunk #2 of 2 ...
[17:00:32.436]  - Finding globals in '...' for chunk #2 ...
[17:00:32.436] getGlobalsAndPackages() ...
[17:00:32.436] Searching for globals...
[17:00:32.436] 
[17:00:32.437] Searching for globals ... DONE
[17:00:32.437] - globals: [0] <none>
[17:00:32.437] getGlobalsAndPackages() ... DONE
[17:00:32.437]    + additional globals found: [n=0] 
[17:00:32.437]    + additional namespaces needed: [n=0] 
[17:00:32.437]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:32.437]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:32.437]  - seeds: <none>
[17:00:32.437]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.438] getGlobalsAndPackages() ...
[17:00:32.438] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.438] Resolving globals: FALSE
[17:00:32.438] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:32.439] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:32.439] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.439] 
[17:00:32.439] getGlobalsAndPackages() ... DONE
[17:00:32.440] run() for ‘Future’ ...
[17:00:32.440] - state: ‘created’
[17:00:32.440] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:32.455] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:32.455]   - Field: ‘node’
[17:00:32.455]   - Field: ‘label’
[17:00:32.455]   - Field: ‘local’
[17:00:32.455]   - Field: ‘owner’
[17:00:32.455]   - Field: ‘envir’
[17:00:32.456]   - Field: ‘workers’
[17:00:32.456]   - Field: ‘packages’
[17:00:32.456]   - Field: ‘gc’
[17:00:32.456]   - Field: ‘conditions’
[17:00:32.456]   - Field: ‘persistent’
[17:00:32.456]   - Field: ‘expr’
[17:00:32.456]   - Field: ‘uuid’
[17:00:32.456]   - Field: ‘seed’
[17:00:32.456]   - Field: ‘version’
[17:00:32.457]   - Field: ‘result’
[17:00:32.457]   - Field: ‘asynchronous’
[17:00:32.457]   - Field: ‘calls’
[17:00:32.457]   - Field: ‘globals’
[17:00:32.457]   - Field: ‘stdout’
[17:00:32.457]   - Field: ‘earlySignal’
[17:00:32.457]   - Field: ‘lazy’
[17:00:32.457]   - Field: ‘state’
[17:00:32.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:32.458] - Launch lazy future ...
[17:00:32.458] Packages needed by the future expression (n = 0): <none>
[17:00:32.458] Packages needed by future strategies (n = 0): <none>
[17:00:32.459] {
[17:00:32.459]     {
[17:00:32.459]         {
[17:00:32.459]             ...future.startTime <- base::Sys.time()
[17:00:32.459]             {
[17:00:32.459]                 {
[17:00:32.459]                   {
[17:00:32.459]                     {
[17:00:32.459]                       base::local({
[17:00:32.459]                         has_future <- base::requireNamespace("future", 
[17:00:32.459]                           quietly = TRUE)
[17:00:32.459]                         if (has_future) {
[17:00:32.459]                           ns <- base::getNamespace("future")
[17:00:32.459]                           version <- ns[[".package"]][["version"]]
[17:00:32.459]                           if (is.null(version)) 
[17:00:32.459]                             version <- utils::packageVersion("future")
[17:00:32.459]                         }
[17:00:32.459]                         else {
[17:00:32.459]                           version <- NULL
[17:00:32.459]                         }
[17:00:32.459]                         if (!has_future || version < "1.8.0") {
[17:00:32.459]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:32.459]                             "", base::R.version$version.string), 
[17:00:32.459]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:32.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:32.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:32.459]                               "release", "version")], collapse = " "), 
[17:00:32.459]                             hostname = base::Sys.info()[["nodename"]])
[17:00:32.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:32.459]                             info)
[17:00:32.459]                           info <- base::paste(info, collapse = "; ")
[17:00:32.459]                           if (!has_future) {
[17:00:32.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:32.459]                               info)
[17:00:32.459]                           }
[17:00:32.459]                           else {
[17:00:32.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:32.459]                               info, version)
[17:00:32.459]                           }
[17:00:32.459]                           base::stop(msg)
[17:00:32.459]                         }
[17:00:32.459]                       })
[17:00:32.459]                     }
[17:00:32.459]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:32.459]                     base::options(mc.cores = 1L)
[17:00:32.459]                   }
[17:00:32.459]                   ...future.strategy.old <- future::plan("list")
[17:00:32.459]                   options(future.plan = NULL)
[17:00:32.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:32.459]                 }
[17:00:32.459]                 ...future.workdir <- getwd()
[17:00:32.459]             }
[17:00:32.459]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:32.459]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:32.459]         }
[17:00:32.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:32.459]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:32.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:32.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:32.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:32.459]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:32.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:32.459]             base::names(...future.oldOptions))
[17:00:32.459]     }
[17:00:32.459]     if (FALSE) {
[17:00:32.459]     }
[17:00:32.459]     else {
[17:00:32.459]         if (TRUE) {
[17:00:32.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:32.459]                 open = "w")
[17:00:32.459]         }
[17:00:32.459]         else {
[17:00:32.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:32.459]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:32.459]         }
[17:00:32.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:32.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:32.459]             base::sink(type = "output", split = FALSE)
[17:00:32.459]             base::close(...future.stdout)
[17:00:32.459]         }, add = TRUE)
[17:00:32.459]     }
[17:00:32.459]     ...future.frame <- base::sys.nframe()
[17:00:32.459]     ...future.conditions <- base::list()
[17:00:32.459]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:32.459]     if (FALSE) {
[17:00:32.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:32.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:32.459]     }
[17:00:32.459]     ...future.result <- base::tryCatch({
[17:00:32.459]         base::withCallingHandlers({
[17:00:32.459]             ...future.value <- base::withVisible(base::local({
[17:00:32.459]                 ...future.makeSendCondition <- base::local({
[17:00:32.459]                   sendCondition <- NULL
[17:00:32.459]                   function(frame = 1L) {
[17:00:32.459]                     if (is.function(sendCondition)) 
[17:00:32.459]                       return(sendCondition)
[17:00:32.459]                     ns <- getNamespace("parallel")
[17:00:32.459]                     if (exists("sendData", mode = "function", 
[17:00:32.459]                       envir = ns)) {
[17:00:32.459]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:32.459]                         envir = ns)
[17:00:32.459]                       envir <- sys.frame(frame)
[17:00:32.459]                       master <- NULL
[17:00:32.459]                       while (!identical(envir, .GlobalEnv) && 
[17:00:32.459]                         !identical(envir, emptyenv())) {
[17:00:32.459]                         if (exists("master", mode = "list", envir = envir, 
[17:00:32.459]                           inherits = FALSE)) {
[17:00:32.459]                           master <- get("master", mode = "list", 
[17:00:32.459]                             envir = envir, inherits = FALSE)
[17:00:32.459]                           if (inherits(master, c("SOCKnode", 
[17:00:32.459]                             "SOCK0node"))) {
[17:00:32.459]                             sendCondition <<- function(cond) {
[17:00:32.459]                               data <- list(type = "VALUE", value = cond, 
[17:00:32.459]                                 success = TRUE)
[17:00:32.459]                               parallel_sendData(master, data)
[17:00:32.459]                             }
[17:00:32.459]                             return(sendCondition)
[17:00:32.459]                           }
[17:00:32.459]                         }
[17:00:32.459]                         frame <- frame + 1L
[17:00:32.459]                         envir <- sys.frame(frame)
[17:00:32.459]                       }
[17:00:32.459]                     }
[17:00:32.459]                     sendCondition <<- function(cond) NULL
[17:00:32.459]                   }
[17:00:32.459]                 })
[17:00:32.459]                 withCallingHandlers({
[17:00:32.459]                   {
[17:00:32.459]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.459]                     if (!identical(...future.globals.maxSize.org, 
[17:00:32.459]                       ...future.globals.maxSize)) {
[17:00:32.459]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.459]                       on.exit(options(oopts), add = TRUE)
[17:00:32.459]                     }
[17:00:32.459]                     {
[17:00:32.459]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.459]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:32.459]                         USE.NAMES = FALSE)
[17:00:32.459]                       do.call(mapply, args = args)
[17:00:32.459]                     }
[17:00:32.459]                   }
[17:00:32.459]                 }, immediateCondition = function(cond) {
[17:00:32.459]                   sendCondition <- ...future.makeSendCondition()
[17:00:32.459]                   sendCondition(cond)
[17:00:32.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.459]                   {
[17:00:32.459]                     inherits <- base::inherits
[17:00:32.459]                     invokeRestart <- base::invokeRestart
[17:00:32.459]                     is.null <- base::is.null
[17:00:32.459]                     muffled <- FALSE
[17:00:32.459]                     if (inherits(cond, "message")) {
[17:00:32.459]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:32.459]                       if (muffled) 
[17:00:32.459]                         invokeRestart("muffleMessage")
[17:00:32.459]                     }
[17:00:32.459]                     else if (inherits(cond, "warning")) {
[17:00:32.459]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:32.459]                       if (muffled) 
[17:00:32.459]                         invokeRestart("muffleWarning")
[17:00:32.459]                     }
[17:00:32.459]                     else if (inherits(cond, "condition")) {
[17:00:32.459]                       if (!is.null(pattern)) {
[17:00:32.459]                         computeRestarts <- base::computeRestarts
[17:00:32.459]                         grepl <- base::grepl
[17:00:32.459]                         restarts <- computeRestarts(cond)
[17:00:32.459]                         for (restart in restarts) {
[17:00:32.459]                           name <- restart$name
[17:00:32.459]                           if (is.null(name)) 
[17:00:32.459]                             next
[17:00:32.459]                           if (!grepl(pattern, name)) 
[17:00:32.459]                             next
[17:00:32.459]                           invokeRestart(restart)
[17:00:32.459]                           muffled <- TRUE
[17:00:32.459]                           break
[17:00:32.459]                         }
[17:00:32.459]                       }
[17:00:32.459]                     }
[17:00:32.459]                     invisible(muffled)
[17:00:32.459]                   }
[17:00:32.459]                   muffleCondition(cond)
[17:00:32.459]                 })
[17:00:32.459]             }))
[17:00:32.459]             future::FutureResult(value = ...future.value$value, 
[17:00:32.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.459]                   ...future.rng), globalenv = if (FALSE) 
[17:00:32.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:32.459]                     ...future.globalenv.names))
[17:00:32.459]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:32.459]         }, condition = base::local({
[17:00:32.459]             c <- base::c
[17:00:32.459]             inherits <- base::inherits
[17:00:32.459]             invokeRestart <- base::invokeRestart
[17:00:32.459]             length <- base::length
[17:00:32.459]             list <- base::list
[17:00:32.459]             seq.int <- base::seq.int
[17:00:32.459]             signalCondition <- base::signalCondition
[17:00:32.459]             sys.calls <- base::sys.calls
[17:00:32.459]             `[[` <- base::`[[`
[17:00:32.459]             `+` <- base::`+`
[17:00:32.459]             `<<-` <- base::`<<-`
[17:00:32.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:32.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:32.459]                   3L)]
[17:00:32.459]             }
[17:00:32.459]             function(cond) {
[17:00:32.459]                 is_error <- inherits(cond, "error")
[17:00:32.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:32.459]                   NULL)
[17:00:32.459]                 if (is_error) {
[17:00:32.459]                   sessionInformation <- function() {
[17:00:32.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:32.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:32.459]                       search = base::search(), system = base::Sys.info())
[17:00:32.459]                   }
[17:00:32.459]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:32.459]                     cond$call), session = sessionInformation(), 
[17:00:32.459]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:32.459]                   signalCondition(cond)
[17:00:32.459]                 }
[17:00:32.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:32.459]                 "immediateCondition"))) {
[17:00:32.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:32.459]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:32.459]                   if (TRUE && !signal) {
[17:00:32.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.459]                     {
[17:00:32.459]                       inherits <- base::inherits
[17:00:32.459]                       invokeRestart <- base::invokeRestart
[17:00:32.459]                       is.null <- base::is.null
[17:00:32.459]                       muffled <- FALSE
[17:00:32.459]                       if (inherits(cond, "message")) {
[17:00:32.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.459]                         if (muffled) 
[17:00:32.459]                           invokeRestart("muffleMessage")
[17:00:32.459]                       }
[17:00:32.459]                       else if (inherits(cond, "warning")) {
[17:00:32.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.459]                         if (muffled) 
[17:00:32.459]                           invokeRestart("muffleWarning")
[17:00:32.459]                       }
[17:00:32.459]                       else if (inherits(cond, "condition")) {
[17:00:32.459]                         if (!is.null(pattern)) {
[17:00:32.459]                           computeRestarts <- base::computeRestarts
[17:00:32.459]                           grepl <- base::grepl
[17:00:32.459]                           restarts <- computeRestarts(cond)
[17:00:32.459]                           for (restart in restarts) {
[17:00:32.459]                             name <- restart$name
[17:00:32.459]                             if (is.null(name)) 
[17:00:32.459]                               next
[17:00:32.459]                             if (!grepl(pattern, name)) 
[17:00:32.459]                               next
[17:00:32.459]                             invokeRestart(restart)
[17:00:32.459]                             muffled <- TRUE
[17:00:32.459]                             break
[17:00:32.459]                           }
[17:00:32.459]                         }
[17:00:32.459]                       }
[17:00:32.459]                       invisible(muffled)
[17:00:32.459]                     }
[17:00:32.459]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.459]                   }
[17:00:32.459]                 }
[17:00:32.459]                 else {
[17:00:32.459]                   if (TRUE) {
[17:00:32.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.459]                     {
[17:00:32.459]                       inherits <- base::inherits
[17:00:32.459]                       invokeRestart <- base::invokeRestart
[17:00:32.459]                       is.null <- base::is.null
[17:00:32.459]                       muffled <- FALSE
[17:00:32.459]                       if (inherits(cond, "message")) {
[17:00:32.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.459]                         if (muffled) 
[17:00:32.459]                           invokeRestart("muffleMessage")
[17:00:32.459]                       }
[17:00:32.459]                       else if (inherits(cond, "warning")) {
[17:00:32.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.459]                         if (muffled) 
[17:00:32.459]                           invokeRestart("muffleWarning")
[17:00:32.459]                       }
[17:00:32.459]                       else if (inherits(cond, "condition")) {
[17:00:32.459]                         if (!is.null(pattern)) {
[17:00:32.459]                           computeRestarts <- base::computeRestarts
[17:00:32.459]                           grepl <- base::grepl
[17:00:32.459]                           restarts <- computeRestarts(cond)
[17:00:32.459]                           for (restart in restarts) {
[17:00:32.459]                             name <- restart$name
[17:00:32.459]                             if (is.null(name)) 
[17:00:32.459]                               next
[17:00:32.459]                             if (!grepl(pattern, name)) 
[17:00:32.459]                               next
[17:00:32.459]                             invokeRestart(restart)
[17:00:32.459]                             muffled <- TRUE
[17:00:32.459]                             break
[17:00:32.459]                           }
[17:00:32.459]                         }
[17:00:32.459]                       }
[17:00:32.459]                       invisible(muffled)
[17:00:32.459]                     }
[17:00:32.459]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.459]                   }
[17:00:32.459]                 }
[17:00:32.459]             }
[17:00:32.459]         }))
[17:00:32.459]     }, error = function(ex) {
[17:00:32.459]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:32.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.459]                 ...future.rng), started = ...future.startTime, 
[17:00:32.459]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:32.459]             version = "1.8"), class = "FutureResult")
[17:00:32.459]     }, finally = {
[17:00:32.459]         if (!identical(...future.workdir, getwd())) 
[17:00:32.459]             setwd(...future.workdir)
[17:00:32.459]         {
[17:00:32.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:32.459]                 ...future.oldOptions$nwarnings <- NULL
[17:00:32.459]             }
[17:00:32.459]             base::options(...future.oldOptions)
[17:00:32.459]             if (.Platform$OS.type == "windows") {
[17:00:32.459]                 old_names <- names(...future.oldEnvVars)
[17:00:32.459]                 envs <- base::Sys.getenv()
[17:00:32.459]                 names <- names(envs)
[17:00:32.459]                 common <- intersect(names, old_names)
[17:00:32.459]                 added <- setdiff(names, old_names)
[17:00:32.459]                 removed <- setdiff(old_names, names)
[17:00:32.459]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:32.459]                   envs[common]]
[17:00:32.459]                 NAMES <- toupper(changed)
[17:00:32.459]                 args <- list()
[17:00:32.459]                 for (kk in seq_along(NAMES)) {
[17:00:32.459]                   name <- changed[[kk]]
[17:00:32.459]                   NAME <- NAMES[[kk]]
[17:00:32.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.459]                     next
[17:00:32.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.459]                 }
[17:00:32.459]                 NAMES <- toupper(added)
[17:00:32.459]                 for (kk in seq_along(NAMES)) {
[17:00:32.459]                   name <- added[[kk]]
[17:00:32.459]                   NAME <- NAMES[[kk]]
[17:00:32.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.459]                     next
[17:00:32.459]                   args[[name]] <- ""
[17:00:32.459]                 }
[17:00:32.459]                 NAMES <- toupper(removed)
[17:00:32.459]                 for (kk in seq_along(NAMES)) {
[17:00:32.459]                   name <- removed[[kk]]
[17:00:32.459]                   NAME <- NAMES[[kk]]
[17:00:32.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.459]                     next
[17:00:32.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.459]                 }
[17:00:32.459]                 if (length(args) > 0) 
[17:00:32.459]                   base::do.call(base::Sys.setenv, args = args)
[17:00:32.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:32.459]             }
[17:00:32.459]             else {
[17:00:32.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:32.459]             }
[17:00:32.459]             {
[17:00:32.459]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:32.459]                   0L) {
[17:00:32.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:32.459]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:32.459]                   base::options(opts)
[17:00:32.459]                 }
[17:00:32.459]                 {
[17:00:32.459]                   {
[17:00:32.459]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:32.459]                     NULL
[17:00:32.459]                   }
[17:00:32.459]                   options(future.plan = NULL)
[17:00:32.459]                   if (is.na(NA_character_)) 
[17:00:32.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:32.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:32.459]                     .init = FALSE)
[17:00:32.459]                 }
[17:00:32.459]             }
[17:00:32.459]         }
[17:00:32.459]     })
[17:00:32.459]     if (TRUE) {
[17:00:32.459]         base::sink(type = "output", split = FALSE)
[17:00:32.459]         if (TRUE) {
[17:00:32.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:32.459]         }
[17:00:32.459]         else {
[17:00:32.459]             ...future.result["stdout"] <- base::list(NULL)
[17:00:32.459]         }
[17:00:32.459]         base::close(...future.stdout)
[17:00:32.459]         ...future.stdout <- NULL
[17:00:32.459]     }
[17:00:32.459]     ...future.result$conditions <- ...future.conditions
[17:00:32.459]     ...future.result$finished <- base::Sys.time()
[17:00:32.459]     ...future.result
[17:00:32.459] }
[17:00:32.511] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:00:32.511] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:00:32.512] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:00:32.512] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:32.512] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.513] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:00:32.513] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:00:32.513] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:32.514] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.514] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:32.514] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.514] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:00:32.515] MultisessionFuture started
[17:00:32.515] - Launch lazy future ... done
[17:00:32.515] run() for ‘MultisessionFuture’ ... done
[17:00:32.515] Created future:
[17:00:32.515] MultisessionFuture:
[17:00:32.515] Label: ‘future_mapply-2’
[17:00:32.515] Expression:
[17:00:32.515] {
[17:00:32.515]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.515]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:32.515]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.515]         on.exit(options(oopts), add = TRUE)
[17:00:32.515]     }
[17:00:32.515]     {
[17:00:32.515]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.515]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:32.515]         do.call(mapply, args = args)
[17:00:32.515]     }
[17:00:32.515] }
[17:00:32.515] Lazy evaluation: FALSE
[17:00:32.515] Asynchronous evaluation: TRUE
[17:00:32.515] Local evaluation: TRUE
[17:00:32.515] Environment: R_GlobalEnv
[17:00:32.515] Capture standard output: TRUE
[17:00:32.515] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:32.515] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:32.515] Packages: <none>
[17:00:32.515] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:32.515] Resolved: FALSE
[17:00:32.515] Value: <not collected>
[17:00:32.515] Conditions captured: <none>
[17:00:32.515] Early signaling: FALSE
[17:00:32.515] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:32.515] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.527] Chunk #2 of 2 ... DONE
[17:00:32.527] Launching 2 futures (chunks) ... DONE
[17:00:32.527] Resolving 2 futures (chunks) ...
[17:00:32.528] resolve() on list ...
[17:00:32.528]  recursive: 0
[17:00:32.528]  length: 2
[17:00:32.528] 
[17:00:32.529] receiveMessageFromWorker() for ClusterFuture ...
[17:00:32.529] - Validating connection of MultisessionFuture
[17:00:32.529] - received message: FutureResult
[17:00:32.529] - Received FutureResult
[17:00:32.529] - Erased future from FutureRegistry
[17:00:32.529] result() for ClusterFuture ...
[17:00:32.530] - result already collected: FutureResult
[17:00:32.530] result() for ClusterFuture ... done
[17:00:32.530] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:32.530] Future #1
[17:00:32.530] result() for ClusterFuture ...
[17:00:32.530] - result already collected: FutureResult
[17:00:32.530] result() for ClusterFuture ... done
[17:00:32.530] result() for ClusterFuture ...
[17:00:32.530] - result already collected: FutureResult
[17:00:32.530] result() for ClusterFuture ... done
[17:00:32.531] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:32.531] - nx: 2
[17:00:32.531] - relay: TRUE
[17:00:32.531] - stdout: TRUE
[17:00:32.531] - signal: TRUE
[17:00:32.531] - resignal: FALSE
[17:00:32.531] - force: TRUE
[17:00:32.531] - relayed: [n=2] FALSE, FALSE
[17:00:32.531] - queued futures: [n=2] FALSE, FALSE
[17:00:32.532]  - until=1
[17:00:32.532]  - relaying element #1
[17:00:32.532] result() for ClusterFuture ...
[17:00:32.532] - result already collected: FutureResult
[17:00:32.532] result() for ClusterFuture ... done
[17:00:32.532] result() for ClusterFuture ...
[17:00:32.532] - result already collected: FutureResult
[17:00:32.532] result() for ClusterFuture ... done
[17:00:32.533] result() for ClusterFuture ...
[17:00:32.533] - result already collected: FutureResult
[17:00:32.533] result() for ClusterFuture ... done
[17:00:32.533] result() for ClusterFuture ...
[17:00:32.533] - result already collected: FutureResult
[17:00:32.533] result() for ClusterFuture ... done
[17:00:32.533] - relayed: [n=2] TRUE, FALSE
[17:00:32.533] - queued futures: [n=2] TRUE, FALSE
[17:00:32.533] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:32.534]  length: 1 (resolved future 1)
[17:00:32.596] receiveMessageFromWorker() for ClusterFuture ...
[17:00:32.597] - Validating connection of MultisessionFuture
[17:00:32.597] - received message: FutureResult
[17:00:32.597] - Received FutureResult
[17:00:32.597] - Erased future from FutureRegistry
[17:00:32.597] result() for ClusterFuture ...
[17:00:32.597] - result already collected: FutureResult
[17:00:32.598] result() for ClusterFuture ... done
[17:00:32.598] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:32.598] Future #2
[17:00:32.598] result() for ClusterFuture ...
[17:00:32.598] - result already collected: FutureResult
[17:00:32.598] result() for ClusterFuture ... done
[17:00:32.598] result() for ClusterFuture ...
[17:00:32.598] - result already collected: FutureResult
[17:00:32.598] result() for ClusterFuture ... done
[17:00:32.599] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:32.599] - nx: 2
[17:00:32.599] - relay: TRUE
[17:00:32.599] - stdout: TRUE
[17:00:32.599] - signal: TRUE
[17:00:32.599] - resignal: FALSE
[17:00:32.599] - force: TRUE
[17:00:32.599] - relayed: [n=2] TRUE, FALSE
[17:00:32.603] - queued futures: [n=2] TRUE, FALSE
[17:00:32.604]  - until=2
[17:00:32.604]  - relaying element #2
[17:00:32.604] result() for ClusterFuture ...
[17:00:32.604] - result already collected: FutureResult
[17:00:32.604] result() for ClusterFuture ... done
[17:00:32.604] result() for ClusterFuture ...
[17:00:32.604] - result already collected: FutureResult
[17:00:32.604] result() for ClusterFuture ... done
[17:00:32.604] result() for ClusterFuture ...
[17:00:32.605] - result already collected: FutureResult
[17:00:32.605] result() for ClusterFuture ... done
[17:00:32.605] result() for ClusterFuture ...
[17:00:32.605] - result already collected: FutureResult
[17:00:32.605] result() for ClusterFuture ... done
[17:00:32.605] - relayed: [n=2] TRUE, TRUE
[17:00:32.605] - queued futures: [n=2] TRUE, TRUE
[17:00:32.605] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:32.605]  length: 0 (resolved future 2)
[17:00:32.605] Relaying remaining futures
[17:00:32.605] signalConditionsASAP(NULL, pos=0) ...
[17:00:32.605] - nx: 2
[17:00:32.606] - relay: TRUE
[17:00:32.606] - stdout: TRUE
[17:00:32.606] - signal: TRUE
[17:00:32.606] - resignal: FALSE
[17:00:32.606] - force: TRUE
[17:00:32.606] - relayed: [n=2] TRUE, TRUE
[17:00:32.606] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:32.606] - relayed: [n=2] TRUE, TRUE
[17:00:32.606] - queued futures: [n=2] TRUE, TRUE
[17:00:32.606] signalConditionsASAP(NULL, pos=0) ... done
[17:00:32.606] resolve() on list ... DONE
[17:00:32.606] result() for ClusterFuture ...
[17:00:32.607] - result already collected: FutureResult
[17:00:32.607] result() for ClusterFuture ... done
[17:00:32.607] result() for ClusterFuture ...
[17:00:32.607] - result already collected: FutureResult
[17:00:32.607] result() for ClusterFuture ... done
[17:00:32.607] result() for ClusterFuture ...
[17:00:32.607] - result already collected: FutureResult
[17:00:32.607] result() for ClusterFuture ... done
[17:00:32.607] result() for ClusterFuture ...
[17:00:32.607] - result already collected: FutureResult
[17:00:32.607] result() for ClusterFuture ... done
[17:00:32.608]  - Number of value chunks collected: 2
[17:00:32.608] Resolving 2 futures (chunks) ... DONE
[17:00:32.608] Reducing values from 2 chunks ...
[17:00:32.608]  - Number of values collected after concatenation: 4
[17:00:32.608]  - Number of values expected: 4
[17:00:32.608] Reducing values from 2 chunks ... DONE
[17:00:32.608] future_mapply() ... DONE
[17:00:32.608] future_mapply() ...
[17:00:32.612] Number of chunks: 2
[17:00:32.612] getGlobalsAndPackagesXApply() ...
[17:00:32.612]  - future.globals: TRUE
[17:00:32.612] getGlobalsAndPackages() ...
[17:00:32.612] Searching for globals...
[17:00:32.613] - globals found: [1] ‘FUN’
[17:00:32.613] Searching for globals ... DONE
[17:00:32.613] Resolving globals: FALSE
[17:00:32.614] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:32.614] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:32.614] - globals: [1] ‘FUN’
[17:00:32.614] 
[17:00:32.614] getGlobalsAndPackages() ... DONE
[17:00:32.614]  - globals found/used: [n=1] ‘FUN’
[17:00:32.614]  - needed namespaces: [n=0] 
[17:00:32.614] Finding globals ... DONE
[17:00:32.615] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:32.615] List of 2
[17:00:32.615]  $ ...future.FUN:function (x, ...)  
[17:00:32.615]  $ MoreArgs     : NULL
[17:00:32.615]  - attr(*, "where")=List of 2
[17:00:32.615]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:32.615]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:32.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:32.615]  - attr(*, "resolved")= logi FALSE
[17:00:32.615]  - attr(*, "total_size")= num NA
[17:00:32.617] Packages to be attached in all futures: [n=0] 
[17:00:32.617] getGlobalsAndPackagesXApply() ... DONE
[17:00:32.617] Number of futures (= number of chunks): 2
[17:00:32.618] Launching 2 futures (chunks) ...
[17:00:32.618] Chunk #1 of 2 ...
[17:00:32.618]  - Finding globals in '...' for chunk #1 ...
[17:00:32.618] getGlobalsAndPackages() ...
[17:00:32.618] Searching for globals...
[17:00:32.618] 
[17:00:32.618] Searching for globals ... DONE
[17:00:32.618] - globals: [0] <none>
[17:00:32.618] getGlobalsAndPackages() ... DONE
[17:00:32.619]    + additional globals found: [n=0] 
[17:00:32.619]    + additional namespaces needed: [n=0] 
[17:00:32.619]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:32.619]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:32.619]  - seeds: <none>
[17:00:32.619]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.619] getGlobalsAndPackages() ...
[17:00:32.619] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.619] Resolving globals: FALSE
[17:00:32.620] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:32.620] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:32.620] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.620] 
[17:00:32.621] getGlobalsAndPackages() ... DONE
[17:00:32.621] run() for ‘Future’ ...
[17:00:32.621] - state: ‘created’
[17:00:32.621] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:32.636] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.636] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:32.636]   - Field: ‘node’
[17:00:32.636]   - Field: ‘label’
[17:00:32.636]   - Field: ‘local’
[17:00:32.636]   - Field: ‘owner’
[17:00:32.636]   - Field: ‘envir’
[17:00:32.636]   - Field: ‘workers’
[17:00:32.637]   - Field: ‘packages’
[17:00:32.637]   - Field: ‘gc’
[17:00:32.637]   - Field: ‘conditions’
[17:00:32.637]   - Field: ‘persistent’
[17:00:32.637]   - Field: ‘expr’
[17:00:32.637]   - Field: ‘uuid’
[17:00:32.637]   - Field: ‘seed’
[17:00:32.637]   - Field: ‘version’
[17:00:32.637]   - Field: ‘result’
[17:00:32.637]   - Field: ‘asynchronous’
[17:00:32.637]   - Field: ‘calls’
[17:00:32.638]   - Field: ‘globals’
[17:00:32.638]   - Field: ‘stdout’
[17:00:32.638]   - Field: ‘earlySignal’
[17:00:32.638]   - Field: ‘lazy’
[17:00:32.638]   - Field: ‘state’
[17:00:32.638] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:32.638] - Launch lazy future ...
[17:00:32.638] Packages needed by the future expression (n = 0): <none>
[17:00:32.638] Packages needed by future strategies (n = 0): <none>
[17:00:32.639] {
[17:00:32.639]     {
[17:00:32.639]         {
[17:00:32.639]             ...future.startTime <- base::Sys.time()
[17:00:32.639]             {
[17:00:32.639]                 {
[17:00:32.639]                   {
[17:00:32.639]                     {
[17:00:32.639]                       base::local({
[17:00:32.639]                         has_future <- base::requireNamespace("future", 
[17:00:32.639]                           quietly = TRUE)
[17:00:32.639]                         if (has_future) {
[17:00:32.639]                           ns <- base::getNamespace("future")
[17:00:32.639]                           version <- ns[[".package"]][["version"]]
[17:00:32.639]                           if (is.null(version)) 
[17:00:32.639]                             version <- utils::packageVersion("future")
[17:00:32.639]                         }
[17:00:32.639]                         else {
[17:00:32.639]                           version <- NULL
[17:00:32.639]                         }
[17:00:32.639]                         if (!has_future || version < "1.8.0") {
[17:00:32.639]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:32.639]                             "", base::R.version$version.string), 
[17:00:32.639]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:32.639]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:32.639]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:32.639]                               "release", "version")], collapse = " "), 
[17:00:32.639]                             hostname = base::Sys.info()[["nodename"]])
[17:00:32.639]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:32.639]                             info)
[17:00:32.639]                           info <- base::paste(info, collapse = "; ")
[17:00:32.639]                           if (!has_future) {
[17:00:32.639]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:32.639]                               info)
[17:00:32.639]                           }
[17:00:32.639]                           else {
[17:00:32.639]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:32.639]                               info, version)
[17:00:32.639]                           }
[17:00:32.639]                           base::stop(msg)
[17:00:32.639]                         }
[17:00:32.639]                       })
[17:00:32.639]                     }
[17:00:32.639]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:32.639]                     base::options(mc.cores = 1L)
[17:00:32.639]                   }
[17:00:32.639]                   ...future.strategy.old <- future::plan("list")
[17:00:32.639]                   options(future.plan = NULL)
[17:00:32.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:32.639]                 }
[17:00:32.639]                 ...future.workdir <- getwd()
[17:00:32.639]             }
[17:00:32.639]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:32.639]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:32.639]         }
[17:00:32.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:32.639]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:32.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:32.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:32.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:32.639]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:32.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:32.639]             base::names(...future.oldOptions))
[17:00:32.639]     }
[17:00:32.639]     if (FALSE) {
[17:00:32.639]     }
[17:00:32.639]     else {
[17:00:32.639]         if (TRUE) {
[17:00:32.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:32.639]                 open = "w")
[17:00:32.639]         }
[17:00:32.639]         else {
[17:00:32.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:32.639]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:32.639]         }
[17:00:32.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:32.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:32.639]             base::sink(type = "output", split = FALSE)
[17:00:32.639]             base::close(...future.stdout)
[17:00:32.639]         }, add = TRUE)
[17:00:32.639]     }
[17:00:32.639]     ...future.frame <- base::sys.nframe()
[17:00:32.639]     ...future.conditions <- base::list()
[17:00:32.639]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:32.639]     if (FALSE) {
[17:00:32.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:32.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:32.639]     }
[17:00:32.639]     ...future.result <- base::tryCatch({
[17:00:32.639]         base::withCallingHandlers({
[17:00:32.639]             ...future.value <- base::withVisible(base::local({
[17:00:32.639]                 ...future.makeSendCondition <- base::local({
[17:00:32.639]                   sendCondition <- NULL
[17:00:32.639]                   function(frame = 1L) {
[17:00:32.639]                     if (is.function(sendCondition)) 
[17:00:32.639]                       return(sendCondition)
[17:00:32.639]                     ns <- getNamespace("parallel")
[17:00:32.639]                     if (exists("sendData", mode = "function", 
[17:00:32.639]                       envir = ns)) {
[17:00:32.639]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:32.639]                         envir = ns)
[17:00:32.639]                       envir <- sys.frame(frame)
[17:00:32.639]                       master <- NULL
[17:00:32.639]                       while (!identical(envir, .GlobalEnv) && 
[17:00:32.639]                         !identical(envir, emptyenv())) {
[17:00:32.639]                         if (exists("master", mode = "list", envir = envir, 
[17:00:32.639]                           inherits = FALSE)) {
[17:00:32.639]                           master <- get("master", mode = "list", 
[17:00:32.639]                             envir = envir, inherits = FALSE)
[17:00:32.639]                           if (inherits(master, c("SOCKnode", 
[17:00:32.639]                             "SOCK0node"))) {
[17:00:32.639]                             sendCondition <<- function(cond) {
[17:00:32.639]                               data <- list(type = "VALUE", value = cond, 
[17:00:32.639]                                 success = TRUE)
[17:00:32.639]                               parallel_sendData(master, data)
[17:00:32.639]                             }
[17:00:32.639]                             return(sendCondition)
[17:00:32.639]                           }
[17:00:32.639]                         }
[17:00:32.639]                         frame <- frame + 1L
[17:00:32.639]                         envir <- sys.frame(frame)
[17:00:32.639]                       }
[17:00:32.639]                     }
[17:00:32.639]                     sendCondition <<- function(cond) NULL
[17:00:32.639]                   }
[17:00:32.639]                 })
[17:00:32.639]                 withCallingHandlers({
[17:00:32.639]                   {
[17:00:32.639]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.639]                     if (!identical(...future.globals.maxSize.org, 
[17:00:32.639]                       ...future.globals.maxSize)) {
[17:00:32.639]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.639]                       on.exit(options(oopts), add = TRUE)
[17:00:32.639]                     }
[17:00:32.639]                     {
[17:00:32.639]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.639]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:32.639]                         USE.NAMES = FALSE)
[17:00:32.639]                       do.call(mapply, args = args)
[17:00:32.639]                     }
[17:00:32.639]                   }
[17:00:32.639]                 }, immediateCondition = function(cond) {
[17:00:32.639]                   sendCondition <- ...future.makeSendCondition()
[17:00:32.639]                   sendCondition(cond)
[17:00:32.639]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.639]                   {
[17:00:32.639]                     inherits <- base::inherits
[17:00:32.639]                     invokeRestart <- base::invokeRestart
[17:00:32.639]                     is.null <- base::is.null
[17:00:32.639]                     muffled <- FALSE
[17:00:32.639]                     if (inherits(cond, "message")) {
[17:00:32.639]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:32.639]                       if (muffled) 
[17:00:32.639]                         invokeRestart("muffleMessage")
[17:00:32.639]                     }
[17:00:32.639]                     else if (inherits(cond, "warning")) {
[17:00:32.639]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:32.639]                       if (muffled) 
[17:00:32.639]                         invokeRestart("muffleWarning")
[17:00:32.639]                     }
[17:00:32.639]                     else if (inherits(cond, "condition")) {
[17:00:32.639]                       if (!is.null(pattern)) {
[17:00:32.639]                         computeRestarts <- base::computeRestarts
[17:00:32.639]                         grepl <- base::grepl
[17:00:32.639]                         restarts <- computeRestarts(cond)
[17:00:32.639]                         for (restart in restarts) {
[17:00:32.639]                           name <- restart$name
[17:00:32.639]                           if (is.null(name)) 
[17:00:32.639]                             next
[17:00:32.639]                           if (!grepl(pattern, name)) 
[17:00:32.639]                             next
[17:00:32.639]                           invokeRestart(restart)
[17:00:32.639]                           muffled <- TRUE
[17:00:32.639]                           break
[17:00:32.639]                         }
[17:00:32.639]                       }
[17:00:32.639]                     }
[17:00:32.639]                     invisible(muffled)
[17:00:32.639]                   }
[17:00:32.639]                   muffleCondition(cond)
[17:00:32.639]                 })
[17:00:32.639]             }))
[17:00:32.639]             future::FutureResult(value = ...future.value$value, 
[17:00:32.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.639]                   ...future.rng), globalenv = if (FALSE) 
[17:00:32.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:32.639]                     ...future.globalenv.names))
[17:00:32.639]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:32.639]         }, condition = base::local({
[17:00:32.639]             c <- base::c
[17:00:32.639]             inherits <- base::inherits
[17:00:32.639]             invokeRestart <- base::invokeRestart
[17:00:32.639]             length <- base::length
[17:00:32.639]             list <- base::list
[17:00:32.639]             seq.int <- base::seq.int
[17:00:32.639]             signalCondition <- base::signalCondition
[17:00:32.639]             sys.calls <- base::sys.calls
[17:00:32.639]             `[[` <- base::`[[`
[17:00:32.639]             `+` <- base::`+`
[17:00:32.639]             `<<-` <- base::`<<-`
[17:00:32.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:32.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:32.639]                   3L)]
[17:00:32.639]             }
[17:00:32.639]             function(cond) {
[17:00:32.639]                 is_error <- inherits(cond, "error")
[17:00:32.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:32.639]                   NULL)
[17:00:32.639]                 if (is_error) {
[17:00:32.639]                   sessionInformation <- function() {
[17:00:32.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:32.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:32.639]                       search = base::search(), system = base::Sys.info())
[17:00:32.639]                   }
[17:00:32.639]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:32.639]                     cond$call), session = sessionInformation(), 
[17:00:32.639]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:32.639]                   signalCondition(cond)
[17:00:32.639]                 }
[17:00:32.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:32.639]                 "immediateCondition"))) {
[17:00:32.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:32.639]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:32.639]                   if (TRUE && !signal) {
[17:00:32.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.639]                     {
[17:00:32.639]                       inherits <- base::inherits
[17:00:32.639]                       invokeRestart <- base::invokeRestart
[17:00:32.639]                       is.null <- base::is.null
[17:00:32.639]                       muffled <- FALSE
[17:00:32.639]                       if (inherits(cond, "message")) {
[17:00:32.639]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.639]                         if (muffled) 
[17:00:32.639]                           invokeRestart("muffleMessage")
[17:00:32.639]                       }
[17:00:32.639]                       else if (inherits(cond, "warning")) {
[17:00:32.639]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.639]                         if (muffled) 
[17:00:32.639]                           invokeRestart("muffleWarning")
[17:00:32.639]                       }
[17:00:32.639]                       else if (inherits(cond, "condition")) {
[17:00:32.639]                         if (!is.null(pattern)) {
[17:00:32.639]                           computeRestarts <- base::computeRestarts
[17:00:32.639]                           grepl <- base::grepl
[17:00:32.639]                           restarts <- computeRestarts(cond)
[17:00:32.639]                           for (restart in restarts) {
[17:00:32.639]                             name <- restart$name
[17:00:32.639]                             if (is.null(name)) 
[17:00:32.639]                               next
[17:00:32.639]                             if (!grepl(pattern, name)) 
[17:00:32.639]                               next
[17:00:32.639]                             invokeRestart(restart)
[17:00:32.639]                             muffled <- TRUE
[17:00:32.639]                             break
[17:00:32.639]                           }
[17:00:32.639]                         }
[17:00:32.639]                       }
[17:00:32.639]                       invisible(muffled)
[17:00:32.639]                     }
[17:00:32.639]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.639]                   }
[17:00:32.639]                 }
[17:00:32.639]                 else {
[17:00:32.639]                   if (TRUE) {
[17:00:32.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.639]                     {
[17:00:32.639]                       inherits <- base::inherits
[17:00:32.639]                       invokeRestart <- base::invokeRestart
[17:00:32.639]                       is.null <- base::is.null
[17:00:32.639]                       muffled <- FALSE
[17:00:32.639]                       if (inherits(cond, "message")) {
[17:00:32.639]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.639]                         if (muffled) 
[17:00:32.639]                           invokeRestart("muffleMessage")
[17:00:32.639]                       }
[17:00:32.639]                       else if (inherits(cond, "warning")) {
[17:00:32.639]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.639]                         if (muffled) 
[17:00:32.639]                           invokeRestart("muffleWarning")
[17:00:32.639]                       }
[17:00:32.639]                       else if (inherits(cond, "condition")) {
[17:00:32.639]                         if (!is.null(pattern)) {
[17:00:32.639]                           computeRestarts <- base::computeRestarts
[17:00:32.639]                           grepl <- base::grepl
[17:00:32.639]                           restarts <- computeRestarts(cond)
[17:00:32.639]                           for (restart in restarts) {
[17:00:32.639]                             name <- restart$name
[17:00:32.639]                             if (is.null(name)) 
[17:00:32.639]                               next
[17:00:32.639]                             if (!grepl(pattern, name)) 
[17:00:32.639]                               next
[17:00:32.639]                             invokeRestart(restart)
[17:00:32.639]                             muffled <- TRUE
[17:00:32.639]                             break
[17:00:32.639]                           }
[17:00:32.639]                         }
[17:00:32.639]                       }
[17:00:32.639]                       invisible(muffled)
[17:00:32.639]                     }
[17:00:32.639]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.639]                   }
[17:00:32.639]                 }
[17:00:32.639]             }
[17:00:32.639]         }))
[17:00:32.639]     }, error = function(ex) {
[17:00:32.639]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:32.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.639]                 ...future.rng), started = ...future.startTime, 
[17:00:32.639]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:32.639]             version = "1.8"), class = "FutureResult")
[17:00:32.639]     }, finally = {
[17:00:32.639]         if (!identical(...future.workdir, getwd())) 
[17:00:32.639]             setwd(...future.workdir)
[17:00:32.639]         {
[17:00:32.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:32.639]                 ...future.oldOptions$nwarnings <- NULL
[17:00:32.639]             }
[17:00:32.639]             base::options(...future.oldOptions)
[17:00:32.639]             if (.Platform$OS.type == "windows") {
[17:00:32.639]                 old_names <- names(...future.oldEnvVars)
[17:00:32.639]                 envs <- base::Sys.getenv()
[17:00:32.639]                 names <- names(envs)
[17:00:32.639]                 common <- intersect(names, old_names)
[17:00:32.639]                 added <- setdiff(names, old_names)
[17:00:32.639]                 removed <- setdiff(old_names, names)
[17:00:32.639]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:32.639]                   envs[common]]
[17:00:32.639]                 NAMES <- toupper(changed)
[17:00:32.639]                 args <- list()
[17:00:32.639]                 for (kk in seq_along(NAMES)) {
[17:00:32.639]                   name <- changed[[kk]]
[17:00:32.639]                   NAME <- NAMES[[kk]]
[17:00:32.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.639]                     next
[17:00:32.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.639]                 }
[17:00:32.639]                 NAMES <- toupper(added)
[17:00:32.639]                 for (kk in seq_along(NAMES)) {
[17:00:32.639]                   name <- added[[kk]]
[17:00:32.639]                   NAME <- NAMES[[kk]]
[17:00:32.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.639]                     next
[17:00:32.639]                   args[[name]] <- ""
[17:00:32.639]                 }
[17:00:32.639]                 NAMES <- toupper(removed)
[17:00:32.639]                 for (kk in seq_along(NAMES)) {
[17:00:32.639]                   name <- removed[[kk]]
[17:00:32.639]                   NAME <- NAMES[[kk]]
[17:00:32.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.639]                     next
[17:00:32.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.639]                 }
[17:00:32.639]                 if (length(args) > 0) 
[17:00:32.639]                   base::do.call(base::Sys.setenv, args = args)
[17:00:32.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:32.639]             }
[17:00:32.639]             else {
[17:00:32.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:32.639]             }
[17:00:32.639]             {
[17:00:32.639]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:32.639]                   0L) {
[17:00:32.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:32.639]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:32.639]                   base::options(opts)
[17:00:32.639]                 }
[17:00:32.639]                 {
[17:00:32.639]                   {
[17:00:32.639]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:32.639]                     NULL
[17:00:32.639]                   }
[17:00:32.639]                   options(future.plan = NULL)
[17:00:32.639]                   if (is.na(NA_character_)) 
[17:00:32.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:32.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:32.639]                     .init = FALSE)
[17:00:32.639]                 }
[17:00:32.639]             }
[17:00:32.639]         }
[17:00:32.639]     })
[17:00:32.639]     if (TRUE) {
[17:00:32.639]         base::sink(type = "output", split = FALSE)
[17:00:32.639]         if (TRUE) {
[17:00:32.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:32.639]         }
[17:00:32.639]         else {
[17:00:32.639]             ...future.result["stdout"] <- base::list(NULL)
[17:00:32.639]         }
[17:00:32.639]         base::close(...future.stdout)
[17:00:32.639]         ...future.stdout <- NULL
[17:00:32.639]     }
[17:00:32.639]     ...future.result$conditions <- ...future.conditions
[17:00:32.639]     ...future.result$finished <- base::Sys.time()
[17:00:32.639]     ...future.result
[17:00:32.639] }
[17:00:32.642] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:00:32.642] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:00:32.642] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:00:32.643] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:32.643] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.643] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:00:32.643] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:00:32.644] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:32.644] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.644] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:32.644] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.645] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:00:32.645] MultisessionFuture started
[17:00:32.645] - Launch lazy future ... done
[17:00:32.645] run() for ‘MultisessionFuture’ ... done
[17:00:32.646] Created future:
[17:00:32.646] MultisessionFuture:
[17:00:32.646] Label: ‘future_mapply-1’
[17:00:32.646] Expression:
[17:00:32.646] {
[17:00:32.646]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.646]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:32.646]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.646]         on.exit(options(oopts), add = TRUE)
[17:00:32.646]     }
[17:00:32.646]     {
[17:00:32.646]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.646]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:32.646]         do.call(mapply, args = args)
[17:00:32.646]     }
[17:00:32.646] }
[17:00:32.646] Lazy evaluation: FALSE
[17:00:32.646] Asynchronous evaluation: TRUE
[17:00:32.646] Local evaluation: TRUE
[17:00:32.646] Environment: R_GlobalEnv
[17:00:32.646] Capture standard output: TRUE
[17:00:32.646] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:32.646] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:32.646] Packages: <none>
[17:00:32.646] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:32.646] Resolved: FALSE
[17:00:32.646] Value: <not collected>
[17:00:32.646] Conditions captured: <none>
[17:00:32.646] Early signaling: FALSE
[17:00:32.646] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:32.646] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.657] Chunk #1 of 2 ... DONE
[17:00:32.658] Chunk #2 of 2 ...
[17:00:32.658]  - Finding globals in '...' for chunk #2 ...
[17:00:32.658] getGlobalsAndPackages() ...
[17:00:32.658] Searching for globals...
[17:00:32.658] 
[17:00:32.658] Searching for globals ... DONE
[17:00:32.659] - globals: [0] <none>
[17:00:32.659] getGlobalsAndPackages() ... DONE
[17:00:32.659]    + additional globals found: [n=0] 
[17:00:32.659]    + additional namespaces needed: [n=0] 
[17:00:32.659]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:32.659]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:32.659]  - seeds: <none>
[17:00:32.659]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.659] getGlobalsAndPackages() ...
[17:00:32.659] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.660] Resolving globals: FALSE
[17:00:32.660] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:32.660] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:32.661] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.661] 
[17:00:32.661] getGlobalsAndPackages() ... DONE
[17:00:32.661] run() for ‘Future’ ...
[17:00:32.661] - state: ‘created’
[17:00:32.661] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:32.676] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.676] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:32.676]   - Field: ‘node’
[17:00:32.676]   - Field: ‘label’
[17:00:32.676]   - Field: ‘local’
[17:00:32.676]   - Field: ‘owner’
[17:00:32.676]   - Field: ‘envir’
[17:00:32.677]   - Field: ‘workers’
[17:00:32.677]   - Field: ‘packages’
[17:00:32.677]   - Field: ‘gc’
[17:00:32.677]   - Field: ‘conditions’
[17:00:32.677]   - Field: ‘persistent’
[17:00:32.677]   - Field: ‘expr’
[17:00:32.677]   - Field: ‘uuid’
[17:00:32.677]   - Field: ‘seed’
[17:00:32.677]   - Field: ‘version’
[17:00:32.677]   - Field: ‘result’
[17:00:32.677]   - Field: ‘asynchronous’
[17:00:32.678]   - Field: ‘calls’
[17:00:32.678]   - Field: ‘globals’
[17:00:32.678]   - Field: ‘stdout’
[17:00:32.678]   - Field: ‘earlySignal’
[17:00:32.678]   - Field: ‘lazy’
[17:00:32.678]   - Field: ‘state’
[17:00:32.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:32.678] - Launch lazy future ...
[17:00:32.678] Packages needed by the future expression (n = 0): <none>
[17:00:32.679] Packages needed by future strategies (n = 0): <none>
[17:00:32.679] {
[17:00:32.679]     {
[17:00:32.679]         {
[17:00:32.679]             ...future.startTime <- base::Sys.time()
[17:00:32.679]             {
[17:00:32.679]                 {
[17:00:32.679]                   {
[17:00:32.679]                     {
[17:00:32.679]                       base::local({
[17:00:32.679]                         has_future <- base::requireNamespace("future", 
[17:00:32.679]                           quietly = TRUE)
[17:00:32.679]                         if (has_future) {
[17:00:32.679]                           ns <- base::getNamespace("future")
[17:00:32.679]                           version <- ns[[".package"]][["version"]]
[17:00:32.679]                           if (is.null(version)) 
[17:00:32.679]                             version <- utils::packageVersion("future")
[17:00:32.679]                         }
[17:00:32.679]                         else {
[17:00:32.679]                           version <- NULL
[17:00:32.679]                         }
[17:00:32.679]                         if (!has_future || version < "1.8.0") {
[17:00:32.679]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:32.679]                             "", base::R.version$version.string), 
[17:00:32.679]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:32.679]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:32.679]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:32.679]                               "release", "version")], collapse = " "), 
[17:00:32.679]                             hostname = base::Sys.info()[["nodename"]])
[17:00:32.679]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:32.679]                             info)
[17:00:32.679]                           info <- base::paste(info, collapse = "; ")
[17:00:32.679]                           if (!has_future) {
[17:00:32.679]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:32.679]                               info)
[17:00:32.679]                           }
[17:00:32.679]                           else {
[17:00:32.679]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:32.679]                               info, version)
[17:00:32.679]                           }
[17:00:32.679]                           base::stop(msg)
[17:00:32.679]                         }
[17:00:32.679]                       })
[17:00:32.679]                     }
[17:00:32.679]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:32.679]                     base::options(mc.cores = 1L)
[17:00:32.679]                   }
[17:00:32.679]                   ...future.strategy.old <- future::plan("list")
[17:00:32.679]                   options(future.plan = NULL)
[17:00:32.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:32.679]                 }
[17:00:32.679]                 ...future.workdir <- getwd()
[17:00:32.679]             }
[17:00:32.679]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:32.679]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:32.679]         }
[17:00:32.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:32.679]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:32.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:32.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:32.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:32.679]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:32.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:32.679]             base::names(...future.oldOptions))
[17:00:32.679]     }
[17:00:32.679]     if (FALSE) {
[17:00:32.679]     }
[17:00:32.679]     else {
[17:00:32.679]         if (TRUE) {
[17:00:32.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:32.679]                 open = "w")
[17:00:32.679]         }
[17:00:32.679]         else {
[17:00:32.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:32.679]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:32.679]         }
[17:00:32.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:32.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:32.679]             base::sink(type = "output", split = FALSE)
[17:00:32.679]             base::close(...future.stdout)
[17:00:32.679]         }, add = TRUE)
[17:00:32.679]     }
[17:00:32.679]     ...future.frame <- base::sys.nframe()
[17:00:32.679]     ...future.conditions <- base::list()
[17:00:32.679]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:32.679]     if (FALSE) {
[17:00:32.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:32.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:32.679]     }
[17:00:32.679]     ...future.result <- base::tryCatch({
[17:00:32.679]         base::withCallingHandlers({
[17:00:32.679]             ...future.value <- base::withVisible(base::local({
[17:00:32.679]                 ...future.makeSendCondition <- base::local({
[17:00:32.679]                   sendCondition <- NULL
[17:00:32.679]                   function(frame = 1L) {
[17:00:32.679]                     if (is.function(sendCondition)) 
[17:00:32.679]                       return(sendCondition)
[17:00:32.679]                     ns <- getNamespace("parallel")
[17:00:32.679]                     if (exists("sendData", mode = "function", 
[17:00:32.679]                       envir = ns)) {
[17:00:32.679]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:32.679]                         envir = ns)
[17:00:32.679]                       envir <- sys.frame(frame)
[17:00:32.679]                       master <- NULL
[17:00:32.679]                       while (!identical(envir, .GlobalEnv) && 
[17:00:32.679]                         !identical(envir, emptyenv())) {
[17:00:32.679]                         if (exists("master", mode = "list", envir = envir, 
[17:00:32.679]                           inherits = FALSE)) {
[17:00:32.679]                           master <- get("master", mode = "list", 
[17:00:32.679]                             envir = envir, inherits = FALSE)
[17:00:32.679]                           if (inherits(master, c("SOCKnode", 
[17:00:32.679]                             "SOCK0node"))) {
[17:00:32.679]                             sendCondition <<- function(cond) {
[17:00:32.679]                               data <- list(type = "VALUE", value = cond, 
[17:00:32.679]                                 success = TRUE)
[17:00:32.679]                               parallel_sendData(master, data)
[17:00:32.679]                             }
[17:00:32.679]                             return(sendCondition)
[17:00:32.679]                           }
[17:00:32.679]                         }
[17:00:32.679]                         frame <- frame + 1L
[17:00:32.679]                         envir <- sys.frame(frame)
[17:00:32.679]                       }
[17:00:32.679]                     }
[17:00:32.679]                     sendCondition <<- function(cond) NULL
[17:00:32.679]                   }
[17:00:32.679]                 })
[17:00:32.679]                 withCallingHandlers({
[17:00:32.679]                   {
[17:00:32.679]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.679]                     if (!identical(...future.globals.maxSize.org, 
[17:00:32.679]                       ...future.globals.maxSize)) {
[17:00:32.679]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.679]                       on.exit(options(oopts), add = TRUE)
[17:00:32.679]                     }
[17:00:32.679]                     {
[17:00:32.679]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.679]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:32.679]                         USE.NAMES = FALSE)
[17:00:32.679]                       do.call(mapply, args = args)
[17:00:32.679]                     }
[17:00:32.679]                   }
[17:00:32.679]                 }, immediateCondition = function(cond) {
[17:00:32.679]                   sendCondition <- ...future.makeSendCondition()
[17:00:32.679]                   sendCondition(cond)
[17:00:32.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.679]                   {
[17:00:32.679]                     inherits <- base::inherits
[17:00:32.679]                     invokeRestart <- base::invokeRestart
[17:00:32.679]                     is.null <- base::is.null
[17:00:32.679]                     muffled <- FALSE
[17:00:32.679]                     if (inherits(cond, "message")) {
[17:00:32.679]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:32.679]                       if (muffled) 
[17:00:32.679]                         invokeRestart("muffleMessage")
[17:00:32.679]                     }
[17:00:32.679]                     else if (inherits(cond, "warning")) {
[17:00:32.679]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:32.679]                       if (muffled) 
[17:00:32.679]                         invokeRestart("muffleWarning")
[17:00:32.679]                     }
[17:00:32.679]                     else if (inherits(cond, "condition")) {
[17:00:32.679]                       if (!is.null(pattern)) {
[17:00:32.679]                         computeRestarts <- base::computeRestarts
[17:00:32.679]                         grepl <- base::grepl
[17:00:32.679]                         restarts <- computeRestarts(cond)
[17:00:32.679]                         for (restart in restarts) {
[17:00:32.679]                           name <- restart$name
[17:00:32.679]                           if (is.null(name)) 
[17:00:32.679]                             next
[17:00:32.679]                           if (!grepl(pattern, name)) 
[17:00:32.679]                             next
[17:00:32.679]                           invokeRestart(restart)
[17:00:32.679]                           muffled <- TRUE
[17:00:32.679]                           break
[17:00:32.679]                         }
[17:00:32.679]                       }
[17:00:32.679]                     }
[17:00:32.679]                     invisible(muffled)
[17:00:32.679]                   }
[17:00:32.679]                   muffleCondition(cond)
[17:00:32.679]                 })
[17:00:32.679]             }))
[17:00:32.679]             future::FutureResult(value = ...future.value$value, 
[17:00:32.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.679]                   ...future.rng), globalenv = if (FALSE) 
[17:00:32.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:32.679]                     ...future.globalenv.names))
[17:00:32.679]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:32.679]         }, condition = base::local({
[17:00:32.679]             c <- base::c
[17:00:32.679]             inherits <- base::inherits
[17:00:32.679]             invokeRestart <- base::invokeRestart
[17:00:32.679]             length <- base::length
[17:00:32.679]             list <- base::list
[17:00:32.679]             seq.int <- base::seq.int
[17:00:32.679]             signalCondition <- base::signalCondition
[17:00:32.679]             sys.calls <- base::sys.calls
[17:00:32.679]             `[[` <- base::`[[`
[17:00:32.679]             `+` <- base::`+`
[17:00:32.679]             `<<-` <- base::`<<-`
[17:00:32.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:32.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:32.679]                   3L)]
[17:00:32.679]             }
[17:00:32.679]             function(cond) {
[17:00:32.679]                 is_error <- inherits(cond, "error")
[17:00:32.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:32.679]                   NULL)
[17:00:32.679]                 if (is_error) {
[17:00:32.679]                   sessionInformation <- function() {
[17:00:32.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:32.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:32.679]                       search = base::search(), system = base::Sys.info())
[17:00:32.679]                   }
[17:00:32.679]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:32.679]                     cond$call), session = sessionInformation(), 
[17:00:32.679]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:32.679]                   signalCondition(cond)
[17:00:32.679]                 }
[17:00:32.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:32.679]                 "immediateCondition"))) {
[17:00:32.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:32.679]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:32.679]                   if (TRUE && !signal) {
[17:00:32.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.679]                     {
[17:00:32.679]                       inherits <- base::inherits
[17:00:32.679]                       invokeRestart <- base::invokeRestart
[17:00:32.679]                       is.null <- base::is.null
[17:00:32.679]                       muffled <- FALSE
[17:00:32.679]                       if (inherits(cond, "message")) {
[17:00:32.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.679]                         if (muffled) 
[17:00:32.679]                           invokeRestart("muffleMessage")
[17:00:32.679]                       }
[17:00:32.679]                       else if (inherits(cond, "warning")) {
[17:00:32.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.679]                         if (muffled) 
[17:00:32.679]                           invokeRestart("muffleWarning")
[17:00:32.679]                       }
[17:00:32.679]                       else if (inherits(cond, "condition")) {
[17:00:32.679]                         if (!is.null(pattern)) {
[17:00:32.679]                           computeRestarts <- base::computeRestarts
[17:00:32.679]                           grepl <- base::grepl
[17:00:32.679]                           restarts <- computeRestarts(cond)
[17:00:32.679]                           for (restart in restarts) {
[17:00:32.679]                             name <- restart$name
[17:00:32.679]                             if (is.null(name)) 
[17:00:32.679]                               next
[17:00:32.679]                             if (!grepl(pattern, name)) 
[17:00:32.679]                               next
[17:00:32.679]                             invokeRestart(restart)
[17:00:32.679]                             muffled <- TRUE
[17:00:32.679]                             break
[17:00:32.679]                           }
[17:00:32.679]                         }
[17:00:32.679]                       }
[17:00:32.679]                       invisible(muffled)
[17:00:32.679]                     }
[17:00:32.679]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.679]                   }
[17:00:32.679]                 }
[17:00:32.679]                 else {
[17:00:32.679]                   if (TRUE) {
[17:00:32.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.679]                     {
[17:00:32.679]                       inherits <- base::inherits
[17:00:32.679]                       invokeRestart <- base::invokeRestart
[17:00:32.679]                       is.null <- base::is.null
[17:00:32.679]                       muffled <- FALSE
[17:00:32.679]                       if (inherits(cond, "message")) {
[17:00:32.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.679]                         if (muffled) 
[17:00:32.679]                           invokeRestart("muffleMessage")
[17:00:32.679]                       }
[17:00:32.679]                       else if (inherits(cond, "warning")) {
[17:00:32.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.679]                         if (muffled) 
[17:00:32.679]                           invokeRestart("muffleWarning")
[17:00:32.679]                       }
[17:00:32.679]                       else if (inherits(cond, "condition")) {
[17:00:32.679]                         if (!is.null(pattern)) {
[17:00:32.679]                           computeRestarts <- base::computeRestarts
[17:00:32.679]                           grepl <- base::grepl
[17:00:32.679]                           restarts <- computeRestarts(cond)
[17:00:32.679]                           for (restart in restarts) {
[17:00:32.679]                             name <- restart$name
[17:00:32.679]                             if (is.null(name)) 
[17:00:32.679]                               next
[17:00:32.679]                             if (!grepl(pattern, name)) 
[17:00:32.679]                               next
[17:00:32.679]                             invokeRestart(restart)
[17:00:32.679]                             muffled <- TRUE
[17:00:32.679]                             break
[17:00:32.679]                           }
[17:00:32.679]                         }
[17:00:32.679]                       }
[17:00:32.679]                       invisible(muffled)
[17:00:32.679]                     }
[17:00:32.679]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.679]                   }
[17:00:32.679]                 }
[17:00:32.679]             }
[17:00:32.679]         }))
[17:00:32.679]     }, error = function(ex) {
[17:00:32.679]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:32.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.679]                 ...future.rng), started = ...future.startTime, 
[17:00:32.679]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:32.679]             version = "1.8"), class = "FutureResult")
[17:00:32.679]     }, finally = {
[17:00:32.679]         if (!identical(...future.workdir, getwd())) 
[17:00:32.679]             setwd(...future.workdir)
[17:00:32.679]         {
[17:00:32.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:32.679]                 ...future.oldOptions$nwarnings <- NULL
[17:00:32.679]             }
[17:00:32.679]             base::options(...future.oldOptions)
[17:00:32.679]             if (.Platform$OS.type == "windows") {
[17:00:32.679]                 old_names <- names(...future.oldEnvVars)
[17:00:32.679]                 envs <- base::Sys.getenv()
[17:00:32.679]                 names <- names(envs)
[17:00:32.679]                 common <- intersect(names, old_names)
[17:00:32.679]                 added <- setdiff(names, old_names)
[17:00:32.679]                 removed <- setdiff(old_names, names)
[17:00:32.679]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:32.679]                   envs[common]]
[17:00:32.679]                 NAMES <- toupper(changed)
[17:00:32.679]                 args <- list()
[17:00:32.679]                 for (kk in seq_along(NAMES)) {
[17:00:32.679]                   name <- changed[[kk]]
[17:00:32.679]                   NAME <- NAMES[[kk]]
[17:00:32.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.679]                     next
[17:00:32.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.679]                 }
[17:00:32.679]                 NAMES <- toupper(added)
[17:00:32.679]                 for (kk in seq_along(NAMES)) {
[17:00:32.679]                   name <- added[[kk]]
[17:00:32.679]                   NAME <- NAMES[[kk]]
[17:00:32.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.679]                     next
[17:00:32.679]                   args[[name]] <- ""
[17:00:32.679]                 }
[17:00:32.679]                 NAMES <- toupper(removed)
[17:00:32.679]                 for (kk in seq_along(NAMES)) {
[17:00:32.679]                   name <- removed[[kk]]
[17:00:32.679]                   NAME <- NAMES[[kk]]
[17:00:32.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.679]                     next
[17:00:32.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.679]                 }
[17:00:32.679]                 if (length(args) > 0) 
[17:00:32.679]                   base::do.call(base::Sys.setenv, args = args)
[17:00:32.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:32.679]             }
[17:00:32.679]             else {
[17:00:32.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:32.679]             }
[17:00:32.679]             {
[17:00:32.679]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:32.679]                   0L) {
[17:00:32.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:32.679]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:32.679]                   base::options(opts)
[17:00:32.679]                 }
[17:00:32.679]                 {
[17:00:32.679]                   {
[17:00:32.679]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:32.679]                     NULL
[17:00:32.679]                   }
[17:00:32.679]                   options(future.plan = NULL)
[17:00:32.679]                   if (is.na(NA_character_)) 
[17:00:32.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:32.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:32.679]                     .init = FALSE)
[17:00:32.679]                 }
[17:00:32.679]             }
[17:00:32.679]         }
[17:00:32.679]     })
[17:00:32.679]     if (TRUE) {
[17:00:32.679]         base::sink(type = "output", split = FALSE)
[17:00:32.679]         if (TRUE) {
[17:00:32.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:32.679]         }
[17:00:32.679]         else {
[17:00:32.679]             ...future.result["stdout"] <- base::list(NULL)
[17:00:32.679]         }
[17:00:32.679]         base::close(...future.stdout)
[17:00:32.679]         ...future.stdout <- NULL
[17:00:32.679]     }
[17:00:32.679]     ...future.result$conditions <- ...future.conditions
[17:00:32.679]     ...future.result$finished <- base::Sys.time()
[17:00:32.679]     ...future.result
[17:00:32.679] }
[17:00:32.682] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:00:32.682] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:00:32.682] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:00:32.683] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:32.683] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.683] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:00:32.684] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:00:32.684] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:32.684] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.684] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:32.685] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.685] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:00:32.685] MultisessionFuture started
[17:00:32.685] - Launch lazy future ... done
[17:00:32.685] run() for ‘MultisessionFuture’ ... done
[17:00:32.686] Created future:
[17:00:32.686] MultisessionFuture:
[17:00:32.686] Label: ‘future_mapply-2’
[17:00:32.686] Expression:
[17:00:32.686] {
[17:00:32.686]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.686]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:32.686]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.686]         on.exit(options(oopts), add = TRUE)
[17:00:32.686]     }
[17:00:32.686]     {
[17:00:32.686]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.686]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:32.686]         do.call(mapply, args = args)
[17:00:32.686]     }
[17:00:32.686] }
[17:00:32.686] Lazy evaluation: FALSE
[17:00:32.686] Asynchronous evaluation: TRUE
[17:00:32.686] Local evaluation: TRUE
[17:00:32.686] Environment: R_GlobalEnv
[17:00:32.686] Capture standard output: TRUE
[17:00:32.686] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:32.686] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:32.686] Packages: <none>
[17:00:32.686] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:32.686] Resolved: FALSE
[17:00:32.686] Value: <not collected>
[17:00:32.686] Conditions captured: <none>
[17:00:32.686] Early signaling: FALSE
[17:00:32.686] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:32.686] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.697] Chunk #2 of 2 ... DONE
[17:00:32.697] Launching 2 futures (chunks) ... DONE
[17:00:32.697] Resolving 2 futures (chunks) ...
[17:00:32.698] resolve() on list ...
[17:00:32.698]  recursive: 0
[17:00:32.698]  length: 2
[17:00:32.698] 
[17:00:32.698] receiveMessageFromWorker() for ClusterFuture ...
[17:00:32.699] - Validating connection of MultisessionFuture
[17:00:32.699] - received message: FutureResult
[17:00:32.699] - Received FutureResult
[17:00:32.699] - Erased future from FutureRegistry
[17:00:32.699] result() for ClusterFuture ...
[17:00:32.699] - result already collected: FutureResult
[17:00:32.699] result() for ClusterFuture ... done
[17:00:32.699] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:32.700] Future #1
[17:00:32.700] result() for ClusterFuture ...
[17:00:32.700] - result already collected: FutureResult
[17:00:32.700] result() for ClusterFuture ... done
[17:00:32.700] result() for ClusterFuture ...
[17:00:32.700] - result already collected: FutureResult
[17:00:32.700] result() for ClusterFuture ... done
[17:00:32.700] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:32.700] - nx: 2
[17:00:32.700] - relay: TRUE
[17:00:32.700] - stdout: TRUE
[17:00:32.700] - signal: TRUE
[17:00:32.701] - resignal: FALSE
[17:00:32.701] - force: TRUE
[17:00:32.701] - relayed: [n=2] FALSE, FALSE
[17:00:32.701] - queued futures: [n=2] FALSE, FALSE
[17:00:32.701]  - until=1
[17:00:32.701]  - relaying element #1
[17:00:32.701] result() for ClusterFuture ...
[17:00:32.701] - result already collected: FutureResult
[17:00:32.701] result() for ClusterFuture ... done
[17:00:32.701] result() for ClusterFuture ...
[17:00:32.701] - result already collected: FutureResult
[17:00:32.702] result() for ClusterFuture ... done
[17:00:32.702] result() for ClusterFuture ...
[17:00:32.702] - result already collected: FutureResult
[17:00:32.702] result() for ClusterFuture ... done
[17:00:32.702] result() for ClusterFuture ...
[17:00:32.702] - result already collected: FutureResult
[17:00:32.702] result() for ClusterFuture ... done
[17:00:32.702] - relayed: [n=2] TRUE, FALSE
[17:00:32.702] - queued futures: [n=2] TRUE, FALSE
[17:00:32.702] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:32.702]  length: 1 (resolved future 1)
[17:00:32.729] receiveMessageFromWorker() for ClusterFuture ...
[17:00:32.729] - Validating connection of MultisessionFuture
[17:00:32.729] - received message: FutureResult
[17:00:32.730] - Received FutureResult
[17:00:32.730] - Erased future from FutureRegistry
[17:00:32.730] result() for ClusterFuture ...
[17:00:32.730] - result already collected: FutureResult
[17:00:32.730] result() for ClusterFuture ... done
[17:00:32.730] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:32.730] Future #2
[17:00:32.730] result() for ClusterFuture ...
[17:00:32.730] - result already collected: FutureResult
[17:00:32.730] result() for ClusterFuture ... done
[17:00:32.731] result() for ClusterFuture ...
[17:00:32.731] - result already collected: FutureResult
[17:00:32.731] result() for ClusterFuture ... done
[17:00:32.731] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:32.731] - nx: 2
[17:00:32.731] - relay: TRUE
[17:00:32.731] - stdout: TRUE
[17:00:32.731] - signal: TRUE
[17:00:32.731] - resignal: FALSE
[17:00:32.731] - force: TRUE
[17:00:32.731] - relayed: [n=2] TRUE, FALSE
[17:00:32.732] - queued futures: [n=2] TRUE, FALSE
[17:00:32.732]  - until=2
[17:00:32.732]  - relaying element #2
[17:00:32.732] result() for ClusterFuture ...
[17:00:32.732] - result already collected: FutureResult
[17:00:32.732] result() for ClusterFuture ... done
[17:00:32.732] result() for ClusterFuture ...
[17:00:32.732] - result already collected: FutureResult
[17:00:32.732] result() for ClusterFuture ... done
[17:00:32.732] result() for ClusterFuture ...
[17:00:32.732] - result already collected: FutureResult
[17:00:32.733] result() for ClusterFuture ... done
[17:00:32.733] result() for ClusterFuture ...
[17:00:32.733] - result already collected: FutureResult
[17:00:32.733] result() for ClusterFuture ... done
[17:00:32.733] - relayed: [n=2] TRUE, TRUE
[17:00:32.733] - queued futures: [n=2] TRUE, TRUE
[17:00:32.733] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:32.733]  length: 0 (resolved future 2)
[17:00:32.733] Relaying remaining futures
[17:00:32.733] signalConditionsASAP(NULL, pos=0) ...
[17:00:32.733] - nx: 2
[17:00:32.734] - relay: TRUE
[17:00:32.734] - stdout: TRUE
[17:00:32.734] - signal: TRUE
[17:00:32.734] - resignal: FALSE
[17:00:32.734] - force: TRUE
[17:00:32.734] - relayed: [n=2] TRUE, TRUE
[17:00:32.734] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:32.734] - relayed: [n=2] TRUE, TRUE
[17:00:32.734] - queued futures: [n=2] TRUE, TRUE
[17:00:32.734] signalConditionsASAP(NULL, pos=0) ... done
[17:00:32.734] resolve() on list ... DONE
[17:00:32.734] result() for ClusterFuture ...
[17:00:32.735] - result already collected: FutureResult
[17:00:32.735] result() for ClusterFuture ... done
[17:00:32.735] result() for ClusterFuture ...
[17:00:32.735] - result already collected: FutureResult
[17:00:32.735] result() for ClusterFuture ... done
[17:00:32.735] result() for ClusterFuture ...
[17:00:32.735] - result already collected: FutureResult
[17:00:32.735] result() for ClusterFuture ... done
[17:00:32.735] result() for ClusterFuture ...
[17:00:32.735] - result already collected: FutureResult
[17:00:32.735] result() for ClusterFuture ... done
[17:00:32.736]  - Number of value chunks collected: 2
[17:00:32.736] Resolving 2 futures (chunks) ... DONE
[17:00:32.736] Reducing values from 2 chunks ...
[17:00:32.736]  - Number of values collected after concatenation: 4
[17:00:32.736]  - Number of values expected: 4
[17:00:32.736] Reducing values from 2 chunks ... DONE
[17:00:32.736] future_mapply() ... DONE
[17:00:32.736] future_mapply() ...
[17:00:32.740] Number of chunks: 2
[17:00:32.740] getGlobalsAndPackagesXApply() ...
[17:00:32.741]  - future.globals: TRUE
[17:00:32.741] getGlobalsAndPackages() ...
[17:00:32.741] Searching for globals...
[17:00:32.741] - globals found: [1] ‘FUN’
[17:00:32.741] Searching for globals ... DONE
[17:00:32.742] Resolving globals: FALSE
[17:00:32.742] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:32.742] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:32.742] - globals: [1] ‘FUN’
[17:00:32.742] 
[17:00:32.742] getGlobalsAndPackages() ... DONE
[17:00:32.743]  - globals found/used: [n=1] ‘FUN’
[17:00:32.743]  - needed namespaces: [n=0] 
[17:00:32.743] Finding globals ... DONE
[17:00:32.743] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:32.743] List of 2
[17:00:32.743]  $ ...future.FUN:function (x, ...)  
[17:00:32.743]  $ MoreArgs     : NULL
[17:00:32.743]  - attr(*, "where")=List of 2
[17:00:32.743]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:32.743]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:32.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:32.743]  - attr(*, "resolved")= logi FALSE
[17:00:32.743]  - attr(*, "total_size")= num NA
[17:00:32.746] Packages to be attached in all futures: [n=0] 
[17:00:32.746] getGlobalsAndPackagesXApply() ... DONE
[17:00:32.746] Number of futures (= number of chunks): 2
[17:00:32.746] Launching 2 futures (chunks) ...
[17:00:32.746] Chunk #1 of 2 ...
[17:00:32.746]  - Finding globals in '...' for chunk #1 ...
[17:00:32.746] getGlobalsAndPackages() ...
[17:00:32.746] Searching for globals...
[17:00:32.747] 
[17:00:32.747] Searching for globals ... DONE
[17:00:32.747] - globals: [0] <none>
[17:00:32.747] getGlobalsAndPackages() ... DONE
[17:00:32.747]    + additional globals found: [n=0] 
[17:00:32.747]    + additional namespaces needed: [n=0] 
[17:00:32.747]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:32.747]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:32.747]  - seeds: <none>
[17:00:32.747]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.748] getGlobalsAndPackages() ...
[17:00:32.748] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.748] Resolving globals: FALSE
[17:00:32.748] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:32.749] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:32.749] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.749] 
[17:00:32.749] getGlobalsAndPackages() ... DONE
[17:00:32.749] run() for ‘Future’ ...
[17:00:32.749] - state: ‘created’
[17:00:32.750] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:32.764] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:32.764]   - Field: ‘node’
[17:00:32.764]   - Field: ‘label’
[17:00:32.764]   - Field: ‘local’
[17:00:32.764]   - Field: ‘owner’
[17:00:32.764]   - Field: ‘envir’
[17:00:32.764]   - Field: ‘workers’
[17:00:32.765]   - Field: ‘packages’
[17:00:32.765]   - Field: ‘gc’
[17:00:32.765]   - Field: ‘conditions’
[17:00:32.765]   - Field: ‘persistent’
[17:00:32.765]   - Field: ‘expr’
[17:00:32.765]   - Field: ‘uuid’
[17:00:32.765]   - Field: ‘seed’
[17:00:32.765]   - Field: ‘version’
[17:00:32.765]   - Field: ‘result’
[17:00:32.765]   - Field: ‘asynchronous’
[17:00:32.765]   - Field: ‘calls’
[17:00:32.765]   - Field: ‘globals’
[17:00:32.766]   - Field: ‘stdout’
[17:00:32.766]   - Field: ‘earlySignal’
[17:00:32.766]   - Field: ‘lazy’
[17:00:32.766]   - Field: ‘state’
[17:00:32.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:32.766] - Launch lazy future ...
[17:00:32.766] Packages needed by the future expression (n = 0): <none>
[17:00:32.766] Packages needed by future strategies (n = 0): <none>
[17:00:32.767] {
[17:00:32.767]     {
[17:00:32.767]         {
[17:00:32.767]             ...future.startTime <- base::Sys.time()
[17:00:32.767]             {
[17:00:32.767]                 {
[17:00:32.767]                   {
[17:00:32.767]                     {
[17:00:32.767]                       base::local({
[17:00:32.767]                         has_future <- base::requireNamespace("future", 
[17:00:32.767]                           quietly = TRUE)
[17:00:32.767]                         if (has_future) {
[17:00:32.767]                           ns <- base::getNamespace("future")
[17:00:32.767]                           version <- ns[[".package"]][["version"]]
[17:00:32.767]                           if (is.null(version)) 
[17:00:32.767]                             version <- utils::packageVersion("future")
[17:00:32.767]                         }
[17:00:32.767]                         else {
[17:00:32.767]                           version <- NULL
[17:00:32.767]                         }
[17:00:32.767]                         if (!has_future || version < "1.8.0") {
[17:00:32.767]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:32.767]                             "", base::R.version$version.string), 
[17:00:32.767]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:32.767]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:32.767]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:32.767]                               "release", "version")], collapse = " "), 
[17:00:32.767]                             hostname = base::Sys.info()[["nodename"]])
[17:00:32.767]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:32.767]                             info)
[17:00:32.767]                           info <- base::paste(info, collapse = "; ")
[17:00:32.767]                           if (!has_future) {
[17:00:32.767]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:32.767]                               info)
[17:00:32.767]                           }
[17:00:32.767]                           else {
[17:00:32.767]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:32.767]                               info, version)
[17:00:32.767]                           }
[17:00:32.767]                           base::stop(msg)
[17:00:32.767]                         }
[17:00:32.767]                       })
[17:00:32.767]                     }
[17:00:32.767]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:32.767]                     base::options(mc.cores = 1L)
[17:00:32.767]                   }
[17:00:32.767]                   ...future.strategy.old <- future::plan("list")
[17:00:32.767]                   options(future.plan = NULL)
[17:00:32.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:32.767]                 }
[17:00:32.767]                 ...future.workdir <- getwd()
[17:00:32.767]             }
[17:00:32.767]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:32.767]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:32.767]         }
[17:00:32.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:32.767]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:32.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:32.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:32.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:32.767]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:32.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:32.767]             base::names(...future.oldOptions))
[17:00:32.767]     }
[17:00:32.767]     if (FALSE) {
[17:00:32.767]     }
[17:00:32.767]     else {
[17:00:32.767]         if (TRUE) {
[17:00:32.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:32.767]                 open = "w")
[17:00:32.767]         }
[17:00:32.767]         else {
[17:00:32.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:32.767]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:32.767]         }
[17:00:32.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:32.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:32.767]             base::sink(type = "output", split = FALSE)
[17:00:32.767]             base::close(...future.stdout)
[17:00:32.767]         }, add = TRUE)
[17:00:32.767]     }
[17:00:32.767]     ...future.frame <- base::sys.nframe()
[17:00:32.767]     ...future.conditions <- base::list()
[17:00:32.767]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:32.767]     if (FALSE) {
[17:00:32.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:32.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:32.767]     }
[17:00:32.767]     ...future.result <- base::tryCatch({
[17:00:32.767]         base::withCallingHandlers({
[17:00:32.767]             ...future.value <- base::withVisible(base::local({
[17:00:32.767]                 ...future.makeSendCondition <- base::local({
[17:00:32.767]                   sendCondition <- NULL
[17:00:32.767]                   function(frame = 1L) {
[17:00:32.767]                     if (is.function(sendCondition)) 
[17:00:32.767]                       return(sendCondition)
[17:00:32.767]                     ns <- getNamespace("parallel")
[17:00:32.767]                     if (exists("sendData", mode = "function", 
[17:00:32.767]                       envir = ns)) {
[17:00:32.767]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:32.767]                         envir = ns)
[17:00:32.767]                       envir <- sys.frame(frame)
[17:00:32.767]                       master <- NULL
[17:00:32.767]                       while (!identical(envir, .GlobalEnv) && 
[17:00:32.767]                         !identical(envir, emptyenv())) {
[17:00:32.767]                         if (exists("master", mode = "list", envir = envir, 
[17:00:32.767]                           inherits = FALSE)) {
[17:00:32.767]                           master <- get("master", mode = "list", 
[17:00:32.767]                             envir = envir, inherits = FALSE)
[17:00:32.767]                           if (inherits(master, c("SOCKnode", 
[17:00:32.767]                             "SOCK0node"))) {
[17:00:32.767]                             sendCondition <<- function(cond) {
[17:00:32.767]                               data <- list(type = "VALUE", value = cond, 
[17:00:32.767]                                 success = TRUE)
[17:00:32.767]                               parallel_sendData(master, data)
[17:00:32.767]                             }
[17:00:32.767]                             return(sendCondition)
[17:00:32.767]                           }
[17:00:32.767]                         }
[17:00:32.767]                         frame <- frame + 1L
[17:00:32.767]                         envir <- sys.frame(frame)
[17:00:32.767]                       }
[17:00:32.767]                     }
[17:00:32.767]                     sendCondition <<- function(cond) NULL
[17:00:32.767]                   }
[17:00:32.767]                 })
[17:00:32.767]                 withCallingHandlers({
[17:00:32.767]                   {
[17:00:32.767]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.767]                     if (!identical(...future.globals.maxSize.org, 
[17:00:32.767]                       ...future.globals.maxSize)) {
[17:00:32.767]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.767]                       on.exit(options(oopts), add = TRUE)
[17:00:32.767]                     }
[17:00:32.767]                     {
[17:00:32.767]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.767]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:32.767]                         USE.NAMES = FALSE)
[17:00:32.767]                       do.call(mapply, args = args)
[17:00:32.767]                     }
[17:00:32.767]                   }
[17:00:32.767]                 }, immediateCondition = function(cond) {
[17:00:32.767]                   sendCondition <- ...future.makeSendCondition()
[17:00:32.767]                   sendCondition(cond)
[17:00:32.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.767]                   {
[17:00:32.767]                     inherits <- base::inherits
[17:00:32.767]                     invokeRestart <- base::invokeRestart
[17:00:32.767]                     is.null <- base::is.null
[17:00:32.767]                     muffled <- FALSE
[17:00:32.767]                     if (inherits(cond, "message")) {
[17:00:32.767]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:32.767]                       if (muffled) 
[17:00:32.767]                         invokeRestart("muffleMessage")
[17:00:32.767]                     }
[17:00:32.767]                     else if (inherits(cond, "warning")) {
[17:00:32.767]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:32.767]                       if (muffled) 
[17:00:32.767]                         invokeRestart("muffleWarning")
[17:00:32.767]                     }
[17:00:32.767]                     else if (inherits(cond, "condition")) {
[17:00:32.767]                       if (!is.null(pattern)) {
[17:00:32.767]                         computeRestarts <- base::computeRestarts
[17:00:32.767]                         grepl <- base::grepl
[17:00:32.767]                         restarts <- computeRestarts(cond)
[17:00:32.767]                         for (restart in restarts) {
[17:00:32.767]                           name <- restart$name
[17:00:32.767]                           if (is.null(name)) 
[17:00:32.767]                             next
[17:00:32.767]                           if (!grepl(pattern, name)) 
[17:00:32.767]                             next
[17:00:32.767]                           invokeRestart(restart)
[17:00:32.767]                           muffled <- TRUE
[17:00:32.767]                           break
[17:00:32.767]                         }
[17:00:32.767]                       }
[17:00:32.767]                     }
[17:00:32.767]                     invisible(muffled)
[17:00:32.767]                   }
[17:00:32.767]                   muffleCondition(cond)
[17:00:32.767]                 })
[17:00:32.767]             }))
[17:00:32.767]             future::FutureResult(value = ...future.value$value, 
[17:00:32.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.767]                   ...future.rng), globalenv = if (FALSE) 
[17:00:32.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:32.767]                     ...future.globalenv.names))
[17:00:32.767]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:32.767]         }, condition = base::local({
[17:00:32.767]             c <- base::c
[17:00:32.767]             inherits <- base::inherits
[17:00:32.767]             invokeRestart <- base::invokeRestart
[17:00:32.767]             length <- base::length
[17:00:32.767]             list <- base::list
[17:00:32.767]             seq.int <- base::seq.int
[17:00:32.767]             signalCondition <- base::signalCondition
[17:00:32.767]             sys.calls <- base::sys.calls
[17:00:32.767]             `[[` <- base::`[[`
[17:00:32.767]             `+` <- base::`+`
[17:00:32.767]             `<<-` <- base::`<<-`
[17:00:32.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:32.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:32.767]                   3L)]
[17:00:32.767]             }
[17:00:32.767]             function(cond) {
[17:00:32.767]                 is_error <- inherits(cond, "error")
[17:00:32.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:32.767]                   NULL)
[17:00:32.767]                 if (is_error) {
[17:00:32.767]                   sessionInformation <- function() {
[17:00:32.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:32.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:32.767]                       search = base::search(), system = base::Sys.info())
[17:00:32.767]                   }
[17:00:32.767]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:32.767]                     cond$call), session = sessionInformation(), 
[17:00:32.767]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:32.767]                   signalCondition(cond)
[17:00:32.767]                 }
[17:00:32.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:32.767]                 "immediateCondition"))) {
[17:00:32.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:32.767]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:32.767]                   if (TRUE && !signal) {
[17:00:32.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.767]                     {
[17:00:32.767]                       inherits <- base::inherits
[17:00:32.767]                       invokeRestart <- base::invokeRestart
[17:00:32.767]                       is.null <- base::is.null
[17:00:32.767]                       muffled <- FALSE
[17:00:32.767]                       if (inherits(cond, "message")) {
[17:00:32.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.767]                         if (muffled) 
[17:00:32.767]                           invokeRestart("muffleMessage")
[17:00:32.767]                       }
[17:00:32.767]                       else if (inherits(cond, "warning")) {
[17:00:32.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.767]                         if (muffled) 
[17:00:32.767]                           invokeRestart("muffleWarning")
[17:00:32.767]                       }
[17:00:32.767]                       else if (inherits(cond, "condition")) {
[17:00:32.767]                         if (!is.null(pattern)) {
[17:00:32.767]                           computeRestarts <- base::computeRestarts
[17:00:32.767]                           grepl <- base::grepl
[17:00:32.767]                           restarts <- computeRestarts(cond)
[17:00:32.767]                           for (restart in restarts) {
[17:00:32.767]                             name <- restart$name
[17:00:32.767]                             if (is.null(name)) 
[17:00:32.767]                               next
[17:00:32.767]                             if (!grepl(pattern, name)) 
[17:00:32.767]                               next
[17:00:32.767]                             invokeRestart(restart)
[17:00:32.767]                             muffled <- TRUE
[17:00:32.767]                             break
[17:00:32.767]                           }
[17:00:32.767]                         }
[17:00:32.767]                       }
[17:00:32.767]                       invisible(muffled)
[17:00:32.767]                     }
[17:00:32.767]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.767]                   }
[17:00:32.767]                 }
[17:00:32.767]                 else {
[17:00:32.767]                   if (TRUE) {
[17:00:32.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.767]                     {
[17:00:32.767]                       inherits <- base::inherits
[17:00:32.767]                       invokeRestart <- base::invokeRestart
[17:00:32.767]                       is.null <- base::is.null
[17:00:32.767]                       muffled <- FALSE
[17:00:32.767]                       if (inherits(cond, "message")) {
[17:00:32.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.767]                         if (muffled) 
[17:00:32.767]                           invokeRestart("muffleMessage")
[17:00:32.767]                       }
[17:00:32.767]                       else if (inherits(cond, "warning")) {
[17:00:32.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.767]                         if (muffled) 
[17:00:32.767]                           invokeRestart("muffleWarning")
[17:00:32.767]                       }
[17:00:32.767]                       else if (inherits(cond, "condition")) {
[17:00:32.767]                         if (!is.null(pattern)) {
[17:00:32.767]                           computeRestarts <- base::computeRestarts
[17:00:32.767]                           grepl <- base::grepl
[17:00:32.767]                           restarts <- computeRestarts(cond)
[17:00:32.767]                           for (restart in restarts) {
[17:00:32.767]                             name <- restart$name
[17:00:32.767]                             if (is.null(name)) 
[17:00:32.767]                               next
[17:00:32.767]                             if (!grepl(pattern, name)) 
[17:00:32.767]                               next
[17:00:32.767]                             invokeRestart(restart)
[17:00:32.767]                             muffled <- TRUE
[17:00:32.767]                             break
[17:00:32.767]                           }
[17:00:32.767]                         }
[17:00:32.767]                       }
[17:00:32.767]                       invisible(muffled)
[17:00:32.767]                     }
[17:00:32.767]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.767]                   }
[17:00:32.767]                 }
[17:00:32.767]             }
[17:00:32.767]         }))
[17:00:32.767]     }, error = function(ex) {
[17:00:32.767]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:32.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.767]                 ...future.rng), started = ...future.startTime, 
[17:00:32.767]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:32.767]             version = "1.8"), class = "FutureResult")
[17:00:32.767]     }, finally = {
[17:00:32.767]         if (!identical(...future.workdir, getwd())) 
[17:00:32.767]             setwd(...future.workdir)
[17:00:32.767]         {
[17:00:32.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:32.767]                 ...future.oldOptions$nwarnings <- NULL
[17:00:32.767]             }
[17:00:32.767]             base::options(...future.oldOptions)
[17:00:32.767]             if (.Platform$OS.type == "windows") {
[17:00:32.767]                 old_names <- names(...future.oldEnvVars)
[17:00:32.767]                 envs <- base::Sys.getenv()
[17:00:32.767]                 names <- names(envs)
[17:00:32.767]                 common <- intersect(names, old_names)
[17:00:32.767]                 added <- setdiff(names, old_names)
[17:00:32.767]                 removed <- setdiff(old_names, names)
[17:00:32.767]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:32.767]                   envs[common]]
[17:00:32.767]                 NAMES <- toupper(changed)
[17:00:32.767]                 args <- list()
[17:00:32.767]                 for (kk in seq_along(NAMES)) {
[17:00:32.767]                   name <- changed[[kk]]
[17:00:32.767]                   NAME <- NAMES[[kk]]
[17:00:32.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.767]                     next
[17:00:32.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.767]                 }
[17:00:32.767]                 NAMES <- toupper(added)
[17:00:32.767]                 for (kk in seq_along(NAMES)) {
[17:00:32.767]                   name <- added[[kk]]
[17:00:32.767]                   NAME <- NAMES[[kk]]
[17:00:32.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.767]                     next
[17:00:32.767]                   args[[name]] <- ""
[17:00:32.767]                 }
[17:00:32.767]                 NAMES <- toupper(removed)
[17:00:32.767]                 for (kk in seq_along(NAMES)) {
[17:00:32.767]                   name <- removed[[kk]]
[17:00:32.767]                   NAME <- NAMES[[kk]]
[17:00:32.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.767]                     next
[17:00:32.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.767]                 }
[17:00:32.767]                 if (length(args) > 0) 
[17:00:32.767]                   base::do.call(base::Sys.setenv, args = args)
[17:00:32.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:32.767]             }
[17:00:32.767]             else {
[17:00:32.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:32.767]             }
[17:00:32.767]             {
[17:00:32.767]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:32.767]                   0L) {
[17:00:32.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:32.767]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:32.767]                   base::options(opts)
[17:00:32.767]                 }
[17:00:32.767]                 {
[17:00:32.767]                   {
[17:00:32.767]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:32.767]                     NULL
[17:00:32.767]                   }
[17:00:32.767]                   options(future.plan = NULL)
[17:00:32.767]                   if (is.na(NA_character_)) 
[17:00:32.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:32.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:32.767]                     .init = FALSE)
[17:00:32.767]                 }
[17:00:32.767]             }
[17:00:32.767]         }
[17:00:32.767]     })
[17:00:32.767]     if (TRUE) {
[17:00:32.767]         base::sink(type = "output", split = FALSE)
[17:00:32.767]         if (TRUE) {
[17:00:32.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:32.767]         }
[17:00:32.767]         else {
[17:00:32.767]             ...future.result["stdout"] <- base::list(NULL)
[17:00:32.767]         }
[17:00:32.767]         base::close(...future.stdout)
[17:00:32.767]         ...future.stdout <- NULL
[17:00:32.767]     }
[17:00:32.767]     ...future.result$conditions <- ...future.conditions
[17:00:32.767]     ...future.result$finished <- base::Sys.time()
[17:00:32.767]     ...future.result
[17:00:32.767] }
[17:00:32.770] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:00:32.770] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:00:32.770] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:00:32.770] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:32.771] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.771] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:00:32.771] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:00:32.771] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:32.771] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.772] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:32.772] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.772] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:00:32.772] MultisessionFuture started
[17:00:32.773] - Launch lazy future ... done
[17:00:32.773] run() for ‘MultisessionFuture’ ... done
[17:00:32.773] Created future:
[17:00:32.773] MultisessionFuture:
[17:00:32.773] Label: ‘future_mapply-1’
[17:00:32.773] Expression:
[17:00:32.773] {
[17:00:32.773]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.773]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:32.773]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.773]         on.exit(options(oopts), add = TRUE)
[17:00:32.773]     }
[17:00:32.773]     {
[17:00:32.773]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.773]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:32.773]         do.call(mapply, args = args)
[17:00:32.773]     }
[17:00:32.773] }
[17:00:32.773] Lazy evaluation: FALSE
[17:00:32.773] Asynchronous evaluation: TRUE
[17:00:32.773] Local evaluation: TRUE
[17:00:32.773] Environment: R_GlobalEnv
[17:00:32.773] Capture standard output: TRUE
[17:00:32.773] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:32.773] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:32.773] Packages: <none>
[17:00:32.773] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:32.773] Resolved: FALSE
[17:00:32.773] Value: <not collected>
[17:00:32.773] Conditions captured: <none>
[17:00:32.773] Early signaling: FALSE
[17:00:32.773] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:32.773] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.784] Chunk #1 of 2 ... DONE
[17:00:32.784] Chunk #2 of 2 ...
[17:00:32.785]  - Finding globals in '...' for chunk #2 ...
[17:00:32.785] getGlobalsAndPackages() ...
[17:00:32.785] Searching for globals...
[17:00:32.785] 
[17:00:32.785] Searching for globals ... DONE
[17:00:32.785] - globals: [0] <none>
[17:00:32.785] getGlobalsAndPackages() ... DONE
[17:00:32.785]    + additional globals found: [n=0] 
[17:00:32.786]    + additional namespaces needed: [n=0] 
[17:00:32.786]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:32.786]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:32.786]  - seeds: <none>
[17:00:32.786]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.786] getGlobalsAndPackages() ...
[17:00:32.786] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.786] Resolving globals: FALSE
[17:00:32.787] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:32.787] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:32.789] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.789] 
[17:00:32.790] getGlobalsAndPackages() ... DONE
[17:00:32.790] run() for ‘Future’ ...
[17:00:32.790] - state: ‘created’
[17:00:32.790] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:32.805] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.805] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:32.806]   - Field: ‘node’
[17:00:32.806]   - Field: ‘label’
[17:00:32.806]   - Field: ‘local’
[17:00:32.806]   - Field: ‘owner’
[17:00:32.806]   - Field: ‘envir’
[17:00:32.806]   - Field: ‘workers’
[17:00:32.806]   - Field: ‘packages’
[17:00:32.806]   - Field: ‘gc’
[17:00:32.806]   - Field: ‘conditions’
[17:00:32.806]   - Field: ‘persistent’
[17:00:32.807]   - Field: ‘expr’
[17:00:32.807]   - Field: ‘uuid’
[17:00:32.807]   - Field: ‘seed’
[17:00:32.807]   - Field: ‘version’
[17:00:32.807]   - Field: ‘result’
[17:00:32.807]   - Field: ‘asynchronous’
[17:00:32.807]   - Field: ‘calls’
[17:00:32.807]   - Field: ‘globals’
[17:00:32.807]   - Field: ‘stdout’
[17:00:32.807]   - Field: ‘earlySignal’
[17:00:32.807]   - Field: ‘lazy’
[17:00:32.808]   - Field: ‘state’
[17:00:32.808] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:32.808] - Launch lazy future ...
[17:00:32.808] Packages needed by the future expression (n = 0): <none>
[17:00:32.808] Packages needed by future strategies (n = 0): <none>
[17:00:32.809] {
[17:00:32.809]     {
[17:00:32.809]         {
[17:00:32.809]             ...future.startTime <- base::Sys.time()
[17:00:32.809]             {
[17:00:32.809]                 {
[17:00:32.809]                   {
[17:00:32.809]                     {
[17:00:32.809]                       base::local({
[17:00:32.809]                         has_future <- base::requireNamespace("future", 
[17:00:32.809]                           quietly = TRUE)
[17:00:32.809]                         if (has_future) {
[17:00:32.809]                           ns <- base::getNamespace("future")
[17:00:32.809]                           version <- ns[[".package"]][["version"]]
[17:00:32.809]                           if (is.null(version)) 
[17:00:32.809]                             version <- utils::packageVersion("future")
[17:00:32.809]                         }
[17:00:32.809]                         else {
[17:00:32.809]                           version <- NULL
[17:00:32.809]                         }
[17:00:32.809]                         if (!has_future || version < "1.8.0") {
[17:00:32.809]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:32.809]                             "", base::R.version$version.string), 
[17:00:32.809]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:32.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:32.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:32.809]                               "release", "version")], collapse = " "), 
[17:00:32.809]                             hostname = base::Sys.info()[["nodename"]])
[17:00:32.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:32.809]                             info)
[17:00:32.809]                           info <- base::paste(info, collapse = "; ")
[17:00:32.809]                           if (!has_future) {
[17:00:32.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:32.809]                               info)
[17:00:32.809]                           }
[17:00:32.809]                           else {
[17:00:32.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:32.809]                               info, version)
[17:00:32.809]                           }
[17:00:32.809]                           base::stop(msg)
[17:00:32.809]                         }
[17:00:32.809]                       })
[17:00:32.809]                     }
[17:00:32.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:32.809]                     base::options(mc.cores = 1L)
[17:00:32.809]                   }
[17:00:32.809]                   ...future.strategy.old <- future::plan("list")
[17:00:32.809]                   options(future.plan = NULL)
[17:00:32.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:32.809]                 }
[17:00:32.809]                 ...future.workdir <- getwd()
[17:00:32.809]             }
[17:00:32.809]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:32.809]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:32.809]         }
[17:00:32.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:32.809]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:32.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:32.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:32.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:32.809]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:32.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:32.809]             base::names(...future.oldOptions))
[17:00:32.809]     }
[17:00:32.809]     if (FALSE) {
[17:00:32.809]     }
[17:00:32.809]     else {
[17:00:32.809]         if (TRUE) {
[17:00:32.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:32.809]                 open = "w")
[17:00:32.809]         }
[17:00:32.809]         else {
[17:00:32.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:32.809]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:32.809]         }
[17:00:32.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:32.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:32.809]             base::sink(type = "output", split = FALSE)
[17:00:32.809]             base::close(...future.stdout)
[17:00:32.809]         }, add = TRUE)
[17:00:32.809]     }
[17:00:32.809]     ...future.frame <- base::sys.nframe()
[17:00:32.809]     ...future.conditions <- base::list()
[17:00:32.809]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:32.809]     if (FALSE) {
[17:00:32.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:32.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:32.809]     }
[17:00:32.809]     ...future.result <- base::tryCatch({
[17:00:32.809]         base::withCallingHandlers({
[17:00:32.809]             ...future.value <- base::withVisible(base::local({
[17:00:32.809]                 ...future.makeSendCondition <- base::local({
[17:00:32.809]                   sendCondition <- NULL
[17:00:32.809]                   function(frame = 1L) {
[17:00:32.809]                     if (is.function(sendCondition)) 
[17:00:32.809]                       return(sendCondition)
[17:00:32.809]                     ns <- getNamespace("parallel")
[17:00:32.809]                     if (exists("sendData", mode = "function", 
[17:00:32.809]                       envir = ns)) {
[17:00:32.809]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:32.809]                         envir = ns)
[17:00:32.809]                       envir <- sys.frame(frame)
[17:00:32.809]                       master <- NULL
[17:00:32.809]                       while (!identical(envir, .GlobalEnv) && 
[17:00:32.809]                         !identical(envir, emptyenv())) {
[17:00:32.809]                         if (exists("master", mode = "list", envir = envir, 
[17:00:32.809]                           inherits = FALSE)) {
[17:00:32.809]                           master <- get("master", mode = "list", 
[17:00:32.809]                             envir = envir, inherits = FALSE)
[17:00:32.809]                           if (inherits(master, c("SOCKnode", 
[17:00:32.809]                             "SOCK0node"))) {
[17:00:32.809]                             sendCondition <<- function(cond) {
[17:00:32.809]                               data <- list(type = "VALUE", value = cond, 
[17:00:32.809]                                 success = TRUE)
[17:00:32.809]                               parallel_sendData(master, data)
[17:00:32.809]                             }
[17:00:32.809]                             return(sendCondition)
[17:00:32.809]                           }
[17:00:32.809]                         }
[17:00:32.809]                         frame <- frame + 1L
[17:00:32.809]                         envir <- sys.frame(frame)
[17:00:32.809]                       }
[17:00:32.809]                     }
[17:00:32.809]                     sendCondition <<- function(cond) NULL
[17:00:32.809]                   }
[17:00:32.809]                 })
[17:00:32.809]                 withCallingHandlers({
[17:00:32.809]                   {
[17:00:32.809]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.809]                     if (!identical(...future.globals.maxSize.org, 
[17:00:32.809]                       ...future.globals.maxSize)) {
[17:00:32.809]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.809]                       on.exit(options(oopts), add = TRUE)
[17:00:32.809]                     }
[17:00:32.809]                     {
[17:00:32.809]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.809]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:32.809]                         USE.NAMES = FALSE)
[17:00:32.809]                       do.call(mapply, args = args)
[17:00:32.809]                     }
[17:00:32.809]                   }
[17:00:32.809]                 }, immediateCondition = function(cond) {
[17:00:32.809]                   sendCondition <- ...future.makeSendCondition()
[17:00:32.809]                   sendCondition(cond)
[17:00:32.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.809]                   {
[17:00:32.809]                     inherits <- base::inherits
[17:00:32.809]                     invokeRestart <- base::invokeRestart
[17:00:32.809]                     is.null <- base::is.null
[17:00:32.809]                     muffled <- FALSE
[17:00:32.809]                     if (inherits(cond, "message")) {
[17:00:32.809]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:32.809]                       if (muffled) 
[17:00:32.809]                         invokeRestart("muffleMessage")
[17:00:32.809]                     }
[17:00:32.809]                     else if (inherits(cond, "warning")) {
[17:00:32.809]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:32.809]                       if (muffled) 
[17:00:32.809]                         invokeRestart("muffleWarning")
[17:00:32.809]                     }
[17:00:32.809]                     else if (inherits(cond, "condition")) {
[17:00:32.809]                       if (!is.null(pattern)) {
[17:00:32.809]                         computeRestarts <- base::computeRestarts
[17:00:32.809]                         grepl <- base::grepl
[17:00:32.809]                         restarts <- computeRestarts(cond)
[17:00:32.809]                         for (restart in restarts) {
[17:00:32.809]                           name <- restart$name
[17:00:32.809]                           if (is.null(name)) 
[17:00:32.809]                             next
[17:00:32.809]                           if (!grepl(pattern, name)) 
[17:00:32.809]                             next
[17:00:32.809]                           invokeRestart(restart)
[17:00:32.809]                           muffled <- TRUE
[17:00:32.809]                           break
[17:00:32.809]                         }
[17:00:32.809]                       }
[17:00:32.809]                     }
[17:00:32.809]                     invisible(muffled)
[17:00:32.809]                   }
[17:00:32.809]                   muffleCondition(cond)
[17:00:32.809]                 })
[17:00:32.809]             }))
[17:00:32.809]             future::FutureResult(value = ...future.value$value, 
[17:00:32.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.809]                   ...future.rng), globalenv = if (FALSE) 
[17:00:32.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:32.809]                     ...future.globalenv.names))
[17:00:32.809]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:32.809]         }, condition = base::local({
[17:00:32.809]             c <- base::c
[17:00:32.809]             inherits <- base::inherits
[17:00:32.809]             invokeRestart <- base::invokeRestart
[17:00:32.809]             length <- base::length
[17:00:32.809]             list <- base::list
[17:00:32.809]             seq.int <- base::seq.int
[17:00:32.809]             signalCondition <- base::signalCondition
[17:00:32.809]             sys.calls <- base::sys.calls
[17:00:32.809]             `[[` <- base::`[[`
[17:00:32.809]             `+` <- base::`+`
[17:00:32.809]             `<<-` <- base::`<<-`
[17:00:32.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:32.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:32.809]                   3L)]
[17:00:32.809]             }
[17:00:32.809]             function(cond) {
[17:00:32.809]                 is_error <- inherits(cond, "error")
[17:00:32.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:32.809]                   NULL)
[17:00:32.809]                 if (is_error) {
[17:00:32.809]                   sessionInformation <- function() {
[17:00:32.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:32.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:32.809]                       search = base::search(), system = base::Sys.info())
[17:00:32.809]                   }
[17:00:32.809]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:32.809]                     cond$call), session = sessionInformation(), 
[17:00:32.809]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:32.809]                   signalCondition(cond)
[17:00:32.809]                 }
[17:00:32.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:32.809]                 "immediateCondition"))) {
[17:00:32.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:32.809]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:32.809]                   if (TRUE && !signal) {
[17:00:32.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.809]                     {
[17:00:32.809]                       inherits <- base::inherits
[17:00:32.809]                       invokeRestart <- base::invokeRestart
[17:00:32.809]                       is.null <- base::is.null
[17:00:32.809]                       muffled <- FALSE
[17:00:32.809]                       if (inherits(cond, "message")) {
[17:00:32.809]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.809]                         if (muffled) 
[17:00:32.809]                           invokeRestart("muffleMessage")
[17:00:32.809]                       }
[17:00:32.809]                       else if (inherits(cond, "warning")) {
[17:00:32.809]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.809]                         if (muffled) 
[17:00:32.809]                           invokeRestart("muffleWarning")
[17:00:32.809]                       }
[17:00:32.809]                       else if (inherits(cond, "condition")) {
[17:00:32.809]                         if (!is.null(pattern)) {
[17:00:32.809]                           computeRestarts <- base::computeRestarts
[17:00:32.809]                           grepl <- base::grepl
[17:00:32.809]                           restarts <- computeRestarts(cond)
[17:00:32.809]                           for (restart in restarts) {
[17:00:32.809]                             name <- restart$name
[17:00:32.809]                             if (is.null(name)) 
[17:00:32.809]                               next
[17:00:32.809]                             if (!grepl(pattern, name)) 
[17:00:32.809]                               next
[17:00:32.809]                             invokeRestart(restart)
[17:00:32.809]                             muffled <- TRUE
[17:00:32.809]                             break
[17:00:32.809]                           }
[17:00:32.809]                         }
[17:00:32.809]                       }
[17:00:32.809]                       invisible(muffled)
[17:00:32.809]                     }
[17:00:32.809]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.809]                   }
[17:00:32.809]                 }
[17:00:32.809]                 else {
[17:00:32.809]                   if (TRUE) {
[17:00:32.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.809]                     {
[17:00:32.809]                       inherits <- base::inherits
[17:00:32.809]                       invokeRestart <- base::invokeRestart
[17:00:32.809]                       is.null <- base::is.null
[17:00:32.809]                       muffled <- FALSE
[17:00:32.809]                       if (inherits(cond, "message")) {
[17:00:32.809]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.809]                         if (muffled) 
[17:00:32.809]                           invokeRestart("muffleMessage")
[17:00:32.809]                       }
[17:00:32.809]                       else if (inherits(cond, "warning")) {
[17:00:32.809]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.809]                         if (muffled) 
[17:00:32.809]                           invokeRestart("muffleWarning")
[17:00:32.809]                       }
[17:00:32.809]                       else if (inherits(cond, "condition")) {
[17:00:32.809]                         if (!is.null(pattern)) {
[17:00:32.809]                           computeRestarts <- base::computeRestarts
[17:00:32.809]                           grepl <- base::grepl
[17:00:32.809]                           restarts <- computeRestarts(cond)
[17:00:32.809]                           for (restart in restarts) {
[17:00:32.809]                             name <- restart$name
[17:00:32.809]                             if (is.null(name)) 
[17:00:32.809]                               next
[17:00:32.809]                             if (!grepl(pattern, name)) 
[17:00:32.809]                               next
[17:00:32.809]                             invokeRestart(restart)
[17:00:32.809]                             muffled <- TRUE
[17:00:32.809]                             break
[17:00:32.809]                           }
[17:00:32.809]                         }
[17:00:32.809]                       }
[17:00:32.809]                       invisible(muffled)
[17:00:32.809]                     }
[17:00:32.809]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.809]                   }
[17:00:32.809]                 }
[17:00:32.809]             }
[17:00:32.809]         }))
[17:00:32.809]     }, error = function(ex) {
[17:00:32.809]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:32.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.809]                 ...future.rng), started = ...future.startTime, 
[17:00:32.809]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:32.809]             version = "1.8"), class = "FutureResult")
[17:00:32.809]     }, finally = {
[17:00:32.809]         if (!identical(...future.workdir, getwd())) 
[17:00:32.809]             setwd(...future.workdir)
[17:00:32.809]         {
[17:00:32.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:32.809]                 ...future.oldOptions$nwarnings <- NULL
[17:00:32.809]             }
[17:00:32.809]             base::options(...future.oldOptions)
[17:00:32.809]             if (.Platform$OS.type == "windows") {
[17:00:32.809]                 old_names <- names(...future.oldEnvVars)
[17:00:32.809]                 envs <- base::Sys.getenv()
[17:00:32.809]                 names <- names(envs)
[17:00:32.809]                 common <- intersect(names, old_names)
[17:00:32.809]                 added <- setdiff(names, old_names)
[17:00:32.809]                 removed <- setdiff(old_names, names)
[17:00:32.809]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:32.809]                   envs[common]]
[17:00:32.809]                 NAMES <- toupper(changed)
[17:00:32.809]                 args <- list()
[17:00:32.809]                 for (kk in seq_along(NAMES)) {
[17:00:32.809]                   name <- changed[[kk]]
[17:00:32.809]                   NAME <- NAMES[[kk]]
[17:00:32.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.809]                     next
[17:00:32.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.809]                 }
[17:00:32.809]                 NAMES <- toupper(added)
[17:00:32.809]                 for (kk in seq_along(NAMES)) {
[17:00:32.809]                   name <- added[[kk]]
[17:00:32.809]                   NAME <- NAMES[[kk]]
[17:00:32.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.809]                     next
[17:00:32.809]                   args[[name]] <- ""
[17:00:32.809]                 }
[17:00:32.809]                 NAMES <- toupper(removed)
[17:00:32.809]                 for (kk in seq_along(NAMES)) {
[17:00:32.809]                   name <- removed[[kk]]
[17:00:32.809]                   NAME <- NAMES[[kk]]
[17:00:32.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.809]                     next
[17:00:32.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.809]                 }
[17:00:32.809]                 if (length(args) > 0) 
[17:00:32.809]                   base::do.call(base::Sys.setenv, args = args)
[17:00:32.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:32.809]             }
[17:00:32.809]             else {
[17:00:32.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:32.809]             }
[17:00:32.809]             {
[17:00:32.809]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:32.809]                   0L) {
[17:00:32.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:32.809]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:32.809]                   base::options(opts)
[17:00:32.809]                 }
[17:00:32.809]                 {
[17:00:32.809]                   {
[17:00:32.809]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:32.809]                     NULL
[17:00:32.809]                   }
[17:00:32.809]                   options(future.plan = NULL)
[17:00:32.809]                   if (is.na(NA_character_)) 
[17:00:32.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:32.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:32.809]                     .init = FALSE)
[17:00:32.809]                 }
[17:00:32.809]             }
[17:00:32.809]         }
[17:00:32.809]     })
[17:00:32.809]     if (TRUE) {
[17:00:32.809]         base::sink(type = "output", split = FALSE)
[17:00:32.809]         if (TRUE) {
[17:00:32.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:32.809]         }
[17:00:32.809]         else {
[17:00:32.809]             ...future.result["stdout"] <- base::list(NULL)
[17:00:32.809]         }
[17:00:32.809]         base::close(...future.stdout)
[17:00:32.809]         ...future.stdout <- NULL
[17:00:32.809]     }
[17:00:32.809]     ...future.result$conditions <- ...future.conditions
[17:00:32.809]     ...future.result$finished <- base::Sys.time()
[17:00:32.809]     ...future.result
[17:00:32.809] }
[17:00:32.811] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:00:32.812] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:00:32.812] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:00:32.812] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:32.816] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.816] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:00:32.816] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:00:32.817] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:32.817] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.817] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:32.817] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.818] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:00:32.818] MultisessionFuture started
[17:00:32.818] - Launch lazy future ... done
[17:00:32.818] run() for ‘MultisessionFuture’ ... done
[17:00:32.819] Created future:
[17:00:32.819] MultisessionFuture:
[17:00:32.819] Label: ‘future_mapply-2’
[17:00:32.819] Expression:
[17:00:32.819] {
[17:00:32.819]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.819]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:32.819]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.819]         on.exit(options(oopts), add = TRUE)
[17:00:32.819]     }
[17:00:32.819]     {
[17:00:32.819]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.819]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:32.819]         do.call(mapply, args = args)
[17:00:32.819]     }
[17:00:32.819] }
[17:00:32.819] Lazy evaluation: FALSE
[17:00:32.819] Asynchronous evaluation: TRUE
[17:00:32.819] Local evaluation: TRUE
[17:00:32.819] Environment: R_GlobalEnv
[17:00:32.819] Capture standard output: TRUE
[17:00:32.819] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:32.819] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:32.819] Packages: <none>
[17:00:32.819] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:32.819] Resolved: FALSE
[17:00:32.819] Value: <not collected>
[17:00:32.819] Conditions captured: <none>
[17:00:32.819] Early signaling: FALSE
[17:00:32.819] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:32.819] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.830] Chunk #2 of 2 ... DONE
[17:00:32.830] Launching 2 futures (chunks) ... DONE
[17:00:32.830] Resolving 2 futures (chunks) ...
[17:00:32.830] resolve() on list ...
[17:00:32.831]  recursive: 0
[17:00:32.831]  length: 2
[17:00:32.831] 
[17:00:32.831] receiveMessageFromWorker() for ClusterFuture ...
[17:00:32.831] - Validating connection of MultisessionFuture
[17:00:32.832] - received message: FutureResult
[17:00:32.832] - Received FutureResult
[17:00:32.832] - Erased future from FutureRegistry
[17:00:32.832] result() for ClusterFuture ...
[17:00:32.832] - result already collected: FutureResult
[17:00:32.832] result() for ClusterFuture ... done
[17:00:32.832] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:32.832] Future #1
[17:00:32.832] result() for ClusterFuture ...
[17:00:32.832] - result already collected: FutureResult
[17:00:32.832] result() for ClusterFuture ... done
[17:00:32.833] result() for ClusterFuture ...
[17:00:32.833] - result already collected: FutureResult
[17:00:32.833] result() for ClusterFuture ... done
[17:00:32.833] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:32.833] - nx: 2
[17:00:32.833] - relay: TRUE
[17:00:32.833] - stdout: TRUE
[17:00:32.833] - signal: TRUE
[17:00:32.833] - resignal: FALSE
[17:00:32.833] - force: TRUE
[17:00:32.833] - relayed: [n=2] FALSE, FALSE
[17:00:32.833] - queued futures: [n=2] FALSE, FALSE
[17:00:32.834]  - until=1
[17:00:32.834]  - relaying element #1
[17:00:32.834] result() for ClusterFuture ...
[17:00:32.834] - result already collected: FutureResult
[17:00:32.834] result() for ClusterFuture ... done
[17:00:32.834] result() for ClusterFuture ...
[17:00:32.834] - result already collected: FutureResult
[17:00:32.834] result() for ClusterFuture ... done
[17:00:32.834] result() for ClusterFuture ...
[17:00:32.834] - result already collected: FutureResult
[17:00:32.834] result() for ClusterFuture ... done
[17:00:32.835] result() for ClusterFuture ...
[17:00:32.835] - result already collected: FutureResult
[17:00:32.835] result() for ClusterFuture ... done
[17:00:32.835] - relayed: [n=2] TRUE, FALSE
[17:00:32.835] - queued futures: [n=2] TRUE, FALSE
[17:00:32.835] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:32.835]  length: 1 (resolved future 1)
[17:00:32.861] receiveMessageFromWorker() for ClusterFuture ...
[17:00:32.861] - Validating connection of MultisessionFuture
[17:00:32.861] - received message: FutureResult
[17:00:32.861] - Received FutureResult
[17:00:32.862] - Erased future from FutureRegistry
[17:00:32.862] result() for ClusterFuture ...
[17:00:32.862] - result already collected: FutureResult
[17:00:32.862] result() for ClusterFuture ... done
[17:00:32.862] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:32.862] Future #2
[17:00:32.862] result() for ClusterFuture ...
[17:00:32.862] - result already collected: FutureResult
[17:00:32.862] result() for ClusterFuture ... done
[17:00:32.862] result() for ClusterFuture ...
[17:00:32.862] - result already collected: FutureResult
[17:00:32.862] result() for ClusterFuture ... done
[17:00:32.863] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:32.863] - nx: 2
[17:00:32.863] - relay: TRUE
[17:00:32.863] - stdout: TRUE
[17:00:32.863] - signal: TRUE
[17:00:32.863] - resignal: FALSE
[17:00:32.863] - force: TRUE
[17:00:32.863] - relayed: [n=2] TRUE, FALSE
[17:00:32.863] - queued futures: [n=2] TRUE, FALSE
[17:00:32.863]  - until=2
[17:00:32.863]  - relaying element #2
[17:00:32.864] result() for ClusterFuture ...
[17:00:32.864] - result already collected: FutureResult
[17:00:32.864] result() for ClusterFuture ... done
[17:00:32.864] result() for ClusterFuture ...
[17:00:32.864] - result already collected: FutureResult
[17:00:32.864] result() for ClusterFuture ... done
[17:00:32.864] result() for ClusterFuture ...
[17:00:32.864] - result already collected: FutureResult
[17:00:32.864] result() for ClusterFuture ... done
[17:00:32.864] result() for ClusterFuture ...
[17:00:32.864] - result already collected: FutureResult
[17:00:32.865] result() for ClusterFuture ... done
[17:00:32.865] - relayed: [n=2] TRUE, TRUE
[17:00:32.865] - queued futures: [n=2] TRUE, TRUE
[17:00:32.865] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:32.865]  length: 0 (resolved future 2)
[17:00:32.865] Relaying remaining futures
[17:00:32.865] signalConditionsASAP(NULL, pos=0) ...
[17:00:32.865] - nx: 2
[17:00:32.865] - relay: TRUE
[17:00:32.865] - stdout: TRUE
[17:00:32.865] - signal: TRUE
[17:00:32.866] - resignal: FALSE
[17:00:32.866] - force: TRUE
[17:00:32.866] - relayed: [n=2] TRUE, TRUE
[17:00:32.866] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:32.866] - relayed: [n=2] TRUE, TRUE
[17:00:32.866] - queued futures: [n=2] TRUE, TRUE
[17:00:32.866] signalConditionsASAP(NULL, pos=0) ... done
[17:00:32.866] resolve() on list ... DONE
[17:00:32.866] result() for ClusterFuture ...
[17:00:32.866] - result already collected: FutureResult
[17:00:32.866] result() for ClusterFuture ... done
[17:00:32.867] result() for ClusterFuture ...
[17:00:32.867] - result already collected: FutureResult
[17:00:32.867] result() for ClusterFuture ... done
[17:00:32.867] result() for ClusterFuture ...
[17:00:32.867] - result already collected: FutureResult
[17:00:32.867] result() for ClusterFuture ... done
[17:00:32.867] result() for ClusterFuture ...
[17:00:32.867] - result already collected: FutureResult
[17:00:32.867] result() for ClusterFuture ... done
[17:00:32.867]  - Number of value chunks collected: 2
[17:00:32.867] Resolving 2 futures (chunks) ... DONE
[17:00:32.868] Reducing values from 2 chunks ...
[17:00:32.868]  - Number of values collected after concatenation: 4
[17:00:32.868]  - Number of values expected: 4
[17:00:32.868] Reducing values from 2 chunks ... DONE
[17:00:32.868] future_mapply() ... DONE
[17:00:32.868] future_mapply() ...
[17:00:32.872] Number of chunks: 2
[17:00:32.872] getGlobalsAndPackagesXApply() ...
[17:00:32.872]  - future.globals: TRUE
[17:00:32.872] getGlobalsAndPackages() ...
[17:00:32.872] Searching for globals...
[17:00:32.873] - globals found: [1] ‘FUN’
[17:00:32.873] Searching for globals ... DONE
[17:00:32.873] Resolving globals: FALSE
[17:00:32.874] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:32.874] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:32.874] - globals: [1] ‘FUN’
[17:00:32.874] 
[17:00:32.874] getGlobalsAndPackages() ... DONE
[17:00:32.874]  - globals found/used: [n=1] ‘FUN’
[17:00:32.875]  - needed namespaces: [n=0] 
[17:00:32.875] Finding globals ... DONE
[17:00:32.875] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:32.875] List of 2
[17:00:32.875]  $ ...future.FUN:function (x, ...)  
[17:00:32.875]  $ MoreArgs     :List of 1
[17:00:32.875]   ..$ x: num 42
[17:00:32.875]  - attr(*, "where")=List of 2
[17:00:32.875]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:32.875]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:32.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:32.875]  - attr(*, "resolved")= logi FALSE
[17:00:32.875]  - attr(*, "total_size")= num NA
[17:00:32.878] Packages to be attached in all futures: [n=0] 
[17:00:32.878] getGlobalsAndPackagesXApply() ... DONE
[17:00:32.878] Number of futures (= number of chunks): 2
[17:00:32.878] Launching 2 futures (chunks) ...
[17:00:32.878] Chunk #1 of 2 ...
[17:00:32.878]  - Finding globals in '...' for chunk #1 ...
[17:00:32.878] getGlobalsAndPackages() ...
[17:00:32.879] Searching for globals...
[17:00:32.879] 
[17:00:32.879] Searching for globals ... DONE
[17:00:32.879] - globals: [0] <none>
[17:00:32.879] getGlobalsAndPackages() ... DONE
[17:00:32.879]    + additional globals found: [n=0] 
[17:00:32.879]    + additional namespaces needed: [n=0] 
[17:00:32.879]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:32.880]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:32.880]  - seeds: <none>
[17:00:32.880]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.880] getGlobalsAndPackages() ...
[17:00:32.880] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.880] Resolving globals: FALSE
[17:00:32.880] The total size of the 5 globals is 224 bytes (224 bytes)
[17:00:32.881] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:32.881] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.881] 
[17:00:32.881] getGlobalsAndPackages() ... DONE
[17:00:32.881] run() for ‘Future’ ...
[17:00:32.882] - state: ‘created’
[17:00:32.882] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:32.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:32.896]   - Field: ‘node’
[17:00:32.896]   - Field: ‘label’
[17:00:32.896]   - Field: ‘local’
[17:00:32.896]   - Field: ‘owner’
[17:00:32.896]   - Field: ‘envir’
[17:00:32.896]   - Field: ‘workers’
[17:00:32.897]   - Field: ‘packages’
[17:00:32.897]   - Field: ‘gc’
[17:00:32.897]   - Field: ‘conditions’
[17:00:32.897]   - Field: ‘persistent’
[17:00:32.897]   - Field: ‘expr’
[17:00:32.897]   - Field: ‘uuid’
[17:00:32.897]   - Field: ‘seed’
[17:00:32.897]   - Field: ‘version’
[17:00:32.897]   - Field: ‘result’
[17:00:32.897]   - Field: ‘asynchronous’
[17:00:32.897]   - Field: ‘calls’
[17:00:32.897]   - Field: ‘globals’
[17:00:32.898]   - Field: ‘stdout’
[17:00:32.898]   - Field: ‘earlySignal’
[17:00:32.898]   - Field: ‘lazy’
[17:00:32.898]   - Field: ‘state’
[17:00:32.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:32.898] - Launch lazy future ...
[17:00:32.898] Packages needed by the future expression (n = 0): <none>
[17:00:32.898] Packages needed by future strategies (n = 0): <none>
[17:00:32.899] {
[17:00:32.899]     {
[17:00:32.899]         {
[17:00:32.899]             ...future.startTime <- base::Sys.time()
[17:00:32.899]             {
[17:00:32.899]                 {
[17:00:32.899]                   {
[17:00:32.899]                     {
[17:00:32.899]                       base::local({
[17:00:32.899]                         has_future <- base::requireNamespace("future", 
[17:00:32.899]                           quietly = TRUE)
[17:00:32.899]                         if (has_future) {
[17:00:32.899]                           ns <- base::getNamespace("future")
[17:00:32.899]                           version <- ns[[".package"]][["version"]]
[17:00:32.899]                           if (is.null(version)) 
[17:00:32.899]                             version <- utils::packageVersion("future")
[17:00:32.899]                         }
[17:00:32.899]                         else {
[17:00:32.899]                           version <- NULL
[17:00:32.899]                         }
[17:00:32.899]                         if (!has_future || version < "1.8.0") {
[17:00:32.899]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:32.899]                             "", base::R.version$version.string), 
[17:00:32.899]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:32.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:32.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:32.899]                               "release", "version")], collapse = " "), 
[17:00:32.899]                             hostname = base::Sys.info()[["nodename"]])
[17:00:32.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:32.899]                             info)
[17:00:32.899]                           info <- base::paste(info, collapse = "; ")
[17:00:32.899]                           if (!has_future) {
[17:00:32.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:32.899]                               info)
[17:00:32.899]                           }
[17:00:32.899]                           else {
[17:00:32.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:32.899]                               info, version)
[17:00:32.899]                           }
[17:00:32.899]                           base::stop(msg)
[17:00:32.899]                         }
[17:00:32.899]                       })
[17:00:32.899]                     }
[17:00:32.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:32.899]                     base::options(mc.cores = 1L)
[17:00:32.899]                   }
[17:00:32.899]                   ...future.strategy.old <- future::plan("list")
[17:00:32.899]                   options(future.plan = NULL)
[17:00:32.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:32.899]                 }
[17:00:32.899]                 ...future.workdir <- getwd()
[17:00:32.899]             }
[17:00:32.899]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:32.899]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:32.899]         }
[17:00:32.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:32.899]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:32.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:32.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:32.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:32.899]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:32.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:32.899]             base::names(...future.oldOptions))
[17:00:32.899]     }
[17:00:32.899]     if (FALSE) {
[17:00:32.899]     }
[17:00:32.899]     else {
[17:00:32.899]         if (TRUE) {
[17:00:32.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:32.899]                 open = "w")
[17:00:32.899]         }
[17:00:32.899]         else {
[17:00:32.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:32.899]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:32.899]         }
[17:00:32.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:32.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:32.899]             base::sink(type = "output", split = FALSE)
[17:00:32.899]             base::close(...future.stdout)
[17:00:32.899]         }, add = TRUE)
[17:00:32.899]     }
[17:00:32.899]     ...future.frame <- base::sys.nframe()
[17:00:32.899]     ...future.conditions <- base::list()
[17:00:32.899]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:32.899]     if (FALSE) {
[17:00:32.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:32.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:32.899]     }
[17:00:32.899]     ...future.result <- base::tryCatch({
[17:00:32.899]         base::withCallingHandlers({
[17:00:32.899]             ...future.value <- base::withVisible(base::local({
[17:00:32.899]                 ...future.makeSendCondition <- base::local({
[17:00:32.899]                   sendCondition <- NULL
[17:00:32.899]                   function(frame = 1L) {
[17:00:32.899]                     if (is.function(sendCondition)) 
[17:00:32.899]                       return(sendCondition)
[17:00:32.899]                     ns <- getNamespace("parallel")
[17:00:32.899]                     if (exists("sendData", mode = "function", 
[17:00:32.899]                       envir = ns)) {
[17:00:32.899]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:32.899]                         envir = ns)
[17:00:32.899]                       envir <- sys.frame(frame)
[17:00:32.899]                       master <- NULL
[17:00:32.899]                       while (!identical(envir, .GlobalEnv) && 
[17:00:32.899]                         !identical(envir, emptyenv())) {
[17:00:32.899]                         if (exists("master", mode = "list", envir = envir, 
[17:00:32.899]                           inherits = FALSE)) {
[17:00:32.899]                           master <- get("master", mode = "list", 
[17:00:32.899]                             envir = envir, inherits = FALSE)
[17:00:32.899]                           if (inherits(master, c("SOCKnode", 
[17:00:32.899]                             "SOCK0node"))) {
[17:00:32.899]                             sendCondition <<- function(cond) {
[17:00:32.899]                               data <- list(type = "VALUE", value = cond, 
[17:00:32.899]                                 success = TRUE)
[17:00:32.899]                               parallel_sendData(master, data)
[17:00:32.899]                             }
[17:00:32.899]                             return(sendCondition)
[17:00:32.899]                           }
[17:00:32.899]                         }
[17:00:32.899]                         frame <- frame + 1L
[17:00:32.899]                         envir <- sys.frame(frame)
[17:00:32.899]                       }
[17:00:32.899]                     }
[17:00:32.899]                     sendCondition <<- function(cond) NULL
[17:00:32.899]                   }
[17:00:32.899]                 })
[17:00:32.899]                 withCallingHandlers({
[17:00:32.899]                   {
[17:00:32.899]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.899]                     if (!identical(...future.globals.maxSize.org, 
[17:00:32.899]                       ...future.globals.maxSize)) {
[17:00:32.899]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.899]                       on.exit(options(oopts), add = TRUE)
[17:00:32.899]                     }
[17:00:32.899]                     {
[17:00:32.899]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.899]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:32.899]                         USE.NAMES = FALSE)
[17:00:32.899]                       do.call(mapply, args = args)
[17:00:32.899]                     }
[17:00:32.899]                   }
[17:00:32.899]                 }, immediateCondition = function(cond) {
[17:00:32.899]                   sendCondition <- ...future.makeSendCondition()
[17:00:32.899]                   sendCondition(cond)
[17:00:32.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.899]                   {
[17:00:32.899]                     inherits <- base::inherits
[17:00:32.899]                     invokeRestart <- base::invokeRestart
[17:00:32.899]                     is.null <- base::is.null
[17:00:32.899]                     muffled <- FALSE
[17:00:32.899]                     if (inherits(cond, "message")) {
[17:00:32.899]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:32.899]                       if (muffled) 
[17:00:32.899]                         invokeRestart("muffleMessage")
[17:00:32.899]                     }
[17:00:32.899]                     else if (inherits(cond, "warning")) {
[17:00:32.899]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:32.899]                       if (muffled) 
[17:00:32.899]                         invokeRestart("muffleWarning")
[17:00:32.899]                     }
[17:00:32.899]                     else if (inherits(cond, "condition")) {
[17:00:32.899]                       if (!is.null(pattern)) {
[17:00:32.899]                         computeRestarts <- base::computeRestarts
[17:00:32.899]                         grepl <- base::grepl
[17:00:32.899]                         restarts <- computeRestarts(cond)
[17:00:32.899]                         for (restart in restarts) {
[17:00:32.899]                           name <- restart$name
[17:00:32.899]                           if (is.null(name)) 
[17:00:32.899]                             next
[17:00:32.899]                           if (!grepl(pattern, name)) 
[17:00:32.899]                             next
[17:00:32.899]                           invokeRestart(restart)
[17:00:32.899]                           muffled <- TRUE
[17:00:32.899]                           break
[17:00:32.899]                         }
[17:00:32.899]                       }
[17:00:32.899]                     }
[17:00:32.899]                     invisible(muffled)
[17:00:32.899]                   }
[17:00:32.899]                   muffleCondition(cond)
[17:00:32.899]                 })
[17:00:32.899]             }))
[17:00:32.899]             future::FutureResult(value = ...future.value$value, 
[17:00:32.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.899]                   ...future.rng), globalenv = if (FALSE) 
[17:00:32.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:32.899]                     ...future.globalenv.names))
[17:00:32.899]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:32.899]         }, condition = base::local({
[17:00:32.899]             c <- base::c
[17:00:32.899]             inherits <- base::inherits
[17:00:32.899]             invokeRestart <- base::invokeRestart
[17:00:32.899]             length <- base::length
[17:00:32.899]             list <- base::list
[17:00:32.899]             seq.int <- base::seq.int
[17:00:32.899]             signalCondition <- base::signalCondition
[17:00:32.899]             sys.calls <- base::sys.calls
[17:00:32.899]             `[[` <- base::`[[`
[17:00:32.899]             `+` <- base::`+`
[17:00:32.899]             `<<-` <- base::`<<-`
[17:00:32.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:32.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:32.899]                   3L)]
[17:00:32.899]             }
[17:00:32.899]             function(cond) {
[17:00:32.899]                 is_error <- inherits(cond, "error")
[17:00:32.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:32.899]                   NULL)
[17:00:32.899]                 if (is_error) {
[17:00:32.899]                   sessionInformation <- function() {
[17:00:32.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:32.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:32.899]                       search = base::search(), system = base::Sys.info())
[17:00:32.899]                   }
[17:00:32.899]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:32.899]                     cond$call), session = sessionInformation(), 
[17:00:32.899]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:32.899]                   signalCondition(cond)
[17:00:32.899]                 }
[17:00:32.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:32.899]                 "immediateCondition"))) {
[17:00:32.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:32.899]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:32.899]                   if (TRUE && !signal) {
[17:00:32.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.899]                     {
[17:00:32.899]                       inherits <- base::inherits
[17:00:32.899]                       invokeRestart <- base::invokeRestart
[17:00:32.899]                       is.null <- base::is.null
[17:00:32.899]                       muffled <- FALSE
[17:00:32.899]                       if (inherits(cond, "message")) {
[17:00:32.899]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.899]                         if (muffled) 
[17:00:32.899]                           invokeRestart("muffleMessage")
[17:00:32.899]                       }
[17:00:32.899]                       else if (inherits(cond, "warning")) {
[17:00:32.899]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.899]                         if (muffled) 
[17:00:32.899]                           invokeRestart("muffleWarning")
[17:00:32.899]                       }
[17:00:32.899]                       else if (inherits(cond, "condition")) {
[17:00:32.899]                         if (!is.null(pattern)) {
[17:00:32.899]                           computeRestarts <- base::computeRestarts
[17:00:32.899]                           grepl <- base::grepl
[17:00:32.899]                           restarts <- computeRestarts(cond)
[17:00:32.899]                           for (restart in restarts) {
[17:00:32.899]                             name <- restart$name
[17:00:32.899]                             if (is.null(name)) 
[17:00:32.899]                               next
[17:00:32.899]                             if (!grepl(pattern, name)) 
[17:00:32.899]                               next
[17:00:32.899]                             invokeRestart(restart)
[17:00:32.899]                             muffled <- TRUE
[17:00:32.899]                             break
[17:00:32.899]                           }
[17:00:32.899]                         }
[17:00:32.899]                       }
[17:00:32.899]                       invisible(muffled)
[17:00:32.899]                     }
[17:00:32.899]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.899]                   }
[17:00:32.899]                 }
[17:00:32.899]                 else {
[17:00:32.899]                   if (TRUE) {
[17:00:32.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.899]                     {
[17:00:32.899]                       inherits <- base::inherits
[17:00:32.899]                       invokeRestart <- base::invokeRestart
[17:00:32.899]                       is.null <- base::is.null
[17:00:32.899]                       muffled <- FALSE
[17:00:32.899]                       if (inherits(cond, "message")) {
[17:00:32.899]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.899]                         if (muffled) 
[17:00:32.899]                           invokeRestart("muffleMessage")
[17:00:32.899]                       }
[17:00:32.899]                       else if (inherits(cond, "warning")) {
[17:00:32.899]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.899]                         if (muffled) 
[17:00:32.899]                           invokeRestart("muffleWarning")
[17:00:32.899]                       }
[17:00:32.899]                       else if (inherits(cond, "condition")) {
[17:00:32.899]                         if (!is.null(pattern)) {
[17:00:32.899]                           computeRestarts <- base::computeRestarts
[17:00:32.899]                           grepl <- base::grepl
[17:00:32.899]                           restarts <- computeRestarts(cond)
[17:00:32.899]                           for (restart in restarts) {
[17:00:32.899]                             name <- restart$name
[17:00:32.899]                             if (is.null(name)) 
[17:00:32.899]                               next
[17:00:32.899]                             if (!grepl(pattern, name)) 
[17:00:32.899]                               next
[17:00:32.899]                             invokeRestart(restart)
[17:00:32.899]                             muffled <- TRUE
[17:00:32.899]                             break
[17:00:32.899]                           }
[17:00:32.899]                         }
[17:00:32.899]                       }
[17:00:32.899]                       invisible(muffled)
[17:00:32.899]                     }
[17:00:32.899]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.899]                   }
[17:00:32.899]                 }
[17:00:32.899]             }
[17:00:32.899]         }))
[17:00:32.899]     }, error = function(ex) {
[17:00:32.899]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:32.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.899]                 ...future.rng), started = ...future.startTime, 
[17:00:32.899]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:32.899]             version = "1.8"), class = "FutureResult")
[17:00:32.899]     }, finally = {
[17:00:32.899]         if (!identical(...future.workdir, getwd())) 
[17:00:32.899]             setwd(...future.workdir)
[17:00:32.899]         {
[17:00:32.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:32.899]                 ...future.oldOptions$nwarnings <- NULL
[17:00:32.899]             }
[17:00:32.899]             base::options(...future.oldOptions)
[17:00:32.899]             if (.Platform$OS.type == "windows") {
[17:00:32.899]                 old_names <- names(...future.oldEnvVars)
[17:00:32.899]                 envs <- base::Sys.getenv()
[17:00:32.899]                 names <- names(envs)
[17:00:32.899]                 common <- intersect(names, old_names)
[17:00:32.899]                 added <- setdiff(names, old_names)
[17:00:32.899]                 removed <- setdiff(old_names, names)
[17:00:32.899]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:32.899]                   envs[common]]
[17:00:32.899]                 NAMES <- toupper(changed)
[17:00:32.899]                 args <- list()
[17:00:32.899]                 for (kk in seq_along(NAMES)) {
[17:00:32.899]                   name <- changed[[kk]]
[17:00:32.899]                   NAME <- NAMES[[kk]]
[17:00:32.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.899]                     next
[17:00:32.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.899]                 }
[17:00:32.899]                 NAMES <- toupper(added)
[17:00:32.899]                 for (kk in seq_along(NAMES)) {
[17:00:32.899]                   name <- added[[kk]]
[17:00:32.899]                   NAME <- NAMES[[kk]]
[17:00:32.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.899]                     next
[17:00:32.899]                   args[[name]] <- ""
[17:00:32.899]                 }
[17:00:32.899]                 NAMES <- toupper(removed)
[17:00:32.899]                 for (kk in seq_along(NAMES)) {
[17:00:32.899]                   name <- removed[[kk]]
[17:00:32.899]                   NAME <- NAMES[[kk]]
[17:00:32.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.899]                     next
[17:00:32.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.899]                 }
[17:00:32.899]                 if (length(args) > 0) 
[17:00:32.899]                   base::do.call(base::Sys.setenv, args = args)
[17:00:32.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:32.899]             }
[17:00:32.899]             else {
[17:00:32.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:32.899]             }
[17:00:32.899]             {
[17:00:32.899]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:32.899]                   0L) {
[17:00:32.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:32.899]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:32.899]                   base::options(opts)
[17:00:32.899]                 }
[17:00:32.899]                 {
[17:00:32.899]                   {
[17:00:32.899]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:32.899]                     NULL
[17:00:32.899]                   }
[17:00:32.899]                   options(future.plan = NULL)
[17:00:32.899]                   if (is.na(NA_character_)) 
[17:00:32.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:32.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:32.899]                     .init = FALSE)
[17:00:32.899]                 }
[17:00:32.899]             }
[17:00:32.899]         }
[17:00:32.899]     })
[17:00:32.899]     if (TRUE) {
[17:00:32.899]         base::sink(type = "output", split = FALSE)
[17:00:32.899]         if (TRUE) {
[17:00:32.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:32.899]         }
[17:00:32.899]         else {
[17:00:32.899]             ...future.result["stdout"] <- base::list(NULL)
[17:00:32.899]         }
[17:00:32.899]         base::close(...future.stdout)
[17:00:32.899]         ...future.stdout <- NULL
[17:00:32.899]     }
[17:00:32.899]     ...future.result$conditions <- ...future.conditions
[17:00:32.899]     ...future.result$finished <- base::Sys.time()
[17:00:32.899]     ...future.result
[17:00:32.899] }
[17:00:32.902] Exporting 5 global objects (224 bytes) to cluster node #1 ...
[17:00:32.902] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:00:32.902] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:00:32.902] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:00:32.903] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:00:32.903] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:00:32.903] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:00:32.903] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:32.904] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.904] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:32.904] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:32.904] Exporting 5 global objects (224 bytes) to cluster node #1 ... DONE
[17:00:32.905] MultisessionFuture started
[17:00:32.905] - Launch lazy future ... done
[17:00:32.905] run() for ‘MultisessionFuture’ ... done
[17:00:32.905] Created future:
[17:00:32.905] MultisessionFuture:
[17:00:32.905] Label: ‘future_mapply-1’
[17:00:32.905] Expression:
[17:00:32.905] {
[17:00:32.905]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.905]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:32.905]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.905]         on.exit(options(oopts), add = TRUE)
[17:00:32.905]     }
[17:00:32.905]     {
[17:00:32.905]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.905]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:32.905]         do.call(mapply, args = args)
[17:00:32.905]     }
[17:00:32.905] }
[17:00:32.905] Lazy evaluation: FALSE
[17:00:32.905] Asynchronous evaluation: TRUE
[17:00:32.905] Local evaluation: TRUE
[17:00:32.905] Environment: R_GlobalEnv
[17:00:32.905] Capture standard output: TRUE
[17:00:32.905] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:32.905] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:32.905] Packages: <none>
[17:00:32.905] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:32.905] Resolved: FALSE
[17:00:32.905] Value: <not collected>
[17:00:32.905] Conditions captured: <none>
[17:00:32.905] Early signaling: FALSE
[17:00:32.905] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:32.905] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.917] Chunk #1 of 2 ... DONE
[17:00:32.917] Chunk #2 of 2 ...
[17:00:32.917]  - Finding globals in '...' for chunk #2 ...
[17:00:32.917] getGlobalsAndPackages() ...
[17:00:32.917] Searching for globals...
[17:00:32.918] 
[17:00:32.918] Searching for globals ... DONE
[17:00:32.918] - globals: [0] <none>
[17:00:32.918] getGlobalsAndPackages() ... DONE
[17:00:32.918]    + additional globals found: [n=0] 
[17:00:32.918]    + additional namespaces needed: [n=0] 
[17:00:32.918]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:32.918]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:32.918]  - seeds: <none>
[17:00:32.918]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.918] getGlobalsAndPackages() ...
[17:00:32.919] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.919] Resolving globals: FALSE
[17:00:32.919] The total size of the 5 globals is 224 bytes (224 bytes)
[17:00:32.920] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:32.920] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:32.920] 
[17:00:32.920] getGlobalsAndPackages() ... DONE
[17:00:32.920] run() for ‘Future’ ...
[17:00:32.920] - state: ‘created’
[17:00:32.921] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:32.934] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:32.935]   - Field: ‘node’
[17:00:32.935]   - Field: ‘label’
[17:00:32.935]   - Field: ‘local’
[17:00:32.935]   - Field: ‘owner’
[17:00:32.935]   - Field: ‘envir’
[17:00:32.935]   - Field: ‘workers’
[17:00:32.935]   - Field: ‘packages’
[17:00:32.935]   - Field: ‘gc’
[17:00:32.936]   - Field: ‘conditions’
[17:00:32.936]   - Field: ‘persistent’
[17:00:32.936]   - Field: ‘expr’
[17:00:32.936]   - Field: ‘uuid’
[17:00:32.936]   - Field: ‘seed’
[17:00:32.936]   - Field: ‘version’
[17:00:32.936]   - Field: ‘result’
[17:00:32.936]   - Field: ‘asynchronous’
[17:00:32.936]   - Field: ‘calls’
[17:00:32.936]   - Field: ‘globals’
[17:00:32.936]   - Field: ‘stdout’
[17:00:32.937]   - Field: ‘earlySignal’
[17:00:32.937]   - Field: ‘lazy’
[17:00:32.937]   - Field: ‘state’
[17:00:32.937] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:32.937] - Launch lazy future ...
[17:00:32.937] Packages needed by the future expression (n = 0): <none>
[17:00:32.937] Packages needed by future strategies (n = 0): <none>
[17:00:32.938] {
[17:00:32.938]     {
[17:00:32.938]         {
[17:00:32.938]             ...future.startTime <- base::Sys.time()
[17:00:32.938]             {
[17:00:32.938]                 {
[17:00:32.938]                   {
[17:00:32.938]                     {
[17:00:32.938]                       base::local({
[17:00:32.938]                         has_future <- base::requireNamespace("future", 
[17:00:32.938]                           quietly = TRUE)
[17:00:32.938]                         if (has_future) {
[17:00:32.938]                           ns <- base::getNamespace("future")
[17:00:32.938]                           version <- ns[[".package"]][["version"]]
[17:00:32.938]                           if (is.null(version)) 
[17:00:32.938]                             version <- utils::packageVersion("future")
[17:00:32.938]                         }
[17:00:32.938]                         else {
[17:00:32.938]                           version <- NULL
[17:00:32.938]                         }
[17:00:32.938]                         if (!has_future || version < "1.8.0") {
[17:00:32.938]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:32.938]                             "", base::R.version$version.string), 
[17:00:32.938]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:32.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:32.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:32.938]                               "release", "version")], collapse = " "), 
[17:00:32.938]                             hostname = base::Sys.info()[["nodename"]])
[17:00:32.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:32.938]                             info)
[17:00:32.938]                           info <- base::paste(info, collapse = "; ")
[17:00:32.938]                           if (!has_future) {
[17:00:32.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:32.938]                               info)
[17:00:32.938]                           }
[17:00:32.938]                           else {
[17:00:32.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:32.938]                               info, version)
[17:00:32.938]                           }
[17:00:32.938]                           base::stop(msg)
[17:00:32.938]                         }
[17:00:32.938]                       })
[17:00:32.938]                     }
[17:00:32.938]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:32.938]                     base::options(mc.cores = 1L)
[17:00:32.938]                   }
[17:00:32.938]                   ...future.strategy.old <- future::plan("list")
[17:00:32.938]                   options(future.plan = NULL)
[17:00:32.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:32.938]                 }
[17:00:32.938]                 ...future.workdir <- getwd()
[17:00:32.938]             }
[17:00:32.938]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:32.938]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:32.938]         }
[17:00:32.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:32.938]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:32.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:32.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:32.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:32.938]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:32.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:32.938]             base::names(...future.oldOptions))
[17:00:32.938]     }
[17:00:32.938]     if (FALSE) {
[17:00:32.938]     }
[17:00:32.938]     else {
[17:00:32.938]         if (TRUE) {
[17:00:32.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:32.938]                 open = "w")
[17:00:32.938]         }
[17:00:32.938]         else {
[17:00:32.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:32.938]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:32.938]         }
[17:00:32.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:32.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:32.938]             base::sink(type = "output", split = FALSE)
[17:00:32.938]             base::close(...future.stdout)
[17:00:32.938]         }, add = TRUE)
[17:00:32.938]     }
[17:00:32.938]     ...future.frame <- base::sys.nframe()
[17:00:32.938]     ...future.conditions <- base::list()
[17:00:32.938]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:32.938]     if (FALSE) {
[17:00:32.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:32.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:32.938]     }
[17:00:32.938]     ...future.result <- base::tryCatch({
[17:00:32.938]         base::withCallingHandlers({
[17:00:32.938]             ...future.value <- base::withVisible(base::local({
[17:00:32.938]                 ...future.makeSendCondition <- base::local({
[17:00:32.938]                   sendCondition <- NULL
[17:00:32.938]                   function(frame = 1L) {
[17:00:32.938]                     if (is.function(sendCondition)) 
[17:00:32.938]                       return(sendCondition)
[17:00:32.938]                     ns <- getNamespace("parallel")
[17:00:32.938]                     if (exists("sendData", mode = "function", 
[17:00:32.938]                       envir = ns)) {
[17:00:32.938]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:32.938]                         envir = ns)
[17:00:32.938]                       envir <- sys.frame(frame)
[17:00:32.938]                       master <- NULL
[17:00:32.938]                       while (!identical(envir, .GlobalEnv) && 
[17:00:32.938]                         !identical(envir, emptyenv())) {
[17:00:32.938]                         if (exists("master", mode = "list", envir = envir, 
[17:00:32.938]                           inherits = FALSE)) {
[17:00:32.938]                           master <- get("master", mode = "list", 
[17:00:32.938]                             envir = envir, inherits = FALSE)
[17:00:32.938]                           if (inherits(master, c("SOCKnode", 
[17:00:32.938]                             "SOCK0node"))) {
[17:00:32.938]                             sendCondition <<- function(cond) {
[17:00:32.938]                               data <- list(type = "VALUE", value = cond, 
[17:00:32.938]                                 success = TRUE)
[17:00:32.938]                               parallel_sendData(master, data)
[17:00:32.938]                             }
[17:00:32.938]                             return(sendCondition)
[17:00:32.938]                           }
[17:00:32.938]                         }
[17:00:32.938]                         frame <- frame + 1L
[17:00:32.938]                         envir <- sys.frame(frame)
[17:00:32.938]                       }
[17:00:32.938]                     }
[17:00:32.938]                     sendCondition <<- function(cond) NULL
[17:00:32.938]                   }
[17:00:32.938]                 })
[17:00:32.938]                 withCallingHandlers({
[17:00:32.938]                   {
[17:00:32.938]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.938]                     if (!identical(...future.globals.maxSize.org, 
[17:00:32.938]                       ...future.globals.maxSize)) {
[17:00:32.938]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.938]                       on.exit(options(oopts), add = TRUE)
[17:00:32.938]                     }
[17:00:32.938]                     {
[17:00:32.938]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.938]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:32.938]                         USE.NAMES = FALSE)
[17:00:32.938]                       do.call(mapply, args = args)
[17:00:32.938]                     }
[17:00:32.938]                   }
[17:00:32.938]                 }, immediateCondition = function(cond) {
[17:00:32.938]                   sendCondition <- ...future.makeSendCondition()
[17:00:32.938]                   sendCondition(cond)
[17:00:32.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.938]                   {
[17:00:32.938]                     inherits <- base::inherits
[17:00:32.938]                     invokeRestart <- base::invokeRestart
[17:00:32.938]                     is.null <- base::is.null
[17:00:32.938]                     muffled <- FALSE
[17:00:32.938]                     if (inherits(cond, "message")) {
[17:00:32.938]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:32.938]                       if (muffled) 
[17:00:32.938]                         invokeRestart("muffleMessage")
[17:00:32.938]                     }
[17:00:32.938]                     else if (inherits(cond, "warning")) {
[17:00:32.938]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:32.938]                       if (muffled) 
[17:00:32.938]                         invokeRestart("muffleWarning")
[17:00:32.938]                     }
[17:00:32.938]                     else if (inherits(cond, "condition")) {
[17:00:32.938]                       if (!is.null(pattern)) {
[17:00:32.938]                         computeRestarts <- base::computeRestarts
[17:00:32.938]                         grepl <- base::grepl
[17:00:32.938]                         restarts <- computeRestarts(cond)
[17:00:32.938]                         for (restart in restarts) {
[17:00:32.938]                           name <- restart$name
[17:00:32.938]                           if (is.null(name)) 
[17:00:32.938]                             next
[17:00:32.938]                           if (!grepl(pattern, name)) 
[17:00:32.938]                             next
[17:00:32.938]                           invokeRestart(restart)
[17:00:32.938]                           muffled <- TRUE
[17:00:32.938]                           break
[17:00:32.938]                         }
[17:00:32.938]                       }
[17:00:32.938]                     }
[17:00:32.938]                     invisible(muffled)
[17:00:32.938]                   }
[17:00:32.938]                   muffleCondition(cond)
[17:00:32.938]                 })
[17:00:32.938]             }))
[17:00:32.938]             future::FutureResult(value = ...future.value$value, 
[17:00:32.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.938]                   ...future.rng), globalenv = if (FALSE) 
[17:00:32.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:32.938]                     ...future.globalenv.names))
[17:00:32.938]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:32.938]         }, condition = base::local({
[17:00:32.938]             c <- base::c
[17:00:32.938]             inherits <- base::inherits
[17:00:32.938]             invokeRestart <- base::invokeRestart
[17:00:32.938]             length <- base::length
[17:00:32.938]             list <- base::list
[17:00:32.938]             seq.int <- base::seq.int
[17:00:32.938]             signalCondition <- base::signalCondition
[17:00:32.938]             sys.calls <- base::sys.calls
[17:00:32.938]             `[[` <- base::`[[`
[17:00:32.938]             `+` <- base::`+`
[17:00:32.938]             `<<-` <- base::`<<-`
[17:00:32.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:32.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:32.938]                   3L)]
[17:00:32.938]             }
[17:00:32.938]             function(cond) {
[17:00:32.938]                 is_error <- inherits(cond, "error")
[17:00:32.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:32.938]                   NULL)
[17:00:32.938]                 if (is_error) {
[17:00:32.938]                   sessionInformation <- function() {
[17:00:32.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:32.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:32.938]                       search = base::search(), system = base::Sys.info())
[17:00:32.938]                   }
[17:00:32.938]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:32.938]                     cond$call), session = sessionInformation(), 
[17:00:32.938]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:32.938]                   signalCondition(cond)
[17:00:32.938]                 }
[17:00:32.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:32.938]                 "immediateCondition"))) {
[17:00:32.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:32.938]                   ...future.conditions[[length(...future.conditions) + 
[17:00:32.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:32.938]                   if (TRUE && !signal) {
[17:00:32.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.938]                     {
[17:00:32.938]                       inherits <- base::inherits
[17:00:32.938]                       invokeRestart <- base::invokeRestart
[17:00:32.938]                       is.null <- base::is.null
[17:00:32.938]                       muffled <- FALSE
[17:00:32.938]                       if (inherits(cond, "message")) {
[17:00:32.938]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.938]                         if (muffled) 
[17:00:32.938]                           invokeRestart("muffleMessage")
[17:00:32.938]                       }
[17:00:32.938]                       else if (inherits(cond, "warning")) {
[17:00:32.938]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.938]                         if (muffled) 
[17:00:32.938]                           invokeRestart("muffleWarning")
[17:00:32.938]                       }
[17:00:32.938]                       else if (inherits(cond, "condition")) {
[17:00:32.938]                         if (!is.null(pattern)) {
[17:00:32.938]                           computeRestarts <- base::computeRestarts
[17:00:32.938]                           grepl <- base::grepl
[17:00:32.938]                           restarts <- computeRestarts(cond)
[17:00:32.938]                           for (restart in restarts) {
[17:00:32.938]                             name <- restart$name
[17:00:32.938]                             if (is.null(name)) 
[17:00:32.938]                               next
[17:00:32.938]                             if (!grepl(pattern, name)) 
[17:00:32.938]                               next
[17:00:32.938]                             invokeRestart(restart)
[17:00:32.938]                             muffled <- TRUE
[17:00:32.938]                             break
[17:00:32.938]                           }
[17:00:32.938]                         }
[17:00:32.938]                       }
[17:00:32.938]                       invisible(muffled)
[17:00:32.938]                     }
[17:00:32.938]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.938]                   }
[17:00:32.938]                 }
[17:00:32.938]                 else {
[17:00:32.938]                   if (TRUE) {
[17:00:32.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:32.938]                     {
[17:00:32.938]                       inherits <- base::inherits
[17:00:32.938]                       invokeRestart <- base::invokeRestart
[17:00:32.938]                       is.null <- base::is.null
[17:00:32.938]                       muffled <- FALSE
[17:00:32.938]                       if (inherits(cond, "message")) {
[17:00:32.938]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:32.938]                         if (muffled) 
[17:00:32.938]                           invokeRestart("muffleMessage")
[17:00:32.938]                       }
[17:00:32.938]                       else if (inherits(cond, "warning")) {
[17:00:32.938]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:32.938]                         if (muffled) 
[17:00:32.938]                           invokeRestart("muffleWarning")
[17:00:32.938]                       }
[17:00:32.938]                       else if (inherits(cond, "condition")) {
[17:00:32.938]                         if (!is.null(pattern)) {
[17:00:32.938]                           computeRestarts <- base::computeRestarts
[17:00:32.938]                           grepl <- base::grepl
[17:00:32.938]                           restarts <- computeRestarts(cond)
[17:00:32.938]                           for (restart in restarts) {
[17:00:32.938]                             name <- restart$name
[17:00:32.938]                             if (is.null(name)) 
[17:00:32.938]                               next
[17:00:32.938]                             if (!grepl(pattern, name)) 
[17:00:32.938]                               next
[17:00:32.938]                             invokeRestart(restart)
[17:00:32.938]                             muffled <- TRUE
[17:00:32.938]                             break
[17:00:32.938]                           }
[17:00:32.938]                         }
[17:00:32.938]                       }
[17:00:32.938]                       invisible(muffled)
[17:00:32.938]                     }
[17:00:32.938]                     muffleCondition(cond, pattern = "^muffle")
[17:00:32.938]                   }
[17:00:32.938]                 }
[17:00:32.938]             }
[17:00:32.938]         }))
[17:00:32.938]     }, error = function(ex) {
[17:00:32.938]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:32.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:32.938]                 ...future.rng), started = ...future.startTime, 
[17:00:32.938]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:32.938]             version = "1.8"), class = "FutureResult")
[17:00:32.938]     }, finally = {
[17:00:32.938]         if (!identical(...future.workdir, getwd())) 
[17:00:32.938]             setwd(...future.workdir)
[17:00:32.938]         {
[17:00:32.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:32.938]                 ...future.oldOptions$nwarnings <- NULL
[17:00:32.938]             }
[17:00:32.938]             base::options(...future.oldOptions)
[17:00:32.938]             if (.Platform$OS.type == "windows") {
[17:00:32.938]                 old_names <- names(...future.oldEnvVars)
[17:00:32.938]                 envs <- base::Sys.getenv()
[17:00:32.938]                 names <- names(envs)
[17:00:32.938]                 common <- intersect(names, old_names)
[17:00:32.938]                 added <- setdiff(names, old_names)
[17:00:32.938]                 removed <- setdiff(old_names, names)
[17:00:32.938]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:32.938]                   envs[common]]
[17:00:32.938]                 NAMES <- toupper(changed)
[17:00:32.938]                 args <- list()
[17:00:32.938]                 for (kk in seq_along(NAMES)) {
[17:00:32.938]                   name <- changed[[kk]]
[17:00:32.938]                   NAME <- NAMES[[kk]]
[17:00:32.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.938]                     next
[17:00:32.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.938]                 }
[17:00:32.938]                 NAMES <- toupper(added)
[17:00:32.938]                 for (kk in seq_along(NAMES)) {
[17:00:32.938]                   name <- added[[kk]]
[17:00:32.938]                   NAME <- NAMES[[kk]]
[17:00:32.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.938]                     next
[17:00:32.938]                   args[[name]] <- ""
[17:00:32.938]                 }
[17:00:32.938]                 NAMES <- toupper(removed)
[17:00:32.938]                 for (kk in seq_along(NAMES)) {
[17:00:32.938]                   name <- removed[[kk]]
[17:00:32.938]                   NAME <- NAMES[[kk]]
[17:00:32.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:32.938]                     next
[17:00:32.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:32.938]                 }
[17:00:32.938]                 if (length(args) > 0) 
[17:00:32.938]                   base::do.call(base::Sys.setenv, args = args)
[17:00:32.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:32.938]             }
[17:00:32.938]             else {
[17:00:32.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:32.938]             }
[17:00:32.938]             {
[17:00:32.938]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:32.938]                   0L) {
[17:00:32.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:32.938]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:32.938]                   base::options(opts)
[17:00:32.938]                 }
[17:00:32.938]                 {
[17:00:32.938]                   {
[17:00:32.938]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:32.938]                     NULL
[17:00:32.938]                   }
[17:00:32.938]                   options(future.plan = NULL)
[17:00:32.938]                   if (is.na(NA_character_)) 
[17:00:32.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:32.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:32.938]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:32.938]                     .init = FALSE)
[17:00:32.938]                 }
[17:00:32.938]             }
[17:00:32.938]         }
[17:00:32.938]     })
[17:00:32.938]     if (TRUE) {
[17:00:32.938]         base::sink(type = "output", split = FALSE)
[17:00:32.938]         if (TRUE) {
[17:00:32.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:32.938]         }
[17:00:32.938]         else {
[17:00:32.938]             ...future.result["stdout"] <- base::list(NULL)
[17:00:32.938]         }
[17:00:32.938]         base::close(...future.stdout)
[17:00:32.938]         ...future.stdout <- NULL
[17:00:32.938]     }
[17:00:32.938]     ...future.result$conditions <- ...future.conditions
[17:00:32.938]     ...future.result$finished <- base::Sys.time()
[17:00:32.938]     ...future.result
[17:00:32.938] }
[17:00:32.941] Exporting 5 global objects (224 bytes) to cluster node #2 ...
[17:00:32.941] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:00:32.941] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:00:32.941] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:00:32.941] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:00:32.942] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:00:32.942] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:00:32.942] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:32.942] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.942] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:32.943] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:32.943] Exporting 5 global objects (224 bytes) to cluster node #2 ... DONE
[17:00:32.943] MultisessionFuture started
[17:00:32.943] - Launch lazy future ... done
[17:00:32.944] run() for ‘MultisessionFuture’ ... done
[17:00:32.944] Created future:
[17:00:32.944] MultisessionFuture:
[17:00:32.944] Label: ‘future_mapply-2’
[17:00:32.944] Expression:
[17:00:32.944] {
[17:00:32.944]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:32.944]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:32.944]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:32.944]         on.exit(options(oopts), add = TRUE)
[17:00:32.944]     }
[17:00:32.944]     {
[17:00:32.944]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:32.944]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:32.944]         do.call(mapply, args = args)
[17:00:32.944]     }
[17:00:32.944] }
[17:00:32.944] Lazy evaluation: FALSE
[17:00:32.944] Asynchronous evaluation: TRUE
[17:00:32.944] Local evaluation: TRUE
[17:00:32.944] Environment: R_GlobalEnv
[17:00:32.944] Capture standard output: TRUE
[17:00:32.944] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:32.944] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:32.944] Packages: <none>
[17:00:32.944] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:32.944] Resolved: FALSE
[17:00:32.944] Value: <not collected>
[17:00:32.944] Conditions captured: <none>
[17:00:32.944] Early signaling: FALSE
[17:00:32.944] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:32.944] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:32.955] Chunk #2 of 2 ... DONE
[17:00:32.955] Launching 2 futures (chunks) ... DONE
[17:00:32.956] Resolving 2 futures (chunks) ...
[17:00:32.956] resolve() on list ...
[17:00:32.956]  recursive: 0
[17:00:32.956]  length: 2
[17:00:32.956] 
[17:00:32.956] receiveMessageFromWorker() for ClusterFuture ...
[17:00:32.957] - Validating connection of MultisessionFuture
[17:00:32.957] - received message: FutureResult
[17:00:32.957] - Received FutureResult
[17:00:32.957] - Erased future from FutureRegistry
[17:00:32.957] result() for ClusterFuture ...
[17:00:32.957] - result already collected: FutureResult
[17:00:32.957] result() for ClusterFuture ... done
[17:00:32.957] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:32.957] Future #1
[17:00:32.958] result() for ClusterFuture ...
[17:00:32.958] - result already collected: FutureResult
[17:00:32.958] result() for ClusterFuture ... done
[17:00:32.958] result() for ClusterFuture ...
[17:00:32.958] - result already collected: FutureResult
[17:00:32.958] result() for ClusterFuture ... done
[17:00:32.958] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:32.958] - nx: 2
[17:00:32.958] - relay: TRUE
[17:00:32.958] - stdout: TRUE
[17:00:32.958] - signal: TRUE
[17:00:32.958] - resignal: FALSE
[17:00:32.959] - force: TRUE
[17:00:32.959] - relayed: [n=2] FALSE, FALSE
[17:00:32.959] - queued futures: [n=2] FALSE, FALSE
[17:00:32.959]  - until=1
[17:00:32.959]  - relaying element #1
[17:00:32.959] result() for ClusterFuture ...
[17:00:32.959] - result already collected: FutureResult
[17:00:32.959] result() for ClusterFuture ... done
[17:00:32.959] result() for ClusterFuture ...
[17:00:32.959] - result already collected: FutureResult
[17:00:32.959] result() for ClusterFuture ... done
[17:00:32.960] result() for ClusterFuture ...
[17:00:32.960] - result already collected: FutureResult
[17:00:32.960] result() for ClusterFuture ... done
[17:00:32.960] result() for ClusterFuture ...
[17:00:32.960] - result already collected: FutureResult
[17:00:32.960] result() for ClusterFuture ... done
[17:00:32.960] - relayed: [n=2] TRUE, FALSE
[17:00:32.960] - queued futures: [n=2] TRUE, FALSE
[17:00:32.960] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:32.960]  length: 1 (resolved future 1)
[17:00:32.985] receiveMessageFromWorker() for ClusterFuture ...
[17:00:32.985] - Validating connection of MultisessionFuture
[17:00:32.985] - received message: FutureResult
[17:00:32.985] - Received FutureResult
[17:00:32.986] - Erased future from FutureRegistry
[17:00:32.986] result() for ClusterFuture ...
[17:00:32.986] - result already collected: FutureResult
[17:00:32.986] result() for ClusterFuture ... done
[17:00:32.986] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:32.986] Future #2
[17:00:32.986] result() for ClusterFuture ...
[17:00:32.986] - result already collected: FutureResult
[17:00:32.986] result() for ClusterFuture ... done
[17:00:32.986] result() for ClusterFuture ...
[17:00:32.986] - result already collected: FutureResult
[17:00:32.987] result() for ClusterFuture ... done
[17:00:32.987] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:32.987] - nx: 2
[17:00:32.987] - relay: TRUE
[17:00:32.987] - stdout: TRUE
[17:00:32.987] - signal: TRUE
[17:00:32.987] - resignal: FALSE
[17:00:32.987] - force: TRUE
[17:00:32.987] - relayed: [n=2] TRUE, FALSE
[17:00:32.987] - queued futures: [n=2] TRUE, FALSE
[17:00:32.987]  - until=2
[17:00:32.988]  - relaying element #2
[17:00:32.988] result() for ClusterFuture ...
[17:00:32.988] - result already collected: FutureResult
[17:00:32.988] result() for ClusterFuture ... done
[17:00:32.988] result() for ClusterFuture ...
[17:00:32.988] - result already collected: FutureResult
[17:00:32.988] result() for ClusterFuture ... done
[17:00:32.988] result() for ClusterFuture ...
[17:00:32.988] - result already collected: FutureResult
[17:00:32.988] result() for ClusterFuture ... done
[17:00:32.988] result() for ClusterFuture ...
[17:00:32.989] - result already collected: FutureResult
[17:00:32.989] result() for ClusterFuture ... done
[17:00:32.989] - relayed: [n=2] TRUE, TRUE
[17:00:32.989] - queued futures: [n=2] TRUE, TRUE
[17:00:32.989] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:32.989]  length: 0 (resolved future 2)
[17:00:32.989] Relaying remaining futures
[17:00:32.989] signalConditionsASAP(NULL, pos=0) ...
[17:00:32.989] - nx: 2
[17:00:32.989] - relay: TRUE
[17:00:32.989] - stdout: TRUE
[17:00:32.989] - signal: TRUE
[17:00:32.990] - resignal: FALSE
[17:00:32.990] - force: TRUE
[17:00:32.990] - relayed: [n=2] TRUE, TRUE
[17:00:32.990] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:32.990] - relayed: [n=2] TRUE, TRUE
[17:00:32.990] - queued futures: [n=2] TRUE, TRUE
[17:00:32.990] signalConditionsASAP(NULL, pos=0) ... done
[17:00:32.990] resolve() on list ... DONE
[17:00:32.990] result() for ClusterFuture ...
[17:00:32.990] - result already collected: FutureResult
[17:00:32.990] result() for ClusterFuture ... done
[17:00:32.991] result() for ClusterFuture ...
[17:00:32.991] - result already collected: FutureResult
[17:00:32.991] result() for ClusterFuture ... done
[17:00:32.991] result() for ClusterFuture ...
[17:00:32.991] - result already collected: FutureResult
[17:00:32.991] result() for ClusterFuture ... done
[17:00:32.991] result() for ClusterFuture ...
[17:00:32.991] - result already collected: FutureResult
[17:00:32.991] result() for ClusterFuture ... done
[17:00:32.991]  - Number of value chunks collected: 2
[17:00:32.991] Resolving 2 futures (chunks) ... DONE
[17:00:32.992] Reducing values from 2 chunks ...
[17:00:32.992]  - Number of values collected after concatenation: 4
[17:00:32.992]  - Number of values expected: 4
[17:00:32.992] Reducing values from 2 chunks ... DONE
[17:00:32.992] future_mapply() ... DONE
[17:00:32.992] future_mapply() ...
[17:00:32.996] Number of chunks: 2
[17:00:32.996] getGlobalsAndPackagesXApply() ...
[17:00:32.996]  - future.globals: TRUE
[17:00:32.996] getGlobalsAndPackages() ...
[17:00:32.996] Searching for globals...
[17:00:32.998] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:00:32.998] Searching for globals ... DONE
[17:00:32.998] Resolving globals: FALSE
[17:00:32.998] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:00:32.998] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:00:32.999] - globals: [1] ‘FUN’
[17:00:33.001] 
[17:00:33.001] getGlobalsAndPackages() ... DONE
[17:00:33.001]  - globals found/used: [n=1] ‘FUN’
[17:00:33.001]  - needed namespaces: [n=0] 
[17:00:33.001] Finding globals ... DONE
[17:00:33.001] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:33.001] List of 2
[17:00:33.001]  $ ...future.FUN:function (x, y)  
[17:00:33.001]  $ MoreArgs     : NULL
[17:00:33.001]  - attr(*, "where")=List of 2
[17:00:33.001]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:33.001]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:33.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:33.001]  - attr(*, "resolved")= logi FALSE
[17:00:33.001]  - attr(*, "total_size")= num NA
[17:00:33.004] Packages to be attached in all futures: [n=0] 
[17:00:33.004] getGlobalsAndPackagesXApply() ... DONE
[17:00:33.004] Number of futures (= number of chunks): 2
[17:00:33.004] Launching 2 futures (chunks) ...
[17:00:33.004] Chunk #1 of 2 ...
[17:00:33.004]  - Finding globals in '...' for chunk #1 ...
[17:00:33.005] getGlobalsAndPackages() ...
[17:00:33.005] Searching for globals...
[17:00:33.005] 
[17:00:33.005] Searching for globals ... DONE
[17:00:33.005] - globals: [0] <none>
[17:00:33.005] getGlobalsAndPackages() ... DONE
[17:00:33.005]    + additional globals found: [n=0] 
[17:00:33.005]    + additional namespaces needed: [n=0] 
[17:00:33.005]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:33.005]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:33.006]  - seeds: <none>
[17:00:33.006]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.006] getGlobalsAndPackages() ...
[17:00:33.006] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.006] Resolving globals: FALSE
[17:00:33.006] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:00:33.007] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.007] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.007] 
[17:00:33.007] getGlobalsAndPackages() ... DONE
[17:00:33.007] run() for ‘Future’ ...
[17:00:33.008] - state: ‘created’
[17:00:33.008] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.022]   - Field: ‘node’
[17:00:33.022]   - Field: ‘label’
[17:00:33.022]   - Field: ‘local’
[17:00:33.022]   - Field: ‘owner’
[17:00:33.022]   - Field: ‘envir’
[17:00:33.023]   - Field: ‘workers’
[17:00:33.023]   - Field: ‘packages’
[17:00:33.023]   - Field: ‘gc’
[17:00:33.023]   - Field: ‘conditions’
[17:00:33.023]   - Field: ‘persistent’
[17:00:33.023]   - Field: ‘expr’
[17:00:33.023]   - Field: ‘uuid’
[17:00:33.023]   - Field: ‘seed’
[17:00:33.023]   - Field: ‘version’
[17:00:33.023]   - Field: ‘result’
[17:00:33.024]   - Field: ‘asynchronous’
[17:00:33.024]   - Field: ‘calls’
[17:00:33.024]   - Field: ‘globals’
[17:00:33.024]   - Field: ‘stdout’
[17:00:33.024]   - Field: ‘earlySignal’
[17:00:33.024]   - Field: ‘lazy’
[17:00:33.024]   - Field: ‘state’
[17:00:33.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.024] - Launch lazy future ...
[17:00:33.024] Packages needed by the future expression (n = 0): <none>
[17:00:33.025] Packages needed by future strategies (n = 0): <none>
[17:00:33.025] {
[17:00:33.025]     {
[17:00:33.025]         {
[17:00:33.025]             ...future.startTime <- base::Sys.time()
[17:00:33.025]             {
[17:00:33.025]                 {
[17:00:33.025]                   {
[17:00:33.025]                     {
[17:00:33.025]                       base::local({
[17:00:33.025]                         has_future <- base::requireNamespace("future", 
[17:00:33.025]                           quietly = TRUE)
[17:00:33.025]                         if (has_future) {
[17:00:33.025]                           ns <- base::getNamespace("future")
[17:00:33.025]                           version <- ns[[".package"]][["version"]]
[17:00:33.025]                           if (is.null(version)) 
[17:00:33.025]                             version <- utils::packageVersion("future")
[17:00:33.025]                         }
[17:00:33.025]                         else {
[17:00:33.025]                           version <- NULL
[17:00:33.025]                         }
[17:00:33.025]                         if (!has_future || version < "1.8.0") {
[17:00:33.025]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.025]                             "", base::R.version$version.string), 
[17:00:33.025]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.025]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.025]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.025]                               "release", "version")], collapse = " "), 
[17:00:33.025]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.025]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.025]                             info)
[17:00:33.025]                           info <- base::paste(info, collapse = "; ")
[17:00:33.025]                           if (!has_future) {
[17:00:33.025]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.025]                               info)
[17:00:33.025]                           }
[17:00:33.025]                           else {
[17:00:33.025]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.025]                               info, version)
[17:00:33.025]                           }
[17:00:33.025]                           base::stop(msg)
[17:00:33.025]                         }
[17:00:33.025]                       })
[17:00:33.025]                     }
[17:00:33.025]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.025]                     base::options(mc.cores = 1L)
[17:00:33.025]                   }
[17:00:33.025]                   ...future.strategy.old <- future::plan("list")
[17:00:33.025]                   options(future.plan = NULL)
[17:00:33.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.025]                 }
[17:00:33.025]                 ...future.workdir <- getwd()
[17:00:33.025]             }
[17:00:33.025]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.025]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.025]         }
[17:00:33.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.025]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:33.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.025]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.025]             base::names(...future.oldOptions))
[17:00:33.025]     }
[17:00:33.025]     if (FALSE) {
[17:00:33.025]     }
[17:00:33.025]     else {
[17:00:33.025]         if (TRUE) {
[17:00:33.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.025]                 open = "w")
[17:00:33.025]         }
[17:00:33.025]         else {
[17:00:33.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.025]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.025]         }
[17:00:33.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.025]             base::sink(type = "output", split = FALSE)
[17:00:33.025]             base::close(...future.stdout)
[17:00:33.025]         }, add = TRUE)
[17:00:33.025]     }
[17:00:33.025]     ...future.frame <- base::sys.nframe()
[17:00:33.025]     ...future.conditions <- base::list()
[17:00:33.025]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.025]     if (FALSE) {
[17:00:33.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.025]     }
[17:00:33.025]     ...future.result <- base::tryCatch({
[17:00:33.025]         base::withCallingHandlers({
[17:00:33.025]             ...future.value <- base::withVisible(base::local({
[17:00:33.025]                 ...future.makeSendCondition <- base::local({
[17:00:33.025]                   sendCondition <- NULL
[17:00:33.025]                   function(frame = 1L) {
[17:00:33.025]                     if (is.function(sendCondition)) 
[17:00:33.025]                       return(sendCondition)
[17:00:33.025]                     ns <- getNamespace("parallel")
[17:00:33.025]                     if (exists("sendData", mode = "function", 
[17:00:33.025]                       envir = ns)) {
[17:00:33.025]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.025]                         envir = ns)
[17:00:33.025]                       envir <- sys.frame(frame)
[17:00:33.025]                       master <- NULL
[17:00:33.025]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.025]                         !identical(envir, emptyenv())) {
[17:00:33.025]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.025]                           inherits = FALSE)) {
[17:00:33.025]                           master <- get("master", mode = "list", 
[17:00:33.025]                             envir = envir, inherits = FALSE)
[17:00:33.025]                           if (inherits(master, c("SOCKnode", 
[17:00:33.025]                             "SOCK0node"))) {
[17:00:33.025]                             sendCondition <<- function(cond) {
[17:00:33.025]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.025]                                 success = TRUE)
[17:00:33.025]                               parallel_sendData(master, data)
[17:00:33.025]                             }
[17:00:33.025]                             return(sendCondition)
[17:00:33.025]                           }
[17:00:33.025]                         }
[17:00:33.025]                         frame <- frame + 1L
[17:00:33.025]                         envir <- sys.frame(frame)
[17:00:33.025]                       }
[17:00:33.025]                     }
[17:00:33.025]                     sendCondition <<- function(cond) NULL
[17:00:33.025]                   }
[17:00:33.025]                 })
[17:00:33.025]                 withCallingHandlers({
[17:00:33.025]                   {
[17:00:33.025]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.025]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.025]                       ...future.globals.maxSize)) {
[17:00:33.025]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.025]                       on.exit(options(oopts), add = TRUE)
[17:00:33.025]                     }
[17:00:33.025]                     {
[17:00:33.025]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.025]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.025]                         USE.NAMES = FALSE)
[17:00:33.025]                       do.call(mapply, args = args)
[17:00:33.025]                     }
[17:00:33.025]                   }
[17:00:33.025]                 }, immediateCondition = function(cond) {
[17:00:33.025]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.025]                   sendCondition(cond)
[17:00:33.025]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.025]                   {
[17:00:33.025]                     inherits <- base::inherits
[17:00:33.025]                     invokeRestart <- base::invokeRestart
[17:00:33.025]                     is.null <- base::is.null
[17:00:33.025]                     muffled <- FALSE
[17:00:33.025]                     if (inherits(cond, "message")) {
[17:00:33.025]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.025]                       if (muffled) 
[17:00:33.025]                         invokeRestart("muffleMessage")
[17:00:33.025]                     }
[17:00:33.025]                     else if (inherits(cond, "warning")) {
[17:00:33.025]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.025]                       if (muffled) 
[17:00:33.025]                         invokeRestart("muffleWarning")
[17:00:33.025]                     }
[17:00:33.025]                     else if (inherits(cond, "condition")) {
[17:00:33.025]                       if (!is.null(pattern)) {
[17:00:33.025]                         computeRestarts <- base::computeRestarts
[17:00:33.025]                         grepl <- base::grepl
[17:00:33.025]                         restarts <- computeRestarts(cond)
[17:00:33.025]                         for (restart in restarts) {
[17:00:33.025]                           name <- restart$name
[17:00:33.025]                           if (is.null(name)) 
[17:00:33.025]                             next
[17:00:33.025]                           if (!grepl(pattern, name)) 
[17:00:33.025]                             next
[17:00:33.025]                           invokeRestart(restart)
[17:00:33.025]                           muffled <- TRUE
[17:00:33.025]                           break
[17:00:33.025]                         }
[17:00:33.025]                       }
[17:00:33.025]                     }
[17:00:33.025]                     invisible(muffled)
[17:00:33.025]                   }
[17:00:33.025]                   muffleCondition(cond)
[17:00:33.025]                 })
[17:00:33.025]             }))
[17:00:33.025]             future::FutureResult(value = ...future.value$value, 
[17:00:33.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.025]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.025]                     ...future.globalenv.names))
[17:00:33.025]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.025]         }, condition = base::local({
[17:00:33.025]             c <- base::c
[17:00:33.025]             inherits <- base::inherits
[17:00:33.025]             invokeRestart <- base::invokeRestart
[17:00:33.025]             length <- base::length
[17:00:33.025]             list <- base::list
[17:00:33.025]             seq.int <- base::seq.int
[17:00:33.025]             signalCondition <- base::signalCondition
[17:00:33.025]             sys.calls <- base::sys.calls
[17:00:33.025]             `[[` <- base::`[[`
[17:00:33.025]             `+` <- base::`+`
[17:00:33.025]             `<<-` <- base::`<<-`
[17:00:33.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.025]                   3L)]
[17:00:33.025]             }
[17:00:33.025]             function(cond) {
[17:00:33.025]                 is_error <- inherits(cond, "error")
[17:00:33.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.025]                   NULL)
[17:00:33.025]                 if (is_error) {
[17:00:33.025]                   sessionInformation <- function() {
[17:00:33.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.025]                       search = base::search(), system = base::Sys.info())
[17:00:33.025]                   }
[17:00:33.025]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.025]                     cond$call), session = sessionInformation(), 
[17:00:33.025]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.025]                   signalCondition(cond)
[17:00:33.025]                 }
[17:00:33.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.025]                 "immediateCondition"))) {
[17:00:33.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.025]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.025]                   if (TRUE && !signal) {
[17:00:33.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.025]                     {
[17:00:33.025]                       inherits <- base::inherits
[17:00:33.025]                       invokeRestart <- base::invokeRestart
[17:00:33.025]                       is.null <- base::is.null
[17:00:33.025]                       muffled <- FALSE
[17:00:33.025]                       if (inherits(cond, "message")) {
[17:00:33.025]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.025]                         if (muffled) 
[17:00:33.025]                           invokeRestart("muffleMessage")
[17:00:33.025]                       }
[17:00:33.025]                       else if (inherits(cond, "warning")) {
[17:00:33.025]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.025]                         if (muffled) 
[17:00:33.025]                           invokeRestart("muffleWarning")
[17:00:33.025]                       }
[17:00:33.025]                       else if (inherits(cond, "condition")) {
[17:00:33.025]                         if (!is.null(pattern)) {
[17:00:33.025]                           computeRestarts <- base::computeRestarts
[17:00:33.025]                           grepl <- base::grepl
[17:00:33.025]                           restarts <- computeRestarts(cond)
[17:00:33.025]                           for (restart in restarts) {
[17:00:33.025]                             name <- restart$name
[17:00:33.025]                             if (is.null(name)) 
[17:00:33.025]                               next
[17:00:33.025]                             if (!grepl(pattern, name)) 
[17:00:33.025]                               next
[17:00:33.025]                             invokeRestart(restart)
[17:00:33.025]                             muffled <- TRUE
[17:00:33.025]                             break
[17:00:33.025]                           }
[17:00:33.025]                         }
[17:00:33.025]                       }
[17:00:33.025]                       invisible(muffled)
[17:00:33.025]                     }
[17:00:33.025]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.025]                   }
[17:00:33.025]                 }
[17:00:33.025]                 else {
[17:00:33.025]                   if (TRUE) {
[17:00:33.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.025]                     {
[17:00:33.025]                       inherits <- base::inherits
[17:00:33.025]                       invokeRestart <- base::invokeRestart
[17:00:33.025]                       is.null <- base::is.null
[17:00:33.025]                       muffled <- FALSE
[17:00:33.025]                       if (inherits(cond, "message")) {
[17:00:33.025]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.025]                         if (muffled) 
[17:00:33.025]                           invokeRestart("muffleMessage")
[17:00:33.025]                       }
[17:00:33.025]                       else if (inherits(cond, "warning")) {
[17:00:33.025]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.025]                         if (muffled) 
[17:00:33.025]                           invokeRestart("muffleWarning")
[17:00:33.025]                       }
[17:00:33.025]                       else if (inherits(cond, "condition")) {
[17:00:33.025]                         if (!is.null(pattern)) {
[17:00:33.025]                           computeRestarts <- base::computeRestarts
[17:00:33.025]                           grepl <- base::grepl
[17:00:33.025]                           restarts <- computeRestarts(cond)
[17:00:33.025]                           for (restart in restarts) {
[17:00:33.025]                             name <- restart$name
[17:00:33.025]                             if (is.null(name)) 
[17:00:33.025]                               next
[17:00:33.025]                             if (!grepl(pattern, name)) 
[17:00:33.025]                               next
[17:00:33.025]                             invokeRestart(restart)
[17:00:33.025]                             muffled <- TRUE
[17:00:33.025]                             break
[17:00:33.025]                           }
[17:00:33.025]                         }
[17:00:33.025]                       }
[17:00:33.025]                       invisible(muffled)
[17:00:33.025]                     }
[17:00:33.025]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.025]                   }
[17:00:33.025]                 }
[17:00:33.025]             }
[17:00:33.025]         }))
[17:00:33.025]     }, error = function(ex) {
[17:00:33.025]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.025]                 ...future.rng), started = ...future.startTime, 
[17:00:33.025]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.025]             version = "1.8"), class = "FutureResult")
[17:00:33.025]     }, finally = {
[17:00:33.025]         if (!identical(...future.workdir, getwd())) 
[17:00:33.025]             setwd(...future.workdir)
[17:00:33.025]         {
[17:00:33.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.025]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.025]             }
[17:00:33.025]             base::options(...future.oldOptions)
[17:00:33.025]             if (.Platform$OS.type == "windows") {
[17:00:33.025]                 old_names <- names(...future.oldEnvVars)
[17:00:33.025]                 envs <- base::Sys.getenv()
[17:00:33.025]                 names <- names(envs)
[17:00:33.025]                 common <- intersect(names, old_names)
[17:00:33.025]                 added <- setdiff(names, old_names)
[17:00:33.025]                 removed <- setdiff(old_names, names)
[17:00:33.025]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.025]                   envs[common]]
[17:00:33.025]                 NAMES <- toupper(changed)
[17:00:33.025]                 args <- list()
[17:00:33.025]                 for (kk in seq_along(NAMES)) {
[17:00:33.025]                   name <- changed[[kk]]
[17:00:33.025]                   NAME <- NAMES[[kk]]
[17:00:33.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.025]                     next
[17:00:33.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.025]                 }
[17:00:33.025]                 NAMES <- toupper(added)
[17:00:33.025]                 for (kk in seq_along(NAMES)) {
[17:00:33.025]                   name <- added[[kk]]
[17:00:33.025]                   NAME <- NAMES[[kk]]
[17:00:33.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.025]                     next
[17:00:33.025]                   args[[name]] <- ""
[17:00:33.025]                 }
[17:00:33.025]                 NAMES <- toupper(removed)
[17:00:33.025]                 for (kk in seq_along(NAMES)) {
[17:00:33.025]                   name <- removed[[kk]]
[17:00:33.025]                   NAME <- NAMES[[kk]]
[17:00:33.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.025]                     next
[17:00:33.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.025]                 }
[17:00:33.025]                 if (length(args) > 0) 
[17:00:33.025]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.025]             }
[17:00:33.025]             else {
[17:00:33.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.025]             }
[17:00:33.025]             {
[17:00:33.025]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.025]                   0L) {
[17:00:33.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.025]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.025]                   base::options(opts)
[17:00:33.025]                 }
[17:00:33.025]                 {
[17:00:33.025]                   {
[17:00:33.025]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.025]                     NULL
[17:00:33.025]                   }
[17:00:33.025]                   options(future.plan = NULL)
[17:00:33.025]                   if (is.na(NA_character_)) 
[17:00:33.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.025]                     .init = FALSE)
[17:00:33.025]                 }
[17:00:33.025]             }
[17:00:33.025]         }
[17:00:33.025]     })
[17:00:33.025]     if (TRUE) {
[17:00:33.025]         base::sink(type = "output", split = FALSE)
[17:00:33.025]         if (TRUE) {
[17:00:33.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.025]         }
[17:00:33.025]         else {
[17:00:33.025]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.025]         }
[17:00:33.025]         base::close(...future.stdout)
[17:00:33.025]         ...future.stdout <- NULL
[17:00:33.025]     }
[17:00:33.025]     ...future.result$conditions <- ...future.conditions
[17:00:33.025]     ...future.result$finished <- base::Sys.time()
[17:00:33.025]     ...future.result
[17:00:33.025] }
[17:00:33.028] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[17:00:33.028] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[17:00:33.028] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[17:00:33.029] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:33.029] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.029] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:00:33.029] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:00:33.030] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:33.030] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.030] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:33.030] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.031] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[17:00:33.031] MultisessionFuture started
[17:00:33.031] - Launch lazy future ... done
[17:00:33.031] run() for ‘MultisessionFuture’ ... done
[17:00:33.032] Created future:
[17:00:33.032] MultisessionFuture:
[17:00:33.032] Label: ‘future_mapply-1’
[17:00:33.032] Expression:
[17:00:33.032] {
[17:00:33.032]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.032]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.032]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.032]         on.exit(options(oopts), add = TRUE)
[17:00:33.032]     }
[17:00:33.032]     {
[17:00:33.032]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.032]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.032]         do.call(mapply, args = args)
[17:00:33.032]     }
[17:00:33.032] }
[17:00:33.032] Lazy evaluation: FALSE
[17:00:33.032] Asynchronous evaluation: TRUE
[17:00:33.032] Local evaluation: TRUE
[17:00:33.032] Environment: R_GlobalEnv
[17:00:33.032] Capture standard output: TRUE
[17:00:33.032] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.032] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.032] Packages: <none>
[17:00:33.032] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.032] Resolved: FALSE
[17:00:33.032] Value: <not collected>
[17:00:33.032] Conditions captured: <none>
[17:00:33.032] Early signaling: FALSE
[17:00:33.032] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.032] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.043] Chunk #1 of 2 ... DONE
[17:00:33.043] Chunk #2 of 2 ...
[17:00:33.043]  - Finding globals in '...' for chunk #2 ...
[17:00:33.044] getGlobalsAndPackages() ...
[17:00:33.044] Searching for globals...
[17:00:33.044] 
[17:00:33.044] Searching for globals ... DONE
[17:00:33.044] - globals: [0] <none>
[17:00:33.044] getGlobalsAndPackages() ... DONE
[17:00:33.044]    + additional globals found: [n=0] 
[17:00:33.044]    + additional namespaces needed: [n=0] 
[17:00:33.045]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:33.045]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:33.045]  - seeds: <none>
[17:00:33.045]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.045] getGlobalsAndPackages() ...
[17:00:33.045] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.045] Resolving globals: FALSE
[17:00:33.046] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:00:33.046] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.046] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.046] 
[17:00:33.046] getGlobalsAndPackages() ... DONE
[17:00:33.047] run() for ‘Future’ ...
[17:00:33.047] - state: ‘created’
[17:00:33.047] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.062] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.063]   - Field: ‘node’
[17:00:33.063]   - Field: ‘label’
[17:00:33.063]   - Field: ‘local’
[17:00:33.063]   - Field: ‘owner’
[17:00:33.063]   - Field: ‘envir’
[17:00:33.063]   - Field: ‘workers’
[17:00:33.063]   - Field: ‘packages’
[17:00:33.063]   - Field: ‘gc’
[17:00:33.063]   - Field: ‘conditions’
[17:00:33.064]   - Field: ‘persistent’
[17:00:33.064]   - Field: ‘expr’
[17:00:33.064]   - Field: ‘uuid’
[17:00:33.064]   - Field: ‘seed’
[17:00:33.064]   - Field: ‘version’
[17:00:33.064]   - Field: ‘result’
[17:00:33.064]   - Field: ‘asynchronous’
[17:00:33.064]   - Field: ‘calls’
[17:00:33.064]   - Field: ‘globals’
[17:00:33.064]   - Field: ‘stdout’
[17:00:33.064]   - Field: ‘earlySignal’
[17:00:33.065]   - Field: ‘lazy’
[17:00:33.065]   - Field: ‘state’
[17:00:33.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.065] - Launch lazy future ...
[17:00:33.065] Packages needed by the future expression (n = 0): <none>
[17:00:33.065] Packages needed by future strategies (n = 0): <none>
[17:00:33.066] {
[17:00:33.066]     {
[17:00:33.066]         {
[17:00:33.066]             ...future.startTime <- base::Sys.time()
[17:00:33.066]             {
[17:00:33.066]                 {
[17:00:33.066]                   {
[17:00:33.066]                     {
[17:00:33.066]                       base::local({
[17:00:33.066]                         has_future <- base::requireNamespace("future", 
[17:00:33.066]                           quietly = TRUE)
[17:00:33.066]                         if (has_future) {
[17:00:33.066]                           ns <- base::getNamespace("future")
[17:00:33.066]                           version <- ns[[".package"]][["version"]]
[17:00:33.066]                           if (is.null(version)) 
[17:00:33.066]                             version <- utils::packageVersion("future")
[17:00:33.066]                         }
[17:00:33.066]                         else {
[17:00:33.066]                           version <- NULL
[17:00:33.066]                         }
[17:00:33.066]                         if (!has_future || version < "1.8.0") {
[17:00:33.066]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.066]                             "", base::R.version$version.string), 
[17:00:33.066]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.066]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.066]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.066]                               "release", "version")], collapse = " "), 
[17:00:33.066]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.066]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.066]                             info)
[17:00:33.066]                           info <- base::paste(info, collapse = "; ")
[17:00:33.066]                           if (!has_future) {
[17:00:33.066]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.066]                               info)
[17:00:33.066]                           }
[17:00:33.066]                           else {
[17:00:33.066]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.066]                               info, version)
[17:00:33.066]                           }
[17:00:33.066]                           base::stop(msg)
[17:00:33.066]                         }
[17:00:33.066]                       })
[17:00:33.066]                     }
[17:00:33.066]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.066]                     base::options(mc.cores = 1L)
[17:00:33.066]                   }
[17:00:33.066]                   ...future.strategy.old <- future::plan("list")
[17:00:33.066]                   options(future.plan = NULL)
[17:00:33.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.066]                 }
[17:00:33.066]                 ...future.workdir <- getwd()
[17:00:33.066]             }
[17:00:33.066]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.066]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.066]         }
[17:00:33.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.066]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:33.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.066]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.066]             base::names(...future.oldOptions))
[17:00:33.066]     }
[17:00:33.066]     if (FALSE) {
[17:00:33.066]     }
[17:00:33.066]     else {
[17:00:33.066]         if (TRUE) {
[17:00:33.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.066]                 open = "w")
[17:00:33.066]         }
[17:00:33.066]         else {
[17:00:33.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.066]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.066]         }
[17:00:33.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.066]             base::sink(type = "output", split = FALSE)
[17:00:33.066]             base::close(...future.stdout)
[17:00:33.066]         }, add = TRUE)
[17:00:33.066]     }
[17:00:33.066]     ...future.frame <- base::sys.nframe()
[17:00:33.066]     ...future.conditions <- base::list()
[17:00:33.066]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.066]     if (FALSE) {
[17:00:33.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.066]     }
[17:00:33.066]     ...future.result <- base::tryCatch({
[17:00:33.066]         base::withCallingHandlers({
[17:00:33.066]             ...future.value <- base::withVisible(base::local({
[17:00:33.066]                 ...future.makeSendCondition <- base::local({
[17:00:33.066]                   sendCondition <- NULL
[17:00:33.066]                   function(frame = 1L) {
[17:00:33.066]                     if (is.function(sendCondition)) 
[17:00:33.066]                       return(sendCondition)
[17:00:33.066]                     ns <- getNamespace("parallel")
[17:00:33.066]                     if (exists("sendData", mode = "function", 
[17:00:33.066]                       envir = ns)) {
[17:00:33.066]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.066]                         envir = ns)
[17:00:33.066]                       envir <- sys.frame(frame)
[17:00:33.066]                       master <- NULL
[17:00:33.066]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.066]                         !identical(envir, emptyenv())) {
[17:00:33.066]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.066]                           inherits = FALSE)) {
[17:00:33.066]                           master <- get("master", mode = "list", 
[17:00:33.066]                             envir = envir, inherits = FALSE)
[17:00:33.066]                           if (inherits(master, c("SOCKnode", 
[17:00:33.066]                             "SOCK0node"))) {
[17:00:33.066]                             sendCondition <<- function(cond) {
[17:00:33.066]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.066]                                 success = TRUE)
[17:00:33.066]                               parallel_sendData(master, data)
[17:00:33.066]                             }
[17:00:33.066]                             return(sendCondition)
[17:00:33.066]                           }
[17:00:33.066]                         }
[17:00:33.066]                         frame <- frame + 1L
[17:00:33.066]                         envir <- sys.frame(frame)
[17:00:33.066]                       }
[17:00:33.066]                     }
[17:00:33.066]                     sendCondition <<- function(cond) NULL
[17:00:33.066]                   }
[17:00:33.066]                 })
[17:00:33.066]                 withCallingHandlers({
[17:00:33.066]                   {
[17:00:33.066]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.066]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.066]                       ...future.globals.maxSize)) {
[17:00:33.066]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.066]                       on.exit(options(oopts), add = TRUE)
[17:00:33.066]                     }
[17:00:33.066]                     {
[17:00:33.066]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.066]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.066]                         USE.NAMES = FALSE)
[17:00:33.066]                       do.call(mapply, args = args)
[17:00:33.066]                     }
[17:00:33.066]                   }
[17:00:33.066]                 }, immediateCondition = function(cond) {
[17:00:33.066]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.066]                   sendCondition(cond)
[17:00:33.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.066]                   {
[17:00:33.066]                     inherits <- base::inherits
[17:00:33.066]                     invokeRestart <- base::invokeRestart
[17:00:33.066]                     is.null <- base::is.null
[17:00:33.066]                     muffled <- FALSE
[17:00:33.066]                     if (inherits(cond, "message")) {
[17:00:33.066]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.066]                       if (muffled) 
[17:00:33.066]                         invokeRestart("muffleMessage")
[17:00:33.066]                     }
[17:00:33.066]                     else if (inherits(cond, "warning")) {
[17:00:33.066]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.066]                       if (muffled) 
[17:00:33.066]                         invokeRestart("muffleWarning")
[17:00:33.066]                     }
[17:00:33.066]                     else if (inherits(cond, "condition")) {
[17:00:33.066]                       if (!is.null(pattern)) {
[17:00:33.066]                         computeRestarts <- base::computeRestarts
[17:00:33.066]                         grepl <- base::grepl
[17:00:33.066]                         restarts <- computeRestarts(cond)
[17:00:33.066]                         for (restart in restarts) {
[17:00:33.066]                           name <- restart$name
[17:00:33.066]                           if (is.null(name)) 
[17:00:33.066]                             next
[17:00:33.066]                           if (!grepl(pattern, name)) 
[17:00:33.066]                             next
[17:00:33.066]                           invokeRestart(restart)
[17:00:33.066]                           muffled <- TRUE
[17:00:33.066]                           break
[17:00:33.066]                         }
[17:00:33.066]                       }
[17:00:33.066]                     }
[17:00:33.066]                     invisible(muffled)
[17:00:33.066]                   }
[17:00:33.066]                   muffleCondition(cond)
[17:00:33.066]                 })
[17:00:33.066]             }))
[17:00:33.066]             future::FutureResult(value = ...future.value$value, 
[17:00:33.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.066]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.066]                     ...future.globalenv.names))
[17:00:33.066]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.066]         }, condition = base::local({
[17:00:33.066]             c <- base::c
[17:00:33.066]             inherits <- base::inherits
[17:00:33.066]             invokeRestart <- base::invokeRestart
[17:00:33.066]             length <- base::length
[17:00:33.066]             list <- base::list
[17:00:33.066]             seq.int <- base::seq.int
[17:00:33.066]             signalCondition <- base::signalCondition
[17:00:33.066]             sys.calls <- base::sys.calls
[17:00:33.066]             `[[` <- base::`[[`
[17:00:33.066]             `+` <- base::`+`
[17:00:33.066]             `<<-` <- base::`<<-`
[17:00:33.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.066]                   3L)]
[17:00:33.066]             }
[17:00:33.066]             function(cond) {
[17:00:33.066]                 is_error <- inherits(cond, "error")
[17:00:33.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.066]                   NULL)
[17:00:33.066]                 if (is_error) {
[17:00:33.066]                   sessionInformation <- function() {
[17:00:33.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.066]                       search = base::search(), system = base::Sys.info())
[17:00:33.066]                   }
[17:00:33.066]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.066]                     cond$call), session = sessionInformation(), 
[17:00:33.066]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.066]                   signalCondition(cond)
[17:00:33.066]                 }
[17:00:33.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.066]                 "immediateCondition"))) {
[17:00:33.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.066]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.066]                   if (TRUE && !signal) {
[17:00:33.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.066]                     {
[17:00:33.066]                       inherits <- base::inherits
[17:00:33.066]                       invokeRestart <- base::invokeRestart
[17:00:33.066]                       is.null <- base::is.null
[17:00:33.066]                       muffled <- FALSE
[17:00:33.066]                       if (inherits(cond, "message")) {
[17:00:33.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.066]                         if (muffled) 
[17:00:33.066]                           invokeRestart("muffleMessage")
[17:00:33.066]                       }
[17:00:33.066]                       else if (inherits(cond, "warning")) {
[17:00:33.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.066]                         if (muffled) 
[17:00:33.066]                           invokeRestart("muffleWarning")
[17:00:33.066]                       }
[17:00:33.066]                       else if (inherits(cond, "condition")) {
[17:00:33.066]                         if (!is.null(pattern)) {
[17:00:33.066]                           computeRestarts <- base::computeRestarts
[17:00:33.066]                           grepl <- base::grepl
[17:00:33.066]                           restarts <- computeRestarts(cond)
[17:00:33.066]                           for (restart in restarts) {
[17:00:33.066]                             name <- restart$name
[17:00:33.066]                             if (is.null(name)) 
[17:00:33.066]                               next
[17:00:33.066]                             if (!grepl(pattern, name)) 
[17:00:33.066]                               next
[17:00:33.066]                             invokeRestart(restart)
[17:00:33.066]                             muffled <- TRUE
[17:00:33.066]                             break
[17:00:33.066]                           }
[17:00:33.066]                         }
[17:00:33.066]                       }
[17:00:33.066]                       invisible(muffled)
[17:00:33.066]                     }
[17:00:33.066]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.066]                   }
[17:00:33.066]                 }
[17:00:33.066]                 else {
[17:00:33.066]                   if (TRUE) {
[17:00:33.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.066]                     {
[17:00:33.066]                       inherits <- base::inherits
[17:00:33.066]                       invokeRestart <- base::invokeRestart
[17:00:33.066]                       is.null <- base::is.null
[17:00:33.066]                       muffled <- FALSE
[17:00:33.066]                       if (inherits(cond, "message")) {
[17:00:33.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.066]                         if (muffled) 
[17:00:33.066]                           invokeRestart("muffleMessage")
[17:00:33.066]                       }
[17:00:33.066]                       else if (inherits(cond, "warning")) {
[17:00:33.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.066]                         if (muffled) 
[17:00:33.066]                           invokeRestart("muffleWarning")
[17:00:33.066]                       }
[17:00:33.066]                       else if (inherits(cond, "condition")) {
[17:00:33.066]                         if (!is.null(pattern)) {
[17:00:33.066]                           computeRestarts <- base::computeRestarts
[17:00:33.066]                           grepl <- base::grepl
[17:00:33.066]                           restarts <- computeRestarts(cond)
[17:00:33.066]                           for (restart in restarts) {
[17:00:33.066]                             name <- restart$name
[17:00:33.066]                             if (is.null(name)) 
[17:00:33.066]                               next
[17:00:33.066]                             if (!grepl(pattern, name)) 
[17:00:33.066]                               next
[17:00:33.066]                             invokeRestart(restart)
[17:00:33.066]                             muffled <- TRUE
[17:00:33.066]                             break
[17:00:33.066]                           }
[17:00:33.066]                         }
[17:00:33.066]                       }
[17:00:33.066]                       invisible(muffled)
[17:00:33.066]                     }
[17:00:33.066]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.066]                   }
[17:00:33.066]                 }
[17:00:33.066]             }
[17:00:33.066]         }))
[17:00:33.066]     }, error = function(ex) {
[17:00:33.066]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.066]                 ...future.rng), started = ...future.startTime, 
[17:00:33.066]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.066]             version = "1.8"), class = "FutureResult")
[17:00:33.066]     }, finally = {
[17:00:33.066]         if (!identical(...future.workdir, getwd())) 
[17:00:33.066]             setwd(...future.workdir)
[17:00:33.066]         {
[17:00:33.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.066]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.066]             }
[17:00:33.066]             base::options(...future.oldOptions)
[17:00:33.066]             if (.Platform$OS.type == "windows") {
[17:00:33.066]                 old_names <- names(...future.oldEnvVars)
[17:00:33.066]                 envs <- base::Sys.getenv()
[17:00:33.066]                 names <- names(envs)
[17:00:33.066]                 common <- intersect(names, old_names)
[17:00:33.066]                 added <- setdiff(names, old_names)
[17:00:33.066]                 removed <- setdiff(old_names, names)
[17:00:33.066]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.066]                   envs[common]]
[17:00:33.066]                 NAMES <- toupper(changed)
[17:00:33.066]                 args <- list()
[17:00:33.066]                 for (kk in seq_along(NAMES)) {
[17:00:33.066]                   name <- changed[[kk]]
[17:00:33.066]                   NAME <- NAMES[[kk]]
[17:00:33.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.066]                     next
[17:00:33.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.066]                 }
[17:00:33.066]                 NAMES <- toupper(added)
[17:00:33.066]                 for (kk in seq_along(NAMES)) {
[17:00:33.066]                   name <- added[[kk]]
[17:00:33.066]                   NAME <- NAMES[[kk]]
[17:00:33.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.066]                     next
[17:00:33.066]                   args[[name]] <- ""
[17:00:33.066]                 }
[17:00:33.066]                 NAMES <- toupper(removed)
[17:00:33.066]                 for (kk in seq_along(NAMES)) {
[17:00:33.066]                   name <- removed[[kk]]
[17:00:33.066]                   NAME <- NAMES[[kk]]
[17:00:33.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.066]                     next
[17:00:33.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.066]                 }
[17:00:33.066]                 if (length(args) > 0) 
[17:00:33.066]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.066]             }
[17:00:33.066]             else {
[17:00:33.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.066]             }
[17:00:33.066]             {
[17:00:33.066]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.066]                   0L) {
[17:00:33.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.066]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.066]                   base::options(opts)
[17:00:33.066]                 }
[17:00:33.066]                 {
[17:00:33.066]                   {
[17:00:33.066]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.066]                     NULL
[17:00:33.066]                   }
[17:00:33.066]                   options(future.plan = NULL)
[17:00:33.066]                   if (is.na(NA_character_)) 
[17:00:33.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.066]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.066]                     .init = FALSE)
[17:00:33.066]                 }
[17:00:33.066]             }
[17:00:33.066]         }
[17:00:33.066]     })
[17:00:33.066]     if (TRUE) {
[17:00:33.066]         base::sink(type = "output", split = FALSE)
[17:00:33.066]         if (TRUE) {
[17:00:33.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.066]         }
[17:00:33.066]         else {
[17:00:33.066]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.066]         }
[17:00:33.066]         base::close(...future.stdout)
[17:00:33.066]         ...future.stdout <- NULL
[17:00:33.066]     }
[17:00:33.066]     ...future.result$conditions <- ...future.conditions
[17:00:33.066]     ...future.result$finished <- base::Sys.time()
[17:00:33.066]     ...future.result
[17:00:33.066] }
[17:00:33.068] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[17:00:33.069] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[17:00:33.069] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[17:00:33.069] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:33.069] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.069] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:00:33.070] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:00:33.070] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:33.070] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.070] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:33.071] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.071] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[17:00:33.071] MultisessionFuture started
[17:00:33.071] - Launch lazy future ... done
[17:00:33.071] run() for ‘MultisessionFuture’ ... done
[17:00:33.072] Created future:
[17:00:33.072] MultisessionFuture:
[17:00:33.072] Label: ‘future_mapply-2’
[17:00:33.072] Expression:
[17:00:33.072] {
[17:00:33.072]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.072]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.072]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.072]         on.exit(options(oopts), add = TRUE)
[17:00:33.072]     }
[17:00:33.072]     {
[17:00:33.072]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.072]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.072]         do.call(mapply, args = args)
[17:00:33.072]     }
[17:00:33.072] }
[17:00:33.072] Lazy evaluation: FALSE
[17:00:33.072] Asynchronous evaluation: TRUE
[17:00:33.072] Local evaluation: TRUE
[17:00:33.072] Environment: R_GlobalEnv
[17:00:33.072] Capture standard output: TRUE
[17:00:33.072] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.072] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.072] Packages: <none>
[17:00:33.072] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.072] Resolved: FALSE
[17:00:33.072] Value: <not collected>
[17:00:33.072] Conditions captured: <none>
[17:00:33.072] Early signaling: FALSE
[17:00:33.072] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.072] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.084] Chunk #2 of 2 ... DONE
[17:00:33.084] Launching 2 futures (chunks) ... DONE
[17:00:33.084] Resolving 2 futures (chunks) ...
[17:00:33.084] resolve() on list ...
[17:00:33.084]  recursive: 0
[17:00:33.084]  length: 2
[17:00:33.084] 
[17:00:33.085] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.085] - Validating connection of MultisessionFuture
[17:00:33.085] - received message: FutureResult
[17:00:33.085] - Received FutureResult
[17:00:33.085] - Erased future from FutureRegistry
[17:00:33.086] result() for ClusterFuture ...
[17:00:33.086] - result already collected: FutureResult
[17:00:33.086] result() for ClusterFuture ... done
[17:00:33.086] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.086] Future #1
[17:00:33.086] result() for ClusterFuture ...
[17:00:33.086] - result already collected: FutureResult
[17:00:33.086] result() for ClusterFuture ... done
[17:00:33.086] result() for ClusterFuture ...
[17:00:33.086] - result already collected: FutureResult
[17:00:33.086] result() for ClusterFuture ... done
[17:00:33.087] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:33.087] - nx: 2
[17:00:33.087] - relay: TRUE
[17:00:33.087] - stdout: TRUE
[17:00:33.087] - signal: TRUE
[17:00:33.087] - resignal: FALSE
[17:00:33.087] - force: TRUE
[17:00:33.087] - relayed: [n=2] FALSE, FALSE
[17:00:33.087] - queued futures: [n=2] FALSE, FALSE
[17:00:33.087]  - until=1
[17:00:33.087]  - relaying element #1
[17:00:33.087] result() for ClusterFuture ...
[17:00:33.088] - result already collected: FutureResult
[17:00:33.088] result() for ClusterFuture ... done
[17:00:33.088] result() for ClusterFuture ...
[17:00:33.088] - result already collected: FutureResult
[17:00:33.088] result() for ClusterFuture ... done
[17:00:33.088] result() for ClusterFuture ...
[17:00:33.088] - result already collected: FutureResult
[17:00:33.088] result() for ClusterFuture ... done
[17:00:33.088] result() for ClusterFuture ...
[17:00:33.088] - result already collected: FutureResult
[17:00:33.088] result() for ClusterFuture ... done
[17:00:33.089] - relayed: [n=2] TRUE, FALSE
[17:00:33.089] - queued futures: [n=2] TRUE, FALSE
[17:00:33.089] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:33.089]  length: 1 (resolved future 1)
[17:00:33.113] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.113] - Validating connection of MultisessionFuture
[17:00:33.113] - received message: FutureResult
[17:00:33.113] - Received FutureResult
[17:00:33.114] - Erased future from FutureRegistry
[17:00:33.114] result() for ClusterFuture ...
[17:00:33.114] - result already collected: FutureResult
[17:00:33.114] result() for ClusterFuture ... done
[17:00:33.114] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.114] Future #2
[17:00:33.114] result() for ClusterFuture ...
[17:00:33.114] - result already collected: FutureResult
[17:00:33.114] result() for ClusterFuture ... done
[17:00:33.114] result() for ClusterFuture ...
[17:00:33.114] - result already collected: FutureResult
[17:00:33.115] result() for ClusterFuture ... done
[17:00:33.115] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:33.115] - nx: 2
[17:00:33.115] - relay: TRUE
[17:00:33.115] - stdout: TRUE
[17:00:33.115] - signal: TRUE
[17:00:33.115] - resignal: FALSE
[17:00:33.115] - force: TRUE
[17:00:33.115] - relayed: [n=2] TRUE, FALSE
[17:00:33.115] - queued futures: [n=2] TRUE, FALSE
[17:00:33.115]  - until=2
[17:00:33.116]  - relaying element #2
[17:00:33.116] result() for ClusterFuture ...
[17:00:33.116] - result already collected: FutureResult
[17:00:33.116] result() for ClusterFuture ... done
[17:00:33.116] result() for ClusterFuture ...
[17:00:33.116] - result already collected: FutureResult
[17:00:33.116] result() for ClusterFuture ... done
[17:00:33.116] result() for ClusterFuture ...
[17:00:33.116] - result already collected: FutureResult
[17:00:33.116] result() for ClusterFuture ... done
[17:00:33.116] result() for ClusterFuture ...
[17:00:33.116] - result already collected: FutureResult
[17:00:33.117] result() for ClusterFuture ... done
[17:00:33.117] - relayed: [n=2] TRUE, TRUE
[17:00:33.117] - queued futures: [n=2] TRUE, TRUE
[17:00:33.117] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:33.117]  length: 0 (resolved future 2)
[17:00:33.117] Relaying remaining futures
[17:00:33.117] signalConditionsASAP(NULL, pos=0) ...
[17:00:33.117] - nx: 2
[17:00:33.117] - relay: TRUE
[17:00:33.117] - stdout: TRUE
[17:00:33.117] - signal: TRUE
[17:00:33.117] - resignal: FALSE
[17:00:33.118] - force: TRUE
[17:00:33.118] - relayed: [n=2] TRUE, TRUE
[17:00:33.118] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:33.118] - relayed: [n=2] TRUE, TRUE
[17:00:33.118] - queued futures: [n=2] TRUE, TRUE
[17:00:33.118] signalConditionsASAP(NULL, pos=0) ... done
[17:00:33.118] resolve() on list ... DONE
[17:00:33.118] result() for ClusterFuture ...
[17:00:33.118] - result already collected: FutureResult
[17:00:33.118] result() for ClusterFuture ... done
[17:00:33.118] result() for ClusterFuture ...
[17:00:33.119] - result already collected: FutureResult
[17:00:33.119] result() for ClusterFuture ... done
[17:00:33.119] result() for ClusterFuture ...
[17:00:33.119] - result already collected: FutureResult
[17:00:33.119] result() for ClusterFuture ... done
[17:00:33.119] result() for ClusterFuture ...
[17:00:33.119] - result already collected: FutureResult
[17:00:33.119] result() for ClusterFuture ... done
[17:00:33.119]  - Number of value chunks collected: 2
[17:00:33.119] Resolving 2 futures (chunks) ... DONE
[17:00:33.119] Reducing values from 2 chunks ...
[17:00:33.120]  - Number of values collected after concatenation: 3
[17:00:33.120]  - Number of values expected: 3
[17:00:33.120] Reducing values from 2 chunks ... DONE
[17:00:33.120] future_mapply() ... DONE
- future_.mapply()
[17:00:33.120] future_mapply() ...
[17:00:33.124] Number of chunks: 2
[17:00:33.124] getGlobalsAndPackagesXApply() ...
[17:00:33.124]  - future.globals: TRUE
[17:00:33.124] getGlobalsAndPackages() ...
[17:00:33.124] Searching for globals...
[17:00:33.126] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:00:33.126] Searching for globals ... DONE
[17:00:33.126] Resolving globals: FALSE
[17:00:33.126] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:00:33.127] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:00:33.127] - globals: [1] ‘FUN’
[17:00:33.127] 
[17:00:33.127] getGlobalsAndPackages() ... DONE
[17:00:33.127]  - globals found/used: [n=1] ‘FUN’
[17:00:33.127]  - needed namespaces: [n=0] 
[17:00:33.127] Finding globals ... DONE
[17:00:33.127] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:33.128] List of 2
[17:00:33.128]  $ ...future.FUN:function (x, y)  
[17:00:33.128]  $ MoreArgs     : list()
[17:00:33.128]  - attr(*, "where")=List of 2
[17:00:33.128]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:33.128]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:33.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:33.128]  - attr(*, "resolved")= logi FALSE
[17:00:33.128]  - attr(*, "total_size")= num NA
[17:00:33.130] Packages to be attached in all futures: [n=0] 
[17:00:33.130] getGlobalsAndPackagesXApply() ... DONE
[17:00:33.130] Number of futures (= number of chunks): 2
[17:00:33.130] Launching 2 futures (chunks) ...
[17:00:33.130] Chunk #1 of 2 ...
[17:00:33.131]  - Finding globals in '...' for chunk #1 ...
[17:00:33.131] getGlobalsAndPackages() ...
[17:00:33.131] Searching for globals...
[17:00:33.131] 
[17:00:33.131] Searching for globals ... DONE
[17:00:33.131] - globals: [0] <none>
[17:00:33.131] getGlobalsAndPackages() ... DONE
[17:00:33.131]    + additional globals found: [n=0] 
[17:00:33.131]    + additional namespaces needed: [n=0] 
[17:00:33.132]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:33.132]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:33.132]  - seeds: <none>
[17:00:33.132]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.132] getGlobalsAndPackages() ...
[17:00:33.132] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.132] Resolving globals: FALSE
[17:00:33.133] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:00:33.133] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:33.133] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.133] 
[17:00:33.133] getGlobalsAndPackages() ... DONE
[17:00:33.134] run() for ‘Future’ ...
[17:00:33.134] - state: ‘created’
[17:00:33.134] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.148] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.148] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.148]   - Field: ‘node’
[17:00:33.148]   - Field: ‘label’
[17:00:33.148]   - Field: ‘local’
[17:00:33.149]   - Field: ‘owner’
[17:00:33.149]   - Field: ‘envir’
[17:00:33.149]   - Field: ‘workers’
[17:00:33.149]   - Field: ‘packages’
[17:00:33.149]   - Field: ‘gc’
[17:00:33.149]   - Field: ‘conditions’
[17:00:33.149]   - Field: ‘persistent’
[17:00:33.149]   - Field: ‘expr’
[17:00:33.149]   - Field: ‘uuid’
[17:00:33.149]   - Field: ‘seed’
[17:00:33.149]   - Field: ‘version’
[17:00:33.149]   - Field: ‘result’
[17:00:33.150]   - Field: ‘asynchronous’
[17:00:33.150]   - Field: ‘calls’
[17:00:33.150]   - Field: ‘globals’
[17:00:33.150]   - Field: ‘stdout’
[17:00:33.150]   - Field: ‘earlySignal’
[17:00:33.150]   - Field: ‘lazy’
[17:00:33.150]   - Field: ‘state’
[17:00:33.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.150] - Launch lazy future ...
[17:00:33.151] Packages needed by the future expression (n = 0): <none>
[17:00:33.151] Packages needed by future strategies (n = 0): <none>
[17:00:33.151] {
[17:00:33.151]     {
[17:00:33.151]         {
[17:00:33.151]             ...future.startTime <- base::Sys.time()
[17:00:33.151]             {
[17:00:33.151]                 {
[17:00:33.151]                   {
[17:00:33.151]                     {
[17:00:33.151]                       base::local({
[17:00:33.151]                         has_future <- base::requireNamespace("future", 
[17:00:33.151]                           quietly = TRUE)
[17:00:33.151]                         if (has_future) {
[17:00:33.151]                           ns <- base::getNamespace("future")
[17:00:33.151]                           version <- ns[[".package"]][["version"]]
[17:00:33.151]                           if (is.null(version)) 
[17:00:33.151]                             version <- utils::packageVersion("future")
[17:00:33.151]                         }
[17:00:33.151]                         else {
[17:00:33.151]                           version <- NULL
[17:00:33.151]                         }
[17:00:33.151]                         if (!has_future || version < "1.8.0") {
[17:00:33.151]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.151]                             "", base::R.version$version.string), 
[17:00:33.151]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.151]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.151]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.151]                               "release", "version")], collapse = " "), 
[17:00:33.151]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.151]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.151]                             info)
[17:00:33.151]                           info <- base::paste(info, collapse = "; ")
[17:00:33.151]                           if (!has_future) {
[17:00:33.151]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.151]                               info)
[17:00:33.151]                           }
[17:00:33.151]                           else {
[17:00:33.151]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.151]                               info, version)
[17:00:33.151]                           }
[17:00:33.151]                           base::stop(msg)
[17:00:33.151]                         }
[17:00:33.151]                       })
[17:00:33.151]                     }
[17:00:33.151]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.151]                     base::options(mc.cores = 1L)
[17:00:33.151]                   }
[17:00:33.151]                   ...future.strategy.old <- future::plan("list")
[17:00:33.151]                   options(future.plan = NULL)
[17:00:33.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.151]                 }
[17:00:33.151]                 ...future.workdir <- getwd()
[17:00:33.151]             }
[17:00:33.151]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.151]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.151]         }
[17:00:33.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.151]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:33.151]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.151]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.151]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.151]             base::names(...future.oldOptions))
[17:00:33.151]     }
[17:00:33.151]     if (FALSE) {
[17:00:33.151]     }
[17:00:33.151]     else {
[17:00:33.151]         if (TRUE) {
[17:00:33.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.151]                 open = "w")
[17:00:33.151]         }
[17:00:33.151]         else {
[17:00:33.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.151]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.151]         }
[17:00:33.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.151]             base::sink(type = "output", split = FALSE)
[17:00:33.151]             base::close(...future.stdout)
[17:00:33.151]         }, add = TRUE)
[17:00:33.151]     }
[17:00:33.151]     ...future.frame <- base::sys.nframe()
[17:00:33.151]     ...future.conditions <- base::list()
[17:00:33.151]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.151]     if (FALSE) {
[17:00:33.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.151]     }
[17:00:33.151]     ...future.result <- base::tryCatch({
[17:00:33.151]         base::withCallingHandlers({
[17:00:33.151]             ...future.value <- base::withVisible(base::local({
[17:00:33.151]                 ...future.makeSendCondition <- base::local({
[17:00:33.151]                   sendCondition <- NULL
[17:00:33.151]                   function(frame = 1L) {
[17:00:33.151]                     if (is.function(sendCondition)) 
[17:00:33.151]                       return(sendCondition)
[17:00:33.151]                     ns <- getNamespace("parallel")
[17:00:33.151]                     if (exists("sendData", mode = "function", 
[17:00:33.151]                       envir = ns)) {
[17:00:33.151]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.151]                         envir = ns)
[17:00:33.151]                       envir <- sys.frame(frame)
[17:00:33.151]                       master <- NULL
[17:00:33.151]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.151]                         !identical(envir, emptyenv())) {
[17:00:33.151]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.151]                           inherits = FALSE)) {
[17:00:33.151]                           master <- get("master", mode = "list", 
[17:00:33.151]                             envir = envir, inherits = FALSE)
[17:00:33.151]                           if (inherits(master, c("SOCKnode", 
[17:00:33.151]                             "SOCK0node"))) {
[17:00:33.151]                             sendCondition <<- function(cond) {
[17:00:33.151]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.151]                                 success = TRUE)
[17:00:33.151]                               parallel_sendData(master, data)
[17:00:33.151]                             }
[17:00:33.151]                             return(sendCondition)
[17:00:33.151]                           }
[17:00:33.151]                         }
[17:00:33.151]                         frame <- frame + 1L
[17:00:33.151]                         envir <- sys.frame(frame)
[17:00:33.151]                       }
[17:00:33.151]                     }
[17:00:33.151]                     sendCondition <<- function(cond) NULL
[17:00:33.151]                   }
[17:00:33.151]                 })
[17:00:33.151]                 withCallingHandlers({
[17:00:33.151]                   {
[17:00:33.151]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.151]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.151]                       ...future.globals.maxSize)) {
[17:00:33.151]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.151]                       on.exit(options(oopts), add = TRUE)
[17:00:33.151]                     }
[17:00:33.151]                     {
[17:00:33.151]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.151]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.151]                         USE.NAMES = FALSE)
[17:00:33.151]                       do.call(mapply, args = args)
[17:00:33.151]                     }
[17:00:33.151]                   }
[17:00:33.151]                 }, immediateCondition = function(cond) {
[17:00:33.151]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.151]                   sendCondition(cond)
[17:00:33.151]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.151]                   {
[17:00:33.151]                     inherits <- base::inherits
[17:00:33.151]                     invokeRestart <- base::invokeRestart
[17:00:33.151]                     is.null <- base::is.null
[17:00:33.151]                     muffled <- FALSE
[17:00:33.151]                     if (inherits(cond, "message")) {
[17:00:33.151]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.151]                       if (muffled) 
[17:00:33.151]                         invokeRestart("muffleMessage")
[17:00:33.151]                     }
[17:00:33.151]                     else if (inherits(cond, "warning")) {
[17:00:33.151]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.151]                       if (muffled) 
[17:00:33.151]                         invokeRestart("muffleWarning")
[17:00:33.151]                     }
[17:00:33.151]                     else if (inherits(cond, "condition")) {
[17:00:33.151]                       if (!is.null(pattern)) {
[17:00:33.151]                         computeRestarts <- base::computeRestarts
[17:00:33.151]                         grepl <- base::grepl
[17:00:33.151]                         restarts <- computeRestarts(cond)
[17:00:33.151]                         for (restart in restarts) {
[17:00:33.151]                           name <- restart$name
[17:00:33.151]                           if (is.null(name)) 
[17:00:33.151]                             next
[17:00:33.151]                           if (!grepl(pattern, name)) 
[17:00:33.151]                             next
[17:00:33.151]                           invokeRestart(restart)
[17:00:33.151]                           muffled <- TRUE
[17:00:33.151]                           break
[17:00:33.151]                         }
[17:00:33.151]                       }
[17:00:33.151]                     }
[17:00:33.151]                     invisible(muffled)
[17:00:33.151]                   }
[17:00:33.151]                   muffleCondition(cond)
[17:00:33.151]                 })
[17:00:33.151]             }))
[17:00:33.151]             future::FutureResult(value = ...future.value$value, 
[17:00:33.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.151]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.151]                     ...future.globalenv.names))
[17:00:33.151]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.151]         }, condition = base::local({
[17:00:33.151]             c <- base::c
[17:00:33.151]             inherits <- base::inherits
[17:00:33.151]             invokeRestart <- base::invokeRestart
[17:00:33.151]             length <- base::length
[17:00:33.151]             list <- base::list
[17:00:33.151]             seq.int <- base::seq.int
[17:00:33.151]             signalCondition <- base::signalCondition
[17:00:33.151]             sys.calls <- base::sys.calls
[17:00:33.151]             `[[` <- base::`[[`
[17:00:33.151]             `+` <- base::`+`
[17:00:33.151]             `<<-` <- base::`<<-`
[17:00:33.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.151]                   3L)]
[17:00:33.151]             }
[17:00:33.151]             function(cond) {
[17:00:33.151]                 is_error <- inherits(cond, "error")
[17:00:33.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.151]                   NULL)
[17:00:33.151]                 if (is_error) {
[17:00:33.151]                   sessionInformation <- function() {
[17:00:33.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.151]                       search = base::search(), system = base::Sys.info())
[17:00:33.151]                   }
[17:00:33.151]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.151]                     cond$call), session = sessionInformation(), 
[17:00:33.151]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.151]                   signalCondition(cond)
[17:00:33.151]                 }
[17:00:33.151]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.151]                 "immediateCondition"))) {
[17:00:33.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.151]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.151]                   if (TRUE && !signal) {
[17:00:33.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.151]                     {
[17:00:33.151]                       inherits <- base::inherits
[17:00:33.151]                       invokeRestart <- base::invokeRestart
[17:00:33.151]                       is.null <- base::is.null
[17:00:33.151]                       muffled <- FALSE
[17:00:33.151]                       if (inherits(cond, "message")) {
[17:00:33.151]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.151]                         if (muffled) 
[17:00:33.151]                           invokeRestart("muffleMessage")
[17:00:33.151]                       }
[17:00:33.151]                       else if (inherits(cond, "warning")) {
[17:00:33.151]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.151]                         if (muffled) 
[17:00:33.151]                           invokeRestart("muffleWarning")
[17:00:33.151]                       }
[17:00:33.151]                       else if (inherits(cond, "condition")) {
[17:00:33.151]                         if (!is.null(pattern)) {
[17:00:33.151]                           computeRestarts <- base::computeRestarts
[17:00:33.151]                           grepl <- base::grepl
[17:00:33.151]                           restarts <- computeRestarts(cond)
[17:00:33.151]                           for (restart in restarts) {
[17:00:33.151]                             name <- restart$name
[17:00:33.151]                             if (is.null(name)) 
[17:00:33.151]                               next
[17:00:33.151]                             if (!grepl(pattern, name)) 
[17:00:33.151]                               next
[17:00:33.151]                             invokeRestart(restart)
[17:00:33.151]                             muffled <- TRUE
[17:00:33.151]                             break
[17:00:33.151]                           }
[17:00:33.151]                         }
[17:00:33.151]                       }
[17:00:33.151]                       invisible(muffled)
[17:00:33.151]                     }
[17:00:33.151]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.151]                   }
[17:00:33.151]                 }
[17:00:33.151]                 else {
[17:00:33.151]                   if (TRUE) {
[17:00:33.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.151]                     {
[17:00:33.151]                       inherits <- base::inherits
[17:00:33.151]                       invokeRestart <- base::invokeRestart
[17:00:33.151]                       is.null <- base::is.null
[17:00:33.151]                       muffled <- FALSE
[17:00:33.151]                       if (inherits(cond, "message")) {
[17:00:33.151]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.151]                         if (muffled) 
[17:00:33.151]                           invokeRestart("muffleMessage")
[17:00:33.151]                       }
[17:00:33.151]                       else if (inherits(cond, "warning")) {
[17:00:33.151]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.151]                         if (muffled) 
[17:00:33.151]                           invokeRestart("muffleWarning")
[17:00:33.151]                       }
[17:00:33.151]                       else if (inherits(cond, "condition")) {
[17:00:33.151]                         if (!is.null(pattern)) {
[17:00:33.151]                           computeRestarts <- base::computeRestarts
[17:00:33.151]                           grepl <- base::grepl
[17:00:33.151]                           restarts <- computeRestarts(cond)
[17:00:33.151]                           for (restart in restarts) {
[17:00:33.151]                             name <- restart$name
[17:00:33.151]                             if (is.null(name)) 
[17:00:33.151]                               next
[17:00:33.151]                             if (!grepl(pattern, name)) 
[17:00:33.151]                               next
[17:00:33.151]                             invokeRestart(restart)
[17:00:33.151]                             muffled <- TRUE
[17:00:33.151]                             break
[17:00:33.151]                           }
[17:00:33.151]                         }
[17:00:33.151]                       }
[17:00:33.151]                       invisible(muffled)
[17:00:33.151]                     }
[17:00:33.151]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.151]                   }
[17:00:33.151]                 }
[17:00:33.151]             }
[17:00:33.151]         }))
[17:00:33.151]     }, error = function(ex) {
[17:00:33.151]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.151]                 ...future.rng), started = ...future.startTime, 
[17:00:33.151]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.151]             version = "1.8"), class = "FutureResult")
[17:00:33.151]     }, finally = {
[17:00:33.151]         if (!identical(...future.workdir, getwd())) 
[17:00:33.151]             setwd(...future.workdir)
[17:00:33.151]         {
[17:00:33.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.151]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.151]             }
[17:00:33.151]             base::options(...future.oldOptions)
[17:00:33.151]             if (.Platform$OS.type == "windows") {
[17:00:33.151]                 old_names <- names(...future.oldEnvVars)
[17:00:33.151]                 envs <- base::Sys.getenv()
[17:00:33.151]                 names <- names(envs)
[17:00:33.151]                 common <- intersect(names, old_names)
[17:00:33.151]                 added <- setdiff(names, old_names)
[17:00:33.151]                 removed <- setdiff(old_names, names)
[17:00:33.151]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.151]                   envs[common]]
[17:00:33.151]                 NAMES <- toupper(changed)
[17:00:33.151]                 args <- list()
[17:00:33.151]                 for (kk in seq_along(NAMES)) {
[17:00:33.151]                   name <- changed[[kk]]
[17:00:33.151]                   NAME <- NAMES[[kk]]
[17:00:33.151]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.151]                     next
[17:00:33.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.151]                 }
[17:00:33.151]                 NAMES <- toupper(added)
[17:00:33.151]                 for (kk in seq_along(NAMES)) {
[17:00:33.151]                   name <- added[[kk]]
[17:00:33.151]                   NAME <- NAMES[[kk]]
[17:00:33.151]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.151]                     next
[17:00:33.151]                   args[[name]] <- ""
[17:00:33.151]                 }
[17:00:33.151]                 NAMES <- toupper(removed)
[17:00:33.151]                 for (kk in seq_along(NAMES)) {
[17:00:33.151]                   name <- removed[[kk]]
[17:00:33.151]                   NAME <- NAMES[[kk]]
[17:00:33.151]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.151]                     next
[17:00:33.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.151]                 }
[17:00:33.151]                 if (length(args) > 0) 
[17:00:33.151]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.151]             }
[17:00:33.151]             else {
[17:00:33.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.151]             }
[17:00:33.151]             {
[17:00:33.151]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.151]                   0L) {
[17:00:33.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.151]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.151]                   base::options(opts)
[17:00:33.151]                 }
[17:00:33.151]                 {
[17:00:33.151]                   {
[17:00:33.151]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.151]                     NULL
[17:00:33.151]                   }
[17:00:33.151]                   options(future.plan = NULL)
[17:00:33.151]                   if (is.na(NA_character_)) 
[17:00:33.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.151]                     .init = FALSE)
[17:00:33.151]                 }
[17:00:33.151]             }
[17:00:33.151]         }
[17:00:33.151]     })
[17:00:33.151]     if (TRUE) {
[17:00:33.151]         base::sink(type = "output", split = FALSE)
[17:00:33.151]         if (TRUE) {
[17:00:33.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.151]         }
[17:00:33.151]         else {
[17:00:33.151]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.151]         }
[17:00:33.151]         base::close(...future.stdout)
[17:00:33.151]         ...future.stdout <- NULL
[17:00:33.151]     }
[17:00:33.151]     ...future.result$conditions <- ...future.conditions
[17:00:33.151]     ...future.result$finished <- base::Sys.time()
[17:00:33.151]     ...future.result
[17:00:33.151] }
[17:00:33.154] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[17:00:33.154] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[17:00:33.154] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[17:00:33.155] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:33.155] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.155] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:00:33.156] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:00:33.156] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:33.156] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.156] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:33.157] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.157] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[17:00:33.157] MultisessionFuture started
[17:00:33.157] - Launch lazy future ... done
[17:00:33.157] run() for ‘MultisessionFuture’ ... done
[17:00:33.158] Created future:
[17:00:33.158] MultisessionFuture:
[17:00:33.158] Label: ‘future_.mapply-1’
[17:00:33.158] Expression:
[17:00:33.158] {
[17:00:33.158]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.158]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.158]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.158]         on.exit(options(oopts), add = TRUE)
[17:00:33.158]     }
[17:00:33.158]     {
[17:00:33.158]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.158]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.158]         do.call(mapply, args = args)
[17:00:33.158]     }
[17:00:33.158] }
[17:00:33.158] Lazy evaluation: FALSE
[17:00:33.158] Asynchronous evaluation: TRUE
[17:00:33.158] Local evaluation: TRUE
[17:00:33.158] Environment: R_GlobalEnv
[17:00:33.158] Capture standard output: TRUE
[17:00:33.158] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.158] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.158] Packages: <none>
[17:00:33.158] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.158] Resolved: FALSE
[17:00:33.158] Value: <not collected>
[17:00:33.158] Conditions captured: <none>
[17:00:33.158] Early signaling: FALSE
[17:00:33.158] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.158] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.169] Chunk #1 of 2 ... DONE
[17:00:33.169] Chunk #2 of 2 ...
[17:00:33.169]  - Finding globals in '...' for chunk #2 ...
[17:00:33.170] getGlobalsAndPackages() ...
[17:00:33.170] Searching for globals...
[17:00:33.170] 
[17:00:33.170] Searching for globals ... DONE
[17:00:33.170] - globals: [0] <none>
[17:00:33.170] getGlobalsAndPackages() ... DONE
[17:00:33.170]    + additional globals found: [n=0] 
[17:00:33.171]    + additional namespaces needed: [n=0] 
[17:00:33.171]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:33.171]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:33.171]  - seeds: <none>
[17:00:33.171]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.171] getGlobalsAndPackages() ...
[17:00:33.171] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.171] Resolving globals: FALSE
[17:00:33.172] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:00:33.172] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:33.172] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.172] 
[17:00:33.172] getGlobalsAndPackages() ... DONE
[17:00:33.173] run() for ‘Future’ ...
[17:00:33.173] - state: ‘created’
[17:00:33.173] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.187] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.188]   - Field: ‘node’
[17:00:33.188]   - Field: ‘label’
[17:00:33.188]   - Field: ‘local’
[17:00:33.188]   - Field: ‘owner’
[17:00:33.188]   - Field: ‘envir’
[17:00:33.188]   - Field: ‘workers’
[17:00:33.188]   - Field: ‘packages’
[17:00:33.188]   - Field: ‘gc’
[17:00:33.188]   - Field: ‘conditions’
[17:00:33.188]   - Field: ‘persistent’
[17:00:33.188]   - Field: ‘expr’
[17:00:33.189]   - Field: ‘uuid’
[17:00:33.189]   - Field: ‘seed’
[17:00:33.189]   - Field: ‘version’
[17:00:33.189]   - Field: ‘result’
[17:00:33.189]   - Field: ‘asynchronous’
[17:00:33.189]   - Field: ‘calls’
[17:00:33.189]   - Field: ‘globals’
[17:00:33.189]   - Field: ‘stdout’
[17:00:33.189]   - Field: ‘earlySignal’
[17:00:33.189]   - Field: ‘lazy’
[17:00:33.190]   - Field: ‘state’
[17:00:33.190] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.190] - Launch lazy future ...
[17:00:33.190] Packages needed by the future expression (n = 0): <none>
[17:00:33.190] Packages needed by future strategies (n = 0): <none>
[17:00:33.193] {
[17:00:33.193]     {
[17:00:33.193]         {
[17:00:33.193]             ...future.startTime <- base::Sys.time()
[17:00:33.193]             {
[17:00:33.193]                 {
[17:00:33.193]                   {
[17:00:33.193]                     {
[17:00:33.193]                       base::local({
[17:00:33.193]                         has_future <- base::requireNamespace("future", 
[17:00:33.193]                           quietly = TRUE)
[17:00:33.193]                         if (has_future) {
[17:00:33.193]                           ns <- base::getNamespace("future")
[17:00:33.193]                           version <- ns[[".package"]][["version"]]
[17:00:33.193]                           if (is.null(version)) 
[17:00:33.193]                             version <- utils::packageVersion("future")
[17:00:33.193]                         }
[17:00:33.193]                         else {
[17:00:33.193]                           version <- NULL
[17:00:33.193]                         }
[17:00:33.193]                         if (!has_future || version < "1.8.0") {
[17:00:33.193]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.193]                             "", base::R.version$version.string), 
[17:00:33.193]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.193]                               "release", "version")], collapse = " "), 
[17:00:33.193]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.193]                             info)
[17:00:33.193]                           info <- base::paste(info, collapse = "; ")
[17:00:33.193]                           if (!has_future) {
[17:00:33.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.193]                               info)
[17:00:33.193]                           }
[17:00:33.193]                           else {
[17:00:33.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.193]                               info, version)
[17:00:33.193]                           }
[17:00:33.193]                           base::stop(msg)
[17:00:33.193]                         }
[17:00:33.193]                       })
[17:00:33.193]                     }
[17:00:33.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.193]                     base::options(mc.cores = 1L)
[17:00:33.193]                   }
[17:00:33.193]                   ...future.strategy.old <- future::plan("list")
[17:00:33.193]                   options(future.plan = NULL)
[17:00:33.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.193]                 }
[17:00:33.193]                 ...future.workdir <- getwd()
[17:00:33.193]             }
[17:00:33.193]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.193]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.193]         }
[17:00:33.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.193]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:33.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.193]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.193]             base::names(...future.oldOptions))
[17:00:33.193]     }
[17:00:33.193]     if (FALSE) {
[17:00:33.193]     }
[17:00:33.193]     else {
[17:00:33.193]         if (TRUE) {
[17:00:33.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.193]                 open = "w")
[17:00:33.193]         }
[17:00:33.193]         else {
[17:00:33.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.193]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.193]         }
[17:00:33.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.193]             base::sink(type = "output", split = FALSE)
[17:00:33.193]             base::close(...future.stdout)
[17:00:33.193]         }, add = TRUE)
[17:00:33.193]     }
[17:00:33.193]     ...future.frame <- base::sys.nframe()
[17:00:33.193]     ...future.conditions <- base::list()
[17:00:33.193]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.193]     if (FALSE) {
[17:00:33.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.193]     }
[17:00:33.193]     ...future.result <- base::tryCatch({
[17:00:33.193]         base::withCallingHandlers({
[17:00:33.193]             ...future.value <- base::withVisible(base::local({
[17:00:33.193]                 ...future.makeSendCondition <- base::local({
[17:00:33.193]                   sendCondition <- NULL
[17:00:33.193]                   function(frame = 1L) {
[17:00:33.193]                     if (is.function(sendCondition)) 
[17:00:33.193]                       return(sendCondition)
[17:00:33.193]                     ns <- getNamespace("parallel")
[17:00:33.193]                     if (exists("sendData", mode = "function", 
[17:00:33.193]                       envir = ns)) {
[17:00:33.193]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.193]                         envir = ns)
[17:00:33.193]                       envir <- sys.frame(frame)
[17:00:33.193]                       master <- NULL
[17:00:33.193]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.193]                         !identical(envir, emptyenv())) {
[17:00:33.193]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.193]                           inherits = FALSE)) {
[17:00:33.193]                           master <- get("master", mode = "list", 
[17:00:33.193]                             envir = envir, inherits = FALSE)
[17:00:33.193]                           if (inherits(master, c("SOCKnode", 
[17:00:33.193]                             "SOCK0node"))) {
[17:00:33.193]                             sendCondition <<- function(cond) {
[17:00:33.193]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.193]                                 success = TRUE)
[17:00:33.193]                               parallel_sendData(master, data)
[17:00:33.193]                             }
[17:00:33.193]                             return(sendCondition)
[17:00:33.193]                           }
[17:00:33.193]                         }
[17:00:33.193]                         frame <- frame + 1L
[17:00:33.193]                         envir <- sys.frame(frame)
[17:00:33.193]                       }
[17:00:33.193]                     }
[17:00:33.193]                     sendCondition <<- function(cond) NULL
[17:00:33.193]                   }
[17:00:33.193]                 })
[17:00:33.193]                 withCallingHandlers({
[17:00:33.193]                   {
[17:00:33.193]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.193]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.193]                       ...future.globals.maxSize)) {
[17:00:33.193]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.193]                       on.exit(options(oopts), add = TRUE)
[17:00:33.193]                     }
[17:00:33.193]                     {
[17:00:33.193]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.193]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.193]                         USE.NAMES = FALSE)
[17:00:33.193]                       do.call(mapply, args = args)
[17:00:33.193]                     }
[17:00:33.193]                   }
[17:00:33.193]                 }, immediateCondition = function(cond) {
[17:00:33.193]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.193]                   sendCondition(cond)
[17:00:33.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.193]                   {
[17:00:33.193]                     inherits <- base::inherits
[17:00:33.193]                     invokeRestart <- base::invokeRestart
[17:00:33.193]                     is.null <- base::is.null
[17:00:33.193]                     muffled <- FALSE
[17:00:33.193]                     if (inherits(cond, "message")) {
[17:00:33.193]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.193]                       if (muffled) 
[17:00:33.193]                         invokeRestart("muffleMessage")
[17:00:33.193]                     }
[17:00:33.193]                     else if (inherits(cond, "warning")) {
[17:00:33.193]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.193]                       if (muffled) 
[17:00:33.193]                         invokeRestart("muffleWarning")
[17:00:33.193]                     }
[17:00:33.193]                     else if (inherits(cond, "condition")) {
[17:00:33.193]                       if (!is.null(pattern)) {
[17:00:33.193]                         computeRestarts <- base::computeRestarts
[17:00:33.193]                         grepl <- base::grepl
[17:00:33.193]                         restarts <- computeRestarts(cond)
[17:00:33.193]                         for (restart in restarts) {
[17:00:33.193]                           name <- restart$name
[17:00:33.193]                           if (is.null(name)) 
[17:00:33.193]                             next
[17:00:33.193]                           if (!grepl(pattern, name)) 
[17:00:33.193]                             next
[17:00:33.193]                           invokeRestart(restart)
[17:00:33.193]                           muffled <- TRUE
[17:00:33.193]                           break
[17:00:33.193]                         }
[17:00:33.193]                       }
[17:00:33.193]                     }
[17:00:33.193]                     invisible(muffled)
[17:00:33.193]                   }
[17:00:33.193]                   muffleCondition(cond)
[17:00:33.193]                 })
[17:00:33.193]             }))
[17:00:33.193]             future::FutureResult(value = ...future.value$value, 
[17:00:33.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.193]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.193]                     ...future.globalenv.names))
[17:00:33.193]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.193]         }, condition = base::local({
[17:00:33.193]             c <- base::c
[17:00:33.193]             inherits <- base::inherits
[17:00:33.193]             invokeRestart <- base::invokeRestart
[17:00:33.193]             length <- base::length
[17:00:33.193]             list <- base::list
[17:00:33.193]             seq.int <- base::seq.int
[17:00:33.193]             signalCondition <- base::signalCondition
[17:00:33.193]             sys.calls <- base::sys.calls
[17:00:33.193]             `[[` <- base::`[[`
[17:00:33.193]             `+` <- base::`+`
[17:00:33.193]             `<<-` <- base::`<<-`
[17:00:33.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.193]                   3L)]
[17:00:33.193]             }
[17:00:33.193]             function(cond) {
[17:00:33.193]                 is_error <- inherits(cond, "error")
[17:00:33.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.193]                   NULL)
[17:00:33.193]                 if (is_error) {
[17:00:33.193]                   sessionInformation <- function() {
[17:00:33.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.193]                       search = base::search(), system = base::Sys.info())
[17:00:33.193]                   }
[17:00:33.193]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.193]                     cond$call), session = sessionInformation(), 
[17:00:33.193]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.193]                   signalCondition(cond)
[17:00:33.193]                 }
[17:00:33.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.193]                 "immediateCondition"))) {
[17:00:33.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.193]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.193]                   if (TRUE && !signal) {
[17:00:33.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.193]                     {
[17:00:33.193]                       inherits <- base::inherits
[17:00:33.193]                       invokeRestart <- base::invokeRestart
[17:00:33.193]                       is.null <- base::is.null
[17:00:33.193]                       muffled <- FALSE
[17:00:33.193]                       if (inherits(cond, "message")) {
[17:00:33.193]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.193]                         if (muffled) 
[17:00:33.193]                           invokeRestart("muffleMessage")
[17:00:33.193]                       }
[17:00:33.193]                       else if (inherits(cond, "warning")) {
[17:00:33.193]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.193]                         if (muffled) 
[17:00:33.193]                           invokeRestart("muffleWarning")
[17:00:33.193]                       }
[17:00:33.193]                       else if (inherits(cond, "condition")) {
[17:00:33.193]                         if (!is.null(pattern)) {
[17:00:33.193]                           computeRestarts <- base::computeRestarts
[17:00:33.193]                           grepl <- base::grepl
[17:00:33.193]                           restarts <- computeRestarts(cond)
[17:00:33.193]                           for (restart in restarts) {
[17:00:33.193]                             name <- restart$name
[17:00:33.193]                             if (is.null(name)) 
[17:00:33.193]                               next
[17:00:33.193]                             if (!grepl(pattern, name)) 
[17:00:33.193]                               next
[17:00:33.193]                             invokeRestart(restart)
[17:00:33.193]                             muffled <- TRUE
[17:00:33.193]                             break
[17:00:33.193]                           }
[17:00:33.193]                         }
[17:00:33.193]                       }
[17:00:33.193]                       invisible(muffled)
[17:00:33.193]                     }
[17:00:33.193]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.193]                   }
[17:00:33.193]                 }
[17:00:33.193]                 else {
[17:00:33.193]                   if (TRUE) {
[17:00:33.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.193]                     {
[17:00:33.193]                       inherits <- base::inherits
[17:00:33.193]                       invokeRestart <- base::invokeRestart
[17:00:33.193]                       is.null <- base::is.null
[17:00:33.193]                       muffled <- FALSE
[17:00:33.193]                       if (inherits(cond, "message")) {
[17:00:33.193]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.193]                         if (muffled) 
[17:00:33.193]                           invokeRestart("muffleMessage")
[17:00:33.193]                       }
[17:00:33.193]                       else if (inherits(cond, "warning")) {
[17:00:33.193]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.193]                         if (muffled) 
[17:00:33.193]                           invokeRestart("muffleWarning")
[17:00:33.193]                       }
[17:00:33.193]                       else if (inherits(cond, "condition")) {
[17:00:33.193]                         if (!is.null(pattern)) {
[17:00:33.193]                           computeRestarts <- base::computeRestarts
[17:00:33.193]                           grepl <- base::grepl
[17:00:33.193]                           restarts <- computeRestarts(cond)
[17:00:33.193]                           for (restart in restarts) {
[17:00:33.193]                             name <- restart$name
[17:00:33.193]                             if (is.null(name)) 
[17:00:33.193]                               next
[17:00:33.193]                             if (!grepl(pattern, name)) 
[17:00:33.193]                               next
[17:00:33.193]                             invokeRestart(restart)
[17:00:33.193]                             muffled <- TRUE
[17:00:33.193]                             break
[17:00:33.193]                           }
[17:00:33.193]                         }
[17:00:33.193]                       }
[17:00:33.193]                       invisible(muffled)
[17:00:33.193]                     }
[17:00:33.193]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.193]                   }
[17:00:33.193]                 }
[17:00:33.193]             }
[17:00:33.193]         }))
[17:00:33.193]     }, error = function(ex) {
[17:00:33.193]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.193]                 ...future.rng), started = ...future.startTime, 
[17:00:33.193]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.193]             version = "1.8"), class = "FutureResult")
[17:00:33.193]     }, finally = {
[17:00:33.193]         if (!identical(...future.workdir, getwd())) 
[17:00:33.193]             setwd(...future.workdir)
[17:00:33.193]         {
[17:00:33.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.193]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.193]             }
[17:00:33.193]             base::options(...future.oldOptions)
[17:00:33.193]             if (.Platform$OS.type == "windows") {
[17:00:33.193]                 old_names <- names(...future.oldEnvVars)
[17:00:33.193]                 envs <- base::Sys.getenv()
[17:00:33.193]                 names <- names(envs)
[17:00:33.193]                 common <- intersect(names, old_names)
[17:00:33.193]                 added <- setdiff(names, old_names)
[17:00:33.193]                 removed <- setdiff(old_names, names)
[17:00:33.193]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.193]                   envs[common]]
[17:00:33.193]                 NAMES <- toupper(changed)
[17:00:33.193]                 args <- list()
[17:00:33.193]                 for (kk in seq_along(NAMES)) {
[17:00:33.193]                   name <- changed[[kk]]
[17:00:33.193]                   NAME <- NAMES[[kk]]
[17:00:33.193]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.193]                     next
[17:00:33.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.193]                 }
[17:00:33.193]                 NAMES <- toupper(added)
[17:00:33.193]                 for (kk in seq_along(NAMES)) {
[17:00:33.193]                   name <- added[[kk]]
[17:00:33.193]                   NAME <- NAMES[[kk]]
[17:00:33.193]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.193]                     next
[17:00:33.193]                   args[[name]] <- ""
[17:00:33.193]                 }
[17:00:33.193]                 NAMES <- toupper(removed)
[17:00:33.193]                 for (kk in seq_along(NAMES)) {
[17:00:33.193]                   name <- removed[[kk]]
[17:00:33.193]                   NAME <- NAMES[[kk]]
[17:00:33.193]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.193]                     next
[17:00:33.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.193]                 }
[17:00:33.193]                 if (length(args) > 0) 
[17:00:33.193]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.193]             }
[17:00:33.193]             else {
[17:00:33.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.193]             }
[17:00:33.193]             {
[17:00:33.193]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.193]                   0L) {
[17:00:33.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.193]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.193]                   base::options(opts)
[17:00:33.193]                 }
[17:00:33.193]                 {
[17:00:33.193]                   {
[17:00:33.193]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.193]                     NULL
[17:00:33.193]                   }
[17:00:33.193]                   options(future.plan = NULL)
[17:00:33.193]                   if (is.na(NA_character_)) 
[17:00:33.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.193]                     .init = FALSE)
[17:00:33.193]                 }
[17:00:33.193]             }
[17:00:33.193]         }
[17:00:33.193]     })
[17:00:33.193]     if (TRUE) {
[17:00:33.193]         base::sink(type = "output", split = FALSE)
[17:00:33.193]         if (TRUE) {
[17:00:33.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.193]         }
[17:00:33.193]         else {
[17:00:33.193]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.193]         }
[17:00:33.193]         base::close(...future.stdout)
[17:00:33.193]         ...future.stdout <- NULL
[17:00:33.193]     }
[17:00:33.193]     ...future.result$conditions <- ...future.conditions
[17:00:33.193]     ...future.result$finished <- base::Sys.time()
[17:00:33.193]     ...future.result
[17:00:33.193] }
[17:00:33.195] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[17:00:33.196] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[17:00:33.196] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[17:00:33.196] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:33.196] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.197] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:00:33.197] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:00:33.197] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:33.197] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.197] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:33.198] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.198] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[17:00:33.198] MultisessionFuture started
[17:00:33.198] - Launch lazy future ... done
[17:00:33.198] run() for ‘MultisessionFuture’ ... done
[17:00:33.198] Created future:
[17:00:33.199] MultisessionFuture:
[17:00:33.199] Label: ‘future_.mapply-2’
[17:00:33.199] Expression:
[17:00:33.199] {
[17:00:33.199]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.199]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.199]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.199]         on.exit(options(oopts), add = TRUE)
[17:00:33.199]     }
[17:00:33.199]     {
[17:00:33.199]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.199]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.199]         do.call(mapply, args = args)
[17:00:33.199]     }
[17:00:33.199] }
[17:00:33.199] Lazy evaluation: FALSE
[17:00:33.199] Asynchronous evaluation: TRUE
[17:00:33.199] Local evaluation: TRUE
[17:00:33.199] Environment: R_GlobalEnv
[17:00:33.199] Capture standard output: TRUE
[17:00:33.199] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.199] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.199] Packages: <none>
[17:00:33.199] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.199] Resolved: FALSE
[17:00:33.199] Value: <not collected>
[17:00:33.199] Conditions captured: <none>
[17:00:33.199] Early signaling: FALSE
[17:00:33.199] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.199] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.210] Chunk #2 of 2 ... DONE
[17:00:33.210] Launching 2 futures (chunks) ... DONE
[17:00:33.210] Resolving 2 futures (chunks) ...
[17:00:33.211] resolve() on list ...
[17:00:33.211]  recursive: 0
[17:00:33.211]  length: 2
[17:00:33.211] 
[17:00:33.212] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.212] - Validating connection of MultisessionFuture
[17:00:33.212] - received message: FutureResult
[17:00:33.212] - Received FutureResult
[17:00:33.212] - Erased future from FutureRegistry
[17:00:33.212] result() for ClusterFuture ...
[17:00:33.212] - result already collected: FutureResult
[17:00:33.212] result() for ClusterFuture ... done
[17:00:33.212] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.213] Future #1
[17:00:33.213] result() for ClusterFuture ...
[17:00:33.213] - result already collected: FutureResult
[17:00:33.213] result() for ClusterFuture ... done
[17:00:33.213] result() for ClusterFuture ...
[17:00:33.213] - result already collected: FutureResult
[17:00:33.213] result() for ClusterFuture ... done
[17:00:33.213] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:33.213] - nx: 2
[17:00:33.213] - relay: TRUE
[17:00:33.213] - stdout: TRUE
[17:00:33.214] - signal: TRUE
[17:00:33.214] - resignal: FALSE
[17:00:33.214] - force: TRUE
[17:00:33.214] - relayed: [n=2] FALSE, FALSE
[17:00:33.214] - queued futures: [n=2] FALSE, FALSE
[17:00:33.214]  - until=1
[17:00:33.214]  - relaying element #1
[17:00:33.214] result() for ClusterFuture ...
[17:00:33.214] - result already collected: FutureResult
[17:00:33.214] result() for ClusterFuture ... done
[17:00:33.214] result() for ClusterFuture ...
[17:00:33.214] - result already collected: FutureResult
[17:00:33.215] result() for ClusterFuture ... done
[17:00:33.215] result() for ClusterFuture ...
[17:00:33.215] - result already collected: FutureResult
[17:00:33.215] result() for ClusterFuture ... done
[17:00:33.215] result() for ClusterFuture ...
[17:00:33.215] - result already collected: FutureResult
[17:00:33.215] result() for ClusterFuture ... done
[17:00:33.215] - relayed: [n=2] TRUE, FALSE
[17:00:33.215] - queued futures: [n=2] TRUE, FALSE
[17:00:33.215] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:33.215]  length: 1 (resolved future 1)
[17:00:33.241] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.241] - Validating connection of MultisessionFuture
[17:00:33.241] - received message: FutureResult
[17:00:33.242] - Received FutureResult
[17:00:33.242] - Erased future from FutureRegistry
[17:00:33.242] result() for ClusterFuture ...
[17:00:33.242] - result already collected: FutureResult
[17:00:33.242] result() for ClusterFuture ... done
[17:00:33.242] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.242] Future #2
[17:00:33.242] result() for ClusterFuture ...
[17:00:33.242] - result already collected: FutureResult
[17:00:33.242] result() for ClusterFuture ... done
[17:00:33.243] result() for ClusterFuture ...
[17:00:33.243] - result already collected: FutureResult
[17:00:33.243] result() for ClusterFuture ... done
[17:00:33.243] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:33.243] - nx: 2
[17:00:33.243] - relay: TRUE
[17:00:33.243] - stdout: TRUE
[17:00:33.243] - signal: TRUE
[17:00:33.243] - resignal: FALSE
[17:00:33.243] - force: TRUE
[17:00:33.243] - relayed: [n=2] TRUE, FALSE
[17:00:33.243] - queued futures: [n=2] TRUE, FALSE
[17:00:33.244]  - until=2
[17:00:33.244]  - relaying element #2
[17:00:33.244] result() for ClusterFuture ...
[17:00:33.244] - result already collected: FutureResult
[17:00:33.244] result() for ClusterFuture ... done
[17:00:33.244] result() for ClusterFuture ...
[17:00:33.244] - result already collected: FutureResult
[17:00:33.244] result() for ClusterFuture ... done
[17:00:33.244] result() for ClusterFuture ...
[17:00:33.244] - result already collected: FutureResult
[17:00:33.244] result() for ClusterFuture ... done
[17:00:33.245] result() for ClusterFuture ...
[17:00:33.245] - result already collected: FutureResult
[17:00:33.245] result() for ClusterFuture ... done
[17:00:33.245] - relayed: [n=2] TRUE, TRUE
[17:00:33.245] - queued futures: [n=2] TRUE, TRUE
[17:00:33.245] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:33.245]  length: 0 (resolved future 2)
[17:00:33.245] Relaying remaining futures
[17:00:33.245] signalConditionsASAP(NULL, pos=0) ...
[17:00:33.245] - nx: 2
[17:00:33.245] - relay: TRUE
[17:00:33.245] - stdout: TRUE
[17:00:33.246] - signal: TRUE
[17:00:33.246] - resignal: FALSE
[17:00:33.246] - force: TRUE
[17:00:33.246] - relayed: [n=2] TRUE, TRUE
[17:00:33.246] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:33.246] - relayed: [n=2] TRUE, TRUE
[17:00:33.246] - queued futures: [n=2] TRUE, TRUE
[17:00:33.246] signalConditionsASAP(NULL, pos=0) ... done
[17:00:33.246] resolve() on list ... DONE
[17:00:33.246] result() for ClusterFuture ...
[17:00:33.246] - result already collected: FutureResult
[17:00:33.247] result() for ClusterFuture ... done
[17:00:33.247] result() for ClusterFuture ...
[17:00:33.247] - result already collected: FutureResult
[17:00:33.247] result() for ClusterFuture ... done
[17:00:33.247] result() for ClusterFuture ...
[17:00:33.247] - result already collected: FutureResult
[17:00:33.247] result() for ClusterFuture ... done
[17:00:33.247] result() for ClusterFuture ...
[17:00:33.247] - result already collected: FutureResult
[17:00:33.247] result() for ClusterFuture ... done
[17:00:33.247]  - Number of value chunks collected: 2
[17:00:33.248] Resolving 2 futures (chunks) ... DONE
[17:00:33.248] Reducing values from 2 chunks ...
[17:00:33.248]  - Number of values collected after concatenation: 3
[17:00:33.248]  - Number of values expected: 3
[17:00:33.248] Reducing values from 2 chunks ... DONE
[17:00:33.248] future_mapply() ... DONE
[17:00:33.248] future_mapply() ...
[17:00:33.252] Number of chunks: 5
[17:00:33.252] getGlobalsAndPackagesXApply() ...
[17:00:33.252]  - future.globals: TRUE
[17:00:33.253] getGlobalsAndPackages() ...
[17:00:33.253] Searching for globals...
[17:00:33.254] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:33.254] Searching for globals ... DONE
[17:00:33.254] Resolving globals: FALSE
[17:00:33.254] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:33.255] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:33.255] - globals: [1] ‘FUN’
[17:00:33.255] 
[17:00:33.255] getGlobalsAndPackages() ... DONE
[17:00:33.255]  - globals found/used: [n=1] ‘FUN’
[17:00:33.255]  - needed namespaces: [n=0] 
[17:00:33.255] Finding globals ... DONE
[17:00:33.256] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:33.256] List of 2
[17:00:33.256]  $ ...future.FUN:function (C, k)  
[17:00:33.256]  $ MoreArgs     : NULL
[17:00:33.256]  - attr(*, "where")=List of 2
[17:00:33.256]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:33.256]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:33.256]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:33.256]  - attr(*, "resolved")= logi FALSE
[17:00:33.256]  - attr(*, "total_size")= num NA
[17:00:33.258] Packages to be attached in all futures: [n=0] 
[17:00:33.258] getGlobalsAndPackagesXApply() ... DONE
[17:00:33.258] Number of futures (= number of chunks): 5
[17:00:33.259] Launching 5 futures (chunks) ...
[17:00:33.259] Chunk #1 of 5 ...
[17:00:33.259]  - Finding globals in '...' for chunk #1 ...
[17:00:33.259] getGlobalsAndPackages() ...
[17:00:33.259] Searching for globals...
[17:00:33.259] 
[17:00:33.259] Searching for globals ... DONE
[17:00:33.260] - globals: [0] <none>
[17:00:33.260] getGlobalsAndPackages() ... DONE
[17:00:33.260]    + additional globals found: [n=0] 
[17:00:33.260]    + additional namespaces needed: [n=0] 
[17:00:33.260]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:33.260]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:33.260]  - seeds: <none>
[17:00:33.260]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.260] getGlobalsAndPackages() ...
[17:00:33.260] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.260] Resolving globals: FALSE
[17:00:33.261] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:33.261] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.261] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.262] 
[17:00:33.262] getGlobalsAndPackages() ... DONE
[17:00:33.262] run() for ‘Future’ ...
[17:00:33.262] - state: ‘created’
[17:00:33.262] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.276] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.277]   - Field: ‘node’
[17:00:33.277]   - Field: ‘label’
[17:00:33.277]   - Field: ‘local’
[17:00:33.277]   - Field: ‘owner’
[17:00:33.277]   - Field: ‘envir’
[17:00:33.277]   - Field: ‘workers’
[17:00:33.277]   - Field: ‘packages’
[17:00:33.277]   - Field: ‘gc’
[17:00:33.278]   - Field: ‘conditions’
[17:00:33.278]   - Field: ‘persistent’
[17:00:33.278]   - Field: ‘expr’
[17:00:33.278]   - Field: ‘uuid’
[17:00:33.278]   - Field: ‘seed’
[17:00:33.278]   - Field: ‘version’
[17:00:33.278]   - Field: ‘result’
[17:00:33.278]   - Field: ‘asynchronous’
[17:00:33.278]   - Field: ‘calls’
[17:00:33.278]   - Field: ‘globals’
[17:00:33.278]   - Field: ‘stdout’
[17:00:33.278]   - Field: ‘earlySignal’
[17:00:33.279]   - Field: ‘lazy’
[17:00:33.279]   - Field: ‘state’
[17:00:33.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.279] - Launch lazy future ...
[17:00:33.279] Packages needed by the future expression (n = 0): <none>
[17:00:33.279] Packages needed by future strategies (n = 0): <none>
[17:00:33.280] {
[17:00:33.280]     {
[17:00:33.280]         {
[17:00:33.280]             ...future.startTime <- base::Sys.time()
[17:00:33.280]             {
[17:00:33.280]                 {
[17:00:33.280]                   {
[17:00:33.280]                     {
[17:00:33.280]                       base::local({
[17:00:33.280]                         has_future <- base::requireNamespace("future", 
[17:00:33.280]                           quietly = TRUE)
[17:00:33.280]                         if (has_future) {
[17:00:33.280]                           ns <- base::getNamespace("future")
[17:00:33.280]                           version <- ns[[".package"]][["version"]]
[17:00:33.280]                           if (is.null(version)) 
[17:00:33.280]                             version <- utils::packageVersion("future")
[17:00:33.280]                         }
[17:00:33.280]                         else {
[17:00:33.280]                           version <- NULL
[17:00:33.280]                         }
[17:00:33.280]                         if (!has_future || version < "1.8.0") {
[17:00:33.280]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.280]                             "", base::R.version$version.string), 
[17:00:33.280]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.280]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.280]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.280]                               "release", "version")], collapse = " "), 
[17:00:33.280]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.280]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.280]                             info)
[17:00:33.280]                           info <- base::paste(info, collapse = "; ")
[17:00:33.280]                           if (!has_future) {
[17:00:33.280]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.280]                               info)
[17:00:33.280]                           }
[17:00:33.280]                           else {
[17:00:33.280]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.280]                               info, version)
[17:00:33.280]                           }
[17:00:33.280]                           base::stop(msg)
[17:00:33.280]                         }
[17:00:33.280]                       })
[17:00:33.280]                     }
[17:00:33.280]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.280]                     base::options(mc.cores = 1L)
[17:00:33.280]                   }
[17:00:33.280]                   ...future.strategy.old <- future::plan("list")
[17:00:33.280]                   options(future.plan = NULL)
[17:00:33.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.280]                 }
[17:00:33.280]                 ...future.workdir <- getwd()
[17:00:33.280]             }
[17:00:33.280]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.280]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.280]         }
[17:00:33.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.280]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:33.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.280]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.280]             base::names(...future.oldOptions))
[17:00:33.280]     }
[17:00:33.280]     if (FALSE) {
[17:00:33.280]     }
[17:00:33.280]     else {
[17:00:33.280]         if (TRUE) {
[17:00:33.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.280]                 open = "w")
[17:00:33.280]         }
[17:00:33.280]         else {
[17:00:33.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.280]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.280]         }
[17:00:33.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.280]             base::sink(type = "output", split = FALSE)
[17:00:33.280]             base::close(...future.stdout)
[17:00:33.280]         }, add = TRUE)
[17:00:33.280]     }
[17:00:33.280]     ...future.frame <- base::sys.nframe()
[17:00:33.280]     ...future.conditions <- base::list()
[17:00:33.280]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.280]     if (FALSE) {
[17:00:33.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.280]     }
[17:00:33.280]     ...future.result <- base::tryCatch({
[17:00:33.280]         base::withCallingHandlers({
[17:00:33.280]             ...future.value <- base::withVisible(base::local({
[17:00:33.280]                 ...future.makeSendCondition <- base::local({
[17:00:33.280]                   sendCondition <- NULL
[17:00:33.280]                   function(frame = 1L) {
[17:00:33.280]                     if (is.function(sendCondition)) 
[17:00:33.280]                       return(sendCondition)
[17:00:33.280]                     ns <- getNamespace("parallel")
[17:00:33.280]                     if (exists("sendData", mode = "function", 
[17:00:33.280]                       envir = ns)) {
[17:00:33.280]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.280]                         envir = ns)
[17:00:33.280]                       envir <- sys.frame(frame)
[17:00:33.280]                       master <- NULL
[17:00:33.280]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.280]                         !identical(envir, emptyenv())) {
[17:00:33.280]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.280]                           inherits = FALSE)) {
[17:00:33.280]                           master <- get("master", mode = "list", 
[17:00:33.280]                             envir = envir, inherits = FALSE)
[17:00:33.280]                           if (inherits(master, c("SOCKnode", 
[17:00:33.280]                             "SOCK0node"))) {
[17:00:33.280]                             sendCondition <<- function(cond) {
[17:00:33.280]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.280]                                 success = TRUE)
[17:00:33.280]                               parallel_sendData(master, data)
[17:00:33.280]                             }
[17:00:33.280]                             return(sendCondition)
[17:00:33.280]                           }
[17:00:33.280]                         }
[17:00:33.280]                         frame <- frame + 1L
[17:00:33.280]                         envir <- sys.frame(frame)
[17:00:33.280]                       }
[17:00:33.280]                     }
[17:00:33.280]                     sendCondition <<- function(cond) NULL
[17:00:33.280]                   }
[17:00:33.280]                 })
[17:00:33.280]                 withCallingHandlers({
[17:00:33.280]                   {
[17:00:33.280]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.280]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.280]                       ...future.globals.maxSize)) {
[17:00:33.280]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.280]                       on.exit(options(oopts), add = TRUE)
[17:00:33.280]                     }
[17:00:33.280]                     {
[17:00:33.280]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.280]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.280]                         USE.NAMES = FALSE)
[17:00:33.280]                       do.call(mapply, args = args)
[17:00:33.280]                     }
[17:00:33.280]                   }
[17:00:33.280]                 }, immediateCondition = function(cond) {
[17:00:33.280]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.280]                   sendCondition(cond)
[17:00:33.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.280]                   {
[17:00:33.280]                     inherits <- base::inherits
[17:00:33.280]                     invokeRestart <- base::invokeRestart
[17:00:33.280]                     is.null <- base::is.null
[17:00:33.280]                     muffled <- FALSE
[17:00:33.280]                     if (inherits(cond, "message")) {
[17:00:33.280]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.280]                       if (muffled) 
[17:00:33.280]                         invokeRestart("muffleMessage")
[17:00:33.280]                     }
[17:00:33.280]                     else if (inherits(cond, "warning")) {
[17:00:33.280]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.280]                       if (muffled) 
[17:00:33.280]                         invokeRestart("muffleWarning")
[17:00:33.280]                     }
[17:00:33.280]                     else if (inherits(cond, "condition")) {
[17:00:33.280]                       if (!is.null(pattern)) {
[17:00:33.280]                         computeRestarts <- base::computeRestarts
[17:00:33.280]                         grepl <- base::grepl
[17:00:33.280]                         restarts <- computeRestarts(cond)
[17:00:33.280]                         for (restart in restarts) {
[17:00:33.280]                           name <- restart$name
[17:00:33.280]                           if (is.null(name)) 
[17:00:33.280]                             next
[17:00:33.280]                           if (!grepl(pattern, name)) 
[17:00:33.280]                             next
[17:00:33.280]                           invokeRestart(restart)
[17:00:33.280]                           muffled <- TRUE
[17:00:33.280]                           break
[17:00:33.280]                         }
[17:00:33.280]                       }
[17:00:33.280]                     }
[17:00:33.280]                     invisible(muffled)
[17:00:33.280]                   }
[17:00:33.280]                   muffleCondition(cond)
[17:00:33.280]                 })
[17:00:33.280]             }))
[17:00:33.280]             future::FutureResult(value = ...future.value$value, 
[17:00:33.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.280]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.280]                     ...future.globalenv.names))
[17:00:33.280]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.280]         }, condition = base::local({
[17:00:33.280]             c <- base::c
[17:00:33.280]             inherits <- base::inherits
[17:00:33.280]             invokeRestart <- base::invokeRestart
[17:00:33.280]             length <- base::length
[17:00:33.280]             list <- base::list
[17:00:33.280]             seq.int <- base::seq.int
[17:00:33.280]             signalCondition <- base::signalCondition
[17:00:33.280]             sys.calls <- base::sys.calls
[17:00:33.280]             `[[` <- base::`[[`
[17:00:33.280]             `+` <- base::`+`
[17:00:33.280]             `<<-` <- base::`<<-`
[17:00:33.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.280]                   3L)]
[17:00:33.280]             }
[17:00:33.280]             function(cond) {
[17:00:33.280]                 is_error <- inherits(cond, "error")
[17:00:33.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.280]                   NULL)
[17:00:33.280]                 if (is_error) {
[17:00:33.280]                   sessionInformation <- function() {
[17:00:33.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.280]                       search = base::search(), system = base::Sys.info())
[17:00:33.280]                   }
[17:00:33.280]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.280]                     cond$call), session = sessionInformation(), 
[17:00:33.280]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.280]                   signalCondition(cond)
[17:00:33.280]                 }
[17:00:33.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.280]                 "immediateCondition"))) {
[17:00:33.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.280]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.280]                   if (TRUE && !signal) {
[17:00:33.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.280]                     {
[17:00:33.280]                       inherits <- base::inherits
[17:00:33.280]                       invokeRestart <- base::invokeRestart
[17:00:33.280]                       is.null <- base::is.null
[17:00:33.280]                       muffled <- FALSE
[17:00:33.280]                       if (inherits(cond, "message")) {
[17:00:33.280]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.280]                         if (muffled) 
[17:00:33.280]                           invokeRestart("muffleMessage")
[17:00:33.280]                       }
[17:00:33.280]                       else if (inherits(cond, "warning")) {
[17:00:33.280]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.280]                         if (muffled) 
[17:00:33.280]                           invokeRestart("muffleWarning")
[17:00:33.280]                       }
[17:00:33.280]                       else if (inherits(cond, "condition")) {
[17:00:33.280]                         if (!is.null(pattern)) {
[17:00:33.280]                           computeRestarts <- base::computeRestarts
[17:00:33.280]                           grepl <- base::grepl
[17:00:33.280]                           restarts <- computeRestarts(cond)
[17:00:33.280]                           for (restart in restarts) {
[17:00:33.280]                             name <- restart$name
[17:00:33.280]                             if (is.null(name)) 
[17:00:33.280]                               next
[17:00:33.280]                             if (!grepl(pattern, name)) 
[17:00:33.280]                               next
[17:00:33.280]                             invokeRestart(restart)
[17:00:33.280]                             muffled <- TRUE
[17:00:33.280]                             break
[17:00:33.280]                           }
[17:00:33.280]                         }
[17:00:33.280]                       }
[17:00:33.280]                       invisible(muffled)
[17:00:33.280]                     }
[17:00:33.280]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.280]                   }
[17:00:33.280]                 }
[17:00:33.280]                 else {
[17:00:33.280]                   if (TRUE) {
[17:00:33.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.280]                     {
[17:00:33.280]                       inherits <- base::inherits
[17:00:33.280]                       invokeRestart <- base::invokeRestart
[17:00:33.280]                       is.null <- base::is.null
[17:00:33.280]                       muffled <- FALSE
[17:00:33.280]                       if (inherits(cond, "message")) {
[17:00:33.280]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.280]                         if (muffled) 
[17:00:33.280]                           invokeRestart("muffleMessage")
[17:00:33.280]                       }
[17:00:33.280]                       else if (inherits(cond, "warning")) {
[17:00:33.280]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.280]                         if (muffled) 
[17:00:33.280]                           invokeRestart("muffleWarning")
[17:00:33.280]                       }
[17:00:33.280]                       else if (inherits(cond, "condition")) {
[17:00:33.280]                         if (!is.null(pattern)) {
[17:00:33.280]                           computeRestarts <- base::computeRestarts
[17:00:33.280]                           grepl <- base::grepl
[17:00:33.280]                           restarts <- computeRestarts(cond)
[17:00:33.280]                           for (restart in restarts) {
[17:00:33.280]                             name <- restart$name
[17:00:33.280]                             if (is.null(name)) 
[17:00:33.280]                               next
[17:00:33.280]                             if (!grepl(pattern, name)) 
[17:00:33.280]                               next
[17:00:33.280]                             invokeRestart(restart)
[17:00:33.280]                             muffled <- TRUE
[17:00:33.280]                             break
[17:00:33.280]                           }
[17:00:33.280]                         }
[17:00:33.280]                       }
[17:00:33.280]                       invisible(muffled)
[17:00:33.280]                     }
[17:00:33.280]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.280]                   }
[17:00:33.280]                 }
[17:00:33.280]             }
[17:00:33.280]         }))
[17:00:33.280]     }, error = function(ex) {
[17:00:33.280]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.280]                 ...future.rng), started = ...future.startTime, 
[17:00:33.280]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.280]             version = "1.8"), class = "FutureResult")
[17:00:33.280]     }, finally = {
[17:00:33.280]         if (!identical(...future.workdir, getwd())) 
[17:00:33.280]             setwd(...future.workdir)
[17:00:33.280]         {
[17:00:33.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.280]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.280]             }
[17:00:33.280]             base::options(...future.oldOptions)
[17:00:33.280]             if (.Platform$OS.type == "windows") {
[17:00:33.280]                 old_names <- names(...future.oldEnvVars)
[17:00:33.280]                 envs <- base::Sys.getenv()
[17:00:33.280]                 names <- names(envs)
[17:00:33.280]                 common <- intersect(names, old_names)
[17:00:33.280]                 added <- setdiff(names, old_names)
[17:00:33.280]                 removed <- setdiff(old_names, names)
[17:00:33.280]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.280]                   envs[common]]
[17:00:33.280]                 NAMES <- toupper(changed)
[17:00:33.280]                 args <- list()
[17:00:33.280]                 for (kk in seq_along(NAMES)) {
[17:00:33.280]                   name <- changed[[kk]]
[17:00:33.280]                   NAME <- NAMES[[kk]]
[17:00:33.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.280]                     next
[17:00:33.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.280]                 }
[17:00:33.280]                 NAMES <- toupper(added)
[17:00:33.280]                 for (kk in seq_along(NAMES)) {
[17:00:33.280]                   name <- added[[kk]]
[17:00:33.280]                   NAME <- NAMES[[kk]]
[17:00:33.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.280]                     next
[17:00:33.280]                   args[[name]] <- ""
[17:00:33.280]                 }
[17:00:33.280]                 NAMES <- toupper(removed)
[17:00:33.280]                 for (kk in seq_along(NAMES)) {
[17:00:33.280]                   name <- removed[[kk]]
[17:00:33.280]                   NAME <- NAMES[[kk]]
[17:00:33.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.280]                     next
[17:00:33.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.280]                 }
[17:00:33.280]                 if (length(args) > 0) 
[17:00:33.280]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.280]             }
[17:00:33.280]             else {
[17:00:33.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.280]             }
[17:00:33.280]             {
[17:00:33.280]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.280]                   0L) {
[17:00:33.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.280]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.280]                   base::options(opts)
[17:00:33.280]                 }
[17:00:33.280]                 {
[17:00:33.280]                   {
[17:00:33.280]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.280]                     NULL
[17:00:33.280]                   }
[17:00:33.280]                   options(future.plan = NULL)
[17:00:33.280]                   if (is.na(NA_character_)) 
[17:00:33.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.280]                     .init = FALSE)
[17:00:33.280]                 }
[17:00:33.280]             }
[17:00:33.280]         }
[17:00:33.280]     })
[17:00:33.280]     if (TRUE) {
[17:00:33.280]         base::sink(type = "output", split = FALSE)
[17:00:33.280]         if (TRUE) {
[17:00:33.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.280]         }
[17:00:33.280]         else {
[17:00:33.280]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.280]         }
[17:00:33.280]         base::close(...future.stdout)
[17:00:33.280]         ...future.stdout <- NULL
[17:00:33.280]     }
[17:00:33.280]     ...future.result$conditions <- ...future.conditions
[17:00:33.280]     ...future.result$finished <- base::Sys.time()
[17:00:33.280]     ...future.result
[17:00:33.280] }
[17:00:33.283] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[17:00:33.283] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:00:33.283] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:00:33.283] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:33.283] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.284] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[17:00:33.284] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[17:00:33.284] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:33.284] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.284] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:33.285] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.285] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[17:00:33.285] MultisessionFuture started
[17:00:33.285] - Launch lazy future ... done
[17:00:33.285] run() for ‘MultisessionFuture’ ... done
[17:00:33.286] Created future:
[17:00:33.286] MultisessionFuture:
[17:00:33.286] Label: ‘future_mapply-1’
[17:00:33.286] Expression:
[17:00:33.286] {
[17:00:33.286]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.286]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.286]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.286]         on.exit(options(oopts), add = TRUE)
[17:00:33.286]     }
[17:00:33.286]     {
[17:00:33.286]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.286]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.286]         do.call(mapply, args = args)
[17:00:33.286]     }
[17:00:33.286] }
[17:00:33.286] Lazy evaluation: FALSE
[17:00:33.286] Asynchronous evaluation: TRUE
[17:00:33.286] Local evaluation: TRUE
[17:00:33.286] Environment: R_GlobalEnv
[17:00:33.286] Capture standard output: TRUE
[17:00:33.286] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.286] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.286] Packages: <none>
[17:00:33.286] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.286] Resolved: FALSE
[17:00:33.286] Value: <not collected>
[17:00:33.286] Conditions captured: <none>
[17:00:33.286] Early signaling: FALSE
[17:00:33.286] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.286] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.297] Chunk #1 of 5 ... DONE
[17:00:33.297] Chunk #2 of 5 ...
[17:00:33.297]  - Finding globals in '...' for chunk #2 ...
[17:00:33.298] getGlobalsAndPackages() ...
[17:00:33.298] Searching for globals...
[17:00:33.298] 
[17:00:33.298] Searching for globals ... DONE
[17:00:33.298] - globals: [0] <none>
[17:00:33.298] getGlobalsAndPackages() ... DONE
[17:00:33.298]    + additional globals found: [n=0] 
[17:00:33.299]    + additional namespaces needed: [n=0] 
[17:00:33.299]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:33.299]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:33.299]  - seeds: <none>
[17:00:33.299]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.299] getGlobalsAndPackages() ...
[17:00:33.299] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.299] Resolving globals: FALSE
[17:00:33.300] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:33.300] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.300] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.300] 
[17:00:33.300] getGlobalsAndPackages() ... DONE
[17:00:33.301] run() for ‘Future’ ...
[17:00:33.301] - state: ‘created’
[17:00:33.301] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.315] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.315]   - Field: ‘node’
[17:00:33.315]   - Field: ‘label’
[17:00:33.315]   - Field: ‘local’
[17:00:33.316]   - Field: ‘owner’
[17:00:33.316]   - Field: ‘envir’
[17:00:33.316]   - Field: ‘workers’
[17:00:33.316]   - Field: ‘packages’
[17:00:33.316]   - Field: ‘gc’
[17:00:33.316]   - Field: ‘conditions’
[17:00:33.316]   - Field: ‘persistent’
[17:00:33.316]   - Field: ‘expr’
[17:00:33.316]   - Field: ‘uuid’
[17:00:33.316]   - Field: ‘seed’
[17:00:33.316]   - Field: ‘version’
[17:00:33.317]   - Field: ‘result’
[17:00:33.317]   - Field: ‘asynchronous’
[17:00:33.317]   - Field: ‘calls’
[17:00:33.317]   - Field: ‘globals’
[17:00:33.317]   - Field: ‘stdout’
[17:00:33.317]   - Field: ‘earlySignal’
[17:00:33.317]   - Field: ‘lazy’
[17:00:33.317]   - Field: ‘state’
[17:00:33.317] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.317] - Launch lazy future ...
[17:00:33.318] Packages needed by the future expression (n = 0): <none>
[17:00:33.318] Packages needed by future strategies (n = 0): <none>
[17:00:33.318] {
[17:00:33.318]     {
[17:00:33.318]         {
[17:00:33.318]             ...future.startTime <- base::Sys.time()
[17:00:33.318]             {
[17:00:33.318]                 {
[17:00:33.318]                   {
[17:00:33.318]                     {
[17:00:33.318]                       base::local({
[17:00:33.318]                         has_future <- base::requireNamespace("future", 
[17:00:33.318]                           quietly = TRUE)
[17:00:33.318]                         if (has_future) {
[17:00:33.318]                           ns <- base::getNamespace("future")
[17:00:33.318]                           version <- ns[[".package"]][["version"]]
[17:00:33.318]                           if (is.null(version)) 
[17:00:33.318]                             version <- utils::packageVersion("future")
[17:00:33.318]                         }
[17:00:33.318]                         else {
[17:00:33.318]                           version <- NULL
[17:00:33.318]                         }
[17:00:33.318]                         if (!has_future || version < "1.8.0") {
[17:00:33.318]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.318]                             "", base::R.version$version.string), 
[17:00:33.318]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.318]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.318]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.318]                               "release", "version")], collapse = " "), 
[17:00:33.318]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.318]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.318]                             info)
[17:00:33.318]                           info <- base::paste(info, collapse = "; ")
[17:00:33.318]                           if (!has_future) {
[17:00:33.318]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.318]                               info)
[17:00:33.318]                           }
[17:00:33.318]                           else {
[17:00:33.318]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.318]                               info, version)
[17:00:33.318]                           }
[17:00:33.318]                           base::stop(msg)
[17:00:33.318]                         }
[17:00:33.318]                       })
[17:00:33.318]                     }
[17:00:33.318]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.318]                     base::options(mc.cores = 1L)
[17:00:33.318]                   }
[17:00:33.318]                   ...future.strategy.old <- future::plan("list")
[17:00:33.318]                   options(future.plan = NULL)
[17:00:33.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.318]                 }
[17:00:33.318]                 ...future.workdir <- getwd()
[17:00:33.318]             }
[17:00:33.318]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.318]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.318]         }
[17:00:33.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.318]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:33.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.318]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.318]             base::names(...future.oldOptions))
[17:00:33.318]     }
[17:00:33.318]     if (FALSE) {
[17:00:33.318]     }
[17:00:33.318]     else {
[17:00:33.318]         if (TRUE) {
[17:00:33.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.318]                 open = "w")
[17:00:33.318]         }
[17:00:33.318]         else {
[17:00:33.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.318]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.318]         }
[17:00:33.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.318]             base::sink(type = "output", split = FALSE)
[17:00:33.318]             base::close(...future.stdout)
[17:00:33.318]         }, add = TRUE)
[17:00:33.318]     }
[17:00:33.318]     ...future.frame <- base::sys.nframe()
[17:00:33.318]     ...future.conditions <- base::list()
[17:00:33.318]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.318]     if (FALSE) {
[17:00:33.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.318]     }
[17:00:33.318]     ...future.result <- base::tryCatch({
[17:00:33.318]         base::withCallingHandlers({
[17:00:33.318]             ...future.value <- base::withVisible(base::local({
[17:00:33.318]                 ...future.makeSendCondition <- base::local({
[17:00:33.318]                   sendCondition <- NULL
[17:00:33.318]                   function(frame = 1L) {
[17:00:33.318]                     if (is.function(sendCondition)) 
[17:00:33.318]                       return(sendCondition)
[17:00:33.318]                     ns <- getNamespace("parallel")
[17:00:33.318]                     if (exists("sendData", mode = "function", 
[17:00:33.318]                       envir = ns)) {
[17:00:33.318]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.318]                         envir = ns)
[17:00:33.318]                       envir <- sys.frame(frame)
[17:00:33.318]                       master <- NULL
[17:00:33.318]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.318]                         !identical(envir, emptyenv())) {
[17:00:33.318]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.318]                           inherits = FALSE)) {
[17:00:33.318]                           master <- get("master", mode = "list", 
[17:00:33.318]                             envir = envir, inherits = FALSE)
[17:00:33.318]                           if (inherits(master, c("SOCKnode", 
[17:00:33.318]                             "SOCK0node"))) {
[17:00:33.318]                             sendCondition <<- function(cond) {
[17:00:33.318]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.318]                                 success = TRUE)
[17:00:33.318]                               parallel_sendData(master, data)
[17:00:33.318]                             }
[17:00:33.318]                             return(sendCondition)
[17:00:33.318]                           }
[17:00:33.318]                         }
[17:00:33.318]                         frame <- frame + 1L
[17:00:33.318]                         envir <- sys.frame(frame)
[17:00:33.318]                       }
[17:00:33.318]                     }
[17:00:33.318]                     sendCondition <<- function(cond) NULL
[17:00:33.318]                   }
[17:00:33.318]                 })
[17:00:33.318]                 withCallingHandlers({
[17:00:33.318]                   {
[17:00:33.318]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.318]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.318]                       ...future.globals.maxSize)) {
[17:00:33.318]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.318]                       on.exit(options(oopts), add = TRUE)
[17:00:33.318]                     }
[17:00:33.318]                     {
[17:00:33.318]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.318]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.318]                         USE.NAMES = FALSE)
[17:00:33.318]                       do.call(mapply, args = args)
[17:00:33.318]                     }
[17:00:33.318]                   }
[17:00:33.318]                 }, immediateCondition = function(cond) {
[17:00:33.318]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.318]                   sendCondition(cond)
[17:00:33.318]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.318]                   {
[17:00:33.318]                     inherits <- base::inherits
[17:00:33.318]                     invokeRestart <- base::invokeRestart
[17:00:33.318]                     is.null <- base::is.null
[17:00:33.318]                     muffled <- FALSE
[17:00:33.318]                     if (inherits(cond, "message")) {
[17:00:33.318]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.318]                       if (muffled) 
[17:00:33.318]                         invokeRestart("muffleMessage")
[17:00:33.318]                     }
[17:00:33.318]                     else if (inherits(cond, "warning")) {
[17:00:33.318]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.318]                       if (muffled) 
[17:00:33.318]                         invokeRestart("muffleWarning")
[17:00:33.318]                     }
[17:00:33.318]                     else if (inherits(cond, "condition")) {
[17:00:33.318]                       if (!is.null(pattern)) {
[17:00:33.318]                         computeRestarts <- base::computeRestarts
[17:00:33.318]                         grepl <- base::grepl
[17:00:33.318]                         restarts <- computeRestarts(cond)
[17:00:33.318]                         for (restart in restarts) {
[17:00:33.318]                           name <- restart$name
[17:00:33.318]                           if (is.null(name)) 
[17:00:33.318]                             next
[17:00:33.318]                           if (!grepl(pattern, name)) 
[17:00:33.318]                             next
[17:00:33.318]                           invokeRestart(restart)
[17:00:33.318]                           muffled <- TRUE
[17:00:33.318]                           break
[17:00:33.318]                         }
[17:00:33.318]                       }
[17:00:33.318]                     }
[17:00:33.318]                     invisible(muffled)
[17:00:33.318]                   }
[17:00:33.318]                   muffleCondition(cond)
[17:00:33.318]                 })
[17:00:33.318]             }))
[17:00:33.318]             future::FutureResult(value = ...future.value$value, 
[17:00:33.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.318]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.318]                     ...future.globalenv.names))
[17:00:33.318]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.318]         }, condition = base::local({
[17:00:33.318]             c <- base::c
[17:00:33.318]             inherits <- base::inherits
[17:00:33.318]             invokeRestart <- base::invokeRestart
[17:00:33.318]             length <- base::length
[17:00:33.318]             list <- base::list
[17:00:33.318]             seq.int <- base::seq.int
[17:00:33.318]             signalCondition <- base::signalCondition
[17:00:33.318]             sys.calls <- base::sys.calls
[17:00:33.318]             `[[` <- base::`[[`
[17:00:33.318]             `+` <- base::`+`
[17:00:33.318]             `<<-` <- base::`<<-`
[17:00:33.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.318]                   3L)]
[17:00:33.318]             }
[17:00:33.318]             function(cond) {
[17:00:33.318]                 is_error <- inherits(cond, "error")
[17:00:33.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.318]                   NULL)
[17:00:33.318]                 if (is_error) {
[17:00:33.318]                   sessionInformation <- function() {
[17:00:33.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.318]                       search = base::search(), system = base::Sys.info())
[17:00:33.318]                   }
[17:00:33.318]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.318]                     cond$call), session = sessionInformation(), 
[17:00:33.318]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.318]                   signalCondition(cond)
[17:00:33.318]                 }
[17:00:33.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.318]                 "immediateCondition"))) {
[17:00:33.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.318]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.318]                   if (TRUE && !signal) {
[17:00:33.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.318]                     {
[17:00:33.318]                       inherits <- base::inherits
[17:00:33.318]                       invokeRestart <- base::invokeRestart
[17:00:33.318]                       is.null <- base::is.null
[17:00:33.318]                       muffled <- FALSE
[17:00:33.318]                       if (inherits(cond, "message")) {
[17:00:33.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.318]                         if (muffled) 
[17:00:33.318]                           invokeRestart("muffleMessage")
[17:00:33.318]                       }
[17:00:33.318]                       else if (inherits(cond, "warning")) {
[17:00:33.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.318]                         if (muffled) 
[17:00:33.318]                           invokeRestart("muffleWarning")
[17:00:33.318]                       }
[17:00:33.318]                       else if (inherits(cond, "condition")) {
[17:00:33.318]                         if (!is.null(pattern)) {
[17:00:33.318]                           computeRestarts <- base::computeRestarts
[17:00:33.318]                           grepl <- base::grepl
[17:00:33.318]                           restarts <- computeRestarts(cond)
[17:00:33.318]                           for (restart in restarts) {
[17:00:33.318]                             name <- restart$name
[17:00:33.318]                             if (is.null(name)) 
[17:00:33.318]                               next
[17:00:33.318]                             if (!grepl(pattern, name)) 
[17:00:33.318]                               next
[17:00:33.318]                             invokeRestart(restart)
[17:00:33.318]                             muffled <- TRUE
[17:00:33.318]                             break
[17:00:33.318]                           }
[17:00:33.318]                         }
[17:00:33.318]                       }
[17:00:33.318]                       invisible(muffled)
[17:00:33.318]                     }
[17:00:33.318]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.318]                   }
[17:00:33.318]                 }
[17:00:33.318]                 else {
[17:00:33.318]                   if (TRUE) {
[17:00:33.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.318]                     {
[17:00:33.318]                       inherits <- base::inherits
[17:00:33.318]                       invokeRestart <- base::invokeRestart
[17:00:33.318]                       is.null <- base::is.null
[17:00:33.318]                       muffled <- FALSE
[17:00:33.318]                       if (inherits(cond, "message")) {
[17:00:33.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.318]                         if (muffled) 
[17:00:33.318]                           invokeRestart("muffleMessage")
[17:00:33.318]                       }
[17:00:33.318]                       else if (inherits(cond, "warning")) {
[17:00:33.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.318]                         if (muffled) 
[17:00:33.318]                           invokeRestart("muffleWarning")
[17:00:33.318]                       }
[17:00:33.318]                       else if (inherits(cond, "condition")) {
[17:00:33.318]                         if (!is.null(pattern)) {
[17:00:33.318]                           computeRestarts <- base::computeRestarts
[17:00:33.318]                           grepl <- base::grepl
[17:00:33.318]                           restarts <- computeRestarts(cond)
[17:00:33.318]                           for (restart in restarts) {
[17:00:33.318]                             name <- restart$name
[17:00:33.318]                             if (is.null(name)) 
[17:00:33.318]                               next
[17:00:33.318]                             if (!grepl(pattern, name)) 
[17:00:33.318]                               next
[17:00:33.318]                             invokeRestart(restart)
[17:00:33.318]                             muffled <- TRUE
[17:00:33.318]                             break
[17:00:33.318]                           }
[17:00:33.318]                         }
[17:00:33.318]                       }
[17:00:33.318]                       invisible(muffled)
[17:00:33.318]                     }
[17:00:33.318]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.318]                   }
[17:00:33.318]                 }
[17:00:33.318]             }
[17:00:33.318]         }))
[17:00:33.318]     }, error = function(ex) {
[17:00:33.318]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.318]                 ...future.rng), started = ...future.startTime, 
[17:00:33.318]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.318]             version = "1.8"), class = "FutureResult")
[17:00:33.318]     }, finally = {
[17:00:33.318]         if (!identical(...future.workdir, getwd())) 
[17:00:33.318]             setwd(...future.workdir)
[17:00:33.318]         {
[17:00:33.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.318]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.318]             }
[17:00:33.318]             base::options(...future.oldOptions)
[17:00:33.318]             if (.Platform$OS.type == "windows") {
[17:00:33.318]                 old_names <- names(...future.oldEnvVars)
[17:00:33.318]                 envs <- base::Sys.getenv()
[17:00:33.318]                 names <- names(envs)
[17:00:33.318]                 common <- intersect(names, old_names)
[17:00:33.318]                 added <- setdiff(names, old_names)
[17:00:33.318]                 removed <- setdiff(old_names, names)
[17:00:33.318]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.318]                   envs[common]]
[17:00:33.318]                 NAMES <- toupper(changed)
[17:00:33.318]                 args <- list()
[17:00:33.318]                 for (kk in seq_along(NAMES)) {
[17:00:33.318]                   name <- changed[[kk]]
[17:00:33.318]                   NAME <- NAMES[[kk]]
[17:00:33.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.318]                     next
[17:00:33.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.318]                 }
[17:00:33.318]                 NAMES <- toupper(added)
[17:00:33.318]                 for (kk in seq_along(NAMES)) {
[17:00:33.318]                   name <- added[[kk]]
[17:00:33.318]                   NAME <- NAMES[[kk]]
[17:00:33.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.318]                     next
[17:00:33.318]                   args[[name]] <- ""
[17:00:33.318]                 }
[17:00:33.318]                 NAMES <- toupper(removed)
[17:00:33.318]                 for (kk in seq_along(NAMES)) {
[17:00:33.318]                   name <- removed[[kk]]
[17:00:33.318]                   NAME <- NAMES[[kk]]
[17:00:33.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.318]                     next
[17:00:33.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.318]                 }
[17:00:33.318]                 if (length(args) > 0) 
[17:00:33.318]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.318]             }
[17:00:33.318]             else {
[17:00:33.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.318]             }
[17:00:33.318]             {
[17:00:33.318]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.318]                   0L) {
[17:00:33.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.318]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.318]                   base::options(opts)
[17:00:33.318]                 }
[17:00:33.318]                 {
[17:00:33.318]                   {
[17:00:33.318]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.318]                     NULL
[17:00:33.318]                   }
[17:00:33.318]                   options(future.plan = NULL)
[17:00:33.318]                   if (is.na(NA_character_)) 
[17:00:33.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.318]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.318]                     .init = FALSE)
[17:00:33.318]                 }
[17:00:33.318]             }
[17:00:33.318]         }
[17:00:33.318]     })
[17:00:33.318]     if (TRUE) {
[17:00:33.318]         base::sink(type = "output", split = FALSE)
[17:00:33.318]         if (TRUE) {
[17:00:33.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.318]         }
[17:00:33.318]         else {
[17:00:33.318]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.318]         }
[17:00:33.318]         base::close(...future.stdout)
[17:00:33.318]         ...future.stdout <- NULL
[17:00:33.318]     }
[17:00:33.318]     ...future.result$conditions <- ...future.conditions
[17:00:33.318]     ...future.result$finished <- base::Sys.time()
[17:00:33.318]     ...future.result
[17:00:33.318] }
[17:00:33.321] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[17:00:33.321] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:00:33.321] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:00:33.322] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:33.322] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.322] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[17:00:33.322] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[17:00:33.322] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:33.323] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.323] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:33.323] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.323] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[17:00:33.324] MultisessionFuture started
[17:00:33.324] - Launch lazy future ... done
[17:00:33.324] run() for ‘MultisessionFuture’ ... done
[17:00:33.324] Created future:
[17:00:33.324] MultisessionFuture:
[17:00:33.324] Label: ‘future_mapply-2’
[17:00:33.324] Expression:
[17:00:33.324] {
[17:00:33.324]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.324]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.324]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.324]         on.exit(options(oopts), add = TRUE)
[17:00:33.324]     }
[17:00:33.324]     {
[17:00:33.324]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.324]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.324]         do.call(mapply, args = args)
[17:00:33.324]     }
[17:00:33.324] }
[17:00:33.324] Lazy evaluation: FALSE
[17:00:33.324] Asynchronous evaluation: TRUE
[17:00:33.324] Local evaluation: TRUE
[17:00:33.324] Environment: R_GlobalEnv
[17:00:33.324] Capture standard output: TRUE
[17:00:33.324] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.324] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.324] Packages: <none>
[17:00:33.324] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.324] Resolved: FALSE
[17:00:33.324] Value: <not collected>
[17:00:33.324] Conditions captured: <none>
[17:00:33.324] Early signaling: FALSE
[17:00:33.324] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.324] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.336] Chunk #2 of 5 ... DONE
[17:00:33.336] Chunk #3 of 5 ...
[17:00:33.336]  - Finding globals in '...' for chunk #3 ...
[17:00:33.336] getGlobalsAndPackages() ...
[17:00:33.336] Searching for globals...
[17:00:33.337] 
[17:00:33.337] Searching for globals ... DONE
[17:00:33.337] - globals: [0] <none>
[17:00:33.337] getGlobalsAndPackages() ... DONE
[17:00:33.337]    + additional globals found: [n=0] 
[17:00:33.337]    + additional namespaces needed: [n=0] 
[17:00:33.337]  - Finding globals in '...' for chunk #3 ... DONE
[17:00:33.337]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:33.337]  - seeds: <none>
[17:00:33.337]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.337] getGlobalsAndPackages() ...
[17:00:33.338] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.338] Resolving globals: FALSE
[17:00:33.338] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:33.339] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.339] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.339] 
[17:00:33.339] getGlobalsAndPackages() ... DONE
[17:00:33.339] run() for ‘Future’ ...
[17:00:33.339] - state: ‘created’
[17:00:33.339] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.354] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.354]   - Field: ‘node’
[17:00:33.354]   - Field: ‘label’
[17:00:33.354]   - Field: ‘local’
[17:00:33.354]   - Field: ‘owner’
[17:00:33.354]   - Field: ‘envir’
[17:00:33.354]   - Field: ‘workers’
[17:00:33.355]   - Field: ‘packages’
[17:00:33.355]   - Field: ‘gc’
[17:00:33.355]   - Field: ‘conditions’
[17:00:33.355]   - Field: ‘persistent’
[17:00:33.355]   - Field: ‘expr’
[17:00:33.355]   - Field: ‘uuid’
[17:00:33.355]   - Field: ‘seed’
[17:00:33.355]   - Field: ‘version’
[17:00:33.355]   - Field: ‘result’
[17:00:33.355]   - Field: ‘asynchronous’
[17:00:33.355]   - Field: ‘calls’
[17:00:33.356]   - Field: ‘globals’
[17:00:33.356]   - Field: ‘stdout’
[17:00:33.356]   - Field: ‘earlySignal’
[17:00:33.356]   - Field: ‘lazy’
[17:00:33.356]   - Field: ‘state’
[17:00:33.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.356] - Launch lazy future ...
[17:00:33.356] Packages needed by the future expression (n = 0): <none>
[17:00:33.357] Packages needed by future strategies (n = 0): <none>
[17:00:33.357] {
[17:00:33.357]     {
[17:00:33.357]         {
[17:00:33.357]             ...future.startTime <- base::Sys.time()
[17:00:33.357]             {
[17:00:33.357]                 {
[17:00:33.357]                   {
[17:00:33.357]                     {
[17:00:33.357]                       base::local({
[17:00:33.357]                         has_future <- base::requireNamespace("future", 
[17:00:33.357]                           quietly = TRUE)
[17:00:33.357]                         if (has_future) {
[17:00:33.357]                           ns <- base::getNamespace("future")
[17:00:33.357]                           version <- ns[[".package"]][["version"]]
[17:00:33.357]                           if (is.null(version)) 
[17:00:33.357]                             version <- utils::packageVersion("future")
[17:00:33.357]                         }
[17:00:33.357]                         else {
[17:00:33.357]                           version <- NULL
[17:00:33.357]                         }
[17:00:33.357]                         if (!has_future || version < "1.8.0") {
[17:00:33.357]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.357]                             "", base::R.version$version.string), 
[17:00:33.357]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.357]                               "release", "version")], collapse = " "), 
[17:00:33.357]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.357]                             info)
[17:00:33.357]                           info <- base::paste(info, collapse = "; ")
[17:00:33.357]                           if (!has_future) {
[17:00:33.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.357]                               info)
[17:00:33.357]                           }
[17:00:33.357]                           else {
[17:00:33.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.357]                               info, version)
[17:00:33.357]                           }
[17:00:33.357]                           base::stop(msg)
[17:00:33.357]                         }
[17:00:33.357]                       })
[17:00:33.357]                     }
[17:00:33.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.357]                     base::options(mc.cores = 1L)
[17:00:33.357]                   }
[17:00:33.357]                   ...future.strategy.old <- future::plan("list")
[17:00:33.357]                   options(future.plan = NULL)
[17:00:33.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.357]                 }
[17:00:33.357]                 ...future.workdir <- getwd()
[17:00:33.357]             }
[17:00:33.357]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.357]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.357]         }
[17:00:33.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.357]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:33.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.357]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.357]             base::names(...future.oldOptions))
[17:00:33.357]     }
[17:00:33.357]     if (FALSE) {
[17:00:33.357]     }
[17:00:33.357]     else {
[17:00:33.357]         if (TRUE) {
[17:00:33.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.357]                 open = "w")
[17:00:33.357]         }
[17:00:33.357]         else {
[17:00:33.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.357]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.357]         }
[17:00:33.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.357]             base::sink(type = "output", split = FALSE)
[17:00:33.357]             base::close(...future.stdout)
[17:00:33.357]         }, add = TRUE)
[17:00:33.357]     }
[17:00:33.357]     ...future.frame <- base::sys.nframe()
[17:00:33.357]     ...future.conditions <- base::list()
[17:00:33.357]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.357]     if (FALSE) {
[17:00:33.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.357]     }
[17:00:33.357]     ...future.result <- base::tryCatch({
[17:00:33.357]         base::withCallingHandlers({
[17:00:33.357]             ...future.value <- base::withVisible(base::local({
[17:00:33.357]                 ...future.makeSendCondition <- base::local({
[17:00:33.357]                   sendCondition <- NULL
[17:00:33.357]                   function(frame = 1L) {
[17:00:33.357]                     if (is.function(sendCondition)) 
[17:00:33.357]                       return(sendCondition)
[17:00:33.357]                     ns <- getNamespace("parallel")
[17:00:33.357]                     if (exists("sendData", mode = "function", 
[17:00:33.357]                       envir = ns)) {
[17:00:33.357]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.357]                         envir = ns)
[17:00:33.357]                       envir <- sys.frame(frame)
[17:00:33.357]                       master <- NULL
[17:00:33.357]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.357]                         !identical(envir, emptyenv())) {
[17:00:33.357]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.357]                           inherits = FALSE)) {
[17:00:33.357]                           master <- get("master", mode = "list", 
[17:00:33.357]                             envir = envir, inherits = FALSE)
[17:00:33.357]                           if (inherits(master, c("SOCKnode", 
[17:00:33.357]                             "SOCK0node"))) {
[17:00:33.357]                             sendCondition <<- function(cond) {
[17:00:33.357]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.357]                                 success = TRUE)
[17:00:33.357]                               parallel_sendData(master, data)
[17:00:33.357]                             }
[17:00:33.357]                             return(sendCondition)
[17:00:33.357]                           }
[17:00:33.357]                         }
[17:00:33.357]                         frame <- frame + 1L
[17:00:33.357]                         envir <- sys.frame(frame)
[17:00:33.357]                       }
[17:00:33.357]                     }
[17:00:33.357]                     sendCondition <<- function(cond) NULL
[17:00:33.357]                   }
[17:00:33.357]                 })
[17:00:33.357]                 withCallingHandlers({
[17:00:33.357]                   {
[17:00:33.357]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.357]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.357]                       ...future.globals.maxSize)) {
[17:00:33.357]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.357]                       on.exit(options(oopts), add = TRUE)
[17:00:33.357]                     }
[17:00:33.357]                     {
[17:00:33.357]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.357]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.357]                         USE.NAMES = FALSE)
[17:00:33.357]                       do.call(mapply, args = args)
[17:00:33.357]                     }
[17:00:33.357]                   }
[17:00:33.357]                 }, immediateCondition = function(cond) {
[17:00:33.357]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.357]                   sendCondition(cond)
[17:00:33.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.357]                   {
[17:00:33.357]                     inherits <- base::inherits
[17:00:33.357]                     invokeRestart <- base::invokeRestart
[17:00:33.357]                     is.null <- base::is.null
[17:00:33.357]                     muffled <- FALSE
[17:00:33.357]                     if (inherits(cond, "message")) {
[17:00:33.357]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.357]                       if (muffled) 
[17:00:33.357]                         invokeRestart("muffleMessage")
[17:00:33.357]                     }
[17:00:33.357]                     else if (inherits(cond, "warning")) {
[17:00:33.357]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.357]                       if (muffled) 
[17:00:33.357]                         invokeRestart("muffleWarning")
[17:00:33.357]                     }
[17:00:33.357]                     else if (inherits(cond, "condition")) {
[17:00:33.357]                       if (!is.null(pattern)) {
[17:00:33.357]                         computeRestarts <- base::computeRestarts
[17:00:33.357]                         grepl <- base::grepl
[17:00:33.357]                         restarts <- computeRestarts(cond)
[17:00:33.357]                         for (restart in restarts) {
[17:00:33.357]                           name <- restart$name
[17:00:33.357]                           if (is.null(name)) 
[17:00:33.357]                             next
[17:00:33.357]                           if (!grepl(pattern, name)) 
[17:00:33.357]                             next
[17:00:33.357]                           invokeRestart(restart)
[17:00:33.357]                           muffled <- TRUE
[17:00:33.357]                           break
[17:00:33.357]                         }
[17:00:33.357]                       }
[17:00:33.357]                     }
[17:00:33.357]                     invisible(muffled)
[17:00:33.357]                   }
[17:00:33.357]                   muffleCondition(cond)
[17:00:33.357]                 })
[17:00:33.357]             }))
[17:00:33.357]             future::FutureResult(value = ...future.value$value, 
[17:00:33.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.357]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.357]                     ...future.globalenv.names))
[17:00:33.357]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.357]         }, condition = base::local({
[17:00:33.357]             c <- base::c
[17:00:33.357]             inherits <- base::inherits
[17:00:33.357]             invokeRestart <- base::invokeRestart
[17:00:33.357]             length <- base::length
[17:00:33.357]             list <- base::list
[17:00:33.357]             seq.int <- base::seq.int
[17:00:33.357]             signalCondition <- base::signalCondition
[17:00:33.357]             sys.calls <- base::sys.calls
[17:00:33.357]             `[[` <- base::`[[`
[17:00:33.357]             `+` <- base::`+`
[17:00:33.357]             `<<-` <- base::`<<-`
[17:00:33.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.357]                   3L)]
[17:00:33.357]             }
[17:00:33.357]             function(cond) {
[17:00:33.357]                 is_error <- inherits(cond, "error")
[17:00:33.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.357]                   NULL)
[17:00:33.357]                 if (is_error) {
[17:00:33.357]                   sessionInformation <- function() {
[17:00:33.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.357]                       search = base::search(), system = base::Sys.info())
[17:00:33.357]                   }
[17:00:33.357]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.357]                     cond$call), session = sessionInformation(), 
[17:00:33.357]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.357]                   signalCondition(cond)
[17:00:33.357]                 }
[17:00:33.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.357]                 "immediateCondition"))) {
[17:00:33.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.357]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.357]                   if (TRUE && !signal) {
[17:00:33.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.357]                     {
[17:00:33.357]                       inherits <- base::inherits
[17:00:33.357]                       invokeRestart <- base::invokeRestart
[17:00:33.357]                       is.null <- base::is.null
[17:00:33.357]                       muffled <- FALSE
[17:00:33.357]                       if (inherits(cond, "message")) {
[17:00:33.357]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.357]                         if (muffled) 
[17:00:33.357]                           invokeRestart("muffleMessage")
[17:00:33.357]                       }
[17:00:33.357]                       else if (inherits(cond, "warning")) {
[17:00:33.357]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.357]                         if (muffled) 
[17:00:33.357]                           invokeRestart("muffleWarning")
[17:00:33.357]                       }
[17:00:33.357]                       else if (inherits(cond, "condition")) {
[17:00:33.357]                         if (!is.null(pattern)) {
[17:00:33.357]                           computeRestarts <- base::computeRestarts
[17:00:33.357]                           grepl <- base::grepl
[17:00:33.357]                           restarts <- computeRestarts(cond)
[17:00:33.357]                           for (restart in restarts) {
[17:00:33.357]                             name <- restart$name
[17:00:33.357]                             if (is.null(name)) 
[17:00:33.357]                               next
[17:00:33.357]                             if (!grepl(pattern, name)) 
[17:00:33.357]                               next
[17:00:33.357]                             invokeRestart(restart)
[17:00:33.357]                             muffled <- TRUE
[17:00:33.357]                             break
[17:00:33.357]                           }
[17:00:33.357]                         }
[17:00:33.357]                       }
[17:00:33.357]                       invisible(muffled)
[17:00:33.357]                     }
[17:00:33.357]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.357]                   }
[17:00:33.357]                 }
[17:00:33.357]                 else {
[17:00:33.357]                   if (TRUE) {
[17:00:33.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.357]                     {
[17:00:33.357]                       inherits <- base::inherits
[17:00:33.357]                       invokeRestart <- base::invokeRestart
[17:00:33.357]                       is.null <- base::is.null
[17:00:33.357]                       muffled <- FALSE
[17:00:33.357]                       if (inherits(cond, "message")) {
[17:00:33.357]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.357]                         if (muffled) 
[17:00:33.357]                           invokeRestart("muffleMessage")
[17:00:33.357]                       }
[17:00:33.357]                       else if (inherits(cond, "warning")) {
[17:00:33.357]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.357]                         if (muffled) 
[17:00:33.357]                           invokeRestart("muffleWarning")
[17:00:33.357]                       }
[17:00:33.357]                       else if (inherits(cond, "condition")) {
[17:00:33.357]                         if (!is.null(pattern)) {
[17:00:33.357]                           computeRestarts <- base::computeRestarts
[17:00:33.357]                           grepl <- base::grepl
[17:00:33.357]                           restarts <- computeRestarts(cond)
[17:00:33.357]                           for (restart in restarts) {
[17:00:33.357]                             name <- restart$name
[17:00:33.357]                             if (is.null(name)) 
[17:00:33.357]                               next
[17:00:33.357]                             if (!grepl(pattern, name)) 
[17:00:33.357]                               next
[17:00:33.357]                             invokeRestart(restart)
[17:00:33.357]                             muffled <- TRUE
[17:00:33.357]                             break
[17:00:33.357]                           }
[17:00:33.357]                         }
[17:00:33.357]                       }
[17:00:33.357]                       invisible(muffled)
[17:00:33.357]                     }
[17:00:33.357]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.357]                   }
[17:00:33.357]                 }
[17:00:33.357]             }
[17:00:33.357]         }))
[17:00:33.357]     }, error = function(ex) {
[17:00:33.357]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.357]                 ...future.rng), started = ...future.startTime, 
[17:00:33.357]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.357]             version = "1.8"), class = "FutureResult")
[17:00:33.357]     }, finally = {
[17:00:33.357]         if (!identical(...future.workdir, getwd())) 
[17:00:33.357]             setwd(...future.workdir)
[17:00:33.357]         {
[17:00:33.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.357]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.357]             }
[17:00:33.357]             base::options(...future.oldOptions)
[17:00:33.357]             if (.Platform$OS.type == "windows") {
[17:00:33.357]                 old_names <- names(...future.oldEnvVars)
[17:00:33.357]                 envs <- base::Sys.getenv()
[17:00:33.357]                 names <- names(envs)
[17:00:33.357]                 common <- intersect(names, old_names)
[17:00:33.357]                 added <- setdiff(names, old_names)
[17:00:33.357]                 removed <- setdiff(old_names, names)
[17:00:33.357]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.357]                   envs[common]]
[17:00:33.357]                 NAMES <- toupper(changed)
[17:00:33.357]                 args <- list()
[17:00:33.357]                 for (kk in seq_along(NAMES)) {
[17:00:33.357]                   name <- changed[[kk]]
[17:00:33.357]                   NAME <- NAMES[[kk]]
[17:00:33.357]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.357]                     next
[17:00:33.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.357]                 }
[17:00:33.357]                 NAMES <- toupper(added)
[17:00:33.357]                 for (kk in seq_along(NAMES)) {
[17:00:33.357]                   name <- added[[kk]]
[17:00:33.357]                   NAME <- NAMES[[kk]]
[17:00:33.357]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.357]                     next
[17:00:33.357]                   args[[name]] <- ""
[17:00:33.357]                 }
[17:00:33.357]                 NAMES <- toupper(removed)
[17:00:33.357]                 for (kk in seq_along(NAMES)) {
[17:00:33.357]                   name <- removed[[kk]]
[17:00:33.357]                   NAME <- NAMES[[kk]]
[17:00:33.357]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.357]                     next
[17:00:33.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.357]                 }
[17:00:33.357]                 if (length(args) > 0) 
[17:00:33.357]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.357]             }
[17:00:33.357]             else {
[17:00:33.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.357]             }
[17:00:33.357]             {
[17:00:33.357]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.357]                   0L) {
[17:00:33.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.357]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.357]                   base::options(opts)
[17:00:33.357]                 }
[17:00:33.357]                 {
[17:00:33.357]                   {
[17:00:33.357]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.357]                     NULL
[17:00:33.357]                   }
[17:00:33.357]                   options(future.plan = NULL)
[17:00:33.357]                   if (is.na(NA_character_)) 
[17:00:33.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.357]                     .init = FALSE)
[17:00:33.357]                 }
[17:00:33.357]             }
[17:00:33.357]         }
[17:00:33.357]     })
[17:00:33.357]     if (TRUE) {
[17:00:33.357]         base::sink(type = "output", split = FALSE)
[17:00:33.357]         if (TRUE) {
[17:00:33.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.357]         }
[17:00:33.357]         else {
[17:00:33.357]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.357]         }
[17:00:33.357]         base::close(...future.stdout)
[17:00:33.357]         ...future.stdout <- NULL
[17:00:33.357]     }
[17:00:33.357]     ...future.result$conditions <- ...future.conditions
[17:00:33.357]     ...future.result$finished <- base::Sys.time()
[17:00:33.357]     ...future.result
[17:00:33.357] }
[17:00:33.359] Poll #1 (0): usedNodes() = 2, workers = 2
[17:00:33.370] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.370] - Validating connection of MultisessionFuture
[17:00:33.370] - received message: FutureResult
[17:00:33.370] - Received FutureResult
[17:00:33.370] - Erased future from FutureRegistry
[17:00:33.371] result() for ClusterFuture ...
[17:00:33.371] - result already collected: FutureResult
[17:00:33.371] result() for ClusterFuture ... done
[17:00:33.371] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.371] result() for ClusterFuture ...
[17:00:33.371] - result already collected: FutureResult
[17:00:33.371] result() for ClusterFuture ... done
[17:00:33.371] result() for ClusterFuture ...
[17:00:33.371] - result already collected: FutureResult
[17:00:33.371] result() for ClusterFuture ... done
[17:00:33.372] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[17:00:33.372] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:00:33.373] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:00:33.373] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:33.373] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.373] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[17:00:33.374] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[17:00:33.374] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:33.374] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.374] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:33.374] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.375] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[17:00:33.375] MultisessionFuture started
[17:00:33.375] - Launch lazy future ... done
[17:00:33.375] run() for ‘MultisessionFuture’ ... done
[17:00:33.375] Created future:
[17:00:33.375] MultisessionFuture:
[17:00:33.375] Label: ‘future_mapply-3’
[17:00:33.375] Expression:
[17:00:33.375] {
[17:00:33.375]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.375]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.375]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.375]         on.exit(options(oopts), add = TRUE)
[17:00:33.375]     }
[17:00:33.375]     {
[17:00:33.375]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.375]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.375]         do.call(mapply, args = args)
[17:00:33.375]     }
[17:00:33.375] }
[17:00:33.375] Lazy evaluation: FALSE
[17:00:33.375] Asynchronous evaluation: TRUE
[17:00:33.375] Local evaluation: TRUE
[17:00:33.375] Environment: R_GlobalEnv
[17:00:33.375] Capture standard output: TRUE
[17:00:33.375] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.375] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.375] Packages: <none>
[17:00:33.375] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.375] Resolved: FALSE
[17:00:33.375] Value: <not collected>
[17:00:33.375] Conditions captured: <none>
[17:00:33.375] Early signaling: FALSE
[17:00:33.375] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.375] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.387] Chunk #3 of 5 ... DONE
[17:00:33.387] Chunk #4 of 5 ...
[17:00:33.387]  - Finding globals in '...' for chunk #4 ...
[17:00:33.387] getGlobalsAndPackages() ...
[17:00:33.387] Searching for globals...
[17:00:33.388] 
[17:00:33.388] Searching for globals ... DONE
[17:00:33.388] - globals: [0] <none>
[17:00:33.388] getGlobalsAndPackages() ... DONE
[17:00:33.388]    + additional globals found: [n=0] 
[17:00:33.388]    + additional namespaces needed: [n=0] 
[17:00:33.388]  - Finding globals in '...' for chunk #4 ... DONE
[17:00:33.388]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:33.388]  - seeds: <none>
[17:00:33.389]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.389] getGlobalsAndPackages() ...
[17:00:33.389] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.389] Resolving globals: FALSE
[17:00:33.389] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:33.390] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.390] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.390] 
[17:00:33.390] getGlobalsAndPackages() ... DONE
[17:00:33.390] run() for ‘Future’ ...
[17:00:33.390] - state: ‘created’
[17:00:33.391] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.405] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.405]   - Field: ‘node’
[17:00:33.405]   - Field: ‘label’
[17:00:33.405]   - Field: ‘local’
[17:00:33.405]   - Field: ‘owner’
[17:00:33.405]   - Field: ‘envir’
[17:00:33.405]   - Field: ‘workers’
[17:00:33.406]   - Field: ‘packages’
[17:00:33.406]   - Field: ‘gc’
[17:00:33.408]   - Field: ‘conditions’
[17:00:33.408]   - Field: ‘persistent’
[17:00:33.408]   - Field: ‘expr’
[17:00:33.408]   - Field: ‘uuid’
[17:00:33.408]   - Field: ‘seed’
[17:00:33.408]   - Field: ‘version’
[17:00:33.409]   - Field: ‘result’
[17:00:33.409]   - Field: ‘asynchronous’
[17:00:33.409]   - Field: ‘calls’
[17:00:33.409]   - Field: ‘globals’
[17:00:33.409]   - Field: ‘stdout’
[17:00:33.409]   - Field: ‘earlySignal’
[17:00:33.409]   - Field: ‘lazy’
[17:00:33.409]   - Field: ‘state’
[17:00:33.409] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.409] - Launch lazy future ...
[17:00:33.410] Packages needed by the future expression (n = 0): <none>
[17:00:33.410] Packages needed by future strategies (n = 0): <none>
[17:00:33.410] {
[17:00:33.410]     {
[17:00:33.410]         {
[17:00:33.410]             ...future.startTime <- base::Sys.time()
[17:00:33.410]             {
[17:00:33.410]                 {
[17:00:33.410]                   {
[17:00:33.410]                     {
[17:00:33.410]                       base::local({
[17:00:33.410]                         has_future <- base::requireNamespace("future", 
[17:00:33.410]                           quietly = TRUE)
[17:00:33.410]                         if (has_future) {
[17:00:33.410]                           ns <- base::getNamespace("future")
[17:00:33.410]                           version <- ns[[".package"]][["version"]]
[17:00:33.410]                           if (is.null(version)) 
[17:00:33.410]                             version <- utils::packageVersion("future")
[17:00:33.410]                         }
[17:00:33.410]                         else {
[17:00:33.410]                           version <- NULL
[17:00:33.410]                         }
[17:00:33.410]                         if (!has_future || version < "1.8.0") {
[17:00:33.410]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.410]                             "", base::R.version$version.string), 
[17:00:33.410]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.410]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.410]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.410]                               "release", "version")], collapse = " "), 
[17:00:33.410]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.410]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.410]                             info)
[17:00:33.410]                           info <- base::paste(info, collapse = "; ")
[17:00:33.410]                           if (!has_future) {
[17:00:33.410]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.410]                               info)
[17:00:33.410]                           }
[17:00:33.410]                           else {
[17:00:33.410]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.410]                               info, version)
[17:00:33.410]                           }
[17:00:33.410]                           base::stop(msg)
[17:00:33.410]                         }
[17:00:33.410]                       })
[17:00:33.410]                     }
[17:00:33.410]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.410]                     base::options(mc.cores = 1L)
[17:00:33.410]                   }
[17:00:33.410]                   ...future.strategy.old <- future::plan("list")
[17:00:33.410]                   options(future.plan = NULL)
[17:00:33.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.410]                 }
[17:00:33.410]                 ...future.workdir <- getwd()
[17:00:33.410]             }
[17:00:33.410]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.410]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.410]         }
[17:00:33.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.410]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:33.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.410]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.410]             base::names(...future.oldOptions))
[17:00:33.410]     }
[17:00:33.410]     if (FALSE) {
[17:00:33.410]     }
[17:00:33.410]     else {
[17:00:33.410]         if (TRUE) {
[17:00:33.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.410]                 open = "w")
[17:00:33.410]         }
[17:00:33.410]         else {
[17:00:33.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.410]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.410]         }
[17:00:33.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.410]             base::sink(type = "output", split = FALSE)
[17:00:33.410]             base::close(...future.stdout)
[17:00:33.410]         }, add = TRUE)
[17:00:33.410]     }
[17:00:33.410]     ...future.frame <- base::sys.nframe()
[17:00:33.410]     ...future.conditions <- base::list()
[17:00:33.410]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.410]     if (FALSE) {
[17:00:33.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.410]     }
[17:00:33.410]     ...future.result <- base::tryCatch({
[17:00:33.410]         base::withCallingHandlers({
[17:00:33.410]             ...future.value <- base::withVisible(base::local({
[17:00:33.410]                 ...future.makeSendCondition <- base::local({
[17:00:33.410]                   sendCondition <- NULL
[17:00:33.410]                   function(frame = 1L) {
[17:00:33.410]                     if (is.function(sendCondition)) 
[17:00:33.410]                       return(sendCondition)
[17:00:33.410]                     ns <- getNamespace("parallel")
[17:00:33.410]                     if (exists("sendData", mode = "function", 
[17:00:33.410]                       envir = ns)) {
[17:00:33.410]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.410]                         envir = ns)
[17:00:33.410]                       envir <- sys.frame(frame)
[17:00:33.410]                       master <- NULL
[17:00:33.410]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.410]                         !identical(envir, emptyenv())) {
[17:00:33.410]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.410]                           inherits = FALSE)) {
[17:00:33.410]                           master <- get("master", mode = "list", 
[17:00:33.410]                             envir = envir, inherits = FALSE)
[17:00:33.410]                           if (inherits(master, c("SOCKnode", 
[17:00:33.410]                             "SOCK0node"))) {
[17:00:33.410]                             sendCondition <<- function(cond) {
[17:00:33.410]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.410]                                 success = TRUE)
[17:00:33.410]                               parallel_sendData(master, data)
[17:00:33.410]                             }
[17:00:33.410]                             return(sendCondition)
[17:00:33.410]                           }
[17:00:33.410]                         }
[17:00:33.410]                         frame <- frame + 1L
[17:00:33.410]                         envir <- sys.frame(frame)
[17:00:33.410]                       }
[17:00:33.410]                     }
[17:00:33.410]                     sendCondition <<- function(cond) NULL
[17:00:33.410]                   }
[17:00:33.410]                 })
[17:00:33.410]                 withCallingHandlers({
[17:00:33.410]                   {
[17:00:33.410]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.410]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.410]                       ...future.globals.maxSize)) {
[17:00:33.410]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.410]                       on.exit(options(oopts), add = TRUE)
[17:00:33.410]                     }
[17:00:33.410]                     {
[17:00:33.410]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.410]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.410]                         USE.NAMES = FALSE)
[17:00:33.410]                       do.call(mapply, args = args)
[17:00:33.410]                     }
[17:00:33.410]                   }
[17:00:33.410]                 }, immediateCondition = function(cond) {
[17:00:33.410]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.410]                   sendCondition(cond)
[17:00:33.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.410]                   {
[17:00:33.410]                     inherits <- base::inherits
[17:00:33.410]                     invokeRestart <- base::invokeRestart
[17:00:33.410]                     is.null <- base::is.null
[17:00:33.410]                     muffled <- FALSE
[17:00:33.410]                     if (inherits(cond, "message")) {
[17:00:33.410]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.410]                       if (muffled) 
[17:00:33.410]                         invokeRestart("muffleMessage")
[17:00:33.410]                     }
[17:00:33.410]                     else if (inherits(cond, "warning")) {
[17:00:33.410]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.410]                       if (muffled) 
[17:00:33.410]                         invokeRestart("muffleWarning")
[17:00:33.410]                     }
[17:00:33.410]                     else if (inherits(cond, "condition")) {
[17:00:33.410]                       if (!is.null(pattern)) {
[17:00:33.410]                         computeRestarts <- base::computeRestarts
[17:00:33.410]                         grepl <- base::grepl
[17:00:33.410]                         restarts <- computeRestarts(cond)
[17:00:33.410]                         for (restart in restarts) {
[17:00:33.410]                           name <- restart$name
[17:00:33.410]                           if (is.null(name)) 
[17:00:33.410]                             next
[17:00:33.410]                           if (!grepl(pattern, name)) 
[17:00:33.410]                             next
[17:00:33.410]                           invokeRestart(restart)
[17:00:33.410]                           muffled <- TRUE
[17:00:33.410]                           break
[17:00:33.410]                         }
[17:00:33.410]                       }
[17:00:33.410]                     }
[17:00:33.410]                     invisible(muffled)
[17:00:33.410]                   }
[17:00:33.410]                   muffleCondition(cond)
[17:00:33.410]                 })
[17:00:33.410]             }))
[17:00:33.410]             future::FutureResult(value = ...future.value$value, 
[17:00:33.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.410]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.410]                     ...future.globalenv.names))
[17:00:33.410]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.410]         }, condition = base::local({
[17:00:33.410]             c <- base::c
[17:00:33.410]             inherits <- base::inherits
[17:00:33.410]             invokeRestart <- base::invokeRestart
[17:00:33.410]             length <- base::length
[17:00:33.410]             list <- base::list
[17:00:33.410]             seq.int <- base::seq.int
[17:00:33.410]             signalCondition <- base::signalCondition
[17:00:33.410]             sys.calls <- base::sys.calls
[17:00:33.410]             `[[` <- base::`[[`
[17:00:33.410]             `+` <- base::`+`
[17:00:33.410]             `<<-` <- base::`<<-`
[17:00:33.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.410]                   3L)]
[17:00:33.410]             }
[17:00:33.410]             function(cond) {
[17:00:33.410]                 is_error <- inherits(cond, "error")
[17:00:33.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.410]                   NULL)
[17:00:33.410]                 if (is_error) {
[17:00:33.410]                   sessionInformation <- function() {
[17:00:33.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.410]                       search = base::search(), system = base::Sys.info())
[17:00:33.410]                   }
[17:00:33.410]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.410]                     cond$call), session = sessionInformation(), 
[17:00:33.410]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.410]                   signalCondition(cond)
[17:00:33.410]                 }
[17:00:33.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.410]                 "immediateCondition"))) {
[17:00:33.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.410]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.410]                   if (TRUE && !signal) {
[17:00:33.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.410]                     {
[17:00:33.410]                       inherits <- base::inherits
[17:00:33.410]                       invokeRestart <- base::invokeRestart
[17:00:33.410]                       is.null <- base::is.null
[17:00:33.410]                       muffled <- FALSE
[17:00:33.410]                       if (inherits(cond, "message")) {
[17:00:33.410]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.410]                         if (muffled) 
[17:00:33.410]                           invokeRestart("muffleMessage")
[17:00:33.410]                       }
[17:00:33.410]                       else if (inherits(cond, "warning")) {
[17:00:33.410]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.410]                         if (muffled) 
[17:00:33.410]                           invokeRestart("muffleWarning")
[17:00:33.410]                       }
[17:00:33.410]                       else if (inherits(cond, "condition")) {
[17:00:33.410]                         if (!is.null(pattern)) {
[17:00:33.410]                           computeRestarts <- base::computeRestarts
[17:00:33.410]                           grepl <- base::grepl
[17:00:33.410]                           restarts <- computeRestarts(cond)
[17:00:33.410]                           for (restart in restarts) {
[17:00:33.410]                             name <- restart$name
[17:00:33.410]                             if (is.null(name)) 
[17:00:33.410]                               next
[17:00:33.410]                             if (!grepl(pattern, name)) 
[17:00:33.410]                               next
[17:00:33.410]                             invokeRestart(restart)
[17:00:33.410]                             muffled <- TRUE
[17:00:33.410]                             break
[17:00:33.410]                           }
[17:00:33.410]                         }
[17:00:33.410]                       }
[17:00:33.410]                       invisible(muffled)
[17:00:33.410]                     }
[17:00:33.410]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.410]                   }
[17:00:33.410]                 }
[17:00:33.410]                 else {
[17:00:33.410]                   if (TRUE) {
[17:00:33.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.410]                     {
[17:00:33.410]                       inherits <- base::inherits
[17:00:33.410]                       invokeRestart <- base::invokeRestart
[17:00:33.410]                       is.null <- base::is.null
[17:00:33.410]                       muffled <- FALSE
[17:00:33.410]                       if (inherits(cond, "message")) {
[17:00:33.410]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.410]                         if (muffled) 
[17:00:33.410]                           invokeRestart("muffleMessage")
[17:00:33.410]                       }
[17:00:33.410]                       else if (inherits(cond, "warning")) {
[17:00:33.410]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.410]                         if (muffled) 
[17:00:33.410]                           invokeRestart("muffleWarning")
[17:00:33.410]                       }
[17:00:33.410]                       else if (inherits(cond, "condition")) {
[17:00:33.410]                         if (!is.null(pattern)) {
[17:00:33.410]                           computeRestarts <- base::computeRestarts
[17:00:33.410]                           grepl <- base::grepl
[17:00:33.410]                           restarts <- computeRestarts(cond)
[17:00:33.410]                           for (restart in restarts) {
[17:00:33.410]                             name <- restart$name
[17:00:33.410]                             if (is.null(name)) 
[17:00:33.410]                               next
[17:00:33.410]                             if (!grepl(pattern, name)) 
[17:00:33.410]                               next
[17:00:33.410]                             invokeRestart(restart)
[17:00:33.410]                             muffled <- TRUE
[17:00:33.410]                             break
[17:00:33.410]                           }
[17:00:33.410]                         }
[17:00:33.410]                       }
[17:00:33.410]                       invisible(muffled)
[17:00:33.410]                     }
[17:00:33.410]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.410]                   }
[17:00:33.410]                 }
[17:00:33.410]             }
[17:00:33.410]         }))
[17:00:33.410]     }, error = function(ex) {
[17:00:33.410]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.410]                 ...future.rng), started = ...future.startTime, 
[17:00:33.410]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.410]             version = "1.8"), class = "FutureResult")
[17:00:33.410]     }, finally = {
[17:00:33.410]         if (!identical(...future.workdir, getwd())) 
[17:00:33.410]             setwd(...future.workdir)
[17:00:33.410]         {
[17:00:33.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.410]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.410]             }
[17:00:33.410]             base::options(...future.oldOptions)
[17:00:33.410]             if (.Platform$OS.type == "windows") {
[17:00:33.410]                 old_names <- names(...future.oldEnvVars)
[17:00:33.410]                 envs <- base::Sys.getenv()
[17:00:33.410]                 names <- names(envs)
[17:00:33.410]                 common <- intersect(names, old_names)
[17:00:33.410]                 added <- setdiff(names, old_names)
[17:00:33.410]                 removed <- setdiff(old_names, names)
[17:00:33.410]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.410]                   envs[common]]
[17:00:33.410]                 NAMES <- toupper(changed)
[17:00:33.410]                 args <- list()
[17:00:33.410]                 for (kk in seq_along(NAMES)) {
[17:00:33.410]                   name <- changed[[kk]]
[17:00:33.410]                   NAME <- NAMES[[kk]]
[17:00:33.410]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.410]                     next
[17:00:33.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.410]                 }
[17:00:33.410]                 NAMES <- toupper(added)
[17:00:33.410]                 for (kk in seq_along(NAMES)) {
[17:00:33.410]                   name <- added[[kk]]
[17:00:33.410]                   NAME <- NAMES[[kk]]
[17:00:33.410]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.410]                     next
[17:00:33.410]                   args[[name]] <- ""
[17:00:33.410]                 }
[17:00:33.410]                 NAMES <- toupper(removed)
[17:00:33.410]                 for (kk in seq_along(NAMES)) {
[17:00:33.410]                   name <- removed[[kk]]
[17:00:33.410]                   NAME <- NAMES[[kk]]
[17:00:33.410]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.410]                     next
[17:00:33.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.410]                 }
[17:00:33.410]                 if (length(args) > 0) 
[17:00:33.410]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.410]             }
[17:00:33.410]             else {
[17:00:33.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.410]             }
[17:00:33.410]             {
[17:00:33.410]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.410]                   0L) {
[17:00:33.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.410]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.410]                   base::options(opts)
[17:00:33.410]                 }
[17:00:33.410]                 {
[17:00:33.410]                   {
[17:00:33.410]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.410]                     NULL
[17:00:33.410]                   }
[17:00:33.410]                   options(future.plan = NULL)
[17:00:33.410]                   if (is.na(NA_character_)) 
[17:00:33.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.410]                     .init = FALSE)
[17:00:33.410]                 }
[17:00:33.410]             }
[17:00:33.410]         }
[17:00:33.410]     })
[17:00:33.410]     if (TRUE) {
[17:00:33.410]         base::sink(type = "output", split = FALSE)
[17:00:33.410]         if (TRUE) {
[17:00:33.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.410]         }
[17:00:33.410]         else {
[17:00:33.410]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.410]         }
[17:00:33.410]         base::close(...future.stdout)
[17:00:33.410]         ...future.stdout <- NULL
[17:00:33.410]     }
[17:00:33.410]     ...future.result$conditions <- ...future.conditions
[17:00:33.410]     ...future.result$finished <- base::Sys.time()
[17:00:33.410]     ...future.result
[17:00:33.410] }
[17:00:33.412] Poll #1 (0): usedNodes() = 2, workers = 2
[17:00:33.423] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.423] - Validating connection of MultisessionFuture
[17:00:33.424] - received message: FutureResult
[17:00:33.424] - Received FutureResult
[17:00:33.424] - Erased future from FutureRegistry
[17:00:33.424] result() for ClusterFuture ...
[17:00:33.424] - result already collected: FutureResult
[17:00:33.424] result() for ClusterFuture ... done
[17:00:33.424] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.424] result() for ClusterFuture ...
[17:00:33.424] - result already collected: FutureResult
[17:00:33.424] result() for ClusterFuture ... done
[17:00:33.425] result() for ClusterFuture ...
[17:00:33.425] - result already collected: FutureResult
[17:00:33.425] result() for ClusterFuture ... done
[17:00:33.425] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[17:00:33.426] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:00:33.426] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:00:33.426] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:33.427] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.427] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[17:00:33.427] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[17:00:33.427] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:33.428] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.428] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:33.428] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.428] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[17:00:33.429] MultisessionFuture started
[17:00:33.429] - Launch lazy future ... done
[17:00:33.429] run() for ‘MultisessionFuture’ ... done
[17:00:33.429] Created future:
[17:00:33.429] MultisessionFuture:
[17:00:33.429] Label: ‘future_mapply-4’
[17:00:33.429] Expression:
[17:00:33.429] {
[17:00:33.429]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.429]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.429]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.429]         on.exit(options(oopts), add = TRUE)
[17:00:33.429]     }
[17:00:33.429]     {
[17:00:33.429]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.429]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.429]         do.call(mapply, args = args)
[17:00:33.429]     }
[17:00:33.429] }
[17:00:33.429] Lazy evaluation: FALSE
[17:00:33.429] Asynchronous evaluation: TRUE
[17:00:33.429] Local evaluation: TRUE
[17:00:33.429] Environment: R_GlobalEnv
[17:00:33.429] Capture standard output: TRUE
[17:00:33.429] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.429] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.429] Packages: <none>
[17:00:33.429] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.429] Resolved: FALSE
[17:00:33.429] Value: <not collected>
[17:00:33.429] Conditions captured: <none>
[17:00:33.429] Early signaling: FALSE
[17:00:33.429] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.429] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.441] Chunk #4 of 5 ... DONE
[17:00:33.441] Chunk #5 of 5 ...
[17:00:33.441]  - Finding globals in '...' for chunk #5 ...
[17:00:33.441] getGlobalsAndPackages() ...
[17:00:33.441] Searching for globals...
[17:00:33.442] 
[17:00:33.442] Searching for globals ... DONE
[17:00:33.442] - globals: [0] <none>
[17:00:33.442] getGlobalsAndPackages() ... DONE
[17:00:33.442]    + additional globals found: [n=0] 
[17:00:33.442]    + additional namespaces needed: [n=0] 
[17:00:33.442]  - Finding globals in '...' for chunk #5 ... DONE
[17:00:33.442]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:00:33.442]  - seeds: <none>
[17:00:33.443]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.443] getGlobalsAndPackages() ...
[17:00:33.443] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.443] Resolving globals: FALSE
[17:00:33.443] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:33.444] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.444] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.444] 
[17:00:33.444] getGlobalsAndPackages() ... DONE
[17:00:33.444] run() for ‘Future’ ...
[17:00:33.445] - state: ‘created’
[17:00:33.445] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.459] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.459]   - Field: ‘node’
[17:00:33.459]   - Field: ‘label’
[17:00:33.459]   - Field: ‘local’
[17:00:33.459]   - Field: ‘owner’
[17:00:33.460]   - Field: ‘envir’
[17:00:33.460]   - Field: ‘workers’
[17:00:33.460]   - Field: ‘packages’
[17:00:33.460]   - Field: ‘gc’
[17:00:33.460]   - Field: ‘conditions’
[17:00:33.460]   - Field: ‘persistent’
[17:00:33.460]   - Field: ‘expr’
[17:00:33.460]   - Field: ‘uuid’
[17:00:33.460]   - Field: ‘seed’
[17:00:33.460]   - Field: ‘version’
[17:00:33.460]   - Field: ‘result’
[17:00:33.460]   - Field: ‘asynchronous’
[17:00:33.461]   - Field: ‘calls’
[17:00:33.461]   - Field: ‘globals’
[17:00:33.461]   - Field: ‘stdout’
[17:00:33.461]   - Field: ‘earlySignal’
[17:00:33.461]   - Field: ‘lazy’
[17:00:33.461]   - Field: ‘state’
[17:00:33.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.461] - Launch lazy future ...
[17:00:33.462] Packages needed by the future expression (n = 0): <none>
[17:00:33.462] Packages needed by future strategies (n = 0): <none>
[17:00:33.462] {
[17:00:33.462]     {
[17:00:33.462]         {
[17:00:33.462]             ...future.startTime <- base::Sys.time()
[17:00:33.462]             {
[17:00:33.462]                 {
[17:00:33.462]                   {
[17:00:33.462]                     {
[17:00:33.462]                       base::local({
[17:00:33.462]                         has_future <- base::requireNamespace("future", 
[17:00:33.462]                           quietly = TRUE)
[17:00:33.462]                         if (has_future) {
[17:00:33.462]                           ns <- base::getNamespace("future")
[17:00:33.462]                           version <- ns[[".package"]][["version"]]
[17:00:33.462]                           if (is.null(version)) 
[17:00:33.462]                             version <- utils::packageVersion("future")
[17:00:33.462]                         }
[17:00:33.462]                         else {
[17:00:33.462]                           version <- NULL
[17:00:33.462]                         }
[17:00:33.462]                         if (!has_future || version < "1.8.0") {
[17:00:33.462]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.462]                             "", base::R.version$version.string), 
[17:00:33.462]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.462]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.462]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.462]                               "release", "version")], collapse = " "), 
[17:00:33.462]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.462]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.462]                             info)
[17:00:33.462]                           info <- base::paste(info, collapse = "; ")
[17:00:33.462]                           if (!has_future) {
[17:00:33.462]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.462]                               info)
[17:00:33.462]                           }
[17:00:33.462]                           else {
[17:00:33.462]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.462]                               info, version)
[17:00:33.462]                           }
[17:00:33.462]                           base::stop(msg)
[17:00:33.462]                         }
[17:00:33.462]                       })
[17:00:33.462]                     }
[17:00:33.462]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.462]                     base::options(mc.cores = 1L)
[17:00:33.462]                   }
[17:00:33.462]                   ...future.strategy.old <- future::plan("list")
[17:00:33.462]                   options(future.plan = NULL)
[17:00:33.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.462]                 }
[17:00:33.462]                 ...future.workdir <- getwd()
[17:00:33.462]             }
[17:00:33.462]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.462]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.462]         }
[17:00:33.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.462]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:00:33.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.462]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.462]             base::names(...future.oldOptions))
[17:00:33.462]     }
[17:00:33.462]     if (FALSE) {
[17:00:33.462]     }
[17:00:33.462]     else {
[17:00:33.462]         if (TRUE) {
[17:00:33.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.462]                 open = "w")
[17:00:33.462]         }
[17:00:33.462]         else {
[17:00:33.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.462]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.462]         }
[17:00:33.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.462]             base::sink(type = "output", split = FALSE)
[17:00:33.462]             base::close(...future.stdout)
[17:00:33.462]         }, add = TRUE)
[17:00:33.462]     }
[17:00:33.462]     ...future.frame <- base::sys.nframe()
[17:00:33.462]     ...future.conditions <- base::list()
[17:00:33.462]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.462]     if (FALSE) {
[17:00:33.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.462]     }
[17:00:33.462]     ...future.result <- base::tryCatch({
[17:00:33.462]         base::withCallingHandlers({
[17:00:33.462]             ...future.value <- base::withVisible(base::local({
[17:00:33.462]                 ...future.makeSendCondition <- base::local({
[17:00:33.462]                   sendCondition <- NULL
[17:00:33.462]                   function(frame = 1L) {
[17:00:33.462]                     if (is.function(sendCondition)) 
[17:00:33.462]                       return(sendCondition)
[17:00:33.462]                     ns <- getNamespace("parallel")
[17:00:33.462]                     if (exists("sendData", mode = "function", 
[17:00:33.462]                       envir = ns)) {
[17:00:33.462]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.462]                         envir = ns)
[17:00:33.462]                       envir <- sys.frame(frame)
[17:00:33.462]                       master <- NULL
[17:00:33.462]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.462]                         !identical(envir, emptyenv())) {
[17:00:33.462]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.462]                           inherits = FALSE)) {
[17:00:33.462]                           master <- get("master", mode = "list", 
[17:00:33.462]                             envir = envir, inherits = FALSE)
[17:00:33.462]                           if (inherits(master, c("SOCKnode", 
[17:00:33.462]                             "SOCK0node"))) {
[17:00:33.462]                             sendCondition <<- function(cond) {
[17:00:33.462]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.462]                                 success = TRUE)
[17:00:33.462]                               parallel_sendData(master, data)
[17:00:33.462]                             }
[17:00:33.462]                             return(sendCondition)
[17:00:33.462]                           }
[17:00:33.462]                         }
[17:00:33.462]                         frame <- frame + 1L
[17:00:33.462]                         envir <- sys.frame(frame)
[17:00:33.462]                       }
[17:00:33.462]                     }
[17:00:33.462]                     sendCondition <<- function(cond) NULL
[17:00:33.462]                   }
[17:00:33.462]                 })
[17:00:33.462]                 withCallingHandlers({
[17:00:33.462]                   {
[17:00:33.462]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.462]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.462]                       ...future.globals.maxSize)) {
[17:00:33.462]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.462]                       on.exit(options(oopts), add = TRUE)
[17:00:33.462]                     }
[17:00:33.462]                     {
[17:00:33.462]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.462]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.462]                         USE.NAMES = FALSE)
[17:00:33.462]                       do.call(mapply, args = args)
[17:00:33.462]                     }
[17:00:33.462]                   }
[17:00:33.462]                 }, immediateCondition = function(cond) {
[17:00:33.462]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.462]                   sendCondition(cond)
[17:00:33.462]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.462]                   {
[17:00:33.462]                     inherits <- base::inherits
[17:00:33.462]                     invokeRestart <- base::invokeRestart
[17:00:33.462]                     is.null <- base::is.null
[17:00:33.462]                     muffled <- FALSE
[17:00:33.462]                     if (inherits(cond, "message")) {
[17:00:33.462]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.462]                       if (muffled) 
[17:00:33.462]                         invokeRestart("muffleMessage")
[17:00:33.462]                     }
[17:00:33.462]                     else if (inherits(cond, "warning")) {
[17:00:33.462]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.462]                       if (muffled) 
[17:00:33.462]                         invokeRestart("muffleWarning")
[17:00:33.462]                     }
[17:00:33.462]                     else if (inherits(cond, "condition")) {
[17:00:33.462]                       if (!is.null(pattern)) {
[17:00:33.462]                         computeRestarts <- base::computeRestarts
[17:00:33.462]                         grepl <- base::grepl
[17:00:33.462]                         restarts <- computeRestarts(cond)
[17:00:33.462]                         for (restart in restarts) {
[17:00:33.462]                           name <- restart$name
[17:00:33.462]                           if (is.null(name)) 
[17:00:33.462]                             next
[17:00:33.462]                           if (!grepl(pattern, name)) 
[17:00:33.462]                             next
[17:00:33.462]                           invokeRestart(restart)
[17:00:33.462]                           muffled <- TRUE
[17:00:33.462]                           break
[17:00:33.462]                         }
[17:00:33.462]                       }
[17:00:33.462]                     }
[17:00:33.462]                     invisible(muffled)
[17:00:33.462]                   }
[17:00:33.462]                   muffleCondition(cond)
[17:00:33.462]                 })
[17:00:33.462]             }))
[17:00:33.462]             future::FutureResult(value = ...future.value$value, 
[17:00:33.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.462]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.462]                     ...future.globalenv.names))
[17:00:33.462]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.462]         }, condition = base::local({
[17:00:33.462]             c <- base::c
[17:00:33.462]             inherits <- base::inherits
[17:00:33.462]             invokeRestart <- base::invokeRestart
[17:00:33.462]             length <- base::length
[17:00:33.462]             list <- base::list
[17:00:33.462]             seq.int <- base::seq.int
[17:00:33.462]             signalCondition <- base::signalCondition
[17:00:33.462]             sys.calls <- base::sys.calls
[17:00:33.462]             `[[` <- base::`[[`
[17:00:33.462]             `+` <- base::`+`
[17:00:33.462]             `<<-` <- base::`<<-`
[17:00:33.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.462]                   3L)]
[17:00:33.462]             }
[17:00:33.462]             function(cond) {
[17:00:33.462]                 is_error <- inherits(cond, "error")
[17:00:33.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.462]                   NULL)
[17:00:33.462]                 if (is_error) {
[17:00:33.462]                   sessionInformation <- function() {
[17:00:33.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.462]                       search = base::search(), system = base::Sys.info())
[17:00:33.462]                   }
[17:00:33.462]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.462]                     cond$call), session = sessionInformation(), 
[17:00:33.462]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.462]                   signalCondition(cond)
[17:00:33.462]                 }
[17:00:33.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.462]                 "immediateCondition"))) {
[17:00:33.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.462]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.462]                   if (TRUE && !signal) {
[17:00:33.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.462]                     {
[17:00:33.462]                       inherits <- base::inherits
[17:00:33.462]                       invokeRestart <- base::invokeRestart
[17:00:33.462]                       is.null <- base::is.null
[17:00:33.462]                       muffled <- FALSE
[17:00:33.462]                       if (inherits(cond, "message")) {
[17:00:33.462]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.462]                         if (muffled) 
[17:00:33.462]                           invokeRestart("muffleMessage")
[17:00:33.462]                       }
[17:00:33.462]                       else if (inherits(cond, "warning")) {
[17:00:33.462]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.462]                         if (muffled) 
[17:00:33.462]                           invokeRestart("muffleWarning")
[17:00:33.462]                       }
[17:00:33.462]                       else if (inherits(cond, "condition")) {
[17:00:33.462]                         if (!is.null(pattern)) {
[17:00:33.462]                           computeRestarts <- base::computeRestarts
[17:00:33.462]                           grepl <- base::grepl
[17:00:33.462]                           restarts <- computeRestarts(cond)
[17:00:33.462]                           for (restart in restarts) {
[17:00:33.462]                             name <- restart$name
[17:00:33.462]                             if (is.null(name)) 
[17:00:33.462]                               next
[17:00:33.462]                             if (!grepl(pattern, name)) 
[17:00:33.462]                               next
[17:00:33.462]                             invokeRestart(restart)
[17:00:33.462]                             muffled <- TRUE
[17:00:33.462]                             break
[17:00:33.462]                           }
[17:00:33.462]                         }
[17:00:33.462]                       }
[17:00:33.462]                       invisible(muffled)
[17:00:33.462]                     }
[17:00:33.462]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.462]                   }
[17:00:33.462]                 }
[17:00:33.462]                 else {
[17:00:33.462]                   if (TRUE) {
[17:00:33.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.462]                     {
[17:00:33.462]                       inherits <- base::inherits
[17:00:33.462]                       invokeRestart <- base::invokeRestart
[17:00:33.462]                       is.null <- base::is.null
[17:00:33.462]                       muffled <- FALSE
[17:00:33.462]                       if (inherits(cond, "message")) {
[17:00:33.462]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.462]                         if (muffled) 
[17:00:33.462]                           invokeRestart("muffleMessage")
[17:00:33.462]                       }
[17:00:33.462]                       else if (inherits(cond, "warning")) {
[17:00:33.462]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.462]                         if (muffled) 
[17:00:33.462]                           invokeRestart("muffleWarning")
[17:00:33.462]                       }
[17:00:33.462]                       else if (inherits(cond, "condition")) {
[17:00:33.462]                         if (!is.null(pattern)) {
[17:00:33.462]                           computeRestarts <- base::computeRestarts
[17:00:33.462]                           grepl <- base::grepl
[17:00:33.462]                           restarts <- computeRestarts(cond)
[17:00:33.462]                           for (restart in restarts) {
[17:00:33.462]                             name <- restart$name
[17:00:33.462]                             if (is.null(name)) 
[17:00:33.462]                               next
[17:00:33.462]                             if (!grepl(pattern, name)) 
[17:00:33.462]                               next
[17:00:33.462]                             invokeRestart(restart)
[17:00:33.462]                             muffled <- TRUE
[17:00:33.462]                             break
[17:00:33.462]                           }
[17:00:33.462]                         }
[17:00:33.462]                       }
[17:00:33.462]                       invisible(muffled)
[17:00:33.462]                     }
[17:00:33.462]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.462]                   }
[17:00:33.462]                 }
[17:00:33.462]             }
[17:00:33.462]         }))
[17:00:33.462]     }, error = function(ex) {
[17:00:33.462]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.462]                 ...future.rng), started = ...future.startTime, 
[17:00:33.462]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.462]             version = "1.8"), class = "FutureResult")
[17:00:33.462]     }, finally = {
[17:00:33.462]         if (!identical(...future.workdir, getwd())) 
[17:00:33.462]             setwd(...future.workdir)
[17:00:33.462]         {
[17:00:33.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.462]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.462]             }
[17:00:33.462]             base::options(...future.oldOptions)
[17:00:33.462]             if (.Platform$OS.type == "windows") {
[17:00:33.462]                 old_names <- names(...future.oldEnvVars)
[17:00:33.462]                 envs <- base::Sys.getenv()
[17:00:33.462]                 names <- names(envs)
[17:00:33.462]                 common <- intersect(names, old_names)
[17:00:33.462]                 added <- setdiff(names, old_names)
[17:00:33.462]                 removed <- setdiff(old_names, names)
[17:00:33.462]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.462]                   envs[common]]
[17:00:33.462]                 NAMES <- toupper(changed)
[17:00:33.462]                 args <- list()
[17:00:33.462]                 for (kk in seq_along(NAMES)) {
[17:00:33.462]                   name <- changed[[kk]]
[17:00:33.462]                   NAME <- NAMES[[kk]]
[17:00:33.462]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.462]                     next
[17:00:33.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.462]                 }
[17:00:33.462]                 NAMES <- toupper(added)
[17:00:33.462]                 for (kk in seq_along(NAMES)) {
[17:00:33.462]                   name <- added[[kk]]
[17:00:33.462]                   NAME <- NAMES[[kk]]
[17:00:33.462]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.462]                     next
[17:00:33.462]                   args[[name]] <- ""
[17:00:33.462]                 }
[17:00:33.462]                 NAMES <- toupper(removed)
[17:00:33.462]                 for (kk in seq_along(NAMES)) {
[17:00:33.462]                   name <- removed[[kk]]
[17:00:33.462]                   NAME <- NAMES[[kk]]
[17:00:33.462]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.462]                     next
[17:00:33.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.462]                 }
[17:00:33.462]                 if (length(args) > 0) 
[17:00:33.462]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.462]             }
[17:00:33.462]             else {
[17:00:33.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.462]             }
[17:00:33.462]             {
[17:00:33.462]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.462]                   0L) {
[17:00:33.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.462]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.462]                   base::options(opts)
[17:00:33.462]                 }
[17:00:33.462]                 {
[17:00:33.462]                   {
[17:00:33.462]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.462]                     NULL
[17:00:33.462]                   }
[17:00:33.462]                   options(future.plan = NULL)
[17:00:33.462]                   if (is.na(NA_character_)) 
[17:00:33.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.462]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.462]                     .init = FALSE)
[17:00:33.462]                 }
[17:00:33.462]             }
[17:00:33.462]         }
[17:00:33.462]     })
[17:00:33.462]     if (TRUE) {
[17:00:33.462]         base::sink(type = "output", split = FALSE)
[17:00:33.462]         if (TRUE) {
[17:00:33.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.462]         }
[17:00:33.462]         else {
[17:00:33.462]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.462]         }
[17:00:33.462]         base::close(...future.stdout)
[17:00:33.462]         ...future.stdout <- NULL
[17:00:33.462]     }
[17:00:33.462]     ...future.result$conditions <- ...future.conditions
[17:00:33.462]     ...future.result$finished <- base::Sys.time()
[17:00:33.462]     ...future.result
[17:00:33.462] }
[17:00:33.464] Poll #1 (0): usedNodes() = 2, workers = 2
[17:00:33.475] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.475] - Validating connection of MultisessionFuture
[17:00:33.476] - received message: FutureResult
[17:00:33.476] - Received FutureResult
[17:00:33.476] - Erased future from FutureRegistry
[17:00:33.476] result() for ClusterFuture ...
[17:00:33.476] - result already collected: FutureResult
[17:00:33.476] result() for ClusterFuture ... done
[17:00:33.476] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.476] result() for ClusterFuture ...
[17:00:33.476] - result already collected: FutureResult
[17:00:33.476] result() for ClusterFuture ... done
[17:00:33.477] result() for ClusterFuture ...
[17:00:33.477] - result already collected: FutureResult
[17:00:33.477] result() for ClusterFuture ... done
[17:00:33.477] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[17:00:33.478] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:00:33.478] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:00:33.478] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:33.479] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.479] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[17:00:33.479] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[17:00:33.479] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:33.480] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.480] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:33.480] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.480] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[17:00:33.481] MultisessionFuture started
[17:00:33.481] - Launch lazy future ... done
[17:00:33.481] run() for ‘MultisessionFuture’ ... done
[17:00:33.481] Created future:
[17:00:33.481] MultisessionFuture:
[17:00:33.481] Label: ‘future_mapply-5’
[17:00:33.481] Expression:
[17:00:33.481] {
[17:00:33.481]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.481]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.481]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.481]         on.exit(options(oopts), add = TRUE)
[17:00:33.481]     }
[17:00:33.481]     {
[17:00:33.481]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.481]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.481]         do.call(mapply, args = args)
[17:00:33.481]     }
[17:00:33.481] }
[17:00:33.481] Lazy evaluation: FALSE
[17:00:33.481] Asynchronous evaluation: TRUE
[17:00:33.481] Local evaluation: TRUE
[17:00:33.481] Environment: R_GlobalEnv
[17:00:33.481] Capture standard output: TRUE
[17:00:33.481] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.481] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.481] Packages: <none>
[17:00:33.481] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.481] Resolved: FALSE
[17:00:33.481] Value: <not collected>
[17:00:33.481] Conditions captured: <none>
[17:00:33.481] Early signaling: FALSE
[17:00:33.481] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.481] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.493] Chunk #5 of 5 ... DONE
[17:00:33.493] Launching 5 futures (chunks) ... DONE
[17:00:33.493] Resolving 5 futures (chunks) ...
[17:00:33.493] resolve() on list ...
[17:00:33.493]  recursive: 0
[17:00:33.493]  length: 5
[17:00:33.493] 
[17:00:33.494] Future #1
[17:00:33.494] result() for ClusterFuture ...
[17:00:33.494] - result already collected: FutureResult
[17:00:33.494] result() for ClusterFuture ... done
[17:00:33.494] result() for ClusterFuture ...
[17:00:33.494] - result already collected: FutureResult
[17:00:33.494] result() for ClusterFuture ... done
[17:00:33.494] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:33.494] - nx: 5
[17:00:33.494] - relay: TRUE
[17:00:33.495] - stdout: TRUE
[17:00:33.495] - signal: TRUE
[17:00:33.495] - resignal: FALSE
[17:00:33.495] - force: TRUE
[17:00:33.495] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:00:33.495] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:00:33.495]  - until=1
[17:00:33.495]  - relaying element #1
[17:00:33.495] result() for ClusterFuture ...
[17:00:33.495] - result already collected: FutureResult
[17:00:33.495] result() for ClusterFuture ... done
[17:00:33.496] result() for ClusterFuture ...
[17:00:33.496] - result already collected: FutureResult
[17:00:33.496] result() for ClusterFuture ... done
[17:00:33.496] result() for ClusterFuture ...
[17:00:33.496] - result already collected: FutureResult
[17:00:33.496] result() for ClusterFuture ... done
[17:00:33.496] result() for ClusterFuture ...
[17:00:33.496] - result already collected: FutureResult
[17:00:33.496] result() for ClusterFuture ... done
[17:00:33.496] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:33.496] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:33.496] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:33.497]  length: 4 (resolved future 1)
[17:00:33.497] Future #2
[17:00:33.497] result() for ClusterFuture ...
[17:00:33.497] - result already collected: FutureResult
[17:00:33.497] result() for ClusterFuture ... done
[17:00:33.497] result() for ClusterFuture ...
[17:00:33.497] - result already collected: FutureResult
[17:00:33.497] result() for ClusterFuture ... done
[17:00:33.497] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:33.497] - nx: 5
[17:00:33.497] - relay: TRUE
[17:00:33.498] - stdout: TRUE
[17:00:33.498] - signal: TRUE
[17:00:33.498] - resignal: FALSE
[17:00:33.498] - force: TRUE
[17:00:33.498] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:33.498] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:00:33.498]  - until=2
[17:00:33.498]  - relaying element #2
[17:00:33.498] result() for ClusterFuture ...
[17:00:33.498] - result already collected: FutureResult
[17:00:33.498] result() for ClusterFuture ... done
[17:00:33.498] result() for ClusterFuture ...
[17:00:33.499] - result already collected: FutureResult
[17:00:33.499] result() for ClusterFuture ... done
[17:00:33.499] result() for ClusterFuture ...
[17:00:33.499] - result already collected: FutureResult
[17:00:33.499] result() for ClusterFuture ... done
[17:00:33.499] result() for ClusterFuture ...
[17:00:33.499] - result already collected: FutureResult
[17:00:33.499] result() for ClusterFuture ... done
[17:00:33.499] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:33.499] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:33.499] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:33.500]  length: 3 (resolved future 2)
[17:00:33.500] Future #3
[17:00:33.500] result() for ClusterFuture ...
[17:00:33.500] - result already collected: FutureResult
[17:00:33.500] result() for ClusterFuture ... done
[17:00:33.500] result() for ClusterFuture ...
[17:00:33.500] - result already collected: FutureResult
[17:00:33.500] result() for ClusterFuture ... done
[17:00:33.500] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:00:33.500] - nx: 5
[17:00:33.500] - relay: TRUE
[17:00:33.500] - stdout: TRUE
[17:00:33.501] - signal: TRUE
[17:00:33.501] - resignal: FALSE
[17:00:33.501] - force: TRUE
[17:00:33.501] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:33.501] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:00:33.501]  - until=3
[17:00:33.501]  - relaying element #3
[17:00:33.501] result() for ClusterFuture ...
[17:00:33.501] - result already collected: FutureResult
[17:00:33.501] result() for ClusterFuture ... done
[17:00:33.501] result() for ClusterFuture ...
[17:00:33.501] - result already collected: FutureResult
[17:00:33.502] result() for ClusterFuture ... done
[17:00:33.502] result() for ClusterFuture ...
[17:00:33.502] - result already collected: FutureResult
[17:00:33.502] result() for ClusterFuture ... done
[17:00:33.502] result() for ClusterFuture ...
[17:00:33.502] - result already collected: FutureResult
[17:00:33.502] result() for ClusterFuture ... done
[17:00:33.502] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:33.502] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:33.502] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:00:33.502]  length: 2 (resolved future 3)
[17:00:33.503] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.503] - Validating connection of MultisessionFuture
[17:00:33.503] - received message: FutureResult
[17:00:33.503] - Received FutureResult
[17:00:33.504] - Erased future from FutureRegistry
[17:00:33.504] result() for ClusterFuture ...
[17:00:33.504] - result already collected: FutureResult
[17:00:33.504] result() for ClusterFuture ... done
[17:00:33.504] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.504] Future #4
[17:00:33.504] result() for ClusterFuture ...
[17:00:33.504] - result already collected: FutureResult
[17:00:33.504] result() for ClusterFuture ... done
[17:00:33.504] result() for ClusterFuture ...
[17:00:33.504] - result already collected: FutureResult
[17:00:33.504] result() for ClusterFuture ... done
[17:00:33.505] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:00:33.505] - nx: 5
[17:00:33.505] - relay: TRUE
[17:00:33.505] - stdout: TRUE
[17:00:33.505] - signal: TRUE
[17:00:33.505] - resignal: FALSE
[17:00:33.505] - force: TRUE
[17:00:33.505] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:33.505] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:00:33.505]  - until=4
[17:00:33.505]  - relaying element #4
[17:00:33.505] result() for ClusterFuture ...
[17:00:33.506] - result already collected: FutureResult
[17:00:33.506] result() for ClusterFuture ... done
[17:00:33.506] result() for ClusterFuture ...
[17:00:33.506] - result already collected: FutureResult
[17:00:33.506] result() for ClusterFuture ... done
[17:00:33.506] result() for ClusterFuture ...
[17:00:33.506] - result already collected: FutureResult
[17:00:33.506] result() for ClusterFuture ... done
[17:00:33.506] result() for ClusterFuture ...
[17:00:33.506] - result already collected: FutureResult
[17:00:33.506] result() for ClusterFuture ... done
[17:00:33.506] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:33.507] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:33.507] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:00:33.507]  length: 1 (resolved future 4)
[17:00:33.528] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.528] - Validating connection of MultisessionFuture
[17:00:33.528] - received message: FutureResult
[17:00:33.528] - Received FutureResult
[17:00:33.529] - Erased future from FutureRegistry
[17:00:33.529] result() for ClusterFuture ...
[17:00:33.529] - result already collected: FutureResult
[17:00:33.529] result() for ClusterFuture ... done
[17:00:33.529] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.529] Future #5
[17:00:33.529] result() for ClusterFuture ...
[17:00:33.529] - result already collected: FutureResult
[17:00:33.529] result() for ClusterFuture ... done
[17:00:33.529] result() for ClusterFuture ...
[17:00:33.529] - result already collected: FutureResult
[17:00:33.530] result() for ClusterFuture ... done
[17:00:33.530] signalConditionsASAP(MultisessionFuture, pos=5) ...
[17:00:33.530] - nx: 5
[17:00:33.530] - relay: TRUE
[17:00:33.530] - stdout: TRUE
[17:00:33.530] - signal: TRUE
[17:00:33.530] - resignal: FALSE
[17:00:33.530] - force: TRUE
[17:00:33.530] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:33.530] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:00:33.530]  - until=5
[17:00:33.530]  - relaying element #5
[17:00:33.531] result() for ClusterFuture ...
[17:00:33.531] - result already collected: FutureResult
[17:00:33.531] result() for ClusterFuture ... done
[17:00:33.531] result() for ClusterFuture ...
[17:00:33.531] - result already collected: FutureResult
[17:00:33.531] result() for ClusterFuture ... done
[17:00:33.531] result() for ClusterFuture ...
[17:00:33.531] - result already collected: FutureResult
[17:00:33.531] result() for ClusterFuture ... done
[17:00:33.531] result() for ClusterFuture ...
[17:00:33.531] - result already collected: FutureResult
[17:00:33.532] result() for ClusterFuture ... done
[17:00:33.532] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:33.532] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:33.532] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[17:00:33.532]  length: 0 (resolved future 5)
[17:00:33.532] Relaying remaining futures
[17:00:33.532] signalConditionsASAP(NULL, pos=0) ...
[17:00:33.532] - nx: 5
[17:00:33.532] - relay: TRUE
[17:00:33.532] - stdout: TRUE
[17:00:33.532] - signal: TRUE
[17:00:33.532] - resignal: FALSE
[17:00:33.533] - force: TRUE
[17:00:33.533] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:33.533] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[17:00:33.533] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:33.533] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:00:33.533] signalConditionsASAP(NULL, pos=0) ... done
[17:00:33.533] resolve() on list ... DONE
[17:00:33.533] result() for ClusterFuture ...
[17:00:33.533] - result already collected: FutureResult
[17:00:33.533] result() for ClusterFuture ... done
[17:00:33.534] result() for ClusterFuture ...
[17:00:33.534] - result already collected: FutureResult
[17:00:33.534] result() for ClusterFuture ... done
[17:00:33.534] result() for ClusterFuture ...
[17:00:33.534] - result already collected: FutureResult
[17:00:33.534] result() for ClusterFuture ... done
[17:00:33.534] result() for ClusterFuture ...
[17:00:33.534] - result already collected: FutureResult
[17:00:33.534] result() for ClusterFuture ... done
[17:00:33.534] result() for ClusterFuture ...
[17:00:33.534] - result already collected: FutureResult
[17:00:33.534] result() for ClusterFuture ... done
[17:00:33.535] result() for ClusterFuture ...
[17:00:33.535] - result already collected: FutureResult
[17:00:33.535] result() for ClusterFuture ... done
[17:00:33.535] result() for ClusterFuture ...
[17:00:33.535] - result already collected: FutureResult
[17:00:33.535] result() for ClusterFuture ... done
[17:00:33.535] result() for ClusterFuture ...
[17:00:33.535] - result already collected: FutureResult
[17:00:33.535] result() for ClusterFuture ... done
[17:00:33.535] result() for ClusterFuture ...
[17:00:33.535] - result already collected: FutureResult
[17:00:33.536] result() for ClusterFuture ... done
[17:00:33.536] result() for ClusterFuture ...
[17:00:33.536] - result already collected: FutureResult
[17:00:33.536] result() for ClusterFuture ... done
[17:00:33.536]  - Number of value chunks collected: 5
[17:00:33.536] Resolving 5 futures (chunks) ... DONE
[17:00:33.536] Reducing values from 5 chunks ...
[17:00:33.536]  - Number of values collected after concatenation: 5
[17:00:33.536]  - Number of values expected: 5
[17:00:33.536] Reducing values from 5 chunks ... DONE
[17:00:33.536] future_mapply() ... DONE
[17:00:33.537] future_mapply() ...
[17:00:33.541] Number of chunks: 2
[17:00:33.541] getGlobalsAndPackagesXApply() ...
[17:00:33.541]  - future.globals: TRUE
[17:00:33.541] getGlobalsAndPackages() ...
[17:00:33.541] Searching for globals...
[17:00:33.542] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:33.542] Searching for globals ... DONE
[17:00:33.543] Resolving globals: FALSE
[17:00:33.543] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:33.543] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:33.543] - globals: [1] ‘FUN’
[17:00:33.544] 
[17:00:33.544] getGlobalsAndPackages() ... DONE
[17:00:33.544]  - globals found/used: [n=1] ‘FUN’
[17:00:33.544]  - needed namespaces: [n=0] 
[17:00:33.544] Finding globals ... DONE
[17:00:33.544] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:33.544] List of 2
[17:00:33.544]  $ ...future.FUN:function (C, k)  
[17:00:33.544]  $ MoreArgs     : list()
[17:00:33.544]  - attr(*, "where")=List of 2
[17:00:33.544]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:33.544]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:33.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:33.544]  - attr(*, "resolved")= logi FALSE
[17:00:33.544]  - attr(*, "total_size")= num NA
[17:00:33.547] Packages to be attached in all futures: [n=0] 
[17:00:33.547] getGlobalsAndPackagesXApply() ... DONE
[17:00:33.547] Number of futures (= number of chunks): 2
[17:00:33.547] Launching 2 futures (chunks) ...
[17:00:33.547] Chunk #1 of 2 ...
[17:00:33.547]  - Finding globals in '...' for chunk #1 ...
[17:00:33.547] getGlobalsAndPackages() ...
[17:00:33.547] Searching for globals...
[17:00:33.548] 
[17:00:33.548] Searching for globals ... DONE
[17:00:33.548] - globals: [0] <none>
[17:00:33.548] getGlobalsAndPackages() ... DONE
[17:00:33.548]    + additional globals found: [n=0] 
[17:00:33.548]    + additional namespaces needed: [n=0] 
[17:00:33.548]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:33.548]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:33.548]  - seeds: <none>
[17:00:33.549]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.549] getGlobalsAndPackages() ...
[17:00:33.549] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.549] Resolving globals: FALSE
[17:00:33.549] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:33.550] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:33.550] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.550] 
[17:00:33.550] getGlobalsAndPackages() ... DONE
[17:00:33.550] run() for ‘Future’ ...
[17:00:33.550] - state: ‘created’
[17:00:33.551] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.565] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.565]   - Field: ‘node’
[17:00:33.565]   - Field: ‘label’
[17:00:33.565]   - Field: ‘local’
[17:00:33.565]   - Field: ‘owner’
[17:00:33.565]   - Field: ‘envir’
[17:00:33.565]   - Field: ‘workers’
[17:00:33.566]   - Field: ‘packages’
[17:00:33.566]   - Field: ‘gc’
[17:00:33.566]   - Field: ‘conditions’
[17:00:33.566]   - Field: ‘persistent’
[17:00:33.566]   - Field: ‘expr’
[17:00:33.566]   - Field: ‘uuid’
[17:00:33.566]   - Field: ‘seed’
[17:00:33.566]   - Field: ‘version’
[17:00:33.566]   - Field: ‘result’
[17:00:33.566]   - Field: ‘asynchronous’
[17:00:33.566]   - Field: ‘calls’
[17:00:33.567]   - Field: ‘globals’
[17:00:33.567]   - Field: ‘stdout’
[17:00:33.567]   - Field: ‘earlySignal’
[17:00:33.567]   - Field: ‘lazy’
[17:00:33.567]   - Field: ‘state’
[17:00:33.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.567] - Launch lazy future ...
[17:00:33.567] Packages needed by the future expression (n = 0): <none>
[17:00:33.568] Packages needed by future strategies (n = 0): <none>
[17:00:33.568] {
[17:00:33.568]     {
[17:00:33.568]         {
[17:00:33.568]             ...future.startTime <- base::Sys.time()
[17:00:33.568]             {
[17:00:33.568]                 {
[17:00:33.568]                   {
[17:00:33.568]                     {
[17:00:33.568]                       base::local({
[17:00:33.568]                         has_future <- base::requireNamespace("future", 
[17:00:33.568]                           quietly = TRUE)
[17:00:33.568]                         if (has_future) {
[17:00:33.568]                           ns <- base::getNamespace("future")
[17:00:33.568]                           version <- ns[[".package"]][["version"]]
[17:00:33.568]                           if (is.null(version)) 
[17:00:33.568]                             version <- utils::packageVersion("future")
[17:00:33.568]                         }
[17:00:33.568]                         else {
[17:00:33.568]                           version <- NULL
[17:00:33.568]                         }
[17:00:33.568]                         if (!has_future || version < "1.8.0") {
[17:00:33.568]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.568]                             "", base::R.version$version.string), 
[17:00:33.568]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.568]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.568]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.568]                               "release", "version")], collapse = " "), 
[17:00:33.568]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.568]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.568]                             info)
[17:00:33.568]                           info <- base::paste(info, collapse = "; ")
[17:00:33.568]                           if (!has_future) {
[17:00:33.568]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.568]                               info)
[17:00:33.568]                           }
[17:00:33.568]                           else {
[17:00:33.568]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.568]                               info, version)
[17:00:33.568]                           }
[17:00:33.568]                           base::stop(msg)
[17:00:33.568]                         }
[17:00:33.568]                       })
[17:00:33.568]                     }
[17:00:33.568]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.568]                     base::options(mc.cores = 1L)
[17:00:33.568]                   }
[17:00:33.568]                   ...future.strategy.old <- future::plan("list")
[17:00:33.568]                   options(future.plan = NULL)
[17:00:33.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.568]                 }
[17:00:33.568]                 ...future.workdir <- getwd()
[17:00:33.568]             }
[17:00:33.568]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.568]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.568]         }
[17:00:33.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.568]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:33.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.568]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.568]             base::names(...future.oldOptions))
[17:00:33.568]     }
[17:00:33.568]     if (FALSE) {
[17:00:33.568]     }
[17:00:33.568]     else {
[17:00:33.568]         if (TRUE) {
[17:00:33.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.568]                 open = "w")
[17:00:33.568]         }
[17:00:33.568]         else {
[17:00:33.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.568]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.568]         }
[17:00:33.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.568]             base::sink(type = "output", split = FALSE)
[17:00:33.568]             base::close(...future.stdout)
[17:00:33.568]         }, add = TRUE)
[17:00:33.568]     }
[17:00:33.568]     ...future.frame <- base::sys.nframe()
[17:00:33.568]     ...future.conditions <- base::list()
[17:00:33.568]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.568]     if (FALSE) {
[17:00:33.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.568]     }
[17:00:33.568]     ...future.result <- base::tryCatch({
[17:00:33.568]         base::withCallingHandlers({
[17:00:33.568]             ...future.value <- base::withVisible(base::local({
[17:00:33.568]                 ...future.makeSendCondition <- base::local({
[17:00:33.568]                   sendCondition <- NULL
[17:00:33.568]                   function(frame = 1L) {
[17:00:33.568]                     if (is.function(sendCondition)) 
[17:00:33.568]                       return(sendCondition)
[17:00:33.568]                     ns <- getNamespace("parallel")
[17:00:33.568]                     if (exists("sendData", mode = "function", 
[17:00:33.568]                       envir = ns)) {
[17:00:33.568]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.568]                         envir = ns)
[17:00:33.568]                       envir <- sys.frame(frame)
[17:00:33.568]                       master <- NULL
[17:00:33.568]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.568]                         !identical(envir, emptyenv())) {
[17:00:33.568]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.568]                           inherits = FALSE)) {
[17:00:33.568]                           master <- get("master", mode = "list", 
[17:00:33.568]                             envir = envir, inherits = FALSE)
[17:00:33.568]                           if (inherits(master, c("SOCKnode", 
[17:00:33.568]                             "SOCK0node"))) {
[17:00:33.568]                             sendCondition <<- function(cond) {
[17:00:33.568]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.568]                                 success = TRUE)
[17:00:33.568]                               parallel_sendData(master, data)
[17:00:33.568]                             }
[17:00:33.568]                             return(sendCondition)
[17:00:33.568]                           }
[17:00:33.568]                         }
[17:00:33.568]                         frame <- frame + 1L
[17:00:33.568]                         envir <- sys.frame(frame)
[17:00:33.568]                       }
[17:00:33.568]                     }
[17:00:33.568]                     sendCondition <<- function(cond) NULL
[17:00:33.568]                   }
[17:00:33.568]                 })
[17:00:33.568]                 withCallingHandlers({
[17:00:33.568]                   {
[17:00:33.568]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.568]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.568]                       ...future.globals.maxSize)) {
[17:00:33.568]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.568]                       on.exit(options(oopts), add = TRUE)
[17:00:33.568]                     }
[17:00:33.568]                     {
[17:00:33.568]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.568]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.568]                         USE.NAMES = FALSE)
[17:00:33.568]                       do.call(mapply, args = args)
[17:00:33.568]                     }
[17:00:33.568]                   }
[17:00:33.568]                 }, immediateCondition = function(cond) {
[17:00:33.568]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.568]                   sendCondition(cond)
[17:00:33.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.568]                   {
[17:00:33.568]                     inherits <- base::inherits
[17:00:33.568]                     invokeRestart <- base::invokeRestart
[17:00:33.568]                     is.null <- base::is.null
[17:00:33.568]                     muffled <- FALSE
[17:00:33.568]                     if (inherits(cond, "message")) {
[17:00:33.568]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.568]                       if (muffled) 
[17:00:33.568]                         invokeRestart("muffleMessage")
[17:00:33.568]                     }
[17:00:33.568]                     else if (inherits(cond, "warning")) {
[17:00:33.568]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.568]                       if (muffled) 
[17:00:33.568]                         invokeRestart("muffleWarning")
[17:00:33.568]                     }
[17:00:33.568]                     else if (inherits(cond, "condition")) {
[17:00:33.568]                       if (!is.null(pattern)) {
[17:00:33.568]                         computeRestarts <- base::computeRestarts
[17:00:33.568]                         grepl <- base::grepl
[17:00:33.568]                         restarts <- computeRestarts(cond)
[17:00:33.568]                         for (restart in restarts) {
[17:00:33.568]                           name <- restart$name
[17:00:33.568]                           if (is.null(name)) 
[17:00:33.568]                             next
[17:00:33.568]                           if (!grepl(pattern, name)) 
[17:00:33.568]                             next
[17:00:33.568]                           invokeRestart(restart)
[17:00:33.568]                           muffled <- TRUE
[17:00:33.568]                           break
[17:00:33.568]                         }
[17:00:33.568]                       }
[17:00:33.568]                     }
[17:00:33.568]                     invisible(muffled)
[17:00:33.568]                   }
[17:00:33.568]                   muffleCondition(cond)
[17:00:33.568]                 })
[17:00:33.568]             }))
[17:00:33.568]             future::FutureResult(value = ...future.value$value, 
[17:00:33.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.568]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.568]                     ...future.globalenv.names))
[17:00:33.568]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.568]         }, condition = base::local({
[17:00:33.568]             c <- base::c
[17:00:33.568]             inherits <- base::inherits
[17:00:33.568]             invokeRestart <- base::invokeRestart
[17:00:33.568]             length <- base::length
[17:00:33.568]             list <- base::list
[17:00:33.568]             seq.int <- base::seq.int
[17:00:33.568]             signalCondition <- base::signalCondition
[17:00:33.568]             sys.calls <- base::sys.calls
[17:00:33.568]             `[[` <- base::`[[`
[17:00:33.568]             `+` <- base::`+`
[17:00:33.568]             `<<-` <- base::`<<-`
[17:00:33.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.568]                   3L)]
[17:00:33.568]             }
[17:00:33.568]             function(cond) {
[17:00:33.568]                 is_error <- inherits(cond, "error")
[17:00:33.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.568]                   NULL)
[17:00:33.568]                 if (is_error) {
[17:00:33.568]                   sessionInformation <- function() {
[17:00:33.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.568]                       search = base::search(), system = base::Sys.info())
[17:00:33.568]                   }
[17:00:33.568]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.568]                     cond$call), session = sessionInformation(), 
[17:00:33.568]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.568]                   signalCondition(cond)
[17:00:33.568]                 }
[17:00:33.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.568]                 "immediateCondition"))) {
[17:00:33.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.568]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.568]                   if (TRUE && !signal) {
[17:00:33.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.568]                     {
[17:00:33.568]                       inherits <- base::inherits
[17:00:33.568]                       invokeRestart <- base::invokeRestart
[17:00:33.568]                       is.null <- base::is.null
[17:00:33.568]                       muffled <- FALSE
[17:00:33.568]                       if (inherits(cond, "message")) {
[17:00:33.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.568]                         if (muffled) 
[17:00:33.568]                           invokeRestart("muffleMessage")
[17:00:33.568]                       }
[17:00:33.568]                       else if (inherits(cond, "warning")) {
[17:00:33.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.568]                         if (muffled) 
[17:00:33.568]                           invokeRestart("muffleWarning")
[17:00:33.568]                       }
[17:00:33.568]                       else if (inherits(cond, "condition")) {
[17:00:33.568]                         if (!is.null(pattern)) {
[17:00:33.568]                           computeRestarts <- base::computeRestarts
[17:00:33.568]                           grepl <- base::grepl
[17:00:33.568]                           restarts <- computeRestarts(cond)
[17:00:33.568]                           for (restart in restarts) {
[17:00:33.568]                             name <- restart$name
[17:00:33.568]                             if (is.null(name)) 
[17:00:33.568]                               next
[17:00:33.568]                             if (!grepl(pattern, name)) 
[17:00:33.568]                               next
[17:00:33.568]                             invokeRestart(restart)
[17:00:33.568]                             muffled <- TRUE
[17:00:33.568]                             break
[17:00:33.568]                           }
[17:00:33.568]                         }
[17:00:33.568]                       }
[17:00:33.568]                       invisible(muffled)
[17:00:33.568]                     }
[17:00:33.568]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.568]                   }
[17:00:33.568]                 }
[17:00:33.568]                 else {
[17:00:33.568]                   if (TRUE) {
[17:00:33.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.568]                     {
[17:00:33.568]                       inherits <- base::inherits
[17:00:33.568]                       invokeRestart <- base::invokeRestart
[17:00:33.568]                       is.null <- base::is.null
[17:00:33.568]                       muffled <- FALSE
[17:00:33.568]                       if (inherits(cond, "message")) {
[17:00:33.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.568]                         if (muffled) 
[17:00:33.568]                           invokeRestart("muffleMessage")
[17:00:33.568]                       }
[17:00:33.568]                       else if (inherits(cond, "warning")) {
[17:00:33.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.568]                         if (muffled) 
[17:00:33.568]                           invokeRestart("muffleWarning")
[17:00:33.568]                       }
[17:00:33.568]                       else if (inherits(cond, "condition")) {
[17:00:33.568]                         if (!is.null(pattern)) {
[17:00:33.568]                           computeRestarts <- base::computeRestarts
[17:00:33.568]                           grepl <- base::grepl
[17:00:33.568]                           restarts <- computeRestarts(cond)
[17:00:33.568]                           for (restart in restarts) {
[17:00:33.568]                             name <- restart$name
[17:00:33.568]                             if (is.null(name)) 
[17:00:33.568]                               next
[17:00:33.568]                             if (!grepl(pattern, name)) 
[17:00:33.568]                               next
[17:00:33.568]                             invokeRestart(restart)
[17:00:33.568]                             muffled <- TRUE
[17:00:33.568]                             break
[17:00:33.568]                           }
[17:00:33.568]                         }
[17:00:33.568]                       }
[17:00:33.568]                       invisible(muffled)
[17:00:33.568]                     }
[17:00:33.568]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.568]                   }
[17:00:33.568]                 }
[17:00:33.568]             }
[17:00:33.568]         }))
[17:00:33.568]     }, error = function(ex) {
[17:00:33.568]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.568]                 ...future.rng), started = ...future.startTime, 
[17:00:33.568]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.568]             version = "1.8"), class = "FutureResult")
[17:00:33.568]     }, finally = {
[17:00:33.568]         if (!identical(...future.workdir, getwd())) 
[17:00:33.568]             setwd(...future.workdir)
[17:00:33.568]         {
[17:00:33.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.568]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.568]             }
[17:00:33.568]             base::options(...future.oldOptions)
[17:00:33.568]             if (.Platform$OS.type == "windows") {
[17:00:33.568]                 old_names <- names(...future.oldEnvVars)
[17:00:33.568]                 envs <- base::Sys.getenv()
[17:00:33.568]                 names <- names(envs)
[17:00:33.568]                 common <- intersect(names, old_names)
[17:00:33.568]                 added <- setdiff(names, old_names)
[17:00:33.568]                 removed <- setdiff(old_names, names)
[17:00:33.568]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.568]                   envs[common]]
[17:00:33.568]                 NAMES <- toupper(changed)
[17:00:33.568]                 args <- list()
[17:00:33.568]                 for (kk in seq_along(NAMES)) {
[17:00:33.568]                   name <- changed[[kk]]
[17:00:33.568]                   NAME <- NAMES[[kk]]
[17:00:33.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.568]                     next
[17:00:33.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.568]                 }
[17:00:33.568]                 NAMES <- toupper(added)
[17:00:33.568]                 for (kk in seq_along(NAMES)) {
[17:00:33.568]                   name <- added[[kk]]
[17:00:33.568]                   NAME <- NAMES[[kk]]
[17:00:33.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.568]                     next
[17:00:33.568]                   args[[name]] <- ""
[17:00:33.568]                 }
[17:00:33.568]                 NAMES <- toupper(removed)
[17:00:33.568]                 for (kk in seq_along(NAMES)) {
[17:00:33.568]                   name <- removed[[kk]]
[17:00:33.568]                   NAME <- NAMES[[kk]]
[17:00:33.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.568]                     next
[17:00:33.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.568]                 }
[17:00:33.568]                 if (length(args) > 0) 
[17:00:33.568]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.568]             }
[17:00:33.568]             else {
[17:00:33.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.568]             }
[17:00:33.568]             {
[17:00:33.568]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.568]                   0L) {
[17:00:33.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.568]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.568]                   base::options(opts)
[17:00:33.568]                 }
[17:00:33.568]                 {
[17:00:33.568]                   {
[17:00:33.568]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.568]                     NULL
[17:00:33.568]                   }
[17:00:33.568]                   options(future.plan = NULL)
[17:00:33.568]                   if (is.na(NA_character_)) 
[17:00:33.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.568]                     .init = FALSE)
[17:00:33.568]                 }
[17:00:33.568]             }
[17:00:33.568]         }
[17:00:33.568]     })
[17:00:33.568]     if (TRUE) {
[17:00:33.568]         base::sink(type = "output", split = FALSE)
[17:00:33.568]         if (TRUE) {
[17:00:33.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.568]         }
[17:00:33.568]         else {
[17:00:33.568]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.568]         }
[17:00:33.568]         base::close(...future.stdout)
[17:00:33.568]         ...future.stdout <- NULL
[17:00:33.568]     }
[17:00:33.568]     ...future.result$conditions <- ...future.conditions
[17:00:33.568]     ...future.result$finished <- base::Sys.time()
[17:00:33.568]     ...future.result
[17:00:33.568] }
[17:00:33.571] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:00:33.571] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:00:33.571] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:00:33.571] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:33.572] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.572] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:00:33.572] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:00:33.572] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:33.573] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.573] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:33.573] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.573] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:00:33.574] MultisessionFuture started
[17:00:33.574] - Launch lazy future ... done
[17:00:33.574] run() for ‘MultisessionFuture’ ... done
[17:00:33.574] Created future:
[17:00:33.574] MultisessionFuture:
[17:00:33.574] Label: ‘future_.mapply-1’
[17:00:33.574] Expression:
[17:00:33.574] {
[17:00:33.574]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.574]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.574]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.574]         on.exit(options(oopts), add = TRUE)
[17:00:33.574]     }
[17:00:33.574]     {
[17:00:33.574]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.574]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.574]         do.call(mapply, args = args)
[17:00:33.574]     }
[17:00:33.574] }
[17:00:33.574] Lazy evaluation: FALSE
[17:00:33.574] Asynchronous evaluation: TRUE
[17:00:33.574] Local evaluation: TRUE
[17:00:33.574] Environment: R_GlobalEnv
[17:00:33.574] Capture standard output: TRUE
[17:00:33.574] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.574] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.574] Packages: <none>
[17:00:33.574] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.574] Resolved: FALSE
[17:00:33.574] Value: <not collected>
[17:00:33.574] Conditions captured: <none>
[17:00:33.574] Early signaling: FALSE
[17:00:33.574] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.574] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.586] Chunk #1 of 2 ... DONE
[17:00:33.586] Chunk #2 of 2 ...
[17:00:33.586]  - Finding globals in '...' for chunk #2 ...
[17:00:33.586] getGlobalsAndPackages() ...
[17:00:33.586] Searching for globals...
[17:00:33.586] 
[17:00:33.586] Searching for globals ... DONE
[17:00:33.587] - globals: [0] <none>
[17:00:33.587] getGlobalsAndPackages() ... DONE
[17:00:33.587]    + additional globals found: [n=0] 
[17:00:33.587]    + additional namespaces needed: [n=0] 
[17:00:33.587]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:33.587]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:33.587]  - seeds: <none>
[17:00:33.587]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.587] getGlobalsAndPackages() ...
[17:00:33.587] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.588] Resolving globals: FALSE
[17:00:33.588] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:00:33.588] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:33.589] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.589] 
[17:00:33.589] getGlobalsAndPackages() ... DONE
[17:00:33.589] run() for ‘Future’ ...
[17:00:33.589] - state: ‘created’
[17:00:33.589] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.606] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.606] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.606]   - Field: ‘node’
[17:00:33.606]   - Field: ‘label’
[17:00:33.606]   - Field: ‘local’
[17:00:33.606]   - Field: ‘owner’
[17:00:33.607]   - Field: ‘envir’
[17:00:33.607]   - Field: ‘workers’
[17:00:33.607]   - Field: ‘packages’
[17:00:33.607]   - Field: ‘gc’
[17:00:33.607]   - Field: ‘conditions’
[17:00:33.607]   - Field: ‘persistent’
[17:00:33.607]   - Field: ‘expr’
[17:00:33.607]   - Field: ‘uuid’
[17:00:33.607]   - Field: ‘seed’
[17:00:33.607]   - Field: ‘version’
[17:00:33.608]   - Field: ‘result’
[17:00:33.608]   - Field: ‘asynchronous’
[17:00:33.608]   - Field: ‘calls’
[17:00:33.608]   - Field: ‘globals’
[17:00:33.608]   - Field: ‘stdout’
[17:00:33.608]   - Field: ‘earlySignal’
[17:00:33.608]   - Field: ‘lazy’
[17:00:33.608]   - Field: ‘state’
[17:00:33.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.608] - Launch lazy future ...
[17:00:33.609] Packages needed by the future expression (n = 0): <none>
[17:00:33.609] Packages needed by future strategies (n = 0): <none>
[17:00:33.609] {
[17:00:33.609]     {
[17:00:33.609]         {
[17:00:33.609]             ...future.startTime <- base::Sys.time()
[17:00:33.609]             {
[17:00:33.609]                 {
[17:00:33.609]                   {
[17:00:33.609]                     {
[17:00:33.609]                       base::local({
[17:00:33.609]                         has_future <- base::requireNamespace("future", 
[17:00:33.609]                           quietly = TRUE)
[17:00:33.609]                         if (has_future) {
[17:00:33.609]                           ns <- base::getNamespace("future")
[17:00:33.609]                           version <- ns[[".package"]][["version"]]
[17:00:33.609]                           if (is.null(version)) 
[17:00:33.609]                             version <- utils::packageVersion("future")
[17:00:33.609]                         }
[17:00:33.609]                         else {
[17:00:33.609]                           version <- NULL
[17:00:33.609]                         }
[17:00:33.609]                         if (!has_future || version < "1.8.0") {
[17:00:33.609]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.609]                             "", base::R.version$version.string), 
[17:00:33.609]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.609]                               "release", "version")], collapse = " "), 
[17:00:33.609]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.609]                             info)
[17:00:33.609]                           info <- base::paste(info, collapse = "; ")
[17:00:33.609]                           if (!has_future) {
[17:00:33.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.609]                               info)
[17:00:33.609]                           }
[17:00:33.609]                           else {
[17:00:33.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.609]                               info, version)
[17:00:33.609]                           }
[17:00:33.609]                           base::stop(msg)
[17:00:33.609]                         }
[17:00:33.609]                       })
[17:00:33.609]                     }
[17:00:33.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.609]                     base::options(mc.cores = 1L)
[17:00:33.609]                   }
[17:00:33.609]                   ...future.strategy.old <- future::plan("list")
[17:00:33.609]                   options(future.plan = NULL)
[17:00:33.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.609]                 }
[17:00:33.609]                 ...future.workdir <- getwd()
[17:00:33.609]             }
[17:00:33.609]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.609]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.609]         }
[17:00:33.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.609]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:33.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.609]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.609]             base::names(...future.oldOptions))
[17:00:33.609]     }
[17:00:33.609]     if (FALSE) {
[17:00:33.609]     }
[17:00:33.609]     else {
[17:00:33.609]         if (TRUE) {
[17:00:33.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.609]                 open = "w")
[17:00:33.609]         }
[17:00:33.609]         else {
[17:00:33.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.609]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.609]         }
[17:00:33.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.609]             base::sink(type = "output", split = FALSE)
[17:00:33.609]             base::close(...future.stdout)
[17:00:33.609]         }, add = TRUE)
[17:00:33.609]     }
[17:00:33.609]     ...future.frame <- base::sys.nframe()
[17:00:33.609]     ...future.conditions <- base::list()
[17:00:33.609]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.609]     if (FALSE) {
[17:00:33.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.609]     }
[17:00:33.609]     ...future.result <- base::tryCatch({
[17:00:33.609]         base::withCallingHandlers({
[17:00:33.609]             ...future.value <- base::withVisible(base::local({
[17:00:33.609]                 ...future.makeSendCondition <- base::local({
[17:00:33.609]                   sendCondition <- NULL
[17:00:33.609]                   function(frame = 1L) {
[17:00:33.609]                     if (is.function(sendCondition)) 
[17:00:33.609]                       return(sendCondition)
[17:00:33.609]                     ns <- getNamespace("parallel")
[17:00:33.609]                     if (exists("sendData", mode = "function", 
[17:00:33.609]                       envir = ns)) {
[17:00:33.609]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.609]                         envir = ns)
[17:00:33.609]                       envir <- sys.frame(frame)
[17:00:33.609]                       master <- NULL
[17:00:33.609]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.609]                         !identical(envir, emptyenv())) {
[17:00:33.609]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.609]                           inherits = FALSE)) {
[17:00:33.609]                           master <- get("master", mode = "list", 
[17:00:33.609]                             envir = envir, inherits = FALSE)
[17:00:33.609]                           if (inherits(master, c("SOCKnode", 
[17:00:33.609]                             "SOCK0node"))) {
[17:00:33.609]                             sendCondition <<- function(cond) {
[17:00:33.609]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.609]                                 success = TRUE)
[17:00:33.609]                               parallel_sendData(master, data)
[17:00:33.609]                             }
[17:00:33.609]                             return(sendCondition)
[17:00:33.609]                           }
[17:00:33.609]                         }
[17:00:33.609]                         frame <- frame + 1L
[17:00:33.609]                         envir <- sys.frame(frame)
[17:00:33.609]                       }
[17:00:33.609]                     }
[17:00:33.609]                     sendCondition <<- function(cond) NULL
[17:00:33.609]                   }
[17:00:33.609]                 })
[17:00:33.609]                 withCallingHandlers({
[17:00:33.609]                   {
[17:00:33.609]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.609]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.609]                       ...future.globals.maxSize)) {
[17:00:33.609]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.609]                       on.exit(options(oopts), add = TRUE)
[17:00:33.609]                     }
[17:00:33.609]                     {
[17:00:33.609]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.609]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.609]                         USE.NAMES = FALSE)
[17:00:33.609]                       do.call(mapply, args = args)
[17:00:33.609]                     }
[17:00:33.609]                   }
[17:00:33.609]                 }, immediateCondition = function(cond) {
[17:00:33.609]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.609]                   sendCondition(cond)
[17:00:33.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.609]                   {
[17:00:33.609]                     inherits <- base::inherits
[17:00:33.609]                     invokeRestart <- base::invokeRestart
[17:00:33.609]                     is.null <- base::is.null
[17:00:33.609]                     muffled <- FALSE
[17:00:33.609]                     if (inherits(cond, "message")) {
[17:00:33.609]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.609]                       if (muffled) 
[17:00:33.609]                         invokeRestart("muffleMessage")
[17:00:33.609]                     }
[17:00:33.609]                     else if (inherits(cond, "warning")) {
[17:00:33.609]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.609]                       if (muffled) 
[17:00:33.609]                         invokeRestart("muffleWarning")
[17:00:33.609]                     }
[17:00:33.609]                     else if (inherits(cond, "condition")) {
[17:00:33.609]                       if (!is.null(pattern)) {
[17:00:33.609]                         computeRestarts <- base::computeRestarts
[17:00:33.609]                         grepl <- base::grepl
[17:00:33.609]                         restarts <- computeRestarts(cond)
[17:00:33.609]                         for (restart in restarts) {
[17:00:33.609]                           name <- restart$name
[17:00:33.609]                           if (is.null(name)) 
[17:00:33.609]                             next
[17:00:33.609]                           if (!grepl(pattern, name)) 
[17:00:33.609]                             next
[17:00:33.609]                           invokeRestart(restart)
[17:00:33.609]                           muffled <- TRUE
[17:00:33.609]                           break
[17:00:33.609]                         }
[17:00:33.609]                       }
[17:00:33.609]                     }
[17:00:33.609]                     invisible(muffled)
[17:00:33.609]                   }
[17:00:33.609]                   muffleCondition(cond)
[17:00:33.609]                 })
[17:00:33.609]             }))
[17:00:33.609]             future::FutureResult(value = ...future.value$value, 
[17:00:33.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.609]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.609]                     ...future.globalenv.names))
[17:00:33.609]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.609]         }, condition = base::local({
[17:00:33.609]             c <- base::c
[17:00:33.609]             inherits <- base::inherits
[17:00:33.609]             invokeRestart <- base::invokeRestart
[17:00:33.609]             length <- base::length
[17:00:33.609]             list <- base::list
[17:00:33.609]             seq.int <- base::seq.int
[17:00:33.609]             signalCondition <- base::signalCondition
[17:00:33.609]             sys.calls <- base::sys.calls
[17:00:33.609]             `[[` <- base::`[[`
[17:00:33.609]             `+` <- base::`+`
[17:00:33.609]             `<<-` <- base::`<<-`
[17:00:33.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.609]                   3L)]
[17:00:33.609]             }
[17:00:33.609]             function(cond) {
[17:00:33.609]                 is_error <- inherits(cond, "error")
[17:00:33.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.609]                   NULL)
[17:00:33.609]                 if (is_error) {
[17:00:33.609]                   sessionInformation <- function() {
[17:00:33.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.609]                       search = base::search(), system = base::Sys.info())
[17:00:33.609]                   }
[17:00:33.609]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.609]                     cond$call), session = sessionInformation(), 
[17:00:33.609]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.609]                   signalCondition(cond)
[17:00:33.609]                 }
[17:00:33.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.609]                 "immediateCondition"))) {
[17:00:33.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.609]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.609]                   if (TRUE && !signal) {
[17:00:33.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.609]                     {
[17:00:33.609]                       inherits <- base::inherits
[17:00:33.609]                       invokeRestart <- base::invokeRestart
[17:00:33.609]                       is.null <- base::is.null
[17:00:33.609]                       muffled <- FALSE
[17:00:33.609]                       if (inherits(cond, "message")) {
[17:00:33.609]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.609]                         if (muffled) 
[17:00:33.609]                           invokeRestart("muffleMessage")
[17:00:33.609]                       }
[17:00:33.609]                       else if (inherits(cond, "warning")) {
[17:00:33.609]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.609]                         if (muffled) 
[17:00:33.609]                           invokeRestart("muffleWarning")
[17:00:33.609]                       }
[17:00:33.609]                       else if (inherits(cond, "condition")) {
[17:00:33.609]                         if (!is.null(pattern)) {
[17:00:33.609]                           computeRestarts <- base::computeRestarts
[17:00:33.609]                           grepl <- base::grepl
[17:00:33.609]                           restarts <- computeRestarts(cond)
[17:00:33.609]                           for (restart in restarts) {
[17:00:33.609]                             name <- restart$name
[17:00:33.609]                             if (is.null(name)) 
[17:00:33.609]                               next
[17:00:33.609]                             if (!grepl(pattern, name)) 
[17:00:33.609]                               next
[17:00:33.609]                             invokeRestart(restart)
[17:00:33.609]                             muffled <- TRUE
[17:00:33.609]                             break
[17:00:33.609]                           }
[17:00:33.609]                         }
[17:00:33.609]                       }
[17:00:33.609]                       invisible(muffled)
[17:00:33.609]                     }
[17:00:33.609]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.609]                   }
[17:00:33.609]                 }
[17:00:33.609]                 else {
[17:00:33.609]                   if (TRUE) {
[17:00:33.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.609]                     {
[17:00:33.609]                       inherits <- base::inherits
[17:00:33.609]                       invokeRestart <- base::invokeRestart
[17:00:33.609]                       is.null <- base::is.null
[17:00:33.609]                       muffled <- FALSE
[17:00:33.609]                       if (inherits(cond, "message")) {
[17:00:33.609]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.609]                         if (muffled) 
[17:00:33.609]                           invokeRestart("muffleMessage")
[17:00:33.609]                       }
[17:00:33.609]                       else if (inherits(cond, "warning")) {
[17:00:33.609]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.609]                         if (muffled) 
[17:00:33.609]                           invokeRestart("muffleWarning")
[17:00:33.609]                       }
[17:00:33.609]                       else if (inherits(cond, "condition")) {
[17:00:33.609]                         if (!is.null(pattern)) {
[17:00:33.609]                           computeRestarts <- base::computeRestarts
[17:00:33.609]                           grepl <- base::grepl
[17:00:33.609]                           restarts <- computeRestarts(cond)
[17:00:33.609]                           for (restart in restarts) {
[17:00:33.609]                             name <- restart$name
[17:00:33.609]                             if (is.null(name)) 
[17:00:33.609]                               next
[17:00:33.609]                             if (!grepl(pattern, name)) 
[17:00:33.609]                               next
[17:00:33.609]                             invokeRestart(restart)
[17:00:33.609]                             muffled <- TRUE
[17:00:33.609]                             break
[17:00:33.609]                           }
[17:00:33.609]                         }
[17:00:33.609]                       }
[17:00:33.609]                       invisible(muffled)
[17:00:33.609]                     }
[17:00:33.609]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.609]                   }
[17:00:33.609]                 }
[17:00:33.609]             }
[17:00:33.609]         }))
[17:00:33.609]     }, error = function(ex) {
[17:00:33.609]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.609]                 ...future.rng), started = ...future.startTime, 
[17:00:33.609]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.609]             version = "1.8"), class = "FutureResult")
[17:00:33.609]     }, finally = {
[17:00:33.609]         if (!identical(...future.workdir, getwd())) 
[17:00:33.609]             setwd(...future.workdir)
[17:00:33.609]         {
[17:00:33.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.609]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.609]             }
[17:00:33.609]             base::options(...future.oldOptions)
[17:00:33.609]             if (.Platform$OS.type == "windows") {
[17:00:33.609]                 old_names <- names(...future.oldEnvVars)
[17:00:33.609]                 envs <- base::Sys.getenv()
[17:00:33.609]                 names <- names(envs)
[17:00:33.609]                 common <- intersect(names, old_names)
[17:00:33.609]                 added <- setdiff(names, old_names)
[17:00:33.609]                 removed <- setdiff(old_names, names)
[17:00:33.609]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.609]                   envs[common]]
[17:00:33.609]                 NAMES <- toupper(changed)
[17:00:33.609]                 args <- list()
[17:00:33.609]                 for (kk in seq_along(NAMES)) {
[17:00:33.609]                   name <- changed[[kk]]
[17:00:33.609]                   NAME <- NAMES[[kk]]
[17:00:33.609]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.609]                     next
[17:00:33.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.609]                 }
[17:00:33.609]                 NAMES <- toupper(added)
[17:00:33.609]                 for (kk in seq_along(NAMES)) {
[17:00:33.609]                   name <- added[[kk]]
[17:00:33.609]                   NAME <- NAMES[[kk]]
[17:00:33.609]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.609]                     next
[17:00:33.609]                   args[[name]] <- ""
[17:00:33.609]                 }
[17:00:33.609]                 NAMES <- toupper(removed)
[17:00:33.609]                 for (kk in seq_along(NAMES)) {
[17:00:33.609]                   name <- removed[[kk]]
[17:00:33.609]                   NAME <- NAMES[[kk]]
[17:00:33.609]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.609]                     next
[17:00:33.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.609]                 }
[17:00:33.609]                 if (length(args) > 0) 
[17:00:33.609]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.609]             }
[17:00:33.609]             else {
[17:00:33.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.609]             }
[17:00:33.609]             {
[17:00:33.609]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.609]                   0L) {
[17:00:33.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.609]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.609]                   base::options(opts)
[17:00:33.609]                 }
[17:00:33.609]                 {
[17:00:33.609]                   {
[17:00:33.609]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.609]                     NULL
[17:00:33.609]                   }
[17:00:33.609]                   options(future.plan = NULL)
[17:00:33.609]                   if (is.na(NA_character_)) 
[17:00:33.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.609]                     .init = FALSE)
[17:00:33.609]                 }
[17:00:33.609]             }
[17:00:33.609]         }
[17:00:33.609]     })
[17:00:33.609]     if (TRUE) {
[17:00:33.609]         base::sink(type = "output", split = FALSE)
[17:00:33.609]         if (TRUE) {
[17:00:33.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.609]         }
[17:00:33.609]         else {
[17:00:33.609]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.609]         }
[17:00:33.609]         base::close(...future.stdout)
[17:00:33.609]         ...future.stdout <- NULL
[17:00:33.609]     }
[17:00:33.609]     ...future.result$conditions <- ...future.conditions
[17:00:33.609]     ...future.result$finished <- base::Sys.time()
[17:00:33.609]     ...future.result
[17:00:33.609] }
[17:00:33.612] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:00:33.612] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:00:33.612] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:00:33.613] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:33.613] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.613] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:00:33.614] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:00:33.614] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:33.614] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.614] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:33.614] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.615] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:00:33.615] MultisessionFuture started
[17:00:33.615] - Launch lazy future ... done
[17:00:33.615] run() for ‘MultisessionFuture’ ... done
[17:00:33.616] Created future:
[17:00:33.616] MultisessionFuture:
[17:00:33.616] Label: ‘future_.mapply-2’
[17:00:33.616] Expression:
[17:00:33.616] {
[17:00:33.616]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.616]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.616]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.616]         on.exit(options(oopts), add = TRUE)
[17:00:33.616]     }
[17:00:33.616]     {
[17:00:33.616]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.616]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.616]         do.call(mapply, args = args)
[17:00:33.616]     }
[17:00:33.616] }
[17:00:33.616] Lazy evaluation: FALSE
[17:00:33.616] Asynchronous evaluation: TRUE
[17:00:33.616] Local evaluation: TRUE
[17:00:33.616] Environment: R_GlobalEnv
[17:00:33.616] Capture standard output: TRUE
[17:00:33.616] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.616] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.616] Packages: <none>
[17:00:33.616] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.616] Resolved: FALSE
[17:00:33.616] Value: <not collected>
[17:00:33.616] Conditions captured: <none>
[17:00:33.616] Early signaling: FALSE
[17:00:33.616] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.616] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.627] Chunk #2 of 2 ... DONE
[17:00:33.627] Launching 2 futures (chunks) ... DONE
[17:00:33.628] Resolving 2 futures (chunks) ...
[17:00:33.628] resolve() on list ...
[17:00:33.628]  recursive: 0
[17:00:33.628]  length: 2
[17:00:33.628] 
[17:00:33.629] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.629] - Validating connection of MultisessionFuture
[17:00:33.629] - received message: FutureResult
[17:00:33.629] - Received FutureResult
[17:00:33.629] - Erased future from FutureRegistry
[17:00:33.629] result() for ClusterFuture ...
[17:00:33.629] - result already collected: FutureResult
[17:00:33.629] result() for ClusterFuture ... done
[17:00:33.629] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.629] Future #1
[17:00:33.630] result() for ClusterFuture ...
[17:00:33.630] - result already collected: FutureResult
[17:00:33.630] result() for ClusterFuture ... done
[17:00:33.630] result() for ClusterFuture ...
[17:00:33.630] - result already collected: FutureResult
[17:00:33.630] result() for ClusterFuture ... done
[17:00:33.630] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:33.630] - nx: 2
[17:00:33.630] - relay: TRUE
[17:00:33.630] - stdout: TRUE
[17:00:33.630] - signal: TRUE
[17:00:33.630] - resignal: FALSE
[17:00:33.631] - force: TRUE
[17:00:33.631] - relayed: [n=2] FALSE, FALSE
[17:00:33.631] - queued futures: [n=2] FALSE, FALSE
[17:00:33.631]  - until=1
[17:00:33.631]  - relaying element #1
[17:00:33.631] result() for ClusterFuture ...
[17:00:33.631] - result already collected: FutureResult
[17:00:33.631] result() for ClusterFuture ... done
[17:00:33.631] result() for ClusterFuture ...
[17:00:33.631] - result already collected: FutureResult
[17:00:33.631] result() for ClusterFuture ... done
[17:00:33.632] result() for ClusterFuture ...
[17:00:33.632] - result already collected: FutureResult
[17:00:33.632] result() for ClusterFuture ... done
[17:00:33.632] result() for ClusterFuture ...
[17:00:33.632] - result already collected: FutureResult
[17:00:33.632] result() for ClusterFuture ... done
[17:00:33.632] - relayed: [n=2] TRUE, FALSE
[17:00:33.632] - queued futures: [n=2] TRUE, FALSE
[17:00:33.632] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:33.632]  length: 1 (resolved future 1)
[17:00:33.657] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.657] - Validating connection of MultisessionFuture
[17:00:33.657] - received message: FutureResult
[17:00:33.657] - Received FutureResult
[17:00:33.658] - Erased future from FutureRegistry
[17:00:33.658] result() for ClusterFuture ...
[17:00:33.658] - result already collected: FutureResult
[17:00:33.658] result() for ClusterFuture ... done
[17:00:33.658] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.658] Future #2
[17:00:33.658] result() for ClusterFuture ...
[17:00:33.658] - result already collected: FutureResult
[17:00:33.658] result() for ClusterFuture ... done
[17:00:33.658] result() for ClusterFuture ...
[17:00:33.658] - result already collected: FutureResult
[17:00:33.659] result() for ClusterFuture ... done
[17:00:33.659] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:33.659] - nx: 2
[17:00:33.659] - relay: TRUE
[17:00:33.659] - stdout: TRUE
[17:00:33.659] - signal: TRUE
[17:00:33.659] - resignal: FALSE
[17:00:33.659] - force: TRUE
[17:00:33.659] - relayed: [n=2] TRUE, FALSE
[17:00:33.659] - queued futures: [n=2] TRUE, FALSE
[17:00:33.660]  - until=2
[17:00:33.660]  - relaying element #2
[17:00:33.660] result() for ClusterFuture ...
[17:00:33.660] - result already collected: FutureResult
[17:00:33.660] result() for ClusterFuture ... done
[17:00:33.660] result() for ClusterFuture ...
[17:00:33.660] - result already collected: FutureResult
[17:00:33.660] result() for ClusterFuture ... done
[17:00:33.660] result() for ClusterFuture ...
[17:00:33.660] - result already collected: FutureResult
[17:00:33.660] result() for ClusterFuture ... done
[17:00:33.661] result() for ClusterFuture ...
[17:00:33.661] - result already collected: FutureResult
[17:00:33.661] result() for ClusterFuture ... done
[17:00:33.661] - relayed: [n=2] TRUE, TRUE
[17:00:33.661] - queued futures: [n=2] TRUE, TRUE
[17:00:33.661] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:33.661]  length: 0 (resolved future 2)
[17:00:33.661] Relaying remaining futures
[17:00:33.661] signalConditionsASAP(NULL, pos=0) ...
[17:00:33.661] - nx: 2
[17:00:33.661] - relay: TRUE
[17:00:33.661] - stdout: TRUE
[17:00:33.662] - signal: TRUE
[17:00:33.662] - resignal: FALSE
[17:00:33.662] - force: TRUE
[17:00:33.662] - relayed: [n=2] TRUE, TRUE
[17:00:33.662] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:33.662] - relayed: [n=2] TRUE, TRUE
[17:00:33.662] - queued futures: [n=2] TRUE, TRUE
[17:00:33.662] signalConditionsASAP(NULL, pos=0) ... done
[17:00:33.662] resolve() on list ... DONE
[17:00:33.662] result() for ClusterFuture ...
[17:00:33.662] - result already collected: FutureResult
[17:00:33.663] result() for ClusterFuture ... done
[17:00:33.663] result() for ClusterFuture ...
[17:00:33.663] - result already collected: FutureResult
[17:00:33.663] result() for ClusterFuture ... done
[17:00:33.663] result() for ClusterFuture ...
[17:00:33.663] - result already collected: FutureResult
[17:00:33.663] result() for ClusterFuture ... done
[17:00:33.663] result() for ClusterFuture ...
[17:00:33.663] - result already collected: FutureResult
[17:00:33.663] result() for ClusterFuture ... done
[17:00:33.663]  - Number of value chunks collected: 2
[17:00:33.664] Resolving 2 futures (chunks) ... DONE
[17:00:33.664] Reducing values from 2 chunks ...
[17:00:33.664]  - Number of values collected after concatenation: 5
[17:00:33.664]  - Number of values expected: 5
[17:00:33.664] Reducing values from 2 chunks ... DONE
[17:00:33.664] future_mapply() ... DONE
[17:00:33.664] future_mapply() ...
[17:00:33.668] Number of chunks: 3
[17:00:33.668] Index remapping (attribute 'ordering'): [n = 5] 3, 2, 5, 1, 4
[17:00:33.668] getGlobalsAndPackagesXApply() ...
[17:00:33.668]  - future.globals: TRUE
[17:00:33.669] getGlobalsAndPackages() ...
[17:00:33.669] Searching for globals...
[17:00:33.670] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:33.670] Searching for globals ... DONE
[17:00:33.670] Resolving globals: FALSE
[17:00:33.671] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:33.671] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:33.671] - globals: [1] ‘FUN’
[17:00:33.671] 
[17:00:33.671] getGlobalsAndPackages() ... DONE
[17:00:33.671]  - globals found/used: [n=1] ‘FUN’
[17:00:33.671]  - needed namespaces: [n=0] 
[17:00:33.671] Finding globals ... DONE
[17:00:33.672] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:33.672] List of 2
[17:00:33.672]  $ ...future.FUN:function (C, k)  
[17:00:33.672]  $ MoreArgs     : NULL
[17:00:33.672]  - attr(*, "where")=List of 2
[17:00:33.672]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:33.672]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:33.672]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:33.672]  - attr(*, "resolved")= logi FALSE
[17:00:33.672]  - attr(*, "total_size")= num NA
[17:00:33.674] Packages to be attached in all futures: [n=0] 
[17:00:33.674] getGlobalsAndPackagesXApply() ... DONE
[17:00:33.674] Number of futures (= number of chunks): 3
[17:00:33.675] Launching 3 futures (chunks) ...
[17:00:33.675] Chunk #1 of 3 ...
[17:00:33.675]  - Finding globals in '...' for chunk #1 ...
[17:00:33.675] getGlobalsAndPackages() ...
[17:00:33.675] Searching for globals...
[17:00:33.675] 
[17:00:33.675] Searching for globals ... DONE
[17:00:33.676] - globals: [0] <none>
[17:00:33.676] getGlobalsAndPackages() ... DONE
[17:00:33.676]    + additional globals found: [n=0] 
[17:00:33.676]    + additional namespaces needed: [n=0] 
[17:00:33.676]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:33.676]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:00:33.676]  - seeds: <none>
[17:00:33.676]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.676] getGlobalsAndPackages() ...
[17:00:33.676] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.676] Resolving globals: FALSE
[17:00:33.677] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:33.677] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.677] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.678] 
[17:00:33.678] getGlobalsAndPackages() ... DONE
[17:00:33.678] run() for ‘Future’ ...
[17:00:33.678] - state: ‘created’
[17:00:33.678] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.692] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.692] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.692]   - Field: ‘node’
[17:00:33.693]   - Field: ‘label’
[17:00:33.693]   - Field: ‘local’
[17:00:33.693]   - Field: ‘owner’
[17:00:33.693]   - Field: ‘envir’
[17:00:33.693]   - Field: ‘workers’
[17:00:33.693]   - Field: ‘packages’
[17:00:33.693]   - Field: ‘gc’
[17:00:33.693]   - Field: ‘conditions’
[17:00:33.693]   - Field: ‘persistent’
[17:00:33.693]   - Field: ‘expr’
[17:00:33.693]   - Field: ‘uuid’
[17:00:33.694]   - Field: ‘seed’
[17:00:33.694]   - Field: ‘version’
[17:00:33.694]   - Field: ‘result’
[17:00:33.694]   - Field: ‘asynchronous’
[17:00:33.694]   - Field: ‘calls’
[17:00:33.694]   - Field: ‘globals’
[17:00:33.694]   - Field: ‘stdout’
[17:00:33.694]   - Field: ‘earlySignal’
[17:00:33.694]   - Field: ‘lazy’
[17:00:33.694]   - Field: ‘state’
[17:00:33.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.694] - Launch lazy future ...
[17:00:33.695] Packages needed by the future expression (n = 0): <none>
[17:00:33.695] Packages needed by future strategies (n = 0): <none>
[17:00:33.695] {
[17:00:33.695]     {
[17:00:33.695]         {
[17:00:33.695]             ...future.startTime <- base::Sys.time()
[17:00:33.695]             {
[17:00:33.695]                 {
[17:00:33.695]                   {
[17:00:33.695]                     {
[17:00:33.695]                       base::local({
[17:00:33.695]                         has_future <- base::requireNamespace("future", 
[17:00:33.695]                           quietly = TRUE)
[17:00:33.695]                         if (has_future) {
[17:00:33.695]                           ns <- base::getNamespace("future")
[17:00:33.695]                           version <- ns[[".package"]][["version"]]
[17:00:33.695]                           if (is.null(version)) 
[17:00:33.695]                             version <- utils::packageVersion("future")
[17:00:33.695]                         }
[17:00:33.695]                         else {
[17:00:33.695]                           version <- NULL
[17:00:33.695]                         }
[17:00:33.695]                         if (!has_future || version < "1.8.0") {
[17:00:33.695]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.695]                             "", base::R.version$version.string), 
[17:00:33.695]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.695]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.695]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.695]                               "release", "version")], collapse = " "), 
[17:00:33.695]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.695]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.695]                             info)
[17:00:33.695]                           info <- base::paste(info, collapse = "; ")
[17:00:33.695]                           if (!has_future) {
[17:00:33.695]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.695]                               info)
[17:00:33.695]                           }
[17:00:33.695]                           else {
[17:00:33.695]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.695]                               info, version)
[17:00:33.695]                           }
[17:00:33.695]                           base::stop(msg)
[17:00:33.695]                         }
[17:00:33.695]                       })
[17:00:33.695]                     }
[17:00:33.695]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.695]                     base::options(mc.cores = 1L)
[17:00:33.695]                   }
[17:00:33.695]                   ...future.strategy.old <- future::plan("list")
[17:00:33.695]                   options(future.plan = NULL)
[17:00:33.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.695]                 }
[17:00:33.695]                 ...future.workdir <- getwd()
[17:00:33.695]             }
[17:00:33.695]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.695]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.695]         }
[17:00:33.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.695]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:00:33.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.695]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.695]             base::names(...future.oldOptions))
[17:00:33.695]     }
[17:00:33.695]     if (FALSE) {
[17:00:33.695]     }
[17:00:33.695]     else {
[17:00:33.695]         if (TRUE) {
[17:00:33.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.695]                 open = "w")
[17:00:33.695]         }
[17:00:33.695]         else {
[17:00:33.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.695]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.695]         }
[17:00:33.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.695]             base::sink(type = "output", split = FALSE)
[17:00:33.695]             base::close(...future.stdout)
[17:00:33.695]         }, add = TRUE)
[17:00:33.695]     }
[17:00:33.695]     ...future.frame <- base::sys.nframe()
[17:00:33.695]     ...future.conditions <- base::list()
[17:00:33.695]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.695]     if (FALSE) {
[17:00:33.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.695]     }
[17:00:33.695]     ...future.result <- base::tryCatch({
[17:00:33.695]         base::withCallingHandlers({
[17:00:33.695]             ...future.value <- base::withVisible(base::local({
[17:00:33.695]                 ...future.makeSendCondition <- base::local({
[17:00:33.695]                   sendCondition <- NULL
[17:00:33.695]                   function(frame = 1L) {
[17:00:33.695]                     if (is.function(sendCondition)) 
[17:00:33.695]                       return(sendCondition)
[17:00:33.695]                     ns <- getNamespace("parallel")
[17:00:33.695]                     if (exists("sendData", mode = "function", 
[17:00:33.695]                       envir = ns)) {
[17:00:33.695]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.695]                         envir = ns)
[17:00:33.695]                       envir <- sys.frame(frame)
[17:00:33.695]                       master <- NULL
[17:00:33.695]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.695]                         !identical(envir, emptyenv())) {
[17:00:33.695]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.695]                           inherits = FALSE)) {
[17:00:33.695]                           master <- get("master", mode = "list", 
[17:00:33.695]                             envir = envir, inherits = FALSE)
[17:00:33.695]                           if (inherits(master, c("SOCKnode", 
[17:00:33.695]                             "SOCK0node"))) {
[17:00:33.695]                             sendCondition <<- function(cond) {
[17:00:33.695]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.695]                                 success = TRUE)
[17:00:33.695]                               parallel_sendData(master, data)
[17:00:33.695]                             }
[17:00:33.695]                             return(sendCondition)
[17:00:33.695]                           }
[17:00:33.695]                         }
[17:00:33.695]                         frame <- frame + 1L
[17:00:33.695]                         envir <- sys.frame(frame)
[17:00:33.695]                       }
[17:00:33.695]                     }
[17:00:33.695]                     sendCondition <<- function(cond) NULL
[17:00:33.695]                   }
[17:00:33.695]                 })
[17:00:33.695]                 withCallingHandlers({
[17:00:33.695]                   {
[17:00:33.695]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.695]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.695]                       ...future.globals.maxSize)) {
[17:00:33.695]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.695]                       on.exit(options(oopts), add = TRUE)
[17:00:33.695]                     }
[17:00:33.695]                     {
[17:00:33.695]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.695]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.695]                         USE.NAMES = FALSE)
[17:00:33.695]                       do.call(mapply, args = args)
[17:00:33.695]                     }
[17:00:33.695]                   }
[17:00:33.695]                 }, immediateCondition = function(cond) {
[17:00:33.695]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.695]                   sendCondition(cond)
[17:00:33.695]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.695]                   {
[17:00:33.695]                     inherits <- base::inherits
[17:00:33.695]                     invokeRestart <- base::invokeRestart
[17:00:33.695]                     is.null <- base::is.null
[17:00:33.695]                     muffled <- FALSE
[17:00:33.695]                     if (inherits(cond, "message")) {
[17:00:33.695]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.695]                       if (muffled) 
[17:00:33.695]                         invokeRestart("muffleMessage")
[17:00:33.695]                     }
[17:00:33.695]                     else if (inherits(cond, "warning")) {
[17:00:33.695]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.695]                       if (muffled) 
[17:00:33.695]                         invokeRestart("muffleWarning")
[17:00:33.695]                     }
[17:00:33.695]                     else if (inherits(cond, "condition")) {
[17:00:33.695]                       if (!is.null(pattern)) {
[17:00:33.695]                         computeRestarts <- base::computeRestarts
[17:00:33.695]                         grepl <- base::grepl
[17:00:33.695]                         restarts <- computeRestarts(cond)
[17:00:33.695]                         for (restart in restarts) {
[17:00:33.695]                           name <- restart$name
[17:00:33.695]                           if (is.null(name)) 
[17:00:33.695]                             next
[17:00:33.695]                           if (!grepl(pattern, name)) 
[17:00:33.695]                             next
[17:00:33.695]                           invokeRestart(restart)
[17:00:33.695]                           muffled <- TRUE
[17:00:33.695]                           break
[17:00:33.695]                         }
[17:00:33.695]                       }
[17:00:33.695]                     }
[17:00:33.695]                     invisible(muffled)
[17:00:33.695]                   }
[17:00:33.695]                   muffleCondition(cond)
[17:00:33.695]                 })
[17:00:33.695]             }))
[17:00:33.695]             future::FutureResult(value = ...future.value$value, 
[17:00:33.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.695]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.695]                     ...future.globalenv.names))
[17:00:33.695]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.695]         }, condition = base::local({
[17:00:33.695]             c <- base::c
[17:00:33.695]             inherits <- base::inherits
[17:00:33.695]             invokeRestart <- base::invokeRestart
[17:00:33.695]             length <- base::length
[17:00:33.695]             list <- base::list
[17:00:33.695]             seq.int <- base::seq.int
[17:00:33.695]             signalCondition <- base::signalCondition
[17:00:33.695]             sys.calls <- base::sys.calls
[17:00:33.695]             `[[` <- base::`[[`
[17:00:33.695]             `+` <- base::`+`
[17:00:33.695]             `<<-` <- base::`<<-`
[17:00:33.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.695]                   3L)]
[17:00:33.695]             }
[17:00:33.695]             function(cond) {
[17:00:33.695]                 is_error <- inherits(cond, "error")
[17:00:33.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.695]                   NULL)
[17:00:33.695]                 if (is_error) {
[17:00:33.695]                   sessionInformation <- function() {
[17:00:33.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.695]                       search = base::search(), system = base::Sys.info())
[17:00:33.695]                   }
[17:00:33.695]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.695]                     cond$call), session = sessionInformation(), 
[17:00:33.695]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.695]                   signalCondition(cond)
[17:00:33.695]                 }
[17:00:33.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.695]                 "immediateCondition"))) {
[17:00:33.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.695]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.695]                   if (TRUE && !signal) {
[17:00:33.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.695]                     {
[17:00:33.695]                       inherits <- base::inherits
[17:00:33.695]                       invokeRestart <- base::invokeRestart
[17:00:33.695]                       is.null <- base::is.null
[17:00:33.695]                       muffled <- FALSE
[17:00:33.695]                       if (inherits(cond, "message")) {
[17:00:33.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.695]                         if (muffled) 
[17:00:33.695]                           invokeRestart("muffleMessage")
[17:00:33.695]                       }
[17:00:33.695]                       else if (inherits(cond, "warning")) {
[17:00:33.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.695]                         if (muffled) 
[17:00:33.695]                           invokeRestart("muffleWarning")
[17:00:33.695]                       }
[17:00:33.695]                       else if (inherits(cond, "condition")) {
[17:00:33.695]                         if (!is.null(pattern)) {
[17:00:33.695]                           computeRestarts <- base::computeRestarts
[17:00:33.695]                           grepl <- base::grepl
[17:00:33.695]                           restarts <- computeRestarts(cond)
[17:00:33.695]                           for (restart in restarts) {
[17:00:33.695]                             name <- restart$name
[17:00:33.695]                             if (is.null(name)) 
[17:00:33.695]                               next
[17:00:33.695]                             if (!grepl(pattern, name)) 
[17:00:33.695]                               next
[17:00:33.695]                             invokeRestart(restart)
[17:00:33.695]                             muffled <- TRUE
[17:00:33.695]                             break
[17:00:33.695]                           }
[17:00:33.695]                         }
[17:00:33.695]                       }
[17:00:33.695]                       invisible(muffled)
[17:00:33.695]                     }
[17:00:33.695]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.695]                   }
[17:00:33.695]                 }
[17:00:33.695]                 else {
[17:00:33.695]                   if (TRUE) {
[17:00:33.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.695]                     {
[17:00:33.695]                       inherits <- base::inherits
[17:00:33.695]                       invokeRestart <- base::invokeRestart
[17:00:33.695]                       is.null <- base::is.null
[17:00:33.695]                       muffled <- FALSE
[17:00:33.695]                       if (inherits(cond, "message")) {
[17:00:33.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.695]                         if (muffled) 
[17:00:33.695]                           invokeRestart("muffleMessage")
[17:00:33.695]                       }
[17:00:33.695]                       else if (inherits(cond, "warning")) {
[17:00:33.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.695]                         if (muffled) 
[17:00:33.695]                           invokeRestart("muffleWarning")
[17:00:33.695]                       }
[17:00:33.695]                       else if (inherits(cond, "condition")) {
[17:00:33.695]                         if (!is.null(pattern)) {
[17:00:33.695]                           computeRestarts <- base::computeRestarts
[17:00:33.695]                           grepl <- base::grepl
[17:00:33.695]                           restarts <- computeRestarts(cond)
[17:00:33.695]                           for (restart in restarts) {
[17:00:33.695]                             name <- restart$name
[17:00:33.695]                             if (is.null(name)) 
[17:00:33.695]                               next
[17:00:33.695]                             if (!grepl(pattern, name)) 
[17:00:33.695]                               next
[17:00:33.695]                             invokeRestart(restart)
[17:00:33.695]                             muffled <- TRUE
[17:00:33.695]                             break
[17:00:33.695]                           }
[17:00:33.695]                         }
[17:00:33.695]                       }
[17:00:33.695]                       invisible(muffled)
[17:00:33.695]                     }
[17:00:33.695]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.695]                   }
[17:00:33.695]                 }
[17:00:33.695]             }
[17:00:33.695]         }))
[17:00:33.695]     }, error = function(ex) {
[17:00:33.695]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.695]                 ...future.rng), started = ...future.startTime, 
[17:00:33.695]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.695]             version = "1.8"), class = "FutureResult")
[17:00:33.695]     }, finally = {
[17:00:33.695]         if (!identical(...future.workdir, getwd())) 
[17:00:33.695]             setwd(...future.workdir)
[17:00:33.695]         {
[17:00:33.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.695]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.695]             }
[17:00:33.695]             base::options(...future.oldOptions)
[17:00:33.695]             if (.Platform$OS.type == "windows") {
[17:00:33.695]                 old_names <- names(...future.oldEnvVars)
[17:00:33.695]                 envs <- base::Sys.getenv()
[17:00:33.695]                 names <- names(envs)
[17:00:33.695]                 common <- intersect(names, old_names)
[17:00:33.695]                 added <- setdiff(names, old_names)
[17:00:33.695]                 removed <- setdiff(old_names, names)
[17:00:33.695]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.695]                   envs[common]]
[17:00:33.695]                 NAMES <- toupper(changed)
[17:00:33.695]                 args <- list()
[17:00:33.695]                 for (kk in seq_along(NAMES)) {
[17:00:33.695]                   name <- changed[[kk]]
[17:00:33.695]                   NAME <- NAMES[[kk]]
[17:00:33.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.695]                     next
[17:00:33.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.695]                 }
[17:00:33.695]                 NAMES <- toupper(added)
[17:00:33.695]                 for (kk in seq_along(NAMES)) {
[17:00:33.695]                   name <- added[[kk]]
[17:00:33.695]                   NAME <- NAMES[[kk]]
[17:00:33.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.695]                     next
[17:00:33.695]                   args[[name]] <- ""
[17:00:33.695]                 }
[17:00:33.695]                 NAMES <- toupper(removed)
[17:00:33.695]                 for (kk in seq_along(NAMES)) {
[17:00:33.695]                   name <- removed[[kk]]
[17:00:33.695]                   NAME <- NAMES[[kk]]
[17:00:33.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.695]                     next
[17:00:33.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.695]                 }
[17:00:33.695]                 if (length(args) > 0) 
[17:00:33.695]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.695]             }
[17:00:33.695]             else {
[17:00:33.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.695]             }
[17:00:33.695]             {
[17:00:33.695]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.695]                   0L) {
[17:00:33.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.695]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.695]                   base::options(opts)
[17:00:33.695]                 }
[17:00:33.695]                 {
[17:00:33.695]                   {
[17:00:33.695]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.695]                     NULL
[17:00:33.695]                   }
[17:00:33.695]                   options(future.plan = NULL)
[17:00:33.695]                   if (is.na(NA_character_)) 
[17:00:33.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.695]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.695]                     .init = FALSE)
[17:00:33.695]                 }
[17:00:33.695]             }
[17:00:33.695]         }
[17:00:33.695]     })
[17:00:33.695]     if (TRUE) {
[17:00:33.695]         base::sink(type = "output", split = FALSE)
[17:00:33.695]         if (TRUE) {
[17:00:33.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.695]         }
[17:00:33.695]         else {
[17:00:33.695]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.695]         }
[17:00:33.695]         base::close(...future.stdout)
[17:00:33.695]         ...future.stdout <- NULL
[17:00:33.695]     }
[17:00:33.695]     ...future.result$conditions <- ...future.conditions
[17:00:33.695]     ...future.result$finished <- base::Sys.time()
[17:00:33.695]     ...future.result
[17:00:33.695] }
[17:00:33.698] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:00:33.698] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:00:33.699] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:00:33.699] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:33.699] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.699] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:00:33.700] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:00:33.700] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:33.700] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.701] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:33.701] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.701] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:00:33.701] MultisessionFuture started
[17:00:33.702] - Launch lazy future ... done
[17:00:33.702] run() for ‘MultisessionFuture’ ... done
[17:00:33.702] Created future:
[17:00:33.702] MultisessionFuture:
[17:00:33.702] Label: ‘future_mapply-1’
[17:00:33.702] Expression:
[17:00:33.702] {
[17:00:33.702]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.702]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.702]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.702]         on.exit(options(oopts), add = TRUE)
[17:00:33.702]     }
[17:00:33.702]     {
[17:00:33.702]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.702]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.702]         do.call(mapply, args = args)
[17:00:33.702]     }
[17:00:33.702] }
[17:00:33.702] Lazy evaluation: FALSE
[17:00:33.702] Asynchronous evaluation: TRUE
[17:00:33.702] Local evaluation: TRUE
[17:00:33.702] Environment: R_GlobalEnv
[17:00:33.702] Capture standard output: TRUE
[17:00:33.702] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.702] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.702] Packages: <none>
[17:00:33.702] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.702] Resolved: FALSE
[17:00:33.702] Value: <not collected>
[17:00:33.702] Conditions captured: <none>
[17:00:33.702] Early signaling: FALSE
[17:00:33.702] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.702] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.714] Chunk #1 of 3 ... DONE
[17:00:33.714] Chunk #2 of 3 ...
[17:00:33.714]  - Finding globals in '...' for chunk #2 ...
[17:00:33.714] getGlobalsAndPackages() ...
[17:00:33.714] Searching for globals...
[17:00:33.714] 
[17:00:33.714] Searching for globals ... DONE
[17:00:33.715] - globals: [0] <none>
[17:00:33.715] getGlobalsAndPackages() ... DONE
[17:00:33.715]    + additional globals found: [n=0] 
[17:00:33.715]    + additional namespaces needed: [n=0] 
[17:00:33.715]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:33.715]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:00:33.715]  - seeds: <none>
[17:00:33.715]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.715] getGlobalsAndPackages() ...
[17:00:33.715] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.716] Resolving globals: FALSE
[17:00:33.716] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:00:33.716] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.717] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.717] 
[17:00:33.717] getGlobalsAndPackages() ... DONE
[17:00:33.717] run() for ‘Future’ ...
[17:00:33.717] - state: ‘created’
[17:00:33.717] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.732] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.732] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.732]   - Field: ‘node’
[17:00:33.732]   - Field: ‘label’
[17:00:33.732]   - Field: ‘local’
[17:00:33.732]   - Field: ‘owner’
[17:00:33.732]   - Field: ‘envir’
[17:00:33.733]   - Field: ‘workers’
[17:00:33.733]   - Field: ‘packages’
[17:00:33.733]   - Field: ‘gc’
[17:00:33.733]   - Field: ‘conditions’
[17:00:33.733]   - Field: ‘persistent’
[17:00:33.733]   - Field: ‘expr’
[17:00:33.733]   - Field: ‘uuid’
[17:00:33.733]   - Field: ‘seed’
[17:00:33.733]   - Field: ‘version’
[17:00:33.733]   - Field: ‘result’
[17:00:33.734]   - Field: ‘asynchronous’
[17:00:33.734]   - Field: ‘calls’
[17:00:33.734]   - Field: ‘globals’
[17:00:33.734]   - Field: ‘stdout’
[17:00:33.734]   - Field: ‘earlySignal’
[17:00:33.734]   - Field: ‘lazy’
[17:00:33.734]   - Field: ‘state’
[17:00:33.734] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.734] - Launch lazy future ...
[17:00:33.735] Packages needed by the future expression (n = 0): <none>
[17:00:33.735] Packages needed by future strategies (n = 0): <none>
[17:00:33.735] {
[17:00:33.735]     {
[17:00:33.735]         {
[17:00:33.735]             ...future.startTime <- base::Sys.time()
[17:00:33.735]             {
[17:00:33.735]                 {
[17:00:33.735]                   {
[17:00:33.735]                     {
[17:00:33.735]                       base::local({
[17:00:33.735]                         has_future <- base::requireNamespace("future", 
[17:00:33.735]                           quietly = TRUE)
[17:00:33.735]                         if (has_future) {
[17:00:33.735]                           ns <- base::getNamespace("future")
[17:00:33.735]                           version <- ns[[".package"]][["version"]]
[17:00:33.735]                           if (is.null(version)) 
[17:00:33.735]                             version <- utils::packageVersion("future")
[17:00:33.735]                         }
[17:00:33.735]                         else {
[17:00:33.735]                           version <- NULL
[17:00:33.735]                         }
[17:00:33.735]                         if (!has_future || version < "1.8.0") {
[17:00:33.735]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.735]                             "", base::R.version$version.string), 
[17:00:33.735]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.735]                               "release", "version")], collapse = " "), 
[17:00:33.735]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.735]                             info)
[17:00:33.735]                           info <- base::paste(info, collapse = "; ")
[17:00:33.735]                           if (!has_future) {
[17:00:33.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.735]                               info)
[17:00:33.735]                           }
[17:00:33.735]                           else {
[17:00:33.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.735]                               info, version)
[17:00:33.735]                           }
[17:00:33.735]                           base::stop(msg)
[17:00:33.735]                         }
[17:00:33.735]                       })
[17:00:33.735]                     }
[17:00:33.735]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.735]                     base::options(mc.cores = 1L)
[17:00:33.735]                   }
[17:00:33.735]                   ...future.strategy.old <- future::plan("list")
[17:00:33.735]                   options(future.plan = NULL)
[17:00:33.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.735]                 }
[17:00:33.735]                 ...future.workdir <- getwd()
[17:00:33.735]             }
[17:00:33.735]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.735]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.735]         }
[17:00:33.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.735]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:00:33.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.735]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.735]             base::names(...future.oldOptions))
[17:00:33.735]     }
[17:00:33.735]     if (FALSE) {
[17:00:33.735]     }
[17:00:33.735]     else {
[17:00:33.735]         if (TRUE) {
[17:00:33.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.735]                 open = "w")
[17:00:33.735]         }
[17:00:33.735]         else {
[17:00:33.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.735]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.735]         }
[17:00:33.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.735]             base::sink(type = "output", split = FALSE)
[17:00:33.735]             base::close(...future.stdout)
[17:00:33.735]         }, add = TRUE)
[17:00:33.735]     }
[17:00:33.735]     ...future.frame <- base::sys.nframe()
[17:00:33.735]     ...future.conditions <- base::list()
[17:00:33.735]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.735]     if (FALSE) {
[17:00:33.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.735]     }
[17:00:33.735]     ...future.result <- base::tryCatch({
[17:00:33.735]         base::withCallingHandlers({
[17:00:33.735]             ...future.value <- base::withVisible(base::local({
[17:00:33.735]                 ...future.makeSendCondition <- base::local({
[17:00:33.735]                   sendCondition <- NULL
[17:00:33.735]                   function(frame = 1L) {
[17:00:33.735]                     if (is.function(sendCondition)) 
[17:00:33.735]                       return(sendCondition)
[17:00:33.735]                     ns <- getNamespace("parallel")
[17:00:33.735]                     if (exists("sendData", mode = "function", 
[17:00:33.735]                       envir = ns)) {
[17:00:33.735]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.735]                         envir = ns)
[17:00:33.735]                       envir <- sys.frame(frame)
[17:00:33.735]                       master <- NULL
[17:00:33.735]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.735]                         !identical(envir, emptyenv())) {
[17:00:33.735]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.735]                           inherits = FALSE)) {
[17:00:33.735]                           master <- get("master", mode = "list", 
[17:00:33.735]                             envir = envir, inherits = FALSE)
[17:00:33.735]                           if (inherits(master, c("SOCKnode", 
[17:00:33.735]                             "SOCK0node"))) {
[17:00:33.735]                             sendCondition <<- function(cond) {
[17:00:33.735]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.735]                                 success = TRUE)
[17:00:33.735]                               parallel_sendData(master, data)
[17:00:33.735]                             }
[17:00:33.735]                             return(sendCondition)
[17:00:33.735]                           }
[17:00:33.735]                         }
[17:00:33.735]                         frame <- frame + 1L
[17:00:33.735]                         envir <- sys.frame(frame)
[17:00:33.735]                       }
[17:00:33.735]                     }
[17:00:33.735]                     sendCondition <<- function(cond) NULL
[17:00:33.735]                   }
[17:00:33.735]                 })
[17:00:33.735]                 withCallingHandlers({
[17:00:33.735]                   {
[17:00:33.735]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.735]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.735]                       ...future.globals.maxSize)) {
[17:00:33.735]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.735]                       on.exit(options(oopts), add = TRUE)
[17:00:33.735]                     }
[17:00:33.735]                     {
[17:00:33.735]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.735]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.735]                         USE.NAMES = FALSE)
[17:00:33.735]                       do.call(mapply, args = args)
[17:00:33.735]                     }
[17:00:33.735]                   }
[17:00:33.735]                 }, immediateCondition = function(cond) {
[17:00:33.735]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.735]                   sendCondition(cond)
[17:00:33.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.735]                   {
[17:00:33.735]                     inherits <- base::inherits
[17:00:33.735]                     invokeRestart <- base::invokeRestart
[17:00:33.735]                     is.null <- base::is.null
[17:00:33.735]                     muffled <- FALSE
[17:00:33.735]                     if (inherits(cond, "message")) {
[17:00:33.735]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.735]                       if (muffled) 
[17:00:33.735]                         invokeRestart("muffleMessage")
[17:00:33.735]                     }
[17:00:33.735]                     else if (inherits(cond, "warning")) {
[17:00:33.735]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.735]                       if (muffled) 
[17:00:33.735]                         invokeRestart("muffleWarning")
[17:00:33.735]                     }
[17:00:33.735]                     else if (inherits(cond, "condition")) {
[17:00:33.735]                       if (!is.null(pattern)) {
[17:00:33.735]                         computeRestarts <- base::computeRestarts
[17:00:33.735]                         grepl <- base::grepl
[17:00:33.735]                         restarts <- computeRestarts(cond)
[17:00:33.735]                         for (restart in restarts) {
[17:00:33.735]                           name <- restart$name
[17:00:33.735]                           if (is.null(name)) 
[17:00:33.735]                             next
[17:00:33.735]                           if (!grepl(pattern, name)) 
[17:00:33.735]                             next
[17:00:33.735]                           invokeRestart(restart)
[17:00:33.735]                           muffled <- TRUE
[17:00:33.735]                           break
[17:00:33.735]                         }
[17:00:33.735]                       }
[17:00:33.735]                     }
[17:00:33.735]                     invisible(muffled)
[17:00:33.735]                   }
[17:00:33.735]                   muffleCondition(cond)
[17:00:33.735]                 })
[17:00:33.735]             }))
[17:00:33.735]             future::FutureResult(value = ...future.value$value, 
[17:00:33.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.735]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.735]                     ...future.globalenv.names))
[17:00:33.735]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.735]         }, condition = base::local({
[17:00:33.735]             c <- base::c
[17:00:33.735]             inherits <- base::inherits
[17:00:33.735]             invokeRestart <- base::invokeRestart
[17:00:33.735]             length <- base::length
[17:00:33.735]             list <- base::list
[17:00:33.735]             seq.int <- base::seq.int
[17:00:33.735]             signalCondition <- base::signalCondition
[17:00:33.735]             sys.calls <- base::sys.calls
[17:00:33.735]             `[[` <- base::`[[`
[17:00:33.735]             `+` <- base::`+`
[17:00:33.735]             `<<-` <- base::`<<-`
[17:00:33.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.735]                   3L)]
[17:00:33.735]             }
[17:00:33.735]             function(cond) {
[17:00:33.735]                 is_error <- inherits(cond, "error")
[17:00:33.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.735]                   NULL)
[17:00:33.735]                 if (is_error) {
[17:00:33.735]                   sessionInformation <- function() {
[17:00:33.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.735]                       search = base::search(), system = base::Sys.info())
[17:00:33.735]                   }
[17:00:33.735]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.735]                     cond$call), session = sessionInformation(), 
[17:00:33.735]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.735]                   signalCondition(cond)
[17:00:33.735]                 }
[17:00:33.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.735]                 "immediateCondition"))) {
[17:00:33.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.735]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.735]                   if (TRUE && !signal) {
[17:00:33.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.735]                     {
[17:00:33.735]                       inherits <- base::inherits
[17:00:33.735]                       invokeRestart <- base::invokeRestart
[17:00:33.735]                       is.null <- base::is.null
[17:00:33.735]                       muffled <- FALSE
[17:00:33.735]                       if (inherits(cond, "message")) {
[17:00:33.735]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.735]                         if (muffled) 
[17:00:33.735]                           invokeRestart("muffleMessage")
[17:00:33.735]                       }
[17:00:33.735]                       else if (inherits(cond, "warning")) {
[17:00:33.735]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.735]                         if (muffled) 
[17:00:33.735]                           invokeRestart("muffleWarning")
[17:00:33.735]                       }
[17:00:33.735]                       else if (inherits(cond, "condition")) {
[17:00:33.735]                         if (!is.null(pattern)) {
[17:00:33.735]                           computeRestarts <- base::computeRestarts
[17:00:33.735]                           grepl <- base::grepl
[17:00:33.735]                           restarts <- computeRestarts(cond)
[17:00:33.735]                           for (restart in restarts) {
[17:00:33.735]                             name <- restart$name
[17:00:33.735]                             if (is.null(name)) 
[17:00:33.735]                               next
[17:00:33.735]                             if (!grepl(pattern, name)) 
[17:00:33.735]                               next
[17:00:33.735]                             invokeRestart(restart)
[17:00:33.735]                             muffled <- TRUE
[17:00:33.735]                             break
[17:00:33.735]                           }
[17:00:33.735]                         }
[17:00:33.735]                       }
[17:00:33.735]                       invisible(muffled)
[17:00:33.735]                     }
[17:00:33.735]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.735]                   }
[17:00:33.735]                 }
[17:00:33.735]                 else {
[17:00:33.735]                   if (TRUE) {
[17:00:33.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.735]                     {
[17:00:33.735]                       inherits <- base::inherits
[17:00:33.735]                       invokeRestart <- base::invokeRestart
[17:00:33.735]                       is.null <- base::is.null
[17:00:33.735]                       muffled <- FALSE
[17:00:33.735]                       if (inherits(cond, "message")) {
[17:00:33.735]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.735]                         if (muffled) 
[17:00:33.735]                           invokeRestart("muffleMessage")
[17:00:33.735]                       }
[17:00:33.735]                       else if (inherits(cond, "warning")) {
[17:00:33.735]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.735]                         if (muffled) 
[17:00:33.735]                           invokeRestart("muffleWarning")
[17:00:33.735]                       }
[17:00:33.735]                       else if (inherits(cond, "condition")) {
[17:00:33.735]                         if (!is.null(pattern)) {
[17:00:33.735]                           computeRestarts <- base::computeRestarts
[17:00:33.735]                           grepl <- base::grepl
[17:00:33.735]                           restarts <- computeRestarts(cond)
[17:00:33.735]                           for (restart in restarts) {
[17:00:33.735]                             name <- restart$name
[17:00:33.735]                             if (is.null(name)) 
[17:00:33.735]                               next
[17:00:33.735]                             if (!grepl(pattern, name)) 
[17:00:33.735]                               next
[17:00:33.735]                             invokeRestart(restart)
[17:00:33.735]                             muffled <- TRUE
[17:00:33.735]                             break
[17:00:33.735]                           }
[17:00:33.735]                         }
[17:00:33.735]                       }
[17:00:33.735]                       invisible(muffled)
[17:00:33.735]                     }
[17:00:33.735]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.735]                   }
[17:00:33.735]                 }
[17:00:33.735]             }
[17:00:33.735]         }))
[17:00:33.735]     }, error = function(ex) {
[17:00:33.735]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.735]                 ...future.rng), started = ...future.startTime, 
[17:00:33.735]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.735]             version = "1.8"), class = "FutureResult")
[17:00:33.735]     }, finally = {
[17:00:33.735]         if (!identical(...future.workdir, getwd())) 
[17:00:33.735]             setwd(...future.workdir)
[17:00:33.735]         {
[17:00:33.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.735]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.735]             }
[17:00:33.735]             base::options(...future.oldOptions)
[17:00:33.735]             if (.Platform$OS.type == "windows") {
[17:00:33.735]                 old_names <- names(...future.oldEnvVars)
[17:00:33.735]                 envs <- base::Sys.getenv()
[17:00:33.735]                 names <- names(envs)
[17:00:33.735]                 common <- intersect(names, old_names)
[17:00:33.735]                 added <- setdiff(names, old_names)
[17:00:33.735]                 removed <- setdiff(old_names, names)
[17:00:33.735]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.735]                   envs[common]]
[17:00:33.735]                 NAMES <- toupper(changed)
[17:00:33.735]                 args <- list()
[17:00:33.735]                 for (kk in seq_along(NAMES)) {
[17:00:33.735]                   name <- changed[[kk]]
[17:00:33.735]                   NAME <- NAMES[[kk]]
[17:00:33.735]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.735]                     next
[17:00:33.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.735]                 }
[17:00:33.735]                 NAMES <- toupper(added)
[17:00:33.735]                 for (kk in seq_along(NAMES)) {
[17:00:33.735]                   name <- added[[kk]]
[17:00:33.735]                   NAME <- NAMES[[kk]]
[17:00:33.735]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.735]                     next
[17:00:33.735]                   args[[name]] <- ""
[17:00:33.735]                 }
[17:00:33.735]                 NAMES <- toupper(removed)
[17:00:33.735]                 for (kk in seq_along(NAMES)) {
[17:00:33.735]                   name <- removed[[kk]]
[17:00:33.735]                   NAME <- NAMES[[kk]]
[17:00:33.735]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.735]                     next
[17:00:33.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.735]                 }
[17:00:33.735]                 if (length(args) > 0) 
[17:00:33.735]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.735]             }
[17:00:33.735]             else {
[17:00:33.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.735]             }
[17:00:33.735]             {
[17:00:33.735]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.735]                   0L) {
[17:00:33.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.735]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.735]                   base::options(opts)
[17:00:33.735]                 }
[17:00:33.735]                 {
[17:00:33.735]                   {
[17:00:33.735]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.735]                     NULL
[17:00:33.735]                   }
[17:00:33.735]                   options(future.plan = NULL)
[17:00:33.735]                   if (is.na(NA_character_)) 
[17:00:33.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.735]                     .init = FALSE)
[17:00:33.735]                 }
[17:00:33.735]             }
[17:00:33.735]         }
[17:00:33.735]     })
[17:00:33.735]     if (TRUE) {
[17:00:33.735]         base::sink(type = "output", split = FALSE)
[17:00:33.735]         if (TRUE) {
[17:00:33.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.735]         }
[17:00:33.735]         else {
[17:00:33.735]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.735]         }
[17:00:33.735]         base::close(...future.stdout)
[17:00:33.735]         ...future.stdout <- NULL
[17:00:33.735]     }
[17:00:33.735]     ...future.result$conditions <- ...future.conditions
[17:00:33.735]     ...future.result$finished <- base::Sys.time()
[17:00:33.735]     ...future.result
[17:00:33.735] }
[17:00:33.738] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[17:00:33.738] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:00:33.739] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:00:33.739] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:33.739] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.739] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[17:00:33.740] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[17:00:33.740] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:33.740] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.740] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:33.741] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.741] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[17:00:33.741] MultisessionFuture started
[17:00:33.741] - Launch lazy future ... done
[17:00:33.742] run() for ‘MultisessionFuture’ ... done
[17:00:33.742] Created future:
[17:00:33.742] MultisessionFuture:
[17:00:33.742] Label: ‘future_mapply-2’
[17:00:33.742] Expression:
[17:00:33.742] {
[17:00:33.742]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.742]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.742]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.742]         on.exit(options(oopts), add = TRUE)
[17:00:33.742]     }
[17:00:33.742]     {
[17:00:33.742]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.742]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.742]         do.call(mapply, args = args)
[17:00:33.742]     }
[17:00:33.742] }
[17:00:33.742] Lazy evaluation: FALSE
[17:00:33.742] Asynchronous evaluation: TRUE
[17:00:33.742] Local evaluation: TRUE
[17:00:33.742] Environment: R_GlobalEnv
[17:00:33.742] Capture standard output: TRUE
[17:00:33.742] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.742] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.742] Packages: <none>
[17:00:33.742] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.742] Resolved: FALSE
[17:00:33.742] Value: <not collected>
[17:00:33.742] Conditions captured: <none>
[17:00:33.742] Early signaling: FALSE
[17:00:33.742] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.742] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.753] Chunk #2 of 3 ... DONE
[17:00:33.753] Chunk #3 of 3 ...
[17:00:33.754]  - Finding globals in '...' for chunk #3 ...
[17:00:33.754] getGlobalsAndPackages() ...
[17:00:33.754] Searching for globals...
[17:00:33.754] 
[17:00:33.754] Searching for globals ... DONE
[17:00:33.754] - globals: [0] <none>
[17:00:33.754] getGlobalsAndPackages() ... DONE
[17:00:33.754]    + additional globals found: [n=0] 
[17:00:33.755]    + additional namespaces needed: [n=0] 
[17:00:33.755]  - Finding globals in '...' for chunk #3 ... DONE
[17:00:33.755]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:00:33.755]  - seeds: <none>
[17:00:33.755]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.755] getGlobalsAndPackages() ...
[17:00:33.755] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.755] Resolving globals: FALSE
[17:00:33.756] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:33.756] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.756] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.756] 
[17:00:33.757] getGlobalsAndPackages() ... DONE
[17:00:33.757] run() for ‘Future’ ...
[17:00:33.757] - state: ‘created’
[17:00:33.757] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.771] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.772] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.772]   - Field: ‘node’
[17:00:33.772]   - Field: ‘label’
[17:00:33.772]   - Field: ‘local’
[17:00:33.772]   - Field: ‘owner’
[17:00:33.772]   - Field: ‘envir’
[17:00:33.772]   - Field: ‘workers’
[17:00:33.772]   - Field: ‘packages’
[17:00:33.772]   - Field: ‘gc’
[17:00:33.772]   - Field: ‘conditions’
[17:00:33.772]   - Field: ‘persistent’
[17:00:33.773]   - Field: ‘expr’
[17:00:33.773]   - Field: ‘uuid’
[17:00:33.773]   - Field: ‘seed’
[17:00:33.773]   - Field: ‘version’
[17:00:33.773]   - Field: ‘result’
[17:00:33.773]   - Field: ‘asynchronous’
[17:00:33.773]   - Field: ‘calls’
[17:00:33.773]   - Field: ‘globals’
[17:00:33.773]   - Field: ‘stdout’
[17:00:33.773]   - Field: ‘earlySignal’
[17:00:33.773]   - Field: ‘lazy’
[17:00:33.774]   - Field: ‘state’
[17:00:33.774] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.774] - Launch lazy future ...
[17:00:33.774] Packages needed by the future expression (n = 0): <none>
[17:00:33.774] Packages needed by future strategies (n = 0): <none>
[17:00:33.775] {
[17:00:33.775]     {
[17:00:33.775]         {
[17:00:33.775]             ...future.startTime <- base::Sys.time()
[17:00:33.775]             {
[17:00:33.775]                 {
[17:00:33.775]                   {
[17:00:33.775]                     {
[17:00:33.775]                       base::local({
[17:00:33.775]                         has_future <- base::requireNamespace("future", 
[17:00:33.775]                           quietly = TRUE)
[17:00:33.775]                         if (has_future) {
[17:00:33.775]                           ns <- base::getNamespace("future")
[17:00:33.775]                           version <- ns[[".package"]][["version"]]
[17:00:33.775]                           if (is.null(version)) 
[17:00:33.775]                             version <- utils::packageVersion("future")
[17:00:33.775]                         }
[17:00:33.775]                         else {
[17:00:33.775]                           version <- NULL
[17:00:33.775]                         }
[17:00:33.775]                         if (!has_future || version < "1.8.0") {
[17:00:33.775]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.775]                             "", base::R.version$version.string), 
[17:00:33.775]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.775]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.775]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.775]                               "release", "version")], collapse = " "), 
[17:00:33.775]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.775]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.775]                             info)
[17:00:33.775]                           info <- base::paste(info, collapse = "; ")
[17:00:33.775]                           if (!has_future) {
[17:00:33.775]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.775]                               info)
[17:00:33.775]                           }
[17:00:33.775]                           else {
[17:00:33.775]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.775]                               info, version)
[17:00:33.775]                           }
[17:00:33.775]                           base::stop(msg)
[17:00:33.775]                         }
[17:00:33.775]                       })
[17:00:33.775]                     }
[17:00:33.775]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.775]                     base::options(mc.cores = 1L)
[17:00:33.775]                   }
[17:00:33.775]                   ...future.strategy.old <- future::plan("list")
[17:00:33.775]                   options(future.plan = NULL)
[17:00:33.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.775]                 }
[17:00:33.775]                 ...future.workdir <- getwd()
[17:00:33.775]             }
[17:00:33.775]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.775]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.775]         }
[17:00:33.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.775]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:00:33.775]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.775]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.775]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.775]             base::names(...future.oldOptions))
[17:00:33.775]     }
[17:00:33.775]     if (FALSE) {
[17:00:33.775]     }
[17:00:33.775]     else {
[17:00:33.775]         if (TRUE) {
[17:00:33.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.775]                 open = "w")
[17:00:33.775]         }
[17:00:33.775]         else {
[17:00:33.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.775]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.775]         }
[17:00:33.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.775]             base::sink(type = "output", split = FALSE)
[17:00:33.775]             base::close(...future.stdout)
[17:00:33.775]         }, add = TRUE)
[17:00:33.775]     }
[17:00:33.775]     ...future.frame <- base::sys.nframe()
[17:00:33.775]     ...future.conditions <- base::list()
[17:00:33.775]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.775]     if (FALSE) {
[17:00:33.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.775]     }
[17:00:33.775]     ...future.result <- base::tryCatch({
[17:00:33.775]         base::withCallingHandlers({
[17:00:33.775]             ...future.value <- base::withVisible(base::local({
[17:00:33.775]                 ...future.makeSendCondition <- base::local({
[17:00:33.775]                   sendCondition <- NULL
[17:00:33.775]                   function(frame = 1L) {
[17:00:33.775]                     if (is.function(sendCondition)) 
[17:00:33.775]                       return(sendCondition)
[17:00:33.775]                     ns <- getNamespace("parallel")
[17:00:33.775]                     if (exists("sendData", mode = "function", 
[17:00:33.775]                       envir = ns)) {
[17:00:33.775]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.775]                         envir = ns)
[17:00:33.775]                       envir <- sys.frame(frame)
[17:00:33.775]                       master <- NULL
[17:00:33.775]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.775]                         !identical(envir, emptyenv())) {
[17:00:33.775]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.775]                           inherits = FALSE)) {
[17:00:33.775]                           master <- get("master", mode = "list", 
[17:00:33.775]                             envir = envir, inherits = FALSE)
[17:00:33.775]                           if (inherits(master, c("SOCKnode", 
[17:00:33.775]                             "SOCK0node"))) {
[17:00:33.775]                             sendCondition <<- function(cond) {
[17:00:33.775]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.775]                                 success = TRUE)
[17:00:33.775]                               parallel_sendData(master, data)
[17:00:33.775]                             }
[17:00:33.775]                             return(sendCondition)
[17:00:33.775]                           }
[17:00:33.775]                         }
[17:00:33.775]                         frame <- frame + 1L
[17:00:33.775]                         envir <- sys.frame(frame)
[17:00:33.775]                       }
[17:00:33.775]                     }
[17:00:33.775]                     sendCondition <<- function(cond) NULL
[17:00:33.775]                   }
[17:00:33.775]                 })
[17:00:33.775]                 withCallingHandlers({
[17:00:33.775]                   {
[17:00:33.775]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.775]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.775]                       ...future.globals.maxSize)) {
[17:00:33.775]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.775]                       on.exit(options(oopts), add = TRUE)
[17:00:33.775]                     }
[17:00:33.775]                     {
[17:00:33.775]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.775]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.775]                         USE.NAMES = FALSE)
[17:00:33.775]                       do.call(mapply, args = args)
[17:00:33.775]                     }
[17:00:33.775]                   }
[17:00:33.775]                 }, immediateCondition = function(cond) {
[17:00:33.775]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.775]                   sendCondition(cond)
[17:00:33.775]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.775]                   {
[17:00:33.775]                     inherits <- base::inherits
[17:00:33.775]                     invokeRestart <- base::invokeRestart
[17:00:33.775]                     is.null <- base::is.null
[17:00:33.775]                     muffled <- FALSE
[17:00:33.775]                     if (inherits(cond, "message")) {
[17:00:33.775]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.775]                       if (muffled) 
[17:00:33.775]                         invokeRestart("muffleMessage")
[17:00:33.775]                     }
[17:00:33.775]                     else if (inherits(cond, "warning")) {
[17:00:33.775]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.775]                       if (muffled) 
[17:00:33.775]                         invokeRestart("muffleWarning")
[17:00:33.775]                     }
[17:00:33.775]                     else if (inherits(cond, "condition")) {
[17:00:33.775]                       if (!is.null(pattern)) {
[17:00:33.775]                         computeRestarts <- base::computeRestarts
[17:00:33.775]                         grepl <- base::grepl
[17:00:33.775]                         restarts <- computeRestarts(cond)
[17:00:33.775]                         for (restart in restarts) {
[17:00:33.775]                           name <- restart$name
[17:00:33.775]                           if (is.null(name)) 
[17:00:33.775]                             next
[17:00:33.775]                           if (!grepl(pattern, name)) 
[17:00:33.775]                             next
[17:00:33.775]                           invokeRestart(restart)
[17:00:33.775]                           muffled <- TRUE
[17:00:33.775]                           break
[17:00:33.775]                         }
[17:00:33.775]                       }
[17:00:33.775]                     }
[17:00:33.775]                     invisible(muffled)
[17:00:33.775]                   }
[17:00:33.775]                   muffleCondition(cond)
[17:00:33.775]                 })
[17:00:33.775]             }))
[17:00:33.775]             future::FutureResult(value = ...future.value$value, 
[17:00:33.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.775]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.775]                     ...future.globalenv.names))
[17:00:33.775]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.775]         }, condition = base::local({
[17:00:33.775]             c <- base::c
[17:00:33.775]             inherits <- base::inherits
[17:00:33.775]             invokeRestart <- base::invokeRestart
[17:00:33.775]             length <- base::length
[17:00:33.775]             list <- base::list
[17:00:33.775]             seq.int <- base::seq.int
[17:00:33.775]             signalCondition <- base::signalCondition
[17:00:33.775]             sys.calls <- base::sys.calls
[17:00:33.775]             `[[` <- base::`[[`
[17:00:33.775]             `+` <- base::`+`
[17:00:33.775]             `<<-` <- base::`<<-`
[17:00:33.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.775]                   3L)]
[17:00:33.775]             }
[17:00:33.775]             function(cond) {
[17:00:33.775]                 is_error <- inherits(cond, "error")
[17:00:33.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.775]                   NULL)
[17:00:33.775]                 if (is_error) {
[17:00:33.775]                   sessionInformation <- function() {
[17:00:33.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.775]                       search = base::search(), system = base::Sys.info())
[17:00:33.775]                   }
[17:00:33.775]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.775]                     cond$call), session = sessionInformation(), 
[17:00:33.775]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.775]                   signalCondition(cond)
[17:00:33.775]                 }
[17:00:33.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.775]                 "immediateCondition"))) {
[17:00:33.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.775]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.775]                   if (TRUE && !signal) {
[17:00:33.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.775]                     {
[17:00:33.775]                       inherits <- base::inherits
[17:00:33.775]                       invokeRestart <- base::invokeRestart
[17:00:33.775]                       is.null <- base::is.null
[17:00:33.775]                       muffled <- FALSE
[17:00:33.775]                       if (inherits(cond, "message")) {
[17:00:33.775]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.775]                         if (muffled) 
[17:00:33.775]                           invokeRestart("muffleMessage")
[17:00:33.775]                       }
[17:00:33.775]                       else if (inherits(cond, "warning")) {
[17:00:33.775]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.775]                         if (muffled) 
[17:00:33.775]                           invokeRestart("muffleWarning")
[17:00:33.775]                       }
[17:00:33.775]                       else if (inherits(cond, "condition")) {
[17:00:33.775]                         if (!is.null(pattern)) {
[17:00:33.775]                           computeRestarts <- base::computeRestarts
[17:00:33.775]                           grepl <- base::grepl
[17:00:33.775]                           restarts <- computeRestarts(cond)
[17:00:33.775]                           for (restart in restarts) {
[17:00:33.775]                             name <- restart$name
[17:00:33.775]                             if (is.null(name)) 
[17:00:33.775]                               next
[17:00:33.775]                             if (!grepl(pattern, name)) 
[17:00:33.775]                               next
[17:00:33.775]                             invokeRestart(restart)
[17:00:33.775]                             muffled <- TRUE
[17:00:33.775]                             break
[17:00:33.775]                           }
[17:00:33.775]                         }
[17:00:33.775]                       }
[17:00:33.775]                       invisible(muffled)
[17:00:33.775]                     }
[17:00:33.775]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.775]                   }
[17:00:33.775]                 }
[17:00:33.775]                 else {
[17:00:33.775]                   if (TRUE) {
[17:00:33.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.775]                     {
[17:00:33.775]                       inherits <- base::inherits
[17:00:33.775]                       invokeRestart <- base::invokeRestart
[17:00:33.775]                       is.null <- base::is.null
[17:00:33.775]                       muffled <- FALSE
[17:00:33.775]                       if (inherits(cond, "message")) {
[17:00:33.775]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.775]                         if (muffled) 
[17:00:33.775]                           invokeRestart("muffleMessage")
[17:00:33.775]                       }
[17:00:33.775]                       else if (inherits(cond, "warning")) {
[17:00:33.775]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.775]                         if (muffled) 
[17:00:33.775]                           invokeRestart("muffleWarning")
[17:00:33.775]                       }
[17:00:33.775]                       else if (inherits(cond, "condition")) {
[17:00:33.775]                         if (!is.null(pattern)) {
[17:00:33.775]                           computeRestarts <- base::computeRestarts
[17:00:33.775]                           grepl <- base::grepl
[17:00:33.775]                           restarts <- computeRestarts(cond)
[17:00:33.775]                           for (restart in restarts) {
[17:00:33.775]                             name <- restart$name
[17:00:33.775]                             if (is.null(name)) 
[17:00:33.775]                               next
[17:00:33.775]                             if (!grepl(pattern, name)) 
[17:00:33.775]                               next
[17:00:33.775]                             invokeRestart(restart)
[17:00:33.775]                             muffled <- TRUE
[17:00:33.775]                             break
[17:00:33.775]                           }
[17:00:33.775]                         }
[17:00:33.775]                       }
[17:00:33.775]                       invisible(muffled)
[17:00:33.775]                     }
[17:00:33.775]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.775]                   }
[17:00:33.775]                 }
[17:00:33.775]             }
[17:00:33.775]         }))
[17:00:33.775]     }, error = function(ex) {
[17:00:33.775]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.775]                 ...future.rng), started = ...future.startTime, 
[17:00:33.775]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.775]             version = "1.8"), class = "FutureResult")
[17:00:33.775]     }, finally = {
[17:00:33.775]         if (!identical(...future.workdir, getwd())) 
[17:00:33.775]             setwd(...future.workdir)
[17:00:33.775]         {
[17:00:33.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.775]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.775]             }
[17:00:33.775]             base::options(...future.oldOptions)
[17:00:33.775]             if (.Platform$OS.type == "windows") {
[17:00:33.775]                 old_names <- names(...future.oldEnvVars)
[17:00:33.775]                 envs <- base::Sys.getenv()
[17:00:33.775]                 names <- names(envs)
[17:00:33.775]                 common <- intersect(names, old_names)
[17:00:33.775]                 added <- setdiff(names, old_names)
[17:00:33.775]                 removed <- setdiff(old_names, names)
[17:00:33.775]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.775]                   envs[common]]
[17:00:33.775]                 NAMES <- toupper(changed)
[17:00:33.775]                 args <- list()
[17:00:33.775]                 for (kk in seq_along(NAMES)) {
[17:00:33.775]                   name <- changed[[kk]]
[17:00:33.775]                   NAME <- NAMES[[kk]]
[17:00:33.775]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.775]                     next
[17:00:33.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.775]                 }
[17:00:33.775]                 NAMES <- toupper(added)
[17:00:33.775]                 for (kk in seq_along(NAMES)) {
[17:00:33.775]                   name <- added[[kk]]
[17:00:33.775]                   NAME <- NAMES[[kk]]
[17:00:33.775]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.775]                     next
[17:00:33.775]                   args[[name]] <- ""
[17:00:33.775]                 }
[17:00:33.775]                 NAMES <- toupper(removed)
[17:00:33.775]                 for (kk in seq_along(NAMES)) {
[17:00:33.775]                   name <- removed[[kk]]
[17:00:33.775]                   NAME <- NAMES[[kk]]
[17:00:33.775]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.775]                     next
[17:00:33.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.775]                 }
[17:00:33.775]                 if (length(args) > 0) 
[17:00:33.775]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.775]             }
[17:00:33.775]             else {
[17:00:33.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.775]             }
[17:00:33.775]             {
[17:00:33.775]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.775]                   0L) {
[17:00:33.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.775]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.775]                   base::options(opts)
[17:00:33.775]                 }
[17:00:33.775]                 {
[17:00:33.775]                   {
[17:00:33.775]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.775]                     NULL
[17:00:33.775]                   }
[17:00:33.775]                   options(future.plan = NULL)
[17:00:33.775]                   if (is.na(NA_character_)) 
[17:00:33.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.775]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.775]                     .init = FALSE)
[17:00:33.775]                 }
[17:00:33.775]             }
[17:00:33.775]         }
[17:00:33.775]     })
[17:00:33.775]     if (TRUE) {
[17:00:33.775]         base::sink(type = "output", split = FALSE)
[17:00:33.775]         if (TRUE) {
[17:00:33.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.775]         }
[17:00:33.775]         else {
[17:00:33.775]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.775]         }
[17:00:33.775]         base::close(...future.stdout)
[17:00:33.775]         ...future.stdout <- NULL
[17:00:33.775]     }
[17:00:33.775]     ...future.result$conditions <- ...future.conditions
[17:00:33.775]     ...future.result$finished <- base::Sys.time()
[17:00:33.775]     ...future.result
[17:00:33.775] }
[17:00:33.777] Poll #1 (0): usedNodes() = 2, workers = 2
[17:00:33.788] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.788] - Validating connection of MultisessionFuture
[17:00:33.788] - received message: FutureResult
[17:00:33.789] - Received FutureResult
[17:00:33.789] - Erased future from FutureRegistry
[17:00:33.789] result() for ClusterFuture ...
[17:00:33.789] - result already collected: FutureResult
[17:00:33.789] result() for ClusterFuture ... done
[17:00:33.789] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.790] result() for ClusterFuture ...
[17:00:33.790] - result already collected: FutureResult
[17:00:33.790] result() for ClusterFuture ... done
[17:00:33.790] result() for ClusterFuture ...
[17:00:33.790] - result already collected: FutureResult
[17:00:33.790] result() for ClusterFuture ... done
[17:00:33.791] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:00:33.791] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:00:33.791] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:00:33.791] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:33.792] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.792] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:00:33.792] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:00:33.792] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:33.793] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.793] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:33.793] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.793] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:00:33.794] MultisessionFuture started
[17:00:33.794] - Launch lazy future ... done
[17:00:33.794] run() for ‘MultisessionFuture’ ... done
[17:00:33.794] Created future:
[17:00:33.794] MultisessionFuture:
[17:00:33.794] Label: ‘future_mapply-3’
[17:00:33.794] Expression:
[17:00:33.794] {
[17:00:33.794]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.794]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.794]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.794]         on.exit(options(oopts), add = TRUE)
[17:00:33.794]     }
[17:00:33.794]     {
[17:00:33.794]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.794]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.794]         do.call(mapply, args = args)
[17:00:33.794]     }
[17:00:33.794] }
[17:00:33.794] Lazy evaluation: FALSE
[17:00:33.794] Asynchronous evaluation: TRUE
[17:00:33.794] Local evaluation: TRUE
[17:00:33.794] Environment: R_GlobalEnv
[17:00:33.794] Capture standard output: TRUE
[17:00:33.794] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.794] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.794] Packages: <none>
[17:00:33.794] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.794] Resolved: FALSE
[17:00:33.794] Value: <not collected>
[17:00:33.794] Conditions captured: <none>
[17:00:33.794] Early signaling: FALSE
[17:00:33.794] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.794] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.806] Chunk #3 of 3 ... DONE
[17:00:33.806] Launching 3 futures (chunks) ... DONE
[17:00:33.806] Resolving 3 futures (chunks) ...
[17:00:33.809] resolve() on list ...
[17:00:33.809]  recursive: 0
[17:00:33.809]  length: 3
[17:00:33.809] 
[17:00:33.809] Future #1
[17:00:33.809] result() for ClusterFuture ...
[17:00:33.809] - result already collected: FutureResult
[17:00:33.809] result() for ClusterFuture ... done
[17:00:33.809] result() for ClusterFuture ...
[17:00:33.810] - result already collected: FutureResult
[17:00:33.810] result() for ClusterFuture ... done
[17:00:33.810] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:33.810] - nx: 3
[17:00:33.810] - relay: TRUE
[17:00:33.810] - stdout: TRUE
[17:00:33.810] - signal: TRUE
[17:00:33.810] - resignal: FALSE
[17:00:33.810] - force: TRUE
[17:00:33.810] - relayed: [n=3] FALSE, FALSE, FALSE
[17:00:33.810] - queued futures: [n=3] FALSE, FALSE, FALSE
[17:00:33.810]  - until=1
[17:00:33.811]  - relaying element #1
[17:00:33.811] result() for ClusterFuture ...
[17:00:33.811] - result already collected: FutureResult
[17:00:33.811] result() for ClusterFuture ... done
[17:00:33.811] result() for ClusterFuture ...
[17:00:33.811] - result already collected: FutureResult
[17:00:33.811] result() for ClusterFuture ... done
[17:00:33.811] result() for ClusterFuture ...
[17:00:33.811] - result already collected: FutureResult
[17:00:33.811] result() for ClusterFuture ... done
[17:00:33.811] result() for ClusterFuture ...
[17:00:33.812] - result already collected: FutureResult
[17:00:33.812] result() for ClusterFuture ... done
[17:00:33.812] - relayed: [n=3] TRUE, FALSE, FALSE
[17:00:33.812] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:00:33.812] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:33.812]  length: 2 (resolved future 1)
[17:00:33.813] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.813] - Validating connection of MultisessionFuture
[17:00:33.813] - received message: FutureResult
[17:00:33.813] - Received FutureResult
[17:00:33.813] - Erased future from FutureRegistry
[17:00:33.813] result() for ClusterFuture ...
[17:00:33.813] - result already collected: FutureResult
[17:00:33.813] result() for ClusterFuture ... done
[17:00:33.813] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.814] Future #2
[17:00:33.814] result() for ClusterFuture ...
[17:00:33.814] - result already collected: FutureResult
[17:00:33.814] result() for ClusterFuture ... done
[17:00:33.814] result() for ClusterFuture ...
[17:00:33.814] - result already collected: FutureResult
[17:00:33.814] result() for ClusterFuture ... done
[17:00:33.814] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:33.814] - nx: 3
[17:00:33.814] - relay: TRUE
[17:00:33.814] - stdout: TRUE
[17:00:33.815] - signal: TRUE
[17:00:33.815] - resignal: FALSE
[17:00:33.815] - force: TRUE
[17:00:33.815] - relayed: [n=3] TRUE, FALSE, FALSE
[17:00:33.815] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:00:33.815]  - until=2
[17:00:33.815]  - relaying element #2
[17:00:33.815] result() for ClusterFuture ...
[17:00:33.815] - result already collected: FutureResult
[17:00:33.815] result() for ClusterFuture ... done
[17:00:33.815] result() for ClusterFuture ...
[17:00:33.815] - result already collected: FutureResult
[17:00:33.816] result() for ClusterFuture ... done
[17:00:33.816] result() for ClusterFuture ...
[17:00:33.816] - result already collected: FutureResult
[17:00:33.816] result() for ClusterFuture ... done
[17:00:33.816] result() for ClusterFuture ...
[17:00:33.816] - result already collected: FutureResult
[17:00:33.816] result() for ClusterFuture ... done
[17:00:33.816] - relayed: [n=3] TRUE, TRUE, FALSE
[17:00:33.816] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:00:33.816] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:33.816]  length: 1 (resolved future 2)
[17:00:33.838] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.838] - Validating connection of MultisessionFuture
[17:00:33.838] - received message: FutureResult
[17:00:33.838] - Received FutureResult
[17:00:33.838] - Erased future from FutureRegistry
[17:00:33.838] result() for ClusterFuture ...
[17:00:33.838] - result already collected: FutureResult
[17:00:33.838] result() for ClusterFuture ... done
[17:00:33.839] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.839] Future #3
[17:00:33.839] result() for ClusterFuture ...
[17:00:33.839] - result already collected: FutureResult
[17:00:33.839] result() for ClusterFuture ... done
[17:00:33.839] result() for ClusterFuture ...
[17:00:33.839] - result already collected: FutureResult
[17:00:33.839] result() for ClusterFuture ... done
[17:00:33.839] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:00:33.839] - nx: 3
[17:00:33.839] - relay: TRUE
[17:00:33.840] - stdout: TRUE
[17:00:33.840] - signal: TRUE
[17:00:33.840] - resignal: FALSE
[17:00:33.840] - force: TRUE
[17:00:33.840] - relayed: [n=3] TRUE, TRUE, FALSE
[17:00:33.840] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:00:33.840]  - until=3
[17:00:33.840]  - relaying element #3
[17:00:33.840] result() for ClusterFuture ...
[17:00:33.840] - result already collected: FutureResult
[17:00:33.840] result() for ClusterFuture ... done
[17:00:33.841] result() for ClusterFuture ...
[17:00:33.841] - result already collected: FutureResult
[17:00:33.841] result() for ClusterFuture ... done
[17:00:33.841] result() for ClusterFuture ...
[17:00:33.841] - result already collected: FutureResult
[17:00:33.841] result() for ClusterFuture ... done
[17:00:33.841] result() for ClusterFuture ...
[17:00:33.841] - result already collected: FutureResult
[17:00:33.841] result() for ClusterFuture ... done
[17:00:33.841] - relayed: [n=3] TRUE, TRUE, TRUE
[17:00:33.841] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:00:33.842] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:00:33.842]  length: 0 (resolved future 3)
[17:00:33.842] Relaying remaining futures
[17:00:33.842] signalConditionsASAP(NULL, pos=0) ...
[17:00:33.842] - nx: 3
[17:00:33.842] - relay: TRUE
[17:00:33.842] - stdout: TRUE
[17:00:33.842] - signal: TRUE
[17:00:33.842] - resignal: FALSE
[17:00:33.842] - force: TRUE
[17:00:33.842] - relayed: [n=3] TRUE, TRUE, TRUE
[17:00:33.842] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[17:00:33.843] - relayed: [n=3] TRUE, TRUE, TRUE
[17:00:33.843] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:00:33.843] signalConditionsASAP(NULL, pos=0) ... done
[17:00:33.843] resolve() on list ... DONE
[17:00:33.843] result() for ClusterFuture ...
[17:00:33.843] - result already collected: FutureResult
[17:00:33.843] result() for ClusterFuture ... done
[17:00:33.843] result() for ClusterFuture ...
[17:00:33.843] - result already collected: FutureResult
[17:00:33.843] result() for ClusterFuture ... done
[17:00:33.843] result() for ClusterFuture ...
[17:00:33.844] - result already collected: FutureResult
[17:00:33.844] result() for ClusterFuture ... done
[17:00:33.844] result() for ClusterFuture ...
[17:00:33.844] - result already collected: FutureResult
[17:00:33.844] result() for ClusterFuture ... done
[17:00:33.844] result() for ClusterFuture ...
[17:00:33.844] - result already collected: FutureResult
[17:00:33.844] result() for ClusterFuture ... done
[17:00:33.844] result() for ClusterFuture ...
[17:00:33.844] - result already collected: FutureResult
[17:00:33.844] result() for ClusterFuture ... done
[17:00:33.845]  - Number of value chunks collected: 3
[17:00:33.845] Resolving 3 futures (chunks) ... DONE
[17:00:33.845] Reducing values from 3 chunks ...
[17:00:33.845]  - Number of values collected after concatenation: 5
[17:00:33.845]  - Number of values expected: 5
[17:00:33.845] Reverse index remapping (attribute 'ordering'): [n = 5] 4, 2, 1, 5, 3
[17:00:33.845] Reducing values from 3 chunks ... DONE
[17:00:33.845] future_mapply() ... DONE
[17:00:33.845] future_mapply() ...
[17:00:33.849] Number of chunks: 2
[17:00:33.849] getGlobalsAndPackagesXApply() ...
[17:00:33.850]  - future.globals: TRUE
[17:00:33.850] getGlobalsAndPackages() ...
[17:00:33.850] Searching for globals...
[17:00:33.851] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:33.851] Searching for globals ... DONE
[17:00:33.851] Resolving globals: FALSE
[17:00:33.852] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:33.852] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:33.852] - globals: [1] ‘FUN’
[17:00:33.852] 
[17:00:33.852] getGlobalsAndPackages() ... DONE
[17:00:33.852]  - globals found/used: [n=1] ‘FUN’
[17:00:33.853]  - needed namespaces: [n=0] 
[17:00:33.853] Finding globals ... DONE
[17:00:33.853] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:33.853] List of 2
[17:00:33.853]  $ ...future.FUN:function (C, k)  
[17:00:33.853]  $ MoreArgs     : list()
[17:00:33.853]  - attr(*, "where")=List of 2
[17:00:33.853]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:33.853]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:33.853]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:33.853]  - attr(*, "resolved")= logi FALSE
[17:00:33.853]  - attr(*, "total_size")= num NA
[17:00:33.855] Packages to be attached in all futures: [n=0] 
[17:00:33.856] getGlobalsAndPackagesXApply() ... DONE
[17:00:33.856] Number of futures (= number of chunks): 2
[17:00:33.856] Launching 2 futures (chunks) ...
[17:00:33.856] Chunk #1 of 2 ...
[17:00:33.856]  - Finding globals in '...' for chunk #1 ...
[17:00:33.856] getGlobalsAndPackages() ...
[17:00:33.856] Searching for globals...
[17:00:33.857] 
[17:00:33.857] Searching for globals ... DONE
[17:00:33.857] - globals: [0] <none>
[17:00:33.857] getGlobalsAndPackages() ... DONE
[17:00:33.857]    + additional globals found: [n=0] 
[17:00:33.857]    + additional namespaces needed: [n=0] 
[17:00:33.857]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:33.857]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:33.857]  - seeds: <none>
[17:00:33.857]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.857] getGlobalsAndPackages() ...
[17:00:33.858] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.858] Resolving globals: FALSE
[17:00:33.858] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:33.859] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:33.859] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.859] 
[17:00:33.859] getGlobalsAndPackages() ... DONE
[17:00:33.859] run() for ‘Future’ ...
[17:00:33.859] - state: ‘created’
[17:00:33.859] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.874] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.874]   - Field: ‘node’
[17:00:33.874]   - Field: ‘label’
[17:00:33.874]   - Field: ‘local’
[17:00:33.874]   - Field: ‘owner’
[17:00:33.874]   - Field: ‘envir’
[17:00:33.875]   - Field: ‘workers’
[17:00:33.875]   - Field: ‘packages’
[17:00:33.875]   - Field: ‘gc’
[17:00:33.875]   - Field: ‘conditions’
[17:00:33.875]   - Field: ‘persistent’
[17:00:33.875]   - Field: ‘expr’
[17:00:33.875]   - Field: ‘uuid’
[17:00:33.875]   - Field: ‘seed’
[17:00:33.875]   - Field: ‘version’
[17:00:33.875]   - Field: ‘result’
[17:00:33.876]   - Field: ‘asynchronous’
[17:00:33.876]   - Field: ‘calls’
[17:00:33.876]   - Field: ‘globals’
[17:00:33.876]   - Field: ‘stdout’
[17:00:33.876]   - Field: ‘earlySignal’
[17:00:33.876]   - Field: ‘lazy’
[17:00:33.876]   - Field: ‘state’
[17:00:33.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.876] - Launch lazy future ...
[17:00:33.877] Packages needed by the future expression (n = 0): <none>
[17:00:33.877] Packages needed by future strategies (n = 0): <none>
[17:00:33.877] {
[17:00:33.877]     {
[17:00:33.877]         {
[17:00:33.877]             ...future.startTime <- base::Sys.time()
[17:00:33.877]             {
[17:00:33.877]                 {
[17:00:33.877]                   {
[17:00:33.877]                     {
[17:00:33.877]                       base::local({
[17:00:33.877]                         has_future <- base::requireNamespace("future", 
[17:00:33.877]                           quietly = TRUE)
[17:00:33.877]                         if (has_future) {
[17:00:33.877]                           ns <- base::getNamespace("future")
[17:00:33.877]                           version <- ns[[".package"]][["version"]]
[17:00:33.877]                           if (is.null(version)) 
[17:00:33.877]                             version <- utils::packageVersion("future")
[17:00:33.877]                         }
[17:00:33.877]                         else {
[17:00:33.877]                           version <- NULL
[17:00:33.877]                         }
[17:00:33.877]                         if (!has_future || version < "1.8.0") {
[17:00:33.877]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.877]                             "", base::R.version$version.string), 
[17:00:33.877]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.877]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.877]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.877]                               "release", "version")], collapse = " "), 
[17:00:33.877]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.877]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.877]                             info)
[17:00:33.877]                           info <- base::paste(info, collapse = "; ")
[17:00:33.877]                           if (!has_future) {
[17:00:33.877]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.877]                               info)
[17:00:33.877]                           }
[17:00:33.877]                           else {
[17:00:33.877]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.877]                               info, version)
[17:00:33.877]                           }
[17:00:33.877]                           base::stop(msg)
[17:00:33.877]                         }
[17:00:33.877]                       })
[17:00:33.877]                     }
[17:00:33.877]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.877]                     base::options(mc.cores = 1L)
[17:00:33.877]                   }
[17:00:33.877]                   ...future.strategy.old <- future::plan("list")
[17:00:33.877]                   options(future.plan = NULL)
[17:00:33.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.877]                 }
[17:00:33.877]                 ...future.workdir <- getwd()
[17:00:33.877]             }
[17:00:33.877]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.877]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.877]         }
[17:00:33.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.877]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:33.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.877]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.877]             base::names(...future.oldOptions))
[17:00:33.877]     }
[17:00:33.877]     if (FALSE) {
[17:00:33.877]     }
[17:00:33.877]     else {
[17:00:33.877]         if (TRUE) {
[17:00:33.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.877]                 open = "w")
[17:00:33.877]         }
[17:00:33.877]         else {
[17:00:33.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.877]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.877]         }
[17:00:33.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.877]             base::sink(type = "output", split = FALSE)
[17:00:33.877]             base::close(...future.stdout)
[17:00:33.877]         }, add = TRUE)
[17:00:33.877]     }
[17:00:33.877]     ...future.frame <- base::sys.nframe()
[17:00:33.877]     ...future.conditions <- base::list()
[17:00:33.877]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.877]     if (FALSE) {
[17:00:33.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.877]     }
[17:00:33.877]     ...future.result <- base::tryCatch({
[17:00:33.877]         base::withCallingHandlers({
[17:00:33.877]             ...future.value <- base::withVisible(base::local({
[17:00:33.877]                 ...future.makeSendCondition <- base::local({
[17:00:33.877]                   sendCondition <- NULL
[17:00:33.877]                   function(frame = 1L) {
[17:00:33.877]                     if (is.function(sendCondition)) 
[17:00:33.877]                       return(sendCondition)
[17:00:33.877]                     ns <- getNamespace("parallel")
[17:00:33.877]                     if (exists("sendData", mode = "function", 
[17:00:33.877]                       envir = ns)) {
[17:00:33.877]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.877]                         envir = ns)
[17:00:33.877]                       envir <- sys.frame(frame)
[17:00:33.877]                       master <- NULL
[17:00:33.877]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.877]                         !identical(envir, emptyenv())) {
[17:00:33.877]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.877]                           inherits = FALSE)) {
[17:00:33.877]                           master <- get("master", mode = "list", 
[17:00:33.877]                             envir = envir, inherits = FALSE)
[17:00:33.877]                           if (inherits(master, c("SOCKnode", 
[17:00:33.877]                             "SOCK0node"))) {
[17:00:33.877]                             sendCondition <<- function(cond) {
[17:00:33.877]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.877]                                 success = TRUE)
[17:00:33.877]                               parallel_sendData(master, data)
[17:00:33.877]                             }
[17:00:33.877]                             return(sendCondition)
[17:00:33.877]                           }
[17:00:33.877]                         }
[17:00:33.877]                         frame <- frame + 1L
[17:00:33.877]                         envir <- sys.frame(frame)
[17:00:33.877]                       }
[17:00:33.877]                     }
[17:00:33.877]                     sendCondition <<- function(cond) NULL
[17:00:33.877]                   }
[17:00:33.877]                 })
[17:00:33.877]                 withCallingHandlers({
[17:00:33.877]                   {
[17:00:33.877]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.877]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.877]                       ...future.globals.maxSize)) {
[17:00:33.877]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.877]                       on.exit(options(oopts), add = TRUE)
[17:00:33.877]                     }
[17:00:33.877]                     {
[17:00:33.877]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.877]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.877]                         USE.NAMES = FALSE)
[17:00:33.877]                       do.call(mapply, args = args)
[17:00:33.877]                     }
[17:00:33.877]                   }
[17:00:33.877]                 }, immediateCondition = function(cond) {
[17:00:33.877]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.877]                   sendCondition(cond)
[17:00:33.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.877]                   {
[17:00:33.877]                     inherits <- base::inherits
[17:00:33.877]                     invokeRestart <- base::invokeRestart
[17:00:33.877]                     is.null <- base::is.null
[17:00:33.877]                     muffled <- FALSE
[17:00:33.877]                     if (inherits(cond, "message")) {
[17:00:33.877]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.877]                       if (muffled) 
[17:00:33.877]                         invokeRestart("muffleMessage")
[17:00:33.877]                     }
[17:00:33.877]                     else if (inherits(cond, "warning")) {
[17:00:33.877]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.877]                       if (muffled) 
[17:00:33.877]                         invokeRestart("muffleWarning")
[17:00:33.877]                     }
[17:00:33.877]                     else if (inherits(cond, "condition")) {
[17:00:33.877]                       if (!is.null(pattern)) {
[17:00:33.877]                         computeRestarts <- base::computeRestarts
[17:00:33.877]                         grepl <- base::grepl
[17:00:33.877]                         restarts <- computeRestarts(cond)
[17:00:33.877]                         for (restart in restarts) {
[17:00:33.877]                           name <- restart$name
[17:00:33.877]                           if (is.null(name)) 
[17:00:33.877]                             next
[17:00:33.877]                           if (!grepl(pattern, name)) 
[17:00:33.877]                             next
[17:00:33.877]                           invokeRestart(restart)
[17:00:33.877]                           muffled <- TRUE
[17:00:33.877]                           break
[17:00:33.877]                         }
[17:00:33.877]                       }
[17:00:33.877]                     }
[17:00:33.877]                     invisible(muffled)
[17:00:33.877]                   }
[17:00:33.877]                   muffleCondition(cond)
[17:00:33.877]                 })
[17:00:33.877]             }))
[17:00:33.877]             future::FutureResult(value = ...future.value$value, 
[17:00:33.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.877]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.877]                     ...future.globalenv.names))
[17:00:33.877]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.877]         }, condition = base::local({
[17:00:33.877]             c <- base::c
[17:00:33.877]             inherits <- base::inherits
[17:00:33.877]             invokeRestart <- base::invokeRestart
[17:00:33.877]             length <- base::length
[17:00:33.877]             list <- base::list
[17:00:33.877]             seq.int <- base::seq.int
[17:00:33.877]             signalCondition <- base::signalCondition
[17:00:33.877]             sys.calls <- base::sys.calls
[17:00:33.877]             `[[` <- base::`[[`
[17:00:33.877]             `+` <- base::`+`
[17:00:33.877]             `<<-` <- base::`<<-`
[17:00:33.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.877]                   3L)]
[17:00:33.877]             }
[17:00:33.877]             function(cond) {
[17:00:33.877]                 is_error <- inherits(cond, "error")
[17:00:33.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.877]                   NULL)
[17:00:33.877]                 if (is_error) {
[17:00:33.877]                   sessionInformation <- function() {
[17:00:33.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.877]                       search = base::search(), system = base::Sys.info())
[17:00:33.877]                   }
[17:00:33.877]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.877]                     cond$call), session = sessionInformation(), 
[17:00:33.877]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.877]                   signalCondition(cond)
[17:00:33.877]                 }
[17:00:33.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.877]                 "immediateCondition"))) {
[17:00:33.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.877]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.877]                   if (TRUE && !signal) {
[17:00:33.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.877]                     {
[17:00:33.877]                       inherits <- base::inherits
[17:00:33.877]                       invokeRestart <- base::invokeRestart
[17:00:33.877]                       is.null <- base::is.null
[17:00:33.877]                       muffled <- FALSE
[17:00:33.877]                       if (inherits(cond, "message")) {
[17:00:33.877]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.877]                         if (muffled) 
[17:00:33.877]                           invokeRestart("muffleMessage")
[17:00:33.877]                       }
[17:00:33.877]                       else if (inherits(cond, "warning")) {
[17:00:33.877]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.877]                         if (muffled) 
[17:00:33.877]                           invokeRestart("muffleWarning")
[17:00:33.877]                       }
[17:00:33.877]                       else if (inherits(cond, "condition")) {
[17:00:33.877]                         if (!is.null(pattern)) {
[17:00:33.877]                           computeRestarts <- base::computeRestarts
[17:00:33.877]                           grepl <- base::grepl
[17:00:33.877]                           restarts <- computeRestarts(cond)
[17:00:33.877]                           for (restart in restarts) {
[17:00:33.877]                             name <- restart$name
[17:00:33.877]                             if (is.null(name)) 
[17:00:33.877]                               next
[17:00:33.877]                             if (!grepl(pattern, name)) 
[17:00:33.877]                               next
[17:00:33.877]                             invokeRestart(restart)
[17:00:33.877]                             muffled <- TRUE
[17:00:33.877]                             break
[17:00:33.877]                           }
[17:00:33.877]                         }
[17:00:33.877]                       }
[17:00:33.877]                       invisible(muffled)
[17:00:33.877]                     }
[17:00:33.877]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.877]                   }
[17:00:33.877]                 }
[17:00:33.877]                 else {
[17:00:33.877]                   if (TRUE) {
[17:00:33.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.877]                     {
[17:00:33.877]                       inherits <- base::inherits
[17:00:33.877]                       invokeRestart <- base::invokeRestart
[17:00:33.877]                       is.null <- base::is.null
[17:00:33.877]                       muffled <- FALSE
[17:00:33.877]                       if (inherits(cond, "message")) {
[17:00:33.877]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.877]                         if (muffled) 
[17:00:33.877]                           invokeRestart("muffleMessage")
[17:00:33.877]                       }
[17:00:33.877]                       else if (inherits(cond, "warning")) {
[17:00:33.877]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.877]                         if (muffled) 
[17:00:33.877]                           invokeRestart("muffleWarning")
[17:00:33.877]                       }
[17:00:33.877]                       else if (inherits(cond, "condition")) {
[17:00:33.877]                         if (!is.null(pattern)) {
[17:00:33.877]                           computeRestarts <- base::computeRestarts
[17:00:33.877]                           grepl <- base::grepl
[17:00:33.877]                           restarts <- computeRestarts(cond)
[17:00:33.877]                           for (restart in restarts) {
[17:00:33.877]                             name <- restart$name
[17:00:33.877]                             if (is.null(name)) 
[17:00:33.877]                               next
[17:00:33.877]                             if (!grepl(pattern, name)) 
[17:00:33.877]                               next
[17:00:33.877]                             invokeRestart(restart)
[17:00:33.877]                             muffled <- TRUE
[17:00:33.877]                             break
[17:00:33.877]                           }
[17:00:33.877]                         }
[17:00:33.877]                       }
[17:00:33.877]                       invisible(muffled)
[17:00:33.877]                     }
[17:00:33.877]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.877]                   }
[17:00:33.877]                 }
[17:00:33.877]             }
[17:00:33.877]         }))
[17:00:33.877]     }, error = function(ex) {
[17:00:33.877]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.877]                 ...future.rng), started = ...future.startTime, 
[17:00:33.877]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.877]             version = "1.8"), class = "FutureResult")
[17:00:33.877]     }, finally = {
[17:00:33.877]         if (!identical(...future.workdir, getwd())) 
[17:00:33.877]             setwd(...future.workdir)
[17:00:33.877]         {
[17:00:33.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.877]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.877]             }
[17:00:33.877]             base::options(...future.oldOptions)
[17:00:33.877]             if (.Platform$OS.type == "windows") {
[17:00:33.877]                 old_names <- names(...future.oldEnvVars)
[17:00:33.877]                 envs <- base::Sys.getenv()
[17:00:33.877]                 names <- names(envs)
[17:00:33.877]                 common <- intersect(names, old_names)
[17:00:33.877]                 added <- setdiff(names, old_names)
[17:00:33.877]                 removed <- setdiff(old_names, names)
[17:00:33.877]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.877]                   envs[common]]
[17:00:33.877]                 NAMES <- toupper(changed)
[17:00:33.877]                 args <- list()
[17:00:33.877]                 for (kk in seq_along(NAMES)) {
[17:00:33.877]                   name <- changed[[kk]]
[17:00:33.877]                   NAME <- NAMES[[kk]]
[17:00:33.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.877]                     next
[17:00:33.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.877]                 }
[17:00:33.877]                 NAMES <- toupper(added)
[17:00:33.877]                 for (kk in seq_along(NAMES)) {
[17:00:33.877]                   name <- added[[kk]]
[17:00:33.877]                   NAME <- NAMES[[kk]]
[17:00:33.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.877]                     next
[17:00:33.877]                   args[[name]] <- ""
[17:00:33.877]                 }
[17:00:33.877]                 NAMES <- toupper(removed)
[17:00:33.877]                 for (kk in seq_along(NAMES)) {
[17:00:33.877]                   name <- removed[[kk]]
[17:00:33.877]                   NAME <- NAMES[[kk]]
[17:00:33.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.877]                     next
[17:00:33.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.877]                 }
[17:00:33.877]                 if (length(args) > 0) 
[17:00:33.877]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.877]             }
[17:00:33.877]             else {
[17:00:33.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.877]             }
[17:00:33.877]             {
[17:00:33.877]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.877]                   0L) {
[17:00:33.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.877]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.877]                   base::options(opts)
[17:00:33.877]                 }
[17:00:33.877]                 {
[17:00:33.877]                   {
[17:00:33.877]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.877]                     NULL
[17:00:33.877]                   }
[17:00:33.877]                   options(future.plan = NULL)
[17:00:33.877]                   if (is.na(NA_character_)) 
[17:00:33.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.877]                     .init = FALSE)
[17:00:33.877]                 }
[17:00:33.877]             }
[17:00:33.877]         }
[17:00:33.877]     })
[17:00:33.877]     if (TRUE) {
[17:00:33.877]         base::sink(type = "output", split = FALSE)
[17:00:33.877]         if (TRUE) {
[17:00:33.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.877]         }
[17:00:33.877]         else {
[17:00:33.877]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.877]         }
[17:00:33.877]         base::close(...future.stdout)
[17:00:33.877]         ...future.stdout <- NULL
[17:00:33.877]     }
[17:00:33.877]     ...future.result$conditions <- ...future.conditions
[17:00:33.877]     ...future.result$finished <- base::Sys.time()
[17:00:33.877]     ...future.result
[17:00:33.877] }
[17:00:33.881] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:00:33.881] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:00:33.881] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:00:33.882] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:33.882] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.882] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:00:33.883] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:00:33.883] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:33.883] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.883] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:33.884] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:33.884] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:00:33.885] MultisessionFuture started
[17:00:33.885] - Launch lazy future ... done
[17:00:33.885] run() for ‘MultisessionFuture’ ... done
[17:00:33.885] Created future:
[17:00:33.885] MultisessionFuture:
[17:00:33.885] Label: ‘future_.mapply-1’
[17:00:33.885] Expression:
[17:00:33.885] {
[17:00:33.885]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.885]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.885]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.885]         on.exit(options(oopts), add = TRUE)
[17:00:33.885]     }
[17:00:33.885]     {
[17:00:33.885]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.885]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.885]         do.call(mapply, args = args)
[17:00:33.885]     }
[17:00:33.885] }
[17:00:33.885] Lazy evaluation: FALSE
[17:00:33.885] Asynchronous evaluation: TRUE
[17:00:33.885] Local evaluation: TRUE
[17:00:33.885] Environment: R_GlobalEnv
[17:00:33.885] Capture standard output: TRUE
[17:00:33.885] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.885] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.885] Packages: <none>
[17:00:33.885] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.885] Resolved: FALSE
[17:00:33.885] Value: <not collected>
[17:00:33.885] Conditions captured: <none>
[17:00:33.885] Early signaling: FALSE
[17:00:33.885] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.885] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.896] Chunk #1 of 2 ... DONE
[17:00:33.897] Chunk #2 of 2 ...
[17:00:33.897]  - Finding globals in '...' for chunk #2 ...
[17:00:33.897] getGlobalsAndPackages() ...
[17:00:33.897] Searching for globals...
[17:00:33.897] 
[17:00:33.897] Searching for globals ... DONE
[17:00:33.897] - globals: [0] <none>
[17:00:33.898] getGlobalsAndPackages() ... DONE
[17:00:33.898]    + additional globals found: [n=0] 
[17:00:33.898]    + additional namespaces needed: [n=0] 
[17:00:33.898]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:33.898]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:33.898]  - seeds: <none>
[17:00:33.898]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.898] getGlobalsAndPackages() ...
[17:00:33.898] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.898] Resolving globals: FALSE
[17:00:33.899] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:00:33.899] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:33.900] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.900] 
[17:00:33.900] getGlobalsAndPackages() ... DONE
[17:00:33.900] run() for ‘Future’ ...
[17:00:33.900] - state: ‘created’
[17:00:33.900] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:33.915] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:33.915]   - Field: ‘node’
[17:00:33.915]   - Field: ‘label’
[17:00:33.915]   - Field: ‘local’
[17:00:33.916]   - Field: ‘owner’
[17:00:33.916]   - Field: ‘envir’
[17:00:33.916]   - Field: ‘workers’
[17:00:33.916]   - Field: ‘packages’
[17:00:33.916]   - Field: ‘gc’
[17:00:33.916]   - Field: ‘conditions’
[17:00:33.916]   - Field: ‘persistent’
[17:00:33.916]   - Field: ‘expr’
[17:00:33.916]   - Field: ‘uuid’
[17:00:33.916]   - Field: ‘seed’
[17:00:33.916]   - Field: ‘version’
[17:00:33.917]   - Field: ‘result’
[17:00:33.917]   - Field: ‘asynchronous’
[17:00:33.917]   - Field: ‘calls’
[17:00:33.917]   - Field: ‘globals’
[17:00:33.917]   - Field: ‘stdout’
[17:00:33.917]   - Field: ‘earlySignal’
[17:00:33.917]   - Field: ‘lazy’
[17:00:33.917]   - Field: ‘state’
[17:00:33.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:33.917] - Launch lazy future ...
[17:00:33.918] Packages needed by the future expression (n = 0): <none>
[17:00:33.918] Packages needed by future strategies (n = 0): <none>
[17:00:33.918] {
[17:00:33.918]     {
[17:00:33.918]         {
[17:00:33.918]             ...future.startTime <- base::Sys.time()
[17:00:33.918]             {
[17:00:33.918]                 {
[17:00:33.918]                   {
[17:00:33.918]                     {
[17:00:33.918]                       base::local({
[17:00:33.918]                         has_future <- base::requireNamespace("future", 
[17:00:33.918]                           quietly = TRUE)
[17:00:33.918]                         if (has_future) {
[17:00:33.918]                           ns <- base::getNamespace("future")
[17:00:33.918]                           version <- ns[[".package"]][["version"]]
[17:00:33.918]                           if (is.null(version)) 
[17:00:33.918]                             version <- utils::packageVersion("future")
[17:00:33.918]                         }
[17:00:33.918]                         else {
[17:00:33.918]                           version <- NULL
[17:00:33.918]                         }
[17:00:33.918]                         if (!has_future || version < "1.8.0") {
[17:00:33.918]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:33.918]                             "", base::R.version$version.string), 
[17:00:33.918]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:33.918]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:33.918]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:33.918]                               "release", "version")], collapse = " "), 
[17:00:33.918]                             hostname = base::Sys.info()[["nodename"]])
[17:00:33.918]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:33.918]                             info)
[17:00:33.918]                           info <- base::paste(info, collapse = "; ")
[17:00:33.918]                           if (!has_future) {
[17:00:33.918]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:33.918]                               info)
[17:00:33.918]                           }
[17:00:33.918]                           else {
[17:00:33.918]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:33.918]                               info, version)
[17:00:33.918]                           }
[17:00:33.918]                           base::stop(msg)
[17:00:33.918]                         }
[17:00:33.918]                       })
[17:00:33.918]                     }
[17:00:33.918]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:33.918]                     base::options(mc.cores = 1L)
[17:00:33.918]                   }
[17:00:33.918]                   ...future.strategy.old <- future::plan("list")
[17:00:33.918]                   options(future.plan = NULL)
[17:00:33.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:33.918]                 }
[17:00:33.918]                 ...future.workdir <- getwd()
[17:00:33.918]             }
[17:00:33.918]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:33.918]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:33.918]         }
[17:00:33.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:33.918]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:33.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:33.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:33.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:33.918]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:33.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:33.918]             base::names(...future.oldOptions))
[17:00:33.918]     }
[17:00:33.918]     if (FALSE) {
[17:00:33.918]     }
[17:00:33.918]     else {
[17:00:33.918]         if (TRUE) {
[17:00:33.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:33.918]                 open = "w")
[17:00:33.918]         }
[17:00:33.918]         else {
[17:00:33.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:33.918]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:33.918]         }
[17:00:33.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:33.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:33.918]             base::sink(type = "output", split = FALSE)
[17:00:33.918]             base::close(...future.stdout)
[17:00:33.918]         }, add = TRUE)
[17:00:33.918]     }
[17:00:33.918]     ...future.frame <- base::sys.nframe()
[17:00:33.918]     ...future.conditions <- base::list()
[17:00:33.918]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:33.918]     if (FALSE) {
[17:00:33.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:33.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:33.918]     }
[17:00:33.918]     ...future.result <- base::tryCatch({
[17:00:33.918]         base::withCallingHandlers({
[17:00:33.918]             ...future.value <- base::withVisible(base::local({
[17:00:33.918]                 ...future.makeSendCondition <- base::local({
[17:00:33.918]                   sendCondition <- NULL
[17:00:33.918]                   function(frame = 1L) {
[17:00:33.918]                     if (is.function(sendCondition)) 
[17:00:33.918]                       return(sendCondition)
[17:00:33.918]                     ns <- getNamespace("parallel")
[17:00:33.918]                     if (exists("sendData", mode = "function", 
[17:00:33.918]                       envir = ns)) {
[17:00:33.918]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:33.918]                         envir = ns)
[17:00:33.918]                       envir <- sys.frame(frame)
[17:00:33.918]                       master <- NULL
[17:00:33.918]                       while (!identical(envir, .GlobalEnv) && 
[17:00:33.918]                         !identical(envir, emptyenv())) {
[17:00:33.918]                         if (exists("master", mode = "list", envir = envir, 
[17:00:33.918]                           inherits = FALSE)) {
[17:00:33.918]                           master <- get("master", mode = "list", 
[17:00:33.918]                             envir = envir, inherits = FALSE)
[17:00:33.918]                           if (inherits(master, c("SOCKnode", 
[17:00:33.918]                             "SOCK0node"))) {
[17:00:33.918]                             sendCondition <<- function(cond) {
[17:00:33.918]                               data <- list(type = "VALUE", value = cond, 
[17:00:33.918]                                 success = TRUE)
[17:00:33.918]                               parallel_sendData(master, data)
[17:00:33.918]                             }
[17:00:33.918]                             return(sendCondition)
[17:00:33.918]                           }
[17:00:33.918]                         }
[17:00:33.918]                         frame <- frame + 1L
[17:00:33.918]                         envir <- sys.frame(frame)
[17:00:33.918]                       }
[17:00:33.918]                     }
[17:00:33.918]                     sendCondition <<- function(cond) NULL
[17:00:33.918]                   }
[17:00:33.918]                 })
[17:00:33.918]                 withCallingHandlers({
[17:00:33.918]                   {
[17:00:33.918]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.918]                     if (!identical(...future.globals.maxSize.org, 
[17:00:33.918]                       ...future.globals.maxSize)) {
[17:00:33.918]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.918]                       on.exit(options(oopts), add = TRUE)
[17:00:33.918]                     }
[17:00:33.918]                     {
[17:00:33.918]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.918]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:33.918]                         USE.NAMES = FALSE)
[17:00:33.918]                       do.call(mapply, args = args)
[17:00:33.918]                     }
[17:00:33.918]                   }
[17:00:33.918]                 }, immediateCondition = function(cond) {
[17:00:33.918]                   sendCondition <- ...future.makeSendCondition()
[17:00:33.918]                   sendCondition(cond)
[17:00:33.918]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.918]                   {
[17:00:33.918]                     inherits <- base::inherits
[17:00:33.918]                     invokeRestart <- base::invokeRestart
[17:00:33.918]                     is.null <- base::is.null
[17:00:33.918]                     muffled <- FALSE
[17:00:33.918]                     if (inherits(cond, "message")) {
[17:00:33.918]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:33.918]                       if (muffled) 
[17:00:33.918]                         invokeRestart("muffleMessage")
[17:00:33.918]                     }
[17:00:33.918]                     else if (inherits(cond, "warning")) {
[17:00:33.918]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:33.918]                       if (muffled) 
[17:00:33.918]                         invokeRestart("muffleWarning")
[17:00:33.918]                     }
[17:00:33.918]                     else if (inherits(cond, "condition")) {
[17:00:33.918]                       if (!is.null(pattern)) {
[17:00:33.918]                         computeRestarts <- base::computeRestarts
[17:00:33.918]                         grepl <- base::grepl
[17:00:33.918]                         restarts <- computeRestarts(cond)
[17:00:33.918]                         for (restart in restarts) {
[17:00:33.918]                           name <- restart$name
[17:00:33.918]                           if (is.null(name)) 
[17:00:33.918]                             next
[17:00:33.918]                           if (!grepl(pattern, name)) 
[17:00:33.918]                             next
[17:00:33.918]                           invokeRestart(restart)
[17:00:33.918]                           muffled <- TRUE
[17:00:33.918]                           break
[17:00:33.918]                         }
[17:00:33.918]                       }
[17:00:33.918]                     }
[17:00:33.918]                     invisible(muffled)
[17:00:33.918]                   }
[17:00:33.918]                   muffleCondition(cond)
[17:00:33.918]                 })
[17:00:33.918]             }))
[17:00:33.918]             future::FutureResult(value = ...future.value$value, 
[17:00:33.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.918]                   ...future.rng), globalenv = if (FALSE) 
[17:00:33.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:33.918]                     ...future.globalenv.names))
[17:00:33.918]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:33.918]         }, condition = base::local({
[17:00:33.918]             c <- base::c
[17:00:33.918]             inherits <- base::inherits
[17:00:33.918]             invokeRestart <- base::invokeRestart
[17:00:33.918]             length <- base::length
[17:00:33.918]             list <- base::list
[17:00:33.918]             seq.int <- base::seq.int
[17:00:33.918]             signalCondition <- base::signalCondition
[17:00:33.918]             sys.calls <- base::sys.calls
[17:00:33.918]             `[[` <- base::`[[`
[17:00:33.918]             `+` <- base::`+`
[17:00:33.918]             `<<-` <- base::`<<-`
[17:00:33.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:33.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:33.918]                   3L)]
[17:00:33.918]             }
[17:00:33.918]             function(cond) {
[17:00:33.918]                 is_error <- inherits(cond, "error")
[17:00:33.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:33.918]                   NULL)
[17:00:33.918]                 if (is_error) {
[17:00:33.918]                   sessionInformation <- function() {
[17:00:33.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:33.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:33.918]                       search = base::search(), system = base::Sys.info())
[17:00:33.918]                   }
[17:00:33.918]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:33.918]                     cond$call), session = sessionInformation(), 
[17:00:33.918]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:33.918]                   signalCondition(cond)
[17:00:33.918]                 }
[17:00:33.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:33.918]                 "immediateCondition"))) {
[17:00:33.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:33.918]                   ...future.conditions[[length(...future.conditions) + 
[17:00:33.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:33.918]                   if (TRUE && !signal) {
[17:00:33.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.918]                     {
[17:00:33.918]                       inherits <- base::inherits
[17:00:33.918]                       invokeRestart <- base::invokeRestart
[17:00:33.918]                       is.null <- base::is.null
[17:00:33.918]                       muffled <- FALSE
[17:00:33.918]                       if (inherits(cond, "message")) {
[17:00:33.918]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.918]                         if (muffled) 
[17:00:33.918]                           invokeRestart("muffleMessage")
[17:00:33.918]                       }
[17:00:33.918]                       else if (inherits(cond, "warning")) {
[17:00:33.918]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.918]                         if (muffled) 
[17:00:33.918]                           invokeRestart("muffleWarning")
[17:00:33.918]                       }
[17:00:33.918]                       else if (inherits(cond, "condition")) {
[17:00:33.918]                         if (!is.null(pattern)) {
[17:00:33.918]                           computeRestarts <- base::computeRestarts
[17:00:33.918]                           grepl <- base::grepl
[17:00:33.918]                           restarts <- computeRestarts(cond)
[17:00:33.918]                           for (restart in restarts) {
[17:00:33.918]                             name <- restart$name
[17:00:33.918]                             if (is.null(name)) 
[17:00:33.918]                               next
[17:00:33.918]                             if (!grepl(pattern, name)) 
[17:00:33.918]                               next
[17:00:33.918]                             invokeRestart(restart)
[17:00:33.918]                             muffled <- TRUE
[17:00:33.918]                             break
[17:00:33.918]                           }
[17:00:33.918]                         }
[17:00:33.918]                       }
[17:00:33.918]                       invisible(muffled)
[17:00:33.918]                     }
[17:00:33.918]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.918]                   }
[17:00:33.918]                 }
[17:00:33.918]                 else {
[17:00:33.918]                   if (TRUE) {
[17:00:33.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:33.918]                     {
[17:00:33.918]                       inherits <- base::inherits
[17:00:33.918]                       invokeRestart <- base::invokeRestart
[17:00:33.918]                       is.null <- base::is.null
[17:00:33.918]                       muffled <- FALSE
[17:00:33.918]                       if (inherits(cond, "message")) {
[17:00:33.918]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:33.918]                         if (muffled) 
[17:00:33.918]                           invokeRestart("muffleMessage")
[17:00:33.918]                       }
[17:00:33.918]                       else if (inherits(cond, "warning")) {
[17:00:33.918]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:33.918]                         if (muffled) 
[17:00:33.918]                           invokeRestart("muffleWarning")
[17:00:33.918]                       }
[17:00:33.918]                       else if (inherits(cond, "condition")) {
[17:00:33.918]                         if (!is.null(pattern)) {
[17:00:33.918]                           computeRestarts <- base::computeRestarts
[17:00:33.918]                           grepl <- base::grepl
[17:00:33.918]                           restarts <- computeRestarts(cond)
[17:00:33.918]                           for (restart in restarts) {
[17:00:33.918]                             name <- restart$name
[17:00:33.918]                             if (is.null(name)) 
[17:00:33.918]                               next
[17:00:33.918]                             if (!grepl(pattern, name)) 
[17:00:33.918]                               next
[17:00:33.918]                             invokeRestart(restart)
[17:00:33.918]                             muffled <- TRUE
[17:00:33.918]                             break
[17:00:33.918]                           }
[17:00:33.918]                         }
[17:00:33.918]                       }
[17:00:33.918]                       invisible(muffled)
[17:00:33.918]                     }
[17:00:33.918]                     muffleCondition(cond, pattern = "^muffle")
[17:00:33.918]                   }
[17:00:33.918]                 }
[17:00:33.918]             }
[17:00:33.918]         }))
[17:00:33.918]     }, error = function(ex) {
[17:00:33.918]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:33.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:33.918]                 ...future.rng), started = ...future.startTime, 
[17:00:33.918]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:33.918]             version = "1.8"), class = "FutureResult")
[17:00:33.918]     }, finally = {
[17:00:33.918]         if (!identical(...future.workdir, getwd())) 
[17:00:33.918]             setwd(...future.workdir)
[17:00:33.918]         {
[17:00:33.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:33.918]                 ...future.oldOptions$nwarnings <- NULL
[17:00:33.918]             }
[17:00:33.918]             base::options(...future.oldOptions)
[17:00:33.918]             if (.Platform$OS.type == "windows") {
[17:00:33.918]                 old_names <- names(...future.oldEnvVars)
[17:00:33.918]                 envs <- base::Sys.getenv()
[17:00:33.918]                 names <- names(envs)
[17:00:33.918]                 common <- intersect(names, old_names)
[17:00:33.918]                 added <- setdiff(names, old_names)
[17:00:33.918]                 removed <- setdiff(old_names, names)
[17:00:33.918]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:33.918]                   envs[common]]
[17:00:33.918]                 NAMES <- toupper(changed)
[17:00:33.918]                 args <- list()
[17:00:33.918]                 for (kk in seq_along(NAMES)) {
[17:00:33.918]                   name <- changed[[kk]]
[17:00:33.918]                   NAME <- NAMES[[kk]]
[17:00:33.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.918]                     next
[17:00:33.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.918]                 }
[17:00:33.918]                 NAMES <- toupper(added)
[17:00:33.918]                 for (kk in seq_along(NAMES)) {
[17:00:33.918]                   name <- added[[kk]]
[17:00:33.918]                   NAME <- NAMES[[kk]]
[17:00:33.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.918]                     next
[17:00:33.918]                   args[[name]] <- ""
[17:00:33.918]                 }
[17:00:33.918]                 NAMES <- toupper(removed)
[17:00:33.918]                 for (kk in seq_along(NAMES)) {
[17:00:33.918]                   name <- removed[[kk]]
[17:00:33.918]                   NAME <- NAMES[[kk]]
[17:00:33.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:33.918]                     next
[17:00:33.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:33.918]                 }
[17:00:33.918]                 if (length(args) > 0) 
[17:00:33.918]                   base::do.call(base::Sys.setenv, args = args)
[17:00:33.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:33.918]             }
[17:00:33.918]             else {
[17:00:33.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:33.918]             }
[17:00:33.918]             {
[17:00:33.918]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:33.918]                   0L) {
[17:00:33.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:33.918]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:33.918]                   base::options(opts)
[17:00:33.918]                 }
[17:00:33.918]                 {
[17:00:33.918]                   {
[17:00:33.918]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:33.918]                     NULL
[17:00:33.918]                   }
[17:00:33.918]                   options(future.plan = NULL)
[17:00:33.918]                   if (is.na(NA_character_)) 
[17:00:33.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:33.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:33.918]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:33.918]                     .init = FALSE)
[17:00:33.918]                 }
[17:00:33.918]             }
[17:00:33.918]         }
[17:00:33.918]     })
[17:00:33.918]     if (TRUE) {
[17:00:33.918]         base::sink(type = "output", split = FALSE)
[17:00:33.918]         if (TRUE) {
[17:00:33.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:33.918]         }
[17:00:33.918]         else {
[17:00:33.918]             ...future.result["stdout"] <- base::list(NULL)
[17:00:33.918]         }
[17:00:33.918]         base::close(...future.stdout)
[17:00:33.918]         ...future.stdout <- NULL
[17:00:33.918]     }
[17:00:33.918]     ...future.result$conditions <- ...future.conditions
[17:00:33.918]     ...future.result$finished <- base::Sys.time()
[17:00:33.918]     ...future.result
[17:00:33.918] }
[17:00:33.921] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:00:33.921] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:00:33.921] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:00:33.922] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:33.922] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.922] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:00:33.922] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:00:33.923] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:33.923] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.923] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:33.923] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:33.923] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:00:33.924] MultisessionFuture started
[17:00:33.924] - Launch lazy future ... done
[17:00:33.924] run() for ‘MultisessionFuture’ ... done
[17:00:33.924] Created future:
[17:00:33.924] MultisessionFuture:
[17:00:33.924] Label: ‘future_.mapply-2’
[17:00:33.924] Expression:
[17:00:33.924] {
[17:00:33.924]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:33.924]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:33.924]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:33.924]         on.exit(options(oopts), add = TRUE)
[17:00:33.924]     }
[17:00:33.924]     {
[17:00:33.924]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:33.924]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:33.924]         do.call(mapply, args = args)
[17:00:33.924]     }
[17:00:33.924] }
[17:00:33.924] Lazy evaluation: FALSE
[17:00:33.924] Asynchronous evaluation: TRUE
[17:00:33.924] Local evaluation: TRUE
[17:00:33.924] Environment: R_GlobalEnv
[17:00:33.924] Capture standard output: TRUE
[17:00:33.924] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:33.924] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:33.924] Packages: <none>
[17:00:33.924] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:33.924] Resolved: FALSE
[17:00:33.924] Value: <not collected>
[17:00:33.924] Conditions captured: <none>
[17:00:33.924] Early signaling: FALSE
[17:00:33.924] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:33.924] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:33.936] Chunk #2 of 2 ... DONE
[17:00:33.936] Launching 2 futures (chunks) ... DONE
[17:00:33.936] Resolving 2 futures (chunks) ...
[17:00:33.936] resolve() on list ...
[17:00:33.936]  recursive: 0
[17:00:33.936]  length: 2
[17:00:33.936] 
[17:00:33.937] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.937] - Validating connection of MultisessionFuture
[17:00:33.937] - received message: FutureResult
[17:00:33.937] - Received FutureResult
[17:00:33.937] - Erased future from FutureRegistry
[17:00:33.938] result() for ClusterFuture ...
[17:00:33.938] - result already collected: FutureResult
[17:00:33.938] result() for ClusterFuture ... done
[17:00:33.938] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.938] Future #1
[17:00:33.938] result() for ClusterFuture ...
[17:00:33.938] - result already collected: FutureResult
[17:00:33.938] result() for ClusterFuture ... done
[17:00:33.938] result() for ClusterFuture ...
[17:00:33.938] - result already collected: FutureResult
[17:00:33.938] result() for ClusterFuture ... done
[17:00:33.938] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:33.939] - nx: 2
[17:00:33.939] - relay: TRUE
[17:00:33.939] - stdout: TRUE
[17:00:33.939] - signal: TRUE
[17:00:33.939] - resignal: FALSE
[17:00:33.939] - force: TRUE
[17:00:33.939] - relayed: [n=2] FALSE, FALSE
[17:00:33.939] - queued futures: [n=2] FALSE, FALSE
[17:00:33.939]  - until=1
[17:00:33.939]  - relaying element #1
[17:00:33.939] result() for ClusterFuture ...
[17:00:33.940] - result already collected: FutureResult
[17:00:33.940] result() for ClusterFuture ... done
[17:00:33.940] result() for ClusterFuture ...
[17:00:33.940] - result already collected: FutureResult
[17:00:33.940] result() for ClusterFuture ... done
[17:00:33.940] result() for ClusterFuture ...
[17:00:33.940] - result already collected: FutureResult
[17:00:33.940] result() for ClusterFuture ... done
[17:00:33.940] result() for ClusterFuture ...
[17:00:33.940] - result already collected: FutureResult
[17:00:33.940] result() for ClusterFuture ... done
[17:00:33.941] - relayed: [n=2] TRUE, FALSE
[17:00:33.941] - queued futures: [n=2] TRUE, FALSE
[17:00:33.941] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:33.941]  length: 1 (resolved future 1)
[17:00:33.969] receiveMessageFromWorker() for ClusterFuture ...
[17:00:33.969] - Validating connection of MultisessionFuture
[17:00:33.969] - received message: FutureResult
[17:00:33.970] - Received FutureResult
[17:00:33.970] - Erased future from FutureRegistry
[17:00:33.970] result() for ClusterFuture ...
[17:00:33.970] - result already collected: FutureResult
[17:00:33.970] result() for ClusterFuture ... done
[17:00:33.970] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:33.970] Future #2
[17:00:33.970] result() for ClusterFuture ...
[17:00:33.970] - result already collected: FutureResult
[17:00:33.970] result() for ClusterFuture ... done
[17:00:33.971] result() for ClusterFuture ...
[17:00:33.971] - result already collected: FutureResult
[17:00:33.971] result() for ClusterFuture ... done
[17:00:33.971] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:33.971] - nx: 2
[17:00:33.971] - relay: TRUE
[17:00:33.971] - stdout: TRUE
[17:00:33.971] - signal: TRUE
[17:00:33.971] - resignal: FALSE
[17:00:33.971] - force: TRUE
[17:00:33.971] - relayed: [n=2] TRUE, FALSE
[17:00:33.972] - queued futures: [n=2] TRUE, FALSE
[17:00:33.972]  - until=2
[17:00:33.972]  - relaying element #2
[17:00:33.972] result() for ClusterFuture ...
[17:00:33.972] - result already collected: FutureResult
[17:00:33.972] result() for ClusterFuture ... done
[17:00:33.972] result() for ClusterFuture ...
[17:00:33.972] - result already collected: FutureResult
[17:00:33.972] result() for ClusterFuture ... done
[17:00:33.972] result() for ClusterFuture ...
[17:00:33.973] - result already collected: FutureResult
[17:00:33.973] result() for ClusterFuture ... done
[17:00:33.973] result() for ClusterFuture ...
[17:00:33.973] - result already collected: FutureResult
[17:00:33.973] result() for ClusterFuture ... done
[17:00:33.973] - relayed: [n=2] TRUE, TRUE
[17:00:33.973] - queued futures: [n=2] TRUE, TRUE
[17:00:33.973] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:33.973]  length: 0 (resolved future 2)
[17:00:33.973] Relaying remaining futures
[17:00:33.973] signalConditionsASAP(NULL, pos=0) ...
[17:00:33.973] - nx: 2
[17:00:33.974] - relay: TRUE
[17:00:33.974] - stdout: TRUE
[17:00:33.974] - signal: TRUE
[17:00:33.974] - resignal: FALSE
[17:00:33.974] - force: TRUE
[17:00:33.974] - relayed: [n=2] TRUE, TRUE
[17:00:33.974] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:33.974] - relayed: [n=2] TRUE, TRUE
[17:00:33.974] - queued futures: [n=2] TRUE, TRUE
[17:00:33.974] signalConditionsASAP(NULL, pos=0) ... done
[17:00:33.974] resolve() on list ... DONE
[17:00:33.975] result() for ClusterFuture ...
[17:00:33.975] - result already collected: FutureResult
[17:00:33.975] result() for ClusterFuture ... done
[17:00:33.975] result() for ClusterFuture ...
[17:00:33.975] - result already collected: FutureResult
[17:00:33.975] result() for ClusterFuture ... done
[17:00:33.975] result() for ClusterFuture ...
[17:00:33.975] - result already collected: FutureResult
[17:00:33.975] result() for ClusterFuture ... done
[17:00:33.975] result() for ClusterFuture ...
[17:00:33.975] - result already collected: FutureResult
[17:00:33.975] result() for ClusterFuture ... done
[17:00:33.976]  - Number of value chunks collected: 2
[17:00:33.976] Resolving 2 futures (chunks) ... DONE
[17:00:33.976] Reducing values from 2 chunks ...
[17:00:33.976]  - Number of values collected after concatenation: 5
[17:00:33.976]  - Number of values expected: 5
[17:00:33.976] Reducing values from 2 chunks ... DONE
[17:00:33.976] future_mapply() ... DONE
[17:00:33.976] future_mapply() ...
[17:00:33.980] Number of chunks: 2
[17:00:33.980] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:00:33.980] getGlobalsAndPackagesXApply() ...
[17:00:33.981]  - future.globals: TRUE
[17:00:33.981] getGlobalsAndPackages() ...
[17:00:33.981] Searching for globals...
[17:00:33.982] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:33.982] Searching for globals ... DONE
[17:00:33.982] Resolving globals: FALSE
[17:00:33.983] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:33.983] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:33.983] - globals: [1] ‘FUN’
[17:00:33.983] 
[17:00:33.983] getGlobalsAndPackages() ... DONE
[17:00:33.983]  - globals found/used: [n=1] ‘FUN’
[17:00:33.984]  - needed namespaces: [n=0] 
[17:00:33.984] Finding globals ... DONE
[17:00:33.984] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:33.984] List of 2
[17:00:33.984]  $ ...future.FUN:function (C, k)  
[17:00:33.984]  $ MoreArgs     : NULL
[17:00:33.984]  - attr(*, "where")=List of 2
[17:00:33.984]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:33.984]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:33.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:33.984]  - attr(*, "resolved")= logi FALSE
[17:00:33.984]  - attr(*, "total_size")= num NA
[17:00:33.986] Packages to be attached in all futures: [n=0] 
[17:00:33.986] getGlobalsAndPackagesXApply() ... DONE
[17:00:33.987] Number of futures (= number of chunks): 2
[17:00:33.989] Launching 2 futures (chunks) ...
[17:00:33.989] Chunk #1 of 2 ...
[17:00:33.989]  - Finding globals in '...' for chunk #1 ...
[17:00:33.989] getGlobalsAndPackages() ...
[17:00:33.990] Searching for globals...
[17:00:33.990] 
[17:00:33.990] Searching for globals ... DONE
[17:00:33.990] - globals: [0] <none>
[17:00:33.990] getGlobalsAndPackages() ... DONE
[17:00:33.990]    + additional globals found: [n=0] 
[17:00:33.990]    + additional namespaces needed: [n=0] 
[17:00:33.990]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:33.991]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:33.991]  - seeds: <none>
[17:00:33.991]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.991] getGlobalsAndPackages() ...
[17:00:33.991] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.991] Resolving globals: FALSE
[17:00:33.992] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:33.992] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:33.992] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:33.992] 
[17:00:33.992] getGlobalsAndPackages() ... DONE
[17:00:33.993] run() for ‘Future’ ...
[17:00:33.993] - state: ‘created’
[17:00:33.993] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.007] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.008] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.008]   - Field: ‘node’
[17:00:34.008]   - Field: ‘label’
[17:00:34.008]   - Field: ‘local’
[17:00:34.008]   - Field: ‘owner’
[17:00:34.008]   - Field: ‘envir’
[17:00:34.008]   - Field: ‘workers’
[17:00:34.008]   - Field: ‘packages’
[17:00:34.008]   - Field: ‘gc’
[17:00:34.008]   - Field: ‘conditions’
[17:00:34.008]   - Field: ‘persistent’
[17:00:34.009]   - Field: ‘expr’
[17:00:34.009]   - Field: ‘uuid’
[17:00:34.009]   - Field: ‘seed’
[17:00:34.009]   - Field: ‘version’
[17:00:34.009]   - Field: ‘result’
[17:00:34.009]   - Field: ‘asynchronous’
[17:00:34.009]   - Field: ‘calls’
[17:00:34.009]   - Field: ‘globals’
[17:00:34.009]   - Field: ‘stdout’
[17:00:34.009]   - Field: ‘earlySignal’
[17:00:34.009]   - Field: ‘lazy’
[17:00:34.010]   - Field: ‘state’
[17:00:34.010] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.010] - Launch lazy future ...
[17:00:34.010] Packages needed by the future expression (n = 0): <none>
[17:00:34.010] Packages needed by future strategies (n = 0): <none>
[17:00:34.011] {
[17:00:34.011]     {
[17:00:34.011]         {
[17:00:34.011]             ...future.startTime <- base::Sys.time()
[17:00:34.011]             {
[17:00:34.011]                 {
[17:00:34.011]                   {
[17:00:34.011]                     {
[17:00:34.011]                       base::local({
[17:00:34.011]                         has_future <- base::requireNamespace("future", 
[17:00:34.011]                           quietly = TRUE)
[17:00:34.011]                         if (has_future) {
[17:00:34.011]                           ns <- base::getNamespace("future")
[17:00:34.011]                           version <- ns[[".package"]][["version"]]
[17:00:34.011]                           if (is.null(version)) 
[17:00:34.011]                             version <- utils::packageVersion("future")
[17:00:34.011]                         }
[17:00:34.011]                         else {
[17:00:34.011]                           version <- NULL
[17:00:34.011]                         }
[17:00:34.011]                         if (!has_future || version < "1.8.0") {
[17:00:34.011]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.011]                             "", base::R.version$version.string), 
[17:00:34.011]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.011]                               "release", "version")], collapse = " "), 
[17:00:34.011]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.011]                             info)
[17:00:34.011]                           info <- base::paste(info, collapse = "; ")
[17:00:34.011]                           if (!has_future) {
[17:00:34.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.011]                               info)
[17:00:34.011]                           }
[17:00:34.011]                           else {
[17:00:34.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.011]                               info, version)
[17:00:34.011]                           }
[17:00:34.011]                           base::stop(msg)
[17:00:34.011]                         }
[17:00:34.011]                       })
[17:00:34.011]                     }
[17:00:34.011]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.011]                     base::options(mc.cores = 1L)
[17:00:34.011]                   }
[17:00:34.011]                   ...future.strategy.old <- future::plan("list")
[17:00:34.011]                   options(future.plan = NULL)
[17:00:34.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.011]                 }
[17:00:34.011]                 ...future.workdir <- getwd()
[17:00:34.011]             }
[17:00:34.011]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.011]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.011]         }
[17:00:34.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.011]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.011]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.011]             base::names(...future.oldOptions))
[17:00:34.011]     }
[17:00:34.011]     if (FALSE) {
[17:00:34.011]     }
[17:00:34.011]     else {
[17:00:34.011]         if (TRUE) {
[17:00:34.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.011]                 open = "w")
[17:00:34.011]         }
[17:00:34.011]         else {
[17:00:34.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.011]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.011]         }
[17:00:34.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.011]             base::sink(type = "output", split = FALSE)
[17:00:34.011]             base::close(...future.stdout)
[17:00:34.011]         }, add = TRUE)
[17:00:34.011]     }
[17:00:34.011]     ...future.frame <- base::sys.nframe()
[17:00:34.011]     ...future.conditions <- base::list()
[17:00:34.011]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.011]     if (FALSE) {
[17:00:34.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.011]     }
[17:00:34.011]     ...future.result <- base::tryCatch({
[17:00:34.011]         base::withCallingHandlers({
[17:00:34.011]             ...future.value <- base::withVisible(base::local({
[17:00:34.011]                 ...future.makeSendCondition <- base::local({
[17:00:34.011]                   sendCondition <- NULL
[17:00:34.011]                   function(frame = 1L) {
[17:00:34.011]                     if (is.function(sendCondition)) 
[17:00:34.011]                       return(sendCondition)
[17:00:34.011]                     ns <- getNamespace("parallel")
[17:00:34.011]                     if (exists("sendData", mode = "function", 
[17:00:34.011]                       envir = ns)) {
[17:00:34.011]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.011]                         envir = ns)
[17:00:34.011]                       envir <- sys.frame(frame)
[17:00:34.011]                       master <- NULL
[17:00:34.011]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.011]                         !identical(envir, emptyenv())) {
[17:00:34.011]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.011]                           inherits = FALSE)) {
[17:00:34.011]                           master <- get("master", mode = "list", 
[17:00:34.011]                             envir = envir, inherits = FALSE)
[17:00:34.011]                           if (inherits(master, c("SOCKnode", 
[17:00:34.011]                             "SOCK0node"))) {
[17:00:34.011]                             sendCondition <<- function(cond) {
[17:00:34.011]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.011]                                 success = TRUE)
[17:00:34.011]                               parallel_sendData(master, data)
[17:00:34.011]                             }
[17:00:34.011]                             return(sendCondition)
[17:00:34.011]                           }
[17:00:34.011]                         }
[17:00:34.011]                         frame <- frame + 1L
[17:00:34.011]                         envir <- sys.frame(frame)
[17:00:34.011]                       }
[17:00:34.011]                     }
[17:00:34.011]                     sendCondition <<- function(cond) NULL
[17:00:34.011]                   }
[17:00:34.011]                 })
[17:00:34.011]                 withCallingHandlers({
[17:00:34.011]                   {
[17:00:34.011]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.011]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.011]                       ...future.globals.maxSize)) {
[17:00:34.011]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.011]                       on.exit(options(oopts), add = TRUE)
[17:00:34.011]                     }
[17:00:34.011]                     {
[17:00:34.011]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.011]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.011]                         USE.NAMES = FALSE)
[17:00:34.011]                       do.call(mapply, args = args)
[17:00:34.011]                     }
[17:00:34.011]                   }
[17:00:34.011]                 }, immediateCondition = function(cond) {
[17:00:34.011]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.011]                   sendCondition(cond)
[17:00:34.011]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.011]                   {
[17:00:34.011]                     inherits <- base::inherits
[17:00:34.011]                     invokeRestart <- base::invokeRestart
[17:00:34.011]                     is.null <- base::is.null
[17:00:34.011]                     muffled <- FALSE
[17:00:34.011]                     if (inherits(cond, "message")) {
[17:00:34.011]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.011]                       if (muffled) 
[17:00:34.011]                         invokeRestart("muffleMessage")
[17:00:34.011]                     }
[17:00:34.011]                     else if (inherits(cond, "warning")) {
[17:00:34.011]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.011]                       if (muffled) 
[17:00:34.011]                         invokeRestart("muffleWarning")
[17:00:34.011]                     }
[17:00:34.011]                     else if (inherits(cond, "condition")) {
[17:00:34.011]                       if (!is.null(pattern)) {
[17:00:34.011]                         computeRestarts <- base::computeRestarts
[17:00:34.011]                         grepl <- base::grepl
[17:00:34.011]                         restarts <- computeRestarts(cond)
[17:00:34.011]                         for (restart in restarts) {
[17:00:34.011]                           name <- restart$name
[17:00:34.011]                           if (is.null(name)) 
[17:00:34.011]                             next
[17:00:34.011]                           if (!grepl(pattern, name)) 
[17:00:34.011]                             next
[17:00:34.011]                           invokeRestart(restart)
[17:00:34.011]                           muffled <- TRUE
[17:00:34.011]                           break
[17:00:34.011]                         }
[17:00:34.011]                       }
[17:00:34.011]                     }
[17:00:34.011]                     invisible(muffled)
[17:00:34.011]                   }
[17:00:34.011]                   muffleCondition(cond)
[17:00:34.011]                 })
[17:00:34.011]             }))
[17:00:34.011]             future::FutureResult(value = ...future.value$value, 
[17:00:34.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.011]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.011]                     ...future.globalenv.names))
[17:00:34.011]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.011]         }, condition = base::local({
[17:00:34.011]             c <- base::c
[17:00:34.011]             inherits <- base::inherits
[17:00:34.011]             invokeRestart <- base::invokeRestart
[17:00:34.011]             length <- base::length
[17:00:34.011]             list <- base::list
[17:00:34.011]             seq.int <- base::seq.int
[17:00:34.011]             signalCondition <- base::signalCondition
[17:00:34.011]             sys.calls <- base::sys.calls
[17:00:34.011]             `[[` <- base::`[[`
[17:00:34.011]             `+` <- base::`+`
[17:00:34.011]             `<<-` <- base::`<<-`
[17:00:34.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.011]                   3L)]
[17:00:34.011]             }
[17:00:34.011]             function(cond) {
[17:00:34.011]                 is_error <- inherits(cond, "error")
[17:00:34.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.011]                   NULL)
[17:00:34.011]                 if (is_error) {
[17:00:34.011]                   sessionInformation <- function() {
[17:00:34.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.011]                       search = base::search(), system = base::Sys.info())
[17:00:34.011]                   }
[17:00:34.011]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.011]                     cond$call), session = sessionInformation(), 
[17:00:34.011]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.011]                   signalCondition(cond)
[17:00:34.011]                 }
[17:00:34.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.011]                 "immediateCondition"))) {
[17:00:34.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.011]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.011]                   if (TRUE && !signal) {
[17:00:34.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.011]                     {
[17:00:34.011]                       inherits <- base::inherits
[17:00:34.011]                       invokeRestart <- base::invokeRestart
[17:00:34.011]                       is.null <- base::is.null
[17:00:34.011]                       muffled <- FALSE
[17:00:34.011]                       if (inherits(cond, "message")) {
[17:00:34.011]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.011]                         if (muffled) 
[17:00:34.011]                           invokeRestart("muffleMessage")
[17:00:34.011]                       }
[17:00:34.011]                       else if (inherits(cond, "warning")) {
[17:00:34.011]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.011]                         if (muffled) 
[17:00:34.011]                           invokeRestart("muffleWarning")
[17:00:34.011]                       }
[17:00:34.011]                       else if (inherits(cond, "condition")) {
[17:00:34.011]                         if (!is.null(pattern)) {
[17:00:34.011]                           computeRestarts <- base::computeRestarts
[17:00:34.011]                           grepl <- base::grepl
[17:00:34.011]                           restarts <- computeRestarts(cond)
[17:00:34.011]                           for (restart in restarts) {
[17:00:34.011]                             name <- restart$name
[17:00:34.011]                             if (is.null(name)) 
[17:00:34.011]                               next
[17:00:34.011]                             if (!grepl(pattern, name)) 
[17:00:34.011]                               next
[17:00:34.011]                             invokeRestart(restart)
[17:00:34.011]                             muffled <- TRUE
[17:00:34.011]                             break
[17:00:34.011]                           }
[17:00:34.011]                         }
[17:00:34.011]                       }
[17:00:34.011]                       invisible(muffled)
[17:00:34.011]                     }
[17:00:34.011]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.011]                   }
[17:00:34.011]                 }
[17:00:34.011]                 else {
[17:00:34.011]                   if (TRUE) {
[17:00:34.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.011]                     {
[17:00:34.011]                       inherits <- base::inherits
[17:00:34.011]                       invokeRestart <- base::invokeRestart
[17:00:34.011]                       is.null <- base::is.null
[17:00:34.011]                       muffled <- FALSE
[17:00:34.011]                       if (inherits(cond, "message")) {
[17:00:34.011]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.011]                         if (muffled) 
[17:00:34.011]                           invokeRestart("muffleMessage")
[17:00:34.011]                       }
[17:00:34.011]                       else if (inherits(cond, "warning")) {
[17:00:34.011]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.011]                         if (muffled) 
[17:00:34.011]                           invokeRestart("muffleWarning")
[17:00:34.011]                       }
[17:00:34.011]                       else if (inherits(cond, "condition")) {
[17:00:34.011]                         if (!is.null(pattern)) {
[17:00:34.011]                           computeRestarts <- base::computeRestarts
[17:00:34.011]                           grepl <- base::grepl
[17:00:34.011]                           restarts <- computeRestarts(cond)
[17:00:34.011]                           for (restart in restarts) {
[17:00:34.011]                             name <- restart$name
[17:00:34.011]                             if (is.null(name)) 
[17:00:34.011]                               next
[17:00:34.011]                             if (!grepl(pattern, name)) 
[17:00:34.011]                               next
[17:00:34.011]                             invokeRestart(restart)
[17:00:34.011]                             muffled <- TRUE
[17:00:34.011]                             break
[17:00:34.011]                           }
[17:00:34.011]                         }
[17:00:34.011]                       }
[17:00:34.011]                       invisible(muffled)
[17:00:34.011]                     }
[17:00:34.011]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.011]                   }
[17:00:34.011]                 }
[17:00:34.011]             }
[17:00:34.011]         }))
[17:00:34.011]     }, error = function(ex) {
[17:00:34.011]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.011]                 ...future.rng), started = ...future.startTime, 
[17:00:34.011]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.011]             version = "1.8"), class = "FutureResult")
[17:00:34.011]     }, finally = {
[17:00:34.011]         if (!identical(...future.workdir, getwd())) 
[17:00:34.011]             setwd(...future.workdir)
[17:00:34.011]         {
[17:00:34.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.011]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.011]             }
[17:00:34.011]             base::options(...future.oldOptions)
[17:00:34.011]             if (.Platform$OS.type == "windows") {
[17:00:34.011]                 old_names <- names(...future.oldEnvVars)
[17:00:34.011]                 envs <- base::Sys.getenv()
[17:00:34.011]                 names <- names(envs)
[17:00:34.011]                 common <- intersect(names, old_names)
[17:00:34.011]                 added <- setdiff(names, old_names)
[17:00:34.011]                 removed <- setdiff(old_names, names)
[17:00:34.011]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.011]                   envs[common]]
[17:00:34.011]                 NAMES <- toupper(changed)
[17:00:34.011]                 args <- list()
[17:00:34.011]                 for (kk in seq_along(NAMES)) {
[17:00:34.011]                   name <- changed[[kk]]
[17:00:34.011]                   NAME <- NAMES[[kk]]
[17:00:34.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.011]                     next
[17:00:34.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.011]                 }
[17:00:34.011]                 NAMES <- toupper(added)
[17:00:34.011]                 for (kk in seq_along(NAMES)) {
[17:00:34.011]                   name <- added[[kk]]
[17:00:34.011]                   NAME <- NAMES[[kk]]
[17:00:34.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.011]                     next
[17:00:34.011]                   args[[name]] <- ""
[17:00:34.011]                 }
[17:00:34.011]                 NAMES <- toupper(removed)
[17:00:34.011]                 for (kk in seq_along(NAMES)) {
[17:00:34.011]                   name <- removed[[kk]]
[17:00:34.011]                   NAME <- NAMES[[kk]]
[17:00:34.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.011]                     next
[17:00:34.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.011]                 }
[17:00:34.011]                 if (length(args) > 0) 
[17:00:34.011]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.011]             }
[17:00:34.011]             else {
[17:00:34.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.011]             }
[17:00:34.011]             {
[17:00:34.011]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.011]                   0L) {
[17:00:34.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.011]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.011]                   base::options(opts)
[17:00:34.011]                 }
[17:00:34.011]                 {
[17:00:34.011]                   {
[17:00:34.011]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.011]                     NULL
[17:00:34.011]                   }
[17:00:34.011]                   options(future.plan = NULL)
[17:00:34.011]                   if (is.na(NA_character_)) 
[17:00:34.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.011]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.011]                     .init = FALSE)
[17:00:34.011]                 }
[17:00:34.011]             }
[17:00:34.011]         }
[17:00:34.011]     })
[17:00:34.011]     if (TRUE) {
[17:00:34.011]         base::sink(type = "output", split = FALSE)
[17:00:34.011]         if (TRUE) {
[17:00:34.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.011]         }
[17:00:34.011]         else {
[17:00:34.011]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.011]         }
[17:00:34.011]         base::close(...future.stdout)
[17:00:34.011]         ...future.stdout <- NULL
[17:00:34.011]     }
[17:00:34.011]     ...future.result$conditions <- ...future.conditions
[17:00:34.011]     ...future.result$finished <- base::Sys.time()
[17:00:34.011]     ...future.result
[17:00:34.011] }
[17:00:34.013] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:00:34.014] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:00:34.014] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:00:34.014] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:34.014] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.014] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:00:34.015] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:00:34.015] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:34.015] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.015] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:34.016] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.016] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:00:34.016] MultisessionFuture started
[17:00:34.016] - Launch lazy future ... done
[17:00:34.016] run() for ‘MultisessionFuture’ ... done
[17:00:34.017] Created future:
[17:00:34.017] MultisessionFuture:
[17:00:34.017] Label: ‘future_mapply-1’
[17:00:34.017] Expression:
[17:00:34.017] {
[17:00:34.017]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.017]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.017]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.017]         on.exit(options(oopts), add = TRUE)
[17:00:34.017]     }
[17:00:34.017]     {
[17:00:34.017]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.017]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.017]         do.call(mapply, args = args)
[17:00:34.017]     }
[17:00:34.017] }
[17:00:34.017] Lazy evaluation: FALSE
[17:00:34.017] Asynchronous evaluation: TRUE
[17:00:34.017] Local evaluation: TRUE
[17:00:34.017] Environment: R_GlobalEnv
[17:00:34.017] Capture standard output: TRUE
[17:00:34.017] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.017] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.017] Packages: <none>
[17:00:34.017] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.017] Resolved: FALSE
[17:00:34.017] Value: <not collected>
[17:00:34.017] Conditions captured: <none>
[17:00:34.017] Early signaling: FALSE
[17:00:34.017] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.017] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.028] Chunk #1 of 2 ... DONE
[17:00:34.028] Chunk #2 of 2 ...
[17:00:34.028]  - Finding globals in '...' for chunk #2 ...
[17:00:34.028] getGlobalsAndPackages() ...
[17:00:34.029] Searching for globals...
[17:00:34.029] 
[17:00:34.029] Searching for globals ... DONE
[17:00:34.029] - globals: [0] <none>
[17:00:34.029] getGlobalsAndPackages() ... DONE
[17:00:34.029]    + additional globals found: [n=0] 
[17:00:34.029]    + additional namespaces needed: [n=0] 
[17:00:34.029]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:34.029]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.030]  - seeds: <none>
[17:00:34.030]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.030] getGlobalsAndPackages() ...
[17:00:34.030] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.030] Resolving globals: FALSE
[17:00:34.030] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:00:34.031] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:34.031] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.031] 
[17:00:34.031] getGlobalsAndPackages() ... DONE
[17:00:34.032] run() for ‘Future’ ...
[17:00:34.032] - state: ‘created’
[17:00:34.032] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.047] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.047]   - Field: ‘node’
[17:00:34.047]   - Field: ‘label’
[17:00:34.047]   - Field: ‘local’
[17:00:34.047]   - Field: ‘owner’
[17:00:34.048]   - Field: ‘envir’
[17:00:34.048]   - Field: ‘workers’
[17:00:34.048]   - Field: ‘packages’
[17:00:34.048]   - Field: ‘gc’
[17:00:34.048]   - Field: ‘conditions’
[17:00:34.048]   - Field: ‘persistent’
[17:00:34.048]   - Field: ‘expr’
[17:00:34.048]   - Field: ‘uuid’
[17:00:34.048]   - Field: ‘seed’
[17:00:34.048]   - Field: ‘version’
[17:00:34.048]   - Field: ‘result’
[17:00:34.049]   - Field: ‘asynchronous’
[17:00:34.049]   - Field: ‘calls’
[17:00:34.049]   - Field: ‘globals’
[17:00:34.049]   - Field: ‘stdout’
[17:00:34.049]   - Field: ‘earlySignal’
[17:00:34.049]   - Field: ‘lazy’
[17:00:34.049]   - Field: ‘state’
[17:00:34.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.049] - Launch lazy future ...
[17:00:34.050] Packages needed by the future expression (n = 0): <none>
[17:00:34.050] Packages needed by future strategies (n = 0): <none>
[17:00:34.050] {
[17:00:34.050]     {
[17:00:34.050]         {
[17:00:34.050]             ...future.startTime <- base::Sys.time()
[17:00:34.050]             {
[17:00:34.050]                 {
[17:00:34.050]                   {
[17:00:34.050]                     {
[17:00:34.050]                       base::local({
[17:00:34.050]                         has_future <- base::requireNamespace("future", 
[17:00:34.050]                           quietly = TRUE)
[17:00:34.050]                         if (has_future) {
[17:00:34.050]                           ns <- base::getNamespace("future")
[17:00:34.050]                           version <- ns[[".package"]][["version"]]
[17:00:34.050]                           if (is.null(version)) 
[17:00:34.050]                             version <- utils::packageVersion("future")
[17:00:34.050]                         }
[17:00:34.050]                         else {
[17:00:34.050]                           version <- NULL
[17:00:34.050]                         }
[17:00:34.050]                         if (!has_future || version < "1.8.0") {
[17:00:34.050]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.050]                             "", base::R.version$version.string), 
[17:00:34.050]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.050]                               "release", "version")], collapse = " "), 
[17:00:34.050]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.050]                             info)
[17:00:34.050]                           info <- base::paste(info, collapse = "; ")
[17:00:34.050]                           if (!has_future) {
[17:00:34.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.050]                               info)
[17:00:34.050]                           }
[17:00:34.050]                           else {
[17:00:34.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.050]                               info, version)
[17:00:34.050]                           }
[17:00:34.050]                           base::stop(msg)
[17:00:34.050]                         }
[17:00:34.050]                       })
[17:00:34.050]                     }
[17:00:34.050]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.050]                     base::options(mc.cores = 1L)
[17:00:34.050]                   }
[17:00:34.050]                   ...future.strategy.old <- future::plan("list")
[17:00:34.050]                   options(future.plan = NULL)
[17:00:34.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.050]                 }
[17:00:34.050]                 ...future.workdir <- getwd()
[17:00:34.050]             }
[17:00:34.050]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.050]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.050]         }
[17:00:34.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.050]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.050]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.050]             base::names(...future.oldOptions))
[17:00:34.050]     }
[17:00:34.050]     if (FALSE) {
[17:00:34.050]     }
[17:00:34.050]     else {
[17:00:34.050]         if (TRUE) {
[17:00:34.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.050]                 open = "w")
[17:00:34.050]         }
[17:00:34.050]         else {
[17:00:34.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.050]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.050]         }
[17:00:34.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.050]             base::sink(type = "output", split = FALSE)
[17:00:34.050]             base::close(...future.stdout)
[17:00:34.050]         }, add = TRUE)
[17:00:34.050]     }
[17:00:34.050]     ...future.frame <- base::sys.nframe()
[17:00:34.050]     ...future.conditions <- base::list()
[17:00:34.050]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.050]     if (FALSE) {
[17:00:34.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.050]     }
[17:00:34.050]     ...future.result <- base::tryCatch({
[17:00:34.050]         base::withCallingHandlers({
[17:00:34.050]             ...future.value <- base::withVisible(base::local({
[17:00:34.050]                 ...future.makeSendCondition <- base::local({
[17:00:34.050]                   sendCondition <- NULL
[17:00:34.050]                   function(frame = 1L) {
[17:00:34.050]                     if (is.function(sendCondition)) 
[17:00:34.050]                       return(sendCondition)
[17:00:34.050]                     ns <- getNamespace("parallel")
[17:00:34.050]                     if (exists("sendData", mode = "function", 
[17:00:34.050]                       envir = ns)) {
[17:00:34.050]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.050]                         envir = ns)
[17:00:34.050]                       envir <- sys.frame(frame)
[17:00:34.050]                       master <- NULL
[17:00:34.050]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.050]                         !identical(envir, emptyenv())) {
[17:00:34.050]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.050]                           inherits = FALSE)) {
[17:00:34.050]                           master <- get("master", mode = "list", 
[17:00:34.050]                             envir = envir, inherits = FALSE)
[17:00:34.050]                           if (inherits(master, c("SOCKnode", 
[17:00:34.050]                             "SOCK0node"))) {
[17:00:34.050]                             sendCondition <<- function(cond) {
[17:00:34.050]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.050]                                 success = TRUE)
[17:00:34.050]                               parallel_sendData(master, data)
[17:00:34.050]                             }
[17:00:34.050]                             return(sendCondition)
[17:00:34.050]                           }
[17:00:34.050]                         }
[17:00:34.050]                         frame <- frame + 1L
[17:00:34.050]                         envir <- sys.frame(frame)
[17:00:34.050]                       }
[17:00:34.050]                     }
[17:00:34.050]                     sendCondition <<- function(cond) NULL
[17:00:34.050]                   }
[17:00:34.050]                 })
[17:00:34.050]                 withCallingHandlers({
[17:00:34.050]                   {
[17:00:34.050]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.050]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.050]                       ...future.globals.maxSize)) {
[17:00:34.050]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.050]                       on.exit(options(oopts), add = TRUE)
[17:00:34.050]                     }
[17:00:34.050]                     {
[17:00:34.050]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.050]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.050]                         USE.NAMES = FALSE)
[17:00:34.050]                       do.call(mapply, args = args)
[17:00:34.050]                     }
[17:00:34.050]                   }
[17:00:34.050]                 }, immediateCondition = function(cond) {
[17:00:34.050]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.050]                   sendCondition(cond)
[17:00:34.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.050]                   {
[17:00:34.050]                     inherits <- base::inherits
[17:00:34.050]                     invokeRestart <- base::invokeRestart
[17:00:34.050]                     is.null <- base::is.null
[17:00:34.050]                     muffled <- FALSE
[17:00:34.050]                     if (inherits(cond, "message")) {
[17:00:34.050]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.050]                       if (muffled) 
[17:00:34.050]                         invokeRestart("muffleMessage")
[17:00:34.050]                     }
[17:00:34.050]                     else if (inherits(cond, "warning")) {
[17:00:34.050]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.050]                       if (muffled) 
[17:00:34.050]                         invokeRestart("muffleWarning")
[17:00:34.050]                     }
[17:00:34.050]                     else if (inherits(cond, "condition")) {
[17:00:34.050]                       if (!is.null(pattern)) {
[17:00:34.050]                         computeRestarts <- base::computeRestarts
[17:00:34.050]                         grepl <- base::grepl
[17:00:34.050]                         restarts <- computeRestarts(cond)
[17:00:34.050]                         for (restart in restarts) {
[17:00:34.050]                           name <- restart$name
[17:00:34.050]                           if (is.null(name)) 
[17:00:34.050]                             next
[17:00:34.050]                           if (!grepl(pattern, name)) 
[17:00:34.050]                             next
[17:00:34.050]                           invokeRestart(restart)
[17:00:34.050]                           muffled <- TRUE
[17:00:34.050]                           break
[17:00:34.050]                         }
[17:00:34.050]                       }
[17:00:34.050]                     }
[17:00:34.050]                     invisible(muffled)
[17:00:34.050]                   }
[17:00:34.050]                   muffleCondition(cond)
[17:00:34.050]                 })
[17:00:34.050]             }))
[17:00:34.050]             future::FutureResult(value = ...future.value$value, 
[17:00:34.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.050]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.050]                     ...future.globalenv.names))
[17:00:34.050]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.050]         }, condition = base::local({
[17:00:34.050]             c <- base::c
[17:00:34.050]             inherits <- base::inherits
[17:00:34.050]             invokeRestart <- base::invokeRestart
[17:00:34.050]             length <- base::length
[17:00:34.050]             list <- base::list
[17:00:34.050]             seq.int <- base::seq.int
[17:00:34.050]             signalCondition <- base::signalCondition
[17:00:34.050]             sys.calls <- base::sys.calls
[17:00:34.050]             `[[` <- base::`[[`
[17:00:34.050]             `+` <- base::`+`
[17:00:34.050]             `<<-` <- base::`<<-`
[17:00:34.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.050]                   3L)]
[17:00:34.050]             }
[17:00:34.050]             function(cond) {
[17:00:34.050]                 is_error <- inherits(cond, "error")
[17:00:34.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.050]                   NULL)
[17:00:34.050]                 if (is_error) {
[17:00:34.050]                   sessionInformation <- function() {
[17:00:34.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.050]                       search = base::search(), system = base::Sys.info())
[17:00:34.050]                   }
[17:00:34.050]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.050]                     cond$call), session = sessionInformation(), 
[17:00:34.050]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.050]                   signalCondition(cond)
[17:00:34.050]                 }
[17:00:34.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.050]                 "immediateCondition"))) {
[17:00:34.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.050]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.050]                   if (TRUE && !signal) {
[17:00:34.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.050]                     {
[17:00:34.050]                       inherits <- base::inherits
[17:00:34.050]                       invokeRestart <- base::invokeRestart
[17:00:34.050]                       is.null <- base::is.null
[17:00:34.050]                       muffled <- FALSE
[17:00:34.050]                       if (inherits(cond, "message")) {
[17:00:34.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.050]                         if (muffled) 
[17:00:34.050]                           invokeRestart("muffleMessage")
[17:00:34.050]                       }
[17:00:34.050]                       else if (inherits(cond, "warning")) {
[17:00:34.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.050]                         if (muffled) 
[17:00:34.050]                           invokeRestart("muffleWarning")
[17:00:34.050]                       }
[17:00:34.050]                       else if (inherits(cond, "condition")) {
[17:00:34.050]                         if (!is.null(pattern)) {
[17:00:34.050]                           computeRestarts <- base::computeRestarts
[17:00:34.050]                           grepl <- base::grepl
[17:00:34.050]                           restarts <- computeRestarts(cond)
[17:00:34.050]                           for (restart in restarts) {
[17:00:34.050]                             name <- restart$name
[17:00:34.050]                             if (is.null(name)) 
[17:00:34.050]                               next
[17:00:34.050]                             if (!grepl(pattern, name)) 
[17:00:34.050]                               next
[17:00:34.050]                             invokeRestart(restart)
[17:00:34.050]                             muffled <- TRUE
[17:00:34.050]                             break
[17:00:34.050]                           }
[17:00:34.050]                         }
[17:00:34.050]                       }
[17:00:34.050]                       invisible(muffled)
[17:00:34.050]                     }
[17:00:34.050]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.050]                   }
[17:00:34.050]                 }
[17:00:34.050]                 else {
[17:00:34.050]                   if (TRUE) {
[17:00:34.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.050]                     {
[17:00:34.050]                       inherits <- base::inherits
[17:00:34.050]                       invokeRestart <- base::invokeRestart
[17:00:34.050]                       is.null <- base::is.null
[17:00:34.050]                       muffled <- FALSE
[17:00:34.050]                       if (inherits(cond, "message")) {
[17:00:34.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.050]                         if (muffled) 
[17:00:34.050]                           invokeRestart("muffleMessage")
[17:00:34.050]                       }
[17:00:34.050]                       else if (inherits(cond, "warning")) {
[17:00:34.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.050]                         if (muffled) 
[17:00:34.050]                           invokeRestart("muffleWarning")
[17:00:34.050]                       }
[17:00:34.050]                       else if (inherits(cond, "condition")) {
[17:00:34.050]                         if (!is.null(pattern)) {
[17:00:34.050]                           computeRestarts <- base::computeRestarts
[17:00:34.050]                           grepl <- base::grepl
[17:00:34.050]                           restarts <- computeRestarts(cond)
[17:00:34.050]                           for (restart in restarts) {
[17:00:34.050]                             name <- restart$name
[17:00:34.050]                             if (is.null(name)) 
[17:00:34.050]                               next
[17:00:34.050]                             if (!grepl(pattern, name)) 
[17:00:34.050]                               next
[17:00:34.050]                             invokeRestart(restart)
[17:00:34.050]                             muffled <- TRUE
[17:00:34.050]                             break
[17:00:34.050]                           }
[17:00:34.050]                         }
[17:00:34.050]                       }
[17:00:34.050]                       invisible(muffled)
[17:00:34.050]                     }
[17:00:34.050]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.050]                   }
[17:00:34.050]                 }
[17:00:34.050]             }
[17:00:34.050]         }))
[17:00:34.050]     }, error = function(ex) {
[17:00:34.050]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.050]                 ...future.rng), started = ...future.startTime, 
[17:00:34.050]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.050]             version = "1.8"), class = "FutureResult")
[17:00:34.050]     }, finally = {
[17:00:34.050]         if (!identical(...future.workdir, getwd())) 
[17:00:34.050]             setwd(...future.workdir)
[17:00:34.050]         {
[17:00:34.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.050]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.050]             }
[17:00:34.050]             base::options(...future.oldOptions)
[17:00:34.050]             if (.Platform$OS.type == "windows") {
[17:00:34.050]                 old_names <- names(...future.oldEnvVars)
[17:00:34.050]                 envs <- base::Sys.getenv()
[17:00:34.050]                 names <- names(envs)
[17:00:34.050]                 common <- intersect(names, old_names)
[17:00:34.050]                 added <- setdiff(names, old_names)
[17:00:34.050]                 removed <- setdiff(old_names, names)
[17:00:34.050]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.050]                   envs[common]]
[17:00:34.050]                 NAMES <- toupper(changed)
[17:00:34.050]                 args <- list()
[17:00:34.050]                 for (kk in seq_along(NAMES)) {
[17:00:34.050]                   name <- changed[[kk]]
[17:00:34.050]                   NAME <- NAMES[[kk]]
[17:00:34.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.050]                     next
[17:00:34.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.050]                 }
[17:00:34.050]                 NAMES <- toupper(added)
[17:00:34.050]                 for (kk in seq_along(NAMES)) {
[17:00:34.050]                   name <- added[[kk]]
[17:00:34.050]                   NAME <- NAMES[[kk]]
[17:00:34.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.050]                     next
[17:00:34.050]                   args[[name]] <- ""
[17:00:34.050]                 }
[17:00:34.050]                 NAMES <- toupper(removed)
[17:00:34.050]                 for (kk in seq_along(NAMES)) {
[17:00:34.050]                   name <- removed[[kk]]
[17:00:34.050]                   NAME <- NAMES[[kk]]
[17:00:34.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.050]                     next
[17:00:34.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.050]                 }
[17:00:34.050]                 if (length(args) > 0) 
[17:00:34.050]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.050]             }
[17:00:34.050]             else {
[17:00:34.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.050]             }
[17:00:34.050]             {
[17:00:34.050]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.050]                   0L) {
[17:00:34.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.050]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.050]                   base::options(opts)
[17:00:34.050]                 }
[17:00:34.050]                 {
[17:00:34.050]                   {
[17:00:34.050]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.050]                     NULL
[17:00:34.050]                   }
[17:00:34.050]                   options(future.plan = NULL)
[17:00:34.050]                   if (is.na(NA_character_)) 
[17:00:34.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.050]                     .init = FALSE)
[17:00:34.050]                 }
[17:00:34.050]             }
[17:00:34.050]         }
[17:00:34.050]     })
[17:00:34.050]     if (TRUE) {
[17:00:34.050]         base::sink(type = "output", split = FALSE)
[17:00:34.050]         if (TRUE) {
[17:00:34.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.050]         }
[17:00:34.050]         else {
[17:00:34.050]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.050]         }
[17:00:34.050]         base::close(...future.stdout)
[17:00:34.050]         ...future.stdout <- NULL
[17:00:34.050]     }
[17:00:34.050]     ...future.result$conditions <- ...future.conditions
[17:00:34.050]     ...future.result$finished <- base::Sys.time()
[17:00:34.050]     ...future.result
[17:00:34.050] }
[17:00:34.053] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:00:34.053] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:00:34.053] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:00:34.054] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:34.054] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.054] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:00:34.054] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:00:34.055] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:34.055] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.055] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:34.055] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.055] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:00:34.056] MultisessionFuture started
[17:00:34.056] - Launch lazy future ... done
[17:00:34.056] run() for ‘MultisessionFuture’ ... done
[17:00:34.056] Created future:
[17:00:34.056] MultisessionFuture:
[17:00:34.056] Label: ‘future_mapply-2’
[17:00:34.056] Expression:
[17:00:34.056] {
[17:00:34.056]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.056]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.056]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.056]         on.exit(options(oopts), add = TRUE)
[17:00:34.056]     }
[17:00:34.056]     {
[17:00:34.056]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.056]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.056]         do.call(mapply, args = args)
[17:00:34.056]     }
[17:00:34.056] }
[17:00:34.056] Lazy evaluation: FALSE
[17:00:34.056] Asynchronous evaluation: TRUE
[17:00:34.056] Local evaluation: TRUE
[17:00:34.056] Environment: R_GlobalEnv
[17:00:34.056] Capture standard output: TRUE
[17:00:34.056] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.056] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.056] Packages: <none>
[17:00:34.056] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.056] Resolved: FALSE
[17:00:34.056] Value: <not collected>
[17:00:34.056] Conditions captured: <none>
[17:00:34.056] Early signaling: FALSE
[17:00:34.056] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.056] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.068] Chunk #2 of 2 ... DONE
[17:00:34.068] Launching 2 futures (chunks) ... DONE
[17:00:34.068] Resolving 2 futures (chunks) ...
[17:00:34.068] resolve() on list ...
[17:00:34.068]  recursive: 0
[17:00:34.068]  length: 2
[17:00:34.069] 
[17:00:34.069] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.069] - Validating connection of MultisessionFuture
[17:00:34.069] - received message: FutureResult
[17:00:34.070] - Received FutureResult
[17:00:34.070] - Erased future from FutureRegistry
[17:00:34.070] result() for ClusterFuture ...
[17:00:34.070] - result already collected: FutureResult
[17:00:34.070] result() for ClusterFuture ... done
[17:00:34.070] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.070] Future #1
[17:00:34.070] result() for ClusterFuture ...
[17:00:34.070] - result already collected: FutureResult
[17:00:34.070] result() for ClusterFuture ... done
[17:00:34.070] result() for ClusterFuture ...
[17:00:34.071] - result already collected: FutureResult
[17:00:34.071] result() for ClusterFuture ... done
[17:00:34.071] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:34.071] - nx: 2
[17:00:34.071] - relay: TRUE
[17:00:34.071] - stdout: TRUE
[17:00:34.071] - signal: TRUE
[17:00:34.071] - resignal: FALSE
[17:00:34.071] - force: TRUE
[17:00:34.071] - relayed: [n=2] FALSE, FALSE
[17:00:34.071] - queued futures: [n=2] FALSE, FALSE
[17:00:34.072]  - until=1
[17:00:34.072]  - relaying element #1
[17:00:34.072] result() for ClusterFuture ...
[17:00:34.072] - result already collected: FutureResult
[17:00:34.072] result() for ClusterFuture ... done
[17:00:34.072] result() for ClusterFuture ...
[17:00:34.072] - result already collected: FutureResult
[17:00:34.072] result() for ClusterFuture ... done
[17:00:34.072] result() for ClusterFuture ...
[17:00:34.072] - result already collected: FutureResult
[17:00:34.072] result() for ClusterFuture ... done
[17:00:34.072] result() for ClusterFuture ...
[17:00:34.073] - result already collected: FutureResult
[17:00:34.073] result() for ClusterFuture ... done
[17:00:34.073] - relayed: [n=2] TRUE, FALSE
[17:00:34.073] - queued futures: [n=2] TRUE, FALSE
[17:00:34.073] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:34.073]  length: 1 (resolved future 1)
[17:00:34.101] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.101] - Validating connection of MultisessionFuture
[17:00:34.101] - received message: FutureResult
[17:00:34.102] - Received FutureResult
[17:00:34.102] - Erased future from FutureRegistry
[17:00:34.102] result() for ClusterFuture ...
[17:00:34.102] - result already collected: FutureResult
[17:00:34.102] result() for ClusterFuture ... done
[17:00:34.102] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.102] Future #2
[17:00:34.102] result() for ClusterFuture ...
[17:00:34.102] - result already collected: FutureResult
[17:00:34.102] result() for ClusterFuture ... done
[17:00:34.103] result() for ClusterFuture ...
[17:00:34.103] - result already collected: FutureResult
[17:00:34.103] result() for ClusterFuture ... done
[17:00:34.103] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:34.103] - nx: 2
[17:00:34.103] - relay: TRUE
[17:00:34.103] - stdout: TRUE
[17:00:34.103] - signal: TRUE
[17:00:34.103] - resignal: FALSE
[17:00:34.103] - force: TRUE
[17:00:34.103] - relayed: [n=2] TRUE, FALSE
[17:00:34.103] - queued futures: [n=2] TRUE, FALSE
[17:00:34.104]  - until=2
[17:00:34.104]  - relaying element #2
[17:00:34.104] result() for ClusterFuture ...
[17:00:34.104] - result already collected: FutureResult
[17:00:34.104] result() for ClusterFuture ... done
[17:00:34.104] result() for ClusterFuture ...
[17:00:34.104] - result already collected: FutureResult
[17:00:34.104] result() for ClusterFuture ... done
[17:00:34.104] result() for ClusterFuture ...
[17:00:34.104] - result already collected: FutureResult
[17:00:34.104] result() for ClusterFuture ... done
[17:00:34.105] result() for ClusterFuture ...
[17:00:34.105] - result already collected: FutureResult
[17:00:34.105] result() for ClusterFuture ... done
[17:00:34.105] - relayed: [n=2] TRUE, TRUE
[17:00:34.105] - queued futures: [n=2] TRUE, TRUE
[17:00:34.105] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:34.105]  length: 0 (resolved future 2)
[17:00:34.105] Relaying remaining futures
[17:00:34.105] signalConditionsASAP(NULL, pos=0) ...
[17:00:34.105] - nx: 2
[17:00:34.105] - relay: TRUE
[17:00:34.106] - stdout: TRUE
[17:00:34.106] - signal: TRUE
[17:00:34.106] - resignal: FALSE
[17:00:34.106] - force: TRUE
[17:00:34.106] - relayed: [n=2] TRUE, TRUE
[17:00:34.106] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:34.106] - relayed: [n=2] TRUE, TRUE
[17:00:34.106] - queued futures: [n=2] TRUE, TRUE
[17:00:34.106] signalConditionsASAP(NULL, pos=0) ... done
[17:00:34.106] resolve() on list ... DONE
[17:00:34.106] result() for ClusterFuture ...
[17:00:34.106] - result already collected: FutureResult
[17:00:34.107] result() for ClusterFuture ... done
[17:00:34.107] result() for ClusterFuture ...
[17:00:34.107] - result already collected: FutureResult
[17:00:34.107] result() for ClusterFuture ... done
[17:00:34.107] result() for ClusterFuture ...
[17:00:34.107] - result already collected: FutureResult
[17:00:34.107] result() for ClusterFuture ... done
[17:00:34.107] result() for ClusterFuture ...
[17:00:34.107] - result already collected: FutureResult
[17:00:34.107] result() for ClusterFuture ... done
[17:00:34.107]  - Number of value chunks collected: 2
[17:00:34.108] Resolving 2 futures (chunks) ... DONE
[17:00:34.108] Reducing values from 2 chunks ...
[17:00:34.108]  - Number of values collected after concatenation: 5
[17:00:34.108]  - Number of values expected: 5
[17:00:34.108] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:00:34.108] Reducing values from 2 chunks ... DONE
[17:00:34.108] future_mapply() ... DONE
[17:00:34.108] future_mapply() ...
[17:00:34.112] Number of chunks: 2
[17:00:34.112] getGlobalsAndPackagesXApply() ...
[17:00:34.112]  - future.globals: TRUE
[17:00:34.113] getGlobalsAndPackages() ...
[17:00:34.113] Searching for globals...
[17:00:34.114] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:00:34.114] Searching for globals ... DONE
[17:00:34.114] Resolving globals: FALSE
[17:00:34.115] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:00:34.115] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:00:34.115] - globals: [1] ‘FUN’
[17:00:34.115] 
[17:00:34.115] getGlobalsAndPackages() ... DONE
[17:00:34.115]  - globals found/used: [n=1] ‘FUN’
[17:00:34.115]  - needed namespaces: [n=0] 
[17:00:34.115] Finding globals ... DONE
[17:00:34.116] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:34.116] List of 2
[17:00:34.116]  $ ...future.FUN:function (C, k)  
[17:00:34.116]  $ MoreArgs     : list()
[17:00:34.116]  - attr(*, "where")=List of 2
[17:00:34.116]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:34.116]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:34.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:34.116]  - attr(*, "resolved")= logi FALSE
[17:00:34.116]  - attr(*, "total_size")= num NA
[17:00:34.118] Packages to be attached in all futures: [n=0] 
[17:00:34.118] getGlobalsAndPackagesXApply() ... DONE
[17:00:34.119] Number of futures (= number of chunks): 2
[17:00:34.119] Launching 2 futures (chunks) ...
[17:00:34.119] Chunk #1 of 2 ...
[17:00:34.119]  - Finding globals in '...' for chunk #1 ...
[17:00:34.119] getGlobalsAndPackages() ...
[17:00:34.119] Searching for globals...
[17:00:34.119] 
[17:00:34.119] Searching for globals ... DONE
[17:00:34.120] - globals: [0] <none>
[17:00:34.120] getGlobalsAndPackages() ... DONE
[17:00:34.120]    + additional globals found: [n=0] 
[17:00:34.120]    + additional namespaces needed: [n=0] 
[17:00:34.120]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:34.120]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.120]  - seeds: <none>
[17:00:34.120]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.120] getGlobalsAndPackages() ...
[17:00:34.121] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.121] Resolving globals: FALSE
[17:00:34.121] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:00:34.122] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:34.122] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.122] 
[17:00:34.122] getGlobalsAndPackages() ... DONE
[17:00:34.122] run() for ‘Future’ ...
[17:00:34.122] - state: ‘created’
[17:00:34.122] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.136] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.137]   - Field: ‘node’
[17:00:34.137]   - Field: ‘label’
[17:00:34.137]   - Field: ‘local’
[17:00:34.137]   - Field: ‘owner’
[17:00:34.137]   - Field: ‘envir’
[17:00:34.137]   - Field: ‘workers’
[17:00:34.137]   - Field: ‘packages’
[17:00:34.137]   - Field: ‘gc’
[17:00:34.138]   - Field: ‘conditions’
[17:00:34.138]   - Field: ‘persistent’
[17:00:34.138]   - Field: ‘expr’
[17:00:34.138]   - Field: ‘uuid’
[17:00:34.138]   - Field: ‘seed’
[17:00:34.138]   - Field: ‘version’
[17:00:34.138]   - Field: ‘result’
[17:00:34.138]   - Field: ‘asynchronous’
[17:00:34.138]   - Field: ‘calls’
[17:00:34.138]   - Field: ‘globals’
[17:00:34.138]   - Field: ‘stdout’
[17:00:34.138]   - Field: ‘earlySignal’
[17:00:34.139]   - Field: ‘lazy’
[17:00:34.139]   - Field: ‘state’
[17:00:34.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.139] - Launch lazy future ...
[17:00:34.139] Packages needed by the future expression (n = 0): <none>
[17:00:34.139] Packages needed by future strategies (n = 0): <none>
[17:00:34.140] {
[17:00:34.140]     {
[17:00:34.140]         {
[17:00:34.140]             ...future.startTime <- base::Sys.time()
[17:00:34.140]             {
[17:00:34.140]                 {
[17:00:34.140]                   {
[17:00:34.140]                     {
[17:00:34.140]                       base::local({
[17:00:34.140]                         has_future <- base::requireNamespace("future", 
[17:00:34.140]                           quietly = TRUE)
[17:00:34.140]                         if (has_future) {
[17:00:34.140]                           ns <- base::getNamespace("future")
[17:00:34.140]                           version <- ns[[".package"]][["version"]]
[17:00:34.140]                           if (is.null(version)) 
[17:00:34.140]                             version <- utils::packageVersion("future")
[17:00:34.140]                         }
[17:00:34.140]                         else {
[17:00:34.140]                           version <- NULL
[17:00:34.140]                         }
[17:00:34.140]                         if (!has_future || version < "1.8.0") {
[17:00:34.140]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.140]                             "", base::R.version$version.string), 
[17:00:34.140]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.140]                               "release", "version")], collapse = " "), 
[17:00:34.140]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.140]                             info)
[17:00:34.140]                           info <- base::paste(info, collapse = "; ")
[17:00:34.140]                           if (!has_future) {
[17:00:34.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.140]                               info)
[17:00:34.140]                           }
[17:00:34.140]                           else {
[17:00:34.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.140]                               info, version)
[17:00:34.140]                           }
[17:00:34.140]                           base::stop(msg)
[17:00:34.140]                         }
[17:00:34.140]                       })
[17:00:34.140]                     }
[17:00:34.140]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.140]                     base::options(mc.cores = 1L)
[17:00:34.140]                   }
[17:00:34.140]                   ...future.strategy.old <- future::plan("list")
[17:00:34.140]                   options(future.plan = NULL)
[17:00:34.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.140]                 }
[17:00:34.140]                 ...future.workdir <- getwd()
[17:00:34.140]             }
[17:00:34.140]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.140]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.140]         }
[17:00:34.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.140]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.140]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.140]             base::names(...future.oldOptions))
[17:00:34.140]     }
[17:00:34.140]     if (FALSE) {
[17:00:34.140]     }
[17:00:34.140]     else {
[17:00:34.140]         if (TRUE) {
[17:00:34.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.140]                 open = "w")
[17:00:34.140]         }
[17:00:34.140]         else {
[17:00:34.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.140]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.140]         }
[17:00:34.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.140]             base::sink(type = "output", split = FALSE)
[17:00:34.140]             base::close(...future.stdout)
[17:00:34.140]         }, add = TRUE)
[17:00:34.140]     }
[17:00:34.140]     ...future.frame <- base::sys.nframe()
[17:00:34.140]     ...future.conditions <- base::list()
[17:00:34.140]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.140]     if (FALSE) {
[17:00:34.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.140]     }
[17:00:34.140]     ...future.result <- base::tryCatch({
[17:00:34.140]         base::withCallingHandlers({
[17:00:34.140]             ...future.value <- base::withVisible(base::local({
[17:00:34.140]                 ...future.makeSendCondition <- base::local({
[17:00:34.140]                   sendCondition <- NULL
[17:00:34.140]                   function(frame = 1L) {
[17:00:34.140]                     if (is.function(sendCondition)) 
[17:00:34.140]                       return(sendCondition)
[17:00:34.140]                     ns <- getNamespace("parallel")
[17:00:34.140]                     if (exists("sendData", mode = "function", 
[17:00:34.140]                       envir = ns)) {
[17:00:34.140]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.140]                         envir = ns)
[17:00:34.140]                       envir <- sys.frame(frame)
[17:00:34.140]                       master <- NULL
[17:00:34.140]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.140]                         !identical(envir, emptyenv())) {
[17:00:34.140]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.140]                           inherits = FALSE)) {
[17:00:34.140]                           master <- get("master", mode = "list", 
[17:00:34.140]                             envir = envir, inherits = FALSE)
[17:00:34.140]                           if (inherits(master, c("SOCKnode", 
[17:00:34.140]                             "SOCK0node"))) {
[17:00:34.140]                             sendCondition <<- function(cond) {
[17:00:34.140]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.140]                                 success = TRUE)
[17:00:34.140]                               parallel_sendData(master, data)
[17:00:34.140]                             }
[17:00:34.140]                             return(sendCondition)
[17:00:34.140]                           }
[17:00:34.140]                         }
[17:00:34.140]                         frame <- frame + 1L
[17:00:34.140]                         envir <- sys.frame(frame)
[17:00:34.140]                       }
[17:00:34.140]                     }
[17:00:34.140]                     sendCondition <<- function(cond) NULL
[17:00:34.140]                   }
[17:00:34.140]                 })
[17:00:34.140]                 withCallingHandlers({
[17:00:34.140]                   {
[17:00:34.140]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.140]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.140]                       ...future.globals.maxSize)) {
[17:00:34.140]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.140]                       on.exit(options(oopts), add = TRUE)
[17:00:34.140]                     }
[17:00:34.140]                     {
[17:00:34.140]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.140]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.140]                         USE.NAMES = FALSE)
[17:00:34.140]                       do.call(mapply, args = args)
[17:00:34.140]                     }
[17:00:34.140]                   }
[17:00:34.140]                 }, immediateCondition = function(cond) {
[17:00:34.140]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.140]                   sendCondition(cond)
[17:00:34.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.140]                   {
[17:00:34.140]                     inherits <- base::inherits
[17:00:34.140]                     invokeRestart <- base::invokeRestart
[17:00:34.140]                     is.null <- base::is.null
[17:00:34.140]                     muffled <- FALSE
[17:00:34.140]                     if (inherits(cond, "message")) {
[17:00:34.140]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.140]                       if (muffled) 
[17:00:34.140]                         invokeRestart("muffleMessage")
[17:00:34.140]                     }
[17:00:34.140]                     else if (inherits(cond, "warning")) {
[17:00:34.140]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.140]                       if (muffled) 
[17:00:34.140]                         invokeRestart("muffleWarning")
[17:00:34.140]                     }
[17:00:34.140]                     else if (inherits(cond, "condition")) {
[17:00:34.140]                       if (!is.null(pattern)) {
[17:00:34.140]                         computeRestarts <- base::computeRestarts
[17:00:34.140]                         grepl <- base::grepl
[17:00:34.140]                         restarts <- computeRestarts(cond)
[17:00:34.140]                         for (restart in restarts) {
[17:00:34.140]                           name <- restart$name
[17:00:34.140]                           if (is.null(name)) 
[17:00:34.140]                             next
[17:00:34.140]                           if (!grepl(pattern, name)) 
[17:00:34.140]                             next
[17:00:34.140]                           invokeRestart(restart)
[17:00:34.140]                           muffled <- TRUE
[17:00:34.140]                           break
[17:00:34.140]                         }
[17:00:34.140]                       }
[17:00:34.140]                     }
[17:00:34.140]                     invisible(muffled)
[17:00:34.140]                   }
[17:00:34.140]                   muffleCondition(cond)
[17:00:34.140]                 })
[17:00:34.140]             }))
[17:00:34.140]             future::FutureResult(value = ...future.value$value, 
[17:00:34.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.140]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.140]                     ...future.globalenv.names))
[17:00:34.140]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.140]         }, condition = base::local({
[17:00:34.140]             c <- base::c
[17:00:34.140]             inherits <- base::inherits
[17:00:34.140]             invokeRestart <- base::invokeRestart
[17:00:34.140]             length <- base::length
[17:00:34.140]             list <- base::list
[17:00:34.140]             seq.int <- base::seq.int
[17:00:34.140]             signalCondition <- base::signalCondition
[17:00:34.140]             sys.calls <- base::sys.calls
[17:00:34.140]             `[[` <- base::`[[`
[17:00:34.140]             `+` <- base::`+`
[17:00:34.140]             `<<-` <- base::`<<-`
[17:00:34.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.140]                   3L)]
[17:00:34.140]             }
[17:00:34.140]             function(cond) {
[17:00:34.140]                 is_error <- inherits(cond, "error")
[17:00:34.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.140]                   NULL)
[17:00:34.140]                 if (is_error) {
[17:00:34.140]                   sessionInformation <- function() {
[17:00:34.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.140]                       search = base::search(), system = base::Sys.info())
[17:00:34.140]                   }
[17:00:34.140]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.140]                     cond$call), session = sessionInformation(), 
[17:00:34.140]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.140]                   signalCondition(cond)
[17:00:34.140]                 }
[17:00:34.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.140]                 "immediateCondition"))) {
[17:00:34.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.140]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.140]                   if (TRUE && !signal) {
[17:00:34.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.140]                     {
[17:00:34.140]                       inherits <- base::inherits
[17:00:34.140]                       invokeRestart <- base::invokeRestart
[17:00:34.140]                       is.null <- base::is.null
[17:00:34.140]                       muffled <- FALSE
[17:00:34.140]                       if (inherits(cond, "message")) {
[17:00:34.140]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.140]                         if (muffled) 
[17:00:34.140]                           invokeRestart("muffleMessage")
[17:00:34.140]                       }
[17:00:34.140]                       else if (inherits(cond, "warning")) {
[17:00:34.140]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.140]                         if (muffled) 
[17:00:34.140]                           invokeRestart("muffleWarning")
[17:00:34.140]                       }
[17:00:34.140]                       else if (inherits(cond, "condition")) {
[17:00:34.140]                         if (!is.null(pattern)) {
[17:00:34.140]                           computeRestarts <- base::computeRestarts
[17:00:34.140]                           grepl <- base::grepl
[17:00:34.140]                           restarts <- computeRestarts(cond)
[17:00:34.140]                           for (restart in restarts) {
[17:00:34.140]                             name <- restart$name
[17:00:34.140]                             if (is.null(name)) 
[17:00:34.140]                               next
[17:00:34.140]                             if (!grepl(pattern, name)) 
[17:00:34.140]                               next
[17:00:34.140]                             invokeRestart(restart)
[17:00:34.140]                             muffled <- TRUE
[17:00:34.140]                             break
[17:00:34.140]                           }
[17:00:34.140]                         }
[17:00:34.140]                       }
[17:00:34.140]                       invisible(muffled)
[17:00:34.140]                     }
[17:00:34.140]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.140]                   }
[17:00:34.140]                 }
[17:00:34.140]                 else {
[17:00:34.140]                   if (TRUE) {
[17:00:34.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.140]                     {
[17:00:34.140]                       inherits <- base::inherits
[17:00:34.140]                       invokeRestart <- base::invokeRestart
[17:00:34.140]                       is.null <- base::is.null
[17:00:34.140]                       muffled <- FALSE
[17:00:34.140]                       if (inherits(cond, "message")) {
[17:00:34.140]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.140]                         if (muffled) 
[17:00:34.140]                           invokeRestart("muffleMessage")
[17:00:34.140]                       }
[17:00:34.140]                       else if (inherits(cond, "warning")) {
[17:00:34.140]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.140]                         if (muffled) 
[17:00:34.140]                           invokeRestart("muffleWarning")
[17:00:34.140]                       }
[17:00:34.140]                       else if (inherits(cond, "condition")) {
[17:00:34.140]                         if (!is.null(pattern)) {
[17:00:34.140]                           computeRestarts <- base::computeRestarts
[17:00:34.140]                           grepl <- base::grepl
[17:00:34.140]                           restarts <- computeRestarts(cond)
[17:00:34.140]                           for (restart in restarts) {
[17:00:34.140]                             name <- restart$name
[17:00:34.140]                             if (is.null(name)) 
[17:00:34.140]                               next
[17:00:34.140]                             if (!grepl(pattern, name)) 
[17:00:34.140]                               next
[17:00:34.140]                             invokeRestart(restart)
[17:00:34.140]                             muffled <- TRUE
[17:00:34.140]                             break
[17:00:34.140]                           }
[17:00:34.140]                         }
[17:00:34.140]                       }
[17:00:34.140]                       invisible(muffled)
[17:00:34.140]                     }
[17:00:34.140]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.140]                   }
[17:00:34.140]                 }
[17:00:34.140]             }
[17:00:34.140]         }))
[17:00:34.140]     }, error = function(ex) {
[17:00:34.140]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.140]                 ...future.rng), started = ...future.startTime, 
[17:00:34.140]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.140]             version = "1.8"), class = "FutureResult")
[17:00:34.140]     }, finally = {
[17:00:34.140]         if (!identical(...future.workdir, getwd())) 
[17:00:34.140]             setwd(...future.workdir)
[17:00:34.140]         {
[17:00:34.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.140]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.140]             }
[17:00:34.140]             base::options(...future.oldOptions)
[17:00:34.140]             if (.Platform$OS.type == "windows") {
[17:00:34.140]                 old_names <- names(...future.oldEnvVars)
[17:00:34.140]                 envs <- base::Sys.getenv()
[17:00:34.140]                 names <- names(envs)
[17:00:34.140]                 common <- intersect(names, old_names)
[17:00:34.140]                 added <- setdiff(names, old_names)
[17:00:34.140]                 removed <- setdiff(old_names, names)
[17:00:34.140]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.140]                   envs[common]]
[17:00:34.140]                 NAMES <- toupper(changed)
[17:00:34.140]                 args <- list()
[17:00:34.140]                 for (kk in seq_along(NAMES)) {
[17:00:34.140]                   name <- changed[[kk]]
[17:00:34.140]                   NAME <- NAMES[[kk]]
[17:00:34.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.140]                     next
[17:00:34.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.140]                 }
[17:00:34.140]                 NAMES <- toupper(added)
[17:00:34.140]                 for (kk in seq_along(NAMES)) {
[17:00:34.140]                   name <- added[[kk]]
[17:00:34.140]                   NAME <- NAMES[[kk]]
[17:00:34.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.140]                     next
[17:00:34.140]                   args[[name]] <- ""
[17:00:34.140]                 }
[17:00:34.140]                 NAMES <- toupper(removed)
[17:00:34.140]                 for (kk in seq_along(NAMES)) {
[17:00:34.140]                   name <- removed[[kk]]
[17:00:34.140]                   NAME <- NAMES[[kk]]
[17:00:34.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.140]                     next
[17:00:34.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.140]                 }
[17:00:34.140]                 if (length(args) > 0) 
[17:00:34.140]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.140]             }
[17:00:34.140]             else {
[17:00:34.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.140]             }
[17:00:34.140]             {
[17:00:34.140]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.140]                   0L) {
[17:00:34.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.140]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.140]                   base::options(opts)
[17:00:34.140]                 }
[17:00:34.140]                 {
[17:00:34.140]                   {
[17:00:34.140]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.140]                     NULL
[17:00:34.140]                   }
[17:00:34.140]                   options(future.plan = NULL)
[17:00:34.140]                   if (is.na(NA_character_)) 
[17:00:34.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.140]                     .init = FALSE)
[17:00:34.140]                 }
[17:00:34.140]             }
[17:00:34.140]         }
[17:00:34.140]     })
[17:00:34.140]     if (TRUE) {
[17:00:34.140]         base::sink(type = "output", split = FALSE)
[17:00:34.140]         if (TRUE) {
[17:00:34.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.140]         }
[17:00:34.140]         else {
[17:00:34.140]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.140]         }
[17:00:34.140]         base::close(...future.stdout)
[17:00:34.140]         ...future.stdout <- NULL
[17:00:34.140]     }
[17:00:34.140]     ...future.result$conditions <- ...future.conditions
[17:00:34.140]     ...future.result$finished <- base::Sys.time()
[17:00:34.140]     ...future.result
[17:00:34.140] }
[17:00:34.143] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:00:34.143] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:00:34.143] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:00:34.143] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:34.144] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.144] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:00:34.144] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:00:34.144] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:34.144] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.145] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:34.145] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.145] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:00:34.146] MultisessionFuture started
[17:00:34.146] - Launch lazy future ... done
[17:00:34.146] run() for ‘MultisessionFuture’ ... done
[17:00:34.146] Created future:
[17:00:34.146] MultisessionFuture:
[17:00:34.146] Label: ‘future_.mapply-1’
[17:00:34.146] Expression:
[17:00:34.146] {
[17:00:34.146]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.146]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.146]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.146]         on.exit(options(oopts), add = TRUE)
[17:00:34.146]     }
[17:00:34.146]     {
[17:00:34.146]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.146]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.146]         do.call(mapply, args = args)
[17:00:34.146]     }
[17:00:34.146] }
[17:00:34.146] Lazy evaluation: FALSE
[17:00:34.146] Asynchronous evaluation: TRUE
[17:00:34.146] Local evaluation: TRUE
[17:00:34.146] Environment: R_GlobalEnv
[17:00:34.146] Capture standard output: TRUE
[17:00:34.146] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.146] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.146] Packages: <none>
[17:00:34.146] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.146] Resolved: FALSE
[17:00:34.146] Value: <not collected>
[17:00:34.146] Conditions captured: <none>
[17:00:34.146] Early signaling: FALSE
[17:00:34.146] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.146] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.158] Chunk #1 of 2 ... DONE
[17:00:34.158] Chunk #2 of 2 ...
[17:00:34.158]  - Finding globals in '...' for chunk #2 ...
[17:00:34.158] getGlobalsAndPackages() ...
[17:00:34.158] Searching for globals...
[17:00:34.158] 
[17:00:34.158] Searching for globals ... DONE
[17:00:34.159] - globals: [0] <none>
[17:00:34.159] getGlobalsAndPackages() ... DONE
[17:00:34.159]    + additional globals found: [n=0] 
[17:00:34.159]    + additional namespaces needed: [n=0] 
[17:00:34.159]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:34.159]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.159]  - seeds: <none>
[17:00:34.159]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.159] getGlobalsAndPackages() ...
[17:00:34.159] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.160] Resolving globals: FALSE
[17:00:34.160] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:00:34.161] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:34.161] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.161] 
[17:00:34.161] getGlobalsAndPackages() ... DONE
[17:00:34.161] run() for ‘Future’ ...
[17:00:34.161] - state: ‘created’
[17:00:34.161] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.176] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.176]   - Field: ‘node’
[17:00:34.176]   - Field: ‘label’
[17:00:34.176]   - Field: ‘local’
[17:00:34.176]   - Field: ‘owner’
[17:00:34.177]   - Field: ‘envir’
[17:00:34.177]   - Field: ‘workers’
[17:00:34.177]   - Field: ‘packages’
[17:00:34.177]   - Field: ‘gc’
[17:00:34.177]   - Field: ‘conditions’
[17:00:34.177]   - Field: ‘persistent’
[17:00:34.177]   - Field: ‘expr’
[17:00:34.177]   - Field: ‘uuid’
[17:00:34.177]   - Field: ‘seed’
[17:00:34.177]   - Field: ‘version’
[17:00:34.177]   - Field: ‘result’
[17:00:34.177]   - Field: ‘asynchronous’
[17:00:34.178]   - Field: ‘calls’
[17:00:34.178]   - Field: ‘globals’
[17:00:34.178]   - Field: ‘stdout’
[17:00:34.178]   - Field: ‘earlySignal’
[17:00:34.178]   - Field: ‘lazy’
[17:00:34.178]   - Field: ‘state’
[17:00:34.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.178] - Launch lazy future ...
[17:00:34.179] Packages needed by the future expression (n = 0): <none>
[17:00:34.179] Packages needed by future strategies (n = 0): <none>
[17:00:34.179] {
[17:00:34.179]     {
[17:00:34.179]         {
[17:00:34.179]             ...future.startTime <- base::Sys.time()
[17:00:34.179]             {
[17:00:34.179]                 {
[17:00:34.179]                   {
[17:00:34.179]                     {
[17:00:34.179]                       base::local({
[17:00:34.179]                         has_future <- base::requireNamespace("future", 
[17:00:34.179]                           quietly = TRUE)
[17:00:34.179]                         if (has_future) {
[17:00:34.179]                           ns <- base::getNamespace("future")
[17:00:34.179]                           version <- ns[[".package"]][["version"]]
[17:00:34.179]                           if (is.null(version)) 
[17:00:34.179]                             version <- utils::packageVersion("future")
[17:00:34.179]                         }
[17:00:34.179]                         else {
[17:00:34.179]                           version <- NULL
[17:00:34.179]                         }
[17:00:34.179]                         if (!has_future || version < "1.8.0") {
[17:00:34.179]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.179]                             "", base::R.version$version.string), 
[17:00:34.179]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.179]                               "release", "version")], collapse = " "), 
[17:00:34.179]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.179]                             info)
[17:00:34.179]                           info <- base::paste(info, collapse = "; ")
[17:00:34.179]                           if (!has_future) {
[17:00:34.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.179]                               info)
[17:00:34.179]                           }
[17:00:34.179]                           else {
[17:00:34.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.179]                               info, version)
[17:00:34.179]                           }
[17:00:34.179]                           base::stop(msg)
[17:00:34.179]                         }
[17:00:34.179]                       })
[17:00:34.179]                     }
[17:00:34.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.179]                     base::options(mc.cores = 1L)
[17:00:34.179]                   }
[17:00:34.179]                   ...future.strategy.old <- future::plan("list")
[17:00:34.179]                   options(future.plan = NULL)
[17:00:34.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.179]                 }
[17:00:34.179]                 ...future.workdir <- getwd()
[17:00:34.179]             }
[17:00:34.179]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.179]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.179]         }
[17:00:34.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.179]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.179]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.179]             base::names(...future.oldOptions))
[17:00:34.179]     }
[17:00:34.179]     if (FALSE) {
[17:00:34.179]     }
[17:00:34.179]     else {
[17:00:34.179]         if (TRUE) {
[17:00:34.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.179]                 open = "w")
[17:00:34.179]         }
[17:00:34.179]         else {
[17:00:34.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.179]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.179]         }
[17:00:34.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.179]             base::sink(type = "output", split = FALSE)
[17:00:34.179]             base::close(...future.stdout)
[17:00:34.179]         }, add = TRUE)
[17:00:34.179]     }
[17:00:34.179]     ...future.frame <- base::sys.nframe()
[17:00:34.179]     ...future.conditions <- base::list()
[17:00:34.179]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.179]     if (FALSE) {
[17:00:34.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.179]     }
[17:00:34.179]     ...future.result <- base::tryCatch({
[17:00:34.179]         base::withCallingHandlers({
[17:00:34.179]             ...future.value <- base::withVisible(base::local({
[17:00:34.179]                 ...future.makeSendCondition <- base::local({
[17:00:34.179]                   sendCondition <- NULL
[17:00:34.179]                   function(frame = 1L) {
[17:00:34.179]                     if (is.function(sendCondition)) 
[17:00:34.179]                       return(sendCondition)
[17:00:34.179]                     ns <- getNamespace("parallel")
[17:00:34.179]                     if (exists("sendData", mode = "function", 
[17:00:34.179]                       envir = ns)) {
[17:00:34.179]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.179]                         envir = ns)
[17:00:34.179]                       envir <- sys.frame(frame)
[17:00:34.179]                       master <- NULL
[17:00:34.179]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.179]                         !identical(envir, emptyenv())) {
[17:00:34.179]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.179]                           inherits = FALSE)) {
[17:00:34.179]                           master <- get("master", mode = "list", 
[17:00:34.179]                             envir = envir, inherits = FALSE)
[17:00:34.179]                           if (inherits(master, c("SOCKnode", 
[17:00:34.179]                             "SOCK0node"))) {
[17:00:34.179]                             sendCondition <<- function(cond) {
[17:00:34.179]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.179]                                 success = TRUE)
[17:00:34.179]                               parallel_sendData(master, data)
[17:00:34.179]                             }
[17:00:34.179]                             return(sendCondition)
[17:00:34.179]                           }
[17:00:34.179]                         }
[17:00:34.179]                         frame <- frame + 1L
[17:00:34.179]                         envir <- sys.frame(frame)
[17:00:34.179]                       }
[17:00:34.179]                     }
[17:00:34.179]                     sendCondition <<- function(cond) NULL
[17:00:34.179]                   }
[17:00:34.179]                 })
[17:00:34.179]                 withCallingHandlers({
[17:00:34.179]                   {
[17:00:34.179]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.179]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.179]                       ...future.globals.maxSize)) {
[17:00:34.179]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.179]                       on.exit(options(oopts), add = TRUE)
[17:00:34.179]                     }
[17:00:34.179]                     {
[17:00:34.179]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.179]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.179]                         USE.NAMES = FALSE)
[17:00:34.179]                       do.call(mapply, args = args)
[17:00:34.179]                     }
[17:00:34.179]                   }
[17:00:34.179]                 }, immediateCondition = function(cond) {
[17:00:34.179]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.179]                   sendCondition(cond)
[17:00:34.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.179]                   {
[17:00:34.179]                     inherits <- base::inherits
[17:00:34.179]                     invokeRestart <- base::invokeRestart
[17:00:34.179]                     is.null <- base::is.null
[17:00:34.179]                     muffled <- FALSE
[17:00:34.179]                     if (inherits(cond, "message")) {
[17:00:34.179]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.179]                       if (muffled) 
[17:00:34.179]                         invokeRestart("muffleMessage")
[17:00:34.179]                     }
[17:00:34.179]                     else if (inherits(cond, "warning")) {
[17:00:34.179]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.179]                       if (muffled) 
[17:00:34.179]                         invokeRestart("muffleWarning")
[17:00:34.179]                     }
[17:00:34.179]                     else if (inherits(cond, "condition")) {
[17:00:34.179]                       if (!is.null(pattern)) {
[17:00:34.179]                         computeRestarts <- base::computeRestarts
[17:00:34.179]                         grepl <- base::grepl
[17:00:34.179]                         restarts <- computeRestarts(cond)
[17:00:34.179]                         for (restart in restarts) {
[17:00:34.179]                           name <- restart$name
[17:00:34.179]                           if (is.null(name)) 
[17:00:34.179]                             next
[17:00:34.179]                           if (!grepl(pattern, name)) 
[17:00:34.179]                             next
[17:00:34.179]                           invokeRestart(restart)
[17:00:34.179]                           muffled <- TRUE
[17:00:34.179]                           break
[17:00:34.179]                         }
[17:00:34.179]                       }
[17:00:34.179]                     }
[17:00:34.179]                     invisible(muffled)
[17:00:34.179]                   }
[17:00:34.179]                   muffleCondition(cond)
[17:00:34.179]                 })
[17:00:34.179]             }))
[17:00:34.179]             future::FutureResult(value = ...future.value$value, 
[17:00:34.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.179]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.179]                     ...future.globalenv.names))
[17:00:34.179]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.179]         }, condition = base::local({
[17:00:34.179]             c <- base::c
[17:00:34.179]             inherits <- base::inherits
[17:00:34.179]             invokeRestart <- base::invokeRestart
[17:00:34.179]             length <- base::length
[17:00:34.179]             list <- base::list
[17:00:34.179]             seq.int <- base::seq.int
[17:00:34.179]             signalCondition <- base::signalCondition
[17:00:34.179]             sys.calls <- base::sys.calls
[17:00:34.179]             `[[` <- base::`[[`
[17:00:34.179]             `+` <- base::`+`
[17:00:34.179]             `<<-` <- base::`<<-`
[17:00:34.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.179]                   3L)]
[17:00:34.179]             }
[17:00:34.179]             function(cond) {
[17:00:34.179]                 is_error <- inherits(cond, "error")
[17:00:34.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.179]                   NULL)
[17:00:34.179]                 if (is_error) {
[17:00:34.179]                   sessionInformation <- function() {
[17:00:34.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.179]                       search = base::search(), system = base::Sys.info())
[17:00:34.179]                   }
[17:00:34.179]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.179]                     cond$call), session = sessionInformation(), 
[17:00:34.179]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.179]                   signalCondition(cond)
[17:00:34.179]                 }
[17:00:34.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.179]                 "immediateCondition"))) {
[17:00:34.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.179]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.179]                   if (TRUE && !signal) {
[17:00:34.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.179]                     {
[17:00:34.179]                       inherits <- base::inherits
[17:00:34.179]                       invokeRestart <- base::invokeRestart
[17:00:34.179]                       is.null <- base::is.null
[17:00:34.179]                       muffled <- FALSE
[17:00:34.179]                       if (inherits(cond, "message")) {
[17:00:34.179]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.179]                         if (muffled) 
[17:00:34.179]                           invokeRestart("muffleMessage")
[17:00:34.179]                       }
[17:00:34.179]                       else if (inherits(cond, "warning")) {
[17:00:34.179]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.179]                         if (muffled) 
[17:00:34.179]                           invokeRestart("muffleWarning")
[17:00:34.179]                       }
[17:00:34.179]                       else if (inherits(cond, "condition")) {
[17:00:34.179]                         if (!is.null(pattern)) {
[17:00:34.179]                           computeRestarts <- base::computeRestarts
[17:00:34.179]                           grepl <- base::grepl
[17:00:34.179]                           restarts <- computeRestarts(cond)
[17:00:34.179]                           for (restart in restarts) {
[17:00:34.179]                             name <- restart$name
[17:00:34.179]                             if (is.null(name)) 
[17:00:34.179]                               next
[17:00:34.179]                             if (!grepl(pattern, name)) 
[17:00:34.179]                               next
[17:00:34.179]                             invokeRestart(restart)
[17:00:34.179]                             muffled <- TRUE
[17:00:34.179]                             break
[17:00:34.179]                           }
[17:00:34.179]                         }
[17:00:34.179]                       }
[17:00:34.179]                       invisible(muffled)
[17:00:34.179]                     }
[17:00:34.179]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.179]                   }
[17:00:34.179]                 }
[17:00:34.179]                 else {
[17:00:34.179]                   if (TRUE) {
[17:00:34.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.179]                     {
[17:00:34.179]                       inherits <- base::inherits
[17:00:34.179]                       invokeRestart <- base::invokeRestart
[17:00:34.179]                       is.null <- base::is.null
[17:00:34.179]                       muffled <- FALSE
[17:00:34.179]                       if (inherits(cond, "message")) {
[17:00:34.179]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.179]                         if (muffled) 
[17:00:34.179]                           invokeRestart("muffleMessage")
[17:00:34.179]                       }
[17:00:34.179]                       else if (inherits(cond, "warning")) {
[17:00:34.179]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.179]                         if (muffled) 
[17:00:34.179]                           invokeRestart("muffleWarning")
[17:00:34.179]                       }
[17:00:34.179]                       else if (inherits(cond, "condition")) {
[17:00:34.179]                         if (!is.null(pattern)) {
[17:00:34.179]                           computeRestarts <- base::computeRestarts
[17:00:34.179]                           grepl <- base::grepl
[17:00:34.179]                           restarts <- computeRestarts(cond)
[17:00:34.179]                           for (restart in restarts) {
[17:00:34.179]                             name <- restart$name
[17:00:34.179]                             if (is.null(name)) 
[17:00:34.179]                               next
[17:00:34.179]                             if (!grepl(pattern, name)) 
[17:00:34.179]                               next
[17:00:34.179]                             invokeRestart(restart)
[17:00:34.179]                             muffled <- TRUE
[17:00:34.179]                             break
[17:00:34.179]                           }
[17:00:34.179]                         }
[17:00:34.179]                       }
[17:00:34.179]                       invisible(muffled)
[17:00:34.179]                     }
[17:00:34.179]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.179]                   }
[17:00:34.179]                 }
[17:00:34.179]             }
[17:00:34.179]         }))
[17:00:34.179]     }, error = function(ex) {
[17:00:34.179]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.179]                 ...future.rng), started = ...future.startTime, 
[17:00:34.179]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.179]             version = "1.8"), class = "FutureResult")
[17:00:34.179]     }, finally = {
[17:00:34.179]         if (!identical(...future.workdir, getwd())) 
[17:00:34.179]             setwd(...future.workdir)
[17:00:34.179]         {
[17:00:34.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.179]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.179]             }
[17:00:34.179]             base::options(...future.oldOptions)
[17:00:34.179]             if (.Platform$OS.type == "windows") {
[17:00:34.179]                 old_names <- names(...future.oldEnvVars)
[17:00:34.179]                 envs <- base::Sys.getenv()
[17:00:34.179]                 names <- names(envs)
[17:00:34.179]                 common <- intersect(names, old_names)
[17:00:34.179]                 added <- setdiff(names, old_names)
[17:00:34.179]                 removed <- setdiff(old_names, names)
[17:00:34.179]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.179]                   envs[common]]
[17:00:34.179]                 NAMES <- toupper(changed)
[17:00:34.179]                 args <- list()
[17:00:34.179]                 for (kk in seq_along(NAMES)) {
[17:00:34.179]                   name <- changed[[kk]]
[17:00:34.179]                   NAME <- NAMES[[kk]]
[17:00:34.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.179]                     next
[17:00:34.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.179]                 }
[17:00:34.179]                 NAMES <- toupper(added)
[17:00:34.179]                 for (kk in seq_along(NAMES)) {
[17:00:34.179]                   name <- added[[kk]]
[17:00:34.179]                   NAME <- NAMES[[kk]]
[17:00:34.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.179]                     next
[17:00:34.179]                   args[[name]] <- ""
[17:00:34.179]                 }
[17:00:34.179]                 NAMES <- toupper(removed)
[17:00:34.179]                 for (kk in seq_along(NAMES)) {
[17:00:34.179]                   name <- removed[[kk]]
[17:00:34.179]                   NAME <- NAMES[[kk]]
[17:00:34.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.179]                     next
[17:00:34.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.179]                 }
[17:00:34.179]                 if (length(args) > 0) 
[17:00:34.179]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.179]             }
[17:00:34.179]             else {
[17:00:34.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.179]             }
[17:00:34.179]             {
[17:00:34.179]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.179]                   0L) {
[17:00:34.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.179]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.179]                   base::options(opts)
[17:00:34.179]                 }
[17:00:34.179]                 {
[17:00:34.179]                   {
[17:00:34.179]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.179]                     NULL
[17:00:34.179]                   }
[17:00:34.179]                   options(future.plan = NULL)
[17:00:34.179]                   if (is.na(NA_character_)) 
[17:00:34.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.179]                     .init = FALSE)
[17:00:34.179]                 }
[17:00:34.179]             }
[17:00:34.179]         }
[17:00:34.179]     })
[17:00:34.179]     if (TRUE) {
[17:00:34.179]         base::sink(type = "output", split = FALSE)
[17:00:34.179]         if (TRUE) {
[17:00:34.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.179]         }
[17:00:34.179]         else {
[17:00:34.179]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.179]         }
[17:00:34.179]         base::close(...future.stdout)
[17:00:34.179]         ...future.stdout <- NULL
[17:00:34.179]     }
[17:00:34.179]     ...future.result$conditions <- ...future.conditions
[17:00:34.179]     ...future.result$finished <- base::Sys.time()
[17:00:34.179]     ...future.result
[17:00:34.179] }
[17:00:34.182] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:00:34.182] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:00:34.183] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:00:34.183] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:34.183] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.183] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:00:34.184] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:00:34.184] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:34.187] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.187] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:34.187] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.187] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:00:34.188] MultisessionFuture started
[17:00:34.188] - Launch lazy future ... done
[17:00:34.188] run() for ‘MultisessionFuture’ ... done
[17:00:34.188] Created future:
[17:00:34.189] MultisessionFuture:
[17:00:34.189] Label: ‘future_.mapply-2’
[17:00:34.189] Expression:
[17:00:34.189] {
[17:00:34.189]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.189]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.189]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.189]         on.exit(options(oopts), add = TRUE)
[17:00:34.189]     }
[17:00:34.189]     {
[17:00:34.189]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.189]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.189]         do.call(mapply, args = args)
[17:00:34.189]     }
[17:00:34.189] }
[17:00:34.189] Lazy evaluation: FALSE
[17:00:34.189] Asynchronous evaluation: TRUE
[17:00:34.189] Local evaluation: TRUE
[17:00:34.189] Environment: R_GlobalEnv
[17:00:34.189] Capture standard output: TRUE
[17:00:34.189] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.189] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.189] Packages: <none>
[17:00:34.189] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.189] Resolved: FALSE
[17:00:34.189] Value: <not collected>
[17:00:34.189] Conditions captured: <none>
[17:00:34.189] Early signaling: FALSE
[17:00:34.189] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.189] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.200] Chunk #2 of 2 ... DONE
[17:00:34.200] Launching 2 futures (chunks) ... DONE
[17:00:34.200] Resolving 2 futures (chunks) ...
[17:00:34.200] resolve() on list ...
[17:00:34.200]  recursive: 0
[17:00:34.201]  length: 2
[17:00:34.201] 
[17:00:34.201] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.201] - Validating connection of MultisessionFuture
[17:00:34.201] - received message: FutureResult
[17:00:34.202] - Received FutureResult
[17:00:34.202] - Erased future from FutureRegistry
[17:00:34.202] result() for ClusterFuture ...
[17:00:34.202] - result already collected: FutureResult
[17:00:34.202] result() for ClusterFuture ... done
[17:00:34.202] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.202] Future #1
[17:00:34.202] result() for ClusterFuture ...
[17:00:34.202] - result already collected: FutureResult
[17:00:34.202] result() for ClusterFuture ... done
[17:00:34.202] result() for ClusterFuture ...
[17:00:34.203] - result already collected: FutureResult
[17:00:34.203] result() for ClusterFuture ... done
[17:00:34.203] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:34.203] - nx: 2
[17:00:34.203] - relay: TRUE
[17:00:34.203] - stdout: TRUE
[17:00:34.203] - signal: TRUE
[17:00:34.203] - resignal: FALSE
[17:00:34.203] - force: TRUE
[17:00:34.203] - relayed: [n=2] FALSE, FALSE
[17:00:34.203] - queued futures: [n=2] FALSE, FALSE
[17:00:34.203]  - until=1
[17:00:34.204]  - relaying element #1
[17:00:34.204] result() for ClusterFuture ...
[17:00:34.204] - result already collected: FutureResult
[17:00:34.204] result() for ClusterFuture ... done
[17:00:34.204] result() for ClusterFuture ...
[17:00:34.204] - result already collected: FutureResult
[17:00:34.204] result() for ClusterFuture ... done
[17:00:34.204] result() for ClusterFuture ...
[17:00:34.204] - result already collected: FutureResult
[17:00:34.204] result() for ClusterFuture ... done
[17:00:34.204] result() for ClusterFuture ...
[17:00:34.205] - result already collected: FutureResult
[17:00:34.205] result() for ClusterFuture ... done
[17:00:34.205] - relayed: [n=2] TRUE, FALSE
[17:00:34.205] - queued futures: [n=2] TRUE, FALSE
[17:00:34.205] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:34.205]  length: 1 (resolved future 1)
[17:00:34.233] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.233] - Validating connection of MultisessionFuture
[17:00:34.233] - received message: FutureResult
[17:00:34.234] - Received FutureResult
[17:00:34.234] - Erased future from FutureRegistry
[17:00:34.234] result() for ClusterFuture ...
[17:00:34.234] - result already collected: FutureResult
[17:00:34.234] result() for ClusterFuture ... done
[17:00:34.234] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.234] Future #2
[17:00:34.234] result() for ClusterFuture ...
[17:00:34.234] - result already collected: FutureResult
[17:00:34.234] result() for ClusterFuture ... done
[17:00:34.235] result() for ClusterFuture ...
[17:00:34.235] - result already collected: FutureResult
[17:00:34.235] result() for ClusterFuture ... done
[17:00:34.235] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:34.235] - nx: 2
[17:00:34.235] - relay: TRUE
[17:00:34.235] - stdout: TRUE
[17:00:34.235] - signal: TRUE
[17:00:34.235] - resignal: FALSE
[17:00:34.235] - force: TRUE
[17:00:34.235] - relayed: [n=2] TRUE, FALSE
[17:00:34.236] - queued futures: [n=2] TRUE, FALSE
[17:00:34.236]  - until=2
[17:00:34.236]  - relaying element #2
[17:00:34.236] result() for ClusterFuture ...
[17:00:34.236] - result already collected: FutureResult
[17:00:34.236] result() for ClusterFuture ... done
[17:00:34.236] result() for ClusterFuture ...
[17:00:34.236] - result already collected: FutureResult
[17:00:34.236] result() for ClusterFuture ... done
[17:00:34.236] result() for ClusterFuture ...
[17:00:34.236] - result already collected: FutureResult
[17:00:34.237] result() for ClusterFuture ... done
[17:00:34.237] result() for ClusterFuture ...
[17:00:34.237] - result already collected: FutureResult
[17:00:34.237] result() for ClusterFuture ... done
[17:00:34.237] - relayed: [n=2] TRUE, TRUE
[17:00:34.237] - queued futures: [n=2] TRUE, TRUE
[17:00:34.237] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:34.237]  length: 0 (resolved future 2)
[17:00:34.237] Relaying remaining futures
[17:00:34.237] signalConditionsASAP(NULL, pos=0) ...
[17:00:34.237] - nx: 2
[17:00:34.238] - relay: TRUE
[17:00:34.238] - stdout: TRUE
[17:00:34.238] - signal: TRUE
[17:00:34.238] - resignal: FALSE
[17:00:34.238] - force: TRUE
[17:00:34.238] - relayed: [n=2] TRUE, TRUE
[17:00:34.238] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:34.238] - relayed: [n=2] TRUE, TRUE
[17:00:34.238] - queued futures: [n=2] TRUE, TRUE
[17:00:34.238] signalConditionsASAP(NULL, pos=0) ... done
[17:00:34.238] resolve() on list ... DONE
[17:00:34.238] result() for ClusterFuture ...
[17:00:34.239] - result already collected: FutureResult
[17:00:34.239] result() for ClusterFuture ... done
[17:00:34.239] result() for ClusterFuture ...
[17:00:34.239] - result already collected: FutureResult
[17:00:34.239] result() for ClusterFuture ... done
[17:00:34.239] result() for ClusterFuture ...
[17:00:34.239] - result already collected: FutureResult
[17:00:34.239] result() for ClusterFuture ... done
[17:00:34.239] result() for ClusterFuture ...
[17:00:34.239] - result already collected: FutureResult
[17:00:34.239] result() for ClusterFuture ... done
[17:00:34.240]  - Number of value chunks collected: 2
[17:00:34.240] Resolving 2 futures (chunks) ... DONE
[17:00:34.240] Reducing values from 2 chunks ...
[17:00:34.240]  - Number of values collected after concatenation: 5
[17:00:34.240]  - Number of values expected: 5
[17:00:34.240] Reducing values from 2 chunks ... DONE
[17:00:34.240] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[17:00:34.240] future_mapply() ...
[17:00:34.244] Number of chunks: 1
[17:00:34.244] getGlobalsAndPackagesXApply() ...
[17:00:34.244]  - future.globals: TRUE
[17:00:34.244] getGlobalsAndPackages() ...
[17:00:34.245] Searching for globals...
[17:00:34.246] - globals found: [1] ‘FUN’
[17:00:34.246] Searching for globals ... DONE
[17:00:34.246] Resolving globals: FALSE
[17:00:34.246] The total size of the 1 globals is 848 bytes (848 bytes)
[17:00:34.246] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:00:34.247] - globals: [1] ‘FUN’
[17:00:34.247] 
[17:00:34.247] getGlobalsAndPackages() ... DONE
[17:00:34.247]  - globals found/used: [n=1] ‘FUN’
[17:00:34.247]  - needed namespaces: [n=0] 
[17:00:34.247] Finding globals ... DONE
[17:00:34.247] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:34.247] List of 2
[17:00:34.247]  $ ...future.FUN:function (x)  
[17:00:34.247]  $ MoreArgs     : NULL
[17:00:34.247]  - attr(*, "where")=List of 2
[17:00:34.247]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:34.247]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:34.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:34.247]  - attr(*, "resolved")= logi FALSE
[17:00:34.247]  - attr(*, "total_size")= num NA
[17:00:34.250] Packages to be attached in all futures: [n=0] 
[17:00:34.250] getGlobalsAndPackagesXApply() ... DONE
[17:00:34.250] Number of futures (= number of chunks): 1
[17:00:34.250] Launching 1 futures (chunks) ...
[17:00:34.250] Chunk #1 of 1 ...
[17:00:34.250]  - Finding globals in '...' for chunk #1 ...
[17:00:34.251] getGlobalsAndPackages() ...
[17:00:34.251] Searching for globals...
[17:00:34.251] 
[17:00:34.251] Searching for globals ... DONE
[17:00:34.251] - globals: [0] <none>
[17:00:34.251] getGlobalsAndPackages() ... DONE
[17:00:34.251]    + additional globals found: [n=0] 
[17:00:34.251]    + additional namespaces needed: [n=0] 
[17:00:34.251]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:34.252]  - seeds: <none>
[17:00:34.252]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.252] getGlobalsAndPackages() ...
[17:00:34.252] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.252] Resolving globals: FALSE
[17:00:34.252] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:00:34.253] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:34.253] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.253] 
[17:00:34.253] getGlobalsAndPackages() ... DONE
[17:00:34.253] run() for ‘Future’ ...
[17:00:34.254] - state: ‘created’
[17:00:34.254] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.268] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.268] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.268]   - Field: ‘node’
[17:00:34.268]   - Field: ‘label’
[17:00:34.268]   - Field: ‘local’
[17:00:34.268]   - Field: ‘owner’
[17:00:34.269]   - Field: ‘envir’
[17:00:34.269]   - Field: ‘workers’
[17:00:34.269]   - Field: ‘packages’
[17:00:34.269]   - Field: ‘gc’
[17:00:34.269]   - Field: ‘conditions’
[17:00:34.269]   - Field: ‘persistent’
[17:00:34.269]   - Field: ‘expr’
[17:00:34.269]   - Field: ‘uuid’
[17:00:34.269]   - Field: ‘seed’
[17:00:34.269]   - Field: ‘version’
[17:00:34.269]   - Field: ‘result’
[17:00:34.270]   - Field: ‘asynchronous’
[17:00:34.270]   - Field: ‘calls’
[17:00:34.270]   - Field: ‘globals’
[17:00:34.270]   - Field: ‘stdout’
[17:00:34.270]   - Field: ‘earlySignal’
[17:00:34.270]   - Field: ‘lazy’
[17:00:34.270]   - Field: ‘state’
[17:00:34.270] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.270] - Launch lazy future ...
[17:00:34.271] Packages needed by the future expression (n = 0): <none>
[17:00:34.271] Packages needed by future strategies (n = 0): <none>
[17:00:34.271] {
[17:00:34.271]     {
[17:00:34.271]         {
[17:00:34.271]             ...future.startTime <- base::Sys.time()
[17:00:34.271]             {
[17:00:34.271]                 {
[17:00:34.271]                   {
[17:00:34.271]                     {
[17:00:34.271]                       base::local({
[17:00:34.271]                         has_future <- base::requireNamespace("future", 
[17:00:34.271]                           quietly = TRUE)
[17:00:34.271]                         if (has_future) {
[17:00:34.271]                           ns <- base::getNamespace("future")
[17:00:34.271]                           version <- ns[[".package"]][["version"]]
[17:00:34.271]                           if (is.null(version)) 
[17:00:34.271]                             version <- utils::packageVersion("future")
[17:00:34.271]                         }
[17:00:34.271]                         else {
[17:00:34.271]                           version <- NULL
[17:00:34.271]                         }
[17:00:34.271]                         if (!has_future || version < "1.8.0") {
[17:00:34.271]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.271]                             "", base::R.version$version.string), 
[17:00:34.271]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.271]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.271]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.271]                               "release", "version")], collapse = " "), 
[17:00:34.271]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.271]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.271]                             info)
[17:00:34.271]                           info <- base::paste(info, collapse = "; ")
[17:00:34.271]                           if (!has_future) {
[17:00:34.271]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.271]                               info)
[17:00:34.271]                           }
[17:00:34.271]                           else {
[17:00:34.271]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.271]                               info, version)
[17:00:34.271]                           }
[17:00:34.271]                           base::stop(msg)
[17:00:34.271]                         }
[17:00:34.271]                       })
[17:00:34.271]                     }
[17:00:34.271]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.271]                     base::options(mc.cores = 1L)
[17:00:34.271]                   }
[17:00:34.271]                   ...future.strategy.old <- future::plan("list")
[17:00:34.271]                   options(future.plan = NULL)
[17:00:34.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.271]                 }
[17:00:34.271]                 ...future.workdir <- getwd()
[17:00:34.271]             }
[17:00:34.271]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.271]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.271]         }
[17:00:34.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.271]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:34.271]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.271]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.271]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.271]             base::names(...future.oldOptions))
[17:00:34.271]     }
[17:00:34.271]     if (FALSE) {
[17:00:34.271]     }
[17:00:34.271]     else {
[17:00:34.271]         if (TRUE) {
[17:00:34.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.271]                 open = "w")
[17:00:34.271]         }
[17:00:34.271]         else {
[17:00:34.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.271]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.271]         }
[17:00:34.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.271]             base::sink(type = "output", split = FALSE)
[17:00:34.271]             base::close(...future.stdout)
[17:00:34.271]         }, add = TRUE)
[17:00:34.271]     }
[17:00:34.271]     ...future.frame <- base::sys.nframe()
[17:00:34.271]     ...future.conditions <- base::list()
[17:00:34.271]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.271]     if (FALSE) {
[17:00:34.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.271]     }
[17:00:34.271]     ...future.result <- base::tryCatch({
[17:00:34.271]         base::withCallingHandlers({
[17:00:34.271]             ...future.value <- base::withVisible(base::local({
[17:00:34.271]                 ...future.makeSendCondition <- base::local({
[17:00:34.271]                   sendCondition <- NULL
[17:00:34.271]                   function(frame = 1L) {
[17:00:34.271]                     if (is.function(sendCondition)) 
[17:00:34.271]                       return(sendCondition)
[17:00:34.271]                     ns <- getNamespace("parallel")
[17:00:34.271]                     if (exists("sendData", mode = "function", 
[17:00:34.271]                       envir = ns)) {
[17:00:34.271]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.271]                         envir = ns)
[17:00:34.271]                       envir <- sys.frame(frame)
[17:00:34.271]                       master <- NULL
[17:00:34.271]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.271]                         !identical(envir, emptyenv())) {
[17:00:34.271]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.271]                           inherits = FALSE)) {
[17:00:34.271]                           master <- get("master", mode = "list", 
[17:00:34.271]                             envir = envir, inherits = FALSE)
[17:00:34.271]                           if (inherits(master, c("SOCKnode", 
[17:00:34.271]                             "SOCK0node"))) {
[17:00:34.271]                             sendCondition <<- function(cond) {
[17:00:34.271]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.271]                                 success = TRUE)
[17:00:34.271]                               parallel_sendData(master, data)
[17:00:34.271]                             }
[17:00:34.271]                             return(sendCondition)
[17:00:34.271]                           }
[17:00:34.271]                         }
[17:00:34.271]                         frame <- frame + 1L
[17:00:34.271]                         envir <- sys.frame(frame)
[17:00:34.271]                       }
[17:00:34.271]                     }
[17:00:34.271]                     sendCondition <<- function(cond) NULL
[17:00:34.271]                   }
[17:00:34.271]                 })
[17:00:34.271]                 withCallingHandlers({
[17:00:34.271]                   {
[17:00:34.271]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.271]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.271]                       ...future.globals.maxSize)) {
[17:00:34.271]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.271]                       on.exit(options(oopts), add = TRUE)
[17:00:34.271]                     }
[17:00:34.271]                     {
[17:00:34.271]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.271]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.271]                         USE.NAMES = FALSE)
[17:00:34.271]                       do.call(mapply, args = args)
[17:00:34.271]                     }
[17:00:34.271]                   }
[17:00:34.271]                 }, immediateCondition = function(cond) {
[17:00:34.271]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.271]                   sendCondition(cond)
[17:00:34.271]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.271]                   {
[17:00:34.271]                     inherits <- base::inherits
[17:00:34.271]                     invokeRestart <- base::invokeRestart
[17:00:34.271]                     is.null <- base::is.null
[17:00:34.271]                     muffled <- FALSE
[17:00:34.271]                     if (inherits(cond, "message")) {
[17:00:34.271]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.271]                       if (muffled) 
[17:00:34.271]                         invokeRestart("muffleMessage")
[17:00:34.271]                     }
[17:00:34.271]                     else if (inherits(cond, "warning")) {
[17:00:34.271]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.271]                       if (muffled) 
[17:00:34.271]                         invokeRestart("muffleWarning")
[17:00:34.271]                     }
[17:00:34.271]                     else if (inherits(cond, "condition")) {
[17:00:34.271]                       if (!is.null(pattern)) {
[17:00:34.271]                         computeRestarts <- base::computeRestarts
[17:00:34.271]                         grepl <- base::grepl
[17:00:34.271]                         restarts <- computeRestarts(cond)
[17:00:34.271]                         for (restart in restarts) {
[17:00:34.271]                           name <- restart$name
[17:00:34.271]                           if (is.null(name)) 
[17:00:34.271]                             next
[17:00:34.271]                           if (!grepl(pattern, name)) 
[17:00:34.271]                             next
[17:00:34.271]                           invokeRestart(restart)
[17:00:34.271]                           muffled <- TRUE
[17:00:34.271]                           break
[17:00:34.271]                         }
[17:00:34.271]                       }
[17:00:34.271]                     }
[17:00:34.271]                     invisible(muffled)
[17:00:34.271]                   }
[17:00:34.271]                   muffleCondition(cond)
[17:00:34.271]                 })
[17:00:34.271]             }))
[17:00:34.271]             future::FutureResult(value = ...future.value$value, 
[17:00:34.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.271]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.271]                     ...future.globalenv.names))
[17:00:34.271]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.271]         }, condition = base::local({
[17:00:34.271]             c <- base::c
[17:00:34.271]             inherits <- base::inherits
[17:00:34.271]             invokeRestart <- base::invokeRestart
[17:00:34.271]             length <- base::length
[17:00:34.271]             list <- base::list
[17:00:34.271]             seq.int <- base::seq.int
[17:00:34.271]             signalCondition <- base::signalCondition
[17:00:34.271]             sys.calls <- base::sys.calls
[17:00:34.271]             `[[` <- base::`[[`
[17:00:34.271]             `+` <- base::`+`
[17:00:34.271]             `<<-` <- base::`<<-`
[17:00:34.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.271]                   3L)]
[17:00:34.271]             }
[17:00:34.271]             function(cond) {
[17:00:34.271]                 is_error <- inherits(cond, "error")
[17:00:34.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.271]                   NULL)
[17:00:34.271]                 if (is_error) {
[17:00:34.271]                   sessionInformation <- function() {
[17:00:34.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.271]                       search = base::search(), system = base::Sys.info())
[17:00:34.271]                   }
[17:00:34.271]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.271]                     cond$call), session = sessionInformation(), 
[17:00:34.271]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.271]                   signalCondition(cond)
[17:00:34.271]                 }
[17:00:34.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.271]                 "immediateCondition"))) {
[17:00:34.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.271]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.271]                   if (TRUE && !signal) {
[17:00:34.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.271]                     {
[17:00:34.271]                       inherits <- base::inherits
[17:00:34.271]                       invokeRestart <- base::invokeRestart
[17:00:34.271]                       is.null <- base::is.null
[17:00:34.271]                       muffled <- FALSE
[17:00:34.271]                       if (inherits(cond, "message")) {
[17:00:34.271]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.271]                         if (muffled) 
[17:00:34.271]                           invokeRestart("muffleMessage")
[17:00:34.271]                       }
[17:00:34.271]                       else if (inherits(cond, "warning")) {
[17:00:34.271]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.271]                         if (muffled) 
[17:00:34.271]                           invokeRestart("muffleWarning")
[17:00:34.271]                       }
[17:00:34.271]                       else if (inherits(cond, "condition")) {
[17:00:34.271]                         if (!is.null(pattern)) {
[17:00:34.271]                           computeRestarts <- base::computeRestarts
[17:00:34.271]                           grepl <- base::grepl
[17:00:34.271]                           restarts <- computeRestarts(cond)
[17:00:34.271]                           for (restart in restarts) {
[17:00:34.271]                             name <- restart$name
[17:00:34.271]                             if (is.null(name)) 
[17:00:34.271]                               next
[17:00:34.271]                             if (!grepl(pattern, name)) 
[17:00:34.271]                               next
[17:00:34.271]                             invokeRestart(restart)
[17:00:34.271]                             muffled <- TRUE
[17:00:34.271]                             break
[17:00:34.271]                           }
[17:00:34.271]                         }
[17:00:34.271]                       }
[17:00:34.271]                       invisible(muffled)
[17:00:34.271]                     }
[17:00:34.271]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.271]                   }
[17:00:34.271]                 }
[17:00:34.271]                 else {
[17:00:34.271]                   if (TRUE) {
[17:00:34.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.271]                     {
[17:00:34.271]                       inherits <- base::inherits
[17:00:34.271]                       invokeRestart <- base::invokeRestart
[17:00:34.271]                       is.null <- base::is.null
[17:00:34.271]                       muffled <- FALSE
[17:00:34.271]                       if (inherits(cond, "message")) {
[17:00:34.271]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.271]                         if (muffled) 
[17:00:34.271]                           invokeRestart("muffleMessage")
[17:00:34.271]                       }
[17:00:34.271]                       else if (inherits(cond, "warning")) {
[17:00:34.271]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.271]                         if (muffled) 
[17:00:34.271]                           invokeRestart("muffleWarning")
[17:00:34.271]                       }
[17:00:34.271]                       else if (inherits(cond, "condition")) {
[17:00:34.271]                         if (!is.null(pattern)) {
[17:00:34.271]                           computeRestarts <- base::computeRestarts
[17:00:34.271]                           grepl <- base::grepl
[17:00:34.271]                           restarts <- computeRestarts(cond)
[17:00:34.271]                           for (restart in restarts) {
[17:00:34.271]                             name <- restart$name
[17:00:34.271]                             if (is.null(name)) 
[17:00:34.271]                               next
[17:00:34.271]                             if (!grepl(pattern, name)) 
[17:00:34.271]                               next
[17:00:34.271]                             invokeRestart(restart)
[17:00:34.271]                             muffled <- TRUE
[17:00:34.271]                             break
[17:00:34.271]                           }
[17:00:34.271]                         }
[17:00:34.271]                       }
[17:00:34.271]                       invisible(muffled)
[17:00:34.271]                     }
[17:00:34.271]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.271]                   }
[17:00:34.271]                 }
[17:00:34.271]             }
[17:00:34.271]         }))
[17:00:34.271]     }, error = function(ex) {
[17:00:34.271]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.271]                 ...future.rng), started = ...future.startTime, 
[17:00:34.271]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.271]             version = "1.8"), class = "FutureResult")
[17:00:34.271]     }, finally = {
[17:00:34.271]         if (!identical(...future.workdir, getwd())) 
[17:00:34.271]             setwd(...future.workdir)
[17:00:34.271]         {
[17:00:34.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.271]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.271]             }
[17:00:34.271]             base::options(...future.oldOptions)
[17:00:34.271]             if (.Platform$OS.type == "windows") {
[17:00:34.271]                 old_names <- names(...future.oldEnvVars)
[17:00:34.271]                 envs <- base::Sys.getenv()
[17:00:34.271]                 names <- names(envs)
[17:00:34.271]                 common <- intersect(names, old_names)
[17:00:34.271]                 added <- setdiff(names, old_names)
[17:00:34.271]                 removed <- setdiff(old_names, names)
[17:00:34.271]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.271]                   envs[common]]
[17:00:34.271]                 NAMES <- toupper(changed)
[17:00:34.271]                 args <- list()
[17:00:34.271]                 for (kk in seq_along(NAMES)) {
[17:00:34.271]                   name <- changed[[kk]]
[17:00:34.271]                   NAME <- NAMES[[kk]]
[17:00:34.271]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.271]                     next
[17:00:34.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.271]                 }
[17:00:34.271]                 NAMES <- toupper(added)
[17:00:34.271]                 for (kk in seq_along(NAMES)) {
[17:00:34.271]                   name <- added[[kk]]
[17:00:34.271]                   NAME <- NAMES[[kk]]
[17:00:34.271]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.271]                     next
[17:00:34.271]                   args[[name]] <- ""
[17:00:34.271]                 }
[17:00:34.271]                 NAMES <- toupper(removed)
[17:00:34.271]                 for (kk in seq_along(NAMES)) {
[17:00:34.271]                   name <- removed[[kk]]
[17:00:34.271]                   NAME <- NAMES[[kk]]
[17:00:34.271]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.271]                     next
[17:00:34.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.271]                 }
[17:00:34.271]                 if (length(args) > 0) 
[17:00:34.271]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.271]             }
[17:00:34.271]             else {
[17:00:34.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.271]             }
[17:00:34.271]             {
[17:00:34.271]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.271]                   0L) {
[17:00:34.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.271]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.271]                   base::options(opts)
[17:00:34.271]                 }
[17:00:34.271]                 {
[17:00:34.271]                   {
[17:00:34.271]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.271]                     NULL
[17:00:34.271]                   }
[17:00:34.271]                   options(future.plan = NULL)
[17:00:34.271]                   if (is.na(NA_character_)) 
[17:00:34.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.271]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.271]                     .init = FALSE)
[17:00:34.271]                 }
[17:00:34.271]             }
[17:00:34.271]         }
[17:00:34.271]     })
[17:00:34.271]     if (TRUE) {
[17:00:34.271]         base::sink(type = "output", split = FALSE)
[17:00:34.271]         if (TRUE) {
[17:00:34.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.271]         }
[17:00:34.271]         else {
[17:00:34.271]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.271]         }
[17:00:34.271]         base::close(...future.stdout)
[17:00:34.271]         ...future.stdout <- NULL
[17:00:34.271]     }
[17:00:34.271]     ...future.result$conditions <- ...future.conditions
[17:00:34.271]     ...future.result$finished <- base::Sys.time()
[17:00:34.271]     ...future.result
[17:00:34.271] }
[17:00:34.274] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[17:00:34.274] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:00:34.274] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:00:34.275] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:34.275] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.275] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:00:34.275] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:00:34.275] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:34.276] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.276] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:34.276] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.276] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[17:00:34.277] MultisessionFuture started
[17:00:34.277] - Launch lazy future ... done
[17:00:34.277] run() for ‘MultisessionFuture’ ... done
[17:00:34.277] Created future:
[17:00:34.277] MultisessionFuture:
[17:00:34.277] Label: ‘future_mapply-1’
[17:00:34.277] Expression:
[17:00:34.277] {
[17:00:34.277]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.277]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.277]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.277]         on.exit(options(oopts), add = TRUE)
[17:00:34.277]     }
[17:00:34.277]     {
[17:00:34.277]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.277]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.277]         do.call(mapply, args = args)
[17:00:34.277]     }
[17:00:34.277] }
[17:00:34.277] Lazy evaluation: FALSE
[17:00:34.277] Asynchronous evaluation: TRUE
[17:00:34.277] Local evaluation: TRUE
[17:00:34.277] Environment: R_GlobalEnv
[17:00:34.277] Capture standard output: TRUE
[17:00:34.277] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.277] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.277] Packages: <none>
[17:00:34.277] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.277] Resolved: FALSE
[17:00:34.277] Value: <not collected>
[17:00:34.277] Conditions captured: <none>
[17:00:34.277] Early signaling: FALSE
[17:00:34.277] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.277] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.289] Chunk #1 of 1 ... DONE
[17:00:34.289] Launching 1 futures (chunks) ... DONE
[17:00:34.289] Resolving 1 futures (chunks) ...
[17:00:34.289] resolve() on list ...
[17:00:34.289]  recursive: 0
[17:00:34.289]  length: 1
[17:00:34.289] 
[17:00:34.331] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.331] - Validating connection of MultisessionFuture
[17:00:34.332] - received message: FutureResult
[17:00:34.332] - Received FutureResult
[17:00:34.332] - Erased future from FutureRegistry
[17:00:34.332] result() for ClusterFuture ...
[17:00:34.332] - result already collected: FutureResult
[17:00:34.332] result() for ClusterFuture ... done
[17:00:34.332] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.332] Future #1
[17:00:34.332] result() for ClusterFuture ...
[17:00:34.333] - result already collected: FutureResult
[17:00:34.333] result() for ClusterFuture ... done
[17:00:34.333] result() for ClusterFuture ...
[17:00:34.333] - result already collected: FutureResult
[17:00:34.333] result() for ClusterFuture ... done
[17:00:34.333] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:34.333] - nx: 1
[17:00:34.333] - relay: TRUE
[17:00:34.333] - stdout: TRUE
[17:00:34.333] - signal: TRUE
[17:00:34.333] - resignal: FALSE
[17:00:34.333] - force: TRUE
[17:00:34.334] - relayed: [n=1] FALSE
[17:00:34.334] - queued futures: [n=1] FALSE
[17:00:34.334]  - until=1
[17:00:34.334]  - relaying element #1
[17:00:34.334] result() for ClusterFuture ...
[17:00:34.334] - result already collected: FutureResult
[17:00:34.334] result() for ClusterFuture ... done
[17:00:34.334] result() for ClusterFuture ...
[17:00:34.334] - result already collected: FutureResult
[17:00:34.334] result() for ClusterFuture ... done
[17:00:34.334] result() for ClusterFuture ...
[17:00:34.335] - result already collected: FutureResult
[17:00:34.335] result() for ClusterFuture ... done
[17:00:34.335] result() for ClusterFuture ...
[17:00:34.335] - result already collected: FutureResult
[17:00:34.335] result() for ClusterFuture ... done
[17:00:34.335] - relayed: [n=1] TRUE
[17:00:34.335] - queued futures: [n=1] TRUE
[17:00:34.335] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:34.335]  length: 0 (resolved future 1)
[17:00:34.335] Relaying remaining futures
[17:00:34.335] signalConditionsASAP(NULL, pos=0) ...
[17:00:34.336] - nx: 1
[17:00:34.336] - relay: TRUE
[17:00:34.336] - stdout: TRUE
[17:00:34.336] - signal: TRUE
[17:00:34.336] - resignal: FALSE
[17:00:34.336] - force: TRUE
[17:00:34.336] - relayed: [n=1] TRUE
[17:00:34.336] - queued futures: [n=1] TRUE
 - flush all
[17:00:34.336] - relayed: [n=1] TRUE
[17:00:34.336] - queued futures: [n=1] TRUE
[17:00:34.337] signalConditionsASAP(NULL, pos=0) ... done
[17:00:34.337] resolve() on list ... DONE
[17:00:34.337] result() for ClusterFuture ...
[17:00:34.337] - result already collected: FutureResult
[17:00:34.337] result() for ClusterFuture ... done
[17:00:34.337] result() for ClusterFuture ...
[17:00:34.337] - result already collected: FutureResult
[17:00:34.337] result() for ClusterFuture ... done
[17:00:34.337]  - Number of value chunks collected: 1
[17:00:34.337] Resolving 1 futures (chunks) ... DONE
[17:00:34.337] Reducing values from 1 chunks ...
[17:00:34.338]  - Number of values collected after concatenation: 1
[17:00:34.338]  - Number of values expected: 1
[17:00:34.338] Reducing values from 1 chunks ... DONE
[17:00:34.338] future_mapply() ... DONE
[17:00:34.338] future_mapply() ...
[17:00:34.342] Number of chunks: 1
[17:00:34.342] getGlobalsAndPackagesXApply() ...
[17:00:34.342]  - future.globals: TRUE
[17:00:34.342] getGlobalsAndPackages() ...
[17:00:34.342] Searching for globals...
[17:00:34.343] - globals found: [1] ‘FUN’
[17:00:34.343] Searching for globals ... DONE
[17:00:34.343] Resolving globals: FALSE
[17:00:34.344] The total size of the 1 globals is 848 bytes (848 bytes)
[17:00:34.344] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:00:34.344] - globals: [1] ‘FUN’
[17:00:34.344] 
[17:00:34.344] getGlobalsAndPackages() ... DONE
[17:00:34.344]  - globals found/used: [n=1] ‘FUN’
[17:00:34.344]  - needed namespaces: [n=0] 
[17:00:34.345] Finding globals ... DONE
[17:00:34.345] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:34.345] List of 2
[17:00:34.345]  $ ...future.FUN:function (x)  
[17:00:34.345]  $ MoreArgs     : list()
[17:00:34.345]  - attr(*, "where")=List of 2
[17:00:34.345]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:34.345]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:34.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:34.345]  - attr(*, "resolved")= logi FALSE
[17:00:34.345]  - attr(*, "total_size")= num NA
[17:00:34.347] Packages to be attached in all futures: [n=0] 
[17:00:34.347] getGlobalsAndPackagesXApply() ... DONE
[17:00:34.348] Number of futures (= number of chunks): 1
[17:00:34.348] Launching 1 futures (chunks) ...
[17:00:34.348] Chunk #1 of 1 ...
[17:00:34.348]  - Finding globals in '...' for chunk #1 ...
[17:00:34.348] getGlobalsAndPackages() ...
[17:00:34.348] Searching for globals...
[17:00:34.348] 
[17:00:34.348] Searching for globals ... DONE
[17:00:34.349] - globals: [0] <none>
[17:00:34.349] getGlobalsAndPackages() ... DONE
[17:00:34.349]    + additional globals found: [n=0] 
[17:00:34.349]    + additional namespaces needed: [n=0] 
[17:00:34.349]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:34.349]  - seeds: <none>
[17:00:34.349]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.349] getGlobalsAndPackages() ...
[17:00:34.349] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.349] Resolving globals: FALSE
[17:00:34.350] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:00:34.350] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:00:34.350] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.350] 
[17:00:34.351] getGlobalsAndPackages() ... DONE
[17:00:34.351] run() for ‘Future’ ...
[17:00:34.351] - state: ‘created’
[17:00:34.351] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.365] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.365] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.365]   - Field: ‘node’
[17:00:34.366]   - Field: ‘label’
[17:00:34.366]   - Field: ‘local’
[17:00:34.366]   - Field: ‘owner’
[17:00:34.366]   - Field: ‘envir’
[17:00:34.366]   - Field: ‘workers’
[17:00:34.366]   - Field: ‘packages’
[17:00:34.366]   - Field: ‘gc’
[17:00:34.366]   - Field: ‘conditions’
[17:00:34.366]   - Field: ‘persistent’
[17:00:34.366]   - Field: ‘expr’
[17:00:34.366]   - Field: ‘uuid’
[17:00:34.367]   - Field: ‘seed’
[17:00:34.367]   - Field: ‘version’
[17:00:34.367]   - Field: ‘result’
[17:00:34.367]   - Field: ‘asynchronous’
[17:00:34.367]   - Field: ‘calls’
[17:00:34.367]   - Field: ‘globals’
[17:00:34.367]   - Field: ‘stdout’
[17:00:34.367]   - Field: ‘earlySignal’
[17:00:34.367]   - Field: ‘lazy’
[17:00:34.367]   - Field: ‘state’
[17:00:34.367] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.368] - Launch lazy future ...
[17:00:34.368] Packages needed by the future expression (n = 0): <none>
[17:00:34.368] Packages needed by future strategies (n = 0): <none>
[17:00:34.368] {
[17:00:34.368]     {
[17:00:34.368]         {
[17:00:34.368]             ...future.startTime <- base::Sys.time()
[17:00:34.368]             {
[17:00:34.368]                 {
[17:00:34.368]                   {
[17:00:34.368]                     {
[17:00:34.368]                       base::local({
[17:00:34.368]                         has_future <- base::requireNamespace("future", 
[17:00:34.368]                           quietly = TRUE)
[17:00:34.368]                         if (has_future) {
[17:00:34.368]                           ns <- base::getNamespace("future")
[17:00:34.368]                           version <- ns[[".package"]][["version"]]
[17:00:34.368]                           if (is.null(version)) 
[17:00:34.368]                             version <- utils::packageVersion("future")
[17:00:34.368]                         }
[17:00:34.368]                         else {
[17:00:34.368]                           version <- NULL
[17:00:34.368]                         }
[17:00:34.368]                         if (!has_future || version < "1.8.0") {
[17:00:34.368]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.368]                             "", base::R.version$version.string), 
[17:00:34.368]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.368]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.368]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.368]                               "release", "version")], collapse = " "), 
[17:00:34.368]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.368]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.368]                             info)
[17:00:34.368]                           info <- base::paste(info, collapse = "; ")
[17:00:34.368]                           if (!has_future) {
[17:00:34.368]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.368]                               info)
[17:00:34.368]                           }
[17:00:34.368]                           else {
[17:00:34.368]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.368]                               info, version)
[17:00:34.368]                           }
[17:00:34.368]                           base::stop(msg)
[17:00:34.368]                         }
[17:00:34.368]                       })
[17:00:34.368]                     }
[17:00:34.368]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.368]                     base::options(mc.cores = 1L)
[17:00:34.368]                   }
[17:00:34.368]                   ...future.strategy.old <- future::plan("list")
[17:00:34.368]                   options(future.plan = NULL)
[17:00:34.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.368]                 }
[17:00:34.368]                 ...future.workdir <- getwd()
[17:00:34.368]             }
[17:00:34.368]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.368]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.368]         }
[17:00:34.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.368]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:00:34.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.368]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.368]             base::names(...future.oldOptions))
[17:00:34.368]     }
[17:00:34.368]     if (FALSE) {
[17:00:34.368]     }
[17:00:34.368]     else {
[17:00:34.368]         if (TRUE) {
[17:00:34.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.368]                 open = "w")
[17:00:34.368]         }
[17:00:34.368]         else {
[17:00:34.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.368]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.368]         }
[17:00:34.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.368]             base::sink(type = "output", split = FALSE)
[17:00:34.368]             base::close(...future.stdout)
[17:00:34.368]         }, add = TRUE)
[17:00:34.368]     }
[17:00:34.368]     ...future.frame <- base::sys.nframe()
[17:00:34.368]     ...future.conditions <- base::list()
[17:00:34.368]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.368]     if (FALSE) {
[17:00:34.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.368]     }
[17:00:34.368]     ...future.result <- base::tryCatch({
[17:00:34.368]         base::withCallingHandlers({
[17:00:34.368]             ...future.value <- base::withVisible(base::local({
[17:00:34.368]                 ...future.makeSendCondition <- base::local({
[17:00:34.368]                   sendCondition <- NULL
[17:00:34.368]                   function(frame = 1L) {
[17:00:34.368]                     if (is.function(sendCondition)) 
[17:00:34.368]                       return(sendCondition)
[17:00:34.368]                     ns <- getNamespace("parallel")
[17:00:34.368]                     if (exists("sendData", mode = "function", 
[17:00:34.368]                       envir = ns)) {
[17:00:34.368]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.368]                         envir = ns)
[17:00:34.368]                       envir <- sys.frame(frame)
[17:00:34.368]                       master <- NULL
[17:00:34.368]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.368]                         !identical(envir, emptyenv())) {
[17:00:34.368]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.368]                           inherits = FALSE)) {
[17:00:34.368]                           master <- get("master", mode = "list", 
[17:00:34.368]                             envir = envir, inherits = FALSE)
[17:00:34.368]                           if (inherits(master, c("SOCKnode", 
[17:00:34.368]                             "SOCK0node"))) {
[17:00:34.368]                             sendCondition <<- function(cond) {
[17:00:34.368]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.368]                                 success = TRUE)
[17:00:34.368]                               parallel_sendData(master, data)
[17:00:34.368]                             }
[17:00:34.368]                             return(sendCondition)
[17:00:34.368]                           }
[17:00:34.368]                         }
[17:00:34.368]                         frame <- frame + 1L
[17:00:34.368]                         envir <- sys.frame(frame)
[17:00:34.368]                       }
[17:00:34.368]                     }
[17:00:34.368]                     sendCondition <<- function(cond) NULL
[17:00:34.368]                   }
[17:00:34.368]                 })
[17:00:34.368]                 withCallingHandlers({
[17:00:34.368]                   {
[17:00:34.368]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.368]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.368]                       ...future.globals.maxSize)) {
[17:00:34.368]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.368]                       on.exit(options(oopts), add = TRUE)
[17:00:34.368]                     }
[17:00:34.368]                     {
[17:00:34.368]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.368]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.368]                         USE.NAMES = FALSE)
[17:00:34.368]                       do.call(mapply, args = args)
[17:00:34.368]                     }
[17:00:34.368]                   }
[17:00:34.368]                 }, immediateCondition = function(cond) {
[17:00:34.368]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.368]                   sendCondition(cond)
[17:00:34.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.368]                   {
[17:00:34.368]                     inherits <- base::inherits
[17:00:34.368]                     invokeRestart <- base::invokeRestart
[17:00:34.368]                     is.null <- base::is.null
[17:00:34.368]                     muffled <- FALSE
[17:00:34.368]                     if (inherits(cond, "message")) {
[17:00:34.368]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.368]                       if (muffled) 
[17:00:34.368]                         invokeRestart("muffleMessage")
[17:00:34.368]                     }
[17:00:34.368]                     else if (inherits(cond, "warning")) {
[17:00:34.368]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.368]                       if (muffled) 
[17:00:34.368]                         invokeRestart("muffleWarning")
[17:00:34.368]                     }
[17:00:34.368]                     else if (inherits(cond, "condition")) {
[17:00:34.368]                       if (!is.null(pattern)) {
[17:00:34.368]                         computeRestarts <- base::computeRestarts
[17:00:34.368]                         grepl <- base::grepl
[17:00:34.368]                         restarts <- computeRestarts(cond)
[17:00:34.368]                         for (restart in restarts) {
[17:00:34.368]                           name <- restart$name
[17:00:34.368]                           if (is.null(name)) 
[17:00:34.368]                             next
[17:00:34.368]                           if (!grepl(pattern, name)) 
[17:00:34.368]                             next
[17:00:34.368]                           invokeRestart(restart)
[17:00:34.368]                           muffled <- TRUE
[17:00:34.368]                           break
[17:00:34.368]                         }
[17:00:34.368]                       }
[17:00:34.368]                     }
[17:00:34.368]                     invisible(muffled)
[17:00:34.368]                   }
[17:00:34.368]                   muffleCondition(cond)
[17:00:34.368]                 })
[17:00:34.368]             }))
[17:00:34.368]             future::FutureResult(value = ...future.value$value, 
[17:00:34.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.368]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.368]                     ...future.globalenv.names))
[17:00:34.368]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.368]         }, condition = base::local({
[17:00:34.368]             c <- base::c
[17:00:34.368]             inherits <- base::inherits
[17:00:34.368]             invokeRestart <- base::invokeRestart
[17:00:34.368]             length <- base::length
[17:00:34.368]             list <- base::list
[17:00:34.368]             seq.int <- base::seq.int
[17:00:34.368]             signalCondition <- base::signalCondition
[17:00:34.368]             sys.calls <- base::sys.calls
[17:00:34.368]             `[[` <- base::`[[`
[17:00:34.368]             `+` <- base::`+`
[17:00:34.368]             `<<-` <- base::`<<-`
[17:00:34.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.368]                   3L)]
[17:00:34.368]             }
[17:00:34.368]             function(cond) {
[17:00:34.368]                 is_error <- inherits(cond, "error")
[17:00:34.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.368]                   NULL)
[17:00:34.368]                 if (is_error) {
[17:00:34.368]                   sessionInformation <- function() {
[17:00:34.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.368]                       search = base::search(), system = base::Sys.info())
[17:00:34.368]                   }
[17:00:34.368]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.368]                     cond$call), session = sessionInformation(), 
[17:00:34.368]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.368]                   signalCondition(cond)
[17:00:34.368]                 }
[17:00:34.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.368]                 "immediateCondition"))) {
[17:00:34.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.368]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.368]                   if (TRUE && !signal) {
[17:00:34.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.368]                     {
[17:00:34.368]                       inherits <- base::inherits
[17:00:34.368]                       invokeRestart <- base::invokeRestart
[17:00:34.368]                       is.null <- base::is.null
[17:00:34.368]                       muffled <- FALSE
[17:00:34.368]                       if (inherits(cond, "message")) {
[17:00:34.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.368]                         if (muffled) 
[17:00:34.368]                           invokeRestart("muffleMessage")
[17:00:34.368]                       }
[17:00:34.368]                       else if (inherits(cond, "warning")) {
[17:00:34.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.368]                         if (muffled) 
[17:00:34.368]                           invokeRestart("muffleWarning")
[17:00:34.368]                       }
[17:00:34.368]                       else if (inherits(cond, "condition")) {
[17:00:34.368]                         if (!is.null(pattern)) {
[17:00:34.368]                           computeRestarts <- base::computeRestarts
[17:00:34.368]                           grepl <- base::grepl
[17:00:34.368]                           restarts <- computeRestarts(cond)
[17:00:34.368]                           for (restart in restarts) {
[17:00:34.368]                             name <- restart$name
[17:00:34.368]                             if (is.null(name)) 
[17:00:34.368]                               next
[17:00:34.368]                             if (!grepl(pattern, name)) 
[17:00:34.368]                               next
[17:00:34.368]                             invokeRestart(restart)
[17:00:34.368]                             muffled <- TRUE
[17:00:34.368]                             break
[17:00:34.368]                           }
[17:00:34.368]                         }
[17:00:34.368]                       }
[17:00:34.368]                       invisible(muffled)
[17:00:34.368]                     }
[17:00:34.368]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.368]                   }
[17:00:34.368]                 }
[17:00:34.368]                 else {
[17:00:34.368]                   if (TRUE) {
[17:00:34.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.368]                     {
[17:00:34.368]                       inherits <- base::inherits
[17:00:34.368]                       invokeRestart <- base::invokeRestart
[17:00:34.368]                       is.null <- base::is.null
[17:00:34.368]                       muffled <- FALSE
[17:00:34.368]                       if (inherits(cond, "message")) {
[17:00:34.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.368]                         if (muffled) 
[17:00:34.368]                           invokeRestart("muffleMessage")
[17:00:34.368]                       }
[17:00:34.368]                       else if (inherits(cond, "warning")) {
[17:00:34.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.368]                         if (muffled) 
[17:00:34.368]                           invokeRestart("muffleWarning")
[17:00:34.368]                       }
[17:00:34.368]                       else if (inherits(cond, "condition")) {
[17:00:34.368]                         if (!is.null(pattern)) {
[17:00:34.368]                           computeRestarts <- base::computeRestarts
[17:00:34.368]                           grepl <- base::grepl
[17:00:34.368]                           restarts <- computeRestarts(cond)
[17:00:34.368]                           for (restart in restarts) {
[17:00:34.368]                             name <- restart$name
[17:00:34.368]                             if (is.null(name)) 
[17:00:34.368]                               next
[17:00:34.368]                             if (!grepl(pattern, name)) 
[17:00:34.368]                               next
[17:00:34.368]                             invokeRestart(restart)
[17:00:34.368]                             muffled <- TRUE
[17:00:34.368]                             break
[17:00:34.368]                           }
[17:00:34.368]                         }
[17:00:34.368]                       }
[17:00:34.368]                       invisible(muffled)
[17:00:34.368]                     }
[17:00:34.368]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.368]                   }
[17:00:34.368]                 }
[17:00:34.368]             }
[17:00:34.368]         }))
[17:00:34.368]     }, error = function(ex) {
[17:00:34.368]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.368]                 ...future.rng), started = ...future.startTime, 
[17:00:34.368]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.368]             version = "1.8"), class = "FutureResult")
[17:00:34.368]     }, finally = {
[17:00:34.368]         if (!identical(...future.workdir, getwd())) 
[17:00:34.368]             setwd(...future.workdir)
[17:00:34.368]         {
[17:00:34.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.368]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.368]             }
[17:00:34.368]             base::options(...future.oldOptions)
[17:00:34.368]             if (.Platform$OS.type == "windows") {
[17:00:34.368]                 old_names <- names(...future.oldEnvVars)
[17:00:34.368]                 envs <- base::Sys.getenv()
[17:00:34.368]                 names <- names(envs)
[17:00:34.368]                 common <- intersect(names, old_names)
[17:00:34.368]                 added <- setdiff(names, old_names)
[17:00:34.368]                 removed <- setdiff(old_names, names)
[17:00:34.368]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.368]                   envs[common]]
[17:00:34.368]                 NAMES <- toupper(changed)
[17:00:34.368]                 args <- list()
[17:00:34.368]                 for (kk in seq_along(NAMES)) {
[17:00:34.368]                   name <- changed[[kk]]
[17:00:34.368]                   NAME <- NAMES[[kk]]
[17:00:34.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.368]                     next
[17:00:34.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.368]                 }
[17:00:34.368]                 NAMES <- toupper(added)
[17:00:34.368]                 for (kk in seq_along(NAMES)) {
[17:00:34.368]                   name <- added[[kk]]
[17:00:34.368]                   NAME <- NAMES[[kk]]
[17:00:34.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.368]                     next
[17:00:34.368]                   args[[name]] <- ""
[17:00:34.368]                 }
[17:00:34.368]                 NAMES <- toupper(removed)
[17:00:34.368]                 for (kk in seq_along(NAMES)) {
[17:00:34.368]                   name <- removed[[kk]]
[17:00:34.368]                   NAME <- NAMES[[kk]]
[17:00:34.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.368]                     next
[17:00:34.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.368]                 }
[17:00:34.368]                 if (length(args) > 0) 
[17:00:34.368]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.368]             }
[17:00:34.368]             else {
[17:00:34.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.368]             }
[17:00:34.368]             {
[17:00:34.368]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.368]                   0L) {
[17:00:34.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.368]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.368]                   base::options(opts)
[17:00:34.368]                 }
[17:00:34.368]                 {
[17:00:34.368]                   {
[17:00:34.368]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.368]                     NULL
[17:00:34.368]                   }
[17:00:34.368]                   options(future.plan = NULL)
[17:00:34.368]                   if (is.na(NA_character_)) 
[17:00:34.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.368]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.368]                     .init = FALSE)
[17:00:34.368]                 }
[17:00:34.368]             }
[17:00:34.368]         }
[17:00:34.368]     })
[17:00:34.368]     if (TRUE) {
[17:00:34.368]         base::sink(type = "output", split = FALSE)
[17:00:34.368]         if (TRUE) {
[17:00:34.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.368]         }
[17:00:34.368]         else {
[17:00:34.368]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.368]         }
[17:00:34.368]         base::close(...future.stdout)
[17:00:34.368]         ...future.stdout <- NULL
[17:00:34.368]     }
[17:00:34.368]     ...future.result$conditions <- ...future.conditions
[17:00:34.368]     ...future.result$finished <- base::Sys.time()
[17:00:34.368]     ...future.result
[17:00:34.368] }
[17:00:34.371] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[17:00:34.371] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:00:34.372] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:00:34.372] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:34.372] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.372] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:00:34.373] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:00:34.373] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:34.373] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.373] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:34.373] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.374] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[17:00:34.374] MultisessionFuture started
[17:00:34.374] - Launch lazy future ... done
[17:00:34.374] run() for ‘MultisessionFuture’ ... done
[17:00:34.374] Created future:
[17:00:34.374] MultisessionFuture:
[17:00:34.374] Label: ‘future_.mapply-1’
[17:00:34.374] Expression:
[17:00:34.374] {
[17:00:34.374]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.374]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.374]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.374]         on.exit(options(oopts), add = TRUE)
[17:00:34.374]     }
[17:00:34.374]     {
[17:00:34.374]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.374]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.374]         do.call(mapply, args = args)
[17:00:34.374]     }
[17:00:34.374] }
[17:00:34.374] Lazy evaluation: FALSE
[17:00:34.374] Asynchronous evaluation: TRUE
[17:00:34.374] Local evaluation: TRUE
[17:00:34.374] Environment: R_GlobalEnv
[17:00:34.374] Capture standard output: TRUE
[17:00:34.374] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.374] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.374] Packages: <none>
[17:00:34.374] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.374] Resolved: FALSE
[17:00:34.374] Value: <not collected>
[17:00:34.374] Conditions captured: <none>
[17:00:34.374] Early signaling: FALSE
[17:00:34.374] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.374] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.386] Chunk #1 of 1 ... DONE
[17:00:34.386] Launching 1 futures (chunks) ... DONE
[17:00:34.386] Resolving 1 futures (chunks) ...
[17:00:34.386] resolve() on list ...
[17:00:34.386]  recursive: 0
[17:00:34.387]  length: 1
[17:00:34.387] 
[17:00:34.417] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.417] - Validating connection of MultisessionFuture
[17:00:34.417] - received message: FutureResult
[17:00:34.417] - Received FutureResult
[17:00:34.418] - Erased future from FutureRegistry
[17:00:34.418] result() for ClusterFuture ...
[17:00:34.418] - result already collected: FutureResult
[17:00:34.418] result() for ClusterFuture ... done
[17:00:34.418] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.418] Future #1
[17:00:34.418] result() for ClusterFuture ...
[17:00:34.418] - result already collected: FutureResult
[17:00:34.418] result() for ClusterFuture ... done
[17:00:34.419] result() for ClusterFuture ...
[17:00:34.419] - result already collected: FutureResult
[17:00:34.419] result() for ClusterFuture ... done
[17:00:34.419] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:34.419] - nx: 1
[17:00:34.419] - relay: TRUE
[17:00:34.419] - stdout: TRUE
[17:00:34.419] - signal: TRUE
[17:00:34.419] - resignal: FALSE
[17:00:34.419] - force: TRUE
[17:00:34.419] - relayed: [n=1] FALSE
[17:00:34.419] - queued futures: [n=1] FALSE
[17:00:34.420]  - until=1
[17:00:34.420]  - relaying element #1
[17:00:34.420] result() for ClusterFuture ...
[17:00:34.420] - result already collected: FutureResult
[17:00:34.420] result() for ClusterFuture ... done
[17:00:34.420] result() for ClusterFuture ...
[17:00:34.420] - result already collected: FutureResult
[17:00:34.420] result() for ClusterFuture ... done
[17:00:34.420] result() for ClusterFuture ...
[17:00:34.420] - result already collected: FutureResult
[17:00:34.420] result() for ClusterFuture ... done
[17:00:34.421] result() for ClusterFuture ...
[17:00:34.421] - result already collected: FutureResult
[17:00:34.421] result() for ClusterFuture ... done
[17:00:34.421] - relayed: [n=1] TRUE
[17:00:34.421] - queued futures: [n=1] TRUE
[17:00:34.421] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:34.421]  length: 0 (resolved future 1)
[17:00:34.421] Relaying remaining futures
[17:00:34.421] signalConditionsASAP(NULL, pos=0) ...
[17:00:34.421] - nx: 1
[17:00:34.421] - relay: TRUE
[17:00:34.422] - stdout: TRUE
[17:00:34.422] - signal: TRUE
[17:00:34.422] - resignal: FALSE
[17:00:34.422] - force: TRUE
[17:00:34.422] - relayed: [n=1] TRUE
[17:00:34.422] - queued futures: [n=1] TRUE
 - flush all
[17:00:34.422] - relayed: [n=1] TRUE
[17:00:34.422] - queued futures: [n=1] TRUE
[17:00:34.422] signalConditionsASAP(NULL, pos=0) ... done
[17:00:34.422] resolve() on list ... DONE
[17:00:34.422] result() for ClusterFuture ...
[17:00:34.422] - result already collected: FutureResult
[17:00:34.423] result() for ClusterFuture ... done
[17:00:34.423] result() for ClusterFuture ...
[17:00:34.423] - result already collected: FutureResult
[17:00:34.423] result() for ClusterFuture ... done
[17:00:34.423]  - Number of value chunks collected: 1
[17:00:34.423] Resolving 1 futures (chunks) ... DONE
[17:00:34.426] Reducing values from 1 chunks ...
[17:00:34.426]  - Number of values collected after concatenation: 1
[17:00:34.426]  - Number of values expected: 1
[17:00:34.426] Reducing values from 1 chunks ... DONE
[17:00:34.426] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[17:00:34.426] future_mapply() ...
[17:00:34.430] Number of chunks: 2
[17:00:34.430] getGlobalsAndPackagesXApply() ...
[17:00:34.430]  - future.globals: TRUE
[17:00:34.430] getGlobalsAndPackages() ...
[17:00:34.431] Searching for globals...
[17:00:34.432] - globals found: [1] ‘FUN’
[17:00:34.432] Searching for globals ... DONE
[17:00:34.432] Resolving globals: FALSE
[17:00:34.432] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:00:34.432] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:00:34.433] - globals: [1] ‘FUN’
[17:00:34.433] 
[17:00:34.433] getGlobalsAndPackages() ... DONE
[17:00:34.433]  - globals found/used: [n=1] ‘FUN’
[17:00:34.433]  - needed namespaces: [n=0] 
[17:00:34.433] Finding globals ... DONE
[17:00:34.433] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:34.433] List of 2
[17:00:34.433]  $ ...future.FUN:function (x, y)  
[17:00:34.433]  $ MoreArgs     :List of 1
[17:00:34.433]   ..$ y: int [1:2] 3 4
[17:00:34.433]  - attr(*, "where")=List of 2
[17:00:34.433]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:34.433]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:34.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:34.433]  - attr(*, "resolved")= logi FALSE
[17:00:34.433]  - attr(*, "total_size")= num NA
[17:00:34.436] Packages to be attached in all futures: [n=0] 
[17:00:34.436] getGlobalsAndPackagesXApply() ... DONE
[17:00:34.437] Number of futures (= number of chunks): 2
[17:00:34.437] Launching 2 futures (chunks) ...
[17:00:34.437] Chunk #1 of 2 ...
[17:00:34.437]  - Finding globals in '...' for chunk #1 ...
[17:00:34.437] getGlobalsAndPackages() ...
[17:00:34.437] Searching for globals...
[17:00:34.437] 
[17:00:34.437] Searching for globals ... DONE
[17:00:34.438] - globals: [0] <none>
[17:00:34.438] getGlobalsAndPackages() ... DONE
[17:00:34.438]    + additional globals found: [n=0] 
[17:00:34.438]    + additional namespaces needed: [n=0] 
[17:00:34.438]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:34.438]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.438]  - seeds: <none>
[17:00:34.438]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.438] getGlobalsAndPackages() ...
[17:00:34.438] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.438] Resolving globals: FALSE
[17:00:34.439] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:00:34.439] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:00:34.439] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.440] 
[17:00:34.440] getGlobalsAndPackages() ... DONE
[17:00:34.440] run() for ‘Future’ ...
[17:00:34.440] - state: ‘created’
[17:00:34.440] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.455] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.456]   - Field: ‘node’
[17:00:34.456]   - Field: ‘label’
[17:00:34.456]   - Field: ‘local’
[17:00:34.456]   - Field: ‘owner’
[17:00:34.456]   - Field: ‘envir’
[17:00:34.456]   - Field: ‘workers’
[17:00:34.456]   - Field: ‘packages’
[17:00:34.456]   - Field: ‘gc’
[17:00:34.456]   - Field: ‘conditions’
[17:00:34.457]   - Field: ‘persistent’
[17:00:34.457]   - Field: ‘expr’
[17:00:34.457]   - Field: ‘uuid’
[17:00:34.457]   - Field: ‘seed’
[17:00:34.457]   - Field: ‘version’
[17:00:34.457]   - Field: ‘result’
[17:00:34.457]   - Field: ‘asynchronous’
[17:00:34.457]   - Field: ‘calls’
[17:00:34.457]   - Field: ‘globals’
[17:00:34.457]   - Field: ‘stdout’
[17:00:34.457]   - Field: ‘earlySignal’
[17:00:34.458]   - Field: ‘lazy’
[17:00:34.458]   - Field: ‘state’
[17:00:34.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.458] - Launch lazy future ...
[17:00:34.458] Packages needed by the future expression (n = 0): <none>
[17:00:34.458] Packages needed by future strategies (n = 0): <none>
[17:00:34.459] {
[17:00:34.459]     {
[17:00:34.459]         {
[17:00:34.459]             ...future.startTime <- base::Sys.time()
[17:00:34.459]             {
[17:00:34.459]                 {
[17:00:34.459]                   {
[17:00:34.459]                     {
[17:00:34.459]                       base::local({
[17:00:34.459]                         has_future <- base::requireNamespace("future", 
[17:00:34.459]                           quietly = TRUE)
[17:00:34.459]                         if (has_future) {
[17:00:34.459]                           ns <- base::getNamespace("future")
[17:00:34.459]                           version <- ns[[".package"]][["version"]]
[17:00:34.459]                           if (is.null(version)) 
[17:00:34.459]                             version <- utils::packageVersion("future")
[17:00:34.459]                         }
[17:00:34.459]                         else {
[17:00:34.459]                           version <- NULL
[17:00:34.459]                         }
[17:00:34.459]                         if (!has_future || version < "1.8.0") {
[17:00:34.459]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.459]                             "", base::R.version$version.string), 
[17:00:34.459]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.459]                               "release", "version")], collapse = " "), 
[17:00:34.459]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.459]                             info)
[17:00:34.459]                           info <- base::paste(info, collapse = "; ")
[17:00:34.459]                           if (!has_future) {
[17:00:34.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.459]                               info)
[17:00:34.459]                           }
[17:00:34.459]                           else {
[17:00:34.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.459]                               info, version)
[17:00:34.459]                           }
[17:00:34.459]                           base::stop(msg)
[17:00:34.459]                         }
[17:00:34.459]                       })
[17:00:34.459]                     }
[17:00:34.459]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.459]                     base::options(mc.cores = 1L)
[17:00:34.459]                   }
[17:00:34.459]                   ...future.strategy.old <- future::plan("list")
[17:00:34.459]                   options(future.plan = NULL)
[17:00:34.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.459]                 }
[17:00:34.459]                 ...future.workdir <- getwd()
[17:00:34.459]             }
[17:00:34.459]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.459]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.459]         }
[17:00:34.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.459]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.459]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.459]             base::names(...future.oldOptions))
[17:00:34.459]     }
[17:00:34.459]     if (FALSE) {
[17:00:34.459]     }
[17:00:34.459]     else {
[17:00:34.459]         if (TRUE) {
[17:00:34.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.459]                 open = "w")
[17:00:34.459]         }
[17:00:34.459]         else {
[17:00:34.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.459]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.459]         }
[17:00:34.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.459]             base::sink(type = "output", split = FALSE)
[17:00:34.459]             base::close(...future.stdout)
[17:00:34.459]         }, add = TRUE)
[17:00:34.459]     }
[17:00:34.459]     ...future.frame <- base::sys.nframe()
[17:00:34.459]     ...future.conditions <- base::list()
[17:00:34.459]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.459]     if (FALSE) {
[17:00:34.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.459]     }
[17:00:34.459]     ...future.result <- base::tryCatch({
[17:00:34.459]         base::withCallingHandlers({
[17:00:34.459]             ...future.value <- base::withVisible(base::local({
[17:00:34.459]                 ...future.makeSendCondition <- base::local({
[17:00:34.459]                   sendCondition <- NULL
[17:00:34.459]                   function(frame = 1L) {
[17:00:34.459]                     if (is.function(sendCondition)) 
[17:00:34.459]                       return(sendCondition)
[17:00:34.459]                     ns <- getNamespace("parallel")
[17:00:34.459]                     if (exists("sendData", mode = "function", 
[17:00:34.459]                       envir = ns)) {
[17:00:34.459]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.459]                         envir = ns)
[17:00:34.459]                       envir <- sys.frame(frame)
[17:00:34.459]                       master <- NULL
[17:00:34.459]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.459]                         !identical(envir, emptyenv())) {
[17:00:34.459]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.459]                           inherits = FALSE)) {
[17:00:34.459]                           master <- get("master", mode = "list", 
[17:00:34.459]                             envir = envir, inherits = FALSE)
[17:00:34.459]                           if (inherits(master, c("SOCKnode", 
[17:00:34.459]                             "SOCK0node"))) {
[17:00:34.459]                             sendCondition <<- function(cond) {
[17:00:34.459]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.459]                                 success = TRUE)
[17:00:34.459]                               parallel_sendData(master, data)
[17:00:34.459]                             }
[17:00:34.459]                             return(sendCondition)
[17:00:34.459]                           }
[17:00:34.459]                         }
[17:00:34.459]                         frame <- frame + 1L
[17:00:34.459]                         envir <- sys.frame(frame)
[17:00:34.459]                       }
[17:00:34.459]                     }
[17:00:34.459]                     sendCondition <<- function(cond) NULL
[17:00:34.459]                   }
[17:00:34.459]                 })
[17:00:34.459]                 withCallingHandlers({
[17:00:34.459]                   {
[17:00:34.459]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.459]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.459]                       ...future.globals.maxSize)) {
[17:00:34.459]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.459]                       on.exit(options(oopts), add = TRUE)
[17:00:34.459]                     }
[17:00:34.459]                     {
[17:00:34.459]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.459]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.459]                         USE.NAMES = FALSE)
[17:00:34.459]                       do.call(mapply, args = args)
[17:00:34.459]                     }
[17:00:34.459]                   }
[17:00:34.459]                 }, immediateCondition = function(cond) {
[17:00:34.459]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.459]                   sendCondition(cond)
[17:00:34.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.459]                   {
[17:00:34.459]                     inherits <- base::inherits
[17:00:34.459]                     invokeRestart <- base::invokeRestart
[17:00:34.459]                     is.null <- base::is.null
[17:00:34.459]                     muffled <- FALSE
[17:00:34.459]                     if (inherits(cond, "message")) {
[17:00:34.459]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.459]                       if (muffled) 
[17:00:34.459]                         invokeRestart("muffleMessage")
[17:00:34.459]                     }
[17:00:34.459]                     else if (inherits(cond, "warning")) {
[17:00:34.459]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.459]                       if (muffled) 
[17:00:34.459]                         invokeRestart("muffleWarning")
[17:00:34.459]                     }
[17:00:34.459]                     else if (inherits(cond, "condition")) {
[17:00:34.459]                       if (!is.null(pattern)) {
[17:00:34.459]                         computeRestarts <- base::computeRestarts
[17:00:34.459]                         grepl <- base::grepl
[17:00:34.459]                         restarts <- computeRestarts(cond)
[17:00:34.459]                         for (restart in restarts) {
[17:00:34.459]                           name <- restart$name
[17:00:34.459]                           if (is.null(name)) 
[17:00:34.459]                             next
[17:00:34.459]                           if (!grepl(pattern, name)) 
[17:00:34.459]                             next
[17:00:34.459]                           invokeRestart(restart)
[17:00:34.459]                           muffled <- TRUE
[17:00:34.459]                           break
[17:00:34.459]                         }
[17:00:34.459]                       }
[17:00:34.459]                     }
[17:00:34.459]                     invisible(muffled)
[17:00:34.459]                   }
[17:00:34.459]                   muffleCondition(cond)
[17:00:34.459]                 })
[17:00:34.459]             }))
[17:00:34.459]             future::FutureResult(value = ...future.value$value, 
[17:00:34.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.459]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.459]                     ...future.globalenv.names))
[17:00:34.459]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.459]         }, condition = base::local({
[17:00:34.459]             c <- base::c
[17:00:34.459]             inherits <- base::inherits
[17:00:34.459]             invokeRestart <- base::invokeRestart
[17:00:34.459]             length <- base::length
[17:00:34.459]             list <- base::list
[17:00:34.459]             seq.int <- base::seq.int
[17:00:34.459]             signalCondition <- base::signalCondition
[17:00:34.459]             sys.calls <- base::sys.calls
[17:00:34.459]             `[[` <- base::`[[`
[17:00:34.459]             `+` <- base::`+`
[17:00:34.459]             `<<-` <- base::`<<-`
[17:00:34.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.459]                   3L)]
[17:00:34.459]             }
[17:00:34.459]             function(cond) {
[17:00:34.459]                 is_error <- inherits(cond, "error")
[17:00:34.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.459]                   NULL)
[17:00:34.459]                 if (is_error) {
[17:00:34.459]                   sessionInformation <- function() {
[17:00:34.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.459]                       search = base::search(), system = base::Sys.info())
[17:00:34.459]                   }
[17:00:34.459]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.459]                     cond$call), session = sessionInformation(), 
[17:00:34.459]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.459]                   signalCondition(cond)
[17:00:34.459]                 }
[17:00:34.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.459]                 "immediateCondition"))) {
[17:00:34.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.459]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.459]                   if (TRUE && !signal) {
[17:00:34.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.459]                     {
[17:00:34.459]                       inherits <- base::inherits
[17:00:34.459]                       invokeRestart <- base::invokeRestart
[17:00:34.459]                       is.null <- base::is.null
[17:00:34.459]                       muffled <- FALSE
[17:00:34.459]                       if (inherits(cond, "message")) {
[17:00:34.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.459]                         if (muffled) 
[17:00:34.459]                           invokeRestart("muffleMessage")
[17:00:34.459]                       }
[17:00:34.459]                       else if (inherits(cond, "warning")) {
[17:00:34.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.459]                         if (muffled) 
[17:00:34.459]                           invokeRestart("muffleWarning")
[17:00:34.459]                       }
[17:00:34.459]                       else if (inherits(cond, "condition")) {
[17:00:34.459]                         if (!is.null(pattern)) {
[17:00:34.459]                           computeRestarts <- base::computeRestarts
[17:00:34.459]                           grepl <- base::grepl
[17:00:34.459]                           restarts <- computeRestarts(cond)
[17:00:34.459]                           for (restart in restarts) {
[17:00:34.459]                             name <- restart$name
[17:00:34.459]                             if (is.null(name)) 
[17:00:34.459]                               next
[17:00:34.459]                             if (!grepl(pattern, name)) 
[17:00:34.459]                               next
[17:00:34.459]                             invokeRestart(restart)
[17:00:34.459]                             muffled <- TRUE
[17:00:34.459]                             break
[17:00:34.459]                           }
[17:00:34.459]                         }
[17:00:34.459]                       }
[17:00:34.459]                       invisible(muffled)
[17:00:34.459]                     }
[17:00:34.459]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.459]                   }
[17:00:34.459]                 }
[17:00:34.459]                 else {
[17:00:34.459]                   if (TRUE) {
[17:00:34.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.459]                     {
[17:00:34.459]                       inherits <- base::inherits
[17:00:34.459]                       invokeRestart <- base::invokeRestart
[17:00:34.459]                       is.null <- base::is.null
[17:00:34.459]                       muffled <- FALSE
[17:00:34.459]                       if (inherits(cond, "message")) {
[17:00:34.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.459]                         if (muffled) 
[17:00:34.459]                           invokeRestart("muffleMessage")
[17:00:34.459]                       }
[17:00:34.459]                       else if (inherits(cond, "warning")) {
[17:00:34.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.459]                         if (muffled) 
[17:00:34.459]                           invokeRestart("muffleWarning")
[17:00:34.459]                       }
[17:00:34.459]                       else if (inherits(cond, "condition")) {
[17:00:34.459]                         if (!is.null(pattern)) {
[17:00:34.459]                           computeRestarts <- base::computeRestarts
[17:00:34.459]                           grepl <- base::grepl
[17:00:34.459]                           restarts <- computeRestarts(cond)
[17:00:34.459]                           for (restart in restarts) {
[17:00:34.459]                             name <- restart$name
[17:00:34.459]                             if (is.null(name)) 
[17:00:34.459]                               next
[17:00:34.459]                             if (!grepl(pattern, name)) 
[17:00:34.459]                               next
[17:00:34.459]                             invokeRestart(restart)
[17:00:34.459]                             muffled <- TRUE
[17:00:34.459]                             break
[17:00:34.459]                           }
[17:00:34.459]                         }
[17:00:34.459]                       }
[17:00:34.459]                       invisible(muffled)
[17:00:34.459]                     }
[17:00:34.459]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.459]                   }
[17:00:34.459]                 }
[17:00:34.459]             }
[17:00:34.459]         }))
[17:00:34.459]     }, error = function(ex) {
[17:00:34.459]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.459]                 ...future.rng), started = ...future.startTime, 
[17:00:34.459]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.459]             version = "1.8"), class = "FutureResult")
[17:00:34.459]     }, finally = {
[17:00:34.459]         if (!identical(...future.workdir, getwd())) 
[17:00:34.459]             setwd(...future.workdir)
[17:00:34.459]         {
[17:00:34.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.459]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.459]             }
[17:00:34.459]             base::options(...future.oldOptions)
[17:00:34.459]             if (.Platform$OS.type == "windows") {
[17:00:34.459]                 old_names <- names(...future.oldEnvVars)
[17:00:34.459]                 envs <- base::Sys.getenv()
[17:00:34.459]                 names <- names(envs)
[17:00:34.459]                 common <- intersect(names, old_names)
[17:00:34.459]                 added <- setdiff(names, old_names)
[17:00:34.459]                 removed <- setdiff(old_names, names)
[17:00:34.459]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.459]                   envs[common]]
[17:00:34.459]                 NAMES <- toupper(changed)
[17:00:34.459]                 args <- list()
[17:00:34.459]                 for (kk in seq_along(NAMES)) {
[17:00:34.459]                   name <- changed[[kk]]
[17:00:34.459]                   NAME <- NAMES[[kk]]
[17:00:34.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.459]                     next
[17:00:34.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.459]                 }
[17:00:34.459]                 NAMES <- toupper(added)
[17:00:34.459]                 for (kk in seq_along(NAMES)) {
[17:00:34.459]                   name <- added[[kk]]
[17:00:34.459]                   NAME <- NAMES[[kk]]
[17:00:34.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.459]                     next
[17:00:34.459]                   args[[name]] <- ""
[17:00:34.459]                 }
[17:00:34.459]                 NAMES <- toupper(removed)
[17:00:34.459]                 for (kk in seq_along(NAMES)) {
[17:00:34.459]                   name <- removed[[kk]]
[17:00:34.459]                   NAME <- NAMES[[kk]]
[17:00:34.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.459]                     next
[17:00:34.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.459]                 }
[17:00:34.459]                 if (length(args) > 0) 
[17:00:34.459]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.459]             }
[17:00:34.459]             else {
[17:00:34.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.459]             }
[17:00:34.459]             {
[17:00:34.459]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.459]                   0L) {
[17:00:34.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.459]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.459]                   base::options(opts)
[17:00:34.459]                 }
[17:00:34.459]                 {
[17:00:34.459]                   {
[17:00:34.459]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.459]                     NULL
[17:00:34.459]                   }
[17:00:34.459]                   options(future.plan = NULL)
[17:00:34.459]                   if (is.na(NA_character_)) 
[17:00:34.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.459]                     .init = FALSE)
[17:00:34.459]                 }
[17:00:34.459]             }
[17:00:34.459]         }
[17:00:34.459]     })
[17:00:34.459]     if (TRUE) {
[17:00:34.459]         base::sink(type = "output", split = FALSE)
[17:00:34.459]         if (TRUE) {
[17:00:34.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.459]         }
[17:00:34.459]         else {
[17:00:34.459]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.459]         }
[17:00:34.459]         base::close(...future.stdout)
[17:00:34.459]         ...future.stdout <- NULL
[17:00:34.459]     }
[17:00:34.459]     ...future.result$conditions <- ...future.conditions
[17:00:34.459]     ...future.result$finished <- base::Sys.time()
[17:00:34.459]     ...future.result
[17:00:34.459] }
[17:00:34.461] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[17:00:34.462] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[17:00:34.462] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[17:00:34.462] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:00:34.462] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:00:34.463] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:00:34.463] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:00:34.463] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:34.463] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.463] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:34.464] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.464] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[17:00:34.464] MultisessionFuture started
[17:00:34.464] - Launch lazy future ... done
[17:00:34.465] run() for ‘MultisessionFuture’ ... done
[17:00:34.465] Created future:
[17:00:34.465] MultisessionFuture:
[17:00:34.465] Label: ‘future_mapply-1’
[17:00:34.465] Expression:
[17:00:34.465] {
[17:00:34.465]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.465]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.465]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.465]         on.exit(options(oopts), add = TRUE)
[17:00:34.465]     }
[17:00:34.465]     {
[17:00:34.465]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.465]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.465]         do.call(mapply, args = args)
[17:00:34.465]     }
[17:00:34.465] }
[17:00:34.465] Lazy evaluation: FALSE
[17:00:34.465] Asynchronous evaluation: TRUE
[17:00:34.465] Local evaluation: TRUE
[17:00:34.465] Environment: R_GlobalEnv
[17:00:34.465] Capture standard output: TRUE
[17:00:34.465] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.465] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.465] Packages: <none>
[17:00:34.465] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.465] Resolved: FALSE
[17:00:34.465] Value: <not collected>
[17:00:34.465] Conditions captured: <none>
[17:00:34.465] Early signaling: FALSE
[17:00:34.465] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.465] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.476] Chunk #1 of 2 ... DONE
[17:00:34.476] Chunk #2 of 2 ...
[17:00:34.476]  - Finding globals in '...' for chunk #2 ...
[17:00:34.477] getGlobalsAndPackages() ...
[17:00:34.477] Searching for globals...
[17:00:34.477] 
[17:00:34.477] Searching for globals ... DONE
[17:00:34.477] - globals: [0] <none>
[17:00:34.477] getGlobalsAndPackages() ... DONE
[17:00:34.477]    + additional globals found: [n=0] 
[17:00:34.477]    + additional namespaces needed: [n=0] 
[17:00:34.477]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:34.478]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.478]  - seeds: <none>
[17:00:34.478]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.478] getGlobalsAndPackages() ...
[17:00:34.478] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.478] Resolving globals: FALSE
[17:00:34.479] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:00:34.479] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:00:34.479] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.479] 
[17:00:34.479] getGlobalsAndPackages() ... DONE
[17:00:34.480] run() for ‘Future’ ...
[17:00:34.480] - state: ‘created’
[17:00:34.480] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.494] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.494]   - Field: ‘node’
[17:00:34.494]   - Field: ‘label’
[17:00:34.495]   - Field: ‘local’
[17:00:34.495]   - Field: ‘owner’
[17:00:34.495]   - Field: ‘envir’
[17:00:34.495]   - Field: ‘workers’
[17:00:34.495]   - Field: ‘packages’
[17:00:34.495]   - Field: ‘gc’
[17:00:34.495]   - Field: ‘conditions’
[17:00:34.495]   - Field: ‘persistent’
[17:00:34.495]   - Field: ‘expr’
[17:00:34.495]   - Field: ‘uuid’
[17:00:34.496]   - Field: ‘seed’
[17:00:34.496]   - Field: ‘version’
[17:00:34.496]   - Field: ‘result’
[17:00:34.496]   - Field: ‘asynchronous’
[17:00:34.496]   - Field: ‘calls’
[17:00:34.496]   - Field: ‘globals’
[17:00:34.496]   - Field: ‘stdout’
[17:00:34.496]   - Field: ‘earlySignal’
[17:00:34.496]   - Field: ‘lazy’
[17:00:34.496]   - Field: ‘state’
[17:00:34.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.497] - Launch lazy future ...
[17:00:34.497] Packages needed by the future expression (n = 0): <none>
[17:00:34.497] Packages needed by future strategies (n = 0): <none>
[17:00:34.497] {
[17:00:34.497]     {
[17:00:34.497]         {
[17:00:34.497]             ...future.startTime <- base::Sys.time()
[17:00:34.497]             {
[17:00:34.497]                 {
[17:00:34.497]                   {
[17:00:34.497]                     {
[17:00:34.497]                       base::local({
[17:00:34.497]                         has_future <- base::requireNamespace("future", 
[17:00:34.497]                           quietly = TRUE)
[17:00:34.497]                         if (has_future) {
[17:00:34.497]                           ns <- base::getNamespace("future")
[17:00:34.497]                           version <- ns[[".package"]][["version"]]
[17:00:34.497]                           if (is.null(version)) 
[17:00:34.497]                             version <- utils::packageVersion("future")
[17:00:34.497]                         }
[17:00:34.497]                         else {
[17:00:34.497]                           version <- NULL
[17:00:34.497]                         }
[17:00:34.497]                         if (!has_future || version < "1.8.0") {
[17:00:34.497]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.497]                             "", base::R.version$version.string), 
[17:00:34.497]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.497]                               "release", "version")], collapse = " "), 
[17:00:34.497]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.497]                             info)
[17:00:34.497]                           info <- base::paste(info, collapse = "; ")
[17:00:34.497]                           if (!has_future) {
[17:00:34.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.497]                               info)
[17:00:34.497]                           }
[17:00:34.497]                           else {
[17:00:34.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.497]                               info, version)
[17:00:34.497]                           }
[17:00:34.497]                           base::stop(msg)
[17:00:34.497]                         }
[17:00:34.497]                       })
[17:00:34.497]                     }
[17:00:34.497]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.497]                     base::options(mc.cores = 1L)
[17:00:34.497]                   }
[17:00:34.497]                   ...future.strategy.old <- future::plan("list")
[17:00:34.497]                   options(future.plan = NULL)
[17:00:34.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.497]                 }
[17:00:34.497]                 ...future.workdir <- getwd()
[17:00:34.497]             }
[17:00:34.497]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.497]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.497]         }
[17:00:34.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.497]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.497]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.497]             base::names(...future.oldOptions))
[17:00:34.497]     }
[17:00:34.497]     if (FALSE) {
[17:00:34.497]     }
[17:00:34.497]     else {
[17:00:34.497]         if (TRUE) {
[17:00:34.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.497]                 open = "w")
[17:00:34.497]         }
[17:00:34.497]         else {
[17:00:34.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.497]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.497]         }
[17:00:34.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.497]             base::sink(type = "output", split = FALSE)
[17:00:34.497]             base::close(...future.stdout)
[17:00:34.497]         }, add = TRUE)
[17:00:34.497]     }
[17:00:34.497]     ...future.frame <- base::sys.nframe()
[17:00:34.497]     ...future.conditions <- base::list()
[17:00:34.497]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.497]     if (FALSE) {
[17:00:34.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.497]     }
[17:00:34.497]     ...future.result <- base::tryCatch({
[17:00:34.497]         base::withCallingHandlers({
[17:00:34.497]             ...future.value <- base::withVisible(base::local({
[17:00:34.497]                 ...future.makeSendCondition <- base::local({
[17:00:34.497]                   sendCondition <- NULL
[17:00:34.497]                   function(frame = 1L) {
[17:00:34.497]                     if (is.function(sendCondition)) 
[17:00:34.497]                       return(sendCondition)
[17:00:34.497]                     ns <- getNamespace("parallel")
[17:00:34.497]                     if (exists("sendData", mode = "function", 
[17:00:34.497]                       envir = ns)) {
[17:00:34.497]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.497]                         envir = ns)
[17:00:34.497]                       envir <- sys.frame(frame)
[17:00:34.497]                       master <- NULL
[17:00:34.497]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.497]                         !identical(envir, emptyenv())) {
[17:00:34.497]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.497]                           inherits = FALSE)) {
[17:00:34.497]                           master <- get("master", mode = "list", 
[17:00:34.497]                             envir = envir, inherits = FALSE)
[17:00:34.497]                           if (inherits(master, c("SOCKnode", 
[17:00:34.497]                             "SOCK0node"))) {
[17:00:34.497]                             sendCondition <<- function(cond) {
[17:00:34.497]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.497]                                 success = TRUE)
[17:00:34.497]                               parallel_sendData(master, data)
[17:00:34.497]                             }
[17:00:34.497]                             return(sendCondition)
[17:00:34.497]                           }
[17:00:34.497]                         }
[17:00:34.497]                         frame <- frame + 1L
[17:00:34.497]                         envir <- sys.frame(frame)
[17:00:34.497]                       }
[17:00:34.497]                     }
[17:00:34.497]                     sendCondition <<- function(cond) NULL
[17:00:34.497]                   }
[17:00:34.497]                 })
[17:00:34.497]                 withCallingHandlers({
[17:00:34.497]                   {
[17:00:34.497]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.497]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.497]                       ...future.globals.maxSize)) {
[17:00:34.497]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.497]                       on.exit(options(oopts), add = TRUE)
[17:00:34.497]                     }
[17:00:34.497]                     {
[17:00:34.497]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.497]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.497]                         USE.NAMES = FALSE)
[17:00:34.497]                       do.call(mapply, args = args)
[17:00:34.497]                     }
[17:00:34.497]                   }
[17:00:34.497]                 }, immediateCondition = function(cond) {
[17:00:34.497]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.497]                   sendCondition(cond)
[17:00:34.497]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.497]                   {
[17:00:34.497]                     inherits <- base::inherits
[17:00:34.497]                     invokeRestart <- base::invokeRestart
[17:00:34.497]                     is.null <- base::is.null
[17:00:34.497]                     muffled <- FALSE
[17:00:34.497]                     if (inherits(cond, "message")) {
[17:00:34.497]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.497]                       if (muffled) 
[17:00:34.497]                         invokeRestart("muffleMessage")
[17:00:34.497]                     }
[17:00:34.497]                     else if (inherits(cond, "warning")) {
[17:00:34.497]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.497]                       if (muffled) 
[17:00:34.497]                         invokeRestart("muffleWarning")
[17:00:34.497]                     }
[17:00:34.497]                     else if (inherits(cond, "condition")) {
[17:00:34.497]                       if (!is.null(pattern)) {
[17:00:34.497]                         computeRestarts <- base::computeRestarts
[17:00:34.497]                         grepl <- base::grepl
[17:00:34.497]                         restarts <- computeRestarts(cond)
[17:00:34.497]                         for (restart in restarts) {
[17:00:34.497]                           name <- restart$name
[17:00:34.497]                           if (is.null(name)) 
[17:00:34.497]                             next
[17:00:34.497]                           if (!grepl(pattern, name)) 
[17:00:34.497]                             next
[17:00:34.497]                           invokeRestart(restart)
[17:00:34.497]                           muffled <- TRUE
[17:00:34.497]                           break
[17:00:34.497]                         }
[17:00:34.497]                       }
[17:00:34.497]                     }
[17:00:34.497]                     invisible(muffled)
[17:00:34.497]                   }
[17:00:34.497]                   muffleCondition(cond)
[17:00:34.497]                 })
[17:00:34.497]             }))
[17:00:34.497]             future::FutureResult(value = ...future.value$value, 
[17:00:34.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.497]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.497]                     ...future.globalenv.names))
[17:00:34.497]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.497]         }, condition = base::local({
[17:00:34.497]             c <- base::c
[17:00:34.497]             inherits <- base::inherits
[17:00:34.497]             invokeRestart <- base::invokeRestart
[17:00:34.497]             length <- base::length
[17:00:34.497]             list <- base::list
[17:00:34.497]             seq.int <- base::seq.int
[17:00:34.497]             signalCondition <- base::signalCondition
[17:00:34.497]             sys.calls <- base::sys.calls
[17:00:34.497]             `[[` <- base::`[[`
[17:00:34.497]             `+` <- base::`+`
[17:00:34.497]             `<<-` <- base::`<<-`
[17:00:34.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.497]                   3L)]
[17:00:34.497]             }
[17:00:34.497]             function(cond) {
[17:00:34.497]                 is_error <- inherits(cond, "error")
[17:00:34.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.497]                   NULL)
[17:00:34.497]                 if (is_error) {
[17:00:34.497]                   sessionInformation <- function() {
[17:00:34.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.497]                       search = base::search(), system = base::Sys.info())
[17:00:34.497]                   }
[17:00:34.497]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.497]                     cond$call), session = sessionInformation(), 
[17:00:34.497]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.497]                   signalCondition(cond)
[17:00:34.497]                 }
[17:00:34.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.497]                 "immediateCondition"))) {
[17:00:34.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.497]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.497]                   if (TRUE && !signal) {
[17:00:34.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.497]                     {
[17:00:34.497]                       inherits <- base::inherits
[17:00:34.497]                       invokeRestart <- base::invokeRestart
[17:00:34.497]                       is.null <- base::is.null
[17:00:34.497]                       muffled <- FALSE
[17:00:34.497]                       if (inherits(cond, "message")) {
[17:00:34.497]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.497]                         if (muffled) 
[17:00:34.497]                           invokeRestart("muffleMessage")
[17:00:34.497]                       }
[17:00:34.497]                       else if (inherits(cond, "warning")) {
[17:00:34.497]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.497]                         if (muffled) 
[17:00:34.497]                           invokeRestart("muffleWarning")
[17:00:34.497]                       }
[17:00:34.497]                       else if (inherits(cond, "condition")) {
[17:00:34.497]                         if (!is.null(pattern)) {
[17:00:34.497]                           computeRestarts <- base::computeRestarts
[17:00:34.497]                           grepl <- base::grepl
[17:00:34.497]                           restarts <- computeRestarts(cond)
[17:00:34.497]                           for (restart in restarts) {
[17:00:34.497]                             name <- restart$name
[17:00:34.497]                             if (is.null(name)) 
[17:00:34.497]                               next
[17:00:34.497]                             if (!grepl(pattern, name)) 
[17:00:34.497]                               next
[17:00:34.497]                             invokeRestart(restart)
[17:00:34.497]                             muffled <- TRUE
[17:00:34.497]                             break
[17:00:34.497]                           }
[17:00:34.497]                         }
[17:00:34.497]                       }
[17:00:34.497]                       invisible(muffled)
[17:00:34.497]                     }
[17:00:34.497]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.497]                   }
[17:00:34.497]                 }
[17:00:34.497]                 else {
[17:00:34.497]                   if (TRUE) {
[17:00:34.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.497]                     {
[17:00:34.497]                       inherits <- base::inherits
[17:00:34.497]                       invokeRestart <- base::invokeRestart
[17:00:34.497]                       is.null <- base::is.null
[17:00:34.497]                       muffled <- FALSE
[17:00:34.497]                       if (inherits(cond, "message")) {
[17:00:34.497]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.497]                         if (muffled) 
[17:00:34.497]                           invokeRestart("muffleMessage")
[17:00:34.497]                       }
[17:00:34.497]                       else if (inherits(cond, "warning")) {
[17:00:34.497]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.497]                         if (muffled) 
[17:00:34.497]                           invokeRestart("muffleWarning")
[17:00:34.497]                       }
[17:00:34.497]                       else if (inherits(cond, "condition")) {
[17:00:34.497]                         if (!is.null(pattern)) {
[17:00:34.497]                           computeRestarts <- base::computeRestarts
[17:00:34.497]                           grepl <- base::grepl
[17:00:34.497]                           restarts <- computeRestarts(cond)
[17:00:34.497]                           for (restart in restarts) {
[17:00:34.497]                             name <- restart$name
[17:00:34.497]                             if (is.null(name)) 
[17:00:34.497]                               next
[17:00:34.497]                             if (!grepl(pattern, name)) 
[17:00:34.497]                               next
[17:00:34.497]                             invokeRestart(restart)
[17:00:34.497]                             muffled <- TRUE
[17:00:34.497]                             break
[17:00:34.497]                           }
[17:00:34.497]                         }
[17:00:34.497]                       }
[17:00:34.497]                       invisible(muffled)
[17:00:34.497]                     }
[17:00:34.497]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.497]                   }
[17:00:34.497]                 }
[17:00:34.497]             }
[17:00:34.497]         }))
[17:00:34.497]     }, error = function(ex) {
[17:00:34.497]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.497]                 ...future.rng), started = ...future.startTime, 
[17:00:34.497]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.497]             version = "1.8"), class = "FutureResult")
[17:00:34.497]     }, finally = {
[17:00:34.497]         if (!identical(...future.workdir, getwd())) 
[17:00:34.497]             setwd(...future.workdir)
[17:00:34.497]         {
[17:00:34.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.497]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.497]             }
[17:00:34.497]             base::options(...future.oldOptions)
[17:00:34.497]             if (.Platform$OS.type == "windows") {
[17:00:34.497]                 old_names <- names(...future.oldEnvVars)
[17:00:34.497]                 envs <- base::Sys.getenv()
[17:00:34.497]                 names <- names(envs)
[17:00:34.497]                 common <- intersect(names, old_names)
[17:00:34.497]                 added <- setdiff(names, old_names)
[17:00:34.497]                 removed <- setdiff(old_names, names)
[17:00:34.497]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.497]                   envs[common]]
[17:00:34.497]                 NAMES <- toupper(changed)
[17:00:34.497]                 args <- list()
[17:00:34.497]                 for (kk in seq_along(NAMES)) {
[17:00:34.497]                   name <- changed[[kk]]
[17:00:34.497]                   NAME <- NAMES[[kk]]
[17:00:34.497]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.497]                     next
[17:00:34.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.497]                 }
[17:00:34.497]                 NAMES <- toupper(added)
[17:00:34.497]                 for (kk in seq_along(NAMES)) {
[17:00:34.497]                   name <- added[[kk]]
[17:00:34.497]                   NAME <- NAMES[[kk]]
[17:00:34.497]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.497]                     next
[17:00:34.497]                   args[[name]] <- ""
[17:00:34.497]                 }
[17:00:34.497]                 NAMES <- toupper(removed)
[17:00:34.497]                 for (kk in seq_along(NAMES)) {
[17:00:34.497]                   name <- removed[[kk]]
[17:00:34.497]                   NAME <- NAMES[[kk]]
[17:00:34.497]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.497]                     next
[17:00:34.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.497]                 }
[17:00:34.497]                 if (length(args) > 0) 
[17:00:34.497]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.497]             }
[17:00:34.497]             else {
[17:00:34.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.497]             }
[17:00:34.497]             {
[17:00:34.497]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.497]                   0L) {
[17:00:34.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.497]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.497]                   base::options(opts)
[17:00:34.497]                 }
[17:00:34.497]                 {
[17:00:34.497]                   {
[17:00:34.497]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.497]                     NULL
[17:00:34.497]                   }
[17:00:34.497]                   options(future.plan = NULL)
[17:00:34.497]                   if (is.na(NA_character_)) 
[17:00:34.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.497]                     .init = FALSE)
[17:00:34.497]                 }
[17:00:34.497]             }
[17:00:34.497]         }
[17:00:34.497]     })
[17:00:34.497]     if (TRUE) {
[17:00:34.497]         base::sink(type = "output", split = FALSE)
[17:00:34.497]         if (TRUE) {
[17:00:34.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.497]         }
[17:00:34.497]         else {
[17:00:34.497]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.497]         }
[17:00:34.497]         base::close(...future.stdout)
[17:00:34.497]         ...future.stdout <- NULL
[17:00:34.497]     }
[17:00:34.497]     ...future.result$conditions <- ...future.conditions
[17:00:34.497]     ...future.result$finished <- base::Sys.time()
[17:00:34.497]     ...future.result
[17:00:34.497] }
[17:00:34.500] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[17:00:34.501] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[17:00:34.501] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[17:00:34.501] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:00:34.501] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:00:34.502] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:00:34.502] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:00:34.502] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:34.502] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.503] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:34.503] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.503] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[17:00:34.504] MultisessionFuture started
[17:00:34.504] - Launch lazy future ... done
[17:00:34.504] run() for ‘MultisessionFuture’ ... done
[17:00:34.504] Created future:
[17:00:34.504] MultisessionFuture:
[17:00:34.504] Label: ‘future_mapply-2’
[17:00:34.504] Expression:
[17:00:34.504] {
[17:00:34.504]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.504]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.504]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.504]         on.exit(options(oopts), add = TRUE)
[17:00:34.504]     }
[17:00:34.504]     {
[17:00:34.504]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.504]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.504]         do.call(mapply, args = args)
[17:00:34.504]     }
[17:00:34.504] }
[17:00:34.504] Lazy evaluation: FALSE
[17:00:34.504] Asynchronous evaluation: TRUE
[17:00:34.504] Local evaluation: TRUE
[17:00:34.504] Environment: R_GlobalEnv
[17:00:34.504] Capture standard output: TRUE
[17:00:34.504] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.504] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.504] Packages: <none>
[17:00:34.504] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.504] Resolved: FALSE
[17:00:34.504] Value: <not collected>
[17:00:34.504] Conditions captured: <none>
[17:00:34.504] Early signaling: FALSE
[17:00:34.504] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.504] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.516] Chunk #2 of 2 ... DONE
[17:00:34.516] Launching 2 futures (chunks) ... DONE
[17:00:34.516] Resolving 2 futures (chunks) ...
[17:00:34.516] resolve() on list ...
[17:00:34.516]  recursive: 0
[17:00:34.516]  length: 2
[17:00:34.516] 
[17:00:34.517] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.517] - Validating connection of MultisessionFuture
[17:00:34.517] - received message: FutureResult
[17:00:34.517] - Received FutureResult
[17:00:34.517] - Erased future from FutureRegistry
[17:00:34.518] result() for ClusterFuture ...
[17:00:34.518] - result already collected: FutureResult
[17:00:34.518] result() for ClusterFuture ... done
[17:00:34.518] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.518] Future #1
[17:00:34.518] result() for ClusterFuture ...
[17:00:34.518] - result already collected: FutureResult
[17:00:34.518] result() for ClusterFuture ... done
[17:00:34.518] result() for ClusterFuture ...
[17:00:34.518] - result already collected: FutureResult
[17:00:34.518] result() for ClusterFuture ... done
[17:00:34.519] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:34.519] - nx: 2
[17:00:34.519] - relay: TRUE
[17:00:34.519] - stdout: TRUE
[17:00:34.519] - signal: TRUE
[17:00:34.519] - resignal: FALSE
[17:00:34.519] - force: TRUE
[17:00:34.519] - relayed: [n=2] FALSE, FALSE
[17:00:34.519] - queued futures: [n=2] FALSE, FALSE
[17:00:34.519]  - until=1
[17:00:34.519]  - relaying element #1
[17:00:34.520] result() for ClusterFuture ...
[17:00:34.520] - result already collected: FutureResult
[17:00:34.520] result() for ClusterFuture ... done
[17:00:34.520] result() for ClusterFuture ...
[17:00:34.520] - result already collected: FutureResult
[17:00:34.520] result() for ClusterFuture ... done
[17:00:34.520] result() for ClusterFuture ...
[17:00:34.520] - result already collected: FutureResult
[17:00:34.520] result() for ClusterFuture ... done
[17:00:34.520] result() for ClusterFuture ...
[17:00:34.520] - result already collected: FutureResult
[17:00:34.521] result() for ClusterFuture ... done
[17:00:34.521] - relayed: [n=2] TRUE, FALSE
[17:00:34.521] - queued futures: [n=2] TRUE, FALSE
[17:00:34.521] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:34.521]  length: 1 (resolved future 1)
[17:00:34.549] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.549] - Validating connection of MultisessionFuture
[17:00:34.549] - received message: FutureResult
[17:00:34.550] - Received FutureResult
[17:00:34.550] - Erased future from FutureRegistry
[17:00:34.550] result() for ClusterFuture ...
[17:00:34.550] - result already collected: FutureResult
[17:00:34.550] result() for ClusterFuture ... done
[17:00:34.550] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.550] Future #2
[17:00:34.550] result() for ClusterFuture ...
[17:00:34.550] - result already collected: FutureResult
[17:00:34.550] result() for ClusterFuture ... done
[17:00:34.551] result() for ClusterFuture ...
[17:00:34.551] - result already collected: FutureResult
[17:00:34.551] result() for ClusterFuture ... done
[17:00:34.551] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:34.551] - nx: 2
[17:00:34.551] - relay: TRUE
[17:00:34.551] - stdout: TRUE
[17:00:34.551] - signal: TRUE
[17:00:34.551] - resignal: FALSE
[17:00:34.551] - force: TRUE
[17:00:34.551] - relayed: [n=2] TRUE, FALSE
[17:00:34.552] - queued futures: [n=2] TRUE, FALSE
[17:00:34.552]  - until=2
[17:00:34.552]  - relaying element #2
[17:00:34.552] result() for ClusterFuture ...
[17:00:34.552] - result already collected: FutureResult
[17:00:34.552] result() for ClusterFuture ... done
[17:00:34.552] result() for ClusterFuture ...
[17:00:34.552] - result already collected: FutureResult
[17:00:34.552] result() for ClusterFuture ... done
[17:00:34.552] result() for ClusterFuture ...
[17:00:34.552] - result already collected: FutureResult
[17:00:34.553] result() for ClusterFuture ... done
[17:00:34.553] result() for ClusterFuture ...
[17:00:34.553] - result already collected: FutureResult
[17:00:34.553] result() for ClusterFuture ... done
[17:00:34.553] - relayed: [n=2] TRUE, TRUE
[17:00:34.553] - queued futures: [n=2] TRUE, TRUE
[17:00:34.553] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:34.553]  length: 0 (resolved future 2)
[17:00:34.553] Relaying remaining futures
[17:00:34.553] signalConditionsASAP(NULL, pos=0) ...
[17:00:34.553] - nx: 2
[17:00:34.554] - relay: TRUE
[17:00:34.554] - stdout: TRUE
[17:00:34.554] - signal: TRUE
[17:00:34.554] - resignal: FALSE
[17:00:34.554] - force: TRUE
[17:00:34.554] - relayed: [n=2] TRUE, TRUE
[17:00:34.554] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:34.554] - relayed: [n=2] TRUE, TRUE
[17:00:34.554] - queued futures: [n=2] TRUE, TRUE
[17:00:34.554] signalConditionsASAP(NULL, pos=0) ... done
[17:00:34.554] resolve() on list ... DONE
[17:00:34.555] result() for ClusterFuture ...
[17:00:34.555] - result already collected: FutureResult
[17:00:34.555] result() for ClusterFuture ... done
[17:00:34.555] result() for ClusterFuture ...
[17:00:34.555] - result already collected: FutureResult
[17:00:34.555] result() for ClusterFuture ... done
[17:00:34.555] result() for ClusterFuture ...
[17:00:34.555] - result already collected: FutureResult
[17:00:34.555] result() for ClusterFuture ... done
[17:00:34.555] result() for ClusterFuture ...
[17:00:34.555] - result already collected: FutureResult
[17:00:34.555] result() for ClusterFuture ... done
[17:00:34.556]  - Number of value chunks collected: 2
[17:00:34.556] Resolving 2 futures (chunks) ... DONE
[17:00:34.556] Reducing values from 2 chunks ...
[17:00:34.556]  - Number of values collected after concatenation: 2
[17:00:34.556]  - Number of values expected: 2
[17:00:34.556] Reducing values from 2 chunks ... DONE
[17:00:34.556] future_mapply() ... DONE
[17:00:34.556] future_mapply() ...
[17:00:34.556] Generating random seeds ...
[17:00:34.557] Generating random seed streams for 2 elements ...
[17:00:34.557] Generating random seed streams for 2 elements ... DONE
[17:00:34.557] Generating random seeds ... DONE
[17:00:34.557] Will set RNG state on exit: 10407, 580549876, 1629907173, -864734119, -1973982717, -885759664, -818934511
[17:00:34.561] Number of chunks: 2
[17:00:34.561] getGlobalsAndPackagesXApply() ...
[17:00:34.561]  - future.globals: TRUE
[17:00:34.561] getGlobalsAndPackages() ...
[17:00:34.561] Searching for globals...
[17:00:34.562] - globals found: [1] ‘FUN’
[17:00:34.562] Searching for globals ... DONE
[17:00:34.562] Resolving globals: FALSE
[17:00:34.563] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:00:34.563] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:00:34.563] - globals: [1] ‘FUN’
[17:00:34.563] 
[17:00:34.563] getGlobalsAndPackages() ... DONE
[17:00:34.563]  - globals found/used: [n=1] ‘FUN’
[17:00:34.564]  - needed namespaces: [n=0] 
[17:00:34.564] Finding globals ... DONE
[17:00:34.564] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:34.564] List of 2
[17:00:34.564]  $ ...future.FUN:function (x, y)  
[17:00:34.564]  $ MoreArgs     :List of 1
[17:00:34.564]   ..$ y: int [1:2] 3 4
[17:00:34.564]  - attr(*, "where")=List of 2
[17:00:34.564]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:34.564]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:34.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:34.564]  - attr(*, "resolved")= logi FALSE
[17:00:34.564]  - attr(*, "total_size")= num NA
[17:00:34.567] Packages to be attached in all futures: [n=0] 
[17:00:34.567] getGlobalsAndPackagesXApply() ... DONE
[17:00:34.567] Number of futures (= number of chunks): 2
[17:00:34.567] Launching 2 futures (chunks) ...
[17:00:34.567] Chunk #1 of 2 ...
[17:00:34.567]  - Finding globals in '...' for chunk #1 ...
[17:00:34.568] getGlobalsAndPackages() ...
[17:00:34.568] Searching for globals...
[17:00:34.568] 
[17:00:34.568] Searching for globals ... DONE
[17:00:34.568] - globals: [0] <none>
[17:00:34.568] getGlobalsAndPackages() ... DONE
[17:00:34.568]    + additional globals found: [n=0] 
[17:00:34.568]    + additional namespaces needed: [n=0] 
[17:00:34.568]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:34.569]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.569]  - seeds: [1] <seeds>
[17:00:34.569]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.569] getGlobalsAndPackages() ...
[17:00:34.569] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.569] Resolving globals: FALSE
[17:00:34.569] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:00:34.570] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:34.570] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.570] 
[17:00:34.570] getGlobalsAndPackages() ... DONE
[17:00:34.571] run() for ‘Future’ ...
[17:00:34.571] - state: ‘created’
[17:00:34.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.585] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.586]   - Field: ‘node’
[17:00:34.586]   - Field: ‘label’
[17:00:34.586]   - Field: ‘local’
[17:00:34.586]   - Field: ‘owner’
[17:00:34.586]   - Field: ‘envir’
[17:00:34.586]   - Field: ‘workers’
[17:00:34.586]   - Field: ‘packages’
[17:00:34.586]   - Field: ‘gc’
[17:00:34.587]   - Field: ‘conditions’
[17:00:34.587]   - Field: ‘persistent’
[17:00:34.587]   - Field: ‘expr’
[17:00:34.587]   - Field: ‘uuid’
[17:00:34.587]   - Field: ‘seed’
[17:00:34.587]   - Field: ‘version’
[17:00:34.587]   - Field: ‘result’
[17:00:34.587]   - Field: ‘asynchronous’
[17:00:34.587]   - Field: ‘calls’
[17:00:34.587]   - Field: ‘globals’
[17:00:34.588]   - Field: ‘stdout’
[17:00:34.588]   - Field: ‘earlySignal’
[17:00:34.588]   - Field: ‘lazy’
[17:00:34.588]   - Field: ‘state’
[17:00:34.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.588] - Launch lazy future ...
[17:00:34.588] Packages needed by the future expression (n = 0): <none>
[17:00:34.588] Packages needed by future strategies (n = 0): <none>
[17:00:34.589] {
[17:00:34.589]     {
[17:00:34.589]         {
[17:00:34.589]             ...future.startTime <- base::Sys.time()
[17:00:34.589]             {
[17:00:34.589]                 {
[17:00:34.589]                   {
[17:00:34.589]                     {
[17:00:34.589]                       base::local({
[17:00:34.589]                         has_future <- base::requireNamespace("future", 
[17:00:34.589]                           quietly = TRUE)
[17:00:34.589]                         if (has_future) {
[17:00:34.589]                           ns <- base::getNamespace("future")
[17:00:34.589]                           version <- ns[[".package"]][["version"]]
[17:00:34.589]                           if (is.null(version)) 
[17:00:34.589]                             version <- utils::packageVersion("future")
[17:00:34.589]                         }
[17:00:34.589]                         else {
[17:00:34.589]                           version <- NULL
[17:00:34.589]                         }
[17:00:34.589]                         if (!has_future || version < "1.8.0") {
[17:00:34.589]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.589]                             "", base::R.version$version.string), 
[17:00:34.589]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.589]                               "release", "version")], collapse = " "), 
[17:00:34.589]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.589]                             info)
[17:00:34.589]                           info <- base::paste(info, collapse = "; ")
[17:00:34.589]                           if (!has_future) {
[17:00:34.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.589]                               info)
[17:00:34.589]                           }
[17:00:34.589]                           else {
[17:00:34.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.589]                               info, version)
[17:00:34.589]                           }
[17:00:34.589]                           base::stop(msg)
[17:00:34.589]                         }
[17:00:34.589]                       })
[17:00:34.589]                     }
[17:00:34.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.589]                     base::options(mc.cores = 1L)
[17:00:34.589]                   }
[17:00:34.589]                   ...future.strategy.old <- future::plan("list")
[17:00:34.589]                   options(future.plan = NULL)
[17:00:34.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.589]                 }
[17:00:34.589]                 ...future.workdir <- getwd()
[17:00:34.589]             }
[17:00:34.589]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.589]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.589]         }
[17:00:34.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.589]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.589]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.589]             base::names(...future.oldOptions))
[17:00:34.589]     }
[17:00:34.589]     if (FALSE) {
[17:00:34.589]     }
[17:00:34.589]     else {
[17:00:34.589]         if (TRUE) {
[17:00:34.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.589]                 open = "w")
[17:00:34.589]         }
[17:00:34.589]         else {
[17:00:34.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.589]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.589]         }
[17:00:34.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.589]             base::sink(type = "output", split = FALSE)
[17:00:34.589]             base::close(...future.stdout)
[17:00:34.589]         }, add = TRUE)
[17:00:34.589]     }
[17:00:34.589]     ...future.frame <- base::sys.nframe()
[17:00:34.589]     ...future.conditions <- base::list()
[17:00:34.589]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.589]     if (FALSE) {
[17:00:34.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.589]     }
[17:00:34.589]     ...future.result <- base::tryCatch({
[17:00:34.589]         base::withCallingHandlers({
[17:00:34.589]             ...future.value <- base::withVisible(base::local({
[17:00:34.589]                 ...future.makeSendCondition <- base::local({
[17:00:34.589]                   sendCondition <- NULL
[17:00:34.589]                   function(frame = 1L) {
[17:00:34.589]                     if (is.function(sendCondition)) 
[17:00:34.589]                       return(sendCondition)
[17:00:34.589]                     ns <- getNamespace("parallel")
[17:00:34.589]                     if (exists("sendData", mode = "function", 
[17:00:34.589]                       envir = ns)) {
[17:00:34.589]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.589]                         envir = ns)
[17:00:34.589]                       envir <- sys.frame(frame)
[17:00:34.589]                       master <- NULL
[17:00:34.589]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.589]                         !identical(envir, emptyenv())) {
[17:00:34.589]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.589]                           inherits = FALSE)) {
[17:00:34.589]                           master <- get("master", mode = "list", 
[17:00:34.589]                             envir = envir, inherits = FALSE)
[17:00:34.589]                           if (inherits(master, c("SOCKnode", 
[17:00:34.589]                             "SOCK0node"))) {
[17:00:34.589]                             sendCondition <<- function(cond) {
[17:00:34.589]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.589]                                 success = TRUE)
[17:00:34.589]                               parallel_sendData(master, data)
[17:00:34.589]                             }
[17:00:34.589]                             return(sendCondition)
[17:00:34.589]                           }
[17:00:34.589]                         }
[17:00:34.589]                         frame <- frame + 1L
[17:00:34.589]                         envir <- sys.frame(frame)
[17:00:34.589]                       }
[17:00:34.589]                     }
[17:00:34.589]                     sendCondition <<- function(cond) NULL
[17:00:34.589]                   }
[17:00:34.589]                 })
[17:00:34.589]                 withCallingHandlers({
[17:00:34.589]                   {
[17:00:34.589]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.589]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.589]                       ...future.globals.maxSize)) {
[17:00:34.589]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.589]                       on.exit(options(oopts), add = TRUE)
[17:00:34.589]                     }
[17:00:34.589]                     {
[17:00:34.589]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:34.589]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:34.589]                           envir = globalenv(), inherits = FALSE)
[17:00:34.589]                         ...future.FUN(...)
[17:00:34.589]                       }
[17:00:34.589]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:34.589]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:34.589]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.589]                         USE.NAMES = FALSE)
[17:00:34.589]                       do.call(mapply, args = args)
[17:00:34.589]                     }
[17:00:34.589]                   }
[17:00:34.589]                 }, immediateCondition = function(cond) {
[17:00:34.589]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.589]                   sendCondition(cond)
[17:00:34.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.589]                   {
[17:00:34.589]                     inherits <- base::inherits
[17:00:34.589]                     invokeRestart <- base::invokeRestart
[17:00:34.589]                     is.null <- base::is.null
[17:00:34.589]                     muffled <- FALSE
[17:00:34.589]                     if (inherits(cond, "message")) {
[17:00:34.589]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.589]                       if (muffled) 
[17:00:34.589]                         invokeRestart("muffleMessage")
[17:00:34.589]                     }
[17:00:34.589]                     else if (inherits(cond, "warning")) {
[17:00:34.589]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.589]                       if (muffled) 
[17:00:34.589]                         invokeRestart("muffleWarning")
[17:00:34.589]                     }
[17:00:34.589]                     else if (inherits(cond, "condition")) {
[17:00:34.589]                       if (!is.null(pattern)) {
[17:00:34.589]                         computeRestarts <- base::computeRestarts
[17:00:34.589]                         grepl <- base::grepl
[17:00:34.589]                         restarts <- computeRestarts(cond)
[17:00:34.589]                         for (restart in restarts) {
[17:00:34.589]                           name <- restart$name
[17:00:34.589]                           if (is.null(name)) 
[17:00:34.589]                             next
[17:00:34.589]                           if (!grepl(pattern, name)) 
[17:00:34.589]                             next
[17:00:34.589]                           invokeRestart(restart)
[17:00:34.589]                           muffled <- TRUE
[17:00:34.589]                           break
[17:00:34.589]                         }
[17:00:34.589]                       }
[17:00:34.589]                     }
[17:00:34.589]                     invisible(muffled)
[17:00:34.589]                   }
[17:00:34.589]                   muffleCondition(cond)
[17:00:34.589]                 })
[17:00:34.589]             }))
[17:00:34.589]             future::FutureResult(value = ...future.value$value, 
[17:00:34.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.589]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.589]                     ...future.globalenv.names))
[17:00:34.589]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.589]         }, condition = base::local({
[17:00:34.589]             c <- base::c
[17:00:34.589]             inherits <- base::inherits
[17:00:34.589]             invokeRestart <- base::invokeRestart
[17:00:34.589]             length <- base::length
[17:00:34.589]             list <- base::list
[17:00:34.589]             seq.int <- base::seq.int
[17:00:34.589]             signalCondition <- base::signalCondition
[17:00:34.589]             sys.calls <- base::sys.calls
[17:00:34.589]             `[[` <- base::`[[`
[17:00:34.589]             `+` <- base::`+`
[17:00:34.589]             `<<-` <- base::`<<-`
[17:00:34.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.589]                   3L)]
[17:00:34.589]             }
[17:00:34.589]             function(cond) {
[17:00:34.589]                 is_error <- inherits(cond, "error")
[17:00:34.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.589]                   NULL)
[17:00:34.589]                 if (is_error) {
[17:00:34.589]                   sessionInformation <- function() {
[17:00:34.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.589]                       search = base::search(), system = base::Sys.info())
[17:00:34.589]                   }
[17:00:34.589]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.589]                     cond$call), session = sessionInformation(), 
[17:00:34.589]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.589]                   signalCondition(cond)
[17:00:34.589]                 }
[17:00:34.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.589]                 "immediateCondition"))) {
[17:00:34.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.589]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.589]                   if (TRUE && !signal) {
[17:00:34.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.589]                     {
[17:00:34.589]                       inherits <- base::inherits
[17:00:34.589]                       invokeRestart <- base::invokeRestart
[17:00:34.589]                       is.null <- base::is.null
[17:00:34.589]                       muffled <- FALSE
[17:00:34.589]                       if (inherits(cond, "message")) {
[17:00:34.589]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.589]                         if (muffled) 
[17:00:34.589]                           invokeRestart("muffleMessage")
[17:00:34.589]                       }
[17:00:34.589]                       else if (inherits(cond, "warning")) {
[17:00:34.589]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.589]                         if (muffled) 
[17:00:34.589]                           invokeRestart("muffleWarning")
[17:00:34.589]                       }
[17:00:34.589]                       else if (inherits(cond, "condition")) {
[17:00:34.589]                         if (!is.null(pattern)) {
[17:00:34.589]                           computeRestarts <- base::computeRestarts
[17:00:34.589]                           grepl <- base::grepl
[17:00:34.589]                           restarts <- computeRestarts(cond)
[17:00:34.589]                           for (restart in restarts) {
[17:00:34.589]                             name <- restart$name
[17:00:34.589]                             if (is.null(name)) 
[17:00:34.589]                               next
[17:00:34.589]                             if (!grepl(pattern, name)) 
[17:00:34.589]                               next
[17:00:34.589]                             invokeRestart(restart)
[17:00:34.589]                             muffled <- TRUE
[17:00:34.589]                             break
[17:00:34.589]                           }
[17:00:34.589]                         }
[17:00:34.589]                       }
[17:00:34.589]                       invisible(muffled)
[17:00:34.589]                     }
[17:00:34.589]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.589]                   }
[17:00:34.589]                 }
[17:00:34.589]                 else {
[17:00:34.589]                   if (TRUE) {
[17:00:34.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.589]                     {
[17:00:34.589]                       inherits <- base::inherits
[17:00:34.589]                       invokeRestart <- base::invokeRestart
[17:00:34.589]                       is.null <- base::is.null
[17:00:34.589]                       muffled <- FALSE
[17:00:34.589]                       if (inherits(cond, "message")) {
[17:00:34.589]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.589]                         if (muffled) 
[17:00:34.589]                           invokeRestart("muffleMessage")
[17:00:34.589]                       }
[17:00:34.589]                       else if (inherits(cond, "warning")) {
[17:00:34.589]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.589]                         if (muffled) 
[17:00:34.589]                           invokeRestart("muffleWarning")
[17:00:34.589]                       }
[17:00:34.589]                       else if (inherits(cond, "condition")) {
[17:00:34.589]                         if (!is.null(pattern)) {
[17:00:34.589]                           computeRestarts <- base::computeRestarts
[17:00:34.589]                           grepl <- base::grepl
[17:00:34.589]                           restarts <- computeRestarts(cond)
[17:00:34.589]                           for (restart in restarts) {
[17:00:34.589]                             name <- restart$name
[17:00:34.589]                             if (is.null(name)) 
[17:00:34.589]                               next
[17:00:34.589]                             if (!grepl(pattern, name)) 
[17:00:34.589]                               next
[17:00:34.589]                             invokeRestart(restart)
[17:00:34.589]                             muffled <- TRUE
[17:00:34.589]                             break
[17:00:34.589]                           }
[17:00:34.589]                         }
[17:00:34.589]                       }
[17:00:34.589]                       invisible(muffled)
[17:00:34.589]                     }
[17:00:34.589]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.589]                   }
[17:00:34.589]                 }
[17:00:34.589]             }
[17:00:34.589]         }))
[17:00:34.589]     }, error = function(ex) {
[17:00:34.589]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.589]                 ...future.rng), started = ...future.startTime, 
[17:00:34.589]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.589]             version = "1.8"), class = "FutureResult")
[17:00:34.589]     }, finally = {
[17:00:34.589]         if (!identical(...future.workdir, getwd())) 
[17:00:34.589]             setwd(...future.workdir)
[17:00:34.589]         {
[17:00:34.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.589]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.589]             }
[17:00:34.589]             base::options(...future.oldOptions)
[17:00:34.589]             if (.Platform$OS.type == "windows") {
[17:00:34.589]                 old_names <- names(...future.oldEnvVars)
[17:00:34.589]                 envs <- base::Sys.getenv()
[17:00:34.589]                 names <- names(envs)
[17:00:34.589]                 common <- intersect(names, old_names)
[17:00:34.589]                 added <- setdiff(names, old_names)
[17:00:34.589]                 removed <- setdiff(old_names, names)
[17:00:34.589]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.589]                   envs[common]]
[17:00:34.589]                 NAMES <- toupper(changed)
[17:00:34.589]                 args <- list()
[17:00:34.589]                 for (kk in seq_along(NAMES)) {
[17:00:34.589]                   name <- changed[[kk]]
[17:00:34.589]                   NAME <- NAMES[[kk]]
[17:00:34.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.589]                     next
[17:00:34.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.589]                 }
[17:00:34.589]                 NAMES <- toupper(added)
[17:00:34.589]                 for (kk in seq_along(NAMES)) {
[17:00:34.589]                   name <- added[[kk]]
[17:00:34.589]                   NAME <- NAMES[[kk]]
[17:00:34.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.589]                     next
[17:00:34.589]                   args[[name]] <- ""
[17:00:34.589]                 }
[17:00:34.589]                 NAMES <- toupper(removed)
[17:00:34.589]                 for (kk in seq_along(NAMES)) {
[17:00:34.589]                   name <- removed[[kk]]
[17:00:34.589]                   NAME <- NAMES[[kk]]
[17:00:34.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.589]                     next
[17:00:34.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.589]                 }
[17:00:34.589]                 if (length(args) > 0) 
[17:00:34.589]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.589]             }
[17:00:34.589]             else {
[17:00:34.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.589]             }
[17:00:34.589]             {
[17:00:34.589]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.589]                   0L) {
[17:00:34.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.589]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.589]                   base::options(opts)
[17:00:34.589]                 }
[17:00:34.589]                 {
[17:00:34.589]                   {
[17:00:34.589]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.589]                     NULL
[17:00:34.589]                   }
[17:00:34.589]                   options(future.plan = NULL)
[17:00:34.589]                   if (is.na(NA_character_)) 
[17:00:34.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.589]                     .init = FALSE)
[17:00:34.589]                 }
[17:00:34.589]             }
[17:00:34.589]         }
[17:00:34.589]     })
[17:00:34.589]     if (TRUE) {
[17:00:34.589]         base::sink(type = "output", split = FALSE)
[17:00:34.589]         if (TRUE) {
[17:00:34.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.589]         }
[17:00:34.589]         else {
[17:00:34.589]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.589]         }
[17:00:34.589]         base::close(...future.stdout)
[17:00:34.589]         ...future.stdout <- NULL
[17:00:34.589]     }
[17:00:34.589]     ...future.result$conditions <- ...future.conditions
[17:00:34.589]     ...future.result$finished <- base::Sys.time()
[17:00:34.589]     ...future.result
[17:00:34.589] }
[17:00:34.592] Exporting 5 global objects (1.85 KiB) to cluster node #1 ...
[17:00:34.592] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[17:00:34.592] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[17:00:34.593] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:00:34.593] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:00:34.593] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:00:34.593] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:00:34.593] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[17:00:34.594] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[17:00:34.594] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:34.594] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.594] Exporting 5 global objects (1.85 KiB) to cluster node #1 ... DONE
[17:00:34.595] MultisessionFuture started
[17:00:34.595] - Launch lazy future ... done
[17:00:34.595] run() for ‘MultisessionFuture’ ... done
[17:00:34.595] Created future:
[17:00:34.595] MultisessionFuture:
[17:00:34.595] Label: ‘future_mapply-1’
[17:00:34.595] Expression:
[17:00:34.595] {
[17:00:34.595]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.595]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.595]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.595]         on.exit(options(oopts), add = TRUE)
[17:00:34.595]     }
[17:00:34.595]     {
[17:00:34.595]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:34.595]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:34.595]                 inherits = FALSE)
[17:00:34.595]             ...future.FUN(...)
[17:00:34.595]         }
[17:00:34.595]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:34.595]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:34.595]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.595]         do.call(mapply, args = args)
[17:00:34.595]     }
[17:00:34.595] }
[17:00:34.595] Lazy evaluation: FALSE
[17:00:34.595] Asynchronous evaluation: TRUE
[17:00:34.595] Local evaluation: TRUE
[17:00:34.595] Environment: R_GlobalEnv
[17:00:34.595] Capture standard output: TRUE
[17:00:34.595] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.595] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.595] Packages: <none>
[17:00:34.595] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:34.595] Resolved: FALSE
[17:00:34.595] Value: <not collected>
[17:00:34.595] Conditions captured: <none>
[17:00:34.595] Early signaling: FALSE
[17:00:34.595] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.595] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.607] Chunk #1 of 2 ... DONE
[17:00:34.607] Chunk #2 of 2 ...
[17:00:34.607]  - Finding globals in '...' for chunk #2 ...
[17:00:34.607] getGlobalsAndPackages() ...
[17:00:34.607] Searching for globals...
[17:00:34.608] 
[17:00:34.608] Searching for globals ... DONE
[17:00:34.608] - globals: [0] <none>
[17:00:34.608] getGlobalsAndPackages() ... DONE
[17:00:34.608]    + additional globals found: [n=0] 
[17:00:34.608]    + additional namespaces needed: [n=0] 
[17:00:34.608]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:34.608]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.608]  - seeds: [1] <seeds>
[17:00:34.609]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.609] getGlobalsAndPackages() ...
[17:00:34.609] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.609] Resolving globals: FALSE
[17:00:34.612] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:00:34.613] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:00:34.613] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.613] 
[17:00:34.613] getGlobalsAndPackages() ... DONE
[17:00:34.613] run() for ‘Future’ ...
[17:00:34.613] - state: ‘created’
[17:00:34.613] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.628] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.628] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.628]   - Field: ‘node’
[17:00:34.629]   - Field: ‘label’
[17:00:34.629]   - Field: ‘local’
[17:00:34.629]   - Field: ‘owner’
[17:00:34.629]   - Field: ‘envir’
[17:00:34.629]   - Field: ‘workers’
[17:00:34.629]   - Field: ‘packages’
[17:00:34.629]   - Field: ‘gc’
[17:00:34.629]   - Field: ‘conditions’
[17:00:34.629]   - Field: ‘persistent’
[17:00:34.629]   - Field: ‘expr’
[17:00:34.629]   - Field: ‘uuid’
[17:00:34.630]   - Field: ‘seed’
[17:00:34.630]   - Field: ‘version’
[17:00:34.630]   - Field: ‘result’
[17:00:34.630]   - Field: ‘asynchronous’
[17:00:34.630]   - Field: ‘calls’
[17:00:34.630]   - Field: ‘globals’
[17:00:34.630]   - Field: ‘stdout’
[17:00:34.630]   - Field: ‘earlySignal’
[17:00:34.630]   - Field: ‘lazy’
[17:00:34.630]   - Field: ‘state’
[17:00:34.630] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.631] - Launch lazy future ...
[17:00:34.631] Packages needed by the future expression (n = 0): <none>
[17:00:34.631] Packages needed by future strategies (n = 0): <none>
[17:00:34.631] {
[17:00:34.631]     {
[17:00:34.631]         {
[17:00:34.631]             ...future.startTime <- base::Sys.time()
[17:00:34.631]             {
[17:00:34.631]                 {
[17:00:34.631]                   {
[17:00:34.631]                     {
[17:00:34.631]                       base::local({
[17:00:34.631]                         has_future <- base::requireNamespace("future", 
[17:00:34.631]                           quietly = TRUE)
[17:00:34.631]                         if (has_future) {
[17:00:34.631]                           ns <- base::getNamespace("future")
[17:00:34.631]                           version <- ns[[".package"]][["version"]]
[17:00:34.631]                           if (is.null(version)) 
[17:00:34.631]                             version <- utils::packageVersion("future")
[17:00:34.631]                         }
[17:00:34.631]                         else {
[17:00:34.631]                           version <- NULL
[17:00:34.631]                         }
[17:00:34.631]                         if (!has_future || version < "1.8.0") {
[17:00:34.631]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.631]                             "", base::R.version$version.string), 
[17:00:34.631]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.631]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.631]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.631]                               "release", "version")], collapse = " "), 
[17:00:34.631]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.631]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.631]                             info)
[17:00:34.631]                           info <- base::paste(info, collapse = "; ")
[17:00:34.631]                           if (!has_future) {
[17:00:34.631]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.631]                               info)
[17:00:34.631]                           }
[17:00:34.631]                           else {
[17:00:34.631]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.631]                               info, version)
[17:00:34.631]                           }
[17:00:34.631]                           base::stop(msg)
[17:00:34.631]                         }
[17:00:34.631]                       })
[17:00:34.631]                     }
[17:00:34.631]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.631]                     base::options(mc.cores = 1L)
[17:00:34.631]                   }
[17:00:34.631]                   ...future.strategy.old <- future::plan("list")
[17:00:34.631]                   options(future.plan = NULL)
[17:00:34.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.631]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.631]                 }
[17:00:34.631]                 ...future.workdir <- getwd()
[17:00:34.631]             }
[17:00:34.631]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.631]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.631]         }
[17:00:34.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.631]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.631]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.631]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.631]             base::names(...future.oldOptions))
[17:00:34.631]     }
[17:00:34.631]     if (FALSE) {
[17:00:34.631]     }
[17:00:34.631]     else {
[17:00:34.631]         if (TRUE) {
[17:00:34.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.631]                 open = "w")
[17:00:34.631]         }
[17:00:34.631]         else {
[17:00:34.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.631]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.631]         }
[17:00:34.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.631]             base::sink(type = "output", split = FALSE)
[17:00:34.631]             base::close(...future.stdout)
[17:00:34.631]         }, add = TRUE)
[17:00:34.631]     }
[17:00:34.631]     ...future.frame <- base::sys.nframe()
[17:00:34.631]     ...future.conditions <- base::list()
[17:00:34.631]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.631]     if (FALSE) {
[17:00:34.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.631]     }
[17:00:34.631]     ...future.result <- base::tryCatch({
[17:00:34.631]         base::withCallingHandlers({
[17:00:34.631]             ...future.value <- base::withVisible(base::local({
[17:00:34.631]                 ...future.makeSendCondition <- base::local({
[17:00:34.631]                   sendCondition <- NULL
[17:00:34.631]                   function(frame = 1L) {
[17:00:34.631]                     if (is.function(sendCondition)) 
[17:00:34.631]                       return(sendCondition)
[17:00:34.631]                     ns <- getNamespace("parallel")
[17:00:34.631]                     if (exists("sendData", mode = "function", 
[17:00:34.631]                       envir = ns)) {
[17:00:34.631]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.631]                         envir = ns)
[17:00:34.631]                       envir <- sys.frame(frame)
[17:00:34.631]                       master <- NULL
[17:00:34.631]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.631]                         !identical(envir, emptyenv())) {
[17:00:34.631]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.631]                           inherits = FALSE)) {
[17:00:34.631]                           master <- get("master", mode = "list", 
[17:00:34.631]                             envir = envir, inherits = FALSE)
[17:00:34.631]                           if (inherits(master, c("SOCKnode", 
[17:00:34.631]                             "SOCK0node"))) {
[17:00:34.631]                             sendCondition <<- function(cond) {
[17:00:34.631]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.631]                                 success = TRUE)
[17:00:34.631]                               parallel_sendData(master, data)
[17:00:34.631]                             }
[17:00:34.631]                             return(sendCondition)
[17:00:34.631]                           }
[17:00:34.631]                         }
[17:00:34.631]                         frame <- frame + 1L
[17:00:34.631]                         envir <- sys.frame(frame)
[17:00:34.631]                       }
[17:00:34.631]                     }
[17:00:34.631]                     sendCondition <<- function(cond) NULL
[17:00:34.631]                   }
[17:00:34.631]                 })
[17:00:34.631]                 withCallingHandlers({
[17:00:34.631]                   {
[17:00:34.631]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.631]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.631]                       ...future.globals.maxSize)) {
[17:00:34.631]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.631]                       on.exit(options(oopts), add = TRUE)
[17:00:34.631]                     }
[17:00:34.631]                     {
[17:00:34.631]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:34.631]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:34.631]                           envir = globalenv(), inherits = FALSE)
[17:00:34.631]                         ...future.FUN(...)
[17:00:34.631]                       }
[17:00:34.631]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:34.631]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:34.631]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.631]                         USE.NAMES = FALSE)
[17:00:34.631]                       do.call(mapply, args = args)
[17:00:34.631]                     }
[17:00:34.631]                   }
[17:00:34.631]                 }, immediateCondition = function(cond) {
[17:00:34.631]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.631]                   sendCondition(cond)
[17:00:34.631]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.631]                   {
[17:00:34.631]                     inherits <- base::inherits
[17:00:34.631]                     invokeRestart <- base::invokeRestart
[17:00:34.631]                     is.null <- base::is.null
[17:00:34.631]                     muffled <- FALSE
[17:00:34.631]                     if (inherits(cond, "message")) {
[17:00:34.631]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.631]                       if (muffled) 
[17:00:34.631]                         invokeRestart("muffleMessage")
[17:00:34.631]                     }
[17:00:34.631]                     else if (inherits(cond, "warning")) {
[17:00:34.631]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.631]                       if (muffled) 
[17:00:34.631]                         invokeRestart("muffleWarning")
[17:00:34.631]                     }
[17:00:34.631]                     else if (inherits(cond, "condition")) {
[17:00:34.631]                       if (!is.null(pattern)) {
[17:00:34.631]                         computeRestarts <- base::computeRestarts
[17:00:34.631]                         grepl <- base::grepl
[17:00:34.631]                         restarts <- computeRestarts(cond)
[17:00:34.631]                         for (restart in restarts) {
[17:00:34.631]                           name <- restart$name
[17:00:34.631]                           if (is.null(name)) 
[17:00:34.631]                             next
[17:00:34.631]                           if (!grepl(pattern, name)) 
[17:00:34.631]                             next
[17:00:34.631]                           invokeRestart(restart)
[17:00:34.631]                           muffled <- TRUE
[17:00:34.631]                           break
[17:00:34.631]                         }
[17:00:34.631]                       }
[17:00:34.631]                     }
[17:00:34.631]                     invisible(muffled)
[17:00:34.631]                   }
[17:00:34.631]                   muffleCondition(cond)
[17:00:34.631]                 })
[17:00:34.631]             }))
[17:00:34.631]             future::FutureResult(value = ...future.value$value, 
[17:00:34.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.631]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.631]                     ...future.globalenv.names))
[17:00:34.631]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.631]         }, condition = base::local({
[17:00:34.631]             c <- base::c
[17:00:34.631]             inherits <- base::inherits
[17:00:34.631]             invokeRestart <- base::invokeRestart
[17:00:34.631]             length <- base::length
[17:00:34.631]             list <- base::list
[17:00:34.631]             seq.int <- base::seq.int
[17:00:34.631]             signalCondition <- base::signalCondition
[17:00:34.631]             sys.calls <- base::sys.calls
[17:00:34.631]             `[[` <- base::`[[`
[17:00:34.631]             `+` <- base::`+`
[17:00:34.631]             `<<-` <- base::`<<-`
[17:00:34.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.631]                   3L)]
[17:00:34.631]             }
[17:00:34.631]             function(cond) {
[17:00:34.631]                 is_error <- inherits(cond, "error")
[17:00:34.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.631]                   NULL)
[17:00:34.631]                 if (is_error) {
[17:00:34.631]                   sessionInformation <- function() {
[17:00:34.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.631]                       search = base::search(), system = base::Sys.info())
[17:00:34.631]                   }
[17:00:34.631]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.631]                     cond$call), session = sessionInformation(), 
[17:00:34.631]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.631]                   signalCondition(cond)
[17:00:34.631]                 }
[17:00:34.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.631]                 "immediateCondition"))) {
[17:00:34.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.631]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.631]                   if (TRUE && !signal) {
[17:00:34.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.631]                     {
[17:00:34.631]                       inherits <- base::inherits
[17:00:34.631]                       invokeRestart <- base::invokeRestart
[17:00:34.631]                       is.null <- base::is.null
[17:00:34.631]                       muffled <- FALSE
[17:00:34.631]                       if (inherits(cond, "message")) {
[17:00:34.631]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.631]                         if (muffled) 
[17:00:34.631]                           invokeRestart("muffleMessage")
[17:00:34.631]                       }
[17:00:34.631]                       else if (inherits(cond, "warning")) {
[17:00:34.631]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.631]                         if (muffled) 
[17:00:34.631]                           invokeRestart("muffleWarning")
[17:00:34.631]                       }
[17:00:34.631]                       else if (inherits(cond, "condition")) {
[17:00:34.631]                         if (!is.null(pattern)) {
[17:00:34.631]                           computeRestarts <- base::computeRestarts
[17:00:34.631]                           grepl <- base::grepl
[17:00:34.631]                           restarts <- computeRestarts(cond)
[17:00:34.631]                           for (restart in restarts) {
[17:00:34.631]                             name <- restart$name
[17:00:34.631]                             if (is.null(name)) 
[17:00:34.631]                               next
[17:00:34.631]                             if (!grepl(pattern, name)) 
[17:00:34.631]                               next
[17:00:34.631]                             invokeRestart(restart)
[17:00:34.631]                             muffled <- TRUE
[17:00:34.631]                             break
[17:00:34.631]                           }
[17:00:34.631]                         }
[17:00:34.631]                       }
[17:00:34.631]                       invisible(muffled)
[17:00:34.631]                     }
[17:00:34.631]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.631]                   }
[17:00:34.631]                 }
[17:00:34.631]                 else {
[17:00:34.631]                   if (TRUE) {
[17:00:34.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.631]                     {
[17:00:34.631]                       inherits <- base::inherits
[17:00:34.631]                       invokeRestart <- base::invokeRestart
[17:00:34.631]                       is.null <- base::is.null
[17:00:34.631]                       muffled <- FALSE
[17:00:34.631]                       if (inherits(cond, "message")) {
[17:00:34.631]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.631]                         if (muffled) 
[17:00:34.631]                           invokeRestart("muffleMessage")
[17:00:34.631]                       }
[17:00:34.631]                       else if (inherits(cond, "warning")) {
[17:00:34.631]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.631]                         if (muffled) 
[17:00:34.631]                           invokeRestart("muffleWarning")
[17:00:34.631]                       }
[17:00:34.631]                       else if (inherits(cond, "condition")) {
[17:00:34.631]                         if (!is.null(pattern)) {
[17:00:34.631]                           computeRestarts <- base::computeRestarts
[17:00:34.631]                           grepl <- base::grepl
[17:00:34.631]                           restarts <- computeRestarts(cond)
[17:00:34.631]                           for (restart in restarts) {
[17:00:34.631]                             name <- restart$name
[17:00:34.631]                             if (is.null(name)) 
[17:00:34.631]                               next
[17:00:34.631]                             if (!grepl(pattern, name)) 
[17:00:34.631]                               next
[17:00:34.631]                             invokeRestart(restart)
[17:00:34.631]                             muffled <- TRUE
[17:00:34.631]                             break
[17:00:34.631]                           }
[17:00:34.631]                         }
[17:00:34.631]                       }
[17:00:34.631]                       invisible(muffled)
[17:00:34.631]                     }
[17:00:34.631]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.631]                   }
[17:00:34.631]                 }
[17:00:34.631]             }
[17:00:34.631]         }))
[17:00:34.631]     }, error = function(ex) {
[17:00:34.631]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.631]                 ...future.rng), started = ...future.startTime, 
[17:00:34.631]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.631]             version = "1.8"), class = "FutureResult")
[17:00:34.631]     }, finally = {
[17:00:34.631]         if (!identical(...future.workdir, getwd())) 
[17:00:34.631]             setwd(...future.workdir)
[17:00:34.631]         {
[17:00:34.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.631]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.631]             }
[17:00:34.631]             base::options(...future.oldOptions)
[17:00:34.631]             if (.Platform$OS.type == "windows") {
[17:00:34.631]                 old_names <- names(...future.oldEnvVars)
[17:00:34.631]                 envs <- base::Sys.getenv()
[17:00:34.631]                 names <- names(envs)
[17:00:34.631]                 common <- intersect(names, old_names)
[17:00:34.631]                 added <- setdiff(names, old_names)
[17:00:34.631]                 removed <- setdiff(old_names, names)
[17:00:34.631]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.631]                   envs[common]]
[17:00:34.631]                 NAMES <- toupper(changed)
[17:00:34.631]                 args <- list()
[17:00:34.631]                 for (kk in seq_along(NAMES)) {
[17:00:34.631]                   name <- changed[[kk]]
[17:00:34.631]                   NAME <- NAMES[[kk]]
[17:00:34.631]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.631]                     next
[17:00:34.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.631]                 }
[17:00:34.631]                 NAMES <- toupper(added)
[17:00:34.631]                 for (kk in seq_along(NAMES)) {
[17:00:34.631]                   name <- added[[kk]]
[17:00:34.631]                   NAME <- NAMES[[kk]]
[17:00:34.631]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.631]                     next
[17:00:34.631]                   args[[name]] <- ""
[17:00:34.631]                 }
[17:00:34.631]                 NAMES <- toupper(removed)
[17:00:34.631]                 for (kk in seq_along(NAMES)) {
[17:00:34.631]                   name <- removed[[kk]]
[17:00:34.631]                   NAME <- NAMES[[kk]]
[17:00:34.631]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.631]                     next
[17:00:34.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.631]                 }
[17:00:34.631]                 if (length(args) > 0) 
[17:00:34.631]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.631]             }
[17:00:34.631]             else {
[17:00:34.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.631]             }
[17:00:34.631]             {
[17:00:34.631]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.631]                   0L) {
[17:00:34.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.631]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.631]                   base::options(opts)
[17:00:34.631]                 }
[17:00:34.631]                 {
[17:00:34.631]                   {
[17:00:34.631]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.631]                     NULL
[17:00:34.631]                   }
[17:00:34.631]                   options(future.plan = NULL)
[17:00:34.631]                   if (is.na(NA_character_)) 
[17:00:34.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.631]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.631]                     .init = FALSE)
[17:00:34.631]                 }
[17:00:34.631]             }
[17:00:34.631]         }
[17:00:34.631]     })
[17:00:34.631]     if (TRUE) {
[17:00:34.631]         base::sink(type = "output", split = FALSE)
[17:00:34.631]         if (TRUE) {
[17:00:34.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.631]         }
[17:00:34.631]         else {
[17:00:34.631]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.631]         }
[17:00:34.631]         base::close(...future.stdout)
[17:00:34.631]         ...future.stdout <- NULL
[17:00:34.631]     }
[17:00:34.631]     ...future.result$conditions <- ...future.conditions
[17:00:34.631]     ...future.result$finished <- base::Sys.time()
[17:00:34.631]     ...future.result
[17:00:34.631] }
[17:00:34.634] Exporting 5 global objects (1.85 KiB) to cluster node #2 ...
[17:00:34.635] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[17:00:34.635] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[17:00:34.635] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:00:34.635] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:00:34.636] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:00:34.636] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:00:34.636] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[17:00:34.636] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[17:00:34.637] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:34.637] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.637] Exporting 5 global objects (1.85 KiB) to cluster node #2 ... DONE
[17:00:34.638] MultisessionFuture started
[17:00:34.638] - Launch lazy future ... done
[17:00:34.638] run() for ‘MultisessionFuture’ ... done
[17:00:34.638] Created future:
[17:00:34.638] MultisessionFuture:
[17:00:34.638] Label: ‘future_mapply-2’
[17:00:34.638] Expression:
[17:00:34.638] {
[17:00:34.638]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.638]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.638]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.638]         on.exit(options(oopts), add = TRUE)
[17:00:34.638]     }
[17:00:34.638]     {
[17:00:34.638]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:34.638]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:34.638]                 inherits = FALSE)
[17:00:34.638]             ...future.FUN(...)
[17:00:34.638]         }
[17:00:34.638]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:34.638]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:34.638]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.638]         do.call(mapply, args = args)
[17:00:34.638]     }
[17:00:34.638] }
[17:00:34.638] Lazy evaluation: FALSE
[17:00:34.638] Asynchronous evaluation: TRUE
[17:00:34.638] Local evaluation: TRUE
[17:00:34.638] Environment: R_GlobalEnv
[17:00:34.638] Capture standard output: TRUE
[17:00:34.638] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.638] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.638] Packages: <none>
[17:00:34.638] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:34.638] Resolved: FALSE
[17:00:34.638] Value: <not collected>
[17:00:34.638] Conditions captured: <none>
[17:00:34.638] Early signaling: FALSE
[17:00:34.638] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.638] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.650] Chunk #2 of 2 ... DONE
[17:00:34.650] Launching 2 futures (chunks) ... DONE
[17:00:34.650] Resolving 2 futures (chunks) ...
[17:00:34.650] resolve() on list ...
[17:00:34.650]  recursive: 0
[17:00:34.650]  length: 2
[17:00:34.651] 
[17:00:34.651] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.651] - Validating connection of MultisessionFuture
[17:00:34.651] - received message: FutureResult
[17:00:34.652] - Received FutureResult
[17:00:34.652] - Erased future from FutureRegistry
[17:00:34.652] result() for ClusterFuture ...
[17:00:34.652] - result already collected: FutureResult
[17:00:34.652] result() for ClusterFuture ... done
[17:00:34.652] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.652] Future #1
[17:00:34.652] result() for ClusterFuture ...
[17:00:34.652] - result already collected: FutureResult
[17:00:34.652] result() for ClusterFuture ... done
[17:00:34.652] result() for ClusterFuture ...
[17:00:34.653] - result already collected: FutureResult
[17:00:34.653] result() for ClusterFuture ... done
[17:00:34.653] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:34.653] - nx: 2
[17:00:34.653] - relay: TRUE
[17:00:34.653] - stdout: TRUE
[17:00:34.653] - signal: TRUE
[17:00:34.653] - resignal: FALSE
[17:00:34.653] - force: TRUE
[17:00:34.653] - relayed: [n=2] FALSE, FALSE
[17:00:34.653] - queued futures: [n=2] FALSE, FALSE
[17:00:34.653]  - until=1
[17:00:34.654]  - relaying element #1
[17:00:34.654] result() for ClusterFuture ...
[17:00:34.654] - result already collected: FutureResult
[17:00:34.654] result() for ClusterFuture ... done
[17:00:34.654] result() for ClusterFuture ...
[17:00:34.654] - result already collected: FutureResult
[17:00:34.654] result() for ClusterFuture ... done
[17:00:34.654] result() for ClusterFuture ...
[17:00:34.654] - result already collected: FutureResult
[17:00:34.654] result() for ClusterFuture ... done
[17:00:34.654] result() for ClusterFuture ...
[17:00:34.654] - result already collected: FutureResult
[17:00:34.655] result() for ClusterFuture ... done
[17:00:34.655] - relayed: [n=2] TRUE, FALSE
[17:00:34.655] - queued futures: [n=2] TRUE, FALSE
[17:00:34.655] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:34.655]  length: 1 (resolved future 1)
[17:00:34.681] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.681] - Validating connection of MultisessionFuture
[17:00:34.681] - received message: FutureResult
[17:00:34.681] - Received FutureResult
[17:00:34.682] - Erased future from FutureRegistry
[17:00:34.682] result() for ClusterFuture ...
[17:00:34.682] - result already collected: FutureResult
[17:00:34.682] result() for ClusterFuture ... done
[17:00:34.682] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.682] Future #2
[17:00:34.682] result() for ClusterFuture ...
[17:00:34.682] - result already collected: FutureResult
[17:00:34.682] result() for ClusterFuture ... done
[17:00:34.682] result() for ClusterFuture ...
[17:00:34.683] - result already collected: FutureResult
[17:00:34.683] result() for ClusterFuture ... done
[17:00:34.683] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:34.683] - nx: 2
[17:00:34.683] - relay: TRUE
[17:00:34.683] - stdout: TRUE
[17:00:34.683] - signal: TRUE
[17:00:34.683] - resignal: FALSE
[17:00:34.683] - force: TRUE
[17:00:34.683] - relayed: [n=2] TRUE, FALSE
[17:00:34.683] - queued futures: [n=2] TRUE, FALSE
[17:00:34.684]  - until=2
[17:00:34.684]  - relaying element #2
[17:00:34.684] result() for ClusterFuture ...
[17:00:34.684] - result already collected: FutureResult
[17:00:34.684] result() for ClusterFuture ... done
[17:00:34.684] result() for ClusterFuture ...
[17:00:34.684] - result already collected: FutureResult
[17:00:34.684] result() for ClusterFuture ... done
[17:00:34.684] result() for ClusterFuture ...
[17:00:34.684] - result already collected: FutureResult
[17:00:34.684] result() for ClusterFuture ... done
[17:00:34.685] result() for ClusterFuture ...
[17:00:34.685] - result already collected: FutureResult
[17:00:34.685] result() for ClusterFuture ... done
[17:00:34.685] - relayed: [n=2] TRUE, TRUE
[17:00:34.685] - queued futures: [n=2] TRUE, TRUE
[17:00:34.685] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:34.685]  length: 0 (resolved future 2)
[17:00:34.685] Relaying remaining futures
[17:00:34.685] signalConditionsASAP(NULL, pos=0) ...
[17:00:34.685] - nx: 2
[17:00:34.685] - relay: TRUE
[17:00:34.685] - stdout: TRUE
[17:00:34.686] - signal: TRUE
[17:00:34.686] - resignal: FALSE
[17:00:34.686] - force: TRUE
[17:00:34.686] - relayed: [n=2] TRUE, TRUE
[17:00:34.686] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:34.686] - relayed: [n=2] TRUE, TRUE
[17:00:34.686] - queued futures: [n=2] TRUE, TRUE
[17:00:34.686] signalConditionsASAP(NULL, pos=0) ... done
[17:00:34.686] resolve() on list ... DONE
[17:00:34.686] result() for ClusterFuture ...
[17:00:34.686] - result already collected: FutureResult
[17:00:34.687] result() for ClusterFuture ... done
[17:00:34.687] result() for ClusterFuture ...
[17:00:34.687] - result already collected: FutureResult
[17:00:34.687] result() for ClusterFuture ... done
[17:00:34.687] result() for ClusterFuture ...
[17:00:34.687] - result already collected: FutureResult
[17:00:34.687] result() for ClusterFuture ... done
[17:00:34.687] result() for ClusterFuture ...
[17:00:34.687] - result already collected: FutureResult
[17:00:34.687] result() for ClusterFuture ... done
[17:00:34.687]  - Number of value chunks collected: 2
[17:00:34.688] Resolving 2 futures (chunks) ... DONE
[17:00:34.688] Reducing values from 2 chunks ...
[17:00:34.688]  - Number of values collected after concatenation: 2
[17:00:34.688]  - Number of values expected: 2
[17:00:34.688] Reducing values from 2 chunks ... DONE
[17:00:34.688] future_mapply() ... DONE
[17:00:34.688] future_mapply() ...
[17:00:34.692] Number of chunks: 2
[17:00:34.692] getGlobalsAndPackagesXApply() ...
[17:00:34.692]  - future.globals: TRUE
[17:00:34.692] getGlobalsAndPackages() ...
[17:00:34.692] Searching for globals...
[17:00:34.694] - globals found: [1] ‘FUN’
[17:00:34.694] Searching for globals ... DONE
[17:00:34.694] Resolving globals: FALSE
[17:00:34.694] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:00:34.694] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:00:34.695] - globals: [1] ‘FUN’
[17:00:34.695] 
[17:00:34.695] getGlobalsAndPackages() ... DONE
[17:00:34.695]  - globals found/used: [n=1] ‘FUN’
[17:00:34.695]  - needed namespaces: [n=0] 
[17:00:34.695] Finding globals ... DONE
[17:00:34.695] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:34.695] List of 2
[17:00:34.695]  $ ...future.FUN:function (x, y)  
[17:00:34.695]  $ MoreArgs     :List of 1
[17:00:34.695]   ..$ y: int [1:2] 3 4
[17:00:34.695]  - attr(*, "where")=List of 2
[17:00:34.695]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:34.695]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:34.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:34.695]  - attr(*, "resolved")= logi FALSE
[17:00:34.695]  - attr(*, "total_size")= num NA
[17:00:34.698] Packages to be attached in all futures: [n=0] 
[17:00:34.698] getGlobalsAndPackagesXApply() ... DONE
[17:00:34.698] Number of futures (= number of chunks): 2
[17:00:34.699] Launching 2 futures (chunks) ...
[17:00:34.699] Chunk #1 of 2 ...
[17:00:34.699]  - Finding globals in '...' for chunk #1 ...
[17:00:34.699] getGlobalsAndPackages() ...
[17:00:34.699] Searching for globals...
[17:00:34.699] 
[17:00:34.699] Searching for globals ... DONE
[17:00:34.699] - globals: [0] <none>
[17:00:34.700] getGlobalsAndPackages() ... DONE
[17:00:34.700]    + additional globals found: [n=0] 
[17:00:34.700]    + additional namespaces needed: [n=0] 
[17:00:34.700]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:34.700]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.700]  - seeds: <none>
[17:00:34.700]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.700] getGlobalsAndPackages() ...
[17:00:34.700] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.700] Resolving globals: FALSE
[17:00:34.701] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:00:34.701] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:00:34.701] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.701] 
[17:00:34.702] getGlobalsAndPackages() ... DONE
[17:00:34.702] run() for ‘Future’ ...
[17:00:34.702] - state: ‘created’
[17:00:34.702] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.716] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.717]   - Field: ‘node’
[17:00:34.717]   - Field: ‘label’
[17:00:34.717]   - Field: ‘local’
[17:00:34.717]   - Field: ‘owner’
[17:00:34.717]   - Field: ‘envir’
[17:00:34.717]   - Field: ‘workers’
[17:00:34.717]   - Field: ‘packages’
[17:00:34.717]   - Field: ‘gc’
[17:00:34.717]   - Field: ‘conditions’
[17:00:34.717]   - Field: ‘persistent’
[17:00:34.718]   - Field: ‘expr’
[17:00:34.718]   - Field: ‘uuid’
[17:00:34.718]   - Field: ‘seed’
[17:00:34.718]   - Field: ‘version’
[17:00:34.718]   - Field: ‘result’
[17:00:34.718]   - Field: ‘asynchronous’
[17:00:34.718]   - Field: ‘calls’
[17:00:34.718]   - Field: ‘globals’
[17:00:34.718]   - Field: ‘stdout’
[17:00:34.718]   - Field: ‘earlySignal’
[17:00:34.718]   - Field: ‘lazy’
[17:00:34.719]   - Field: ‘state’
[17:00:34.719] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.719] - Launch lazy future ...
[17:00:34.719] Packages needed by the future expression (n = 0): <none>
[17:00:34.719] Packages needed by future strategies (n = 0): <none>
[17:00:34.720] {
[17:00:34.720]     {
[17:00:34.720]         {
[17:00:34.720]             ...future.startTime <- base::Sys.time()
[17:00:34.720]             {
[17:00:34.720]                 {
[17:00:34.720]                   {
[17:00:34.720]                     {
[17:00:34.720]                       base::local({
[17:00:34.720]                         has_future <- base::requireNamespace("future", 
[17:00:34.720]                           quietly = TRUE)
[17:00:34.720]                         if (has_future) {
[17:00:34.720]                           ns <- base::getNamespace("future")
[17:00:34.720]                           version <- ns[[".package"]][["version"]]
[17:00:34.720]                           if (is.null(version)) 
[17:00:34.720]                             version <- utils::packageVersion("future")
[17:00:34.720]                         }
[17:00:34.720]                         else {
[17:00:34.720]                           version <- NULL
[17:00:34.720]                         }
[17:00:34.720]                         if (!has_future || version < "1.8.0") {
[17:00:34.720]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.720]                             "", base::R.version$version.string), 
[17:00:34.720]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.720]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.720]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.720]                               "release", "version")], collapse = " "), 
[17:00:34.720]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.720]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.720]                             info)
[17:00:34.720]                           info <- base::paste(info, collapse = "; ")
[17:00:34.720]                           if (!has_future) {
[17:00:34.720]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.720]                               info)
[17:00:34.720]                           }
[17:00:34.720]                           else {
[17:00:34.720]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.720]                               info, version)
[17:00:34.720]                           }
[17:00:34.720]                           base::stop(msg)
[17:00:34.720]                         }
[17:00:34.720]                       })
[17:00:34.720]                     }
[17:00:34.720]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.720]                     base::options(mc.cores = 1L)
[17:00:34.720]                   }
[17:00:34.720]                   ...future.strategy.old <- future::plan("list")
[17:00:34.720]                   options(future.plan = NULL)
[17:00:34.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.720]                 }
[17:00:34.720]                 ...future.workdir <- getwd()
[17:00:34.720]             }
[17:00:34.720]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.720]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.720]         }
[17:00:34.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.720]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.720]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.720]             base::names(...future.oldOptions))
[17:00:34.720]     }
[17:00:34.720]     if (FALSE) {
[17:00:34.720]     }
[17:00:34.720]     else {
[17:00:34.720]         if (TRUE) {
[17:00:34.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.720]                 open = "w")
[17:00:34.720]         }
[17:00:34.720]         else {
[17:00:34.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.720]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.720]         }
[17:00:34.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.720]             base::sink(type = "output", split = FALSE)
[17:00:34.720]             base::close(...future.stdout)
[17:00:34.720]         }, add = TRUE)
[17:00:34.720]     }
[17:00:34.720]     ...future.frame <- base::sys.nframe()
[17:00:34.720]     ...future.conditions <- base::list()
[17:00:34.720]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.720]     if (FALSE) {
[17:00:34.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.720]     }
[17:00:34.720]     ...future.result <- base::tryCatch({
[17:00:34.720]         base::withCallingHandlers({
[17:00:34.720]             ...future.value <- base::withVisible(base::local({
[17:00:34.720]                 ...future.makeSendCondition <- base::local({
[17:00:34.720]                   sendCondition <- NULL
[17:00:34.720]                   function(frame = 1L) {
[17:00:34.720]                     if (is.function(sendCondition)) 
[17:00:34.720]                       return(sendCondition)
[17:00:34.720]                     ns <- getNamespace("parallel")
[17:00:34.720]                     if (exists("sendData", mode = "function", 
[17:00:34.720]                       envir = ns)) {
[17:00:34.720]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.720]                         envir = ns)
[17:00:34.720]                       envir <- sys.frame(frame)
[17:00:34.720]                       master <- NULL
[17:00:34.720]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.720]                         !identical(envir, emptyenv())) {
[17:00:34.720]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.720]                           inherits = FALSE)) {
[17:00:34.720]                           master <- get("master", mode = "list", 
[17:00:34.720]                             envir = envir, inherits = FALSE)
[17:00:34.720]                           if (inherits(master, c("SOCKnode", 
[17:00:34.720]                             "SOCK0node"))) {
[17:00:34.720]                             sendCondition <<- function(cond) {
[17:00:34.720]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.720]                                 success = TRUE)
[17:00:34.720]                               parallel_sendData(master, data)
[17:00:34.720]                             }
[17:00:34.720]                             return(sendCondition)
[17:00:34.720]                           }
[17:00:34.720]                         }
[17:00:34.720]                         frame <- frame + 1L
[17:00:34.720]                         envir <- sys.frame(frame)
[17:00:34.720]                       }
[17:00:34.720]                     }
[17:00:34.720]                     sendCondition <<- function(cond) NULL
[17:00:34.720]                   }
[17:00:34.720]                 })
[17:00:34.720]                 withCallingHandlers({
[17:00:34.720]                   {
[17:00:34.720]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.720]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.720]                       ...future.globals.maxSize)) {
[17:00:34.720]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.720]                       on.exit(options(oopts), add = TRUE)
[17:00:34.720]                     }
[17:00:34.720]                     {
[17:00:34.720]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.720]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.720]                         USE.NAMES = FALSE)
[17:00:34.720]                       do.call(mapply, args = args)
[17:00:34.720]                     }
[17:00:34.720]                   }
[17:00:34.720]                 }, immediateCondition = function(cond) {
[17:00:34.720]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.720]                   sendCondition(cond)
[17:00:34.720]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.720]                   {
[17:00:34.720]                     inherits <- base::inherits
[17:00:34.720]                     invokeRestart <- base::invokeRestart
[17:00:34.720]                     is.null <- base::is.null
[17:00:34.720]                     muffled <- FALSE
[17:00:34.720]                     if (inherits(cond, "message")) {
[17:00:34.720]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.720]                       if (muffled) 
[17:00:34.720]                         invokeRestart("muffleMessage")
[17:00:34.720]                     }
[17:00:34.720]                     else if (inherits(cond, "warning")) {
[17:00:34.720]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.720]                       if (muffled) 
[17:00:34.720]                         invokeRestart("muffleWarning")
[17:00:34.720]                     }
[17:00:34.720]                     else if (inherits(cond, "condition")) {
[17:00:34.720]                       if (!is.null(pattern)) {
[17:00:34.720]                         computeRestarts <- base::computeRestarts
[17:00:34.720]                         grepl <- base::grepl
[17:00:34.720]                         restarts <- computeRestarts(cond)
[17:00:34.720]                         for (restart in restarts) {
[17:00:34.720]                           name <- restart$name
[17:00:34.720]                           if (is.null(name)) 
[17:00:34.720]                             next
[17:00:34.720]                           if (!grepl(pattern, name)) 
[17:00:34.720]                             next
[17:00:34.720]                           invokeRestart(restart)
[17:00:34.720]                           muffled <- TRUE
[17:00:34.720]                           break
[17:00:34.720]                         }
[17:00:34.720]                       }
[17:00:34.720]                     }
[17:00:34.720]                     invisible(muffled)
[17:00:34.720]                   }
[17:00:34.720]                   muffleCondition(cond)
[17:00:34.720]                 })
[17:00:34.720]             }))
[17:00:34.720]             future::FutureResult(value = ...future.value$value, 
[17:00:34.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.720]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.720]                     ...future.globalenv.names))
[17:00:34.720]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.720]         }, condition = base::local({
[17:00:34.720]             c <- base::c
[17:00:34.720]             inherits <- base::inherits
[17:00:34.720]             invokeRestart <- base::invokeRestart
[17:00:34.720]             length <- base::length
[17:00:34.720]             list <- base::list
[17:00:34.720]             seq.int <- base::seq.int
[17:00:34.720]             signalCondition <- base::signalCondition
[17:00:34.720]             sys.calls <- base::sys.calls
[17:00:34.720]             `[[` <- base::`[[`
[17:00:34.720]             `+` <- base::`+`
[17:00:34.720]             `<<-` <- base::`<<-`
[17:00:34.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.720]                   3L)]
[17:00:34.720]             }
[17:00:34.720]             function(cond) {
[17:00:34.720]                 is_error <- inherits(cond, "error")
[17:00:34.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.720]                   NULL)
[17:00:34.720]                 if (is_error) {
[17:00:34.720]                   sessionInformation <- function() {
[17:00:34.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.720]                       search = base::search(), system = base::Sys.info())
[17:00:34.720]                   }
[17:00:34.720]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.720]                     cond$call), session = sessionInformation(), 
[17:00:34.720]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.720]                   signalCondition(cond)
[17:00:34.720]                 }
[17:00:34.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.720]                 "immediateCondition"))) {
[17:00:34.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.720]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.720]                   if (TRUE && !signal) {
[17:00:34.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.720]                     {
[17:00:34.720]                       inherits <- base::inherits
[17:00:34.720]                       invokeRestart <- base::invokeRestart
[17:00:34.720]                       is.null <- base::is.null
[17:00:34.720]                       muffled <- FALSE
[17:00:34.720]                       if (inherits(cond, "message")) {
[17:00:34.720]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.720]                         if (muffled) 
[17:00:34.720]                           invokeRestart("muffleMessage")
[17:00:34.720]                       }
[17:00:34.720]                       else if (inherits(cond, "warning")) {
[17:00:34.720]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.720]                         if (muffled) 
[17:00:34.720]                           invokeRestart("muffleWarning")
[17:00:34.720]                       }
[17:00:34.720]                       else if (inherits(cond, "condition")) {
[17:00:34.720]                         if (!is.null(pattern)) {
[17:00:34.720]                           computeRestarts <- base::computeRestarts
[17:00:34.720]                           grepl <- base::grepl
[17:00:34.720]                           restarts <- computeRestarts(cond)
[17:00:34.720]                           for (restart in restarts) {
[17:00:34.720]                             name <- restart$name
[17:00:34.720]                             if (is.null(name)) 
[17:00:34.720]                               next
[17:00:34.720]                             if (!grepl(pattern, name)) 
[17:00:34.720]                               next
[17:00:34.720]                             invokeRestart(restart)
[17:00:34.720]                             muffled <- TRUE
[17:00:34.720]                             break
[17:00:34.720]                           }
[17:00:34.720]                         }
[17:00:34.720]                       }
[17:00:34.720]                       invisible(muffled)
[17:00:34.720]                     }
[17:00:34.720]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.720]                   }
[17:00:34.720]                 }
[17:00:34.720]                 else {
[17:00:34.720]                   if (TRUE) {
[17:00:34.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.720]                     {
[17:00:34.720]                       inherits <- base::inherits
[17:00:34.720]                       invokeRestart <- base::invokeRestart
[17:00:34.720]                       is.null <- base::is.null
[17:00:34.720]                       muffled <- FALSE
[17:00:34.720]                       if (inherits(cond, "message")) {
[17:00:34.720]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.720]                         if (muffled) 
[17:00:34.720]                           invokeRestart("muffleMessage")
[17:00:34.720]                       }
[17:00:34.720]                       else if (inherits(cond, "warning")) {
[17:00:34.720]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.720]                         if (muffled) 
[17:00:34.720]                           invokeRestart("muffleWarning")
[17:00:34.720]                       }
[17:00:34.720]                       else if (inherits(cond, "condition")) {
[17:00:34.720]                         if (!is.null(pattern)) {
[17:00:34.720]                           computeRestarts <- base::computeRestarts
[17:00:34.720]                           grepl <- base::grepl
[17:00:34.720]                           restarts <- computeRestarts(cond)
[17:00:34.720]                           for (restart in restarts) {
[17:00:34.720]                             name <- restart$name
[17:00:34.720]                             if (is.null(name)) 
[17:00:34.720]                               next
[17:00:34.720]                             if (!grepl(pattern, name)) 
[17:00:34.720]                               next
[17:00:34.720]                             invokeRestart(restart)
[17:00:34.720]                             muffled <- TRUE
[17:00:34.720]                             break
[17:00:34.720]                           }
[17:00:34.720]                         }
[17:00:34.720]                       }
[17:00:34.720]                       invisible(muffled)
[17:00:34.720]                     }
[17:00:34.720]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.720]                   }
[17:00:34.720]                 }
[17:00:34.720]             }
[17:00:34.720]         }))
[17:00:34.720]     }, error = function(ex) {
[17:00:34.720]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.720]                 ...future.rng), started = ...future.startTime, 
[17:00:34.720]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.720]             version = "1.8"), class = "FutureResult")
[17:00:34.720]     }, finally = {
[17:00:34.720]         if (!identical(...future.workdir, getwd())) 
[17:00:34.720]             setwd(...future.workdir)
[17:00:34.720]         {
[17:00:34.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.720]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.720]             }
[17:00:34.720]             base::options(...future.oldOptions)
[17:00:34.720]             if (.Platform$OS.type == "windows") {
[17:00:34.720]                 old_names <- names(...future.oldEnvVars)
[17:00:34.720]                 envs <- base::Sys.getenv()
[17:00:34.720]                 names <- names(envs)
[17:00:34.720]                 common <- intersect(names, old_names)
[17:00:34.720]                 added <- setdiff(names, old_names)
[17:00:34.720]                 removed <- setdiff(old_names, names)
[17:00:34.720]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.720]                   envs[common]]
[17:00:34.720]                 NAMES <- toupper(changed)
[17:00:34.720]                 args <- list()
[17:00:34.720]                 for (kk in seq_along(NAMES)) {
[17:00:34.720]                   name <- changed[[kk]]
[17:00:34.720]                   NAME <- NAMES[[kk]]
[17:00:34.720]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.720]                     next
[17:00:34.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.720]                 }
[17:00:34.720]                 NAMES <- toupper(added)
[17:00:34.720]                 for (kk in seq_along(NAMES)) {
[17:00:34.720]                   name <- added[[kk]]
[17:00:34.720]                   NAME <- NAMES[[kk]]
[17:00:34.720]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.720]                     next
[17:00:34.720]                   args[[name]] <- ""
[17:00:34.720]                 }
[17:00:34.720]                 NAMES <- toupper(removed)
[17:00:34.720]                 for (kk in seq_along(NAMES)) {
[17:00:34.720]                   name <- removed[[kk]]
[17:00:34.720]                   NAME <- NAMES[[kk]]
[17:00:34.720]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.720]                     next
[17:00:34.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.720]                 }
[17:00:34.720]                 if (length(args) > 0) 
[17:00:34.720]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.720]             }
[17:00:34.720]             else {
[17:00:34.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.720]             }
[17:00:34.720]             {
[17:00:34.720]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.720]                   0L) {
[17:00:34.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.720]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.720]                   base::options(opts)
[17:00:34.720]                 }
[17:00:34.720]                 {
[17:00:34.720]                   {
[17:00:34.720]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.720]                     NULL
[17:00:34.720]                   }
[17:00:34.720]                   options(future.plan = NULL)
[17:00:34.720]                   if (is.na(NA_character_)) 
[17:00:34.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.720]                     .init = FALSE)
[17:00:34.720]                 }
[17:00:34.720]             }
[17:00:34.720]         }
[17:00:34.720]     })
[17:00:34.720]     if (TRUE) {
[17:00:34.720]         base::sink(type = "output", split = FALSE)
[17:00:34.720]         if (TRUE) {
[17:00:34.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.720]         }
[17:00:34.720]         else {
[17:00:34.720]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.720]         }
[17:00:34.720]         base::close(...future.stdout)
[17:00:34.720]         ...future.stdout <- NULL
[17:00:34.720]     }
[17:00:34.720]     ...future.result$conditions <- ...future.conditions
[17:00:34.720]     ...future.result$finished <- base::Sys.time()
[17:00:34.720]     ...future.result
[17:00:34.720] }
[17:00:34.723] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[17:00:34.723] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[17:00:34.723] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[17:00:34.723] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:00:34.724] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:00:34.724] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:00:34.724] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:00:34.724] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:34.724] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.725] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:34.725] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.725] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[17:00:34.725] MultisessionFuture started
[17:00:34.725] - Launch lazy future ... done
[17:00:34.726] run() for ‘MultisessionFuture’ ... done
[17:00:34.726] Created future:
[17:00:34.726] MultisessionFuture:
[17:00:34.726] Label: ‘future_.mapply-1’
[17:00:34.726] Expression:
[17:00:34.726] {
[17:00:34.726]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.726]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.726]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.726]         on.exit(options(oopts), add = TRUE)
[17:00:34.726]     }
[17:00:34.726]     {
[17:00:34.726]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.726]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.726]         do.call(mapply, args = args)
[17:00:34.726]     }
[17:00:34.726] }
[17:00:34.726] Lazy evaluation: FALSE
[17:00:34.726] Asynchronous evaluation: TRUE
[17:00:34.726] Local evaluation: TRUE
[17:00:34.726] Environment: R_GlobalEnv
[17:00:34.726] Capture standard output: TRUE
[17:00:34.726] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.726] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.726] Packages: <none>
[17:00:34.726] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.726] Resolved: FALSE
[17:00:34.726] Value: <not collected>
[17:00:34.726] Conditions captured: <none>
[17:00:34.726] Early signaling: FALSE
[17:00:34.726] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.726] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.737] Chunk #1 of 2 ... DONE
[17:00:34.737] Chunk #2 of 2 ...
[17:00:34.738]  - Finding globals in '...' for chunk #2 ...
[17:00:34.738] getGlobalsAndPackages() ...
[17:00:34.738] Searching for globals...
[17:00:34.738] 
[17:00:34.738] Searching for globals ... DONE
[17:00:34.738] - globals: [0] <none>
[17:00:34.738] getGlobalsAndPackages() ... DONE
[17:00:34.738]    + additional globals found: [n=0] 
[17:00:34.739]    + additional namespaces needed: [n=0] 
[17:00:34.739]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:34.739]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.739]  - seeds: <none>
[17:00:34.739]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.739] getGlobalsAndPackages() ...
[17:00:34.739] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.739] Resolving globals: FALSE
[17:00:34.740] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:00:34.740] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:00:34.740] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.740] 
[17:00:34.741] getGlobalsAndPackages() ... DONE
[17:00:34.741] run() for ‘Future’ ...
[17:00:34.741] - state: ‘created’
[17:00:34.741] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.755] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.756]   - Field: ‘node’
[17:00:34.756]   - Field: ‘label’
[17:00:34.756]   - Field: ‘local’
[17:00:34.756]   - Field: ‘owner’
[17:00:34.756]   - Field: ‘envir’
[17:00:34.756]   - Field: ‘workers’
[17:00:34.756]   - Field: ‘packages’
[17:00:34.756]   - Field: ‘gc’
[17:00:34.756]   - Field: ‘conditions’
[17:00:34.756]   - Field: ‘persistent’
[17:00:34.757]   - Field: ‘expr’
[17:00:34.757]   - Field: ‘uuid’
[17:00:34.757]   - Field: ‘seed’
[17:00:34.757]   - Field: ‘version’
[17:00:34.757]   - Field: ‘result’
[17:00:34.757]   - Field: ‘asynchronous’
[17:00:34.757]   - Field: ‘calls’
[17:00:34.757]   - Field: ‘globals’
[17:00:34.757]   - Field: ‘stdout’
[17:00:34.757]   - Field: ‘earlySignal’
[17:00:34.757]   - Field: ‘lazy’
[17:00:34.758]   - Field: ‘state’
[17:00:34.758] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.758] - Launch lazy future ...
[17:00:34.758] Packages needed by the future expression (n = 0): <none>
[17:00:34.758] Packages needed by future strategies (n = 0): <none>
[17:00:34.759] {
[17:00:34.759]     {
[17:00:34.759]         {
[17:00:34.759]             ...future.startTime <- base::Sys.time()
[17:00:34.759]             {
[17:00:34.759]                 {
[17:00:34.759]                   {
[17:00:34.759]                     {
[17:00:34.759]                       base::local({
[17:00:34.759]                         has_future <- base::requireNamespace("future", 
[17:00:34.759]                           quietly = TRUE)
[17:00:34.759]                         if (has_future) {
[17:00:34.759]                           ns <- base::getNamespace("future")
[17:00:34.759]                           version <- ns[[".package"]][["version"]]
[17:00:34.759]                           if (is.null(version)) 
[17:00:34.759]                             version <- utils::packageVersion("future")
[17:00:34.759]                         }
[17:00:34.759]                         else {
[17:00:34.759]                           version <- NULL
[17:00:34.759]                         }
[17:00:34.759]                         if (!has_future || version < "1.8.0") {
[17:00:34.759]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.759]                             "", base::R.version$version.string), 
[17:00:34.759]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.759]                               "release", "version")], collapse = " "), 
[17:00:34.759]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.759]                             info)
[17:00:34.759]                           info <- base::paste(info, collapse = "; ")
[17:00:34.759]                           if (!has_future) {
[17:00:34.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.759]                               info)
[17:00:34.759]                           }
[17:00:34.759]                           else {
[17:00:34.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.759]                               info, version)
[17:00:34.759]                           }
[17:00:34.759]                           base::stop(msg)
[17:00:34.759]                         }
[17:00:34.759]                       })
[17:00:34.759]                     }
[17:00:34.759]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.759]                     base::options(mc.cores = 1L)
[17:00:34.759]                   }
[17:00:34.759]                   ...future.strategy.old <- future::plan("list")
[17:00:34.759]                   options(future.plan = NULL)
[17:00:34.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.759]                 }
[17:00:34.759]                 ...future.workdir <- getwd()
[17:00:34.759]             }
[17:00:34.759]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.759]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.759]         }
[17:00:34.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.759]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.759]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.759]             base::names(...future.oldOptions))
[17:00:34.759]     }
[17:00:34.759]     if (FALSE) {
[17:00:34.759]     }
[17:00:34.759]     else {
[17:00:34.759]         if (TRUE) {
[17:00:34.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.759]                 open = "w")
[17:00:34.759]         }
[17:00:34.759]         else {
[17:00:34.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.759]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.759]         }
[17:00:34.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.759]             base::sink(type = "output", split = FALSE)
[17:00:34.759]             base::close(...future.stdout)
[17:00:34.759]         }, add = TRUE)
[17:00:34.759]     }
[17:00:34.759]     ...future.frame <- base::sys.nframe()
[17:00:34.759]     ...future.conditions <- base::list()
[17:00:34.759]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.759]     if (FALSE) {
[17:00:34.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.759]     }
[17:00:34.759]     ...future.result <- base::tryCatch({
[17:00:34.759]         base::withCallingHandlers({
[17:00:34.759]             ...future.value <- base::withVisible(base::local({
[17:00:34.759]                 ...future.makeSendCondition <- base::local({
[17:00:34.759]                   sendCondition <- NULL
[17:00:34.759]                   function(frame = 1L) {
[17:00:34.759]                     if (is.function(sendCondition)) 
[17:00:34.759]                       return(sendCondition)
[17:00:34.759]                     ns <- getNamespace("parallel")
[17:00:34.759]                     if (exists("sendData", mode = "function", 
[17:00:34.759]                       envir = ns)) {
[17:00:34.759]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.759]                         envir = ns)
[17:00:34.759]                       envir <- sys.frame(frame)
[17:00:34.759]                       master <- NULL
[17:00:34.759]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.759]                         !identical(envir, emptyenv())) {
[17:00:34.759]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.759]                           inherits = FALSE)) {
[17:00:34.759]                           master <- get("master", mode = "list", 
[17:00:34.759]                             envir = envir, inherits = FALSE)
[17:00:34.759]                           if (inherits(master, c("SOCKnode", 
[17:00:34.759]                             "SOCK0node"))) {
[17:00:34.759]                             sendCondition <<- function(cond) {
[17:00:34.759]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.759]                                 success = TRUE)
[17:00:34.759]                               parallel_sendData(master, data)
[17:00:34.759]                             }
[17:00:34.759]                             return(sendCondition)
[17:00:34.759]                           }
[17:00:34.759]                         }
[17:00:34.759]                         frame <- frame + 1L
[17:00:34.759]                         envir <- sys.frame(frame)
[17:00:34.759]                       }
[17:00:34.759]                     }
[17:00:34.759]                     sendCondition <<- function(cond) NULL
[17:00:34.759]                   }
[17:00:34.759]                 })
[17:00:34.759]                 withCallingHandlers({
[17:00:34.759]                   {
[17:00:34.759]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.759]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.759]                       ...future.globals.maxSize)) {
[17:00:34.759]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.759]                       on.exit(options(oopts), add = TRUE)
[17:00:34.759]                     }
[17:00:34.759]                     {
[17:00:34.759]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.759]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.759]                         USE.NAMES = FALSE)
[17:00:34.759]                       do.call(mapply, args = args)
[17:00:34.759]                     }
[17:00:34.759]                   }
[17:00:34.759]                 }, immediateCondition = function(cond) {
[17:00:34.759]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.759]                   sendCondition(cond)
[17:00:34.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.759]                   {
[17:00:34.759]                     inherits <- base::inherits
[17:00:34.759]                     invokeRestart <- base::invokeRestart
[17:00:34.759]                     is.null <- base::is.null
[17:00:34.759]                     muffled <- FALSE
[17:00:34.759]                     if (inherits(cond, "message")) {
[17:00:34.759]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.759]                       if (muffled) 
[17:00:34.759]                         invokeRestart("muffleMessage")
[17:00:34.759]                     }
[17:00:34.759]                     else if (inherits(cond, "warning")) {
[17:00:34.759]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.759]                       if (muffled) 
[17:00:34.759]                         invokeRestart("muffleWarning")
[17:00:34.759]                     }
[17:00:34.759]                     else if (inherits(cond, "condition")) {
[17:00:34.759]                       if (!is.null(pattern)) {
[17:00:34.759]                         computeRestarts <- base::computeRestarts
[17:00:34.759]                         grepl <- base::grepl
[17:00:34.759]                         restarts <- computeRestarts(cond)
[17:00:34.759]                         for (restart in restarts) {
[17:00:34.759]                           name <- restart$name
[17:00:34.759]                           if (is.null(name)) 
[17:00:34.759]                             next
[17:00:34.759]                           if (!grepl(pattern, name)) 
[17:00:34.759]                             next
[17:00:34.759]                           invokeRestart(restart)
[17:00:34.759]                           muffled <- TRUE
[17:00:34.759]                           break
[17:00:34.759]                         }
[17:00:34.759]                       }
[17:00:34.759]                     }
[17:00:34.759]                     invisible(muffled)
[17:00:34.759]                   }
[17:00:34.759]                   muffleCondition(cond)
[17:00:34.759]                 })
[17:00:34.759]             }))
[17:00:34.759]             future::FutureResult(value = ...future.value$value, 
[17:00:34.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.759]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.759]                     ...future.globalenv.names))
[17:00:34.759]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.759]         }, condition = base::local({
[17:00:34.759]             c <- base::c
[17:00:34.759]             inherits <- base::inherits
[17:00:34.759]             invokeRestart <- base::invokeRestart
[17:00:34.759]             length <- base::length
[17:00:34.759]             list <- base::list
[17:00:34.759]             seq.int <- base::seq.int
[17:00:34.759]             signalCondition <- base::signalCondition
[17:00:34.759]             sys.calls <- base::sys.calls
[17:00:34.759]             `[[` <- base::`[[`
[17:00:34.759]             `+` <- base::`+`
[17:00:34.759]             `<<-` <- base::`<<-`
[17:00:34.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.759]                   3L)]
[17:00:34.759]             }
[17:00:34.759]             function(cond) {
[17:00:34.759]                 is_error <- inherits(cond, "error")
[17:00:34.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.759]                   NULL)
[17:00:34.759]                 if (is_error) {
[17:00:34.759]                   sessionInformation <- function() {
[17:00:34.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.759]                       search = base::search(), system = base::Sys.info())
[17:00:34.759]                   }
[17:00:34.759]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.759]                     cond$call), session = sessionInformation(), 
[17:00:34.759]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.759]                   signalCondition(cond)
[17:00:34.759]                 }
[17:00:34.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.759]                 "immediateCondition"))) {
[17:00:34.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.759]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.759]                   if (TRUE && !signal) {
[17:00:34.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.759]                     {
[17:00:34.759]                       inherits <- base::inherits
[17:00:34.759]                       invokeRestart <- base::invokeRestart
[17:00:34.759]                       is.null <- base::is.null
[17:00:34.759]                       muffled <- FALSE
[17:00:34.759]                       if (inherits(cond, "message")) {
[17:00:34.759]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.759]                         if (muffled) 
[17:00:34.759]                           invokeRestart("muffleMessage")
[17:00:34.759]                       }
[17:00:34.759]                       else if (inherits(cond, "warning")) {
[17:00:34.759]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.759]                         if (muffled) 
[17:00:34.759]                           invokeRestart("muffleWarning")
[17:00:34.759]                       }
[17:00:34.759]                       else if (inherits(cond, "condition")) {
[17:00:34.759]                         if (!is.null(pattern)) {
[17:00:34.759]                           computeRestarts <- base::computeRestarts
[17:00:34.759]                           grepl <- base::grepl
[17:00:34.759]                           restarts <- computeRestarts(cond)
[17:00:34.759]                           for (restart in restarts) {
[17:00:34.759]                             name <- restart$name
[17:00:34.759]                             if (is.null(name)) 
[17:00:34.759]                               next
[17:00:34.759]                             if (!grepl(pattern, name)) 
[17:00:34.759]                               next
[17:00:34.759]                             invokeRestart(restart)
[17:00:34.759]                             muffled <- TRUE
[17:00:34.759]                             break
[17:00:34.759]                           }
[17:00:34.759]                         }
[17:00:34.759]                       }
[17:00:34.759]                       invisible(muffled)
[17:00:34.759]                     }
[17:00:34.759]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.759]                   }
[17:00:34.759]                 }
[17:00:34.759]                 else {
[17:00:34.759]                   if (TRUE) {
[17:00:34.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.759]                     {
[17:00:34.759]                       inherits <- base::inherits
[17:00:34.759]                       invokeRestart <- base::invokeRestart
[17:00:34.759]                       is.null <- base::is.null
[17:00:34.759]                       muffled <- FALSE
[17:00:34.759]                       if (inherits(cond, "message")) {
[17:00:34.759]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.759]                         if (muffled) 
[17:00:34.759]                           invokeRestart("muffleMessage")
[17:00:34.759]                       }
[17:00:34.759]                       else if (inherits(cond, "warning")) {
[17:00:34.759]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.759]                         if (muffled) 
[17:00:34.759]                           invokeRestart("muffleWarning")
[17:00:34.759]                       }
[17:00:34.759]                       else if (inherits(cond, "condition")) {
[17:00:34.759]                         if (!is.null(pattern)) {
[17:00:34.759]                           computeRestarts <- base::computeRestarts
[17:00:34.759]                           grepl <- base::grepl
[17:00:34.759]                           restarts <- computeRestarts(cond)
[17:00:34.759]                           for (restart in restarts) {
[17:00:34.759]                             name <- restart$name
[17:00:34.759]                             if (is.null(name)) 
[17:00:34.759]                               next
[17:00:34.759]                             if (!grepl(pattern, name)) 
[17:00:34.759]                               next
[17:00:34.759]                             invokeRestart(restart)
[17:00:34.759]                             muffled <- TRUE
[17:00:34.759]                             break
[17:00:34.759]                           }
[17:00:34.759]                         }
[17:00:34.759]                       }
[17:00:34.759]                       invisible(muffled)
[17:00:34.759]                     }
[17:00:34.759]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.759]                   }
[17:00:34.759]                 }
[17:00:34.759]             }
[17:00:34.759]         }))
[17:00:34.759]     }, error = function(ex) {
[17:00:34.759]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.759]                 ...future.rng), started = ...future.startTime, 
[17:00:34.759]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.759]             version = "1.8"), class = "FutureResult")
[17:00:34.759]     }, finally = {
[17:00:34.759]         if (!identical(...future.workdir, getwd())) 
[17:00:34.759]             setwd(...future.workdir)
[17:00:34.759]         {
[17:00:34.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.759]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.759]             }
[17:00:34.759]             base::options(...future.oldOptions)
[17:00:34.759]             if (.Platform$OS.type == "windows") {
[17:00:34.759]                 old_names <- names(...future.oldEnvVars)
[17:00:34.759]                 envs <- base::Sys.getenv()
[17:00:34.759]                 names <- names(envs)
[17:00:34.759]                 common <- intersect(names, old_names)
[17:00:34.759]                 added <- setdiff(names, old_names)
[17:00:34.759]                 removed <- setdiff(old_names, names)
[17:00:34.759]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.759]                   envs[common]]
[17:00:34.759]                 NAMES <- toupper(changed)
[17:00:34.759]                 args <- list()
[17:00:34.759]                 for (kk in seq_along(NAMES)) {
[17:00:34.759]                   name <- changed[[kk]]
[17:00:34.759]                   NAME <- NAMES[[kk]]
[17:00:34.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.759]                     next
[17:00:34.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.759]                 }
[17:00:34.759]                 NAMES <- toupper(added)
[17:00:34.759]                 for (kk in seq_along(NAMES)) {
[17:00:34.759]                   name <- added[[kk]]
[17:00:34.759]                   NAME <- NAMES[[kk]]
[17:00:34.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.759]                     next
[17:00:34.759]                   args[[name]] <- ""
[17:00:34.759]                 }
[17:00:34.759]                 NAMES <- toupper(removed)
[17:00:34.759]                 for (kk in seq_along(NAMES)) {
[17:00:34.759]                   name <- removed[[kk]]
[17:00:34.759]                   NAME <- NAMES[[kk]]
[17:00:34.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.759]                     next
[17:00:34.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.759]                 }
[17:00:34.759]                 if (length(args) > 0) 
[17:00:34.759]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.759]             }
[17:00:34.759]             else {
[17:00:34.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.759]             }
[17:00:34.759]             {
[17:00:34.759]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.759]                   0L) {
[17:00:34.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.759]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.759]                   base::options(opts)
[17:00:34.759]                 }
[17:00:34.759]                 {
[17:00:34.759]                   {
[17:00:34.759]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.759]                     NULL
[17:00:34.759]                   }
[17:00:34.759]                   options(future.plan = NULL)
[17:00:34.759]                   if (is.na(NA_character_)) 
[17:00:34.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.759]                     .init = FALSE)
[17:00:34.759]                 }
[17:00:34.759]             }
[17:00:34.759]         }
[17:00:34.759]     })
[17:00:34.759]     if (TRUE) {
[17:00:34.759]         base::sink(type = "output", split = FALSE)
[17:00:34.759]         if (TRUE) {
[17:00:34.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.759]         }
[17:00:34.759]         else {
[17:00:34.759]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.759]         }
[17:00:34.759]         base::close(...future.stdout)
[17:00:34.759]         ...future.stdout <- NULL
[17:00:34.759]     }
[17:00:34.759]     ...future.result$conditions <- ...future.conditions
[17:00:34.759]     ...future.result$finished <- base::Sys.time()
[17:00:34.759]     ...future.result
[17:00:34.759] }
[17:00:34.761] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[17:00:34.762] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[17:00:34.762] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[17:00:34.762] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:00:34.762] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:00:34.763] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:00:34.763] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:00:34.763] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:34.764] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.764] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:34.764] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.764] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[17:00:34.765] MultisessionFuture started
[17:00:34.765] - Launch lazy future ... done
[17:00:34.765] run() for ‘MultisessionFuture’ ... done
[17:00:34.765] Created future:
[17:00:34.765] MultisessionFuture:
[17:00:34.765] Label: ‘future_.mapply-2’
[17:00:34.765] Expression:
[17:00:34.765] {
[17:00:34.765]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.765]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.765]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.765]         on.exit(options(oopts), add = TRUE)
[17:00:34.765]     }
[17:00:34.765]     {
[17:00:34.765]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.765]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.765]         do.call(mapply, args = args)
[17:00:34.765]     }
[17:00:34.765] }
[17:00:34.765] Lazy evaluation: FALSE
[17:00:34.765] Asynchronous evaluation: TRUE
[17:00:34.765] Local evaluation: TRUE
[17:00:34.765] Environment: R_GlobalEnv
[17:00:34.765] Capture standard output: TRUE
[17:00:34.765] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.765] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.765] Packages: <none>
[17:00:34.765] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.765] Resolved: FALSE
[17:00:34.765] Value: <not collected>
[17:00:34.765] Conditions captured: <none>
[17:00:34.765] Early signaling: FALSE
[17:00:34.765] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.765] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.777] Chunk #2 of 2 ... DONE
[17:00:34.777] Launching 2 futures (chunks) ... DONE
[17:00:34.777] Resolving 2 futures (chunks) ...
[17:00:34.777] resolve() on list ...
[17:00:34.777]  recursive: 0
[17:00:34.777]  length: 2
[17:00:34.777] 
[17:00:34.778] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.778] - Validating connection of MultisessionFuture
[17:00:34.778] - received message: FutureResult
[17:00:34.778] - Received FutureResult
[17:00:34.778] - Erased future from FutureRegistry
[17:00:34.778] result() for ClusterFuture ...
[17:00:34.778] - result already collected: FutureResult
[17:00:34.779] result() for ClusterFuture ... done
[17:00:34.779] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.779] Future #1
[17:00:34.779] result() for ClusterFuture ...
[17:00:34.779] - result already collected: FutureResult
[17:00:34.779] result() for ClusterFuture ... done
[17:00:34.779] result() for ClusterFuture ...
[17:00:34.779] - result already collected: FutureResult
[17:00:34.779] result() for ClusterFuture ... done
[17:00:34.779] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:34.779] - nx: 2
[17:00:34.780] - relay: TRUE
[17:00:34.780] - stdout: TRUE
[17:00:34.780] - signal: TRUE
[17:00:34.780] - resignal: FALSE
[17:00:34.780] - force: TRUE
[17:00:34.780] - relayed: [n=2] FALSE, FALSE
[17:00:34.780] - queued futures: [n=2] FALSE, FALSE
[17:00:34.780]  - until=1
[17:00:34.780]  - relaying element #1
[17:00:34.780] result() for ClusterFuture ...
[17:00:34.780] - result already collected: FutureResult
[17:00:34.781] result() for ClusterFuture ... done
[17:00:34.781] result() for ClusterFuture ...
[17:00:34.781] - result already collected: FutureResult
[17:00:34.781] result() for ClusterFuture ... done
[17:00:34.781] result() for ClusterFuture ...
[17:00:34.781] - result already collected: FutureResult
[17:00:34.781] result() for ClusterFuture ... done
[17:00:34.781] result() for ClusterFuture ...
[17:00:34.781] - result already collected: FutureResult
[17:00:34.781] result() for ClusterFuture ... done
[17:00:34.781] - relayed: [n=2] TRUE, FALSE
[17:00:34.781] - queued futures: [n=2] TRUE, FALSE
[17:00:34.782] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:34.782]  length: 1 (resolved future 1)
[17:00:34.809] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.809] - Validating connection of MultisessionFuture
[17:00:34.809] - received message: FutureResult
[17:00:34.810] - Received FutureResult
[17:00:34.810] - Erased future from FutureRegistry
[17:00:34.810] result() for ClusterFuture ...
[17:00:34.810] - result already collected: FutureResult
[17:00:34.810] result() for ClusterFuture ... done
[17:00:34.810] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.810] Future #2
[17:00:34.810] result() for ClusterFuture ...
[17:00:34.810] - result already collected: FutureResult
[17:00:34.810] result() for ClusterFuture ... done
[17:00:34.810] result() for ClusterFuture ...
[17:00:34.811] - result already collected: FutureResult
[17:00:34.811] result() for ClusterFuture ... done
[17:00:34.811] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:34.811] - nx: 2
[17:00:34.811] - relay: TRUE
[17:00:34.811] - stdout: TRUE
[17:00:34.811] - signal: TRUE
[17:00:34.811] - resignal: FALSE
[17:00:34.811] - force: TRUE
[17:00:34.811] - relayed: [n=2] TRUE, FALSE
[17:00:34.811] - queued futures: [n=2] TRUE, FALSE
[17:00:34.812]  - until=2
[17:00:34.812]  - relaying element #2
[17:00:34.812] result() for ClusterFuture ...
[17:00:34.812] - result already collected: FutureResult
[17:00:34.812] result() for ClusterFuture ... done
[17:00:34.812] result() for ClusterFuture ...
[17:00:34.812] - result already collected: FutureResult
[17:00:34.812] result() for ClusterFuture ... done
[17:00:34.812] result() for ClusterFuture ...
[17:00:34.812] - result already collected: FutureResult
[17:00:34.812] result() for ClusterFuture ... done
[17:00:34.813] result() for ClusterFuture ...
[17:00:34.813] - result already collected: FutureResult
[17:00:34.813] result() for ClusterFuture ... done
[17:00:34.813] - relayed: [n=2] TRUE, TRUE
[17:00:34.813] - queued futures: [n=2] TRUE, TRUE
[17:00:34.813] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:34.813]  length: 0 (resolved future 2)
[17:00:34.813] Relaying remaining futures
[17:00:34.813] signalConditionsASAP(NULL, pos=0) ...
[17:00:34.813] - nx: 2
[17:00:34.813] - relay: TRUE
[17:00:34.813] - stdout: TRUE
[17:00:34.814] - signal: TRUE
[17:00:34.814] - resignal: FALSE
[17:00:34.814] - force: TRUE
[17:00:34.814] - relayed: [n=2] TRUE, TRUE
[17:00:34.814] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:34.814] - relayed: [n=2] TRUE, TRUE
[17:00:34.814] - queued futures: [n=2] TRUE, TRUE
[17:00:34.814] signalConditionsASAP(NULL, pos=0) ... done
[17:00:34.814] resolve() on list ... DONE
[17:00:34.814] result() for ClusterFuture ...
[17:00:34.814] - result already collected: FutureResult
[17:00:34.815] result() for ClusterFuture ... done
[17:00:34.815] result() for ClusterFuture ...
[17:00:34.815] - result already collected: FutureResult
[17:00:34.815] result() for ClusterFuture ... done
[17:00:34.815] result() for ClusterFuture ...
[17:00:34.815] - result already collected: FutureResult
[17:00:34.815] result() for ClusterFuture ... done
[17:00:34.815] result() for ClusterFuture ...
[17:00:34.815] - result already collected: FutureResult
[17:00:34.815] result() for ClusterFuture ... done
[17:00:34.816]  - Number of value chunks collected: 2
[17:00:34.816] Resolving 2 futures (chunks) ... DONE
[17:00:34.816] Reducing values from 2 chunks ...
[17:00:34.816]  - Number of values collected after concatenation: 2
[17:00:34.816]  - Number of values expected: 2
[17:00:34.816] Reducing values from 2 chunks ... DONE
[17:00:34.816] future_mapply() ... DONE
- Recycle arguments to same length ...
[17:00:34.819] future_mapply() ...
[17:00:34.823] Number of chunks: 2
[17:00:34.823] getGlobalsAndPackagesXApply() ...
[17:00:34.823]  - future.globals: TRUE
[17:00:34.823] getGlobalsAndPackages() ...
[17:00:34.823] Searching for globals...
[17:00:34.824] - globals found: [1] ‘FUN’
[17:00:34.824] Searching for globals ... DONE
[17:00:34.824] Resolving globals: FALSE
[17:00:34.824] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:34.825] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:34.825] - globals: [1] ‘FUN’
[17:00:34.825] 
[17:00:34.825] getGlobalsAndPackages() ... DONE
[17:00:34.825]  - globals found/used: [n=1] ‘FUN’
[17:00:34.825]  - needed namespaces: [n=0] 
[17:00:34.825] Finding globals ... DONE
[17:00:34.825] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:34.826] List of 2
[17:00:34.826]  $ ...future.FUN:function (x, ...)  
[17:00:34.826]  $ MoreArgs     : NULL
[17:00:34.826]  - attr(*, "where")=List of 2
[17:00:34.826]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:34.826]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:34.826]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:34.826]  - attr(*, "resolved")= logi FALSE
[17:00:34.826]  - attr(*, "total_size")= num NA
[17:00:34.828] Packages to be attached in all futures: [n=0] 
[17:00:34.828] getGlobalsAndPackagesXApply() ... DONE
[17:00:34.828] Number of futures (= number of chunks): 2
[17:00:34.828] Launching 2 futures (chunks) ...
[17:00:34.828] Chunk #1 of 2 ...
[17:00:34.829]  - Finding globals in '...' for chunk #1 ...
[17:00:34.829] getGlobalsAndPackages() ...
[17:00:34.829] Searching for globals...
[17:00:34.829] 
[17:00:34.829] Searching for globals ... DONE
[17:00:34.829] - globals: [0] <none>
[17:00:34.829] getGlobalsAndPackages() ... DONE
[17:00:34.829]    + additional globals found: [n=0] 
[17:00:34.830]    + additional namespaces needed: [n=0] 
[17:00:34.830]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:34.830]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.830]  - seeds: <none>
[17:00:34.830]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.830] getGlobalsAndPackages() ...
[17:00:34.830] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.830] Resolving globals: FALSE
[17:00:34.831] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:34.831] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:34.831] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.831] 
[17:00:34.831] getGlobalsAndPackages() ... DONE
[17:00:34.832] run() for ‘Future’ ...
[17:00:34.832] - state: ‘created’
[17:00:34.832] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.846] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.847]   - Field: ‘node’
[17:00:34.847]   - Field: ‘label’
[17:00:34.847]   - Field: ‘local’
[17:00:34.847]   - Field: ‘owner’
[17:00:34.847]   - Field: ‘envir’
[17:00:34.847]   - Field: ‘workers’
[17:00:34.847]   - Field: ‘packages’
[17:00:34.847]   - Field: ‘gc’
[17:00:34.847]   - Field: ‘conditions’
[17:00:34.847]   - Field: ‘persistent’
[17:00:34.847]   - Field: ‘expr’
[17:00:34.848]   - Field: ‘uuid’
[17:00:34.848]   - Field: ‘seed’
[17:00:34.848]   - Field: ‘version’
[17:00:34.848]   - Field: ‘result’
[17:00:34.848]   - Field: ‘asynchronous’
[17:00:34.848]   - Field: ‘calls’
[17:00:34.848]   - Field: ‘globals’
[17:00:34.848]   - Field: ‘stdout’
[17:00:34.848]   - Field: ‘earlySignal’
[17:00:34.848]   - Field: ‘lazy’
[17:00:34.848]   - Field: ‘state’
[17:00:34.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.849] - Launch lazy future ...
[17:00:34.849] Packages needed by the future expression (n = 0): <none>
[17:00:34.849] Packages needed by future strategies (n = 0): <none>
[17:00:34.849] {
[17:00:34.849]     {
[17:00:34.849]         {
[17:00:34.849]             ...future.startTime <- base::Sys.time()
[17:00:34.849]             {
[17:00:34.849]                 {
[17:00:34.849]                   {
[17:00:34.849]                     {
[17:00:34.849]                       base::local({
[17:00:34.849]                         has_future <- base::requireNamespace("future", 
[17:00:34.849]                           quietly = TRUE)
[17:00:34.849]                         if (has_future) {
[17:00:34.849]                           ns <- base::getNamespace("future")
[17:00:34.849]                           version <- ns[[".package"]][["version"]]
[17:00:34.849]                           if (is.null(version)) 
[17:00:34.849]                             version <- utils::packageVersion("future")
[17:00:34.849]                         }
[17:00:34.849]                         else {
[17:00:34.849]                           version <- NULL
[17:00:34.849]                         }
[17:00:34.849]                         if (!has_future || version < "1.8.0") {
[17:00:34.849]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.849]                             "", base::R.version$version.string), 
[17:00:34.849]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.849]                               "release", "version")], collapse = " "), 
[17:00:34.849]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.849]                             info)
[17:00:34.849]                           info <- base::paste(info, collapse = "; ")
[17:00:34.849]                           if (!has_future) {
[17:00:34.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.849]                               info)
[17:00:34.849]                           }
[17:00:34.849]                           else {
[17:00:34.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.849]                               info, version)
[17:00:34.849]                           }
[17:00:34.849]                           base::stop(msg)
[17:00:34.849]                         }
[17:00:34.849]                       })
[17:00:34.849]                     }
[17:00:34.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.849]                     base::options(mc.cores = 1L)
[17:00:34.849]                   }
[17:00:34.849]                   ...future.strategy.old <- future::plan("list")
[17:00:34.849]                   options(future.plan = NULL)
[17:00:34.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.849]                 }
[17:00:34.849]                 ...future.workdir <- getwd()
[17:00:34.849]             }
[17:00:34.849]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.849]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.849]         }
[17:00:34.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.849]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.849]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.849]             base::names(...future.oldOptions))
[17:00:34.849]     }
[17:00:34.849]     if (FALSE) {
[17:00:34.849]     }
[17:00:34.849]     else {
[17:00:34.849]         if (TRUE) {
[17:00:34.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.849]                 open = "w")
[17:00:34.849]         }
[17:00:34.849]         else {
[17:00:34.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.849]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.849]         }
[17:00:34.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.849]             base::sink(type = "output", split = FALSE)
[17:00:34.849]             base::close(...future.stdout)
[17:00:34.849]         }, add = TRUE)
[17:00:34.849]     }
[17:00:34.849]     ...future.frame <- base::sys.nframe()
[17:00:34.849]     ...future.conditions <- base::list()
[17:00:34.849]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.849]     if (FALSE) {
[17:00:34.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.849]     }
[17:00:34.849]     ...future.result <- base::tryCatch({
[17:00:34.849]         base::withCallingHandlers({
[17:00:34.849]             ...future.value <- base::withVisible(base::local({
[17:00:34.849]                 ...future.makeSendCondition <- base::local({
[17:00:34.849]                   sendCondition <- NULL
[17:00:34.849]                   function(frame = 1L) {
[17:00:34.849]                     if (is.function(sendCondition)) 
[17:00:34.849]                       return(sendCondition)
[17:00:34.849]                     ns <- getNamespace("parallel")
[17:00:34.849]                     if (exists("sendData", mode = "function", 
[17:00:34.849]                       envir = ns)) {
[17:00:34.849]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.849]                         envir = ns)
[17:00:34.849]                       envir <- sys.frame(frame)
[17:00:34.849]                       master <- NULL
[17:00:34.849]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.849]                         !identical(envir, emptyenv())) {
[17:00:34.849]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.849]                           inherits = FALSE)) {
[17:00:34.849]                           master <- get("master", mode = "list", 
[17:00:34.849]                             envir = envir, inherits = FALSE)
[17:00:34.849]                           if (inherits(master, c("SOCKnode", 
[17:00:34.849]                             "SOCK0node"))) {
[17:00:34.849]                             sendCondition <<- function(cond) {
[17:00:34.849]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.849]                                 success = TRUE)
[17:00:34.849]                               parallel_sendData(master, data)
[17:00:34.849]                             }
[17:00:34.849]                             return(sendCondition)
[17:00:34.849]                           }
[17:00:34.849]                         }
[17:00:34.849]                         frame <- frame + 1L
[17:00:34.849]                         envir <- sys.frame(frame)
[17:00:34.849]                       }
[17:00:34.849]                     }
[17:00:34.849]                     sendCondition <<- function(cond) NULL
[17:00:34.849]                   }
[17:00:34.849]                 })
[17:00:34.849]                 withCallingHandlers({
[17:00:34.849]                   {
[17:00:34.849]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.849]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.849]                       ...future.globals.maxSize)) {
[17:00:34.849]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.849]                       on.exit(options(oopts), add = TRUE)
[17:00:34.849]                     }
[17:00:34.849]                     {
[17:00:34.849]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.849]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.849]                         USE.NAMES = FALSE)
[17:00:34.849]                       do.call(mapply, args = args)
[17:00:34.849]                     }
[17:00:34.849]                   }
[17:00:34.849]                 }, immediateCondition = function(cond) {
[17:00:34.849]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.849]                   sendCondition(cond)
[17:00:34.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.849]                   {
[17:00:34.849]                     inherits <- base::inherits
[17:00:34.849]                     invokeRestart <- base::invokeRestart
[17:00:34.849]                     is.null <- base::is.null
[17:00:34.849]                     muffled <- FALSE
[17:00:34.849]                     if (inherits(cond, "message")) {
[17:00:34.849]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.849]                       if (muffled) 
[17:00:34.849]                         invokeRestart("muffleMessage")
[17:00:34.849]                     }
[17:00:34.849]                     else if (inherits(cond, "warning")) {
[17:00:34.849]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.849]                       if (muffled) 
[17:00:34.849]                         invokeRestart("muffleWarning")
[17:00:34.849]                     }
[17:00:34.849]                     else if (inherits(cond, "condition")) {
[17:00:34.849]                       if (!is.null(pattern)) {
[17:00:34.849]                         computeRestarts <- base::computeRestarts
[17:00:34.849]                         grepl <- base::grepl
[17:00:34.849]                         restarts <- computeRestarts(cond)
[17:00:34.849]                         for (restart in restarts) {
[17:00:34.849]                           name <- restart$name
[17:00:34.849]                           if (is.null(name)) 
[17:00:34.849]                             next
[17:00:34.849]                           if (!grepl(pattern, name)) 
[17:00:34.849]                             next
[17:00:34.849]                           invokeRestart(restart)
[17:00:34.849]                           muffled <- TRUE
[17:00:34.849]                           break
[17:00:34.849]                         }
[17:00:34.849]                       }
[17:00:34.849]                     }
[17:00:34.849]                     invisible(muffled)
[17:00:34.849]                   }
[17:00:34.849]                   muffleCondition(cond)
[17:00:34.849]                 })
[17:00:34.849]             }))
[17:00:34.849]             future::FutureResult(value = ...future.value$value, 
[17:00:34.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.849]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.849]                     ...future.globalenv.names))
[17:00:34.849]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.849]         }, condition = base::local({
[17:00:34.849]             c <- base::c
[17:00:34.849]             inherits <- base::inherits
[17:00:34.849]             invokeRestart <- base::invokeRestart
[17:00:34.849]             length <- base::length
[17:00:34.849]             list <- base::list
[17:00:34.849]             seq.int <- base::seq.int
[17:00:34.849]             signalCondition <- base::signalCondition
[17:00:34.849]             sys.calls <- base::sys.calls
[17:00:34.849]             `[[` <- base::`[[`
[17:00:34.849]             `+` <- base::`+`
[17:00:34.849]             `<<-` <- base::`<<-`
[17:00:34.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.849]                   3L)]
[17:00:34.849]             }
[17:00:34.849]             function(cond) {
[17:00:34.849]                 is_error <- inherits(cond, "error")
[17:00:34.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.849]                   NULL)
[17:00:34.849]                 if (is_error) {
[17:00:34.849]                   sessionInformation <- function() {
[17:00:34.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.849]                       search = base::search(), system = base::Sys.info())
[17:00:34.849]                   }
[17:00:34.849]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.849]                     cond$call), session = sessionInformation(), 
[17:00:34.849]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.849]                   signalCondition(cond)
[17:00:34.849]                 }
[17:00:34.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.849]                 "immediateCondition"))) {
[17:00:34.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.849]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.849]                   if (TRUE && !signal) {
[17:00:34.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.849]                     {
[17:00:34.849]                       inherits <- base::inherits
[17:00:34.849]                       invokeRestart <- base::invokeRestart
[17:00:34.849]                       is.null <- base::is.null
[17:00:34.849]                       muffled <- FALSE
[17:00:34.849]                       if (inherits(cond, "message")) {
[17:00:34.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.849]                         if (muffled) 
[17:00:34.849]                           invokeRestart("muffleMessage")
[17:00:34.849]                       }
[17:00:34.849]                       else if (inherits(cond, "warning")) {
[17:00:34.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.849]                         if (muffled) 
[17:00:34.849]                           invokeRestart("muffleWarning")
[17:00:34.849]                       }
[17:00:34.849]                       else if (inherits(cond, "condition")) {
[17:00:34.849]                         if (!is.null(pattern)) {
[17:00:34.849]                           computeRestarts <- base::computeRestarts
[17:00:34.849]                           grepl <- base::grepl
[17:00:34.849]                           restarts <- computeRestarts(cond)
[17:00:34.849]                           for (restart in restarts) {
[17:00:34.849]                             name <- restart$name
[17:00:34.849]                             if (is.null(name)) 
[17:00:34.849]                               next
[17:00:34.849]                             if (!grepl(pattern, name)) 
[17:00:34.849]                               next
[17:00:34.849]                             invokeRestart(restart)
[17:00:34.849]                             muffled <- TRUE
[17:00:34.849]                             break
[17:00:34.849]                           }
[17:00:34.849]                         }
[17:00:34.849]                       }
[17:00:34.849]                       invisible(muffled)
[17:00:34.849]                     }
[17:00:34.849]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.849]                   }
[17:00:34.849]                 }
[17:00:34.849]                 else {
[17:00:34.849]                   if (TRUE) {
[17:00:34.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.849]                     {
[17:00:34.849]                       inherits <- base::inherits
[17:00:34.849]                       invokeRestart <- base::invokeRestart
[17:00:34.849]                       is.null <- base::is.null
[17:00:34.849]                       muffled <- FALSE
[17:00:34.849]                       if (inherits(cond, "message")) {
[17:00:34.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.849]                         if (muffled) 
[17:00:34.849]                           invokeRestart("muffleMessage")
[17:00:34.849]                       }
[17:00:34.849]                       else if (inherits(cond, "warning")) {
[17:00:34.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.849]                         if (muffled) 
[17:00:34.849]                           invokeRestart("muffleWarning")
[17:00:34.849]                       }
[17:00:34.849]                       else if (inherits(cond, "condition")) {
[17:00:34.849]                         if (!is.null(pattern)) {
[17:00:34.849]                           computeRestarts <- base::computeRestarts
[17:00:34.849]                           grepl <- base::grepl
[17:00:34.849]                           restarts <- computeRestarts(cond)
[17:00:34.849]                           for (restart in restarts) {
[17:00:34.849]                             name <- restart$name
[17:00:34.849]                             if (is.null(name)) 
[17:00:34.849]                               next
[17:00:34.849]                             if (!grepl(pattern, name)) 
[17:00:34.849]                               next
[17:00:34.849]                             invokeRestart(restart)
[17:00:34.849]                             muffled <- TRUE
[17:00:34.849]                             break
[17:00:34.849]                           }
[17:00:34.849]                         }
[17:00:34.849]                       }
[17:00:34.849]                       invisible(muffled)
[17:00:34.849]                     }
[17:00:34.849]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.849]                   }
[17:00:34.849]                 }
[17:00:34.849]             }
[17:00:34.849]         }))
[17:00:34.849]     }, error = function(ex) {
[17:00:34.849]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.849]                 ...future.rng), started = ...future.startTime, 
[17:00:34.849]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.849]             version = "1.8"), class = "FutureResult")
[17:00:34.849]     }, finally = {
[17:00:34.849]         if (!identical(...future.workdir, getwd())) 
[17:00:34.849]             setwd(...future.workdir)
[17:00:34.849]         {
[17:00:34.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.849]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.849]             }
[17:00:34.849]             base::options(...future.oldOptions)
[17:00:34.849]             if (.Platform$OS.type == "windows") {
[17:00:34.849]                 old_names <- names(...future.oldEnvVars)
[17:00:34.849]                 envs <- base::Sys.getenv()
[17:00:34.849]                 names <- names(envs)
[17:00:34.849]                 common <- intersect(names, old_names)
[17:00:34.849]                 added <- setdiff(names, old_names)
[17:00:34.849]                 removed <- setdiff(old_names, names)
[17:00:34.849]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.849]                   envs[common]]
[17:00:34.849]                 NAMES <- toupper(changed)
[17:00:34.849]                 args <- list()
[17:00:34.849]                 for (kk in seq_along(NAMES)) {
[17:00:34.849]                   name <- changed[[kk]]
[17:00:34.849]                   NAME <- NAMES[[kk]]
[17:00:34.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.849]                     next
[17:00:34.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.849]                 }
[17:00:34.849]                 NAMES <- toupper(added)
[17:00:34.849]                 for (kk in seq_along(NAMES)) {
[17:00:34.849]                   name <- added[[kk]]
[17:00:34.849]                   NAME <- NAMES[[kk]]
[17:00:34.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.849]                     next
[17:00:34.849]                   args[[name]] <- ""
[17:00:34.849]                 }
[17:00:34.849]                 NAMES <- toupper(removed)
[17:00:34.849]                 for (kk in seq_along(NAMES)) {
[17:00:34.849]                   name <- removed[[kk]]
[17:00:34.849]                   NAME <- NAMES[[kk]]
[17:00:34.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.849]                     next
[17:00:34.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.849]                 }
[17:00:34.849]                 if (length(args) > 0) 
[17:00:34.849]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.849]             }
[17:00:34.849]             else {
[17:00:34.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.849]             }
[17:00:34.849]             {
[17:00:34.849]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.849]                   0L) {
[17:00:34.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.849]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.849]                   base::options(opts)
[17:00:34.849]                 }
[17:00:34.849]                 {
[17:00:34.849]                   {
[17:00:34.849]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.849]                     NULL
[17:00:34.849]                   }
[17:00:34.849]                   options(future.plan = NULL)
[17:00:34.849]                   if (is.na(NA_character_)) 
[17:00:34.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.849]                     .init = FALSE)
[17:00:34.849]                 }
[17:00:34.849]             }
[17:00:34.849]         }
[17:00:34.849]     })
[17:00:34.849]     if (TRUE) {
[17:00:34.849]         base::sink(type = "output", split = FALSE)
[17:00:34.849]         if (TRUE) {
[17:00:34.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.849]         }
[17:00:34.849]         else {
[17:00:34.849]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.849]         }
[17:00:34.849]         base::close(...future.stdout)
[17:00:34.849]         ...future.stdout <- NULL
[17:00:34.849]     }
[17:00:34.849]     ...future.result$conditions <- ...future.conditions
[17:00:34.849]     ...future.result$finished <- base::Sys.time()
[17:00:34.849]     ...future.result
[17:00:34.849] }
[17:00:34.852] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:00:34.853] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:00:34.853] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:00:34.853] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:34.853] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.853] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:00:34.854] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:00:34.854] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:34.854] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.854] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:34.855] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.855] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:00:34.855] MultisessionFuture started
[17:00:34.855] - Launch lazy future ... done
[17:00:34.855] run() for ‘MultisessionFuture’ ... done
[17:00:34.856] Created future:
[17:00:34.856] MultisessionFuture:
[17:00:34.856] Label: ‘future_mapply-1’
[17:00:34.856] Expression:
[17:00:34.856] {
[17:00:34.856]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.856]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.856]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.856]         on.exit(options(oopts), add = TRUE)
[17:00:34.856]     }
[17:00:34.856]     {
[17:00:34.856]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.856]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.856]         do.call(mapply, args = args)
[17:00:34.856]     }
[17:00:34.856] }
[17:00:34.856] Lazy evaluation: FALSE
[17:00:34.856] Asynchronous evaluation: TRUE
[17:00:34.856] Local evaluation: TRUE
[17:00:34.856] Environment: R_GlobalEnv
[17:00:34.856] Capture standard output: TRUE
[17:00:34.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.856] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.856] Packages: <none>
[17:00:34.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.856] Resolved: FALSE
[17:00:34.856] Value: <not collected>
[17:00:34.856] Conditions captured: <none>
[17:00:34.856] Early signaling: FALSE
[17:00:34.856] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.856] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.867] Chunk #1 of 2 ... DONE
[17:00:34.867] Chunk #2 of 2 ...
[17:00:34.867]  - Finding globals in '...' for chunk #2 ...
[17:00:34.868] getGlobalsAndPackages() ...
[17:00:34.868] Searching for globals...
[17:00:34.868] 
[17:00:34.868] Searching for globals ... DONE
[17:00:34.868] - globals: [0] <none>
[17:00:34.868] getGlobalsAndPackages() ... DONE
[17:00:34.868]    + additional globals found: [n=0] 
[17:00:34.869]    + additional namespaces needed: [n=0] 
[17:00:34.869]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:34.869]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.869]  - seeds: <none>
[17:00:34.869]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.869] getGlobalsAndPackages() ...
[17:00:34.869] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.869] Resolving globals: FALSE
[17:00:34.870] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:34.870] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:34.870] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.870] 
[17:00:34.871] getGlobalsAndPackages() ... DONE
[17:00:34.871] run() for ‘Future’ ...
[17:00:34.871] - state: ‘created’
[17:00:34.871] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.885] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.886]   - Field: ‘node’
[17:00:34.886]   - Field: ‘label’
[17:00:34.886]   - Field: ‘local’
[17:00:34.886]   - Field: ‘owner’
[17:00:34.886]   - Field: ‘envir’
[17:00:34.886]   - Field: ‘workers’
[17:00:34.886]   - Field: ‘packages’
[17:00:34.886]   - Field: ‘gc’
[17:00:34.886]   - Field: ‘conditions’
[17:00:34.886]   - Field: ‘persistent’
[17:00:34.886]   - Field: ‘expr’
[17:00:34.887]   - Field: ‘uuid’
[17:00:34.887]   - Field: ‘seed’
[17:00:34.887]   - Field: ‘version’
[17:00:34.887]   - Field: ‘result’
[17:00:34.887]   - Field: ‘asynchronous’
[17:00:34.887]   - Field: ‘calls’
[17:00:34.887]   - Field: ‘globals’
[17:00:34.887]   - Field: ‘stdout’
[17:00:34.887]   - Field: ‘earlySignal’
[17:00:34.887]   - Field: ‘lazy’
[17:00:34.888]   - Field: ‘state’
[17:00:34.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.888] - Launch lazy future ...
[17:00:34.888] Packages needed by the future expression (n = 0): <none>
[17:00:34.888] Packages needed by future strategies (n = 0): <none>
[17:00:34.889] {
[17:00:34.889]     {
[17:00:34.889]         {
[17:00:34.889]             ...future.startTime <- base::Sys.time()
[17:00:34.889]             {
[17:00:34.889]                 {
[17:00:34.889]                   {
[17:00:34.889]                     {
[17:00:34.889]                       base::local({
[17:00:34.889]                         has_future <- base::requireNamespace("future", 
[17:00:34.889]                           quietly = TRUE)
[17:00:34.889]                         if (has_future) {
[17:00:34.889]                           ns <- base::getNamespace("future")
[17:00:34.889]                           version <- ns[[".package"]][["version"]]
[17:00:34.889]                           if (is.null(version)) 
[17:00:34.889]                             version <- utils::packageVersion("future")
[17:00:34.889]                         }
[17:00:34.889]                         else {
[17:00:34.889]                           version <- NULL
[17:00:34.889]                         }
[17:00:34.889]                         if (!has_future || version < "1.8.0") {
[17:00:34.889]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.889]                             "", base::R.version$version.string), 
[17:00:34.889]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:34.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:34.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.889]                               "release", "version")], collapse = " "), 
[17:00:34.889]                             hostname = base::Sys.info()[["nodename"]])
[17:00:34.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.889]                             info)
[17:00:34.889]                           info <- base::paste(info, collapse = "; ")
[17:00:34.889]                           if (!has_future) {
[17:00:34.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.889]                               info)
[17:00:34.889]                           }
[17:00:34.889]                           else {
[17:00:34.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.889]                               info, version)
[17:00:34.889]                           }
[17:00:34.889]                           base::stop(msg)
[17:00:34.889]                         }
[17:00:34.889]                       })
[17:00:34.889]                     }
[17:00:34.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.889]                     base::options(mc.cores = 1L)
[17:00:34.889]                   }
[17:00:34.889]                   ...future.strategy.old <- future::plan("list")
[17:00:34.889]                   options(future.plan = NULL)
[17:00:34.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.889]                 }
[17:00:34.889]                 ...future.workdir <- getwd()
[17:00:34.889]             }
[17:00:34.889]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.889]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.889]         }
[17:00:34.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.889]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.889]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.889]             base::names(...future.oldOptions))
[17:00:34.889]     }
[17:00:34.889]     if (FALSE) {
[17:00:34.889]     }
[17:00:34.889]     else {
[17:00:34.889]         if (TRUE) {
[17:00:34.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.889]                 open = "w")
[17:00:34.889]         }
[17:00:34.889]         else {
[17:00:34.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.889]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.889]         }
[17:00:34.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.889]             base::sink(type = "output", split = FALSE)
[17:00:34.889]             base::close(...future.stdout)
[17:00:34.889]         }, add = TRUE)
[17:00:34.889]     }
[17:00:34.889]     ...future.frame <- base::sys.nframe()
[17:00:34.889]     ...future.conditions <- base::list()
[17:00:34.889]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.889]     if (FALSE) {
[17:00:34.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.889]     }
[17:00:34.889]     ...future.result <- base::tryCatch({
[17:00:34.889]         base::withCallingHandlers({
[17:00:34.889]             ...future.value <- base::withVisible(base::local({
[17:00:34.889]                 ...future.makeSendCondition <- base::local({
[17:00:34.889]                   sendCondition <- NULL
[17:00:34.889]                   function(frame = 1L) {
[17:00:34.889]                     if (is.function(sendCondition)) 
[17:00:34.889]                       return(sendCondition)
[17:00:34.889]                     ns <- getNamespace("parallel")
[17:00:34.889]                     if (exists("sendData", mode = "function", 
[17:00:34.889]                       envir = ns)) {
[17:00:34.889]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.889]                         envir = ns)
[17:00:34.889]                       envir <- sys.frame(frame)
[17:00:34.889]                       master <- NULL
[17:00:34.889]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.889]                         !identical(envir, emptyenv())) {
[17:00:34.889]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.889]                           inherits = FALSE)) {
[17:00:34.889]                           master <- get("master", mode = "list", 
[17:00:34.889]                             envir = envir, inherits = FALSE)
[17:00:34.889]                           if (inherits(master, c("SOCKnode", 
[17:00:34.889]                             "SOCK0node"))) {
[17:00:34.889]                             sendCondition <<- function(cond) {
[17:00:34.889]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.889]                                 success = TRUE)
[17:00:34.889]                               parallel_sendData(master, data)
[17:00:34.889]                             }
[17:00:34.889]                             return(sendCondition)
[17:00:34.889]                           }
[17:00:34.889]                         }
[17:00:34.889]                         frame <- frame + 1L
[17:00:34.889]                         envir <- sys.frame(frame)
[17:00:34.889]                       }
[17:00:34.889]                     }
[17:00:34.889]                     sendCondition <<- function(cond) NULL
[17:00:34.889]                   }
[17:00:34.889]                 })
[17:00:34.889]                 withCallingHandlers({
[17:00:34.889]                   {
[17:00:34.889]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.889]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.889]                       ...future.globals.maxSize)) {
[17:00:34.889]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.889]                       on.exit(options(oopts), add = TRUE)
[17:00:34.889]                     }
[17:00:34.889]                     {
[17:00:34.889]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.889]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.889]                         USE.NAMES = FALSE)
[17:00:34.889]                       do.call(mapply, args = args)
[17:00:34.889]                     }
[17:00:34.889]                   }
[17:00:34.889]                 }, immediateCondition = function(cond) {
[17:00:34.889]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.889]                   sendCondition(cond)
[17:00:34.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.889]                   {
[17:00:34.889]                     inherits <- base::inherits
[17:00:34.889]                     invokeRestart <- base::invokeRestart
[17:00:34.889]                     is.null <- base::is.null
[17:00:34.889]                     muffled <- FALSE
[17:00:34.889]                     if (inherits(cond, "message")) {
[17:00:34.889]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.889]                       if (muffled) 
[17:00:34.889]                         invokeRestart("muffleMessage")
[17:00:34.889]                     }
[17:00:34.889]                     else if (inherits(cond, "warning")) {
[17:00:34.889]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.889]                       if (muffled) 
[17:00:34.889]                         invokeRestart("muffleWarning")
[17:00:34.889]                     }
[17:00:34.889]                     else if (inherits(cond, "condition")) {
[17:00:34.889]                       if (!is.null(pattern)) {
[17:00:34.889]                         computeRestarts <- base::computeRestarts
[17:00:34.889]                         grepl <- base::grepl
[17:00:34.889]                         restarts <- computeRestarts(cond)
[17:00:34.889]                         for (restart in restarts) {
[17:00:34.889]                           name <- restart$name
[17:00:34.889]                           if (is.null(name)) 
[17:00:34.889]                             next
[17:00:34.889]                           if (!grepl(pattern, name)) 
[17:00:34.889]                             next
[17:00:34.889]                           invokeRestart(restart)
[17:00:34.889]                           muffled <- TRUE
[17:00:34.889]                           break
[17:00:34.889]                         }
[17:00:34.889]                       }
[17:00:34.889]                     }
[17:00:34.889]                     invisible(muffled)
[17:00:34.889]                   }
[17:00:34.889]                   muffleCondition(cond)
[17:00:34.889]                 })
[17:00:34.889]             }))
[17:00:34.889]             future::FutureResult(value = ...future.value$value, 
[17:00:34.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.889]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.889]                     ...future.globalenv.names))
[17:00:34.889]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.889]         }, condition = base::local({
[17:00:34.889]             c <- base::c
[17:00:34.889]             inherits <- base::inherits
[17:00:34.889]             invokeRestart <- base::invokeRestart
[17:00:34.889]             length <- base::length
[17:00:34.889]             list <- base::list
[17:00:34.889]             seq.int <- base::seq.int
[17:00:34.889]             signalCondition <- base::signalCondition
[17:00:34.889]             sys.calls <- base::sys.calls
[17:00:34.889]             `[[` <- base::`[[`
[17:00:34.889]             `+` <- base::`+`
[17:00:34.889]             `<<-` <- base::`<<-`
[17:00:34.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.889]                   3L)]
[17:00:34.889]             }
[17:00:34.889]             function(cond) {
[17:00:34.889]                 is_error <- inherits(cond, "error")
[17:00:34.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.889]                   NULL)
[17:00:34.889]                 if (is_error) {
[17:00:34.889]                   sessionInformation <- function() {
[17:00:34.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.889]                       search = base::search(), system = base::Sys.info())
[17:00:34.889]                   }
[17:00:34.889]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.889]                     cond$call), session = sessionInformation(), 
[17:00:34.889]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.889]                   signalCondition(cond)
[17:00:34.889]                 }
[17:00:34.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.889]                 "immediateCondition"))) {
[17:00:34.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.889]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.889]                   if (TRUE && !signal) {
[17:00:34.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.889]                     {
[17:00:34.889]                       inherits <- base::inherits
[17:00:34.889]                       invokeRestart <- base::invokeRestart
[17:00:34.889]                       is.null <- base::is.null
[17:00:34.889]                       muffled <- FALSE
[17:00:34.889]                       if (inherits(cond, "message")) {
[17:00:34.889]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.889]                         if (muffled) 
[17:00:34.889]                           invokeRestart("muffleMessage")
[17:00:34.889]                       }
[17:00:34.889]                       else if (inherits(cond, "warning")) {
[17:00:34.889]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.889]                         if (muffled) 
[17:00:34.889]                           invokeRestart("muffleWarning")
[17:00:34.889]                       }
[17:00:34.889]                       else if (inherits(cond, "condition")) {
[17:00:34.889]                         if (!is.null(pattern)) {
[17:00:34.889]                           computeRestarts <- base::computeRestarts
[17:00:34.889]                           grepl <- base::grepl
[17:00:34.889]                           restarts <- computeRestarts(cond)
[17:00:34.889]                           for (restart in restarts) {
[17:00:34.889]                             name <- restart$name
[17:00:34.889]                             if (is.null(name)) 
[17:00:34.889]                               next
[17:00:34.889]                             if (!grepl(pattern, name)) 
[17:00:34.889]                               next
[17:00:34.889]                             invokeRestart(restart)
[17:00:34.889]                             muffled <- TRUE
[17:00:34.889]                             break
[17:00:34.889]                           }
[17:00:34.889]                         }
[17:00:34.889]                       }
[17:00:34.889]                       invisible(muffled)
[17:00:34.889]                     }
[17:00:34.889]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.889]                   }
[17:00:34.889]                 }
[17:00:34.889]                 else {
[17:00:34.889]                   if (TRUE) {
[17:00:34.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.889]                     {
[17:00:34.889]                       inherits <- base::inherits
[17:00:34.889]                       invokeRestart <- base::invokeRestart
[17:00:34.889]                       is.null <- base::is.null
[17:00:34.889]                       muffled <- FALSE
[17:00:34.889]                       if (inherits(cond, "message")) {
[17:00:34.889]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.889]                         if (muffled) 
[17:00:34.889]                           invokeRestart("muffleMessage")
[17:00:34.889]                       }
[17:00:34.889]                       else if (inherits(cond, "warning")) {
[17:00:34.889]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.889]                         if (muffled) 
[17:00:34.889]                           invokeRestart("muffleWarning")
[17:00:34.889]                       }
[17:00:34.889]                       else if (inherits(cond, "condition")) {
[17:00:34.889]                         if (!is.null(pattern)) {
[17:00:34.889]                           computeRestarts <- base::computeRestarts
[17:00:34.889]                           grepl <- base::grepl
[17:00:34.889]                           restarts <- computeRestarts(cond)
[17:00:34.889]                           for (restart in restarts) {
[17:00:34.889]                             name <- restart$name
[17:00:34.889]                             if (is.null(name)) 
[17:00:34.889]                               next
[17:00:34.889]                             if (!grepl(pattern, name)) 
[17:00:34.889]                               next
[17:00:34.889]                             invokeRestart(restart)
[17:00:34.889]                             muffled <- TRUE
[17:00:34.889]                             break
[17:00:34.889]                           }
[17:00:34.889]                         }
[17:00:34.889]                       }
[17:00:34.889]                       invisible(muffled)
[17:00:34.889]                     }
[17:00:34.889]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.889]                   }
[17:00:34.889]                 }
[17:00:34.889]             }
[17:00:34.889]         }))
[17:00:34.889]     }, error = function(ex) {
[17:00:34.889]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.889]                 ...future.rng), started = ...future.startTime, 
[17:00:34.889]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.889]             version = "1.8"), class = "FutureResult")
[17:00:34.889]     }, finally = {
[17:00:34.889]         if (!identical(...future.workdir, getwd())) 
[17:00:34.889]             setwd(...future.workdir)
[17:00:34.889]         {
[17:00:34.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.889]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.889]             }
[17:00:34.889]             base::options(...future.oldOptions)
[17:00:34.889]             if (.Platform$OS.type == "windows") {
[17:00:34.889]                 old_names <- names(...future.oldEnvVars)
[17:00:34.889]                 envs <- base::Sys.getenv()
[17:00:34.889]                 names <- names(envs)
[17:00:34.889]                 common <- intersect(names, old_names)
[17:00:34.889]                 added <- setdiff(names, old_names)
[17:00:34.889]                 removed <- setdiff(old_names, names)
[17:00:34.889]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.889]                   envs[common]]
[17:00:34.889]                 NAMES <- toupper(changed)
[17:00:34.889]                 args <- list()
[17:00:34.889]                 for (kk in seq_along(NAMES)) {
[17:00:34.889]                   name <- changed[[kk]]
[17:00:34.889]                   NAME <- NAMES[[kk]]
[17:00:34.889]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.889]                     next
[17:00:34.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.889]                 }
[17:00:34.889]                 NAMES <- toupper(added)
[17:00:34.889]                 for (kk in seq_along(NAMES)) {
[17:00:34.889]                   name <- added[[kk]]
[17:00:34.889]                   NAME <- NAMES[[kk]]
[17:00:34.889]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.889]                     next
[17:00:34.889]                   args[[name]] <- ""
[17:00:34.889]                 }
[17:00:34.889]                 NAMES <- toupper(removed)
[17:00:34.889]                 for (kk in seq_along(NAMES)) {
[17:00:34.889]                   name <- removed[[kk]]
[17:00:34.889]                   NAME <- NAMES[[kk]]
[17:00:34.889]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.889]                     next
[17:00:34.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.889]                 }
[17:00:34.889]                 if (length(args) > 0) 
[17:00:34.889]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.889]             }
[17:00:34.889]             else {
[17:00:34.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.889]             }
[17:00:34.889]             {
[17:00:34.889]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.889]                   0L) {
[17:00:34.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.889]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.889]                   base::options(opts)
[17:00:34.889]                 }
[17:00:34.889]                 {
[17:00:34.889]                   {
[17:00:34.889]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.889]                     NULL
[17:00:34.889]                   }
[17:00:34.889]                   options(future.plan = NULL)
[17:00:34.889]                   if (is.na(NA_character_)) 
[17:00:34.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.889]                     .init = FALSE)
[17:00:34.889]                 }
[17:00:34.889]             }
[17:00:34.889]         }
[17:00:34.889]     })
[17:00:34.889]     if (TRUE) {
[17:00:34.889]         base::sink(type = "output", split = FALSE)
[17:00:34.889]         if (TRUE) {
[17:00:34.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.889]         }
[17:00:34.889]         else {
[17:00:34.889]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.889]         }
[17:00:34.889]         base::close(...future.stdout)
[17:00:34.889]         ...future.stdout <- NULL
[17:00:34.889]     }
[17:00:34.889]     ...future.result$conditions <- ...future.conditions
[17:00:34.889]     ...future.result$finished <- base::Sys.time()
[17:00:34.889]     ...future.result
[17:00:34.889] }
[17:00:34.891] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:00:34.892] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:00:34.892] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:00:34.892] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:34.893] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.893] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:00:34.893] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:00:34.893] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:34.894] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.894] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:34.894] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:34.894] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:00:34.895] MultisessionFuture started
[17:00:34.895] - Launch lazy future ... done
[17:00:34.895] run() for ‘MultisessionFuture’ ... done
[17:00:34.895] Created future:
[17:00:34.895] MultisessionFuture:
[17:00:34.895] Label: ‘future_mapply-2’
[17:00:34.895] Expression:
[17:00:34.895] {
[17:00:34.895]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.895]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.895]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.895]         on.exit(options(oopts), add = TRUE)
[17:00:34.895]     }
[17:00:34.895]     {
[17:00:34.895]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:34.895]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.895]         do.call(mapply, args = args)
[17:00:34.895]     }
[17:00:34.895] }
[17:00:34.895] Lazy evaluation: FALSE
[17:00:34.895] Asynchronous evaluation: TRUE
[17:00:34.895] Local evaluation: TRUE
[17:00:34.895] Environment: R_GlobalEnv
[17:00:34.895] Capture standard output: TRUE
[17:00:34.895] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.895] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.895] Packages: <none>
[17:00:34.895] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:34.895] Resolved: FALSE
[17:00:34.895] Value: <not collected>
[17:00:34.895] Conditions captured: <none>
[17:00:34.895] Early signaling: FALSE
[17:00:34.895] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.895] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.907] Chunk #2 of 2 ... DONE
[17:00:34.907] Launching 2 futures (chunks) ... DONE
[17:00:34.907] Resolving 2 futures (chunks) ...
[17:00:34.907] resolve() on list ...
[17:00:34.907]  recursive: 0
[17:00:34.908]  length: 2
[17:00:34.908] 
[17:00:34.908] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.908] - Validating connection of MultisessionFuture
[17:00:34.908] - received message: FutureResult
[17:00:34.909] - Received FutureResult
[17:00:34.909] - Erased future from FutureRegistry
[17:00:34.909] result() for ClusterFuture ...
[17:00:34.909] - result already collected: FutureResult
[17:00:34.909] result() for ClusterFuture ... done
[17:00:34.909] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.909] Future #1
[17:00:34.909] result() for ClusterFuture ...
[17:00:34.909] - result already collected: FutureResult
[17:00:34.909] result() for ClusterFuture ... done
[17:00:34.910] result() for ClusterFuture ...
[17:00:34.910] - result already collected: FutureResult
[17:00:34.910] result() for ClusterFuture ... done
[17:00:34.910] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:34.910] - nx: 2
[17:00:34.910] - relay: TRUE
[17:00:34.910] - stdout: TRUE
[17:00:34.910] - signal: TRUE
[17:00:34.910] - resignal: FALSE
[17:00:34.910] - force: TRUE
[17:00:34.910] - relayed: [n=2] FALSE, FALSE
[17:00:34.910] - queued futures: [n=2] FALSE, FALSE
[17:00:34.911]  - until=1
[17:00:34.911]  - relaying element #1
[17:00:34.911] result() for ClusterFuture ...
[17:00:34.911] - result already collected: FutureResult
[17:00:34.911] result() for ClusterFuture ... done
[17:00:34.911] result() for ClusterFuture ...
[17:00:34.911] - result already collected: FutureResult
[17:00:34.911] result() for ClusterFuture ... done
[17:00:34.911] result() for ClusterFuture ...
[17:00:34.911] - result already collected: FutureResult
[17:00:34.911] result() for ClusterFuture ... done
[17:00:34.912] result() for ClusterFuture ...
[17:00:34.912] - result already collected: FutureResult
[17:00:34.912] result() for ClusterFuture ... done
[17:00:34.912] - relayed: [n=2] TRUE, FALSE
[17:00:34.912] - queued futures: [n=2] TRUE, FALSE
[17:00:34.912] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:34.912]  length: 1 (resolved future 1)
[17:00:34.937] receiveMessageFromWorker() for ClusterFuture ...
[17:00:34.937] - Validating connection of MultisessionFuture
[17:00:34.937] - received message: FutureResult
[17:00:34.938] - Received FutureResult
[17:00:34.938] - Erased future from FutureRegistry
[17:00:34.938] result() for ClusterFuture ...
[17:00:34.938] - result already collected: FutureResult
[17:00:34.938] result() for ClusterFuture ... done
[17:00:34.938] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:34.938] Future #2
[17:00:34.938] result() for ClusterFuture ...
[17:00:34.938] - result already collected: FutureResult
[17:00:34.938] result() for ClusterFuture ... done
[17:00:34.939] result() for ClusterFuture ...
[17:00:34.939] - result already collected: FutureResult
[17:00:34.939] result() for ClusterFuture ... done
[17:00:34.939] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:34.939] - nx: 2
[17:00:34.939] - relay: TRUE
[17:00:34.939] - stdout: TRUE
[17:00:34.939] - signal: TRUE
[17:00:34.939] - resignal: FALSE
[17:00:34.939] - force: TRUE
[17:00:34.939] - relayed: [n=2] TRUE, FALSE
[17:00:34.940] - queued futures: [n=2] TRUE, FALSE
[17:00:34.940]  - until=2
[17:00:34.940]  - relaying element #2
[17:00:34.940] result() for ClusterFuture ...
[17:00:34.940] - result already collected: FutureResult
[17:00:34.940] result() for ClusterFuture ... done
[17:00:34.940] result() for ClusterFuture ...
[17:00:34.940] - result already collected: FutureResult
[17:00:34.940] result() for ClusterFuture ... done
[17:00:34.940] result() for ClusterFuture ...
[17:00:34.940] - result already collected: FutureResult
[17:00:34.941] result() for ClusterFuture ... done
[17:00:34.941] result() for ClusterFuture ...
[17:00:34.941] - result already collected: FutureResult
[17:00:34.941] result() for ClusterFuture ... done
[17:00:34.941] - relayed: [n=2] TRUE, TRUE
[17:00:34.941] - queued futures: [n=2] TRUE, TRUE
[17:00:34.941] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:34.941]  length: 0 (resolved future 2)
[17:00:34.941] Relaying remaining futures
[17:00:34.941] signalConditionsASAP(NULL, pos=0) ...
[17:00:34.941] - nx: 2
[17:00:34.941] - relay: TRUE
[17:00:34.942] - stdout: TRUE
[17:00:34.942] - signal: TRUE
[17:00:34.942] - resignal: FALSE
[17:00:34.942] - force: TRUE
[17:00:34.942] - relayed: [n=2] TRUE, TRUE
[17:00:34.942] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:34.942] - relayed: [n=2] TRUE, TRUE
[17:00:34.942] - queued futures: [n=2] TRUE, TRUE
[17:00:34.942] signalConditionsASAP(NULL, pos=0) ... done
[17:00:34.942] resolve() on list ... DONE
[17:00:34.942] result() for ClusterFuture ...
[17:00:34.943] - result already collected: FutureResult
[17:00:34.943] result() for ClusterFuture ... done
[17:00:34.943] result() for ClusterFuture ...
[17:00:34.943] - result already collected: FutureResult
[17:00:34.943] result() for ClusterFuture ... done
[17:00:34.943] result() for ClusterFuture ...
[17:00:34.943] - result already collected: FutureResult
[17:00:34.943] result() for ClusterFuture ... done
[17:00:34.943] result() for ClusterFuture ...
[17:00:34.943] - result already collected: FutureResult
[17:00:34.943] result() for ClusterFuture ... done
[17:00:34.944]  - Number of value chunks collected: 2
[17:00:34.944] Resolving 2 futures (chunks) ... DONE
[17:00:34.944] Reducing values from 2 chunks ...
[17:00:34.944]  - Number of values collected after concatenation: 4
[17:00:34.944]  - Number of values expected: 4
[17:00:34.944] Reducing values from 2 chunks ... DONE
[17:00:34.944] future_mapply() ... DONE
- Parallel RNG ...
[17:00:34.944] future_mapply() ...
[17:00:34.944] Generating random seeds ...
[17:00:34.945] Generating random seed streams for 4 elements ...
[17:00:34.945] Generating random seed streams for 4 elements ... DONE
[17:00:34.945] Generating random seeds ... DONE
[17:00:34.945] Will set RNG state on exit: 10407, -864734119, -295750991, -216078594, -818934511, -1408974628, -91446427
[17:00:34.949] Number of chunks: 2
[17:00:34.949] getGlobalsAndPackagesXApply() ...
[17:00:34.949]  - future.globals: TRUE
[17:00:34.949] getGlobalsAndPackages() ...
[17:00:34.949] Searching for globals...
[17:00:34.950] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:00:34.950] Searching for globals ... DONE
[17:00:34.951] Resolving globals: FALSE
[17:00:34.951] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:00:34.951] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:00:34.952] - globals: [1] ‘FUN’
[17:00:34.952] - packages: [1] ‘stats’
[17:00:34.952] getGlobalsAndPackages() ... DONE
[17:00:34.952]  - globals found/used: [n=1] ‘FUN’
[17:00:34.952]  - needed namespaces: [n=1] ‘stats’
[17:00:34.952] Finding globals ... DONE
[17:00:34.952] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:34.952] List of 2
[17:00:34.952]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:00:34.952]  $ MoreArgs     :List of 1
[17:00:34.952]   ..$ min: num 1
[17:00:34.952]  - attr(*, "where")=List of 2
[17:00:34.952]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:34.952]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:34.952]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:34.952]  - attr(*, "resolved")= logi FALSE
[17:00:34.952]  - attr(*, "total_size")= num NA
[17:00:34.955] Packages to be attached in all futures: [n=1] ‘stats’
[17:00:34.955] getGlobalsAndPackagesXApply() ... DONE
[17:00:34.955] Number of futures (= number of chunks): 2
[17:00:34.956] Launching 2 futures (chunks) ...
[17:00:34.956] Chunk #1 of 2 ...
[17:00:34.956]  - Finding globals in '...' for chunk #1 ...
[17:00:34.956] getGlobalsAndPackages() ...
[17:00:34.956] Searching for globals...
[17:00:34.956] 
[17:00:34.956] Searching for globals ... DONE
[17:00:34.956] - globals: [0] <none>
[17:00:34.957] getGlobalsAndPackages() ... DONE
[17:00:34.957]    + additional globals found: [n=0] 
[17:00:34.957]    + additional namespaces needed: [n=0] 
[17:00:34.957]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:34.957]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.957]  - seeds: [2] <seeds>
[17:00:34.957]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.957] getGlobalsAndPackages() ...
[17:00:34.958] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.958] Resolving globals: FALSE
[17:00:34.958] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:00:34.959] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:00:34.959] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.959] - packages: [1] ‘stats’
[17:00:34.959] getGlobalsAndPackages() ... DONE
[17:00:34.960] run() for ‘Future’ ...
[17:00:34.960] - state: ‘created’
[17:00:34.960] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:34.974] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:34.975]   - Field: ‘node’
[17:00:34.975]   - Field: ‘label’
[17:00:34.975]   - Field: ‘local’
[17:00:34.975]   - Field: ‘owner’
[17:00:34.975]   - Field: ‘envir’
[17:00:34.975]   - Field: ‘workers’
[17:00:34.975]   - Field: ‘packages’
[17:00:34.975]   - Field: ‘gc’
[17:00:34.975]   - Field: ‘conditions’
[17:00:34.976]   - Field: ‘persistent’
[17:00:34.976]   - Field: ‘expr’
[17:00:34.976]   - Field: ‘uuid’
[17:00:34.976]   - Field: ‘seed’
[17:00:34.976]   - Field: ‘version’
[17:00:34.976]   - Field: ‘result’
[17:00:34.976]   - Field: ‘asynchronous’
[17:00:34.976]   - Field: ‘calls’
[17:00:34.976]   - Field: ‘globals’
[17:00:34.976]   - Field: ‘stdout’
[17:00:34.977]   - Field: ‘earlySignal’
[17:00:34.977]   - Field: ‘lazy’
[17:00:34.977]   - Field: ‘state’
[17:00:34.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:34.977] - Launch lazy future ...
[17:00:34.977] Packages needed by the future expression (n = 1): ‘stats’
[17:00:34.977] Packages needed by future strategies (n = 0): <none>
[17:00:34.978] {
[17:00:34.978]     {
[17:00:34.978]         {
[17:00:34.978]             ...future.startTime <- base::Sys.time()
[17:00:34.978]             {
[17:00:34.978]                 {
[17:00:34.978]                   {
[17:00:34.978]                     {
[17:00:34.978]                       {
[17:00:34.978]                         base::local({
[17:00:34.978]                           has_future <- base::requireNamespace("future", 
[17:00:34.978]                             quietly = TRUE)
[17:00:34.978]                           if (has_future) {
[17:00:34.978]                             ns <- base::getNamespace("future")
[17:00:34.978]                             version <- ns[[".package"]][["version"]]
[17:00:34.978]                             if (is.null(version)) 
[17:00:34.978]                               version <- utils::packageVersion("future")
[17:00:34.978]                           }
[17:00:34.978]                           else {
[17:00:34.978]                             version <- NULL
[17:00:34.978]                           }
[17:00:34.978]                           if (!has_future || version < "1.8.0") {
[17:00:34.978]                             info <- base::c(r_version = base::gsub("R version ", 
[17:00:34.978]                               "", base::R.version$version.string), 
[17:00:34.978]                               platform = base::sprintf("%s (%s-bit)", 
[17:00:34.978]                                 base::R.version$platform, 8 * 
[17:00:34.978]                                   base::.Machine$sizeof.pointer), 
[17:00:34.978]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:34.978]                                 "release", "version")], collapse = " "), 
[17:00:34.978]                               hostname = base::Sys.info()[["nodename"]])
[17:00:34.978]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:00:34.978]                               info)
[17:00:34.978]                             info <- base::paste(info, collapse = "; ")
[17:00:34.978]                             if (!has_future) {
[17:00:34.978]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:34.978]                                 info)
[17:00:34.978]                             }
[17:00:34.978]                             else {
[17:00:34.978]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:34.978]                                 info, version)
[17:00:34.978]                             }
[17:00:34.978]                             base::stop(msg)
[17:00:34.978]                           }
[17:00:34.978]                         })
[17:00:34.978]                       }
[17:00:34.978]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:34.978]                       base::options(mc.cores = 1L)
[17:00:34.978]                     }
[17:00:34.978]                     base::local({
[17:00:34.978]                       for (pkg in "stats") {
[17:00:34.978]                         base::loadNamespace(pkg)
[17:00:34.978]                         base::library(pkg, character.only = TRUE)
[17:00:34.978]                       }
[17:00:34.978]                     })
[17:00:34.978]                   }
[17:00:34.978]                   ...future.strategy.old <- future::plan("list")
[17:00:34.978]                   options(future.plan = NULL)
[17:00:34.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:34.978]                 }
[17:00:34.978]                 ...future.workdir <- getwd()
[17:00:34.978]             }
[17:00:34.978]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:34.978]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:34.978]         }
[17:00:34.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:34.978]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:34.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:34.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:34.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:34.978]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:34.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:34.978]             base::names(...future.oldOptions))
[17:00:34.978]     }
[17:00:34.978]     if (FALSE) {
[17:00:34.978]     }
[17:00:34.978]     else {
[17:00:34.978]         if (TRUE) {
[17:00:34.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:34.978]                 open = "w")
[17:00:34.978]         }
[17:00:34.978]         else {
[17:00:34.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:34.978]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:34.978]         }
[17:00:34.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:34.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:34.978]             base::sink(type = "output", split = FALSE)
[17:00:34.978]             base::close(...future.stdout)
[17:00:34.978]         }, add = TRUE)
[17:00:34.978]     }
[17:00:34.978]     ...future.frame <- base::sys.nframe()
[17:00:34.978]     ...future.conditions <- base::list()
[17:00:34.978]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:34.978]     if (FALSE) {
[17:00:34.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:34.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:34.978]     }
[17:00:34.978]     ...future.result <- base::tryCatch({
[17:00:34.978]         base::withCallingHandlers({
[17:00:34.978]             ...future.value <- base::withVisible(base::local({
[17:00:34.978]                 ...future.makeSendCondition <- base::local({
[17:00:34.978]                   sendCondition <- NULL
[17:00:34.978]                   function(frame = 1L) {
[17:00:34.978]                     if (is.function(sendCondition)) 
[17:00:34.978]                       return(sendCondition)
[17:00:34.978]                     ns <- getNamespace("parallel")
[17:00:34.978]                     if (exists("sendData", mode = "function", 
[17:00:34.978]                       envir = ns)) {
[17:00:34.978]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:34.978]                         envir = ns)
[17:00:34.978]                       envir <- sys.frame(frame)
[17:00:34.978]                       master <- NULL
[17:00:34.978]                       while (!identical(envir, .GlobalEnv) && 
[17:00:34.978]                         !identical(envir, emptyenv())) {
[17:00:34.978]                         if (exists("master", mode = "list", envir = envir, 
[17:00:34.978]                           inherits = FALSE)) {
[17:00:34.978]                           master <- get("master", mode = "list", 
[17:00:34.978]                             envir = envir, inherits = FALSE)
[17:00:34.978]                           if (inherits(master, c("SOCKnode", 
[17:00:34.978]                             "SOCK0node"))) {
[17:00:34.978]                             sendCondition <<- function(cond) {
[17:00:34.978]                               data <- list(type = "VALUE", value = cond, 
[17:00:34.978]                                 success = TRUE)
[17:00:34.978]                               parallel_sendData(master, data)
[17:00:34.978]                             }
[17:00:34.978]                             return(sendCondition)
[17:00:34.978]                           }
[17:00:34.978]                         }
[17:00:34.978]                         frame <- frame + 1L
[17:00:34.978]                         envir <- sys.frame(frame)
[17:00:34.978]                       }
[17:00:34.978]                     }
[17:00:34.978]                     sendCondition <<- function(cond) NULL
[17:00:34.978]                   }
[17:00:34.978]                 })
[17:00:34.978]                 withCallingHandlers({
[17:00:34.978]                   {
[17:00:34.978]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.978]                     if (!identical(...future.globals.maxSize.org, 
[17:00:34.978]                       ...future.globals.maxSize)) {
[17:00:34.978]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.978]                       on.exit(options(oopts), add = TRUE)
[17:00:34.978]                     }
[17:00:34.978]                     {
[17:00:34.978]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:34.978]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:34.978]                           envir = globalenv(), inherits = FALSE)
[17:00:34.978]                         ...future.FUN(...)
[17:00:34.978]                       }
[17:00:34.978]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:34.978]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:34.978]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:34.978]                         USE.NAMES = FALSE)
[17:00:34.978]                       do.call(mapply, args = args)
[17:00:34.978]                     }
[17:00:34.978]                   }
[17:00:34.978]                 }, immediateCondition = function(cond) {
[17:00:34.978]                   sendCondition <- ...future.makeSendCondition()
[17:00:34.978]                   sendCondition(cond)
[17:00:34.978]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.978]                   {
[17:00:34.978]                     inherits <- base::inherits
[17:00:34.978]                     invokeRestart <- base::invokeRestart
[17:00:34.978]                     is.null <- base::is.null
[17:00:34.978]                     muffled <- FALSE
[17:00:34.978]                     if (inherits(cond, "message")) {
[17:00:34.978]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:34.978]                       if (muffled) 
[17:00:34.978]                         invokeRestart("muffleMessage")
[17:00:34.978]                     }
[17:00:34.978]                     else if (inherits(cond, "warning")) {
[17:00:34.978]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:34.978]                       if (muffled) 
[17:00:34.978]                         invokeRestart("muffleWarning")
[17:00:34.978]                     }
[17:00:34.978]                     else if (inherits(cond, "condition")) {
[17:00:34.978]                       if (!is.null(pattern)) {
[17:00:34.978]                         computeRestarts <- base::computeRestarts
[17:00:34.978]                         grepl <- base::grepl
[17:00:34.978]                         restarts <- computeRestarts(cond)
[17:00:34.978]                         for (restart in restarts) {
[17:00:34.978]                           name <- restart$name
[17:00:34.978]                           if (is.null(name)) 
[17:00:34.978]                             next
[17:00:34.978]                           if (!grepl(pattern, name)) 
[17:00:34.978]                             next
[17:00:34.978]                           invokeRestart(restart)
[17:00:34.978]                           muffled <- TRUE
[17:00:34.978]                           break
[17:00:34.978]                         }
[17:00:34.978]                       }
[17:00:34.978]                     }
[17:00:34.978]                     invisible(muffled)
[17:00:34.978]                   }
[17:00:34.978]                   muffleCondition(cond)
[17:00:34.978]                 })
[17:00:34.978]             }))
[17:00:34.978]             future::FutureResult(value = ...future.value$value, 
[17:00:34.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.978]                   ...future.rng), globalenv = if (FALSE) 
[17:00:34.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:34.978]                     ...future.globalenv.names))
[17:00:34.978]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:34.978]         }, condition = base::local({
[17:00:34.978]             c <- base::c
[17:00:34.978]             inherits <- base::inherits
[17:00:34.978]             invokeRestart <- base::invokeRestart
[17:00:34.978]             length <- base::length
[17:00:34.978]             list <- base::list
[17:00:34.978]             seq.int <- base::seq.int
[17:00:34.978]             signalCondition <- base::signalCondition
[17:00:34.978]             sys.calls <- base::sys.calls
[17:00:34.978]             `[[` <- base::`[[`
[17:00:34.978]             `+` <- base::`+`
[17:00:34.978]             `<<-` <- base::`<<-`
[17:00:34.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:34.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:34.978]                   3L)]
[17:00:34.978]             }
[17:00:34.978]             function(cond) {
[17:00:34.978]                 is_error <- inherits(cond, "error")
[17:00:34.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:34.978]                   NULL)
[17:00:34.978]                 if (is_error) {
[17:00:34.978]                   sessionInformation <- function() {
[17:00:34.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:34.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:34.978]                       search = base::search(), system = base::Sys.info())
[17:00:34.978]                   }
[17:00:34.978]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:34.978]                     cond$call), session = sessionInformation(), 
[17:00:34.978]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:34.978]                   signalCondition(cond)
[17:00:34.978]                 }
[17:00:34.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:34.978]                 "immediateCondition"))) {
[17:00:34.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:34.978]                   ...future.conditions[[length(...future.conditions) + 
[17:00:34.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:34.978]                   if (TRUE && !signal) {
[17:00:34.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.978]                     {
[17:00:34.978]                       inherits <- base::inherits
[17:00:34.978]                       invokeRestart <- base::invokeRestart
[17:00:34.978]                       is.null <- base::is.null
[17:00:34.978]                       muffled <- FALSE
[17:00:34.978]                       if (inherits(cond, "message")) {
[17:00:34.978]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.978]                         if (muffled) 
[17:00:34.978]                           invokeRestart("muffleMessage")
[17:00:34.978]                       }
[17:00:34.978]                       else if (inherits(cond, "warning")) {
[17:00:34.978]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.978]                         if (muffled) 
[17:00:34.978]                           invokeRestart("muffleWarning")
[17:00:34.978]                       }
[17:00:34.978]                       else if (inherits(cond, "condition")) {
[17:00:34.978]                         if (!is.null(pattern)) {
[17:00:34.978]                           computeRestarts <- base::computeRestarts
[17:00:34.978]                           grepl <- base::grepl
[17:00:34.978]                           restarts <- computeRestarts(cond)
[17:00:34.978]                           for (restart in restarts) {
[17:00:34.978]                             name <- restart$name
[17:00:34.978]                             if (is.null(name)) 
[17:00:34.978]                               next
[17:00:34.978]                             if (!grepl(pattern, name)) 
[17:00:34.978]                               next
[17:00:34.978]                             invokeRestart(restart)
[17:00:34.978]                             muffled <- TRUE
[17:00:34.978]                             break
[17:00:34.978]                           }
[17:00:34.978]                         }
[17:00:34.978]                       }
[17:00:34.978]                       invisible(muffled)
[17:00:34.978]                     }
[17:00:34.978]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.978]                   }
[17:00:34.978]                 }
[17:00:34.978]                 else {
[17:00:34.978]                   if (TRUE) {
[17:00:34.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:34.978]                     {
[17:00:34.978]                       inherits <- base::inherits
[17:00:34.978]                       invokeRestart <- base::invokeRestart
[17:00:34.978]                       is.null <- base::is.null
[17:00:34.978]                       muffled <- FALSE
[17:00:34.978]                       if (inherits(cond, "message")) {
[17:00:34.978]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:34.978]                         if (muffled) 
[17:00:34.978]                           invokeRestart("muffleMessage")
[17:00:34.978]                       }
[17:00:34.978]                       else if (inherits(cond, "warning")) {
[17:00:34.978]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:34.978]                         if (muffled) 
[17:00:34.978]                           invokeRestart("muffleWarning")
[17:00:34.978]                       }
[17:00:34.978]                       else if (inherits(cond, "condition")) {
[17:00:34.978]                         if (!is.null(pattern)) {
[17:00:34.978]                           computeRestarts <- base::computeRestarts
[17:00:34.978]                           grepl <- base::grepl
[17:00:34.978]                           restarts <- computeRestarts(cond)
[17:00:34.978]                           for (restart in restarts) {
[17:00:34.978]                             name <- restart$name
[17:00:34.978]                             if (is.null(name)) 
[17:00:34.978]                               next
[17:00:34.978]                             if (!grepl(pattern, name)) 
[17:00:34.978]                               next
[17:00:34.978]                             invokeRestart(restart)
[17:00:34.978]                             muffled <- TRUE
[17:00:34.978]                             break
[17:00:34.978]                           }
[17:00:34.978]                         }
[17:00:34.978]                       }
[17:00:34.978]                       invisible(muffled)
[17:00:34.978]                     }
[17:00:34.978]                     muffleCondition(cond, pattern = "^muffle")
[17:00:34.978]                   }
[17:00:34.978]                 }
[17:00:34.978]             }
[17:00:34.978]         }))
[17:00:34.978]     }, error = function(ex) {
[17:00:34.978]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:34.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:34.978]                 ...future.rng), started = ...future.startTime, 
[17:00:34.978]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:34.978]             version = "1.8"), class = "FutureResult")
[17:00:34.978]     }, finally = {
[17:00:34.978]         if (!identical(...future.workdir, getwd())) 
[17:00:34.978]             setwd(...future.workdir)
[17:00:34.978]         {
[17:00:34.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:34.978]                 ...future.oldOptions$nwarnings <- NULL
[17:00:34.978]             }
[17:00:34.978]             base::options(...future.oldOptions)
[17:00:34.978]             if (.Platform$OS.type == "windows") {
[17:00:34.978]                 old_names <- names(...future.oldEnvVars)
[17:00:34.978]                 envs <- base::Sys.getenv()
[17:00:34.978]                 names <- names(envs)
[17:00:34.978]                 common <- intersect(names, old_names)
[17:00:34.978]                 added <- setdiff(names, old_names)
[17:00:34.978]                 removed <- setdiff(old_names, names)
[17:00:34.978]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:34.978]                   envs[common]]
[17:00:34.978]                 NAMES <- toupper(changed)
[17:00:34.978]                 args <- list()
[17:00:34.978]                 for (kk in seq_along(NAMES)) {
[17:00:34.978]                   name <- changed[[kk]]
[17:00:34.978]                   NAME <- NAMES[[kk]]
[17:00:34.978]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.978]                     next
[17:00:34.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.978]                 }
[17:00:34.978]                 NAMES <- toupper(added)
[17:00:34.978]                 for (kk in seq_along(NAMES)) {
[17:00:34.978]                   name <- added[[kk]]
[17:00:34.978]                   NAME <- NAMES[[kk]]
[17:00:34.978]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.978]                     next
[17:00:34.978]                   args[[name]] <- ""
[17:00:34.978]                 }
[17:00:34.978]                 NAMES <- toupper(removed)
[17:00:34.978]                 for (kk in seq_along(NAMES)) {
[17:00:34.978]                   name <- removed[[kk]]
[17:00:34.978]                   NAME <- NAMES[[kk]]
[17:00:34.978]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:34.978]                     next
[17:00:34.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:34.978]                 }
[17:00:34.978]                 if (length(args) > 0) 
[17:00:34.978]                   base::do.call(base::Sys.setenv, args = args)
[17:00:34.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:34.978]             }
[17:00:34.978]             else {
[17:00:34.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:34.978]             }
[17:00:34.978]             {
[17:00:34.978]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:34.978]                   0L) {
[17:00:34.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:34.978]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:34.978]                   base::options(opts)
[17:00:34.978]                 }
[17:00:34.978]                 {
[17:00:34.978]                   {
[17:00:34.978]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:34.978]                     NULL
[17:00:34.978]                   }
[17:00:34.978]                   options(future.plan = NULL)
[17:00:34.978]                   if (is.na(NA_character_)) 
[17:00:34.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:34.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:34.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:34.978]                     .init = FALSE)
[17:00:34.978]                 }
[17:00:34.978]             }
[17:00:34.978]         }
[17:00:34.978]     })
[17:00:34.978]     if (TRUE) {
[17:00:34.978]         base::sink(type = "output", split = FALSE)
[17:00:34.978]         if (TRUE) {
[17:00:34.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:34.978]         }
[17:00:34.978]         else {
[17:00:34.978]             ...future.result["stdout"] <- base::list(NULL)
[17:00:34.978]         }
[17:00:34.978]         base::close(...future.stdout)
[17:00:34.978]         ...future.stdout <- NULL
[17:00:34.978]     }
[17:00:34.978]     ...future.result$conditions <- ...future.conditions
[17:00:34.978]     ...future.result$finished <- base::Sys.time()
[17:00:34.978]     ...future.result
[17:00:34.978] }
[17:00:34.981] Exporting 5 global objects (2.47 KiB) to cluster node #1 ...
[17:00:34.981] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ...
[17:00:34.981] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ... DONE
[17:00:34.982] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:00:34.982] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:00:34.982] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:00:34.982] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:00:34.983] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ...
[17:00:34.983] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ... DONE
[17:00:34.983] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:34.983] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:34.984] Exporting 5 global objects (2.47 KiB) to cluster node #1 ... DONE
[17:00:34.984] MultisessionFuture started
[17:00:34.984] - Launch lazy future ... done
[17:00:34.984] run() for ‘MultisessionFuture’ ... done
[17:00:34.985] Created future:
[17:00:34.985] MultisessionFuture:
[17:00:34.985] Label: ‘future_mapply-1’
[17:00:34.985] Expression:
[17:00:34.985] {
[17:00:34.985]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:34.985]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:34.985]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:34.985]         on.exit(options(oopts), add = TRUE)
[17:00:34.985]     }
[17:00:34.985]     {
[17:00:34.985]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:34.985]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:34.985]                 inherits = FALSE)
[17:00:34.985]             ...future.FUN(...)
[17:00:34.985]         }
[17:00:34.985]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:34.985]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:34.985]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:34.985]         do.call(mapply, args = args)
[17:00:34.985]     }
[17:00:34.985] }
[17:00:34.985] Lazy evaluation: FALSE
[17:00:34.985] Asynchronous evaluation: TRUE
[17:00:34.985] Local evaluation: TRUE
[17:00:34.985] Environment: R_GlobalEnv
[17:00:34.985] Capture standard output: TRUE
[17:00:34.985] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:34.985] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:34.985] Packages: 1 packages (‘stats’)
[17:00:34.985] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:34.985] Resolved: FALSE
[17:00:34.985] Value: <not collected>
[17:00:34.985] Conditions captured: <none>
[17:00:34.985] Early signaling: FALSE
[17:00:34.985] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:34.985] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:34.996] Chunk #1 of 2 ... DONE
[17:00:34.996] Chunk #2 of 2 ...
[17:00:34.997]  - Finding globals in '...' for chunk #2 ...
[17:00:34.997] getGlobalsAndPackages() ...
[17:00:34.997] Searching for globals...
[17:00:34.997] 
[17:00:34.997] Searching for globals ... DONE
[17:00:34.997] - globals: [0] <none>
[17:00:34.998] getGlobalsAndPackages() ... DONE
[17:00:34.998]    + additional globals found: [n=0] 
[17:00:34.998]    + additional namespaces needed: [n=0] 
[17:00:34.998]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:34.998]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:34.998]  - seeds: [2] <seeds>
[17:00:34.998]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.998] getGlobalsAndPackages() ...
[17:00:34.998] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:34.998] Resolving globals: FALSE
[17:00:35.002] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:00:35.002] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:00:35.002] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.003] - packages: [1] ‘stats’
[17:00:35.003] getGlobalsAndPackages() ... DONE
[17:00:35.003] run() for ‘Future’ ...
[17:00:35.003] - state: ‘created’
[17:00:35.003] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:35.018] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:35.019]   - Field: ‘node’
[17:00:35.019]   - Field: ‘label’
[17:00:35.019]   - Field: ‘local’
[17:00:35.019]   - Field: ‘owner’
[17:00:35.019]   - Field: ‘envir’
[17:00:35.019]   - Field: ‘workers’
[17:00:35.019]   - Field: ‘packages’
[17:00:35.019]   - Field: ‘gc’
[17:00:35.019]   - Field: ‘conditions’
[17:00:35.019]   - Field: ‘persistent’
[17:00:35.020]   - Field: ‘expr’
[17:00:35.020]   - Field: ‘uuid’
[17:00:35.020]   - Field: ‘seed’
[17:00:35.020]   - Field: ‘version’
[17:00:35.020]   - Field: ‘result’
[17:00:35.020]   - Field: ‘asynchronous’
[17:00:35.020]   - Field: ‘calls’
[17:00:35.020]   - Field: ‘globals’
[17:00:35.020]   - Field: ‘stdout’
[17:00:35.020]   - Field: ‘earlySignal’
[17:00:35.020]   - Field: ‘lazy’
[17:00:35.021]   - Field: ‘state’
[17:00:35.021] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:35.021] - Launch lazy future ...
[17:00:35.021] Packages needed by the future expression (n = 1): ‘stats’
[17:00:35.021] Packages needed by future strategies (n = 0): <none>
[17:00:35.022] {
[17:00:35.022]     {
[17:00:35.022]         {
[17:00:35.022]             ...future.startTime <- base::Sys.time()
[17:00:35.022]             {
[17:00:35.022]                 {
[17:00:35.022]                   {
[17:00:35.022]                     {
[17:00:35.022]                       {
[17:00:35.022]                         base::local({
[17:00:35.022]                           has_future <- base::requireNamespace("future", 
[17:00:35.022]                             quietly = TRUE)
[17:00:35.022]                           if (has_future) {
[17:00:35.022]                             ns <- base::getNamespace("future")
[17:00:35.022]                             version <- ns[[".package"]][["version"]]
[17:00:35.022]                             if (is.null(version)) 
[17:00:35.022]                               version <- utils::packageVersion("future")
[17:00:35.022]                           }
[17:00:35.022]                           else {
[17:00:35.022]                             version <- NULL
[17:00:35.022]                           }
[17:00:35.022]                           if (!has_future || version < "1.8.0") {
[17:00:35.022]                             info <- base::c(r_version = base::gsub("R version ", 
[17:00:35.022]                               "", base::R.version$version.string), 
[17:00:35.022]                               platform = base::sprintf("%s (%s-bit)", 
[17:00:35.022]                                 base::R.version$platform, 8 * 
[17:00:35.022]                                   base::.Machine$sizeof.pointer), 
[17:00:35.022]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:35.022]                                 "release", "version")], collapse = " "), 
[17:00:35.022]                               hostname = base::Sys.info()[["nodename"]])
[17:00:35.022]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:00:35.022]                               info)
[17:00:35.022]                             info <- base::paste(info, collapse = "; ")
[17:00:35.022]                             if (!has_future) {
[17:00:35.022]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:35.022]                                 info)
[17:00:35.022]                             }
[17:00:35.022]                             else {
[17:00:35.022]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:35.022]                                 info, version)
[17:00:35.022]                             }
[17:00:35.022]                             base::stop(msg)
[17:00:35.022]                           }
[17:00:35.022]                         })
[17:00:35.022]                       }
[17:00:35.022]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:35.022]                       base::options(mc.cores = 1L)
[17:00:35.022]                     }
[17:00:35.022]                     base::local({
[17:00:35.022]                       for (pkg in "stats") {
[17:00:35.022]                         base::loadNamespace(pkg)
[17:00:35.022]                         base::library(pkg, character.only = TRUE)
[17:00:35.022]                       }
[17:00:35.022]                     })
[17:00:35.022]                   }
[17:00:35.022]                   ...future.strategy.old <- future::plan("list")
[17:00:35.022]                   options(future.plan = NULL)
[17:00:35.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:35.022]                 }
[17:00:35.022]                 ...future.workdir <- getwd()
[17:00:35.022]             }
[17:00:35.022]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:35.022]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:35.022]         }
[17:00:35.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:35.022]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:35.022]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:35.022]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:35.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:35.022]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:35.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:35.022]             base::names(...future.oldOptions))
[17:00:35.022]     }
[17:00:35.022]     if (FALSE) {
[17:00:35.022]     }
[17:00:35.022]     else {
[17:00:35.022]         if (TRUE) {
[17:00:35.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:35.022]                 open = "w")
[17:00:35.022]         }
[17:00:35.022]         else {
[17:00:35.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:35.022]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:35.022]         }
[17:00:35.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:35.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:35.022]             base::sink(type = "output", split = FALSE)
[17:00:35.022]             base::close(...future.stdout)
[17:00:35.022]         }, add = TRUE)
[17:00:35.022]     }
[17:00:35.022]     ...future.frame <- base::sys.nframe()
[17:00:35.022]     ...future.conditions <- base::list()
[17:00:35.022]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:35.022]     if (FALSE) {
[17:00:35.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:35.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:35.022]     }
[17:00:35.022]     ...future.result <- base::tryCatch({
[17:00:35.022]         base::withCallingHandlers({
[17:00:35.022]             ...future.value <- base::withVisible(base::local({
[17:00:35.022]                 ...future.makeSendCondition <- base::local({
[17:00:35.022]                   sendCondition <- NULL
[17:00:35.022]                   function(frame = 1L) {
[17:00:35.022]                     if (is.function(sendCondition)) 
[17:00:35.022]                       return(sendCondition)
[17:00:35.022]                     ns <- getNamespace("parallel")
[17:00:35.022]                     if (exists("sendData", mode = "function", 
[17:00:35.022]                       envir = ns)) {
[17:00:35.022]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:35.022]                         envir = ns)
[17:00:35.022]                       envir <- sys.frame(frame)
[17:00:35.022]                       master <- NULL
[17:00:35.022]                       while (!identical(envir, .GlobalEnv) && 
[17:00:35.022]                         !identical(envir, emptyenv())) {
[17:00:35.022]                         if (exists("master", mode = "list", envir = envir, 
[17:00:35.022]                           inherits = FALSE)) {
[17:00:35.022]                           master <- get("master", mode = "list", 
[17:00:35.022]                             envir = envir, inherits = FALSE)
[17:00:35.022]                           if (inherits(master, c("SOCKnode", 
[17:00:35.022]                             "SOCK0node"))) {
[17:00:35.022]                             sendCondition <<- function(cond) {
[17:00:35.022]                               data <- list(type = "VALUE", value = cond, 
[17:00:35.022]                                 success = TRUE)
[17:00:35.022]                               parallel_sendData(master, data)
[17:00:35.022]                             }
[17:00:35.022]                             return(sendCondition)
[17:00:35.022]                           }
[17:00:35.022]                         }
[17:00:35.022]                         frame <- frame + 1L
[17:00:35.022]                         envir <- sys.frame(frame)
[17:00:35.022]                       }
[17:00:35.022]                     }
[17:00:35.022]                     sendCondition <<- function(cond) NULL
[17:00:35.022]                   }
[17:00:35.022]                 })
[17:00:35.022]                 withCallingHandlers({
[17:00:35.022]                   {
[17:00:35.022]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.022]                     if (!identical(...future.globals.maxSize.org, 
[17:00:35.022]                       ...future.globals.maxSize)) {
[17:00:35.022]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.022]                       on.exit(options(oopts), add = TRUE)
[17:00:35.022]                     }
[17:00:35.022]                     {
[17:00:35.022]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:35.022]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:00:35.022]                           envir = globalenv(), inherits = FALSE)
[17:00:35.022]                         ...future.FUN(...)
[17:00:35.022]                       }
[17:00:35.022]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:35.022]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:35.022]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:35.022]                         USE.NAMES = FALSE)
[17:00:35.022]                       do.call(mapply, args = args)
[17:00:35.022]                     }
[17:00:35.022]                   }
[17:00:35.022]                 }, immediateCondition = function(cond) {
[17:00:35.022]                   sendCondition <- ...future.makeSendCondition()
[17:00:35.022]                   sendCondition(cond)
[17:00:35.022]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.022]                   {
[17:00:35.022]                     inherits <- base::inherits
[17:00:35.022]                     invokeRestart <- base::invokeRestart
[17:00:35.022]                     is.null <- base::is.null
[17:00:35.022]                     muffled <- FALSE
[17:00:35.022]                     if (inherits(cond, "message")) {
[17:00:35.022]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:35.022]                       if (muffled) 
[17:00:35.022]                         invokeRestart("muffleMessage")
[17:00:35.022]                     }
[17:00:35.022]                     else if (inherits(cond, "warning")) {
[17:00:35.022]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:35.022]                       if (muffled) 
[17:00:35.022]                         invokeRestart("muffleWarning")
[17:00:35.022]                     }
[17:00:35.022]                     else if (inherits(cond, "condition")) {
[17:00:35.022]                       if (!is.null(pattern)) {
[17:00:35.022]                         computeRestarts <- base::computeRestarts
[17:00:35.022]                         grepl <- base::grepl
[17:00:35.022]                         restarts <- computeRestarts(cond)
[17:00:35.022]                         for (restart in restarts) {
[17:00:35.022]                           name <- restart$name
[17:00:35.022]                           if (is.null(name)) 
[17:00:35.022]                             next
[17:00:35.022]                           if (!grepl(pattern, name)) 
[17:00:35.022]                             next
[17:00:35.022]                           invokeRestart(restart)
[17:00:35.022]                           muffled <- TRUE
[17:00:35.022]                           break
[17:00:35.022]                         }
[17:00:35.022]                       }
[17:00:35.022]                     }
[17:00:35.022]                     invisible(muffled)
[17:00:35.022]                   }
[17:00:35.022]                   muffleCondition(cond)
[17:00:35.022]                 })
[17:00:35.022]             }))
[17:00:35.022]             future::FutureResult(value = ...future.value$value, 
[17:00:35.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.022]                   ...future.rng), globalenv = if (FALSE) 
[17:00:35.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:35.022]                     ...future.globalenv.names))
[17:00:35.022]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:35.022]         }, condition = base::local({
[17:00:35.022]             c <- base::c
[17:00:35.022]             inherits <- base::inherits
[17:00:35.022]             invokeRestart <- base::invokeRestart
[17:00:35.022]             length <- base::length
[17:00:35.022]             list <- base::list
[17:00:35.022]             seq.int <- base::seq.int
[17:00:35.022]             signalCondition <- base::signalCondition
[17:00:35.022]             sys.calls <- base::sys.calls
[17:00:35.022]             `[[` <- base::`[[`
[17:00:35.022]             `+` <- base::`+`
[17:00:35.022]             `<<-` <- base::`<<-`
[17:00:35.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:35.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:35.022]                   3L)]
[17:00:35.022]             }
[17:00:35.022]             function(cond) {
[17:00:35.022]                 is_error <- inherits(cond, "error")
[17:00:35.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:35.022]                   NULL)
[17:00:35.022]                 if (is_error) {
[17:00:35.022]                   sessionInformation <- function() {
[17:00:35.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:35.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:35.022]                       search = base::search(), system = base::Sys.info())
[17:00:35.022]                   }
[17:00:35.022]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:35.022]                     cond$call), session = sessionInformation(), 
[17:00:35.022]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:35.022]                   signalCondition(cond)
[17:00:35.022]                 }
[17:00:35.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:35.022]                 "immediateCondition"))) {
[17:00:35.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:35.022]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:35.022]                   if (TRUE && !signal) {
[17:00:35.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.022]                     {
[17:00:35.022]                       inherits <- base::inherits
[17:00:35.022]                       invokeRestart <- base::invokeRestart
[17:00:35.022]                       is.null <- base::is.null
[17:00:35.022]                       muffled <- FALSE
[17:00:35.022]                       if (inherits(cond, "message")) {
[17:00:35.022]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.022]                         if (muffled) 
[17:00:35.022]                           invokeRestart("muffleMessage")
[17:00:35.022]                       }
[17:00:35.022]                       else if (inherits(cond, "warning")) {
[17:00:35.022]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.022]                         if (muffled) 
[17:00:35.022]                           invokeRestart("muffleWarning")
[17:00:35.022]                       }
[17:00:35.022]                       else if (inherits(cond, "condition")) {
[17:00:35.022]                         if (!is.null(pattern)) {
[17:00:35.022]                           computeRestarts <- base::computeRestarts
[17:00:35.022]                           grepl <- base::grepl
[17:00:35.022]                           restarts <- computeRestarts(cond)
[17:00:35.022]                           for (restart in restarts) {
[17:00:35.022]                             name <- restart$name
[17:00:35.022]                             if (is.null(name)) 
[17:00:35.022]                               next
[17:00:35.022]                             if (!grepl(pattern, name)) 
[17:00:35.022]                               next
[17:00:35.022]                             invokeRestart(restart)
[17:00:35.022]                             muffled <- TRUE
[17:00:35.022]                             break
[17:00:35.022]                           }
[17:00:35.022]                         }
[17:00:35.022]                       }
[17:00:35.022]                       invisible(muffled)
[17:00:35.022]                     }
[17:00:35.022]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.022]                   }
[17:00:35.022]                 }
[17:00:35.022]                 else {
[17:00:35.022]                   if (TRUE) {
[17:00:35.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.022]                     {
[17:00:35.022]                       inherits <- base::inherits
[17:00:35.022]                       invokeRestart <- base::invokeRestart
[17:00:35.022]                       is.null <- base::is.null
[17:00:35.022]                       muffled <- FALSE
[17:00:35.022]                       if (inherits(cond, "message")) {
[17:00:35.022]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.022]                         if (muffled) 
[17:00:35.022]                           invokeRestart("muffleMessage")
[17:00:35.022]                       }
[17:00:35.022]                       else if (inherits(cond, "warning")) {
[17:00:35.022]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.022]                         if (muffled) 
[17:00:35.022]                           invokeRestart("muffleWarning")
[17:00:35.022]                       }
[17:00:35.022]                       else if (inherits(cond, "condition")) {
[17:00:35.022]                         if (!is.null(pattern)) {
[17:00:35.022]                           computeRestarts <- base::computeRestarts
[17:00:35.022]                           grepl <- base::grepl
[17:00:35.022]                           restarts <- computeRestarts(cond)
[17:00:35.022]                           for (restart in restarts) {
[17:00:35.022]                             name <- restart$name
[17:00:35.022]                             if (is.null(name)) 
[17:00:35.022]                               next
[17:00:35.022]                             if (!grepl(pattern, name)) 
[17:00:35.022]                               next
[17:00:35.022]                             invokeRestart(restart)
[17:00:35.022]                             muffled <- TRUE
[17:00:35.022]                             break
[17:00:35.022]                           }
[17:00:35.022]                         }
[17:00:35.022]                       }
[17:00:35.022]                       invisible(muffled)
[17:00:35.022]                     }
[17:00:35.022]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.022]                   }
[17:00:35.022]                 }
[17:00:35.022]             }
[17:00:35.022]         }))
[17:00:35.022]     }, error = function(ex) {
[17:00:35.022]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:35.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.022]                 ...future.rng), started = ...future.startTime, 
[17:00:35.022]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:35.022]             version = "1.8"), class = "FutureResult")
[17:00:35.022]     }, finally = {
[17:00:35.022]         if (!identical(...future.workdir, getwd())) 
[17:00:35.022]             setwd(...future.workdir)
[17:00:35.022]         {
[17:00:35.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:35.022]                 ...future.oldOptions$nwarnings <- NULL
[17:00:35.022]             }
[17:00:35.022]             base::options(...future.oldOptions)
[17:00:35.022]             if (.Platform$OS.type == "windows") {
[17:00:35.022]                 old_names <- names(...future.oldEnvVars)
[17:00:35.022]                 envs <- base::Sys.getenv()
[17:00:35.022]                 names <- names(envs)
[17:00:35.022]                 common <- intersect(names, old_names)
[17:00:35.022]                 added <- setdiff(names, old_names)
[17:00:35.022]                 removed <- setdiff(old_names, names)
[17:00:35.022]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:35.022]                   envs[common]]
[17:00:35.022]                 NAMES <- toupper(changed)
[17:00:35.022]                 args <- list()
[17:00:35.022]                 for (kk in seq_along(NAMES)) {
[17:00:35.022]                   name <- changed[[kk]]
[17:00:35.022]                   NAME <- NAMES[[kk]]
[17:00:35.022]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.022]                     next
[17:00:35.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.022]                 }
[17:00:35.022]                 NAMES <- toupper(added)
[17:00:35.022]                 for (kk in seq_along(NAMES)) {
[17:00:35.022]                   name <- added[[kk]]
[17:00:35.022]                   NAME <- NAMES[[kk]]
[17:00:35.022]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.022]                     next
[17:00:35.022]                   args[[name]] <- ""
[17:00:35.022]                 }
[17:00:35.022]                 NAMES <- toupper(removed)
[17:00:35.022]                 for (kk in seq_along(NAMES)) {
[17:00:35.022]                   name <- removed[[kk]]
[17:00:35.022]                   NAME <- NAMES[[kk]]
[17:00:35.022]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.022]                     next
[17:00:35.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.022]                 }
[17:00:35.022]                 if (length(args) > 0) 
[17:00:35.022]                   base::do.call(base::Sys.setenv, args = args)
[17:00:35.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:35.022]             }
[17:00:35.022]             else {
[17:00:35.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:35.022]             }
[17:00:35.022]             {
[17:00:35.022]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:35.022]                   0L) {
[17:00:35.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:35.022]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:35.022]                   base::options(opts)
[17:00:35.022]                 }
[17:00:35.022]                 {
[17:00:35.022]                   {
[17:00:35.022]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:35.022]                     NULL
[17:00:35.022]                   }
[17:00:35.022]                   options(future.plan = NULL)
[17:00:35.022]                   if (is.na(NA_character_)) 
[17:00:35.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:35.022]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:35.022]                     .init = FALSE)
[17:00:35.022]                 }
[17:00:35.022]             }
[17:00:35.022]         }
[17:00:35.022]     })
[17:00:35.022]     if (TRUE) {
[17:00:35.022]         base::sink(type = "output", split = FALSE)
[17:00:35.022]         if (TRUE) {
[17:00:35.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:35.022]         }
[17:00:35.022]         else {
[17:00:35.022]             ...future.result["stdout"] <- base::list(NULL)
[17:00:35.022]         }
[17:00:35.022]         base::close(...future.stdout)
[17:00:35.022]         ...future.stdout <- NULL
[17:00:35.022]     }
[17:00:35.022]     ...future.result$conditions <- ...future.conditions
[17:00:35.022]     ...future.result$finished <- base::Sys.time()
[17:00:35.022]     ...future.result
[17:00:35.022] }
[17:00:35.025] Exporting 5 global objects (2.47 KiB) to cluster node #2 ...
[17:00:35.025] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ...
[17:00:35.025] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ... DONE
[17:00:35.025] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:00:35.026] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:00:35.026] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:00:35.026] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:00:35.026] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ...
[17:00:35.027] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ... DONE
[17:00:35.027] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:35.027] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:35.027] Exporting 5 global objects (2.47 KiB) to cluster node #2 ... DONE
[17:00:35.028] MultisessionFuture started
[17:00:35.028] - Launch lazy future ... done
[17:00:35.028] run() for ‘MultisessionFuture’ ... done
[17:00:35.029] Created future:
[17:00:35.029] MultisessionFuture:
[17:00:35.029] Label: ‘future_mapply-2’
[17:00:35.029] Expression:
[17:00:35.029] {
[17:00:35.029]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.029]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:35.029]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.029]         on.exit(options(oopts), add = TRUE)
[17:00:35.029]     }
[17:00:35.029]     {
[17:00:35.029]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:00:35.029]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:00:35.029]                 inherits = FALSE)
[17:00:35.029]             ...future.FUN(...)
[17:00:35.029]         }
[17:00:35.029]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:00:35.029]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:00:35.029]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:35.029]         do.call(mapply, args = args)
[17:00:35.029]     }
[17:00:35.029] }
[17:00:35.029] Lazy evaluation: FALSE
[17:00:35.029] Asynchronous evaluation: TRUE
[17:00:35.029] Local evaluation: TRUE
[17:00:35.029] Environment: R_GlobalEnv
[17:00:35.029] Capture standard output: TRUE
[17:00:35.029] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:35.029] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:35.029] Packages: 1 packages (‘stats’)
[17:00:35.029] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:00:35.029] Resolved: FALSE
[17:00:35.029] Value: <not collected>
[17:00:35.029] Conditions captured: <none>
[17:00:35.029] Early signaling: FALSE
[17:00:35.029] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:35.029] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.041] Chunk #2 of 2 ... DONE
[17:00:35.041] Launching 2 futures (chunks) ... DONE
[17:00:35.041] Resolving 2 futures (chunks) ...
[17:00:35.041] resolve() on list ...
[17:00:35.041]  recursive: 0
[17:00:35.041]  length: 2
[17:00:35.041] 
[17:00:35.042] receiveMessageFromWorker() for ClusterFuture ...
[17:00:35.042] - Validating connection of MultisessionFuture
[17:00:35.042] - received message: FutureResult
[17:00:35.042] - Received FutureResult
[17:00:35.042] - Erased future from FutureRegistry
[17:00:35.042] result() for ClusterFuture ...
[17:00:35.043] - result already collected: FutureResult
[17:00:35.043] result() for ClusterFuture ... done
[17:00:35.043] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:35.043] Future #1
[17:00:35.043] result() for ClusterFuture ...
[17:00:35.043] - result already collected: FutureResult
[17:00:35.043] result() for ClusterFuture ... done
[17:00:35.043] result() for ClusterFuture ...
[17:00:35.043] - result already collected: FutureResult
[17:00:35.043] result() for ClusterFuture ... done
[17:00:35.043] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:35.044] - nx: 2
[17:00:35.044] - relay: TRUE
[17:00:35.044] - stdout: TRUE
[17:00:35.044] - signal: TRUE
[17:00:35.044] - resignal: FALSE
[17:00:35.044] - force: TRUE
[17:00:35.044] - relayed: [n=2] FALSE, FALSE
[17:00:35.044] - queued futures: [n=2] FALSE, FALSE
[17:00:35.044]  - until=1
[17:00:35.044]  - relaying element #1
[17:00:35.044] result() for ClusterFuture ...
[17:00:35.044] - result already collected: FutureResult
[17:00:35.045] result() for ClusterFuture ... done
[17:00:35.045] result() for ClusterFuture ...
[17:00:35.045] - result already collected: FutureResult
[17:00:35.045] result() for ClusterFuture ... done
[17:00:35.045] result() for ClusterFuture ...
[17:00:35.045] - result already collected: FutureResult
[17:00:35.045] result() for ClusterFuture ... done
[17:00:35.045] result() for ClusterFuture ...
[17:00:35.045] - result already collected: FutureResult
[17:00:35.045] result() for ClusterFuture ... done
[17:00:35.045] - relayed: [n=2] TRUE, FALSE
[17:00:35.046] - queued futures: [n=2] TRUE, FALSE
[17:00:35.046] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:35.046]  length: 1 (resolved future 1)
[17:00:35.073] receiveMessageFromWorker() for ClusterFuture ...
[17:00:35.073] - Validating connection of MultisessionFuture
[17:00:35.074] - received message: FutureResult
[17:00:35.074] - Received FutureResult
[17:00:35.074] - Erased future from FutureRegistry
[17:00:35.074] result() for ClusterFuture ...
[17:00:35.074] - result already collected: FutureResult
[17:00:35.074] result() for ClusterFuture ... done
[17:00:35.074] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:35.075] Future #2
[17:00:35.075] result() for ClusterFuture ...
[17:00:35.075] - result already collected: FutureResult
[17:00:35.075] result() for ClusterFuture ... done
[17:00:35.075] result() for ClusterFuture ...
[17:00:35.075] - result already collected: FutureResult
[17:00:35.075] result() for ClusterFuture ... done
[17:00:35.075] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:35.075] - nx: 2
[17:00:35.075] - relay: TRUE
[17:00:35.075] - stdout: TRUE
[17:00:35.076] - signal: TRUE
[17:00:35.076] - resignal: FALSE
[17:00:35.076] - force: TRUE
[17:00:35.076] - relayed: [n=2] TRUE, FALSE
[17:00:35.076] - queued futures: [n=2] TRUE, FALSE
[17:00:35.076]  - until=2
[17:00:35.076]  - relaying element #2
[17:00:35.076] result() for ClusterFuture ...
[17:00:35.076] - result already collected: FutureResult
[17:00:35.076] result() for ClusterFuture ... done
[17:00:35.076] result() for ClusterFuture ...
[17:00:35.076] - result already collected: FutureResult
[17:00:35.077] result() for ClusterFuture ... done
[17:00:35.077] result() for ClusterFuture ...
[17:00:35.077] - result already collected: FutureResult
[17:00:35.077] result() for ClusterFuture ... done
[17:00:35.077] result() for ClusterFuture ...
[17:00:35.077] - result already collected: FutureResult
[17:00:35.077] result() for ClusterFuture ... done
[17:00:35.077] - relayed: [n=2] TRUE, TRUE
[17:00:35.077] - queued futures: [n=2] TRUE, TRUE
[17:00:35.077] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:35.078]  length: 0 (resolved future 2)
[17:00:35.078] Relaying remaining futures
[17:00:35.078] signalConditionsASAP(NULL, pos=0) ...
[17:00:35.078] - nx: 2
[17:00:35.078] - relay: TRUE
[17:00:35.078] - stdout: TRUE
[17:00:35.078] - signal: TRUE
[17:00:35.078] - resignal: FALSE
[17:00:35.078] - force: TRUE
[17:00:35.078] - relayed: [n=2] TRUE, TRUE
[17:00:35.078] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:35.079] - relayed: [n=2] TRUE, TRUE
[17:00:35.079] - queued futures: [n=2] TRUE, TRUE
[17:00:35.079] signalConditionsASAP(NULL, pos=0) ... done
[17:00:35.079] resolve() on list ... DONE
[17:00:35.079] result() for ClusterFuture ...
[17:00:35.079] - result already collected: FutureResult
[17:00:35.079] result() for ClusterFuture ... done
[17:00:35.079] result() for ClusterFuture ...
[17:00:35.079] - result already collected: FutureResult
[17:00:35.079] result() for ClusterFuture ... done
[17:00:35.079] result() for ClusterFuture ...
[17:00:35.080] - result already collected: FutureResult
[17:00:35.080] result() for ClusterFuture ... done
[17:00:35.080] result() for ClusterFuture ...
[17:00:35.080] - result already collected: FutureResult
[17:00:35.080] result() for ClusterFuture ... done
[17:00:35.080]  - Number of value chunks collected: 2
[17:00:35.080] Resolving 2 futures (chunks) ... DONE
[17:00:35.080] Reducing values from 2 chunks ...
[17:00:35.080]  - Number of values collected after concatenation: 4
[17:00:35.080]  - Number of values expected: 4
[17:00:35.080] Reducing values from 2 chunks ... DONE
[17:00:35.081] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[17:00:35.081] future_mapply() ...
[17:00:35.085] Number of chunks: 2
[17:00:35.085] getGlobalsAndPackagesXApply() ...
[17:00:35.085]  - future.globals: TRUE
[17:00:35.085] getGlobalsAndPackages() ...
[17:00:35.085] Searching for globals...
[17:00:35.086] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:00:35.087] Searching for globals ... DONE
[17:00:35.087] Resolving globals: FALSE
[17:00:35.087] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[17:00:35.087] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[17:00:35.088] - globals: [1] ‘FUN’
[17:00:35.088] - packages: [1] ‘stats’
[17:00:35.088] getGlobalsAndPackages() ... DONE
[17:00:35.088]  - globals found/used: [n=1] ‘FUN’
[17:00:35.088]  - needed namespaces: [n=1] ‘stats’
[17:00:35.088] Finding globals ... DONE
[17:00:35.088] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:35.088] List of 2
[17:00:35.088]  $ ...future.FUN:function (x, w, ...)  
[17:00:35.088]  $ MoreArgs     : NULL
[17:00:35.088]  - attr(*, "where")=List of 2
[17:00:35.088]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:35.088]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:35.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:35.088]  - attr(*, "resolved")= logi FALSE
[17:00:35.088]  - attr(*, "total_size")= num NA
[17:00:35.091] Packages to be attached in all futures: [n=1] ‘stats’
[17:00:35.091] getGlobalsAndPackagesXApply() ... DONE
[17:00:35.091] Number of futures (= number of chunks): 2
[17:00:35.091] Launching 2 futures (chunks) ...
[17:00:35.091] Chunk #1 of 2 ...
[17:00:35.091]  - Finding globals in '...' for chunk #1 ...
[17:00:35.092] getGlobalsAndPackages() ...
[17:00:35.092] Searching for globals...
[17:00:35.092] 
[17:00:35.092] Searching for globals ... DONE
[17:00:35.092] - globals: [0] <none>
[17:00:35.092] getGlobalsAndPackages() ... DONE
[17:00:35.092]    + additional globals found: [n=0] 
[17:00:35.092]    + additional namespaces needed: [n=0] 
[17:00:35.092]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:35.093]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:35.093]  - seeds: <none>
[17:00:35.093]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.093] getGlobalsAndPackages() ...
[17:00:35.093] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.093] Resolving globals: FALSE
[17:00:35.094] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[17:00:35.094] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:35.094] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.094] - packages: [1] ‘stats’
[17:00:35.094] getGlobalsAndPackages() ... DONE
[17:00:35.095] run() for ‘Future’ ...
[17:00:35.095] - state: ‘created’
[17:00:35.095] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:35.109] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:35.109]   - Field: ‘node’
[17:00:35.109]   - Field: ‘label’
[17:00:35.109]   - Field: ‘local’
[17:00:35.109]   - Field: ‘owner’
[17:00:35.110]   - Field: ‘envir’
[17:00:35.110]   - Field: ‘workers’
[17:00:35.110]   - Field: ‘packages’
[17:00:35.110]   - Field: ‘gc’
[17:00:35.110]   - Field: ‘conditions’
[17:00:35.110]   - Field: ‘persistent’
[17:00:35.110]   - Field: ‘expr’
[17:00:35.110]   - Field: ‘uuid’
[17:00:35.110]   - Field: ‘seed’
[17:00:35.110]   - Field: ‘version’
[17:00:35.110]   - Field: ‘result’
[17:00:35.111]   - Field: ‘asynchronous’
[17:00:35.111]   - Field: ‘calls’
[17:00:35.111]   - Field: ‘globals’
[17:00:35.111]   - Field: ‘stdout’
[17:00:35.111]   - Field: ‘earlySignal’
[17:00:35.111]   - Field: ‘lazy’
[17:00:35.111]   - Field: ‘state’
[17:00:35.111] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:35.111] - Launch lazy future ...
[17:00:35.112] Packages needed by the future expression (n = 1): ‘stats’
[17:00:35.112] Packages needed by future strategies (n = 0): <none>
[17:00:35.112] {
[17:00:35.112]     {
[17:00:35.112]         {
[17:00:35.112]             ...future.startTime <- base::Sys.time()
[17:00:35.112]             {
[17:00:35.112]                 {
[17:00:35.112]                   {
[17:00:35.112]                     {
[17:00:35.112]                       {
[17:00:35.112]                         base::local({
[17:00:35.112]                           has_future <- base::requireNamespace("future", 
[17:00:35.112]                             quietly = TRUE)
[17:00:35.112]                           if (has_future) {
[17:00:35.112]                             ns <- base::getNamespace("future")
[17:00:35.112]                             version <- ns[[".package"]][["version"]]
[17:00:35.112]                             if (is.null(version)) 
[17:00:35.112]                               version <- utils::packageVersion("future")
[17:00:35.112]                           }
[17:00:35.112]                           else {
[17:00:35.112]                             version <- NULL
[17:00:35.112]                           }
[17:00:35.112]                           if (!has_future || version < "1.8.0") {
[17:00:35.112]                             info <- base::c(r_version = base::gsub("R version ", 
[17:00:35.112]                               "", base::R.version$version.string), 
[17:00:35.112]                               platform = base::sprintf("%s (%s-bit)", 
[17:00:35.112]                                 base::R.version$platform, 8 * 
[17:00:35.112]                                   base::.Machine$sizeof.pointer), 
[17:00:35.112]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:35.112]                                 "release", "version")], collapse = " "), 
[17:00:35.112]                               hostname = base::Sys.info()[["nodename"]])
[17:00:35.112]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:00:35.112]                               info)
[17:00:35.112]                             info <- base::paste(info, collapse = "; ")
[17:00:35.112]                             if (!has_future) {
[17:00:35.112]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:35.112]                                 info)
[17:00:35.112]                             }
[17:00:35.112]                             else {
[17:00:35.112]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:35.112]                                 info, version)
[17:00:35.112]                             }
[17:00:35.112]                             base::stop(msg)
[17:00:35.112]                           }
[17:00:35.112]                         })
[17:00:35.112]                       }
[17:00:35.112]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:35.112]                       base::options(mc.cores = 1L)
[17:00:35.112]                     }
[17:00:35.112]                     base::local({
[17:00:35.112]                       for (pkg in "stats") {
[17:00:35.112]                         base::loadNamespace(pkg)
[17:00:35.112]                         base::library(pkg, character.only = TRUE)
[17:00:35.112]                       }
[17:00:35.112]                     })
[17:00:35.112]                   }
[17:00:35.112]                   ...future.strategy.old <- future::plan("list")
[17:00:35.112]                   options(future.plan = NULL)
[17:00:35.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:35.112]                 }
[17:00:35.112]                 ...future.workdir <- getwd()
[17:00:35.112]             }
[17:00:35.112]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:35.112]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:35.112]         }
[17:00:35.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:35.112]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:35.112]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:35.112]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:35.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:35.112]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:35.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:35.112]             base::names(...future.oldOptions))
[17:00:35.112]     }
[17:00:35.112]     if (FALSE) {
[17:00:35.112]     }
[17:00:35.112]     else {
[17:00:35.112]         if (TRUE) {
[17:00:35.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:35.112]                 open = "w")
[17:00:35.112]         }
[17:00:35.112]         else {
[17:00:35.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:35.112]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:35.112]         }
[17:00:35.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:35.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:35.112]             base::sink(type = "output", split = FALSE)
[17:00:35.112]             base::close(...future.stdout)
[17:00:35.112]         }, add = TRUE)
[17:00:35.112]     }
[17:00:35.112]     ...future.frame <- base::sys.nframe()
[17:00:35.112]     ...future.conditions <- base::list()
[17:00:35.112]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:35.112]     if (FALSE) {
[17:00:35.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:35.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:35.112]     }
[17:00:35.112]     ...future.result <- base::tryCatch({
[17:00:35.112]         base::withCallingHandlers({
[17:00:35.112]             ...future.value <- base::withVisible(base::local({
[17:00:35.112]                 ...future.makeSendCondition <- base::local({
[17:00:35.112]                   sendCondition <- NULL
[17:00:35.112]                   function(frame = 1L) {
[17:00:35.112]                     if (is.function(sendCondition)) 
[17:00:35.112]                       return(sendCondition)
[17:00:35.112]                     ns <- getNamespace("parallel")
[17:00:35.112]                     if (exists("sendData", mode = "function", 
[17:00:35.112]                       envir = ns)) {
[17:00:35.112]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:35.112]                         envir = ns)
[17:00:35.112]                       envir <- sys.frame(frame)
[17:00:35.112]                       master <- NULL
[17:00:35.112]                       while (!identical(envir, .GlobalEnv) && 
[17:00:35.112]                         !identical(envir, emptyenv())) {
[17:00:35.112]                         if (exists("master", mode = "list", envir = envir, 
[17:00:35.112]                           inherits = FALSE)) {
[17:00:35.112]                           master <- get("master", mode = "list", 
[17:00:35.112]                             envir = envir, inherits = FALSE)
[17:00:35.112]                           if (inherits(master, c("SOCKnode", 
[17:00:35.112]                             "SOCK0node"))) {
[17:00:35.112]                             sendCondition <<- function(cond) {
[17:00:35.112]                               data <- list(type = "VALUE", value = cond, 
[17:00:35.112]                                 success = TRUE)
[17:00:35.112]                               parallel_sendData(master, data)
[17:00:35.112]                             }
[17:00:35.112]                             return(sendCondition)
[17:00:35.112]                           }
[17:00:35.112]                         }
[17:00:35.112]                         frame <- frame + 1L
[17:00:35.112]                         envir <- sys.frame(frame)
[17:00:35.112]                       }
[17:00:35.112]                     }
[17:00:35.112]                     sendCondition <<- function(cond) NULL
[17:00:35.112]                   }
[17:00:35.112]                 })
[17:00:35.112]                 withCallingHandlers({
[17:00:35.112]                   {
[17:00:35.112]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.112]                     if (!identical(...future.globals.maxSize.org, 
[17:00:35.112]                       ...future.globals.maxSize)) {
[17:00:35.112]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.112]                       on.exit(options(oopts), add = TRUE)
[17:00:35.112]                     }
[17:00:35.112]                     {
[17:00:35.112]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.112]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:35.112]                         USE.NAMES = FALSE)
[17:00:35.112]                       do.call(mapply, args = args)
[17:00:35.112]                     }
[17:00:35.112]                   }
[17:00:35.112]                 }, immediateCondition = function(cond) {
[17:00:35.112]                   sendCondition <- ...future.makeSendCondition()
[17:00:35.112]                   sendCondition(cond)
[17:00:35.112]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.112]                   {
[17:00:35.112]                     inherits <- base::inherits
[17:00:35.112]                     invokeRestart <- base::invokeRestart
[17:00:35.112]                     is.null <- base::is.null
[17:00:35.112]                     muffled <- FALSE
[17:00:35.112]                     if (inherits(cond, "message")) {
[17:00:35.112]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:35.112]                       if (muffled) 
[17:00:35.112]                         invokeRestart("muffleMessage")
[17:00:35.112]                     }
[17:00:35.112]                     else if (inherits(cond, "warning")) {
[17:00:35.112]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:35.112]                       if (muffled) 
[17:00:35.112]                         invokeRestart("muffleWarning")
[17:00:35.112]                     }
[17:00:35.112]                     else if (inherits(cond, "condition")) {
[17:00:35.112]                       if (!is.null(pattern)) {
[17:00:35.112]                         computeRestarts <- base::computeRestarts
[17:00:35.112]                         grepl <- base::grepl
[17:00:35.112]                         restarts <- computeRestarts(cond)
[17:00:35.112]                         for (restart in restarts) {
[17:00:35.112]                           name <- restart$name
[17:00:35.112]                           if (is.null(name)) 
[17:00:35.112]                             next
[17:00:35.112]                           if (!grepl(pattern, name)) 
[17:00:35.112]                             next
[17:00:35.112]                           invokeRestart(restart)
[17:00:35.112]                           muffled <- TRUE
[17:00:35.112]                           break
[17:00:35.112]                         }
[17:00:35.112]                       }
[17:00:35.112]                     }
[17:00:35.112]                     invisible(muffled)
[17:00:35.112]                   }
[17:00:35.112]                   muffleCondition(cond)
[17:00:35.112]                 })
[17:00:35.112]             }))
[17:00:35.112]             future::FutureResult(value = ...future.value$value, 
[17:00:35.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.112]                   ...future.rng), globalenv = if (FALSE) 
[17:00:35.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:35.112]                     ...future.globalenv.names))
[17:00:35.112]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:35.112]         }, condition = base::local({
[17:00:35.112]             c <- base::c
[17:00:35.112]             inherits <- base::inherits
[17:00:35.112]             invokeRestart <- base::invokeRestart
[17:00:35.112]             length <- base::length
[17:00:35.112]             list <- base::list
[17:00:35.112]             seq.int <- base::seq.int
[17:00:35.112]             signalCondition <- base::signalCondition
[17:00:35.112]             sys.calls <- base::sys.calls
[17:00:35.112]             `[[` <- base::`[[`
[17:00:35.112]             `+` <- base::`+`
[17:00:35.112]             `<<-` <- base::`<<-`
[17:00:35.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:35.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:35.112]                   3L)]
[17:00:35.112]             }
[17:00:35.112]             function(cond) {
[17:00:35.112]                 is_error <- inherits(cond, "error")
[17:00:35.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:35.112]                   NULL)
[17:00:35.112]                 if (is_error) {
[17:00:35.112]                   sessionInformation <- function() {
[17:00:35.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:35.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:35.112]                       search = base::search(), system = base::Sys.info())
[17:00:35.112]                   }
[17:00:35.112]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:35.112]                     cond$call), session = sessionInformation(), 
[17:00:35.112]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:35.112]                   signalCondition(cond)
[17:00:35.112]                 }
[17:00:35.112]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:35.112]                 "immediateCondition"))) {
[17:00:35.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:35.112]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:35.112]                   if (TRUE && !signal) {
[17:00:35.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.112]                     {
[17:00:35.112]                       inherits <- base::inherits
[17:00:35.112]                       invokeRestart <- base::invokeRestart
[17:00:35.112]                       is.null <- base::is.null
[17:00:35.112]                       muffled <- FALSE
[17:00:35.112]                       if (inherits(cond, "message")) {
[17:00:35.112]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.112]                         if (muffled) 
[17:00:35.112]                           invokeRestart("muffleMessage")
[17:00:35.112]                       }
[17:00:35.112]                       else if (inherits(cond, "warning")) {
[17:00:35.112]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.112]                         if (muffled) 
[17:00:35.112]                           invokeRestart("muffleWarning")
[17:00:35.112]                       }
[17:00:35.112]                       else if (inherits(cond, "condition")) {
[17:00:35.112]                         if (!is.null(pattern)) {
[17:00:35.112]                           computeRestarts <- base::computeRestarts
[17:00:35.112]                           grepl <- base::grepl
[17:00:35.112]                           restarts <- computeRestarts(cond)
[17:00:35.112]                           for (restart in restarts) {
[17:00:35.112]                             name <- restart$name
[17:00:35.112]                             if (is.null(name)) 
[17:00:35.112]                               next
[17:00:35.112]                             if (!grepl(pattern, name)) 
[17:00:35.112]                               next
[17:00:35.112]                             invokeRestart(restart)
[17:00:35.112]                             muffled <- TRUE
[17:00:35.112]                             break
[17:00:35.112]                           }
[17:00:35.112]                         }
[17:00:35.112]                       }
[17:00:35.112]                       invisible(muffled)
[17:00:35.112]                     }
[17:00:35.112]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.112]                   }
[17:00:35.112]                 }
[17:00:35.112]                 else {
[17:00:35.112]                   if (TRUE) {
[17:00:35.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.112]                     {
[17:00:35.112]                       inherits <- base::inherits
[17:00:35.112]                       invokeRestart <- base::invokeRestart
[17:00:35.112]                       is.null <- base::is.null
[17:00:35.112]                       muffled <- FALSE
[17:00:35.112]                       if (inherits(cond, "message")) {
[17:00:35.112]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.112]                         if (muffled) 
[17:00:35.112]                           invokeRestart("muffleMessage")
[17:00:35.112]                       }
[17:00:35.112]                       else if (inherits(cond, "warning")) {
[17:00:35.112]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.112]                         if (muffled) 
[17:00:35.112]                           invokeRestart("muffleWarning")
[17:00:35.112]                       }
[17:00:35.112]                       else if (inherits(cond, "condition")) {
[17:00:35.112]                         if (!is.null(pattern)) {
[17:00:35.112]                           computeRestarts <- base::computeRestarts
[17:00:35.112]                           grepl <- base::grepl
[17:00:35.112]                           restarts <- computeRestarts(cond)
[17:00:35.112]                           for (restart in restarts) {
[17:00:35.112]                             name <- restart$name
[17:00:35.112]                             if (is.null(name)) 
[17:00:35.112]                               next
[17:00:35.112]                             if (!grepl(pattern, name)) 
[17:00:35.112]                               next
[17:00:35.112]                             invokeRestart(restart)
[17:00:35.112]                             muffled <- TRUE
[17:00:35.112]                             break
[17:00:35.112]                           }
[17:00:35.112]                         }
[17:00:35.112]                       }
[17:00:35.112]                       invisible(muffled)
[17:00:35.112]                     }
[17:00:35.112]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.112]                   }
[17:00:35.112]                 }
[17:00:35.112]             }
[17:00:35.112]         }))
[17:00:35.112]     }, error = function(ex) {
[17:00:35.112]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:35.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.112]                 ...future.rng), started = ...future.startTime, 
[17:00:35.112]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:35.112]             version = "1.8"), class = "FutureResult")
[17:00:35.112]     }, finally = {
[17:00:35.112]         if (!identical(...future.workdir, getwd())) 
[17:00:35.112]             setwd(...future.workdir)
[17:00:35.112]         {
[17:00:35.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:35.112]                 ...future.oldOptions$nwarnings <- NULL
[17:00:35.112]             }
[17:00:35.112]             base::options(...future.oldOptions)
[17:00:35.112]             if (.Platform$OS.type == "windows") {
[17:00:35.112]                 old_names <- names(...future.oldEnvVars)
[17:00:35.112]                 envs <- base::Sys.getenv()
[17:00:35.112]                 names <- names(envs)
[17:00:35.112]                 common <- intersect(names, old_names)
[17:00:35.112]                 added <- setdiff(names, old_names)
[17:00:35.112]                 removed <- setdiff(old_names, names)
[17:00:35.112]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:35.112]                   envs[common]]
[17:00:35.112]                 NAMES <- toupper(changed)
[17:00:35.112]                 args <- list()
[17:00:35.112]                 for (kk in seq_along(NAMES)) {
[17:00:35.112]                   name <- changed[[kk]]
[17:00:35.112]                   NAME <- NAMES[[kk]]
[17:00:35.112]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.112]                     next
[17:00:35.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.112]                 }
[17:00:35.112]                 NAMES <- toupper(added)
[17:00:35.112]                 for (kk in seq_along(NAMES)) {
[17:00:35.112]                   name <- added[[kk]]
[17:00:35.112]                   NAME <- NAMES[[kk]]
[17:00:35.112]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.112]                     next
[17:00:35.112]                   args[[name]] <- ""
[17:00:35.112]                 }
[17:00:35.112]                 NAMES <- toupper(removed)
[17:00:35.112]                 for (kk in seq_along(NAMES)) {
[17:00:35.112]                   name <- removed[[kk]]
[17:00:35.112]                   NAME <- NAMES[[kk]]
[17:00:35.112]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.112]                     next
[17:00:35.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.112]                 }
[17:00:35.112]                 if (length(args) > 0) 
[17:00:35.112]                   base::do.call(base::Sys.setenv, args = args)
[17:00:35.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:35.112]             }
[17:00:35.112]             else {
[17:00:35.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:35.112]             }
[17:00:35.112]             {
[17:00:35.112]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:35.112]                   0L) {
[17:00:35.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:35.112]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:35.112]                   base::options(opts)
[17:00:35.112]                 }
[17:00:35.112]                 {
[17:00:35.112]                   {
[17:00:35.112]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:35.112]                     NULL
[17:00:35.112]                   }
[17:00:35.112]                   options(future.plan = NULL)
[17:00:35.112]                   if (is.na(NA_character_)) 
[17:00:35.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:35.112]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:35.112]                     .init = FALSE)
[17:00:35.112]                 }
[17:00:35.112]             }
[17:00:35.112]         }
[17:00:35.112]     })
[17:00:35.112]     if (TRUE) {
[17:00:35.112]         base::sink(type = "output", split = FALSE)
[17:00:35.112]         if (TRUE) {
[17:00:35.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:35.112]         }
[17:00:35.112]         else {
[17:00:35.112]             ...future.result["stdout"] <- base::list(NULL)
[17:00:35.112]         }
[17:00:35.112]         base::close(...future.stdout)
[17:00:35.112]         ...future.stdout <- NULL
[17:00:35.112]     }
[17:00:35.112]     ...future.result$conditions <- ...future.conditions
[17:00:35.112]     ...future.result$finished <- base::Sys.time()
[17:00:35.112]     ...future.result
[17:00:35.112] }
[17:00:35.115] Exporting 5 global objects (2.07 KiB) to cluster node #1 ...
[17:00:35.115] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ...
[17:00:35.116] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ... DONE
[17:00:35.116] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:35.116] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:35.117] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ...
[17:00:35.117] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ... DONE
[17:00:35.117] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:35.117] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:35.118] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:35.118] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:35.118] Exporting 5 global objects (2.07 KiB) to cluster node #1 ... DONE
[17:00:35.119] MultisessionFuture started
[17:00:35.119] - Launch lazy future ... done
[17:00:35.119] run() for ‘MultisessionFuture’ ... done
[17:00:35.119] Created future:
[17:00:35.119] MultisessionFuture:
[17:00:35.119] Label: ‘future_Map-1’
[17:00:35.119] Expression:
[17:00:35.119] {
[17:00:35.119]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.119]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:35.119]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.119]         on.exit(options(oopts), add = TRUE)
[17:00:35.119]     }
[17:00:35.119]     {
[17:00:35.119]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.119]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:35.119]         do.call(mapply, args = args)
[17:00:35.119]     }
[17:00:35.119] }
[17:00:35.119] Lazy evaluation: FALSE
[17:00:35.119] Asynchronous evaluation: TRUE
[17:00:35.119] Local evaluation: TRUE
[17:00:35.119] Environment: R_GlobalEnv
[17:00:35.119] Capture standard output: TRUE
[17:00:35.119] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:35.119] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:35.119] Packages: 1 packages (‘stats’)
[17:00:35.119] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:35.119] Resolved: FALSE
[17:00:35.119] Value: <not collected>
[17:00:35.119] Conditions captured: <none>
[17:00:35.119] Early signaling: FALSE
[17:00:35.119] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:35.119] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.131] Chunk #1 of 2 ... DONE
[17:00:35.131] Chunk #2 of 2 ...
[17:00:35.131]  - Finding globals in '...' for chunk #2 ...
[17:00:35.131] getGlobalsAndPackages() ...
[17:00:35.131] Searching for globals...
[17:00:35.132] 
[17:00:35.132] Searching for globals ... DONE
[17:00:35.132] - globals: [0] <none>
[17:00:35.132] getGlobalsAndPackages() ... DONE
[17:00:35.132]    + additional globals found: [n=0] 
[17:00:35.132]    + additional namespaces needed: [n=0] 
[17:00:35.132]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:35.132]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:35.133]  - seeds: <none>
[17:00:35.133]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.133] getGlobalsAndPackages() ...
[17:00:35.133] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.133] Resolving globals: FALSE
[17:00:35.133] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[17:00:35.134] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:35.134] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.134] - packages: [1] ‘stats’
[17:00:35.134] getGlobalsAndPackages() ... DONE
[17:00:35.135] run() for ‘Future’ ...
[17:00:35.135] - state: ‘created’
[17:00:35.135] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:35.149] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:35.149]   - Field: ‘node’
[17:00:35.150]   - Field: ‘label’
[17:00:35.150]   - Field: ‘local’
[17:00:35.150]   - Field: ‘owner’
[17:00:35.150]   - Field: ‘envir’
[17:00:35.150]   - Field: ‘workers’
[17:00:35.150]   - Field: ‘packages’
[17:00:35.150]   - Field: ‘gc’
[17:00:35.150]   - Field: ‘conditions’
[17:00:35.150]   - Field: ‘persistent’
[17:00:35.150]   - Field: ‘expr’
[17:00:35.150]   - Field: ‘uuid’
[17:00:35.151]   - Field: ‘seed’
[17:00:35.151]   - Field: ‘version’
[17:00:35.151]   - Field: ‘result’
[17:00:35.151]   - Field: ‘asynchronous’
[17:00:35.151]   - Field: ‘calls’
[17:00:35.151]   - Field: ‘globals’
[17:00:35.151]   - Field: ‘stdout’
[17:00:35.151]   - Field: ‘earlySignal’
[17:00:35.151]   - Field: ‘lazy’
[17:00:35.151]   - Field: ‘state’
[17:00:35.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:35.152] - Launch lazy future ...
[17:00:35.152] Packages needed by the future expression (n = 1): ‘stats’
[17:00:35.152] Packages needed by future strategies (n = 0): <none>
[17:00:35.153] {
[17:00:35.153]     {
[17:00:35.153]         {
[17:00:35.153]             ...future.startTime <- base::Sys.time()
[17:00:35.153]             {
[17:00:35.153]                 {
[17:00:35.153]                   {
[17:00:35.153]                     {
[17:00:35.153]                       {
[17:00:35.153]                         base::local({
[17:00:35.153]                           has_future <- base::requireNamespace("future", 
[17:00:35.153]                             quietly = TRUE)
[17:00:35.153]                           if (has_future) {
[17:00:35.153]                             ns <- base::getNamespace("future")
[17:00:35.153]                             version <- ns[[".package"]][["version"]]
[17:00:35.153]                             if (is.null(version)) 
[17:00:35.153]                               version <- utils::packageVersion("future")
[17:00:35.153]                           }
[17:00:35.153]                           else {
[17:00:35.153]                             version <- NULL
[17:00:35.153]                           }
[17:00:35.153]                           if (!has_future || version < "1.8.0") {
[17:00:35.153]                             info <- base::c(r_version = base::gsub("R version ", 
[17:00:35.153]                               "", base::R.version$version.string), 
[17:00:35.153]                               platform = base::sprintf("%s (%s-bit)", 
[17:00:35.153]                                 base::R.version$platform, 8 * 
[17:00:35.153]                                   base::.Machine$sizeof.pointer), 
[17:00:35.153]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:35.153]                                 "release", "version")], collapse = " "), 
[17:00:35.153]                               hostname = base::Sys.info()[["nodename"]])
[17:00:35.153]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:00:35.153]                               info)
[17:00:35.153]                             info <- base::paste(info, collapse = "; ")
[17:00:35.153]                             if (!has_future) {
[17:00:35.153]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:35.153]                                 info)
[17:00:35.153]                             }
[17:00:35.153]                             else {
[17:00:35.153]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:35.153]                                 info, version)
[17:00:35.153]                             }
[17:00:35.153]                             base::stop(msg)
[17:00:35.153]                           }
[17:00:35.153]                         })
[17:00:35.153]                       }
[17:00:35.153]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:35.153]                       base::options(mc.cores = 1L)
[17:00:35.153]                     }
[17:00:35.153]                     base::local({
[17:00:35.153]                       for (pkg in "stats") {
[17:00:35.153]                         base::loadNamespace(pkg)
[17:00:35.153]                         base::library(pkg, character.only = TRUE)
[17:00:35.153]                       }
[17:00:35.153]                     })
[17:00:35.153]                   }
[17:00:35.153]                   ...future.strategy.old <- future::plan("list")
[17:00:35.153]                   options(future.plan = NULL)
[17:00:35.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:35.153]                 }
[17:00:35.153]                 ...future.workdir <- getwd()
[17:00:35.153]             }
[17:00:35.153]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:35.153]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:35.153]         }
[17:00:35.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:35.153]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:35.153]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:35.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:35.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:35.153]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:35.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:35.153]             base::names(...future.oldOptions))
[17:00:35.153]     }
[17:00:35.153]     if (FALSE) {
[17:00:35.153]     }
[17:00:35.153]     else {
[17:00:35.153]         if (TRUE) {
[17:00:35.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:35.153]                 open = "w")
[17:00:35.153]         }
[17:00:35.153]         else {
[17:00:35.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:35.153]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:35.153]         }
[17:00:35.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:35.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:35.153]             base::sink(type = "output", split = FALSE)
[17:00:35.153]             base::close(...future.stdout)
[17:00:35.153]         }, add = TRUE)
[17:00:35.153]     }
[17:00:35.153]     ...future.frame <- base::sys.nframe()
[17:00:35.153]     ...future.conditions <- base::list()
[17:00:35.153]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:35.153]     if (FALSE) {
[17:00:35.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:35.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:35.153]     }
[17:00:35.153]     ...future.result <- base::tryCatch({
[17:00:35.153]         base::withCallingHandlers({
[17:00:35.153]             ...future.value <- base::withVisible(base::local({
[17:00:35.153]                 ...future.makeSendCondition <- base::local({
[17:00:35.153]                   sendCondition <- NULL
[17:00:35.153]                   function(frame = 1L) {
[17:00:35.153]                     if (is.function(sendCondition)) 
[17:00:35.153]                       return(sendCondition)
[17:00:35.153]                     ns <- getNamespace("parallel")
[17:00:35.153]                     if (exists("sendData", mode = "function", 
[17:00:35.153]                       envir = ns)) {
[17:00:35.153]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:35.153]                         envir = ns)
[17:00:35.153]                       envir <- sys.frame(frame)
[17:00:35.153]                       master <- NULL
[17:00:35.153]                       while (!identical(envir, .GlobalEnv) && 
[17:00:35.153]                         !identical(envir, emptyenv())) {
[17:00:35.153]                         if (exists("master", mode = "list", envir = envir, 
[17:00:35.153]                           inherits = FALSE)) {
[17:00:35.153]                           master <- get("master", mode = "list", 
[17:00:35.153]                             envir = envir, inherits = FALSE)
[17:00:35.153]                           if (inherits(master, c("SOCKnode", 
[17:00:35.153]                             "SOCK0node"))) {
[17:00:35.153]                             sendCondition <<- function(cond) {
[17:00:35.153]                               data <- list(type = "VALUE", value = cond, 
[17:00:35.153]                                 success = TRUE)
[17:00:35.153]                               parallel_sendData(master, data)
[17:00:35.153]                             }
[17:00:35.153]                             return(sendCondition)
[17:00:35.153]                           }
[17:00:35.153]                         }
[17:00:35.153]                         frame <- frame + 1L
[17:00:35.153]                         envir <- sys.frame(frame)
[17:00:35.153]                       }
[17:00:35.153]                     }
[17:00:35.153]                     sendCondition <<- function(cond) NULL
[17:00:35.153]                   }
[17:00:35.153]                 })
[17:00:35.153]                 withCallingHandlers({
[17:00:35.153]                   {
[17:00:35.153]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.153]                     if (!identical(...future.globals.maxSize.org, 
[17:00:35.153]                       ...future.globals.maxSize)) {
[17:00:35.153]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.153]                       on.exit(options(oopts), add = TRUE)
[17:00:35.153]                     }
[17:00:35.153]                     {
[17:00:35.153]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.153]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:35.153]                         USE.NAMES = FALSE)
[17:00:35.153]                       do.call(mapply, args = args)
[17:00:35.153]                     }
[17:00:35.153]                   }
[17:00:35.153]                 }, immediateCondition = function(cond) {
[17:00:35.153]                   sendCondition <- ...future.makeSendCondition()
[17:00:35.153]                   sendCondition(cond)
[17:00:35.153]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.153]                   {
[17:00:35.153]                     inherits <- base::inherits
[17:00:35.153]                     invokeRestart <- base::invokeRestart
[17:00:35.153]                     is.null <- base::is.null
[17:00:35.153]                     muffled <- FALSE
[17:00:35.153]                     if (inherits(cond, "message")) {
[17:00:35.153]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:35.153]                       if (muffled) 
[17:00:35.153]                         invokeRestart("muffleMessage")
[17:00:35.153]                     }
[17:00:35.153]                     else if (inherits(cond, "warning")) {
[17:00:35.153]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:35.153]                       if (muffled) 
[17:00:35.153]                         invokeRestart("muffleWarning")
[17:00:35.153]                     }
[17:00:35.153]                     else if (inherits(cond, "condition")) {
[17:00:35.153]                       if (!is.null(pattern)) {
[17:00:35.153]                         computeRestarts <- base::computeRestarts
[17:00:35.153]                         grepl <- base::grepl
[17:00:35.153]                         restarts <- computeRestarts(cond)
[17:00:35.153]                         for (restart in restarts) {
[17:00:35.153]                           name <- restart$name
[17:00:35.153]                           if (is.null(name)) 
[17:00:35.153]                             next
[17:00:35.153]                           if (!grepl(pattern, name)) 
[17:00:35.153]                             next
[17:00:35.153]                           invokeRestart(restart)
[17:00:35.153]                           muffled <- TRUE
[17:00:35.153]                           break
[17:00:35.153]                         }
[17:00:35.153]                       }
[17:00:35.153]                     }
[17:00:35.153]                     invisible(muffled)
[17:00:35.153]                   }
[17:00:35.153]                   muffleCondition(cond)
[17:00:35.153]                 })
[17:00:35.153]             }))
[17:00:35.153]             future::FutureResult(value = ...future.value$value, 
[17:00:35.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.153]                   ...future.rng), globalenv = if (FALSE) 
[17:00:35.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:35.153]                     ...future.globalenv.names))
[17:00:35.153]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:35.153]         }, condition = base::local({
[17:00:35.153]             c <- base::c
[17:00:35.153]             inherits <- base::inherits
[17:00:35.153]             invokeRestart <- base::invokeRestart
[17:00:35.153]             length <- base::length
[17:00:35.153]             list <- base::list
[17:00:35.153]             seq.int <- base::seq.int
[17:00:35.153]             signalCondition <- base::signalCondition
[17:00:35.153]             sys.calls <- base::sys.calls
[17:00:35.153]             `[[` <- base::`[[`
[17:00:35.153]             `+` <- base::`+`
[17:00:35.153]             `<<-` <- base::`<<-`
[17:00:35.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:35.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:35.153]                   3L)]
[17:00:35.153]             }
[17:00:35.153]             function(cond) {
[17:00:35.153]                 is_error <- inherits(cond, "error")
[17:00:35.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:35.153]                   NULL)
[17:00:35.153]                 if (is_error) {
[17:00:35.153]                   sessionInformation <- function() {
[17:00:35.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:35.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:35.153]                       search = base::search(), system = base::Sys.info())
[17:00:35.153]                   }
[17:00:35.153]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:35.153]                     cond$call), session = sessionInformation(), 
[17:00:35.153]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:35.153]                   signalCondition(cond)
[17:00:35.153]                 }
[17:00:35.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:35.153]                 "immediateCondition"))) {
[17:00:35.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:35.153]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:35.153]                   if (TRUE && !signal) {
[17:00:35.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.153]                     {
[17:00:35.153]                       inherits <- base::inherits
[17:00:35.153]                       invokeRestart <- base::invokeRestart
[17:00:35.153]                       is.null <- base::is.null
[17:00:35.153]                       muffled <- FALSE
[17:00:35.153]                       if (inherits(cond, "message")) {
[17:00:35.153]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.153]                         if (muffled) 
[17:00:35.153]                           invokeRestart("muffleMessage")
[17:00:35.153]                       }
[17:00:35.153]                       else if (inherits(cond, "warning")) {
[17:00:35.153]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.153]                         if (muffled) 
[17:00:35.153]                           invokeRestart("muffleWarning")
[17:00:35.153]                       }
[17:00:35.153]                       else if (inherits(cond, "condition")) {
[17:00:35.153]                         if (!is.null(pattern)) {
[17:00:35.153]                           computeRestarts <- base::computeRestarts
[17:00:35.153]                           grepl <- base::grepl
[17:00:35.153]                           restarts <- computeRestarts(cond)
[17:00:35.153]                           for (restart in restarts) {
[17:00:35.153]                             name <- restart$name
[17:00:35.153]                             if (is.null(name)) 
[17:00:35.153]                               next
[17:00:35.153]                             if (!grepl(pattern, name)) 
[17:00:35.153]                               next
[17:00:35.153]                             invokeRestart(restart)
[17:00:35.153]                             muffled <- TRUE
[17:00:35.153]                             break
[17:00:35.153]                           }
[17:00:35.153]                         }
[17:00:35.153]                       }
[17:00:35.153]                       invisible(muffled)
[17:00:35.153]                     }
[17:00:35.153]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.153]                   }
[17:00:35.153]                 }
[17:00:35.153]                 else {
[17:00:35.153]                   if (TRUE) {
[17:00:35.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.153]                     {
[17:00:35.153]                       inherits <- base::inherits
[17:00:35.153]                       invokeRestart <- base::invokeRestart
[17:00:35.153]                       is.null <- base::is.null
[17:00:35.153]                       muffled <- FALSE
[17:00:35.153]                       if (inherits(cond, "message")) {
[17:00:35.153]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.153]                         if (muffled) 
[17:00:35.153]                           invokeRestart("muffleMessage")
[17:00:35.153]                       }
[17:00:35.153]                       else if (inherits(cond, "warning")) {
[17:00:35.153]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.153]                         if (muffled) 
[17:00:35.153]                           invokeRestart("muffleWarning")
[17:00:35.153]                       }
[17:00:35.153]                       else if (inherits(cond, "condition")) {
[17:00:35.153]                         if (!is.null(pattern)) {
[17:00:35.153]                           computeRestarts <- base::computeRestarts
[17:00:35.153]                           grepl <- base::grepl
[17:00:35.153]                           restarts <- computeRestarts(cond)
[17:00:35.153]                           for (restart in restarts) {
[17:00:35.153]                             name <- restart$name
[17:00:35.153]                             if (is.null(name)) 
[17:00:35.153]                               next
[17:00:35.153]                             if (!grepl(pattern, name)) 
[17:00:35.153]                               next
[17:00:35.153]                             invokeRestart(restart)
[17:00:35.153]                             muffled <- TRUE
[17:00:35.153]                             break
[17:00:35.153]                           }
[17:00:35.153]                         }
[17:00:35.153]                       }
[17:00:35.153]                       invisible(muffled)
[17:00:35.153]                     }
[17:00:35.153]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.153]                   }
[17:00:35.153]                 }
[17:00:35.153]             }
[17:00:35.153]         }))
[17:00:35.153]     }, error = function(ex) {
[17:00:35.153]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:35.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.153]                 ...future.rng), started = ...future.startTime, 
[17:00:35.153]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:35.153]             version = "1.8"), class = "FutureResult")
[17:00:35.153]     }, finally = {
[17:00:35.153]         if (!identical(...future.workdir, getwd())) 
[17:00:35.153]             setwd(...future.workdir)
[17:00:35.153]         {
[17:00:35.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:35.153]                 ...future.oldOptions$nwarnings <- NULL
[17:00:35.153]             }
[17:00:35.153]             base::options(...future.oldOptions)
[17:00:35.153]             if (.Platform$OS.type == "windows") {
[17:00:35.153]                 old_names <- names(...future.oldEnvVars)
[17:00:35.153]                 envs <- base::Sys.getenv()
[17:00:35.153]                 names <- names(envs)
[17:00:35.153]                 common <- intersect(names, old_names)
[17:00:35.153]                 added <- setdiff(names, old_names)
[17:00:35.153]                 removed <- setdiff(old_names, names)
[17:00:35.153]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:35.153]                   envs[common]]
[17:00:35.153]                 NAMES <- toupper(changed)
[17:00:35.153]                 args <- list()
[17:00:35.153]                 for (kk in seq_along(NAMES)) {
[17:00:35.153]                   name <- changed[[kk]]
[17:00:35.153]                   NAME <- NAMES[[kk]]
[17:00:35.153]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.153]                     next
[17:00:35.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.153]                 }
[17:00:35.153]                 NAMES <- toupper(added)
[17:00:35.153]                 for (kk in seq_along(NAMES)) {
[17:00:35.153]                   name <- added[[kk]]
[17:00:35.153]                   NAME <- NAMES[[kk]]
[17:00:35.153]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.153]                     next
[17:00:35.153]                   args[[name]] <- ""
[17:00:35.153]                 }
[17:00:35.153]                 NAMES <- toupper(removed)
[17:00:35.153]                 for (kk in seq_along(NAMES)) {
[17:00:35.153]                   name <- removed[[kk]]
[17:00:35.153]                   NAME <- NAMES[[kk]]
[17:00:35.153]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.153]                     next
[17:00:35.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.153]                 }
[17:00:35.153]                 if (length(args) > 0) 
[17:00:35.153]                   base::do.call(base::Sys.setenv, args = args)
[17:00:35.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:35.153]             }
[17:00:35.153]             else {
[17:00:35.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:35.153]             }
[17:00:35.153]             {
[17:00:35.153]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:35.153]                   0L) {
[17:00:35.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:35.153]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:35.153]                   base::options(opts)
[17:00:35.153]                 }
[17:00:35.153]                 {
[17:00:35.153]                   {
[17:00:35.153]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:35.153]                     NULL
[17:00:35.153]                   }
[17:00:35.153]                   options(future.plan = NULL)
[17:00:35.153]                   if (is.na(NA_character_)) 
[17:00:35.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:35.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:35.153]                     .init = FALSE)
[17:00:35.153]                 }
[17:00:35.153]             }
[17:00:35.153]         }
[17:00:35.153]     })
[17:00:35.153]     if (TRUE) {
[17:00:35.153]         base::sink(type = "output", split = FALSE)
[17:00:35.153]         if (TRUE) {
[17:00:35.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:35.153]         }
[17:00:35.153]         else {
[17:00:35.153]             ...future.result["stdout"] <- base::list(NULL)
[17:00:35.153]         }
[17:00:35.153]         base::close(...future.stdout)
[17:00:35.153]         ...future.stdout <- NULL
[17:00:35.153]     }
[17:00:35.153]     ...future.result$conditions <- ...future.conditions
[17:00:35.153]     ...future.result$finished <- base::Sys.time()
[17:00:35.153]     ...future.result
[17:00:35.153] }
[17:00:35.155] Exporting 5 global objects (2.41 KiB) to cluster node #2 ...
[17:00:35.156] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ...
[17:00:35.156] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ... DONE
[17:00:35.156] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:35.156] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:35.157] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ...
[17:00:35.157] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ... DONE
[17:00:35.157] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:35.157] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:35.157] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:35.158] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:35.158] Exporting 5 global objects (2.41 KiB) to cluster node #2 ... DONE
[17:00:35.158] MultisessionFuture started
[17:00:35.158] - Launch lazy future ... done
[17:00:35.158] run() for ‘MultisessionFuture’ ... done
[17:00:35.159] Created future:
[17:00:35.159] MultisessionFuture:
[17:00:35.159] Label: ‘future_Map-2’
[17:00:35.159] Expression:
[17:00:35.159] {
[17:00:35.159]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.159]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:35.159]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.159]         on.exit(options(oopts), add = TRUE)
[17:00:35.159]     }
[17:00:35.159]     {
[17:00:35.159]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.159]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:35.159]         do.call(mapply, args = args)
[17:00:35.159]     }
[17:00:35.159] }
[17:00:35.159] Lazy evaluation: FALSE
[17:00:35.159] Asynchronous evaluation: TRUE
[17:00:35.159] Local evaluation: TRUE
[17:00:35.159] Environment: R_GlobalEnv
[17:00:35.159] Capture standard output: TRUE
[17:00:35.159] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:35.159] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:35.159] Packages: 1 packages (‘stats’)
[17:00:35.159] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:35.159] Resolved: FALSE
[17:00:35.159] Value: <not collected>
[17:00:35.159] Conditions captured: <none>
[17:00:35.159] Early signaling: FALSE
[17:00:35.159] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:35.159] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.170] Chunk #2 of 2 ... DONE
[17:00:35.171] Launching 2 futures (chunks) ... DONE
[17:00:35.171] Resolving 2 futures (chunks) ...
[17:00:35.171] resolve() on list ...
[17:00:35.171]  recursive: 0
[17:00:35.171]  length: 2
[17:00:35.171] 
[17:00:35.172] receiveMessageFromWorker() for ClusterFuture ...
[17:00:35.172] - Validating connection of MultisessionFuture
[17:00:35.172] - received message: FutureResult
[17:00:35.172] - Received FutureResult
[17:00:35.172] - Erased future from FutureRegistry
[17:00:35.172] result() for ClusterFuture ...
[17:00:35.172] - result already collected: FutureResult
[17:00:35.173] result() for ClusterFuture ... done
[17:00:35.173] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:35.173] Future #1
[17:00:35.173] result() for ClusterFuture ...
[17:00:35.173] - result already collected: FutureResult
[17:00:35.173] result() for ClusterFuture ... done
[17:00:35.173] result() for ClusterFuture ...
[17:00:35.173] - result already collected: FutureResult
[17:00:35.173] result() for ClusterFuture ... done
[17:00:35.173] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:35.173] - nx: 2
[17:00:35.174] - relay: TRUE
[17:00:35.174] - stdout: TRUE
[17:00:35.174] - signal: TRUE
[17:00:35.174] - resignal: FALSE
[17:00:35.174] - force: TRUE
[17:00:35.174] - relayed: [n=2] FALSE, FALSE
[17:00:35.174] - queued futures: [n=2] FALSE, FALSE
[17:00:35.174]  - until=1
[17:00:35.174]  - relaying element #1
[17:00:35.174] result() for ClusterFuture ...
[17:00:35.174] - result already collected: FutureResult
[17:00:35.174] result() for ClusterFuture ... done
[17:00:35.175] result() for ClusterFuture ...
[17:00:35.175] - result already collected: FutureResult
[17:00:35.175] result() for ClusterFuture ... done
[17:00:35.175] result() for ClusterFuture ...
[17:00:35.175] - result already collected: FutureResult
[17:00:35.175] result() for ClusterFuture ... done
[17:00:35.175] result() for ClusterFuture ...
[17:00:35.175] - result already collected: FutureResult
[17:00:35.175] result() for ClusterFuture ... done
[17:00:35.175] - relayed: [n=2] TRUE, FALSE
[17:00:35.175] - queued futures: [n=2] TRUE, FALSE
[17:00:35.176] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:35.176]  length: 1 (resolved future 1)
[17:00:35.201] receiveMessageFromWorker() for ClusterFuture ...
[17:00:35.201] - Validating connection of MultisessionFuture
[17:00:35.202] - received message: FutureResult
[17:00:35.202] - Received FutureResult
[17:00:35.202] - Erased future from FutureRegistry
[17:00:35.202] result() for ClusterFuture ...
[17:00:35.202] - result already collected: FutureResult
[17:00:35.202] result() for ClusterFuture ... done
[17:00:35.202] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:35.202] Future #2
[17:00:35.202] result() for ClusterFuture ...
[17:00:35.203] - result already collected: FutureResult
[17:00:35.203] result() for ClusterFuture ... done
[17:00:35.203] result() for ClusterFuture ...
[17:00:35.203] - result already collected: FutureResult
[17:00:35.203] result() for ClusterFuture ... done
[17:00:35.203] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:35.203] - nx: 2
[17:00:35.203] - relay: TRUE
[17:00:35.203] - stdout: TRUE
[17:00:35.203] - signal: TRUE
[17:00:35.203] - resignal: FALSE
[17:00:35.204] - force: TRUE
[17:00:35.204] - relayed: [n=2] TRUE, FALSE
[17:00:35.204] - queued futures: [n=2] TRUE, FALSE
[17:00:35.204]  - until=2
[17:00:35.204]  - relaying element #2
[17:00:35.204] result() for ClusterFuture ...
[17:00:35.204] - result already collected: FutureResult
[17:00:35.204] result() for ClusterFuture ... done
[17:00:35.204] result() for ClusterFuture ...
[17:00:35.204] - result already collected: FutureResult
[17:00:35.204] result() for ClusterFuture ... done
[17:00:35.205] result() for ClusterFuture ...
[17:00:35.205] - result already collected: FutureResult
[17:00:35.205] result() for ClusterFuture ... done
[17:00:35.205] result() for ClusterFuture ...
[17:00:35.205] - result already collected: FutureResult
[17:00:35.205] result() for ClusterFuture ... done
[17:00:35.205] - relayed: [n=2] TRUE, TRUE
[17:00:35.205] - queued futures: [n=2] TRUE, TRUE
[17:00:35.205] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:35.205]  length: 0 (resolved future 2)
[17:00:35.205] Relaying remaining futures
[17:00:35.206] signalConditionsASAP(NULL, pos=0) ...
[17:00:35.206] - nx: 2
[17:00:35.206] - relay: TRUE
[17:00:35.206] - stdout: TRUE
[17:00:35.206] - signal: TRUE
[17:00:35.206] - resignal: FALSE
[17:00:35.206] - force: TRUE
[17:00:35.206] - relayed: [n=2] TRUE, TRUE
[17:00:35.206] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:35.206] - relayed: [n=2] TRUE, TRUE
[17:00:35.206] - queued futures: [n=2] TRUE, TRUE
[17:00:35.207] signalConditionsASAP(NULL, pos=0) ... done
[17:00:35.207] resolve() on list ... DONE
[17:00:35.207] result() for ClusterFuture ...
[17:00:35.210] - result already collected: FutureResult
[17:00:35.210] result() for ClusterFuture ... done
[17:00:35.210] result() for ClusterFuture ...
[17:00:35.210] - result already collected: FutureResult
[17:00:35.210] result() for ClusterFuture ... done
[17:00:35.210] result() for ClusterFuture ...
[17:00:35.210] - result already collected: FutureResult
[17:00:35.210] result() for ClusterFuture ... done
[17:00:35.210] result() for ClusterFuture ...
[17:00:35.210] - result already collected: FutureResult
[17:00:35.211] result() for ClusterFuture ... done
[17:00:35.211]  - Number of value chunks collected: 2
[17:00:35.211] Resolving 2 futures (chunks) ... DONE
[17:00:35.211] Reducing values from 2 chunks ...
[17:00:35.211]  - Number of values collected after concatenation: 5
[17:00:35.211]  - Number of values expected: 5
[17:00:35.211] Reducing values from 2 chunks ... DONE
[17:00:35.211] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[17:00:35.213] future_mapply() ...
[17:00:35.217] Number of chunks: 2
[17:00:35.217] getGlobalsAndPackagesXApply() ...
[17:00:35.217]  - future.globals: TRUE
[17:00:35.217] getGlobalsAndPackages() ...
[17:00:35.217] Searching for globals...
[17:00:35.218] - globals found: [1] ‘FUN’
[17:00:35.218] Searching for globals ... DONE
[17:00:35.218] Resolving globals: FALSE
[17:00:35.219] The total size of the 1 globals is 56 bytes (56 bytes)
[17:00:35.219] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:00:35.219] - globals: [1] ‘FUN’
[17:00:35.219] 
[17:00:35.219] getGlobalsAndPackages() ... DONE
[17:00:35.220]  - globals found/used: [n=1] ‘FUN’
[17:00:35.220]  - needed namespaces: [n=0] 
[17:00:35.220] Finding globals ... DONE
[17:00:35.220] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:35.220] List of 2
[17:00:35.220]  $ ...future.FUN:function (e1, e2)  
[17:00:35.220]  $ MoreArgs     : NULL
[17:00:35.220]  - attr(*, "where")=List of 2
[17:00:35.220]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:35.220]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:35.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:35.220]  - attr(*, "resolved")= logi FALSE
[17:00:35.220]  - attr(*, "total_size")= num NA
[17:00:35.223] Packages to be attached in all futures: [n=0] 
[17:00:35.223] getGlobalsAndPackagesXApply() ... DONE
[17:00:35.223] Number of futures (= number of chunks): 2
[17:00:35.223] Launching 2 futures (chunks) ...
[17:00:35.223] Chunk #1 of 2 ...
[17:00:35.223]  - Finding globals in '...' for chunk #1 ...
[17:00:35.223] getGlobalsAndPackages() ...
[17:00:35.223] Searching for globals...
[17:00:35.224] 
[17:00:35.224] Searching for globals ... DONE
[17:00:35.224] - globals: [0] <none>
[17:00:35.224] getGlobalsAndPackages() ... DONE
[17:00:35.224]    + additional globals found: [n=0] 
[17:00:35.224]    + additional namespaces needed: [n=0] 
[17:00:35.224]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:35.224]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:35.224]  - seeds: <none>
[17:00:35.225]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.225] getGlobalsAndPackages() ...
[17:00:35.225] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.225] Resolving globals: FALSE
[17:00:35.225] The total size of the 5 globals is 168 bytes (168 bytes)
[17:00:35.226] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:35.226] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.226] 
[17:00:35.226] getGlobalsAndPackages() ... DONE
[17:00:35.226] run() for ‘Future’ ...
[17:00:35.226] - state: ‘created’
[17:00:35.227] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:35.241] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.241] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:35.241]   - Field: ‘node’
[17:00:35.241]   - Field: ‘label’
[17:00:35.241]   - Field: ‘local’
[17:00:35.241]   - Field: ‘owner’
[17:00:35.241]   - Field: ‘envir’
[17:00:35.241]   - Field: ‘workers’
[17:00:35.241]   - Field: ‘packages’
[17:00:35.242]   - Field: ‘gc’
[17:00:35.242]   - Field: ‘conditions’
[17:00:35.242]   - Field: ‘persistent’
[17:00:35.242]   - Field: ‘expr’
[17:00:35.242]   - Field: ‘uuid’
[17:00:35.242]   - Field: ‘seed’
[17:00:35.242]   - Field: ‘version’
[17:00:35.242]   - Field: ‘result’
[17:00:35.242]   - Field: ‘asynchronous’
[17:00:35.242]   - Field: ‘calls’
[17:00:35.242]   - Field: ‘globals’
[17:00:35.243]   - Field: ‘stdout’
[17:00:35.243]   - Field: ‘earlySignal’
[17:00:35.243]   - Field: ‘lazy’
[17:00:35.243]   - Field: ‘state’
[17:00:35.243] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:35.243] - Launch lazy future ...
[17:00:35.243] Packages needed by the future expression (n = 0): <none>
[17:00:35.243] Packages needed by future strategies (n = 0): <none>
[17:00:35.244] {
[17:00:35.244]     {
[17:00:35.244]         {
[17:00:35.244]             ...future.startTime <- base::Sys.time()
[17:00:35.244]             {
[17:00:35.244]                 {
[17:00:35.244]                   {
[17:00:35.244]                     {
[17:00:35.244]                       base::local({
[17:00:35.244]                         has_future <- base::requireNamespace("future", 
[17:00:35.244]                           quietly = TRUE)
[17:00:35.244]                         if (has_future) {
[17:00:35.244]                           ns <- base::getNamespace("future")
[17:00:35.244]                           version <- ns[[".package"]][["version"]]
[17:00:35.244]                           if (is.null(version)) 
[17:00:35.244]                             version <- utils::packageVersion("future")
[17:00:35.244]                         }
[17:00:35.244]                         else {
[17:00:35.244]                           version <- NULL
[17:00:35.244]                         }
[17:00:35.244]                         if (!has_future || version < "1.8.0") {
[17:00:35.244]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:35.244]                             "", base::R.version$version.string), 
[17:00:35.244]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:35.244]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:35.244]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:35.244]                               "release", "version")], collapse = " "), 
[17:00:35.244]                             hostname = base::Sys.info()[["nodename"]])
[17:00:35.244]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:35.244]                             info)
[17:00:35.244]                           info <- base::paste(info, collapse = "; ")
[17:00:35.244]                           if (!has_future) {
[17:00:35.244]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:35.244]                               info)
[17:00:35.244]                           }
[17:00:35.244]                           else {
[17:00:35.244]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:35.244]                               info, version)
[17:00:35.244]                           }
[17:00:35.244]                           base::stop(msg)
[17:00:35.244]                         }
[17:00:35.244]                       })
[17:00:35.244]                     }
[17:00:35.244]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:35.244]                     base::options(mc.cores = 1L)
[17:00:35.244]                   }
[17:00:35.244]                   ...future.strategy.old <- future::plan("list")
[17:00:35.244]                   options(future.plan = NULL)
[17:00:35.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:35.244]                 }
[17:00:35.244]                 ...future.workdir <- getwd()
[17:00:35.244]             }
[17:00:35.244]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:35.244]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:35.244]         }
[17:00:35.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:35.244]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:35.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:35.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:35.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:35.244]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:35.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:35.244]             base::names(...future.oldOptions))
[17:00:35.244]     }
[17:00:35.244]     if (FALSE) {
[17:00:35.244]     }
[17:00:35.244]     else {
[17:00:35.244]         if (TRUE) {
[17:00:35.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:35.244]                 open = "w")
[17:00:35.244]         }
[17:00:35.244]         else {
[17:00:35.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:35.244]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:35.244]         }
[17:00:35.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:35.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:35.244]             base::sink(type = "output", split = FALSE)
[17:00:35.244]             base::close(...future.stdout)
[17:00:35.244]         }, add = TRUE)
[17:00:35.244]     }
[17:00:35.244]     ...future.frame <- base::sys.nframe()
[17:00:35.244]     ...future.conditions <- base::list()
[17:00:35.244]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:35.244]     if (FALSE) {
[17:00:35.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:35.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:35.244]     }
[17:00:35.244]     ...future.result <- base::tryCatch({
[17:00:35.244]         base::withCallingHandlers({
[17:00:35.244]             ...future.value <- base::withVisible(base::local({
[17:00:35.244]                 ...future.makeSendCondition <- base::local({
[17:00:35.244]                   sendCondition <- NULL
[17:00:35.244]                   function(frame = 1L) {
[17:00:35.244]                     if (is.function(sendCondition)) 
[17:00:35.244]                       return(sendCondition)
[17:00:35.244]                     ns <- getNamespace("parallel")
[17:00:35.244]                     if (exists("sendData", mode = "function", 
[17:00:35.244]                       envir = ns)) {
[17:00:35.244]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:35.244]                         envir = ns)
[17:00:35.244]                       envir <- sys.frame(frame)
[17:00:35.244]                       master <- NULL
[17:00:35.244]                       while (!identical(envir, .GlobalEnv) && 
[17:00:35.244]                         !identical(envir, emptyenv())) {
[17:00:35.244]                         if (exists("master", mode = "list", envir = envir, 
[17:00:35.244]                           inherits = FALSE)) {
[17:00:35.244]                           master <- get("master", mode = "list", 
[17:00:35.244]                             envir = envir, inherits = FALSE)
[17:00:35.244]                           if (inherits(master, c("SOCKnode", 
[17:00:35.244]                             "SOCK0node"))) {
[17:00:35.244]                             sendCondition <<- function(cond) {
[17:00:35.244]                               data <- list(type = "VALUE", value = cond, 
[17:00:35.244]                                 success = TRUE)
[17:00:35.244]                               parallel_sendData(master, data)
[17:00:35.244]                             }
[17:00:35.244]                             return(sendCondition)
[17:00:35.244]                           }
[17:00:35.244]                         }
[17:00:35.244]                         frame <- frame + 1L
[17:00:35.244]                         envir <- sys.frame(frame)
[17:00:35.244]                       }
[17:00:35.244]                     }
[17:00:35.244]                     sendCondition <<- function(cond) NULL
[17:00:35.244]                   }
[17:00:35.244]                 })
[17:00:35.244]                 withCallingHandlers({
[17:00:35.244]                   {
[17:00:35.244]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.244]                     if (!identical(...future.globals.maxSize.org, 
[17:00:35.244]                       ...future.globals.maxSize)) {
[17:00:35.244]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.244]                       on.exit(options(oopts), add = TRUE)
[17:00:35.244]                     }
[17:00:35.244]                     {
[17:00:35.244]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.244]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:35.244]                         USE.NAMES = FALSE)
[17:00:35.244]                       do.call(mapply, args = args)
[17:00:35.244]                     }
[17:00:35.244]                   }
[17:00:35.244]                 }, immediateCondition = function(cond) {
[17:00:35.244]                   sendCondition <- ...future.makeSendCondition()
[17:00:35.244]                   sendCondition(cond)
[17:00:35.244]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.244]                   {
[17:00:35.244]                     inherits <- base::inherits
[17:00:35.244]                     invokeRestart <- base::invokeRestart
[17:00:35.244]                     is.null <- base::is.null
[17:00:35.244]                     muffled <- FALSE
[17:00:35.244]                     if (inherits(cond, "message")) {
[17:00:35.244]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:35.244]                       if (muffled) 
[17:00:35.244]                         invokeRestart("muffleMessage")
[17:00:35.244]                     }
[17:00:35.244]                     else if (inherits(cond, "warning")) {
[17:00:35.244]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:35.244]                       if (muffled) 
[17:00:35.244]                         invokeRestart("muffleWarning")
[17:00:35.244]                     }
[17:00:35.244]                     else if (inherits(cond, "condition")) {
[17:00:35.244]                       if (!is.null(pattern)) {
[17:00:35.244]                         computeRestarts <- base::computeRestarts
[17:00:35.244]                         grepl <- base::grepl
[17:00:35.244]                         restarts <- computeRestarts(cond)
[17:00:35.244]                         for (restart in restarts) {
[17:00:35.244]                           name <- restart$name
[17:00:35.244]                           if (is.null(name)) 
[17:00:35.244]                             next
[17:00:35.244]                           if (!grepl(pattern, name)) 
[17:00:35.244]                             next
[17:00:35.244]                           invokeRestart(restart)
[17:00:35.244]                           muffled <- TRUE
[17:00:35.244]                           break
[17:00:35.244]                         }
[17:00:35.244]                       }
[17:00:35.244]                     }
[17:00:35.244]                     invisible(muffled)
[17:00:35.244]                   }
[17:00:35.244]                   muffleCondition(cond)
[17:00:35.244]                 })
[17:00:35.244]             }))
[17:00:35.244]             future::FutureResult(value = ...future.value$value, 
[17:00:35.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.244]                   ...future.rng), globalenv = if (FALSE) 
[17:00:35.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:35.244]                     ...future.globalenv.names))
[17:00:35.244]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:35.244]         }, condition = base::local({
[17:00:35.244]             c <- base::c
[17:00:35.244]             inherits <- base::inherits
[17:00:35.244]             invokeRestart <- base::invokeRestart
[17:00:35.244]             length <- base::length
[17:00:35.244]             list <- base::list
[17:00:35.244]             seq.int <- base::seq.int
[17:00:35.244]             signalCondition <- base::signalCondition
[17:00:35.244]             sys.calls <- base::sys.calls
[17:00:35.244]             `[[` <- base::`[[`
[17:00:35.244]             `+` <- base::`+`
[17:00:35.244]             `<<-` <- base::`<<-`
[17:00:35.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:35.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:35.244]                   3L)]
[17:00:35.244]             }
[17:00:35.244]             function(cond) {
[17:00:35.244]                 is_error <- inherits(cond, "error")
[17:00:35.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:35.244]                   NULL)
[17:00:35.244]                 if (is_error) {
[17:00:35.244]                   sessionInformation <- function() {
[17:00:35.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:35.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:35.244]                       search = base::search(), system = base::Sys.info())
[17:00:35.244]                   }
[17:00:35.244]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:35.244]                     cond$call), session = sessionInformation(), 
[17:00:35.244]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:35.244]                   signalCondition(cond)
[17:00:35.244]                 }
[17:00:35.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:35.244]                 "immediateCondition"))) {
[17:00:35.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:35.244]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:35.244]                   if (TRUE && !signal) {
[17:00:35.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.244]                     {
[17:00:35.244]                       inherits <- base::inherits
[17:00:35.244]                       invokeRestart <- base::invokeRestart
[17:00:35.244]                       is.null <- base::is.null
[17:00:35.244]                       muffled <- FALSE
[17:00:35.244]                       if (inherits(cond, "message")) {
[17:00:35.244]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.244]                         if (muffled) 
[17:00:35.244]                           invokeRestart("muffleMessage")
[17:00:35.244]                       }
[17:00:35.244]                       else if (inherits(cond, "warning")) {
[17:00:35.244]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.244]                         if (muffled) 
[17:00:35.244]                           invokeRestart("muffleWarning")
[17:00:35.244]                       }
[17:00:35.244]                       else if (inherits(cond, "condition")) {
[17:00:35.244]                         if (!is.null(pattern)) {
[17:00:35.244]                           computeRestarts <- base::computeRestarts
[17:00:35.244]                           grepl <- base::grepl
[17:00:35.244]                           restarts <- computeRestarts(cond)
[17:00:35.244]                           for (restart in restarts) {
[17:00:35.244]                             name <- restart$name
[17:00:35.244]                             if (is.null(name)) 
[17:00:35.244]                               next
[17:00:35.244]                             if (!grepl(pattern, name)) 
[17:00:35.244]                               next
[17:00:35.244]                             invokeRestart(restart)
[17:00:35.244]                             muffled <- TRUE
[17:00:35.244]                             break
[17:00:35.244]                           }
[17:00:35.244]                         }
[17:00:35.244]                       }
[17:00:35.244]                       invisible(muffled)
[17:00:35.244]                     }
[17:00:35.244]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.244]                   }
[17:00:35.244]                 }
[17:00:35.244]                 else {
[17:00:35.244]                   if (TRUE) {
[17:00:35.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.244]                     {
[17:00:35.244]                       inherits <- base::inherits
[17:00:35.244]                       invokeRestart <- base::invokeRestart
[17:00:35.244]                       is.null <- base::is.null
[17:00:35.244]                       muffled <- FALSE
[17:00:35.244]                       if (inherits(cond, "message")) {
[17:00:35.244]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.244]                         if (muffled) 
[17:00:35.244]                           invokeRestart("muffleMessage")
[17:00:35.244]                       }
[17:00:35.244]                       else if (inherits(cond, "warning")) {
[17:00:35.244]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.244]                         if (muffled) 
[17:00:35.244]                           invokeRestart("muffleWarning")
[17:00:35.244]                       }
[17:00:35.244]                       else if (inherits(cond, "condition")) {
[17:00:35.244]                         if (!is.null(pattern)) {
[17:00:35.244]                           computeRestarts <- base::computeRestarts
[17:00:35.244]                           grepl <- base::grepl
[17:00:35.244]                           restarts <- computeRestarts(cond)
[17:00:35.244]                           for (restart in restarts) {
[17:00:35.244]                             name <- restart$name
[17:00:35.244]                             if (is.null(name)) 
[17:00:35.244]                               next
[17:00:35.244]                             if (!grepl(pattern, name)) 
[17:00:35.244]                               next
[17:00:35.244]                             invokeRestart(restart)
[17:00:35.244]                             muffled <- TRUE
[17:00:35.244]                             break
[17:00:35.244]                           }
[17:00:35.244]                         }
[17:00:35.244]                       }
[17:00:35.244]                       invisible(muffled)
[17:00:35.244]                     }
[17:00:35.244]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.244]                   }
[17:00:35.244]                 }
[17:00:35.244]             }
[17:00:35.244]         }))
[17:00:35.244]     }, error = function(ex) {
[17:00:35.244]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:35.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.244]                 ...future.rng), started = ...future.startTime, 
[17:00:35.244]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:35.244]             version = "1.8"), class = "FutureResult")
[17:00:35.244]     }, finally = {
[17:00:35.244]         if (!identical(...future.workdir, getwd())) 
[17:00:35.244]             setwd(...future.workdir)
[17:00:35.244]         {
[17:00:35.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:35.244]                 ...future.oldOptions$nwarnings <- NULL
[17:00:35.244]             }
[17:00:35.244]             base::options(...future.oldOptions)
[17:00:35.244]             if (.Platform$OS.type == "windows") {
[17:00:35.244]                 old_names <- names(...future.oldEnvVars)
[17:00:35.244]                 envs <- base::Sys.getenv()
[17:00:35.244]                 names <- names(envs)
[17:00:35.244]                 common <- intersect(names, old_names)
[17:00:35.244]                 added <- setdiff(names, old_names)
[17:00:35.244]                 removed <- setdiff(old_names, names)
[17:00:35.244]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:35.244]                   envs[common]]
[17:00:35.244]                 NAMES <- toupper(changed)
[17:00:35.244]                 args <- list()
[17:00:35.244]                 for (kk in seq_along(NAMES)) {
[17:00:35.244]                   name <- changed[[kk]]
[17:00:35.244]                   NAME <- NAMES[[kk]]
[17:00:35.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.244]                     next
[17:00:35.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.244]                 }
[17:00:35.244]                 NAMES <- toupper(added)
[17:00:35.244]                 for (kk in seq_along(NAMES)) {
[17:00:35.244]                   name <- added[[kk]]
[17:00:35.244]                   NAME <- NAMES[[kk]]
[17:00:35.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.244]                     next
[17:00:35.244]                   args[[name]] <- ""
[17:00:35.244]                 }
[17:00:35.244]                 NAMES <- toupper(removed)
[17:00:35.244]                 for (kk in seq_along(NAMES)) {
[17:00:35.244]                   name <- removed[[kk]]
[17:00:35.244]                   NAME <- NAMES[[kk]]
[17:00:35.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.244]                     next
[17:00:35.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.244]                 }
[17:00:35.244]                 if (length(args) > 0) 
[17:00:35.244]                   base::do.call(base::Sys.setenv, args = args)
[17:00:35.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:35.244]             }
[17:00:35.244]             else {
[17:00:35.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:35.244]             }
[17:00:35.244]             {
[17:00:35.244]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:35.244]                   0L) {
[17:00:35.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:35.244]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:35.244]                   base::options(opts)
[17:00:35.244]                 }
[17:00:35.244]                 {
[17:00:35.244]                   {
[17:00:35.244]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:35.244]                     NULL
[17:00:35.244]                   }
[17:00:35.244]                   options(future.plan = NULL)
[17:00:35.244]                   if (is.na(NA_character_)) 
[17:00:35.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:35.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:35.244]                     .init = FALSE)
[17:00:35.244]                 }
[17:00:35.244]             }
[17:00:35.244]         }
[17:00:35.244]     })
[17:00:35.244]     if (TRUE) {
[17:00:35.244]         base::sink(type = "output", split = FALSE)
[17:00:35.244]         if (TRUE) {
[17:00:35.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:35.244]         }
[17:00:35.244]         else {
[17:00:35.244]             ...future.result["stdout"] <- base::list(NULL)
[17:00:35.244]         }
[17:00:35.244]         base::close(...future.stdout)
[17:00:35.244]         ...future.stdout <- NULL
[17:00:35.244]     }
[17:00:35.244]     ...future.result$conditions <- ...future.conditions
[17:00:35.244]     ...future.result$finished <- base::Sys.time()
[17:00:35.244]     ...future.result
[17:00:35.244] }
[17:00:35.247] Exporting 5 global objects (168 bytes) to cluster node #1 ...
[17:00:35.247] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:00:35.247] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:00:35.248] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:35.248] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:35.248] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:00:35.248] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:00:35.249] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:35.249] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:35.249] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:35.249] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:35.250] Exporting 5 global objects (168 bytes) to cluster node #1 ... DONE
[17:00:35.250] MultisessionFuture started
[17:00:35.250] - Launch lazy future ... done
[17:00:35.250] run() for ‘MultisessionFuture’ ... done
[17:00:35.251] Created future:
[17:00:35.251] MultisessionFuture:
[17:00:35.251] Label: ‘future_Map-1’
[17:00:35.251] Expression:
[17:00:35.251] {
[17:00:35.251]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.251]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:35.251]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.251]         on.exit(options(oopts), add = TRUE)
[17:00:35.251]     }
[17:00:35.251]     {
[17:00:35.251]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.251]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:35.251]         do.call(mapply, args = args)
[17:00:35.251]     }
[17:00:35.251] }
[17:00:35.251] Lazy evaluation: FALSE
[17:00:35.251] Asynchronous evaluation: TRUE
[17:00:35.251] Local evaluation: TRUE
[17:00:35.251] Environment: R_GlobalEnv
[17:00:35.251] Capture standard output: TRUE
[17:00:35.251] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:35.251] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:35.251] Packages: <none>
[17:00:35.251] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:35.251] Resolved: FALSE
[17:00:35.251] Value: <not collected>
[17:00:35.251] Conditions captured: <none>
[17:00:35.251] Early signaling: FALSE
[17:00:35.251] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:35.251] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.262] Chunk #1 of 2 ... DONE
[17:00:35.262] Chunk #2 of 2 ...
[17:00:35.262]  - Finding globals in '...' for chunk #2 ...
[17:00:35.263] getGlobalsAndPackages() ...
[17:00:35.263] Searching for globals...
[17:00:35.263] 
[17:00:35.263] Searching for globals ... DONE
[17:00:35.263] - globals: [0] <none>
[17:00:35.263] getGlobalsAndPackages() ... DONE
[17:00:35.264]    + additional globals found: [n=0] 
[17:00:35.264]    + additional namespaces needed: [n=0] 
[17:00:35.264]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:35.264]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:35.264]  - seeds: <none>
[17:00:35.264]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.264] getGlobalsAndPackages() ...
[17:00:35.264] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.264] Resolving globals: FALSE
[17:00:35.265] The total size of the 5 globals is 280 bytes (280 bytes)
[17:00:35.265] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:35.265] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.265] 
[17:00:35.266] getGlobalsAndPackages() ... DONE
[17:00:35.266] run() for ‘Future’ ...
[17:00:35.266] - state: ‘created’
[17:00:35.266] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:35.280] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:35.281]   - Field: ‘node’
[17:00:35.281]   - Field: ‘label’
[17:00:35.281]   - Field: ‘local’
[17:00:35.281]   - Field: ‘owner’
[17:00:35.281]   - Field: ‘envir’
[17:00:35.281]   - Field: ‘workers’
[17:00:35.281]   - Field: ‘packages’
[17:00:35.281]   - Field: ‘gc’
[17:00:35.282]   - Field: ‘conditions’
[17:00:35.282]   - Field: ‘persistent’
[17:00:35.282]   - Field: ‘expr’
[17:00:35.282]   - Field: ‘uuid’
[17:00:35.282]   - Field: ‘seed’
[17:00:35.282]   - Field: ‘version’
[17:00:35.282]   - Field: ‘result’
[17:00:35.282]   - Field: ‘asynchronous’
[17:00:35.282]   - Field: ‘calls’
[17:00:35.282]   - Field: ‘globals’
[17:00:35.282]   - Field: ‘stdout’
[17:00:35.283]   - Field: ‘earlySignal’
[17:00:35.283]   - Field: ‘lazy’
[17:00:35.283]   - Field: ‘state’
[17:00:35.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:35.283] - Launch lazy future ...
[17:00:35.283] Packages needed by the future expression (n = 0): <none>
[17:00:35.283] Packages needed by future strategies (n = 0): <none>
[17:00:35.284] {
[17:00:35.284]     {
[17:00:35.284]         {
[17:00:35.284]             ...future.startTime <- base::Sys.time()
[17:00:35.284]             {
[17:00:35.284]                 {
[17:00:35.284]                   {
[17:00:35.284]                     {
[17:00:35.284]                       base::local({
[17:00:35.284]                         has_future <- base::requireNamespace("future", 
[17:00:35.284]                           quietly = TRUE)
[17:00:35.284]                         if (has_future) {
[17:00:35.284]                           ns <- base::getNamespace("future")
[17:00:35.284]                           version <- ns[[".package"]][["version"]]
[17:00:35.284]                           if (is.null(version)) 
[17:00:35.284]                             version <- utils::packageVersion("future")
[17:00:35.284]                         }
[17:00:35.284]                         else {
[17:00:35.284]                           version <- NULL
[17:00:35.284]                         }
[17:00:35.284]                         if (!has_future || version < "1.8.0") {
[17:00:35.284]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:35.284]                             "", base::R.version$version.string), 
[17:00:35.284]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:35.284]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:35.284]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:35.284]                               "release", "version")], collapse = " "), 
[17:00:35.284]                             hostname = base::Sys.info()[["nodename"]])
[17:00:35.284]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:35.284]                             info)
[17:00:35.284]                           info <- base::paste(info, collapse = "; ")
[17:00:35.284]                           if (!has_future) {
[17:00:35.284]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:35.284]                               info)
[17:00:35.284]                           }
[17:00:35.284]                           else {
[17:00:35.284]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:35.284]                               info, version)
[17:00:35.284]                           }
[17:00:35.284]                           base::stop(msg)
[17:00:35.284]                         }
[17:00:35.284]                       })
[17:00:35.284]                     }
[17:00:35.284]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:35.284]                     base::options(mc.cores = 1L)
[17:00:35.284]                   }
[17:00:35.284]                   ...future.strategy.old <- future::plan("list")
[17:00:35.284]                   options(future.plan = NULL)
[17:00:35.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:35.284]                 }
[17:00:35.284]                 ...future.workdir <- getwd()
[17:00:35.284]             }
[17:00:35.284]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:35.284]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:35.284]         }
[17:00:35.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:35.284]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:35.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:35.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:35.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:35.284]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:35.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:35.284]             base::names(...future.oldOptions))
[17:00:35.284]     }
[17:00:35.284]     if (FALSE) {
[17:00:35.284]     }
[17:00:35.284]     else {
[17:00:35.284]         if (TRUE) {
[17:00:35.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:35.284]                 open = "w")
[17:00:35.284]         }
[17:00:35.284]         else {
[17:00:35.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:35.284]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:35.284]         }
[17:00:35.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:35.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:35.284]             base::sink(type = "output", split = FALSE)
[17:00:35.284]             base::close(...future.stdout)
[17:00:35.284]         }, add = TRUE)
[17:00:35.284]     }
[17:00:35.284]     ...future.frame <- base::sys.nframe()
[17:00:35.284]     ...future.conditions <- base::list()
[17:00:35.284]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:35.284]     if (FALSE) {
[17:00:35.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:35.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:35.284]     }
[17:00:35.284]     ...future.result <- base::tryCatch({
[17:00:35.284]         base::withCallingHandlers({
[17:00:35.284]             ...future.value <- base::withVisible(base::local({
[17:00:35.284]                 ...future.makeSendCondition <- base::local({
[17:00:35.284]                   sendCondition <- NULL
[17:00:35.284]                   function(frame = 1L) {
[17:00:35.284]                     if (is.function(sendCondition)) 
[17:00:35.284]                       return(sendCondition)
[17:00:35.284]                     ns <- getNamespace("parallel")
[17:00:35.284]                     if (exists("sendData", mode = "function", 
[17:00:35.284]                       envir = ns)) {
[17:00:35.284]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:35.284]                         envir = ns)
[17:00:35.284]                       envir <- sys.frame(frame)
[17:00:35.284]                       master <- NULL
[17:00:35.284]                       while (!identical(envir, .GlobalEnv) && 
[17:00:35.284]                         !identical(envir, emptyenv())) {
[17:00:35.284]                         if (exists("master", mode = "list", envir = envir, 
[17:00:35.284]                           inherits = FALSE)) {
[17:00:35.284]                           master <- get("master", mode = "list", 
[17:00:35.284]                             envir = envir, inherits = FALSE)
[17:00:35.284]                           if (inherits(master, c("SOCKnode", 
[17:00:35.284]                             "SOCK0node"))) {
[17:00:35.284]                             sendCondition <<- function(cond) {
[17:00:35.284]                               data <- list(type = "VALUE", value = cond, 
[17:00:35.284]                                 success = TRUE)
[17:00:35.284]                               parallel_sendData(master, data)
[17:00:35.284]                             }
[17:00:35.284]                             return(sendCondition)
[17:00:35.284]                           }
[17:00:35.284]                         }
[17:00:35.284]                         frame <- frame + 1L
[17:00:35.284]                         envir <- sys.frame(frame)
[17:00:35.284]                       }
[17:00:35.284]                     }
[17:00:35.284]                     sendCondition <<- function(cond) NULL
[17:00:35.284]                   }
[17:00:35.284]                 })
[17:00:35.284]                 withCallingHandlers({
[17:00:35.284]                   {
[17:00:35.284]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.284]                     if (!identical(...future.globals.maxSize.org, 
[17:00:35.284]                       ...future.globals.maxSize)) {
[17:00:35.284]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.284]                       on.exit(options(oopts), add = TRUE)
[17:00:35.284]                     }
[17:00:35.284]                     {
[17:00:35.284]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.284]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:35.284]                         USE.NAMES = FALSE)
[17:00:35.284]                       do.call(mapply, args = args)
[17:00:35.284]                     }
[17:00:35.284]                   }
[17:00:35.284]                 }, immediateCondition = function(cond) {
[17:00:35.284]                   sendCondition <- ...future.makeSendCondition()
[17:00:35.284]                   sendCondition(cond)
[17:00:35.284]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.284]                   {
[17:00:35.284]                     inherits <- base::inherits
[17:00:35.284]                     invokeRestart <- base::invokeRestart
[17:00:35.284]                     is.null <- base::is.null
[17:00:35.284]                     muffled <- FALSE
[17:00:35.284]                     if (inherits(cond, "message")) {
[17:00:35.284]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:35.284]                       if (muffled) 
[17:00:35.284]                         invokeRestart("muffleMessage")
[17:00:35.284]                     }
[17:00:35.284]                     else if (inherits(cond, "warning")) {
[17:00:35.284]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:35.284]                       if (muffled) 
[17:00:35.284]                         invokeRestart("muffleWarning")
[17:00:35.284]                     }
[17:00:35.284]                     else if (inherits(cond, "condition")) {
[17:00:35.284]                       if (!is.null(pattern)) {
[17:00:35.284]                         computeRestarts <- base::computeRestarts
[17:00:35.284]                         grepl <- base::grepl
[17:00:35.284]                         restarts <- computeRestarts(cond)
[17:00:35.284]                         for (restart in restarts) {
[17:00:35.284]                           name <- restart$name
[17:00:35.284]                           if (is.null(name)) 
[17:00:35.284]                             next
[17:00:35.284]                           if (!grepl(pattern, name)) 
[17:00:35.284]                             next
[17:00:35.284]                           invokeRestart(restart)
[17:00:35.284]                           muffled <- TRUE
[17:00:35.284]                           break
[17:00:35.284]                         }
[17:00:35.284]                       }
[17:00:35.284]                     }
[17:00:35.284]                     invisible(muffled)
[17:00:35.284]                   }
[17:00:35.284]                   muffleCondition(cond)
[17:00:35.284]                 })
[17:00:35.284]             }))
[17:00:35.284]             future::FutureResult(value = ...future.value$value, 
[17:00:35.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.284]                   ...future.rng), globalenv = if (FALSE) 
[17:00:35.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:35.284]                     ...future.globalenv.names))
[17:00:35.284]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:35.284]         }, condition = base::local({
[17:00:35.284]             c <- base::c
[17:00:35.284]             inherits <- base::inherits
[17:00:35.284]             invokeRestart <- base::invokeRestart
[17:00:35.284]             length <- base::length
[17:00:35.284]             list <- base::list
[17:00:35.284]             seq.int <- base::seq.int
[17:00:35.284]             signalCondition <- base::signalCondition
[17:00:35.284]             sys.calls <- base::sys.calls
[17:00:35.284]             `[[` <- base::`[[`
[17:00:35.284]             `+` <- base::`+`
[17:00:35.284]             `<<-` <- base::`<<-`
[17:00:35.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:35.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:35.284]                   3L)]
[17:00:35.284]             }
[17:00:35.284]             function(cond) {
[17:00:35.284]                 is_error <- inherits(cond, "error")
[17:00:35.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:35.284]                   NULL)
[17:00:35.284]                 if (is_error) {
[17:00:35.284]                   sessionInformation <- function() {
[17:00:35.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:35.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:35.284]                       search = base::search(), system = base::Sys.info())
[17:00:35.284]                   }
[17:00:35.284]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:35.284]                     cond$call), session = sessionInformation(), 
[17:00:35.284]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:35.284]                   signalCondition(cond)
[17:00:35.284]                 }
[17:00:35.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:35.284]                 "immediateCondition"))) {
[17:00:35.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:35.284]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:35.284]                   if (TRUE && !signal) {
[17:00:35.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.284]                     {
[17:00:35.284]                       inherits <- base::inherits
[17:00:35.284]                       invokeRestart <- base::invokeRestart
[17:00:35.284]                       is.null <- base::is.null
[17:00:35.284]                       muffled <- FALSE
[17:00:35.284]                       if (inherits(cond, "message")) {
[17:00:35.284]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.284]                         if (muffled) 
[17:00:35.284]                           invokeRestart("muffleMessage")
[17:00:35.284]                       }
[17:00:35.284]                       else if (inherits(cond, "warning")) {
[17:00:35.284]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.284]                         if (muffled) 
[17:00:35.284]                           invokeRestart("muffleWarning")
[17:00:35.284]                       }
[17:00:35.284]                       else if (inherits(cond, "condition")) {
[17:00:35.284]                         if (!is.null(pattern)) {
[17:00:35.284]                           computeRestarts <- base::computeRestarts
[17:00:35.284]                           grepl <- base::grepl
[17:00:35.284]                           restarts <- computeRestarts(cond)
[17:00:35.284]                           for (restart in restarts) {
[17:00:35.284]                             name <- restart$name
[17:00:35.284]                             if (is.null(name)) 
[17:00:35.284]                               next
[17:00:35.284]                             if (!grepl(pattern, name)) 
[17:00:35.284]                               next
[17:00:35.284]                             invokeRestart(restart)
[17:00:35.284]                             muffled <- TRUE
[17:00:35.284]                             break
[17:00:35.284]                           }
[17:00:35.284]                         }
[17:00:35.284]                       }
[17:00:35.284]                       invisible(muffled)
[17:00:35.284]                     }
[17:00:35.284]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.284]                   }
[17:00:35.284]                 }
[17:00:35.284]                 else {
[17:00:35.284]                   if (TRUE) {
[17:00:35.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.284]                     {
[17:00:35.284]                       inherits <- base::inherits
[17:00:35.284]                       invokeRestart <- base::invokeRestart
[17:00:35.284]                       is.null <- base::is.null
[17:00:35.284]                       muffled <- FALSE
[17:00:35.284]                       if (inherits(cond, "message")) {
[17:00:35.284]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.284]                         if (muffled) 
[17:00:35.284]                           invokeRestart("muffleMessage")
[17:00:35.284]                       }
[17:00:35.284]                       else if (inherits(cond, "warning")) {
[17:00:35.284]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.284]                         if (muffled) 
[17:00:35.284]                           invokeRestart("muffleWarning")
[17:00:35.284]                       }
[17:00:35.284]                       else if (inherits(cond, "condition")) {
[17:00:35.284]                         if (!is.null(pattern)) {
[17:00:35.284]                           computeRestarts <- base::computeRestarts
[17:00:35.284]                           grepl <- base::grepl
[17:00:35.284]                           restarts <- computeRestarts(cond)
[17:00:35.284]                           for (restart in restarts) {
[17:00:35.284]                             name <- restart$name
[17:00:35.284]                             if (is.null(name)) 
[17:00:35.284]                               next
[17:00:35.284]                             if (!grepl(pattern, name)) 
[17:00:35.284]                               next
[17:00:35.284]                             invokeRestart(restart)
[17:00:35.284]                             muffled <- TRUE
[17:00:35.284]                             break
[17:00:35.284]                           }
[17:00:35.284]                         }
[17:00:35.284]                       }
[17:00:35.284]                       invisible(muffled)
[17:00:35.284]                     }
[17:00:35.284]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.284]                   }
[17:00:35.284]                 }
[17:00:35.284]             }
[17:00:35.284]         }))
[17:00:35.284]     }, error = function(ex) {
[17:00:35.284]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:35.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.284]                 ...future.rng), started = ...future.startTime, 
[17:00:35.284]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:35.284]             version = "1.8"), class = "FutureResult")
[17:00:35.284]     }, finally = {
[17:00:35.284]         if (!identical(...future.workdir, getwd())) 
[17:00:35.284]             setwd(...future.workdir)
[17:00:35.284]         {
[17:00:35.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:35.284]                 ...future.oldOptions$nwarnings <- NULL
[17:00:35.284]             }
[17:00:35.284]             base::options(...future.oldOptions)
[17:00:35.284]             if (.Platform$OS.type == "windows") {
[17:00:35.284]                 old_names <- names(...future.oldEnvVars)
[17:00:35.284]                 envs <- base::Sys.getenv()
[17:00:35.284]                 names <- names(envs)
[17:00:35.284]                 common <- intersect(names, old_names)
[17:00:35.284]                 added <- setdiff(names, old_names)
[17:00:35.284]                 removed <- setdiff(old_names, names)
[17:00:35.284]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:35.284]                   envs[common]]
[17:00:35.284]                 NAMES <- toupper(changed)
[17:00:35.284]                 args <- list()
[17:00:35.284]                 for (kk in seq_along(NAMES)) {
[17:00:35.284]                   name <- changed[[kk]]
[17:00:35.284]                   NAME <- NAMES[[kk]]
[17:00:35.284]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.284]                     next
[17:00:35.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.284]                 }
[17:00:35.284]                 NAMES <- toupper(added)
[17:00:35.284]                 for (kk in seq_along(NAMES)) {
[17:00:35.284]                   name <- added[[kk]]
[17:00:35.284]                   NAME <- NAMES[[kk]]
[17:00:35.284]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.284]                     next
[17:00:35.284]                   args[[name]] <- ""
[17:00:35.284]                 }
[17:00:35.284]                 NAMES <- toupper(removed)
[17:00:35.284]                 for (kk in seq_along(NAMES)) {
[17:00:35.284]                   name <- removed[[kk]]
[17:00:35.284]                   NAME <- NAMES[[kk]]
[17:00:35.284]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.284]                     next
[17:00:35.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.284]                 }
[17:00:35.284]                 if (length(args) > 0) 
[17:00:35.284]                   base::do.call(base::Sys.setenv, args = args)
[17:00:35.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:35.284]             }
[17:00:35.284]             else {
[17:00:35.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:35.284]             }
[17:00:35.284]             {
[17:00:35.284]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:35.284]                   0L) {
[17:00:35.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:35.284]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:35.284]                   base::options(opts)
[17:00:35.284]                 }
[17:00:35.284]                 {
[17:00:35.284]                   {
[17:00:35.284]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:35.284]                     NULL
[17:00:35.284]                   }
[17:00:35.284]                   options(future.plan = NULL)
[17:00:35.284]                   if (is.na(NA_character_)) 
[17:00:35.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:35.284]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:35.284]                     .init = FALSE)
[17:00:35.284]                 }
[17:00:35.284]             }
[17:00:35.284]         }
[17:00:35.284]     })
[17:00:35.284]     if (TRUE) {
[17:00:35.284]         base::sink(type = "output", split = FALSE)
[17:00:35.284]         if (TRUE) {
[17:00:35.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:35.284]         }
[17:00:35.284]         else {
[17:00:35.284]             ...future.result["stdout"] <- base::list(NULL)
[17:00:35.284]         }
[17:00:35.284]         base::close(...future.stdout)
[17:00:35.284]         ...future.stdout <- NULL
[17:00:35.284]     }
[17:00:35.284]     ...future.result$conditions <- ...future.conditions
[17:00:35.284]     ...future.result$finished <- base::Sys.time()
[17:00:35.284]     ...future.result
[17:00:35.284] }
[17:00:35.287] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:00:35.287] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:00:35.287] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:00:35.287] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:35.288] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:35.288] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:00:35.288] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:00:35.288] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:35.289] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:35.289] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:35.289] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:35.289] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:00:35.289] MultisessionFuture started
[17:00:35.290] - Launch lazy future ... done
[17:00:35.290] run() for ‘MultisessionFuture’ ... done
[17:00:35.290] Created future:
[17:00:35.290] MultisessionFuture:
[17:00:35.290] Label: ‘future_Map-2’
[17:00:35.290] Expression:
[17:00:35.290] {
[17:00:35.290]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.290]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:35.290]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.290]         on.exit(options(oopts), add = TRUE)
[17:00:35.290]     }
[17:00:35.290]     {
[17:00:35.290]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.290]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:35.290]         do.call(mapply, args = args)
[17:00:35.290]     }
[17:00:35.290] }
[17:00:35.290] Lazy evaluation: FALSE
[17:00:35.290] Asynchronous evaluation: TRUE
[17:00:35.290] Local evaluation: TRUE
[17:00:35.290] Environment: R_GlobalEnv
[17:00:35.290] Capture standard output: TRUE
[17:00:35.290] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:35.290] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:35.290] Packages: <none>
[17:00:35.290] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:35.290] Resolved: FALSE
[17:00:35.290] Value: <not collected>
[17:00:35.290] Conditions captured: <none>
[17:00:35.290] Early signaling: FALSE
[17:00:35.290] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:35.290] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.301] Chunk #2 of 2 ... DONE
[17:00:35.302] Launching 2 futures (chunks) ... DONE
[17:00:35.302] Resolving 2 futures (chunks) ...
[17:00:35.302] resolve() on list ...
[17:00:35.302]  recursive: 0
[17:00:35.302]  length: 2
[17:00:35.302] 
[17:00:35.303] receiveMessageFromWorker() for ClusterFuture ...
[17:00:35.303] - Validating connection of MultisessionFuture
[17:00:35.303] - received message: FutureResult
[17:00:35.303] - Received FutureResult
[17:00:35.303] - Erased future from FutureRegistry
[17:00:35.303] result() for ClusterFuture ...
[17:00:35.303] - result already collected: FutureResult
[17:00:35.303] result() for ClusterFuture ... done
[17:00:35.304] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:35.304] Future #1
[17:00:35.304] result() for ClusterFuture ...
[17:00:35.304] - result already collected: FutureResult
[17:00:35.304] result() for ClusterFuture ... done
[17:00:35.304] result() for ClusterFuture ...
[17:00:35.304] - result already collected: FutureResult
[17:00:35.304] result() for ClusterFuture ... done
[17:00:35.304] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:35.304] - nx: 2
[17:00:35.304] - relay: TRUE
[17:00:35.304] - stdout: TRUE
[17:00:35.305] - signal: TRUE
[17:00:35.305] - resignal: FALSE
[17:00:35.305] - force: TRUE
[17:00:35.305] - relayed: [n=2] FALSE, FALSE
[17:00:35.305] - queued futures: [n=2] FALSE, FALSE
[17:00:35.305]  - until=1
[17:00:35.305]  - relaying element #1
[17:00:35.305] result() for ClusterFuture ...
[17:00:35.305] - result already collected: FutureResult
[17:00:35.305] result() for ClusterFuture ... done
[17:00:35.305] result() for ClusterFuture ...
[17:00:35.305] - result already collected: FutureResult
[17:00:35.306] result() for ClusterFuture ... done
[17:00:35.306] result() for ClusterFuture ...
[17:00:35.306] - result already collected: FutureResult
[17:00:35.306] result() for ClusterFuture ... done
[17:00:35.306] result() for ClusterFuture ...
[17:00:35.306] - result already collected: FutureResult
[17:00:35.306] result() for ClusterFuture ... done
[17:00:35.306] - relayed: [n=2] TRUE, FALSE
[17:00:35.306] - queued futures: [n=2] TRUE, FALSE
[17:00:35.306] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:35.307]  length: 1 (resolved future 1)
[17:00:35.333] receiveMessageFromWorker() for ClusterFuture ...
[17:00:35.333] - Validating connection of MultisessionFuture
[17:00:35.333] - received message: FutureResult
[17:00:35.334] - Received FutureResult
[17:00:35.334] - Erased future from FutureRegistry
[17:00:35.334] result() for ClusterFuture ...
[17:00:35.334] - result already collected: FutureResult
[17:00:35.334] result() for ClusterFuture ... done
[17:00:35.334] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:35.334] Future #2
[17:00:35.334] result() for ClusterFuture ...
[17:00:35.334] - result already collected: FutureResult
[17:00:35.334] result() for ClusterFuture ... done
[17:00:35.335] result() for ClusterFuture ...
[17:00:35.335] - result already collected: FutureResult
[17:00:35.335] result() for ClusterFuture ... done
[17:00:35.335] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:35.335] - nx: 2
[17:00:35.335] - relay: TRUE
[17:00:35.335] - stdout: TRUE
[17:00:35.335] - signal: TRUE
[17:00:35.335] - resignal: FALSE
[17:00:35.335] - force: TRUE
[17:00:35.335] - relayed: [n=2] TRUE, FALSE
[17:00:35.336] - queued futures: [n=2] TRUE, FALSE
[17:00:35.336]  - until=2
[17:00:35.336]  - relaying element #2
[17:00:35.336] result() for ClusterFuture ...
[17:00:35.336] - result already collected: FutureResult
[17:00:35.336] result() for ClusterFuture ... done
[17:00:35.336] result() for ClusterFuture ...
[17:00:35.336] - result already collected: FutureResult
[17:00:35.336] result() for ClusterFuture ... done
[17:00:35.336] result() for ClusterFuture ...
[17:00:35.336] - result already collected: FutureResult
[17:00:35.337] result() for ClusterFuture ... done
[17:00:35.337] result() for ClusterFuture ...
[17:00:35.337] - result already collected: FutureResult
[17:00:35.337] result() for ClusterFuture ... done
[17:00:35.337] - relayed: [n=2] TRUE, TRUE
[17:00:35.337] - queued futures: [n=2] TRUE, TRUE
[17:00:35.337] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:35.337]  length: 0 (resolved future 2)
[17:00:35.337] Relaying remaining futures
[17:00:35.337] signalConditionsASAP(NULL, pos=0) ...
[17:00:35.337] - nx: 2
[17:00:35.338] - relay: TRUE
[17:00:35.338] - stdout: TRUE
[17:00:35.338] - signal: TRUE
[17:00:35.338] - resignal: FALSE
[17:00:35.338] - force: TRUE
[17:00:35.338] - relayed: [n=2] TRUE, TRUE
[17:00:35.338] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:35.338] - relayed: [n=2] TRUE, TRUE
[17:00:35.338] - queued futures: [n=2] TRUE, TRUE
[17:00:35.338] signalConditionsASAP(NULL, pos=0) ... done
[17:00:35.338] resolve() on list ... DONE
[17:00:35.339] result() for ClusterFuture ...
[17:00:35.339] - result already collected: FutureResult
[17:00:35.339] result() for ClusterFuture ... done
[17:00:35.339] result() for ClusterFuture ...
[17:00:35.339] - result already collected: FutureResult
[17:00:35.339] result() for ClusterFuture ... done
[17:00:35.339] result() for ClusterFuture ...
[17:00:35.339] - result already collected: FutureResult
[17:00:35.339] result() for ClusterFuture ... done
[17:00:35.339] result() for ClusterFuture ...
[17:00:35.339] - result already collected: FutureResult
[17:00:35.339] result() for ClusterFuture ... done
[17:00:35.340]  - Number of value chunks collected: 2
[17:00:35.340] Resolving 2 futures (chunks) ... DONE
[17:00:35.340] Reducing values from 2 chunks ...
[17:00:35.340]  - Number of values collected after concatenation: 3
[17:00:35.340]  - Number of values expected: 3
[17:00:35.340] Reducing values from 2 chunks ... DONE
[17:00:35.340] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[17:00:35.341] future_mapply() ...
[17:00:35.344] Number of chunks: 2
[17:00:35.345] getGlobalsAndPackagesXApply() ...
[17:00:35.345]  - future.globals: TRUE
[17:00:35.345] getGlobalsAndPackages() ...
[17:00:35.345] Searching for globals...
[17:00:35.346] - globals found: [1] ‘FUN’
[17:00:35.346] Searching for globals ... DONE
[17:00:35.346] Resolving globals: FALSE
[17:00:35.346] The total size of the 1 globals is 848 bytes (848 bytes)
[17:00:35.347] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:00:35.347] - globals: [1] ‘FUN’
[17:00:35.347] 
[17:00:35.347] getGlobalsAndPackages() ... DONE
[17:00:35.347]  - globals found/used: [n=1] ‘FUN’
[17:00:35.347]  - needed namespaces: [n=0] 
[17:00:35.347] Finding globals ... DONE
[17:00:35.348] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:00:35.348] List of 2
[17:00:35.348]  $ ...future.FUN:function (x)  
[17:00:35.348]  $ MoreArgs     : NULL
[17:00:35.348]  - attr(*, "where")=List of 2
[17:00:35.348]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:00:35.348]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:00:35.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:00:35.348]  - attr(*, "resolved")= logi FALSE
[17:00:35.348]  - attr(*, "total_size")= num NA
[17:00:35.350] Packages to be attached in all futures: [n=0] 
[17:00:35.350] getGlobalsAndPackagesXApply() ... DONE
[17:00:35.350] Number of futures (= number of chunks): 2
[17:00:35.351] Launching 2 futures (chunks) ...
[17:00:35.351] Chunk #1 of 2 ...
[17:00:35.351]  - Finding globals in '...' for chunk #1 ...
[17:00:35.351] getGlobalsAndPackages() ...
[17:00:35.351] Searching for globals...
[17:00:35.351] 
[17:00:35.351] Searching for globals ... DONE
[17:00:35.351] - globals: [0] <none>
[17:00:35.352] getGlobalsAndPackages() ... DONE
[17:00:35.352]    + additional globals found: [n=0] 
[17:00:35.352]    + additional namespaces needed: [n=0] 
[17:00:35.352]  - Finding globals in '...' for chunk #1 ... DONE
[17:00:35.352]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:35.352]  - seeds: <none>
[17:00:35.352]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.352] getGlobalsAndPackages() ...
[17:00:35.352] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.352] Resolving globals: FALSE
[17:00:35.353] The total size of the 5 globals is 904 bytes (904 bytes)
[17:00:35.353] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:35.353] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.354] 
[17:00:35.354] getGlobalsAndPackages() ... DONE
[17:00:35.354] run() for ‘Future’ ...
[17:00:35.354] - state: ‘created’
[17:00:35.354] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:35.368] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:35.368]   - Field: ‘node’
[17:00:35.369]   - Field: ‘label’
[17:00:35.369]   - Field: ‘local’
[17:00:35.369]   - Field: ‘owner’
[17:00:35.369]   - Field: ‘envir’
[17:00:35.369]   - Field: ‘workers’
[17:00:35.369]   - Field: ‘packages’
[17:00:35.369]   - Field: ‘gc’
[17:00:35.369]   - Field: ‘conditions’
[17:00:35.369]   - Field: ‘persistent’
[17:00:35.369]   - Field: ‘expr’
[17:00:35.370]   - Field: ‘uuid’
[17:00:35.370]   - Field: ‘seed’
[17:00:35.370]   - Field: ‘version’
[17:00:35.370]   - Field: ‘result’
[17:00:35.370]   - Field: ‘asynchronous’
[17:00:35.370]   - Field: ‘calls’
[17:00:35.370]   - Field: ‘globals’
[17:00:35.370]   - Field: ‘stdout’
[17:00:35.370]   - Field: ‘earlySignal’
[17:00:35.370]   - Field: ‘lazy’
[17:00:35.370]   - Field: ‘state’
[17:00:35.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:35.371] - Launch lazy future ...
[17:00:35.371] Packages needed by the future expression (n = 0): <none>
[17:00:35.371] Packages needed by future strategies (n = 0): <none>
[17:00:35.371] {
[17:00:35.371]     {
[17:00:35.371]         {
[17:00:35.371]             ...future.startTime <- base::Sys.time()
[17:00:35.371]             {
[17:00:35.371]                 {
[17:00:35.371]                   {
[17:00:35.371]                     {
[17:00:35.371]                       base::local({
[17:00:35.371]                         has_future <- base::requireNamespace("future", 
[17:00:35.371]                           quietly = TRUE)
[17:00:35.371]                         if (has_future) {
[17:00:35.371]                           ns <- base::getNamespace("future")
[17:00:35.371]                           version <- ns[[".package"]][["version"]]
[17:00:35.371]                           if (is.null(version)) 
[17:00:35.371]                             version <- utils::packageVersion("future")
[17:00:35.371]                         }
[17:00:35.371]                         else {
[17:00:35.371]                           version <- NULL
[17:00:35.371]                         }
[17:00:35.371]                         if (!has_future || version < "1.8.0") {
[17:00:35.371]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:35.371]                             "", base::R.version$version.string), 
[17:00:35.371]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:35.371]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:35.371]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:35.371]                               "release", "version")], collapse = " "), 
[17:00:35.371]                             hostname = base::Sys.info()[["nodename"]])
[17:00:35.371]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:35.371]                             info)
[17:00:35.371]                           info <- base::paste(info, collapse = "; ")
[17:00:35.371]                           if (!has_future) {
[17:00:35.371]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:35.371]                               info)
[17:00:35.371]                           }
[17:00:35.371]                           else {
[17:00:35.371]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:35.371]                               info, version)
[17:00:35.371]                           }
[17:00:35.371]                           base::stop(msg)
[17:00:35.371]                         }
[17:00:35.371]                       })
[17:00:35.371]                     }
[17:00:35.371]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:35.371]                     base::options(mc.cores = 1L)
[17:00:35.371]                   }
[17:00:35.371]                   ...future.strategy.old <- future::plan("list")
[17:00:35.371]                   options(future.plan = NULL)
[17:00:35.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:35.371]                 }
[17:00:35.371]                 ...future.workdir <- getwd()
[17:00:35.371]             }
[17:00:35.371]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:35.371]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:35.371]         }
[17:00:35.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:35.371]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:35.371]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:35.371]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:35.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:35.371]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:35.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:35.371]             base::names(...future.oldOptions))
[17:00:35.371]     }
[17:00:35.371]     if (FALSE) {
[17:00:35.371]     }
[17:00:35.371]     else {
[17:00:35.371]         if (TRUE) {
[17:00:35.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:35.371]                 open = "w")
[17:00:35.371]         }
[17:00:35.371]         else {
[17:00:35.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:35.371]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:35.371]         }
[17:00:35.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:35.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:35.371]             base::sink(type = "output", split = FALSE)
[17:00:35.371]             base::close(...future.stdout)
[17:00:35.371]         }, add = TRUE)
[17:00:35.371]     }
[17:00:35.371]     ...future.frame <- base::sys.nframe()
[17:00:35.371]     ...future.conditions <- base::list()
[17:00:35.371]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:35.371]     if (FALSE) {
[17:00:35.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:35.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:35.371]     }
[17:00:35.371]     ...future.result <- base::tryCatch({
[17:00:35.371]         base::withCallingHandlers({
[17:00:35.371]             ...future.value <- base::withVisible(base::local({
[17:00:35.371]                 ...future.makeSendCondition <- base::local({
[17:00:35.371]                   sendCondition <- NULL
[17:00:35.371]                   function(frame = 1L) {
[17:00:35.371]                     if (is.function(sendCondition)) 
[17:00:35.371]                       return(sendCondition)
[17:00:35.371]                     ns <- getNamespace("parallel")
[17:00:35.371]                     if (exists("sendData", mode = "function", 
[17:00:35.371]                       envir = ns)) {
[17:00:35.371]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:35.371]                         envir = ns)
[17:00:35.371]                       envir <- sys.frame(frame)
[17:00:35.371]                       master <- NULL
[17:00:35.371]                       while (!identical(envir, .GlobalEnv) && 
[17:00:35.371]                         !identical(envir, emptyenv())) {
[17:00:35.371]                         if (exists("master", mode = "list", envir = envir, 
[17:00:35.371]                           inherits = FALSE)) {
[17:00:35.371]                           master <- get("master", mode = "list", 
[17:00:35.371]                             envir = envir, inherits = FALSE)
[17:00:35.371]                           if (inherits(master, c("SOCKnode", 
[17:00:35.371]                             "SOCK0node"))) {
[17:00:35.371]                             sendCondition <<- function(cond) {
[17:00:35.371]                               data <- list(type = "VALUE", value = cond, 
[17:00:35.371]                                 success = TRUE)
[17:00:35.371]                               parallel_sendData(master, data)
[17:00:35.371]                             }
[17:00:35.371]                             return(sendCondition)
[17:00:35.371]                           }
[17:00:35.371]                         }
[17:00:35.371]                         frame <- frame + 1L
[17:00:35.371]                         envir <- sys.frame(frame)
[17:00:35.371]                       }
[17:00:35.371]                     }
[17:00:35.371]                     sendCondition <<- function(cond) NULL
[17:00:35.371]                   }
[17:00:35.371]                 })
[17:00:35.371]                 withCallingHandlers({
[17:00:35.371]                   {
[17:00:35.371]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.371]                     if (!identical(...future.globals.maxSize.org, 
[17:00:35.371]                       ...future.globals.maxSize)) {
[17:00:35.371]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.371]                       on.exit(options(oopts), add = TRUE)
[17:00:35.371]                     }
[17:00:35.371]                     {
[17:00:35.371]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.371]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:35.371]                         USE.NAMES = FALSE)
[17:00:35.371]                       do.call(mapply, args = args)
[17:00:35.371]                     }
[17:00:35.371]                   }
[17:00:35.371]                 }, immediateCondition = function(cond) {
[17:00:35.371]                   sendCondition <- ...future.makeSendCondition()
[17:00:35.371]                   sendCondition(cond)
[17:00:35.371]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.371]                   {
[17:00:35.371]                     inherits <- base::inherits
[17:00:35.371]                     invokeRestart <- base::invokeRestart
[17:00:35.371]                     is.null <- base::is.null
[17:00:35.371]                     muffled <- FALSE
[17:00:35.371]                     if (inherits(cond, "message")) {
[17:00:35.371]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:35.371]                       if (muffled) 
[17:00:35.371]                         invokeRestart("muffleMessage")
[17:00:35.371]                     }
[17:00:35.371]                     else if (inherits(cond, "warning")) {
[17:00:35.371]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:35.371]                       if (muffled) 
[17:00:35.371]                         invokeRestart("muffleWarning")
[17:00:35.371]                     }
[17:00:35.371]                     else if (inherits(cond, "condition")) {
[17:00:35.371]                       if (!is.null(pattern)) {
[17:00:35.371]                         computeRestarts <- base::computeRestarts
[17:00:35.371]                         grepl <- base::grepl
[17:00:35.371]                         restarts <- computeRestarts(cond)
[17:00:35.371]                         for (restart in restarts) {
[17:00:35.371]                           name <- restart$name
[17:00:35.371]                           if (is.null(name)) 
[17:00:35.371]                             next
[17:00:35.371]                           if (!grepl(pattern, name)) 
[17:00:35.371]                             next
[17:00:35.371]                           invokeRestart(restart)
[17:00:35.371]                           muffled <- TRUE
[17:00:35.371]                           break
[17:00:35.371]                         }
[17:00:35.371]                       }
[17:00:35.371]                     }
[17:00:35.371]                     invisible(muffled)
[17:00:35.371]                   }
[17:00:35.371]                   muffleCondition(cond)
[17:00:35.371]                 })
[17:00:35.371]             }))
[17:00:35.371]             future::FutureResult(value = ...future.value$value, 
[17:00:35.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.371]                   ...future.rng), globalenv = if (FALSE) 
[17:00:35.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:35.371]                     ...future.globalenv.names))
[17:00:35.371]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:35.371]         }, condition = base::local({
[17:00:35.371]             c <- base::c
[17:00:35.371]             inherits <- base::inherits
[17:00:35.371]             invokeRestart <- base::invokeRestart
[17:00:35.371]             length <- base::length
[17:00:35.371]             list <- base::list
[17:00:35.371]             seq.int <- base::seq.int
[17:00:35.371]             signalCondition <- base::signalCondition
[17:00:35.371]             sys.calls <- base::sys.calls
[17:00:35.371]             `[[` <- base::`[[`
[17:00:35.371]             `+` <- base::`+`
[17:00:35.371]             `<<-` <- base::`<<-`
[17:00:35.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:35.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:35.371]                   3L)]
[17:00:35.371]             }
[17:00:35.371]             function(cond) {
[17:00:35.371]                 is_error <- inherits(cond, "error")
[17:00:35.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:35.371]                   NULL)
[17:00:35.371]                 if (is_error) {
[17:00:35.371]                   sessionInformation <- function() {
[17:00:35.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:35.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:35.371]                       search = base::search(), system = base::Sys.info())
[17:00:35.371]                   }
[17:00:35.371]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:35.371]                     cond$call), session = sessionInformation(), 
[17:00:35.371]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:35.371]                   signalCondition(cond)
[17:00:35.371]                 }
[17:00:35.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:35.371]                 "immediateCondition"))) {
[17:00:35.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:35.371]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:35.371]                   if (TRUE && !signal) {
[17:00:35.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.371]                     {
[17:00:35.371]                       inherits <- base::inherits
[17:00:35.371]                       invokeRestart <- base::invokeRestart
[17:00:35.371]                       is.null <- base::is.null
[17:00:35.371]                       muffled <- FALSE
[17:00:35.371]                       if (inherits(cond, "message")) {
[17:00:35.371]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.371]                         if (muffled) 
[17:00:35.371]                           invokeRestart("muffleMessage")
[17:00:35.371]                       }
[17:00:35.371]                       else if (inherits(cond, "warning")) {
[17:00:35.371]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.371]                         if (muffled) 
[17:00:35.371]                           invokeRestart("muffleWarning")
[17:00:35.371]                       }
[17:00:35.371]                       else if (inherits(cond, "condition")) {
[17:00:35.371]                         if (!is.null(pattern)) {
[17:00:35.371]                           computeRestarts <- base::computeRestarts
[17:00:35.371]                           grepl <- base::grepl
[17:00:35.371]                           restarts <- computeRestarts(cond)
[17:00:35.371]                           for (restart in restarts) {
[17:00:35.371]                             name <- restart$name
[17:00:35.371]                             if (is.null(name)) 
[17:00:35.371]                               next
[17:00:35.371]                             if (!grepl(pattern, name)) 
[17:00:35.371]                               next
[17:00:35.371]                             invokeRestart(restart)
[17:00:35.371]                             muffled <- TRUE
[17:00:35.371]                             break
[17:00:35.371]                           }
[17:00:35.371]                         }
[17:00:35.371]                       }
[17:00:35.371]                       invisible(muffled)
[17:00:35.371]                     }
[17:00:35.371]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.371]                   }
[17:00:35.371]                 }
[17:00:35.371]                 else {
[17:00:35.371]                   if (TRUE) {
[17:00:35.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.371]                     {
[17:00:35.371]                       inherits <- base::inherits
[17:00:35.371]                       invokeRestart <- base::invokeRestart
[17:00:35.371]                       is.null <- base::is.null
[17:00:35.371]                       muffled <- FALSE
[17:00:35.371]                       if (inherits(cond, "message")) {
[17:00:35.371]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.371]                         if (muffled) 
[17:00:35.371]                           invokeRestart("muffleMessage")
[17:00:35.371]                       }
[17:00:35.371]                       else if (inherits(cond, "warning")) {
[17:00:35.371]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.371]                         if (muffled) 
[17:00:35.371]                           invokeRestart("muffleWarning")
[17:00:35.371]                       }
[17:00:35.371]                       else if (inherits(cond, "condition")) {
[17:00:35.371]                         if (!is.null(pattern)) {
[17:00:35.371]                           computeRestarts <- base::computeRestarts
[17:00:35.371]                           grepl <- base::grepl
[17:00:35.371]                           restarts <- computeRestarts(cond)
[17:00:35.371]                           for (restart in restarts) {
[17:00:35.371]                             name <- restart$name
[17:00:35.371]                             if (is.null(name)) 
[17:00:35.371]                               next
[17:00:35.371]                             if (!grepl(pattern, name)) 
[17:00:35.371]                               next
[17:00:35.371]                             invokeRestart(restart)
[17:00:35.371]                             muffled <- TRUE
[17:00:35.371]                             break
[17:00:35.371]                           }
[17:00:35.371]                         }
[17:00:35.371]                       }
[17:00:35.371]                       invisible(muffled)
[17:00:35.371]                     }
[17:00:35.371]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.371]                   }
[17:00:35.371]                 }
[17:00:35.371]             }
[17:00:35.371]         }))
[17:00:35.371]     }, error = function(ex) {
[17:00:35.371]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:35.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.371]                 ...future.rng), started = ...future.startTime, 
[17:00:35.371]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:35.371]             version = "1.8"), class = "FutureResult")
[17:00:35.371]     }, finally = {
[17:00:35.371]         if (!identical(...future.workdir, getwd())) 
[17:00:35.371]             setwd(...future.workdir)
[17:00:35.371]         {
[17:00:35.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:35.371]                 ...future.oldOptions$nwarnings <- NULL
[17:00:35.371]             }
[17:00:35.371]             base::options(...future.oldOptions)
[17:00:35.371]             if (.Platform$OS.type == "windows") {
[17:00:35.371]                 old_names <- names(...future.oldEnvVars)
[17:00:35.371]                 envs <- base::Sys.getenv()
[17:00:35.371]                 names <- names(envs)
[17:00:35.371]                 common <- intersect(names, old_names)
[17:00:35.371]                 added <- setdiff(names, old_names)
[17:00:35.371]                 removed <- setdiff(old_names, names)
[17:00:35.371]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:35.371]                   envs[common]]
[17:00:35.371]                 NAMES <- toupper(changed)
[17:00:35.371]                 args <- list()
[17:00:35.371]                 for (kk in seq_along(NAMES)) {
[17:00:35.371]                   name <- changed[[kk]]
[17:00:35.371]                   NAME <- NAMES[[kk]]
[17:00:35.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.371]                     next
[17:00:35.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.371]                 }
[17:00:35.371]                 NAMES <- toupper(added)
[17:00:35.371]                 for (kk in seq_along(NAMES)) {
[17:00:35.371]                   name <- added[[kk]]
[17:00:35.371]                   NAME <- NAMES[[kk]]
[17:00:35.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.371]                     next
[17:00:35.371]                   args[[name]] <- ""
[17:00:35.371]                 }
[17:00:35.371]                 NAMES <- toupper(removed)
[17:00:35.371]                 for (kk in seq_along(NAMES)) {
[17:00:35.371]                   name <- removed[[kk]]
[17:00:35.371]                   NAME <- NAMES[[kk]]
[17:00:35.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.371]                     next
[17:00:35.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.371]                 }
[17:00:35.371]                 if (length(args) > 0) 
[17:00:35.371]                   base::do.call(base::Sys.setenv, args = args)
[17:00:35.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:35.371]             }
[17:00:35.371]             else {
[17:00:35.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:35.371]             }
[17:00:35.371]             {
[17:00:35.371]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:35.371]                   0L) {
[17:00:35.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:35.371]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:35.371]                   base::options(opts)
[17:00:35.371]                 }
[17:00:35.371]                 {
[17:00:35.371]                   {
[17:00:35.371]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:35.371]                     NULL
[17:00:35.371]                   }
[17:00:35.371]                   options(future.plan = NULL)
[17:00:35.371]                   if (is.na(NA_character_)) 
[17:00:35.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:35.371]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:35.371]                     .init = FALSE)
[17:00:35.371]                 }
[17:00:35.371]             }
[17:00:35.371]         }
[17:00:35.371]     })
[17:00:35.371]     if (TRUE) {
[17:00:35.371]         base::sink(type = "output", split = FALSE)
[17:00:35.371]         if (TRUE) {
[17:00:35.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:35.371]         }
[17:00:35.371]         else {
[17:00:35.371]             ...future.result["stdout"] <- base::list(NULL)
[17:00:35.371]         }
[17:00:35.371]         base::close(...future.stdout)
[17:00:35.371]         ...future.stdout <- NULL
[17:00:35.371]     }
[17:00:35.371]     ...future.result$conditions <- ...future.conditions
[17:00:35.371]     ...future.result$finished <- base::Sys.time()
[17:00:35.371]     ...future.result
[17:00:35.371] }
[17:00:35.374] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[17:00:35.374] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:00:35.375] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:00:35.375] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:00:35.375] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:00:35.375] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:00:35.376] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:00:35.376] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:00:35.376] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:00:35.376] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:00:35.377] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:00:35.377] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[17:00:35.377] MultisessionFuture started
[17:00:35.377] - Launch lazy future ... done
[17:00:35.377] run() for ‘MultisessionFuture’ ... done
[17:00:35.377] Created future:
[17:00:35.377] MultisessionFuture:
[17:00:35.377] Label: ‘future_mapply-1’
[17:00:35.377] Expression:
[17:00:35.377] {
[17:00:35.377]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.377]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:35.377]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.377]         on.exit(options(oopts), add = TRUE)
[17:00:35.377]     }
[17:00:35.377]     {
[17:00:35.377]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.377]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:35.377]         do.call(mapply, args = args)
[17:00:35.377]     }
[17:00:35.377] }
[17:00:35.377] Lazy evaluation: FALSE
[17:00:35.377] Asynchronous evaluation: TRUE
[17:00:35.377] Local evaluation: TRUE
[17:00:35.377] Environment: R_GlobalEnv
[17:00:35.377] Capture standard output: TRUE
[17:00:35.377] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:35.377] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:35.377] Packages: <none>
[17:00:35.377] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:35.377] Resolved: FALSE
[17:00:35.377] Value: <not collected>
[17:00:35.377] Conditions captured: <none>
[17:00:35.377] Early signaling: FALSE
[17:00:35.377] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:35.377] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.392] Chunk #1 of 2 ... DONE
[17:00:35.392] Chunk #2 of 2 ...
[17:00:35.392]  - Finding globals in '...' for chunk #2 ...
[17:00:35.392] getGlobalsAndPackages() ...
[17:00:35.392] Searching for globals...
[17:00:35.393] 
[17:00:35.393] Searching for globals ... DONE
[17:00:35.393] - globals: [0] <none>
[17:00:35.393] getGlobalsAndPackages() ... DONE
[17:00:35.393]    + additional globals found: [n=0] 
[17:00:35.393]    + additional namespaces needed: [n=0] 
[17:00:35.393]  - Finding globals in '...' for chunk #2 ... DONE
[17:00:35.393]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:00:35.393]  - seeds: <none>
[17:00:35.394]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.394] getGlobalsAndPackages() ...
[17:00:35.394] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.394] Resolving globals: FALSE
[17:00:35.394] The total size of the 5 globals is 904 bytes (904 bytes)
[17:00:35.395] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:00:35.395] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:00:35.395] 
[17:00:35.395] getGlobalsAndPackages() ... DONE
[17:00:35.395] run() for ‘Future’ ...
[17:00:35.396] - state: ‘created’
[17:00:35.396] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:00:35.411] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.411] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:00:35.411]   - Field: ‘node’
[17:00:35.411]   - Field: ‘label’
[17:00:35.411]   - Field: ‘local’
[17:00:35.411]   - Field: ‘owner’
[17:00:35.411]   - Field: ‘envir’
[17:00:35.412]   - Field: ‘workers’
[17:00:35.412]   - Field: ‘packages’
[17:00:35.412]   - Field: ‘gc’
[17:00:35.412]   - Field: ‘conditions’
[17:00:35.412]   - Field: ‘persistent’
[17:00:35.412]   - Field: ‘expr’
[17:00:35.412]   - Field: ‘uuid’
[17:00:35.412]   - Field: ‘seed’
[17:00:35.412]   - Field: ‘version’
[17:00:35.412]   - Field: ‘result’
[17:00:35.412]   - Field: ‘asynchronous’
[17:00:35.413]   - Field: ‘calls’
[17:00:35.413]   - Field: ‘globals’
[17:00:35.413]   - Field: ‘stdout’
[17:00:35.413]   - Field: ‘earlySignal’
[17:00:35.413]   - Field: ‘lazy’
[17:00:35.413]   - Field: ‘state’
[17:00:35.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:00:35.413] - Launch lazy future ...
[17:00:35.413] Packages needed by the future expression (n = 0): <none>
[17:00:35.414] Packages needed by future strategies (n = 0): <none>
[17:00:35.414] {
[17:00:35.414]     {
[17:00:35.414]         {
[17:00:35.414]             ...future.startTime <- base::Sys.time()
[17:00:35.414]             {
[17:00:35.414]                 {
[17:00:35.414]                   {
[17:00:35.414]                     {
[17:00:35.414]                       base::local({
[17:00:35.414]                         has_future <- base::requireNamespace("future", 
[17:00:35.414]                           quietly = TRUE)
[17:00:35.414]                         if (has_future) {
[17:00:35.414]                           ns <- base::getNamespace("future")
[17:00:35.414]                           version <- ns[[".package"]][["version"]]
[17:00:35.414]                           if (is.null(version)) 
[17:00:35.414]                             version <- utils::packageVersion("future")
[17:00:35.414]                         }
[17:00:35.414]                         else {
[17:00:35.414]                           version <- NULL
[17:00:35.414]                         }
[17:00:35.414]                         if (!has_future || version < "1.8.0") {
[17:00:35.414]                           info <- base::c(r_version = base::gsub("R version ", 
[17:00:35.414]                             "", base::R.version$version.string), 
[17:00:35.414]                             platform = base::sprintf("%s (%s-bit)", 
[17:00:35.414]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:00:35.414]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:00:35.414]                               "release", "version")], collapse = " "), 
[17:00:35.414]                             hostname = base::Sys.info()[["nodename"]])
[17:00:35.414]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:00:35.414]                             info)
[17:00:35.414]                           info <- base::paste(info, collapse = "; ")
[17:00:35.414]                           if (!has_future) {
[17:00:35.414]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:00:35.414]                               info)
[17:00:35.414]                           }
[17:00:35.414]                           else {
[17:00:35.414]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:00:35.414]                               info, version)
[17:00:35.414]                           }
[17:00:35.414]                           base::stop(msg)
[17:00:35.414]                         }
[17:00:35.414]                       })
[17:00:35.414]                     }
[17:00:35.414]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:00:35.414]                     base::options(mc.cores = 1L)
[17:00:35.414]                   }
[17:00:35.414]                   ...future.strategy.old <- future::plan("list")
[17:00:35.414]                   options(future.plan = NULL)
[17:00:35.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:00:35.414]                 }
[17:00:35.414]                 ...future.workdir <- getwd()
[17:00:35.414]             }
[17:00:35.414]             ...future.oldOptions <- base::as.list(base::.Options)
[17:00:35.414]             ...future.oldEnvVars <- base::Sys.getenv()
[17:00:35.414]         }
[17:00:35.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:00:35.414]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:00:35.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:00:35.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:00:35.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:00:35.414]             future.stdout.windows.reencode = NULL, width = 80L)
[17:00:35.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:00:35.414]             base::names(...future.oldOptions))
[17:00:35.414]     }
[17:00:35.414]     if (FALSE) {
[17:00:35.414]     }
[17:00:35.414]     else {
[17:00:35.414]         if (TRUE) {
[17:00:35.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:00:35.414]                 open = "w")
[17:00:35.414]         }
[17:00:35.414]         else {
[17:00:35.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:00:35.414]                 windows = "NUL", "/dev/null"), open = "w")
[17:00:35.414]         }
[17:00:35.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:00:35.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:00:35.414]             base::sink(type = "output", split = FALSE)
[17:00:35.414]             base::close(...future.stdout)
[17:00:35.414]         }, add = TRUE)
[17:00:35.414]     }
[17:00:35.414]     ...future.frame <- base::sys.nframe()
[17:00:35.414]     ...future.conditions <- base::list()
[17:00:35.414]     ...future.rng <- base::globalenv()$.Random.seed
[17:00:35.414]     if (FALSE) {
[17:00:35.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:00:35.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:00:35.414]     }
[17:00:35.414]     ...future.result <- base::tryCatch({
[17:00:35.414]         base::withCallingHandlers({
[17:00:35.414]             ...future.value <- base::withVisible(base::local({
[17:00:35.414]                 ...future.makeSendCondition <- base::local({
[17:00:35.414]                   sendCondition <- NULL
[17:00:35.414]                   function(frame = 1L) {
[17:00:35.414]                     if (is.function(sendCondition)) 
[17:00:35.414]                       return(sendCondition)
[17:00:35.414]                     ns <- getNamespace("parallel")
[17:00:35.414]                     if (exists("sendData", mode = "function", 
[17:00:35.414]                       envir = ns)) {
[17:00:35.414]                       parallel_sendData <- get("sendData", mode = "function", 
[17:00:35.414]                         envir = ns)
[17:00:35.414]                       envir <- sys.frame(frame)
[17:00:35.414]                       master <- NULL
[17:00:35.414]                       while (!identical(envir, .GlobalEnv) && 
[17:00:35.414]                         !identical(envir, emptyenv())) {
[17:00:35.414]                         if (exists("master", mode = "list", envir = envir, 
[17:00:35.414]                           inherits = FALSE)) {
[17:00:35.414]                           master <- get("master", mode = "list", 
[17:00:35.414]                             envir = envir, inherits = FALSE)
[17:00:35.414]                           if (inherits(master, c("SOCKnode", 
[17:00:35.414]                             "SOCK0node"))) {
[17:00:35.414]                             sendCondition <<- function(cond) {
[17:00:35.414]                               data <- list(type = "VALUE", value = cond, 
[17:00:35.414]                                 success = TRUE)
[17:00:35.414]                               parallel_sendData(master, data)
[17:00:35.414]                             }
[17:00:35.414]                             return(sendCondition)
[17:00:35.414]                           }
[17:00:35.414]                         }
[17:00:35.414]                         frame <- frame + 1L
[17:00:35.414]                         envir <- sys.frame(frame)
[17:00:35.414]                       }
[17:00:35.414]                     }
[17:00:35.414]                     sendCondition <<- function(cond) NULL
[17:00:35.414]                   }
[17:00:35.414]                 })
[17:00:35.414]                 withCallingHandlers({
[17:00:35.414]                   {
[17:00:35.414]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.414]                     if (!identical(...future.globals.maxSize.org, 
[17:00:35.414]                       ...future.globals.maxSize)) {
[17:00:35.414]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.414]                       on.exit(options(oopts), add = TRUE)
[17:00:35.414]                     }
[17:00:35.414]                     {
[17:00:35.414]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.414]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:00:35.414]                         USE.NAMES = FALSE)
[17:00:35.414]                       do.call(mapply, args = args)
[17:00:35.414]                     }
[17:00:35.414]                   }
[17:00:35.414]                 }, immediateCondition = function(cond) {
[17:00:35.414]                   sendCondition <- ...future.makeSendCondition()
[17:00:35.414]                   sendCondition(cond)
[17:00:35.414]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.414]                   {
[17:00:35.414]                     inherits <- base::inherits
[17:00:35.414]                     invokeRestart <- base::invokeRestart
[17:00:35.414]                     is.null <- base::is.null
[17:00:35.414]                     muffled <- FALSE
[17:00:35.414]                     if (inherits(cond, "message")) {
[17:00:35.414]                       muffled <- grepl(pattern, "muffleMessage")
[17:00:35.414]                       if (muffled) 
[17:00:35.414]                         invokeRestart("muffleMessage")
[17:00:35.414]                     }
[17:00:35.414]                     else if (inherits(cond, "warning")) {
[17:00:35.414]                       muffled <- grepl(pattern, "muffleWarning")
[17:00:35.414]                       if (muffled) 
[17:00:35.414]                         invokeRestart("muffleWarning")
[17:00:35.414]                     }
[17:00:35.414]                     else if (inherits(cond, "condition")) {
[17:00:35.414]                       if (!is.null(pattern)) {
[17:00:35.414]                         computeRestarts <- base::computeRestarts
[17:00:35.414]                         grepl <- base::grepl
[17:00:35.414]                         restarts <- computeRestarts(cond)
[17:00:35.414]                         for (restart in restarts) {
[17:00:35.414]                           name <- restart$name
[17:00:35.414]                           if (is.null(name)) 
[17:00:35.414]                             next
[17:00:35.414]                           if (!grepl(pattern, name)) 
[17:00:35.414]                             next
[17:00:35.414]                           invokeRestart(restart)
[17:00:35.414]                           muffled <- TRUE
[17:00:35.414]                           break
[17:00:35.414]                         }
[17:00:35.414]                       }
[17:00:35.414]                     }
[17:00:35.414]                     invisible(muffled)
[17:00:35.414]                   }
[17:00:35.414]                   muffleCondition(cond)
[17:00:35.414]                 })
[17:00:35.414]             }))
[17:00:35.414]             future::FutureResult(value = ...future.value$value, 
[17:00:35.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.414]                   ...future.rng), globalenv = if (FALSE) 
[17:00:35.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:00:35.414]                     ...future.globalenv.names))
[17:00:35.414]                 else NULL, started = ...future.startTime, version = "1.8")
[17:00:35.414]         }, condition = base::local({
[17:00:35.414]             c <- base::c
[17:00:35.414]             inherits <- base::inherits
[17:00:35.414]             invokeRestart <- base::invokeRestart
[17:00:35.414]             length <- base::length
[17:00:35.414]             list <- base::list
[17:00:35.414]             seq.int <- base::seq.int
[17:00:35.414]             signalCondition <- base::signalCondition
[17:00:35.414]             sys.calls <- base::sys.calls
[17:00:35.414]             `[[` <- base::`[[`
[17:00:35.414]             `+` <- base::`+`
[17:00:35.414]             `<<-` <- base::`<<-`
[17:00:35.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:00:35.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:00:35.414]                   3L)]
[17:00:35.414]             }
[17:00:35.414]             function(cond) {
[17:00:35.414]                 is_error <- inherits(cond, "error")
[17:00:35.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:00:35.414]                   NULL)
[17:00:35.414]                 if (is_error) {
[17:00:35.414]                   sessionInformation <- function() {
[17:00:35.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:00:35.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:00:35.414]                       search = base::search(), system = base::Sys.info())
[17:00:35.414]                   }
[17:00:35.414]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:00:35.414]                     cond$call), session = sessionInformation(), 
[17:00:35.414]                     timestamp = base::Sys.time(), signaled = 0L)
[17:00:35.414]                   signalCondition(cond)
[17:00:35.414]                 }
[17:00:35.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:00:35.414]                 "immediateCondition"))) {
[17:00:35.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:00:35.414]                   ...future.conditions[[length(...future.conditions) + 
[17:00:35.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:00:35.414]                   if (TRUE && !signal) {
[17:00:35.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.414]                     {
[17:00:35.414]                       inherits <- base::inherits
[17:00:35.414]                       invokeRestart <- base::invokeRestart
[17:00:35.414]                       is.null <- base::is.null
[17:00:35.414]                       muffled <- FALSE
[17:00:35.414]                       if (inherits(cond, "message")) {
[17:00:35.414]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.414]                         if (muffled) 
[17:00:35.414]                           invokeRestart("muffleMessage")
[17:00:35.414]                       }
[17:00:35.414]                       else if (inherits(cond, "warning")) {
[17:00:35.414]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.414]                         if (muffled) 
[17:00:35.414]                           invokeRestart("muffleWarning")
[17:00:35.414]                       }
[17:00:35.414]                       else if (inherits(cond, "condition")) {
[17:00:35.414]                         if (!is.null(pattern)) {
[17:00:35.414]                           computeRestarts <- base::computeRestarts
[17:00:35.414]                           grepl <- base::grepl
[17:00:35.414]                           restarts <- computeRestarts(cond)
[17:00:35.414]                           for (restart in restarts) {
[17:00:35.414]                             name <- restart$name
[17:00:35.414]                             if (is.null(name)) 
[17:00:35.414]                               next
[17:00:35.414]                             if (!grepl(pattern, name)) 
[17:00:35.414]                               next
[17:00:35.414]                             invokeRestart(restart)
[17:00:35.414]                             muffled <- TRUE
[17:00:35.414]                             break
[17:00:35.414]                           }
[17:00:35.414]                         }
[17:00:35.414]                       }
[17:00:35.414]                       invisible(muffled)
[17:00:35.414]                     }
[17:00:35.414]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.414]                   }
[17:00:35.414]                 }
[17:00:35.414]                 else {
[17:00:35.414]                   if (TRUE) {
[17:00:35.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:00:35.414]                     {
[17:00:35.414]                       inherits <- base::inherits
[17:00:35.414]                       invokeRestart <- base::invokeRestart
[17:00:35.414]                       is.null <- base::is.null
[17:00:35.414]                       muffled <- FALSE
[17:00:35.414]                       if (inherits(cond, "message")) {
[17:00:35.414]                         muffled <- grepl(pattern, "muffleMessage")
[17:00:35.414]                         if (muffled) 
[17:00:35.414]                           invokeRestart("muffleMessage")
[17:00:35.414]                       }
[17:00:35.414]                       else if (inherits(cond, "warning")) {
[17:00:35.414]                         muffled <- grepl(pattern, "muffleWarning")
[17:00:35.414]                         if (muffled) 
[17:00:35.414]                           invokeRestart("muffleWarning")
[17:00:35.414]                       }
[17:00:35.414]                       else if (inherits(cond, "condition")) {
[17:00:35.414]                         if (!is.null(pattern)) {
[17:00:35.414]                           computeRestarts <- base::computeRestarts
[17:00:35.414]                           grepl <- base::grepl
[17:00:35.414]                           restarts <- computeRestarts(cond)
[17:00:35.414]                           for (restart in restarts) {
[17:00:35.414]                             name <- restart$name
[17:00:35.414]                             if (is.null(name)) 
[17:00:35.414]                               next
[17:00:35.414]                             if (!grepl(pattern, name)) 
[17:00:35.414]                               next
[17:00:35.414]                             invokeRestart(restart)
[17:00:35.414]                             muffled <- TRUE
[17:00:35.414]                             break
[17:00:35.414]                           }
[17:00:35.414]                         }
[17:00:35.414]                       }
[17:00:35.414]                       invisible(muffled)
[17:00:35.414]                     }
[17:00:35.414]                     muffleCondition(cond, pattern = "^muffle")
[17:00:35.414]                   }
[17:00:35.414]                 }
[17:00:35.414]             }
[17:00:35.414]         }))
[17:00:35.414]     }, error = function(ex) {
[17:00:35.414]         base::structure(base::list(value = NULL, visible = NULL, 
[17:00:35.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:00:35.414]                 ...future.rng), started = ...future.startTime, 
[17:00:35.414]             finished = Sys.time(), session_uuid = NA_character_, 
[17:00:35.414]             version = "1.8"), class = "FutureResult")
[17:00:35.414]     }, finally = {
[17:00:35.414]         if (!identical(...future.workdir, getwd())) 
[17:00:35.414]             setwd(...future.workdir)
[17:00:35.414]         {
[17:00:35.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:00:35.414]                 ...future.oldOptions$nwarnings <- NULL
[17:00:35.414]             }
[17:00:35.414]             base::options(...future.oldOptions)
[17:00:35.414]             if (.Platform$OS.type == "windows") {
[17:00:35.414]                 old_names <- names(...future.oldEnvVars)
[17:00:35.414]                 envs <- base::Sys.getenv()
[17:00:35.414]                 names <- names(envs)
[17:00:35.414]                 common <- intersect(names, old_names)
[17:00:35.414]                 added <- setdiff(names, old_names)
[17:00:35.414]                 removed <- setdiff(old_names, names)
[17:00:35.414]                 changed <- common[...future.oldEnvVars[common] != 
[17:00:35.414]                   envs[common]]
[17:00:35.414]                 NAMES <- toupper(changed)
[17:00:35.414]                 args <- list()
[17:00:35.414]                 for (kk in seq_along(NAMES)) {
[17:00:35.414]                   name <- changed[[kk]]
[17:00:35.414]                   NAME <- NAMES[[kk]]
[17:00:35.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.414]                     next
[17:00:35.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.414]                 }
[17:00:35.414]                 NAMES <- toupper(added)
[17:00:35.414]                 for (kk in seq_along(NAMES)) {
[17:00:35.414]                   name <- added[[kk]]
[17:00:35.414]                   NAME <- NAMES[[kk]]
[17:00:35.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.414]                     next
[17:00:35.414]                   args[[name]] <- ""
[17:00:35.414]                 }
[17:00:35.414]                 NAMES <- toupper(removed)
[17:00:35.414]                 for (kk in seq_along(NAMES)) {
[17:00:35.414]                   name <- removed[[kk]]
[17:00:35.414]                   NAME <- NAMES[[kk]]
[17:00:35.414]                   if (name != NAME && is.element(NAME, old_names)) 
[17:00:35.414]                     next
[17:00:35.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:00:35.414]                 }
[17:00:35.414]                 if (length(args) > 0) 
[17:00:35.414]                   base::do.call(base::Sys.setenv, args = args)
[17:00:35.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:00:35.414]             }
[17:00:35.414]             else {
[17:00:35.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:00:35.414]             }
[17:00:35.414]             {
[17:00:35.414]                 if (base::length(...future.futureOptionsAdded) > 
[17:00:35.414]                   0L) {
[17:00:35.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:00:35.414]                   base::names(opts) <- ...future.futureOptionsAdded
[17:00:35.414]                   base::options(opts)
[17:00:35.414]                 }
[17:00:35.414]                 {
[17:00:35.414]                   {
[17:00:35.414]                     base::options(mc.cores = ...future.mc.cores.old)
[17:00:35.414]                     NULL
[17:00:35.414]                   }
[17:00:35.414]                   options(future.plan = NULL)
[17:00:35.414]                   if (is.na(NA_character_)) 
[17:00:35.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:00:35.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:00:35.414]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:00:35.414]                     .init = FALSE)
[17:00:35.414]                 }
[17:00:35.414]             }
[17:00:35.414]         }
[17:00:35.414]     })
[17:00:35.414]     if (TRUE) {
[17:00:35.414]         base::sink(type = "output", split = FALSE)
[17:00:35.414]         if (TRUE) {
[17:00:35.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:00:35.414]         }
[17:00:35.414]         else {
[17:00:35.414]             ...future.result["stdout"] <- base::list(NULL)
[17:00:35.414]         }
[17:00:35.414]         base::close(...future.stdout)
[17:00:35.414]         ...future.stdout <- NULL
[17:00:35.414]     }
[17:00:35.414]     ...future.result$conditions <- ...future.conditions
[17:00:35.414]     ...future.result$finished <- base::Sys.time()
[17:00:35.414]     ...future.result
[17:00:35.414] }
[17:00:35.417] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[17:00:35.417] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:00:35.417] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:00:35.417] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:00:35.418] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:00:35.418] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:00:35.418] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:00:35.418] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:00:35.419] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:00:35.419] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:00:35.419] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:00:35.419] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[17:00:35.420] MultisessionFuture started
[17:00:35.420] - Launch lazy future ... done
[17:00:35.420] run() for ‘MultisessionFuture’ ... done
[17:00:35.420] Created future:
[17:00:35.420] MultisessionFuture:
[17:00:35.420] Label: ‘future_mapply-2’
[17:00:35.420] Expression:
[17:00:35.420] {
[17:00:35.420]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:00:35.420]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:00:35.420]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:00:35.420]         on.exit(options(oopts), add = TRUE)
[17:00:35.420]     }
[17:00:35.420]     {
[17:00:35.420]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:00:35.420]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:00:35.420]         do.call(mapply, args = args)
[17:00:35.420]     }
[17:00:35.420] }
[17:00:35.420] Lazy evaluation: FALSE
[17:00:35.420] Asynchronous evaluation: TRUE
[17:00:35.420] Local evaluation: TRUE
[17:00:35.420] Environment: R_GlobalEnv
[17:00:35.420] Capture standard output: TRUE
[17:00:35.420] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:00:35.420] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:00:35.420] Packages: <none>
[17:00:35.420] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:00:35.420] Resolved: FALSE
[17:00:35.420] Value: <not collected>
[17:00:35.420] Conditions captured: <none>
[17:00:35.420] Early signaling: FALSE
[17:00:35.420] Owner process: 925c4221-20d3-ec86-8a23-cb9452000129
[17:00:35.420] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:00:35.432] Chunk #2 of 2 ... DONE
[17:00:35.432] Launching 2 futures (chunks) ... DONE
[17:00:35.432] Resolving 2 futures (chunks) ...
[17:00:35.433] resolve() on list ...
[17:00:35.433]  recursive: 0
[17:00:35.433]  length: 2
[17:00:35.433] 
[17:00:35.433] receiveMessageFromWorker() for ClusterFuture ...
[17:00:35.433] - Validating connection of MultisessionFuture
[17:00:35.434] - received message: FutureResult
[17:00:35.434] - Received FutureResult
[17:00:35.434] - Erased future from FutureRegistry
[17:00:35.434] result() for ClusterFuture ...
[17:00:35.434] - result already collected: FutureResult
[17:00:35.434] result() for ClusterFuture ... done
[17:00:35.434] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:35.434] Future #1
[17:00:35.434] result() for ClusterFuture ...
[17:00:35.434] - result already collected: FutureResult
[17:00:35.435] result() for ClusterFuture ... done
[17:00:35.435] result() for ClusterFuture ...
[17:00:35.435] - result already collected: FutureResult
[17:00:35.435] result() for ClusterFuture ... done
[17:00:35.435] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:00:35.435] - nx: 2
[17:00:35.435] - relay: TRUE
[17:00:35.435] - stdout: TRUE
[17:00:35.435] - signal: TRUE
[17:00:35.435] - resignal: FALSE
[17:00:35.436] - force: TRUE
[17:00:35.436] - relayed: [n=2] FALSE, FALSE
[17:00:35.436] - queued futures: [n=2] FALSE, FALSE
[17:00:35.436]  - until=1
[17:00:35.436]  - relaying element #1
[17:00:35.436] result() for ClusterFuture ...
[17:00:35.436] - result already collected: FutureResult
[17:00:35.436] result() for ClusterFuture ... done
[17:00:35.436] result() for ClusterFuture ...
[17:00:35.436] - result already collected: FutureResult
[17:00:35.436] result() for ClusterFuture ... done
[17:00:35.437] result() for ClusterFuture ...
[17:00:35.437] - result already collected: FutureResult
[17:00:35.437] result() for ClusterFuture ... done
[17:00:35.437] result() for ClusterFuture ...
[17:00:35.437] - result already collected: FutureResult
[17:00:35.437] result() for ClusterFuture ... done
[17:00:35.437] - relayed: [n=2] TRUE, FALSE
[17:00:35.437] - queued futures: [n=2] TRUE, FALSE
[17:00:35.437] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:00:35.437]  length: 1 (resolved future 1)
[17:00:35.465] receiveMessageFromWorker() for ClusterFuture ...
[17:00:35.465] - Validating connection of MultisessionFuture
[17:00:35.465] - received message: FutureResult
[17:00:35.466] - Received FutureResult
[17:00:35.466] - Erased future from FutureRegistry
[17:00:35.466] result() for ClusterFuture ...
[17:00:35.466] - result already collected: FutureResult
[17:00:35.466] result() for ClusterFuture ... done
[17:00:35.466] receiveMessageFromWorker() for ClusterFuture ... done
[17:00:35.466] Future #2
[17:00:35.466] result() for ClusterFuture ...
[17:00:35.466] - result already collected: FutureResult
[17:00:35.467] result() for ClusterFuture ... done
[17:00:35.467] result() for ClusterFuture ...
[17:00:35.467] - result already collected: FutureResult
[17:00:35.467] result() for ClusterFuture ... done
[17:00:35.467] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:00:35.467] - nx: 2
[17:00:35.467] - relay: TRUE
[17:00:35.467] - stdout: TRUE
[17:00:35.467] - signal: TRUE
[17:00:35.467] - resignal: FALSE
[17:00:35.467] - force: TRUE
[17:00:35.468] - relayed: [n=2] TRUE, FALSE
[17:00:35.468] - queued futures: [n=2] TRUE, FALSE
[17:00:35.468]  - until=2
[17:00:35.468]  - relaying element #2
[17:00:35.468] result() for ClusterFuture ...
[17:00:35.468] - result already collected: FutureResult
[17:00:35.468] result() for ClusterFuture ... done
[17:00:35.468] result() for ClusterFuture ...
[17:00:35.468] - result already collected: FutureResult
[17:00:35.468] result() for ClusterFuture ... done
[17:00:35.468] result() for ClusterFuture ...
[17:00:35.469] - result already collected: FutureResult
[17:00:35.469] result() for ClusterFuture ... done
[17:00:35.469] result() for ClusterFuture ...
[17:00:35.469] - result already collected: FutureResult
[17:00:35.469] result() for ClusterFuture ... done
[17:00:35.469] - relayed: [n=2] TRUE, TRUE
[17:00:35.469] - queued futures: [n=2] TRUE, TRUE
[17:00:35.469] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:00:35.469]  length: 0 (resolved future 2)
[17:00:35.469] Relaying remaining futures
[17:00:35.469] signalConditionsASAP(NULL, pos=0) ...
[17:00:35.470] - nx: 2
[17:00:35.470] - relay: TRUE
[17:00:35.470] - stdout: TRUE
[17:00:35.470] - signal: TRUE
[17:00:35.470] - resignal: FALSE
[17:00:35.470] - force: TRUE
[17:00:35.470] - relayed: [n=2] TRUE, TRUE
[17:00:35.470] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:00:35.470] - relayed: [n=2] TRUE, TRUE
[17:00:35.470] - queued futures: [n=2] TRUE, TRUE
[17:00:35.470] signalConditionsASAP(NULL, pos=0) ... done
[17:00:35.471] resolve() on list ... DONE
[17:00:35.471] result() for ClusterFuture ...
[17:00:35.471] - result already collected: FutureResult
[17:00:35.471] result() for ClusterFuture ... done
[17:00:35.471] result() for ClusterFuture ...
[17:00:35.471] - result already collected: FutureResult
[17:00:35.471] result() for ClusterFuture ... done
[17:00:35.471] result() for ClusterFuture ...
[17:00:35.471] - result already collected: FutureResult
[17:00:35.471] result() for ClusterFuture ... done
[17:00:35.471] result() for ClusterFuture ...
[17:00:35.472] - result already collected: FutureResult
[17:00:35.472] result() for ClusterFuture ... done
[17:00:35.472]  - Number of value chunks collected: 2
[17:00:35.472] Resolving 2 futures (chunks) ... DONE
[17:00:35.472] Reducing values from 2 chunks ...
[17:00:35.472]  - Number of values collected after concatenation: 2
[17:00:35.472]  - Number of values expected: 2
[17:00:35.472] Reducing values from 2 chunks ... DONE
[17:00:35.472] future_mapply() ... DONE
[17:00:35.473] plan(): Setting new future strategy stack:
[17:00:35.473] List of future strategies:
[17:00:35.473] 1. sequential:
[17:00:35.473]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:35.473]    - tweaked: FALSE
[17:00:35.473]    - call: plan(sequential)
[17:00:35.474] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[17:00:35.475] plan(): Setting new future strategy stack:
[17:00:35.475] List of future strategies:
[17:00:35.475] 1. FutureStrategy:
[17:00:35.475]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:00:35.475]    - tweaked: FALSE
[17:00:35.475]    - call: future::plan(oplan)
[17:00:35.476] plan(): nbrOfWorkers() = 1
> 
